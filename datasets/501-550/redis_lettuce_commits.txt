File: src/main/java/io/lettuce/core/output/KeyValueListOutput.java
Patch:
@@ -74,7 +74,7 @@ public void set(ByteBuffer bytes) {
     public void multi(int count) {
 
         if (!initialized) {
-            output = OutputFactory.newList(keys == null ? count / 2 : count);
+            output = OutputFactory.newList(count);
             initialized = true;
         }
     }

File: src/main/java/io/lettuce/core/RedisCommandBuilder.java
Patch:
@@ -2909,7 +2909,7 @@ Command<K, V, StringMatchResult> stralgoLcs(StrAlgoArgs strAlgoArgs) {
 
         CommandArgs<K, V> args = new CommandArgs<>(codec);
         strAlgoArgs.build(args);
-        return createCommand(STRALGO, new StringMatchResultOutput<>(codec, strAlgoArgs.isWithIdx()), args);
+        return createCommand(STRALGO, new StringMatchResultOutput<>(codec), args);
     }
 
     Command<K, V, Set<V>> sunion(K... keys) {

File: src/main/java/io/lettuce/core/dynamic/output/OutputRegistry.java
Patch:
@@ -56,6 +56,8 @@ public class OutputRegistry {
         register(registry, StringListOutput.class, StringListOutput::new);
         register(registry, VoidOutput.class, VoidOutput::new);
 
+        register(registry, StringMatchResultOutput.class, StringMatchResultOutput::new);
+
         BUILTIN.putAll(registry);
     }
 

File: src/main/java/io/lettuce/core/ScanIterator.java
Patch:
@@ -341,7 +341,7 @@ private ScoredValueScanCursor<V> getNextScanCursor(ScanCursor scanCursor) {
      * @return a {@link Stream} for this {@link ScanIterator}.
      */
     public Stream<T> stream() {
-        return StreamSupport.stream(Spliterators.spliterator(this, 0, 0), false);
+        return StreamSupport.stream(Spliterators.spliterator(this, -1, 0), false);
     }
 
     /**

File: src/main/java/io/lettuce/core/AbstractRedisReactiveCommands.java
Patch:
@@ -98,7 +98,7 @@ public abstract class AbstractRedisReactiveCommands<K, V>
 
     private final RedisJsonCommandBuilder<K, V> jsonCommandBuilder;
 
-    private final JsonParser parser;
+    private final Mono<JsonParser> parser;
 
     private final ClientResources clientResources;
 
@@ -112,7 +112,7 @@ public abstract class AbstractRedisReactiveCommands<K, V>
      * @param connection the connection to operate on.
      * @param codec the codec for command encoding.
      */
-    public AbstractRedisReactiveCommands(StatefulConnection<K, V> connection, RedisCodec<K, V> codec, JsonParser parser) {
+    public AbstractRedisReactiveCommands(StatefulConnection<K, V> connection, RedisCodec<K, V> codec, Mono<JsonParser> parser) {
         this.connection = connection;
         this.parser = parser;
         this.commandBuilder = new RedisCommandBuilder<>(codec);
@@ -139,7 +139,7 @@ private EventExecutorGroup getScheduler() {
 
     @Override
     public JsonParser getJsonParser() {
-        return parser;
+        return parser.block();
     }
 
     @Override

File: src/main/java/io/lettuce/core/RedisAsyncCommandsImpl.java
Patch:
@@ -5,6 +5,7 @@
 import io.lettuce.core.cluster.api.async.RedisClusterAsyncCommands;
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.json.JsonParser;
+import reactor.core.publisher.Mono;
 
 /**
  * An asynchronous and thread-safe API for a Redis connection.
@@ -23,7 +24,7 @@ public class RedisAsyncCommandsImpl<K, V> extends AbstractRedisAsyncCommands<K,
      * @param codec the codec for command encoding
      *
      */
-    public RedisAsyncCommandsImpl(StatefulRedisConnection<K, V> connection, RedisCodec<K, V> codec, JsonParser parser) {
+    public RedisAsyncCommandsImpl(StatefulRedisConnection<K, V> connection, RedisCodec<K, V> codec, Mono<JsonParser> parser) {
         super(connection, codec, parser);
     }
 

File: src/main/java/io/lettuce/core/RedisReactiveCommandsImpl.java
Patch:
@@ -5,6 +5,7 @@
 import io.lettuce.core.cluster.api.reactive.RedisClusterReactiveCommands;
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.json.JsonParser;
+import reactor.core.publisher.Mono;
 
 /**
  * A reactive and thread-safe API for a Redis Sentinel connection.
@@ -23,7 +24,8 @@ public class RedisReactiveCommandsImpl<K, V> extends AbstractRedisReactiveComman
      * @param codec the codec for command encoding.
      *
      */
-    public RedisReactiveCommandsImpl(StatefulRedisConnection<K, V> connection, RedisCodec<K, V> codec, JsonParser parser) {
+    public RedisReactiveCommandsImpl(StatefulRedisConnection<K, V> connection, RedisCodec<K, V> codec,
+            Mono<JsonParser> parser) {
         super(connection, codec, parser);
     }
 

File: src/main/java/io/lettuce/core/StatefulRedisConnectionImpl.java
Patch:
@@ -40,6 +40,7 @@
 import io.lettuce.core.output.MultiOutput;
 import io.lettuce.core.output.StatusOutput;
 import io.lettuce.core.protocol.*;
+import reactor.core.publisher.Mono;
 
 /**
  * A thread-safe connection to a Redis server. Multiple threads may share one {@link StatefulRedisConnectionImpl}
@@ -65,7 +66,7 @@ public class StatefulRedisConnectionImpl<K, V> extends RedisChannelHandler<K, V>
 
     private final PushHandler pushHandler;
 
-    private final JsonParser parser;
+    private final Mono<JsonParser> parser;
 
     protected MultiOutput<K, V> multi;
 
@@ -78,7 +79,7 @@ public class StatefulRedisConnectionImpl<K, V> extends RedisChannelHandler<K, V>
      * @param timeout Maximum time to wait for a response.
      */
     public StatefulRedisConnectionImpl(RedisChannelWriter writer, PushHandler pushHandler, RedisCodec<K, V> codec,
-            Duration timeout, JsonParser parser) {
+            Duration timeout, Mono<JsonParser> parser) {
 
         super(writer, timeout);
 

File: src/main/java/io/lettuce/core/cluster/RedisAdvancedClusterReactiveCommandsImpl.java
Patch:
@@ -77,11 +77,11 @@ public class RedisAdvancedClusterReactiveCommandsImpl<K, V> extends AbstractRedi
      * @param connection the stateful connection.
      * @param codec Codec used to encode/decode keys and values.
      * @deprecated since 5.2, use
-     *             {@link #RedisAdvancedClusterReactiveCommandsImpl(StatefulRedisClusterConnection, RedisCodec, JsonParser)}.
+     *             {@link #RedisAdvancedClusterReactiveCommandsImpl(StatefulRedisClusterConnection, RedisCodec, Mono)}.
      */
     @Deprecated
     public RedisAdvancedClusterReactiveCommandsImpl(StatefulRedisClusterConnectionImpl<K, V> connection, RedisCodec<K, V> codec,
-            JsonParser parser) {
+            Mono<JsonParser> parser) {
         super(connection, codec, parser);
         this.codec = codec;
     }
@@ -93,7 +93,7 @@ public RedisAdvancedClusterReactiveCommandsImpl(StatefulRedisClusterConnectionIm
      * @param codec Codec used to encode/decode keys and values.
      */
     public RedisAdvancedClusterReactiveCommandsImpl(StatefulRedisClusterConnection<K, V> connection, RedisCodec<K, V> codec,
-            JsonParser parser) {
+            Mono<JsonParser> parser) {
         super(connection, codec, parser);
         this.codec = codec;
     }

File: src/main/java/io/lettuce/core/cluster/StatefulRedisClusterConnectionImpl.java
Patch:
@@ -58,6 +58,7 @@
 import io.lettuce.core.protocol.ConnectionIntent;
 import io.lettuce.core.protocol.ConnectionWatchdog;
 import io.lettuce.core.protocol.RedisCommand;
+import reactor.core.publisher.Mono;
 
 /**
  * A thread-safe connection to a Redis Cluster. Multiple threads may share one {@link StatefulRedisClusterConnectionImpl}
@@ -75,7 +76,7 @@ public class StatefulRedisClusterConnectionImpl<K, V> extends RedisChannelHandle
 
     protected final RedisCodec<K, V> codec;
 
-    protected final JsonParser parser;
+    protected final Mono<JsonParser> parser;
 
     protected final RedisAdvancedClusterCommands<K, V> sync;
 
@@ -96,7 +97,7 @@ public class StatefulRedisClusterConnectionImpl<K, V> extends RedisChannelHandle
      * @param timeout Maximum time to wait for a response.
      */
     public StatefulRedisClusterConnectionImpl(RedisChannelWriter writer, ClusterPushHandler pushHandler, RedisCodec<K, V> codec,
-            Duration timeout, JsonParser parser) {
+            Duration timeout, Mono<JsonParser> parser) {
 
         super(writer, timeout);
         this.pushHandler = pushHandler;

File: src/main/java/io/lettuce/core/masterreplica/StatefulRedisMasterReplicaConnectionImpl.java
Patch:
@@ -6,6 +6,7 @@
 import io.lettuce.core.StatefulRedisConnectionImpl;
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.json.JsonParser;
+import reactor.core.publisher.Mono;
 
 /**
  * @author Mark Paluch
@@ -19,9 +20,10 @@ class StatefulRedisMasterReplicaConnectionImpl<K, V> extends StatefulRedisConnec
      * @param writer the channel writer
      * @param codec Codec used to encode/decode keys and values.
      * @param timeout Maximum time to wait for a response.
+     * @param parser the JSON parser to use
      */
     StatefulRedisMasterReplicaConnectionImpl(MasterReplicaChannelWriter writer, RedisCodec<K, V> codec, Duration timeout,
-            JsonParser parser) {
+            Mono<JsonParser> parser) {
         super(writer, NoOpPushHandler.INSTANCE, codec, timeout, parser);
     }
 

File: src/main/java/io/lettuce/core/sentinel/RedisSentinelReactiveCommandsImpl.java
Patch:
@@ -51,7 +51,8 @@ public class RedisSentinelReactiveCommandsImpl<K, V> extends AbstractRedisReacti
 
     private final SentinelCommandBuilder<K, V> commandBuilder;
 
-    public RedisSentinelReactiveCommandsImpl(StatefulConnection<K, V> connection, RedisCodec<K, V> codec, JsonParser parser) {
+    public RedisSentinelReactiveCommandsImpl(StatefulConnection<K, V> connection, RedisCodec<K, V> codec,
+            Mono<JsonParser> parser) {
         super(connection, codec, parser);
         commandBuilder = new SentinelCommandBuilder<K, V>(codec);
     }

File: src/main/java/io/lettuce/core/sentinel/StatefulRedisSentinelConnectionImpl.java
Patch:
@@ -34,6 +34,7 @@
 import io.lettuce.core.sentinel.api.async.RedisSentinelAsyncCommands;
 import io.lettuce.core.sentinel.api.reactive.RedisSentinelReactiveCommands;
 import io.lettuce.core.sentinel.api.sync.RedisSentinelCommands;
+import reactor.core.publisher.Mono;
 
 /**
  * @author Mark Paluch
@@ -52,7 +53,7 @@ public class StatefulRedisSentinelConnectionImpl<K, V> extends RedisChannelHandl
     private final SentinelConnectionState connectionState = new SentinelConnectionState();
 
     public StatefulRedisSentinelConnectionImpl(RedisChannelWriter writer, RedisCodec<K, V> codec, Duration timeout,
-            JsonParser parser) {
+            Mono<JsonParser> parser) {
 
         super(writer, timeout);
 

File: src/test/java/biz/paluch/redis/extensibility/MyExtendedRedisClusterClient.java
Patch:
@@ -31,6 +31,7 @@
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.json.JsonParser;
 import io.lettuce.core.resource.ClientResources;
+import reactor.core.publisher.Mono;
 
 /**
  * Demo code for extending a RedisClusterClient.
@@ -50,7 +51,7 @@ public MyExtendedRedisClusterClient() {
     @Override
     protected <V, K> StatefulRedisClusterConnectionImpl<K, V> newStatefulRedisClusterConnection(
             RedisChannelWriter channelWriter, ClusterPushHandler pushHandler, RedisCodec<K, V> codec, Duration timeout,
-            JsonParser parser) {
+            Mono<JsonParser> parser) {
         return new MyRedisClusterConnection<>(channelWriter, pushHandler, codec, timeout, parser);
     }
 

File: src/test/java/biz/paluch/redis/extensibility/MyRedisClusterConnection.java
Patch:
@@ -26,6 +26,7 @@
 import io.lettuce.core.cluster.StatefulRedisClusterConnectionImpl;
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.json.JsonParser;
+import reactor.core.publisher.Mono;
 
 /**
  * Demo code for extending a @{@link StatefulRedisClusterConnectionImpl}
@@ -36,7 +37,7 @@
 class MyRedisClusterConnection<K, V> extends StatefulRedisClusterConnectionImpl<K, V> {
 
     public MyRedisClusterConnection(RedisChannelWriter writer, ClusterPushHandler pushHandler, RedisCodec<K, V> codec,
-            Duration timeout, JsonParser parser) {
+            Duration timeout, Mono<JsonParser> parser) {
         super(writer, pushHandler, codec, timeout, parser);
     }
 

File: src/test/java/io/lettuce/core/RedisJsonCommandBuilderUnitTests.java
Patch:
@@ -19,6 +19,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import org.junit.jupiter.api.Test;
+import reactor.core.publisher.Mono;
 
 import java.nio.charset.StandardCharsets;
 import java.util.Collections;
@@ -39,13 +40,13 @@ class RedisJsonCommandBuilderUnitTests {
 
     public static final String ID_BIKE_6 = "{\"id\":\"bike6\"}";
 
-    public static final JsonParser PARSER = DefaultJsonParser.INSTANCE;
+    public static final JsonParser PARSER = new DefaultJsonParser();
 
     public static final JsonValue ELEMENT = PARSER.createJsonValue(ID_BIKE_6);
 
     public static final JsonPath MY_PATH = JsonPath.of("$..commuter_bikes");
 
-    RedisJsonCommandBuilder<String, String> builder = new RedisJsonCommandBuilder<>(StringCodec.UTF8, PARSER);
+    RedisJsonCommandBuilder<String, String> builder = new RedisJsonCommandBuilder<>(StringCodec.UTF8, Mono.just(PARSER));
 
     @Test
     void shouldCorrectlyConstructJsonArrappend() {

File: src/test/java/io/lettuce/core/json/DelegateJsonObjectUnitTests.java
Patch:
@@ -18,7 +18,7 @@ class DelegateJsonObjectUnitTests {
 
     @Test
     void put() {
-        DefaultJsonParser parser = DefaultJsonParser.INSTANCE;
+        DefaultJsonParser parser = new DefaultJsonParser();
         DelegateJsonObject underTest = new DelegateJsonObject();
 
         underTest.put("test", parser.createJsonValue("\"test\"")).put("test2", parser.createJsonValue("1")).put("test2",
@@ -31,7 +31,7 @@ void put() {
 
     @Test
     void remove() {
-        DefaultJsonParser parser = DefaultJsonParser.INSTANCE;
+        DefaultJsonParser parser = new DefaultJsonParser();
         DelegateJsonObject underTest = new DelegateJsonObject();
 
         underTest.put("test", parser.createJsonValue("\"test\"")).put("test2", parser.createJsonValue("1")).remove("test");

File: src/test/java/io/lettuce/core/json/RedisJsonIntegrationTests.java
Patch:
@@ -24,6 +24,7 @@
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.ValueSource;
+import reactor.core.publisher.Mono;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -579,7 +580,7 @@ void withCustomParser() {
         RedisURI redisURI = RedisURI.Builder.redis("127.0.0.1").withPort(16379).build();
 
         try (RedisClient client = RedisClient.create(redisURI)) {
-            client.setOptions(ClientOptions.builder().jsonParser(new CustomParser()).build());
+            client.setOptions(ClientOptions.builder().jsonParser(Mono.just(new CustomParser())).build());
             StatefulRedisConnection<String, String> connection = client.connect(StringCodec.UTF8);
             RedisCommands<String, String> redis = connection.sync();
             assertThat(redis.getJsonParser()).isInstanceOf(CustomParser.class);

File: src/test/java/io/lettuce/core/output/JsonValueListOutputUnitTests.java
Patch:
@@ -22,7 +22,7 @@ class JsonValueListOutputUnitTests {
 
     @Test
     void set() {
-        JsonValueListOutput<String, String> sut = new JsonValueListOutput<>(StringCodec.UTF8, DefaultJsonParser.INSTANCE);
+        JsonValueListOutput<String, String> sut = new JsonValueListOutput<>(StringCodec.UTF8, new DefaultJsonParser());
         sut.multi(2);
         sut.set(ByteBuffer.wrap("[1,2,3]".getBytes()));
         sut.set(ByteBuffer.wrap("world".getBytes()));

File: src/test/jmh/io/lettuce/core/dynamic/RedisCommandFactoryBenchmark.java
Patch:
@@ -12,6 +12,7 @@
 import io.lettuce.core.api.sync.RedisCommands;
 import io.lettuce.core.codec.StringCodec;
 import io.lettuce.core.dynamic.batch.BatchSize;
+import reactor.core.publisher.Mono;
 
 /**
  * Benchmark for commands executed through {@link RedisCommandFactory}.
@@ -31,7 +32,7 @@ public void setup() {
         redisCommandFactory = new RedisCommandFactory(new MockStatefulConnection(EmptyRedisChannelWriter.INSTANCE));
         regularCommands = redisCommandFactory.getCommands(RegularCommands.class);
 
-        asyncCommands = new RedisAsyncCommandsImpl<>(EmptyStatefulRedisConnection.INSTANCE, StringCodec.UTF8, DefaultJsonParser.INSTANCE);
+        asyncCommands = new RedisAsyncCommandsImpl<>(EmptyStatefulRedisConnection.INSTANCE, StringCodec.UTF8, Mono.just(new DefaultJsonParser()));
     }
 
     @Benchmark

File: src/main/java/io/lettuce/core/AclSetuserArgs.java
Patch:
@@ -606,7 +606,7 @@ public <K, V> void build(CommandArgs<K, V> args) {
 
         @Override
         public String toString() {
-            return getClass().getSimpleName() + ": " + value.name();
+            return getClass().getSimpleName() + ": " + value.toString();
         }
 
     }
@@ -716,7 +716,7 @@ public <K, V> void build(CommandArgs<K, V> args) {
             if (command.getSubCommand() == null) {
                 args.add("+" + command.getCommand().name());
             } else {
-                args.add("+" + command.getCommand().name() + "|" + command.getSubCommand().name());
+                args.add("+" + command.getCommand().name() + "|" + command.getSubCommand().toString());
             }
         }
 
@@ -735,7 +735,7 @@ public <K, V> void build(CommandArgs<K, V> args) {
             if (command.getSubCommand() == null) {
                 args.add("-" + command.getCommand().name());
             } else {
-                args.add("-" + command.getCommand().name() + "|" + command.getSubCommand().name());
+                args.add("-" + command.getCommand().name() + "|" + command.getSubCommand().toString());
             }
         }
 

File: src/main/java/io/lettuce/core/FutureSyncInvocationHandler.java
Patch:
@@ -107,8 +107,8 @@ private static boolean isTxControlMethod(String methodName, Object[] args) {
         if (methodName.equals("dispatch") && args.length > 0 && args[0] instanceof ProtocolKeyword) {
 
             ProtocolKeyword keyword = (ProtocolKeyword) args[0];
-            if (keyword.name().equals(CommandType.MULTI.name()) || keyword.name().equals(CommandType.EXEC.name())
-                    || keyword.name().equals(CommandType.DISCARD.name())) {
+            if (keyword.toString().equals(CommandType.MULTI.name()) || keyword.toString().equals(CommandType.EXEC.name())
+                    || keyword.toString().equals(CommandType.DISCARD.name())) {
                 return true;
             }
         }

File: src/main/java/io/lettuce/core/RedisAsyncCommandsImpl.java
Patch:
@@ -4,6 +4,7 @@
 import io.lettuce.core.api.async.RedisAsyncCommands;
 import io.lettuce.core.cluster.api.async.RedisClusterAsyncCommands;
 import io.lettuce.core.codec.RedisCodec;
+import io.lettuce.core.json.JsonParser;
 
 /**
  * An asynchronous and thread-safe API for a Redis connection.
@@ -22,8 +23,8 @@ public class RedisAsyncCommandsImpl<K, V> extends AbstractRedisAsyncCommands<K,
      * @param codec the codec for command encoding
      *
      */
-    public RedisAsyncCommandsImpl(StatefulRedisConnection<K, V> connection, RedisCodec<K, V> codec) {
-        super(connection, codec);
+    public RedisAsyncCommandsImpl(StatefulRedisConnection<K, V> connection, RedisCodec<K, V> codec, JsonParser parser) {
+        super(connection, codec, parser);
     }
 
     @Override

File: src/main/java/io/lettuce/core/RedisClient.java
Patch:
@@ -38,6 +38,7 @@
 import io.lettuce.core.internal.ExceptionFactory;
 import io.lettuce.core.internal.Futures;
 import io.lettuce.core.internal.LettuceAssert;
+import io.lettuce.core.json.JsonParser;
 import io.lettuce.core.masterreplica.MasterReplica;
 import io.lettuce.core.protocol.CommandExpiryWriter;
 import io.lettuce.core.protocol.CommandHandler;
@@ -656,7 +657,7 @@ protected <K, V> StatefulRedisPubSubConnectionImpl<K, V> newStatefulRedisPubSubC
      */
     protected <K, V> StatefulRedisSentinelConnectionImpl<K, V> newStatefulRedisSentinelConnection(
             RedisChannelWriter channelWriter, RedisCodec<K, V> codec, Duration timeout) {
-        return new StatefulRedisSentinelConnectionImpl<>(channelWriter, codec, timeout);
+        return new StatefulRedisSentinelConnectionImpl<>(channelWriter, codec, timeout, getOptions().getJsonParser());
     }
 
     /**
@@ -674,7 +675,7 @@ protected <K, V> StatefulRedisSentinelConnectionImpl<K, V> newStatefulRedisSenti
      */
     protected <K, V> StatefulRedisConnectionImpl<K, V> newStatefulRedisConnection(RedisChannelWriter channelWriter,
             PushHandler pushHandler, RedisCodec<K, V> codec, Duration timeout) {
-        return new StatefulRedisConnectionImpl<>(channelWriter, pushHandler, codec, timeout);
+        return new StatefulRedisConnectionImpl<>(channelWriter, pushHandler, codec, timeout, getOptions().getJsonParser());
     }
 
     /**

File: src/main/java/io/lettuce/core/RedisReactiveCommandsImpl.java
Patch:
@@ -4,6 +4,7 @@
 import io.lettuce.core.api.reactive.RedisReactiveCommands;
 import io.lettuce.core.cluster.api.reactive.RedisClusterReactiveCommands;
 import io.lettuce.core.codec.RedisCodec;
+import io.lettuce.core.json.JsonParser;
 
 /**
  * A reactive and thread-safe API for a Redis Sentinel connection.
@@ -22,8 +23,8 @@ public class RedisReactiveCommandsImpl<K, V> extends AbstractRedisReactiveComman
      * @param codec the codec for command encoding.
      *
      */
-    public RedisReactiveCommandsImpl(StatefulRedisConnection<K, V> connection, RedisCodec<K, V> codec) {
-        super(connection, codec);
+    public RedisReactiveCommandsImpl(StatefulRedisConnection<K, V> connection, RedisCodec<K, V> codec, JsonParser parser) {
+        super(connection, codec, parser);
     }
 
     @Override

File: src/main/java/io/lettuce/core/api/reactive/RedisReactiveCommands.java
Patch:
@@ -36,7 +36,7 @@ public interface RedisReactiveCommands<K, V> extends BaseRedisReactiveCommands<K
         RedisHashReactiveCommands<K, V>, RedisHLLReactiveCommands<K, V>, RedisKeyReactiveCommands<K, V>,
         RedisListReactiveCommands<K, V>, RedisScriptingReactiveCommands<K, V>, RedisServerReactiveCommands<K, V>,
         RedisSetReactiveCommands<K, V>, RedisSortedSetReactiveCommands<K, V>, RedisStreamReactiveCommands<K, V>,
-        RedisStringReactiveCommands<K, V>, RedisTransactionalReactiveCommands<K, V> {
+        RedisStringReactiveCommands<K, V>, RedisTransactionalReactiveCommands<K, V>, RedisJsonReactiveCommands<K, V> {
 
     /**
      * Authenticate to the server.

File: src/main/java/io/lettuce/core/cluster/ClusterDistributionChannelWriter.java
Patch:
@@ -141,13 +141,13 @@ private <K, V, T> RedisCommand<K, V, T> doWrite(RedisCommand<K, V, T> command) {
                     clusterEventListener.onMovedRedirection();
                     asking = false;
 
-                    publish(new MovedRedirectionEvent(clusterCommand.getType().name(), keyAsString, slot,
+                    publish(new MovedRedirectionEvent(clusterCommand.getType().toString(), keyAsString, slot,
                             clusterCommand.getError()));
                 } else {
                     target = getAskTarget(clusterCommand.getError());
                     asking = true;
                     clusterEventListener.onAskRedirection();
-                    publish(new AskRedirectionEvent(clusterCommand.getType().name(), keyAsString, slot,
+                    publish(new AskRedirectionEvent(clusterCommand.getType().toString(), keyAsString, slot,
                             clusterCommand.getError()));
                 }
 

File: src/main/java/io/lettuce/core/cluster/CommandSet.java
Patch:
@@ -59,7 +59,7 @@ public boolean hasCommand(ProtocolKeyword commandName) {
             return availableCommands.contains(commandName);
         }
 
-        return commands.containsKey(commandName.name().toLowerCase());
+        return commands.containsKey(commandName.toString().toLowerCase());
     }
 
 }

File: src/main/java/io/lettuce/core/dynamic/DefaultCommandMethodVerifier.java
Patch:
@@ -55,10 +55,10 @@ public DefaultCommandMethodVerifier(List<CommandDetail> commandDetails) {
     @Override
     public void validate(CommandSegments commandSegments, CommandMethod commandMethod) throws CommandMethodSyntaxException {
 
-        LettuceAssert.notEmpty(commandSegments.getCommandType().name(), "Command name must not be empty");
+        LettuceAssert.notEmpty(commandSegments.getCommandType().toString(), "Command name must not be empty");
 
-        CommandDetail commandDetail = findCommandDetail(commandSegments.getCommandType().name())
-                .orElseThrow(() -> syntaxException(commandSegments.getCommandType().name(), commandMethod));
+        CommandDetail commandDetail = findCommandDetail(commandSegments.getCommandType().toString())
+                .orElseThrow(() -> syntaxException(commandSegments.getCommandType().toString(), commandMethod));
 
         validateParameters(commandDetail, commandSegments, commandMethod);
     }

File: src/main/java/io/lettuce/core/masterreplica/AutodiscoveryConnector.java
Patch:
@@ -134,7 +134,7 @@ private Mono<StatefulRedisMasterReplicaConnection<K, V>> initializeConnection(Re
                     redisClient.getResources(), redisClient.getOptions());
 
             StatefulRedisMasterReplicaConnectionImpl<K, V> connection = new StatefulRedisMasterReplicaConnectionImpl<>(
-                    channelWriter, codec, redisURI.getTimeout());
+                    channelWriter, codec, redisURI.getTimeout(), redisClient.getOptions().getJsonParser());
 
             connection.setOptions(redisClient.getOptions());
 

File: src/main/java/io/lettuce/core/masterreplica/MasterReplicaChannelWriter.java
Patch:
@@ -271,11 +271,11 @@ private static boolean isSuccessfullyCompleted(CompletableFuture<?> connectFutur
     }
 
     private static boolean isStartTransaction(ProtocolKeyword command) {
-        return command.name().equals("MULTI");
+        return command.toString().equals("MULTI");
     }
 
     private boolean isEndTransaction(ProtocolKeyword command) {
-        return command.name().equals("EXEC") || command.name().equals("DISCARD");
+        return command.toString().equals("EXEC") || command.toString().equals("DISCARD");
     }
 
 }

File: src/main/java/io/lettuce/core/masterreplica/SentinelConnector.java
Patch:
@@ -98,7 +98,7 @@ public CompletableFuture<Void> closeAsync() {
         };
 
         StatefulRedisMasterReplicaConnectionImpl<K, V> connection = new StatefulRedisMasterReplicaConnectionImpl<>(
-                channelWriter, codec, redisURI.getTimeout());
+                channelWriter, codec, redisURI.getTimeout(), redisClient.getOptions().getJsonParser());
         connection.setOptions(redisClient.getOptions());
 
         CompletionStage<Void> bind = sentinelTopologyRefresh.bind(runnable);

File: src/main/java/io/lettuce/core/masterreplica/StaticMasterReplicaConnector.java
Patch:
@@ -90,7 +90,7 @@ private Mono<StatefulRedisMasterReplicaConnection<K, V>> initializeConnection(Re
                 redisClient.getResources(), redisClient.getOptions());
 
         StatefulRedisMasterReplicaConnectionImpl<K, V> connection = new StatefulRedisMasterReplicaConnectionImpl<>(
-                channelWriter, codec, seedNode.getTimeout());
+                channelWriter, codec, seedNode.getTimeout(), redisClient.getOptions().getJsonParser());
         connection.setOptions(redisClient.getOptions());
 
         return Mono.just(connection);

File: src/main/java/io/lettuce/core/metrics/CommandLatencyId.java
Patch:
@@ -31,7 +31,7 @@ protected CommandLatencyId(SocketAddress localAddress, SocketAddress remoteAddre
         this.localAddress = localAddress;
         this.remoteAddress = remoteAddress;
         this.commandType = commandType;
-        this.commandName = commandType.name();
+        this.commandName = commandType.toString();
     }
 
     /**

File: src/main/java/io/lettuce/core/metrics/MicrometerCommandLatencyRecorder.java
Patch:
@@ -115,7 +115,7 @@ protected Timer completionTimer(CommandLatencyId commandLatencyId) {
 
         Timer.Builder timer = Timer.builder(METRIC_COMPLETION)
                 .description("Latency between command send and command completion (complete response received")
-                .tag(LABEL_COMMAND, commandLatencyId.commandType().name())
+                .tag(LABEL_COMMAND, commandLatencyId.commandType().toString())
                 .tag(LABEL_LOCAL, commandLatencyId.localAddress().toString())
                 .tag(LABEL_REMOTE, commandLatencyId.remoteAddress().toString()).tags(options.tags());
 
@@ -131,7 +131,7 @@ protected Timer firstResponseTimer(CommandLatencyId commandLatencyId) {
 
         Timer.Builder timer = Timer.builder(METRIC_FIRST_RESPONSE)
                 .description("Latency between command send and first response (first response received)")
-                .tag(LABEL_COMMAND, commandLatencyId.commandType().name())
+                .tag(LABEL_COMMAND, commandLatencyId.commandType().toString())
                 .tag(LABEL_LOCAL, commandLatencyId.localAddress().toString())
                 .tag(LABEL_REMOTE, commandLatencyId.remoteAddress().toString()).tags(options.tags());
 

File: src/main/java/io/lettuce/core/metrics/MicrometerOptions.java
Patch:
@@ -217,7 +217,7 @@ public Builder enabledCommands(CommandType... commands) {
                 enabledCommands.add(enabledCommand.name());
             }
 
-            return metricsFilter(command -> enabledCommands.contains(command.getType().name()));
+            return metricsFilter(command -> enabledCommands.contains(command.getType().toString()));
         }
 
         /**

File: src/main/java/io/lettuce/core/protocol/CommandArgs.java
Patch:
@@ -441,7 +441,7 @@ static BytesArgument of(ProtocolKeyword protocolKeyword) {
 
         @Override
         public String toString() {
-            return protocolKeyword.name();
+            return protocolKeyword.toString();
         }
 
     }

File: src/main/java/io/lettuce/core/protocol/CommandHandler.java
Patch:
@@ -476,7 +476,7 @@ private void attachTracing(ChannelHandlerContext ctx, RedisCommand<?, ?, ?> comm
             TraceContext context = provider.getTraceContext();
 
             Tracer.Span span = tracer.nextSpan(context);
-            span.name(command.getType().name());
+            span.name(command.getType().toString());
 
             if (tracedEndpoint != null) {
                 span.remoteEndpoint(tracedEndpoint);

File: src/main/java/io/lettuce/core/protocol/CommandKeyword.java
Patch:
@@ -49,11 +49,11 @@ public enum CommandKeyword implements ProtocolKeyword {
 
     MIGRATING, IMPORTING, SAVE, SKIPME, SLAVES, STREAM, STORE, SUM, SEGFAULT, SETUSER, TAKEOVER, TRACKING, TRACKINGINFO, TYPE, UNBLOCK, USERS, USAGE, WEIGHTS, WHOAMI,
 
-    WITHSCORE, WITHSCORES, WITHVALUES, XOR, XX, YES;
+    WITHSCORE, WITHSCORES, WITHVALUES, XOR, XX, YES, INDENT, NEWLINE, SPACE;
 
     public final byte[] bytes;
 
-    private CommandKeyword() {
+    CommandKeyword() {
         bytes = name().getBytes(StandardCharsets.US_ASCII);
     }
 

File: src/main/java/io/lettuce/core/protocol/ProtocolKeyword.java
Patch:
@@ -17,6 +17,6 @@ public interface ProtocolKeyword {
      *
      * @return name of the command.
      */
-    String name();
+    String toString();
 
 }

File: src/main/java/io/lettuce/core/pubsub/PubSubCommandHandler.java
Patch:
@@ -213,7 +213,7 @@ protected void notifyPushListeners(PushMessage notification) {
 
     private boolean shouldCompleteCommand(PubSubOutput.Type type, RedisCommand<?, ?, ?> command) {
 
-        String commandType = command.getType().name();
+        String commandType = command.getType().toString();
         switch (type) {
             case subscribe:
                 return commandType.equalsIgnoreCase("SUBSCRIBE");

File: src/main/java/io/lettuce/core/pubsub/RedisPubSubAsyncCommandsImpl.java
Patch:
@@ -47,7 +47,7 @@ public class RedisPubSubAsyncCommandsImpl<K, V> extends RedisAsyncCommandsImpl<K
      * @param codec Codec used to encode/decode keys and values.
      */
     public RedisPubSubAsyncCommandsImpl(StatefulRedisPubSubConnection<K, V> connection, RedisCodec<K, V> codec) {
-        super(connection, codec);
+        super(connection, codec, null);
         this.commandBuilder = new PubSubCommandBuilder<>(codec);
     }
 

File: src/main/java/io/lettuce/core/pubsub/RedisPubSubReactiveCommandsImpl.java
Patch:
@@ -52,7 +52,7 @@ public class RedisPubSubReactiveCommandsImpl<K, V> extends RedisReactiveCommands
      * @param codec Codec used to encode/decode keys and values.
      */
     public RedisPubSubReactiveCommandsImpl(StatefulRedisPubSubConnection<K, V> connection, RedisCodec<K, V> codec) {
-        super(connection, codec);
+        super(connection, codec, null);
         this.commandBuilder = new PubSubCommandBuilder<>(codec);
     }
 

File: src/main/java/io/lettuce/core/pubsub/StatefulRedisPubSubConnectionImpl.java
Patch:
@@ -62,7 +62,7 @@ public class StatefulRedisPubSubConnectionImpl<K, V> extends StatefulRedisConnec
     public StatefulRedisPubSubConnectionImpl(PubSubEndpoint<K, V> endpoint, RedisChannelWriter writer, RedisCodec<K, V> codec,
             Duration timeout) {
 
-        super(writer, endpoint, codec, timeout);
+        super(writer, endpoint, codec, timeout, null);
         this.endpoint = endpoint;
         endpoint.setConnectionState(getConnectionState());
     }

File: src/main/java/io/lettuce/core/sentinel/RedisSentinelReactiveCommandsImpl.java
Patch:
@@ -28,6 +28,7 @@
 import io.lettuce.core.api.StatefulConnection;
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.internal.LettuceAssert;
+import io.lettuce.core.json.JsonParser;
 import io.lettuce.core.output.CommandOutput;
 import io.lettuce.core.protocol.Command;
 import io.lettuce.core.protocol.CommandArgs;
@@ -50,8 +51,8 @@ public class RedisSentinelReactiveCommandsImpl<K, V> extends AbstractRedisReacti
 
     private final SentinelCommandBuilder<K, V> commandBuilder;
 
-    public RedisSentinelReactiveCommandsImpl(StatefulConnection<K, V> connection, RedisCodec<K, V> codec) {
-        super(connection, codec);
+    public RedisSentinelReactiveCommandsImpl(StatefulConnection<K, V> connection, RedisCodec<K, V> codec, JsonParser parser) {
+        super(connection, codec, parser);
         commandBuilder = new SentinelCommandBuilder<K, V>(codec);
     }
 

File: src/main/java/io/lettuce/core/tracing/BraveTracing.java
Patch:
@@ -341,7 +341,7 @@ static class BraveSpan extends Tracer.Span {
         @Override
         public BraveSpan start(RedisCommand<?, ?, ?> command) {
 
-            span.name(command.getType().name());
+            span.name(command.getType().toString());
 
             if (includeCommandArgsInSpanTags && command.getArgs() != null) {
                 span.tag("redis.args", command.getArgs().toCommandString());

File: src/main/java/io/lettuce/core/tracing/DefaultLettuceObservationConvention.java
Patch:
@@ -30,7 +30,7 @@ public KeyValues getLowCardinalityKeyValues(LettuceObservationContext context) {
 
         Tracing.Endpoint ep = context.getRequiredEndpoint();
         KeyValues keyValues = KeyValues.of(LowCardinalityCommandKeyNames.DATABASE_SYSTEM.withValue("redis"), //
-                LowCardinalityCommandKeyNames.REDIS_COMMAND.withValue(context.getRequiredCommand().getType().name()));
+                LowCardinalityCommandKeyNames.REDIS_COMMAND.withValue(context.getRequiredCommand().getType().toString()));
 
         if (ep instanceof SocketAddressEndpoint) {
 
@@ -62,7 +62,7 @@ public KeyValues getHighCardinalityKeyValues(LettuceObservationContext context)
 
             if (command.getArgs() != null) {
                 return KeyValues.of(HighCardinalityCommandKeyNames.STATEMENT
-                        .withValue(command.getType().name() + " " + command.getArgs().toCommandString()));
+                        .withValue(command.getType().toString() + " " + command.getArgs().toCommandString()));
             }
         }
 
@@ -71,7 +71,7 @@ public KeyValues getHighCardinalityKeyValues(LettuceObservationContext context)
 
     @Override
     public String getContextualName(LettuceObservationContext context) {
-        return context.getRequiredCommand().getType().name().toLowerCase(Locale.ROOT);
+        return context.getRequiredCommand().getType().toString().toLowerCase(Locale.ROOT);
     }
 
     public boolean includeCommandArgsInSpanTags() {

File: src/test/java/biz/paluch/redis/extensibility/MyRedisClusterConnection.java
Patch:
@@ -25,6 +25,7 @@
 import io.lettuce.core.cluster.ClusterPushHandler;
 import io.lettuce.core.cluster.StatefulRedisClusterConnectionImpl;
 import io.lettuce.core.codec.RedisCodec;
+import io.lettuce.core.json.JsonParser;
 
 /**
  * Demo code for extending a @{@link StatefulRedisClusterConnectionImpl}
@@ -35,8 +36,8 @@
 class MyRedisClusterConnection<K, V> extends StatefulRedisClusterConnectionImpl<K, V> {
 
     public MyRedisClusterConnection(RedisChannelWriter writer, ClusterPushHandler pushHandler, RedisCodec<K, V> codec,
-            Duration timeout) {
-        super(writer, pushHandler, codec, timeout);
+            Duration timeout, JsonParser parser) {
+        super(writer, pushHandler, codec, timeout, parser);
     }
 
 }

File: src/test/java/io/lettuce/apigenerator/Constants.java
Patch:
@@ -29,7 +29,8 @@ class Constants {
     public static final String[] TEMPLATE_NAMES = { "BaseRedisCommands", "RedisAclCommands", "RedisFunctionCommands",
             "RedisGeoCommands", "RedisHashCommands", "RedisHLLCommands", "RedisKeyCommands", "RedisListCommands",
             "RedisScriptingCommands", "RedisSentinelCommands", "RedisServerCommands", "RedisSetCommands",
-            "RedisSortedSetCommands", "RedisStreamCommands", "RedisStringCommands", "RedisTransactionalCommands" };
+            "RedisSortedSetCommands", "RedisStreamCommands", "RedisStringCommands", "RedisTransactionalCommands",
+            "RedisJsonCommands" };
 
     public static final File TEMPLATES = new File("src/main/templates");
 

File: src/test/java/io/lettuce/core/cluster/ClusterReadOnlyCommandsUnitTests.java
Patch:
@@ -23,7 +23,7 @@ void testCount() {
     void testResolvableCommandNames() {
 
         for (ProtocolKeyword readOnlyCommand : ClusterReadOnlyCommands.getReadOnlyCommands()) {
-            assertThat(readOnlyCommand.name()).isEqualTo(CommandType.valueOf(readOnlyCommand.name()).name());
+            assertThat(readOnlyCommand.toString()).isEqualTo(CommandType.valueOf(readOnlyCommand.toString()).name());
         }
     }
 

File: src/test/java/io/lettuce/core/commands/ServerCommandIntegrationTests.java
Patch:
@@ -635,7 +635,7 @@ void clientSetinfo() {
     @Test
     void testReadOnlyCommands() {
         for (ProtocolKeyword readOnlyCommand : ClusterReadOnlyCommands.getReadOnlyCommands()) {
-            assertThat(isCommandReadOnly(readOnlyCommand.name())).isTrue();
+            assertThat(isCommandReadOnly(readOnlyCommand.toString())).isTrue();
         }
     }
 

File: src/test/java/io/lettuce/core/dynamic/CommandSegmentCommandFactoryUnitTests.java
Patch:
@@ -155,7 +155,7 @@ private String toString(RedisCommand<?, ?, ?> command) {
 
         StringBuilder builder = new StringBuilder();
 
-        builder.append(command.getType().name());
+        builder.append(command.getType().toString());
 
         String commandString = command.getArgs().toCommandString();
 

File: src/test/java/io/lettuce/core/metrics/CommandLatencyIdUnitTests.java
Patch:
@@ -54,7 +54,7 @@ public byte[] getBytes() {
         }
 
         @Override
-        public String name() {
+        public String toString() {
             return name;
         }
 

File: src/test/java/io/lettuce/core/tracing/BraveTracingUnitTests.java
Patch:
@@ -2,7 +2,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.List;
 import java.util.Queue;
 import java.util.concurrent.LinkedBlockingQueue;
 
@@ -14,7 +13,6 @@
 
 import io.lettuce.core.protocol.AsyncCommand;
 import zipkin2.Span;
-import brave.Tag;
 import brave.Tracer;
 import brave.Tracing;
 import brave.handler.MutableSpan;
@@ -102,7 +100,7 @@ void shouldCustomizeEndpoint() {
     void shouldCustomizeSpan() {
 
         BraveTracing tracing = BraveTracing.builder().tracing(clientTracing)
-                .spanCustomizer((command, span) -> span.tag("cmd", command.getType().name())).build();
+                .spanCustomizer((command, span) -> span.tag("cmd", command.getType().toString())).build();
 
         BraveTracing.BraveSpan span = (BraveTracing.BraveSpan) tracing.getTracerProvider().getTracer().nextSpan();
         span.start(new AsyncCommand<>(new Command<>(CommandType.AUTH, null)));

File: src/test/java/io/lettuce/test/CliParser.java
Patch:
@@ -54,11 +54,11 @@ public static Command<String, String, List<Object>> parse(String command) {
 
                     @Override
                     public byte[] getBytes() {
-                        return name().getBytes(StandardCharsets.UTF_8);
+                        return this.toString().getBytes(StandardCharsets.UTF_8);
                     }
 
                     @Override
-                    public String name() {
+                    public String toString() {
                         return typeName;
                     }
 

File: src/test/jmh/io/lettuce/core/dynamic/RedisCommandFactoryBenchmark.java
Patch:
@@ -1,5 +1,6 @@
 package io.lettuce.core.dynamic;
 
+import io.lettuce.core.json.DefaultJsonParser;
 import org.mockito.Mockito;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.Scope;
@@ -30,7 +31,7 @@ public void setup() {
         redisCommandFactory = new RedisCommandFactory(new MockStatefulConnection(EmptyRedisChannelWriter.INSTANCE));
         regularCommands = redisCommandFactory.getCommands(RegularCommands.class);
 
-        asyncCommands = new RedisAsyncCommandsImpl<>(EmptyStatefulRedisConnection.INSTANCE, StringCodec.UTF8);
+        asyncCommands = new RedisAsyncCommandsImpl<>(EmptyStatefulRedisConnection.INSTANCE, StringCodec.UTF8, DefaultJsonParser.INSTANCE);
     }
 
     @Benchmark

File: src/main/java/io/lettuce/core/ClientOptions.java
Patch:
@@ -67,7 +67,7 @@ public class ClientOptions implements Serializable {
 
     public static final boolean DEFAULT_SUSPEND_RECONNECT_PROTO_FAIL = false;
 
-    public static final TimeoutOptions DEFAULT_TIMEOUT_OPTIONS = TimeoutOptions.create();
+    public static final TimeoutOptions DEFAULT_TIMEOUT_OPTIONS = TimeoutOptions.enabled();
 
     private final boolean autoReconnect;
 

File: src/test/java/io/lettuce/core/reliability/AtLeastOnceTest.java
Patch:
@@ -8,6 +8,7 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 
+import io.lettuce.core.TimeoutOptions;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
@@ -44,7 +45,8 @@ class AtLeastOnceTest extends AbstractRedisClientTest {
 
     @BeforeEach
     void before() {
-        client.setOptions(ClientOptions.builder().autoReconnect(true).build());
+        client.setOptions(ClientOptions.builder().autoReconnect(true)
+                .timeoutOptions(TimeoutOptions.builder().timeoutCommands(false).build()).build());
 
         // needs to be increased on slow systems...perhaps...
         client.setDefaultTimeout(3, TimeUnit.SECONDS);

File: src/test/java/io/lettuce/core/reliability/AtMostOnceTest.java
Patch:
@@ -9,6 +9,7 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 
+import io.lettuce.core.TimeoutOptions;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
@@ -46,7 +47,8 @@ class AtMostOnceTest extends AbstractRedisClientTest {
 
     @BeforeEach
     void before() {
-        client.setOptions(ClientOptions.builder().autoReconnect(false).build());
+        client.setOptions(ClientOptions.builder().autoReconnect(false)
+                .timeoutOptions(TimeoutOptions.builder().timeoutCommands(false).build()).build());
 
         // needs to be increased on slow systems...perhaps...
         client.setDefaultTimeout(3, TimeUnit.SECONDS);

File: src/main/java/io/lettuce/core/pubsub/RedisPubSubReactiveCommandsImpl.java
Patch:
@@ -161,7 +161,7 @@ public Mono<Map<K, Long>> pubsubShardNumsub(K... shardChannels) {
 
     @Override
     public Mono<Long> spublish(K shardChannel, V message) {
-        return createMono(() -> commandBuilder.publish(shardChannel, message));
+        return createMono(() -> commandBuilder.spublish(shardChannel, message));
     }
 
     @Override

File: src/main/java/io/lettuce/core/protocol/ReadOnlyCommands.java
Patch:
@@ -71,7 +71,7 @@ public static ReadOnlyPredicate asPredicate() {
 
     enum CommandName {
         ASKING, BITCOUNT, BITPOS, CLIENT, COMMAND, DUMP, ECHO, EVAL_RO, EVALSHA_RO, EXISTS, FCALL_RO, //
-        GEODIST, GEOPOS, GEORADIUS, GEORADIUS_RO, GEORADIUSBYMEMBER, GEORADIUSBYMEMBER_RO, GEOSEARCH, GEOHASH, GET, GETBIT, //
+        GEODIST, GEOPOS, GEORADIUS_RO, GEORADIUSBYMEMBER_RO, GEOSEARCH, GEOHASH, GET, GETBIT, //
         GETRANGE, HEXISTS, HGET, HGETALL, HKEYS, HLEN, HMGET, HRANDFIELD, HSCAN, HSTRLEN, //
         HVALS, INFO, KEYS, LINDEX, LLEN, LPOS, LRANGE, SORT_RO, MGET, PFCOUNT, PTTL, //
         RANDOMKEY, READWRITE, SCAN, SCARD, SCRIPT, //

File: src/test/java/io/lettuce/core/cluster/ClusterReadOnlyCommandsUnitTests.java
Patch:
@@ -16,7 +16,7 @@ class ClusterReadOnlyCommandsUnitTests {
 
     @Test
     void testCount() {
-        assertThat(ClusterReadOnlyCommands.getReadOnlyCommands()).hasSize(86);
+        assertThat(ClusterReadOnlyCommands.getReadOnlyCommands()).hasSize(84);
     }
 
     @Test

File: src/test/java/io/lettuce/core/commands/HashCommandIntegrationTests.java
Patch:
@@ -560,7 +560,7 @@ void hexpire() {
         assertThat(redis.hexpire(MY_KEY, 0, MY_FIELD)).containsExactly(2L);
         assertThat(redis.hset(MY_KEY, MY_FIELD, MY_VALUE)).isTrue();
         assertThat(redis.hexpire(MY_KEY, 1, MY_FIELD, MY_SECOND_FIELD)).containsExactly(1L, -2L);
-        assertThat(redis.hexpire("invalidKey", 1, MY_FIELD)).isEmpty();
+        assertThat(redis.hexpire("invalidKey", 1, MY_FIELD)).containsExactly(-2L);
 
         await().until(() -> redis.hget(MY_KEY, MY_FIELD) == null);
     }
@@ -584,7 +584,7 @@ void hexpireat() {
         assertThat(redis.hexpireat(MY_KEY, Instant.now().minusSeconds(1), MY_FIELD)).containsExactly(2L);
         assertThat(redis.hset(MY_KEY, MY_FIELD, MY_VALUE)).isTrue();
         assertThat(redis.hexpireat(MY_KEY, Instant.now().plusSeconds(1), MY_FIELD)).containsExactly(1L);
-        assertThat(redis.hexpireat("invalidKey", Instant.now().plusSeconds(1), MY_FIELD)).isEmpty();
+        assertThat(redis.hexpireat("invalidKey", Instant.now().plusSeconds(1), MY_FIELD)).containsExactly(-2L);
 
         await().until(() -> redis.hget(MY_KEY, MY_FIELD) == null);
     }
@@ -609,7 +609,7 @@ void hexpiretime() {
     @Test
     @EnabledOnCommand("HPERSIST")
     void hpersist() {
-        assertThat(redis.hpersist(MY_KEY, MY_FIELD)).isEmpty();
+        assertThat(redis.hpersist(MY_KEY, MY_FIELD)).containsExactly(-2L);
 
         assertThat(redis.hset(MY_KEY, MY_FIELD, MY_VALUE)).isTrue();
         assertThat(redis.hpersist(MY_KEY, MY_FIELD)).containsExactly(-1L);

File: src/main/java/io/lettuce/core/KillArgs.java
Patch:
@@ -167,7 +167,7 @@ public static KillArgs user(String username) {
          *
          * @return new {@link KillArgs} with {@literal MAXAGE} set.
          * @see KillArgs#maxAge(Long)
-         * @since 7.0
+         * @since 6.4
          */
         public static KillArgs maxAge(Long maxAge) {
             return new KillArgs().maxAge(maxAge);
@@ -259,7 +259,7 @@ public KillArgs type(Type type) {
      *
      * @param maxAge must not be {@code null}.
      * @return {@code this} {@link KillArgs}.
-     * @since 7.0
+     * @since 6.4
      */
     public KillArgs maxAge(Long maxAge) {
 

File: src/main/java/io/lettuce/core/ScanIterator.java
Patch:
@@ -113,7 +113,7 @@ public static <K, V> ScanIterator<KeyValue<K, V>> hscan(RedisHashCommands<K, V>
      * @param <K> Key type.
      * @param <V> Value type.
      * @return a new {@link ScanIterator}.
-     * @since 7.0
+     * @since 6.4
      */
     public static <K, V> ScanIterator<K> hscanNovalues(RedisHashCommands<K, V> commands, K key) {
         return hscanNovalues(commands, key, Optional.empty());
@@ -147,7 +147,7 @@ public static <K, V> ScanIterator<KeyValue<K, V>> hscan(RedisHashCommands<K, V>
      * @param <K> Key type.
      * @param <V> Value type.
      * @return a new {@link ScanIterator}.
-     * @since 7.0
+     * @since 6.4
      */
     public static <K, V> ScanIterator<K> hscanNovalues(RedisHashCommands<K, V> commands, K key, ScanArgs scanArgs) {
 

File: src/main/java/io/lettuce/core/ScanStream.java
Patch:
@@ -114,7 +114,7 @@ public static <K, V> Flux<KeyValue<K, V>> hscan(RedisHashReactiveCommands<K, V>
      * @param <K> Key type.
      * @param <V> Value type.
      * @return a new {@link Flux}.
-     * @since 7.0
+     * @since 6.4
      */
     public static <K, V> Flux<K> hscanNovalues(RedisHashReactiveCommands<K, V> commands, K key) {
         return hscanNovalues(commands, key, Optional.empty());
@@ -148,7 +148,7 @@ public static <K, V> Flux<KeyValue<K, V>> hscan(RedisHashReactiveCommands<K, V>
      * @param <K> Key type.
      * @param <V> Value type.
      * @return a new {@link Flux}.
-     * @since 7.0
+     * @since 6.4
      */
     public static <K, V> Flux<K> hscanNovalues(RedisHashReactiveCommands<K, V> commands, K key, ScanArgs scanArgs) {
 

File: src/main/java/io/lettuce/core/XReadArgs.java
Patch:
@@ -189,7 +189,7 @@ public static <K> StreamOffset<K> latest(K name) {
          *
          * @param name must not be {@code null}.
          * @return the {@link StreamOffset} object without a specific offset.
-         * @since 7.0
+         * @since 6.4
          */
         public static <K> StreamOffset<K> last(K name) {
 

File: src/main/java/io/lettuce/core/api/async/BaseRedisAsyncCommands.java
Patch:
@@ -91,7 +91,7 @@ public interface BaseRedisAsyncCommands<K, V> {
      *
      * @param shardChannels channel keys.
      * @return array-reply a list of channels and number of subscribers for every channel.
-     * @since 7.0
+     * @since 6.4
      */
     RedisFuture<Map<K, Long>> pubsubShardNumsub(K... shardChannels);
 
@@ -108,7 +108,7 @@ public interface BaseRedisAsyncCommands<K, V> {
      * @param shardChannel the shard channel type: key.
      * @param message the message type: value.
      * @return Long integer-reply the number of clients that received the message.
-     * @since 7.0
+     * @since 6.4
      */
     RedisFuture<Long> spublish(K shardChannel, V message);
 

File: src/main/java/io/lettuce/core/api/async/RedisScriptingAsyncCommands.java
Patch:
@@ -94,7 +94,7 @@ public interface RedisScriptingAsyncCommands<K, V> {
      * @param values the values.
      * @param <T> expected return type.
      * @return script result.
-     * @since 7.0
+     * @since 6.4
      */
     <T> RedisFuture<T> evalReadOnly(String script, ScriptOutputType type, K[] keys, V... values);
 

File: src/main/java/io/lettuce/core/api/reactive/BaseRedisReactiveCommands.java
Patch:
@@ -91,7 +91,7 @@ public interface BaseRedisReactiveCommands<K, V> {
      *
      * @param shardChannels channel keys.
      * @return array-reply a list of channels and number of subscribers for every channel.
-     * @since 7.0
+     * @since 6.4
      */
     Mono<Map<K, Long>> pubsubShardNumsub(K... shardChannels);
 
@@ -108,7 +108,7 @@ public interface BaseRedisReactiveCommands<K, V> {
      * @param shardChannel the shard channel type: key.
      * @param message the message type: value.
      * @return Long integer-reply the number of clients that received the message.
-     * @since 7.0
+     * @since 6.4
      */
     Mono<Long> spublish(K shardChannel, V message);
 

File: src/main/java/io/lettuce/core/api/reactive/RedisScriptingReactiveCommands.java
Patch:
@@ -93,7 +93,7 @@ public interface RedisScriptingReactiveCommands<K, V> {
      * @param values the values.
      * @param <T> expected return type.
      * @return script result.
-     * @since 7.0
+     * @since 6.4
      */
     <T> Flux<T> evalReadOnly(String script, ScriptOutputType type, K[] keys, V... values);
 

File: src/main/java/io/lettuce/core/api/sync/BaseRedisCommands.java
Patch:
@@ -90,7 +90,7 @@ public interface BaseRedisCommands<K, V> {
      *
      * @param shardChannels channel keys.
      * @return array-reply a list of channels and number of subscribers for every channel.
-     * @since 7.0
+     * @since 6.4
      */
     Map<K, Long> pubsubShardNumsub(K... shardChannels);
 
@@ -107,7 +107,7 @@ public interface BaseRedisCommands<K, V> {
      * @param shardChannel the shard channel type: key.
      * @param message the message type: value.
      * @return Long integer-reply the number of clients that received the message.
-     * @since 7.0
+     * @since 6.4
      */
     Long spublish(K shardChannel, V message);
 

File: src/main/java/io/lettuce/core/api/sync/RedisScriptingCommands.java
Patch:
@@ -93,7 +93,7 @@ public interface RedisScriptingCommands<K, V> {
      * @param values the values.
      * @param <T> expected return type.
      * @return script result.
-     * @since 7.0
+     * @since 6.4
      */
     <T> T evalReadOnly(String script, ScriptOutputType type, K[] keys, V... values);
 

File: src/main/java/io/lettuce/core/cluster/api/async/BaseNodeSelectionAsyncCommands.java
Patch:
@@ -91,7 +91,7 @@ public interface BaseNodeSelectionAsyncCommands<K, V> {
      *
      * @param shardChannels channel keys.
      * @return array-reply a list of channels and number of subscribers for every channel.
-     * @since 7.0
+     * @since 6.4
      */
     AsyncExecutions<Map<K, Long>> pubsubShardNumsub(K... shardChannels);
 
@@ -108,7 +108,7 @@ public interface BaseNodeSelectionAsyncCommands<K, V> {
      * @param shardChannel the shard channel type: key.
      * @param message the message type: value.
      * @return Long integer-reply the number of clients that received the message.
-     * @since 7.0
+     * @since 6.4
      */
     AsyncExecutions<Long> spublish(K shardChannel, V message);
 

File: src/main/java/io/lettuce/core/cluster/api/async/NodeSelectionScriptingAsyncCommands.java
Patch:
@@ -93,7 +93,7 @@ public interface NodeSelectionScriptingAsyncCommands<K, V> {
      * @param values the values.
      * @param <T> expected return type.
      * @return script result.
-     * @since 7.0
+     * @since 6.4
      */
     <T> AsyncExecutions<T> evalReadOnly(String script, ScriptOutputType type, K[] keys, V... values);
 

File: src/main/java/io/lettuce/core/cluster/api/sync/BaseNodeSelectionCommands.java
Patch:
@@ -86,7 +86,7 @@ public interface BaseNodeSelectionCommands<K, V> {
      *
      * @param shardChannels channel keys.
      * @return array-reply a list of channels and number of subscribers for every channel.
-     * @since 7.0
+     * @since 6.4
      */
     Executions<Map<K, Long>> pubsubShardNumsub(K... shardChannels);
 
@@ -103,7 +103,7 @@ public interface BaseNodeSelectionCommands<K, V> {
      * @param shardChannel the shard channel type: key.
      * @param message the message type: value.
      * @return Long integer-reply the number of clients that received the message.
-     * @since 7.0
+     * @since 6.4
      */
     Executions<Long> spublish(K shardChannel, V message);
 

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionScriptingCommands.java
Patch:
@@ -93,7 +93,7 @@ public interface NodeSelectionScriptingCommands<K, V> {
      * @param values the values.
      * @param <T> expected return type.
      * @return script result.
-     * @since 7.0
+     * @since 6.4
      */
     <T> Executions<T> evalReadOnly(String script, ScriptOutputType type, K[] keys, V... values);
 

File: src/main/java/io/lettuce/core/cluster/pubsub/RedisClusterPubSubListener.java
Patch:
@@ -73,7 +73,7 @@ public interface RedisClusterPubSubListener<K, V> {
      * @param node the {@link RedisClusterNode} from which the {@code message} originates.
      * @param shardChannel shard channel.
      * @param message Message.
-     * @since 7.0
+     * @since 6.4
      */
     default void smessage(RedisClusterNode node, K shardChannel, V message) {
         message(node, shardChannel, message);
@@ -85,7 +85,7 @@ default void smessage(RedisClusterNode node, K shardChannel, V message) {
      * @param node the {@link RedisClusterNode} from which the {@code message} originates.
      * @param shardChannel Shard channel
      * @param count Subscription count.
-     * @since 7.0
+     * @since 6.4
      */
     default void ssubscribed(RedisClusterNode node, K shardChannel, long count) {
         subscribed(node, shardChannel, count);
@@ -97,7 +97,7 @@ default void ssubscribed(RedisClusterNode node, K shardChannel, long count) {
      * @param node the {@link RedisClusterNode} from which the {@code message} originates.
      * @param shardChannel Shard channel
      * @param count Subscription count.
-     * @since 7.0
+     * @since 6.4
      */
     default void sunsubscribed(RedisClusterNode node, K shardChannel, long count) {
         unsubscribed(node, shardChannel, count);

File: src/main/java/io/lettuce/core/cluster/pubsub/api/async/NodeSelectionPubSubAsyncCommands.java
Patch:
@@ -47,7 +47,7 @@ public interface NodeSelectionPubSubAsyncCommands<K, V> {
      *
      * @param shardChannels the channels
      * @return RedisFuture&lt;Void&gt; Future to synchronize {@code subscribe} completion
-     * @since 7.0
+     * @since 6.4
      */
     AsyncExecutions<Void> ssubscribe(K... shardChannels);
 
@@ -56,7 +56,7 @@ public interface NodeSelectionPubSubAsyncCommands<K, V> {
      *
      * @param shardChannels the channels
      * @return RedisFuture&lt;Void&gt; Future to synchronize {@code unsubscribe} completion.
-     * @since 7.0
+     * @since 6.4
      */
     AsyncExecutions<Void> sunsubscribe(K... shardChannels);
 

File: src/main/java/io/lettuce/core/cluster/pubsub/api/reactive/NodeSelectionPubSubReactiveCommands.java
Patch:
@@ -47,7 +47,7 @@ public interface NodeSelectionPubSubReactiveCommands<K, V> {
      *
      * @param shardCchannels the channels
      * @return RedisFuture&lt;Void&gt; Future to synchronize {@code subscribe} completion
-     * @since 7.0
+     * @since 6.4
      */
     ReactiveExecutions<Void> ssubscribe(K... shardCchannels);
 
@@ -56,7 +56,7 @@ public interface NodeSelectionPubSubReactiveCommands<K, V> {
      *
      * @param shardCchannels the channels
      * @return RedisFuture&lt;Void&gt; Future to synchronize {@code unsubscribe} completion.
-     * @since 7.0
+     * @since 6.4
      */
     ReactiveExecutions<Void> sunsubscribe(K... shardCchannels);
 

File: src/main/java/io/lettuce/core/cluster/pubsub/api/sync/NodeSelectionPubSubCommands.java
Patch:
@@ -47,7 +47,7 @@ public interface NodeSelectionPubSubCommands<K, V> {
      *
      * @param shardChannels the channels
      * @return Executions Future to synchronize {@code subscribe} completion
-     * @since 7.0
+     * @since 6.4
      */
     Executions<Void> ssubscribe(K... shardChannels);
 
@@ -56,7 +56,7 @@ public interface NodeSelectionPubSubCommands<K, V> {
      *
      * @param shardChannels the channels
      * @return Executions Future to synchronize {@code unsubscribe} completion.
-     * @since 7.0
+     * @since 6.4
      */
     Executions<Void> sunsubscribe(K... shardChannels);
 

File: src/main/java/io/lettuce/core/pubsub/RedisPubSubListener.java
Patch:
@@ -82,7 +82,7 @@ public interface RedisPubSubListener<K, V> {
      *
      * @param shardChannel Shard channel
      * @param count Subscription count.
-     * @since 7.0
+     * @since 6.4
      */
     default void ssubscribed(K shardChannel, long count) {
         subscribed(shardChannel, count);
@@ -93,7 +93,7 @@ default void ssubscribed(K shardChannel, long count) {
      *
      * @param shardChannel Channel
      * @param count Subscription count.
-     * @since 7.0
+     * @since 6.4
      */
     default void sunsubscribed(K shardChannel, long count) {
         unsubscribed(shardChannel, count);
@@ -104,7 +104,7 @@ default void sunsubscribed(K shardChannel, long count) {
      *
      * @param shardChannel shard channel.
      * @param message Message.
-     * @since 7.0
+     * @since 6.4
      */
     default void smessage(K shardChannel, V message) {
         message(shardChannel, message);

File: src/main/java/io/lettuce/core/pubsub/api/async/RedisPubSubAsyncCommands.java
Patch:
@@ -56,7 +56,7 @@ public interface RedisPubSubAsyncCommands<K, V> extends RedisAsyncCommands<K, V>
      *
      * @param shardChannels the shard channels
      * @return RedisFuture&lt;Void&gt; Future to synchronize {@code subscribe} completion
-     * @since 7.0
+     * @since 6.4
      */
     RedisFuture<Void> ssubscribe(K... shardChannels);
 
@@ -65,7 +65,7 @@ public interface RedisPubSubAsyncCommands<K, V> extends RedisAsyncCommands<K, V>
      *
      * @param shardChannels the shard channels
      * @return RedisFuture&lt;Void&gt; Future to synchronize {@code unsubscribe} completion.
-     * @since 7.0
+     * @since 6.4
      */
     RedisFuture<Void> sunsubscribe(K... shardChannels);
 

File: src/main/java/io/lettuce/core/pubsub/api/reactive/RedisPubSubReactiveCommands.java
Patch:
@@ -103,7 +103,7 @@ public interface RedisPubSubReactiveCommands<K, V> extends RedisReactiveCommands
      *
      * @param shardChannels the channels.
      * @return Mono&lt;Void&gt; Mono for {@code subscribe} command.
-     * @since 7.0
+     * @since 6.4
      */
     Mono<Void> ssubscribe(K... shardChannels);
 
@@ -113,7 +113,7 @@ public interface RedisPubSubReactiveCommands<K, V> extends RedisReactiveCommands
      *
      * @param shardChannels the channels.
      * @return Mono&lt;Void&gt; Mono for {@code unsubscribe} command.
-     * @since 7.0
+     * @since 6.4
      */
     Mono<Void> sunsubscribe(K... shardChannels);
 

File: src/main/java/io/lettuce/core/pubsub/api/sync/RedisPubSubCommands.java
Patch:
@@ -45,15 +45,15 @@ public interface RedisPubSubCommands<K, V> extends RedisCommands<K, V> {
      * Listen for messages published to the given shard channels.
      *
      * @param shardChannels the channels
-     * @since 7.0
+     * @since 6.4
      */
     void ssubscribe(K... shardChannels);
 
     /**
      * Stop listening for messages posted to the given channels.
      *
      * @param shardChannels the channels
-     * @since 7.0
+     * @since 6.4
      */
     void sunsubscribe(K... shardChannels);
 

File: src/main/templates/io/lettuce/core/api/BaseRedisCommands.java
Patch:
@@ -91,7 +91,7 @@ public interface BaseRedisCommands<K, V> {
      *
      * @param shardChannels channel keys.
      * @return array-reply a list of channels and number of subscribers for every channel.
-     * @since 7.0
+     * @since 6.4
      */
     Map<K, Long> pubsubShardNumsub(K... shardChannels);
 
@@ -108,7 +108,7 @@ public interface BaseRedisCommands<K, V> {
      * @param shardChannel the shard channel type: key.
      * @param message the message type: value.
      * @return Long integer-reply the number of clients that received the message.
-     * @since 7.0
+     * @since 6.4
      */
     Long spublish(K shardChannel, V message);
 

File: src/main/templates/io/lettuce/core/api/RedisScriptingCommands.java
Patch:
@@ -92,7 +92,7 @@ public interface RedisScriptingCommands<K, V> {
      * @param values the values.
      * @param <T> expected return type.
      * @return script result.
-     * @since 7.0
+     * @since 6.4
      */
     <T> T evalReadOnly(String script, ScriptOutputType type, K[] keys, V... values);
 

File: src/test/java/io/lettuce/core/commands/ScriptingCommandIntegrationTests.java
Patch:
@@ -134,7 +134,7 @@ void evalWithArgs() {
     @EnabledOnCommand("EVAL_RO") // Redis 7.0
     void evalReadOnly() {
         String[] keys = new String[] { "key1" };
-        assertThat((String) redis.evalReadOnly("return KEYS[1]".getBytes(), STATUS, keys, "a")).isEqualTo("key1");
+        assertThat((String) redis.evalReadOnly("return KEYS[1]", STATUS, keys, "a")).isEqualTo("key1");
     }
 
     @Test

File: src/main/java/io/lettuce/core/protocol/CommandKeyword.java
Patch:
@@ -37,7 +37,7 @@ public enum CommandKeyword implements ProtocolKeyword {
 
     BY, BYLEX, BYSCORE, CACHING, CAT, CH, CHANNELS, COPY, COUNT, COUNTKEYSINSLOT, CONSUMERS, CREATE, DB, DELSLOTS, DELSLOTSRANGE, DELUSER, DESC, DRYRUN, SOFT, HARD, ENCODING,
 
-    FAILOVER, FORGET, FLUSH, FORCE, FREQ, FLUSHSLOTS, GENPASS, GETNAME, GETUSER, GETKEYSINSLOT, GETREDIR, GROUP, GROUPS, HTSTATS, ID, IDLE, INFO,
+    FAILOVER, FORGET, FIELDS, FLUSH, FORCE, FREQ, FLUSHSLOTS, GENPASS, GETNAME, GETUSER, GETKEYSINSLOT, GETREDIR, GROUP, GROUPS, HTSTATS, ID, IDLE, INFO,
 
     IDLETIME, JUSTID, KILL, KEYSLOT, LEFT, LEN, LIMIT, LIST, LOAD, LOG, MATCH,
 

File: src/main/java/io/lettuce/core/protocol/CommandType.java
Patch:
@@ -46,7 +46,7 @@ public enum CommandType implements ProtocolKeyword {
 
     // Keys
 
-    COPY, DEL, DUMP, EXISTS, HEXPIRE, EXPIRE, HEXPIREAT, EXPIREAT, HEXPIRETIME, EXPIRETIME, KEYS, MIGRATE, MOVE, OBJECT, HPERSIST, PERSIST, PEXPIRE, PEXPIREAT, PEXPIRETIME, PTTL, RANDOMKEY, RENAME, RENAMENX, RESTORE, TOUCH, TTL, TYPE, SCAN, UNLINK,
+    COPY, DEL, DUMP, EXISTS, HEXPIRE, EXPIRE, HEXPIREAT, EXPIREAT, HEXPIRETIME, EXPIRETIME, KEYS, MIGRATE, MOVE, OBJECT, HPERSIST, PERSIST, PEXPIRE, HPEXPIRE, PEXPIREAT, HPEXPIREAT, PEXPIRETIME, HPEXPIRETIME, PTTL, HPTTL, RANDOMKEY, RENAME, RENAMENX, RESTORE, TOUCH, TTL, HTTL, TYPE, SCAN, UNLINK,
 
     // String
 

File: src/main/java/io/lettuce/core/AbstractRedisClient.java
Patch:
@@ -305,9 +305,8 @@ protected void channelType(ConnectionBuilder connectionBuilder, ConnectionPoint
         LettuceAssert.notNull(connectionPoint, "ConnectionPoint must not be null");
 
         boolean domainSocket = LettuceStrings.isNotEmpty(connectionPoint.getSocket());
-        connectionBuilder.bootstrap().group(
-                getEventLoopGroup(
-                        domainSocket ? NativeTransports.eventLoopGroupClass(true) : Transports.eventLoopGroupClass()));
+        connectionBuilder.bootstrap().group(getEventLoopGroup(
+                domainSocket ? NativeTransports.eventLoopGroupClass(true) : Transports.eventLoopGroupClass()));
 
         if (connectionPoint.getSocket() != null) {
             NativeTransports.assertDomainSocketAvailable();

File: src/main/java/io/lettuce/core/AbstractRedisReactiveCommands.java
Patch:
@@ -1357,7 +1357,7 @@ public Mono<StreamScanCursor> hscan(KeyValueStreamingChannel<K, V> channel, K ke
 
     @Override
     public Mono<StreamScanCursor> hscanNovalues(KeyStreamingChannel<K> channel, K key, ScanCursor scanCursor,
-                                                ScanArgs scanArgs) {
+            ScanArgs scanArgs) {
         return createMono(() -> commandBuilder.hscanNoValuesStreaming(channel, key, scanCursor, scanArgs));
     }
 
@@ -2151,7 +2151,7 @@ public Flux<V> spop(K key, long count) {
     public Mono<Long> spublish(K shardChannel, V message) {
         return createMono(() -> commandBuilder.spublish(shardChannel, message));
     }
-    
+
     @Override
     public Mono<V> srandmember(K key) {
         return createMono(() -> commandBuilder.srandmember(key));

File: src/main/java/io/lettuce/core/ChannelGroupListener.java
Patch:
@@ -67,4 +67,5 @@ private static String getRedisUri(Channel channel) {
     private static CommandHandler getCommandHandler(ChannelHandlerContext ctx) {
         return ctx.pipeline().get(CommandHandler.class);
     }
+
 }

File: src/main/java/io/lettuce/core/FlushMode.java
Patch:
@@ -51,4 +51,5 @@ public enum FlushMode implements ProtocolKeyword {
     public byte[] getBytes() {
         return bytes;
     }
+
 }

File: src/main/java/io/lettuce/core/GeoArgs.java
Patch:
@@ -266,6 +266,7 @@ public enum Unit implements ProtocolKeyword {
         public byte[] getBytes() {
             return asBytes;
         }
+
     }
 
     public <K, V> void build(CommandArgs<K, V> args) {

File: src/main/java/io/lettuce/core/KillArgs.java
Patch:
@@ -27,8 +27,8 @@
 
 /**
  *
- * Argument list builder for the Redis <a href="https://redis.io/commands/client-kill">CLIENT KILL</a> command. Static import the
- * methods from {@link Builder} and chain the method calls: {@code id(1).skipme()}.
+ * Argument list builder for the Redis <a href="https://redis.io/commands/client-kill">CLIENT KILL</a> command. Static import
+ * the methods from {@link Builder} and chain the method calls: {@code id(1).skipme()}.
  * <p>
  * {@link KillArgs} is a mutable object and instances should be used only once to avoid shared mutable state.
  *
@@ -159,6 +159,7 @@ public static KillArgs typeSlave() {
         public static KillArgs user(String username) {
             return new KillArgs().user(username);
         }
+
     }
 
     /**

File: src/main/java/io/lettuce/core/LMoveArgs.java
Patch:
@@ -89,10 +89,12 @@ public static LMoveArgs rightLeft() {
         public static LMoveArgs rightRight() {
             return new LMoveArgs(CommandKeyword.RIGHT, CommandKeyword.RIGHT);
         }
+
     }
 
     @Override
     public <K, V> void build(CommandArgs<K, V> args) {
         args.add(source).add(destination);
     }
+
 }

File: src/main/java/io/lettuce/core/MigrateArgs.java
Patch:
@@ -29,8 +29,8 @@
 import io.lettuce.core.protocol.CommandType;
 
 /**
- * Argument list builder for the Redis <a href="https://redis.io/commands/migrate">MIGRATE</a> command. Static import the methods
- * from {@link Builder} and chain the method calls: {@code copy().auth("foobar")}.
+ * Argument list builder for the Redis <a href="https://redis.io/commands/migrate">MIGRATE</a> command. Static import the
+ * methods from {@link Builder} and chain the method calls: {@code copy().auth("foobar")}.
  * <p>
  * {@link MigrateArgs} is a mutable object and instances should be used only once to avoid shared mutable state.
  *

File: src/main/java/io/lettuce/core/Range.java
Patch:
@@ -261,7 +261,6 @@ public int hashCode() {
             return Objects.hash(value, including);
         }
 
-
         @Override
         public String toString() {
 

File: src/main/java/io/lettuce/core/ReadFromImpl.java
Patch:
@@ -62,6 +62,7 @@ public List<RedisNodeDescription> select(Nodes nodes) {
 
             return Collections.emptyList();
         }
+
     }
 
     /**

File: src/main/java/io/lettuce/core/RedisChannelWriter.java
Patch:
@@ -69,8 +69,8 @@ public interface RedisChannelWriter extends Closeable, AsyncCloseable {
     void setConnectionFacade(ConnectionFacade connection);
 
     /**
-     * Disable or enable auto-flush behavior. Default is {@code true}. If autoFlushCommands is disabled, multiple commands
-     * can be issued without writing them actually to the transport. Commands are buffered until a {@link #flushCommands()} is
+     * Disable or enable auto-flush behavior. Default is {@code true}. If autoFlushCommands is disabled, multiple commands can
+     * be issued without writing them actually to the transport. Commands are buffered until a {@link #flushCommands()} is
      * issued. After calling {@link #flushCommands()} commands are sent to the transport and executed by Redis.
      *
      * @param autoFlush state of autoFlush.

File: src/main/java/io/lettuce/core/RedisCommandBuilder.java
Patch:
@@ -1689,7 +1689,7 @@ Command<K, V, StreamScanCursor> hscanStreaming(KeyValueStreamingChannel<K, V> ch
     }
 
     Command<K, V, StreamScanCursor> hscanNoValuesStreaming(KeyStreamingChannel<K> channel, K key, ScanCursor scanCursor,
-                                                           ScanArgs scanArgs) {
+            ScanArgs scanArgs) {
         notNullKey(key);
         notNull(channel);
 

File: src/main/java/io/lettuce/core/RedisPublisher.java
Patch:
@@ -414,7 +414,8 @@ void potentiallyReadMore() {
 
             /*
              * getDemand() maybe is Long.MAX_VALUE，because MonoNext.NextSubscriber#request(long n) inner use the Long.MAX_VALUE,
-             * so maybe "getDemand() + 1" will be overflow，we use "getDemand() > data.size() - 1" replace the "(getDemand() + 1) > data.size()"
+             * so maybe "getDemand() + 1" will be overflow，we use "getDemand() > data.size() - 1" replace the
+             * "(getDemand() + 1) > data.size()"
              */
             if (getDemand() > data.size() - 1) {
                 state().readData(this);

File: src/main/java/io/lettuce/core/RestoreArgs.java
Patch:
@@ -27,8 +27,8 @@
 import io.lettuce.core.protocol.CommandArgs;
 
 /**
- * Argument list builder for the Redis <a href="https://redis.io/commands/restore">RESTORE</a> command. Static import the methods
- * from {@link RestoreArgs.Builder} and call the methods: {@code ttl(…)} .
+ * Argument list builder for the Redis <a href="https://redis.io/commands/restore">RESTORE</a> command. Static import the
+ * methods from {@link RestoreArgs.Builder} and call the methods: {@code ttl(…)} .
  * <p>
  * {@link RestoreArgs} is a mutable object and instances should be used only once to avoid shared mutable state.
  *
@@ -199,4 +199,5 @@ public <K, V> void build(CommandArgs<K, V> args) {
             args.add(FREQ).add(frequency);
         }
     }
+
 }

File: src/main/java/io/lettuce/core/ScanIterator.java
Patch:
@@ -185,8 +185,7 @@ private MapScanCursor<K, V> getNextScanCursor(ScanCursor scanCursor) {
         };
     }
 
-    private static <K, V> ScanIterator<K> hscanNovalues(RedisHashCommands<K, V> commands, K key,
-            Optional<ScanArgs> scanArgs) {
+    private static <K, V> ScanIterator<K> hscanNovalues(RedisHashCommands<K, V> commands, K key, Optional<ScanArgs> scanArgs) {
 
         LettuceAssert.notNull(commands, "RedisKeyCommands must not be null");
         LettuceAssert.notNull(key, "Key must not be null");
@@ -204,7 +203,8 @@ protected ScanCursor nextScanCursor(ScanCursor scanCursor) {
             private KeyScanCursor<K> getNextScanCursor(ScanCursor scanCursor) {
 
                 if (scanCursor == null) {
-                    return scanArgs.map(scanArgs -> commands.hscanNovalues(key, scanArgs)).orElseGet(() -> commands.hscanNovalues(key));
+                    return scanArgs.map(scanArgs -> commands.hscanNovalues(key, scanArgs))
+                            .orElseGet(() -> commands.hscanNovalues(key));
                 }
 
                 return scanArgs.map((scanArgs) -> commands.hscanNovalues(key, scanCursor, scanArgs))

File: src/main/java/io/lettuce/core/ScanStream.java
Patch:
@@ -177,8 +177,7 @@ private static <K, V> Flux<KeyValue<K, V>> hscan(RedisHashReactiveCommands<K, V>
                 });
     }
 
-    private static <K, V> Flux<K> hscanNovalues(RedisHashReactiveCommands<K, V> commands, K key,
-            Optional<ScanArgs> scanArgs) {
+    private static <K, V> Flux<K> hscanNovalues(RedisHashReactiveCommands<K, V> commands, K key, Optional<ScanArgs> scanArgs) {
 
         LettuceAssert.notNull(commands, "RedisHashReactiveCommands must not be null");
         LettuceAssert.notNull(key, "Key must not be null");

File: src/main/java/io/lettuce/core/SetArgs.java
Patch:
@@ -29,8 +29,8 @@
 import io.lettuce.core.protocol.CommandArgs;
 
 /**
- * Argument list builder for the Redis <a href="https://redis.io/commands/set">SET</a> command starting from Redis 2.6.12. Static
- * import the methods from {@link Builder} and chain the method calls: {@code ex(10).nx()}.
+ * Argument list builder for the Redis <a href="https://redis.io/commands/set">SET</a> command starting from Redis 2.6.12.
+ * Static import the methods from {@link Builder} and chain the method calls: {@code ex(10).nx()}.
  * <p>
  * {@link SetArgs} is a mutable object and instances should be used only once to avoid shared mutable state.
  *

File: src/main/java/io/lettuce/core/ShutdownArgs.java
Patch:
@@ -91,6 +91,7 @@ public static ShutdownArgs force() {
         public static ShutdownArgs abort() {
             return new ShutdownArgs().abort();
         }
+
     }
 
     /**

File: src/main/java/io/lettuce/core/StrAlgoArgs.java
Patch:
@@ -26,8 +26,8 @@
 import io.lettuce.core.protocol.CommandArgs;
 
 /**
- * Argument list builder for the Redis <a href="https://redis.io/commands/stralgo">STRALGO</a> command. Static import the methods
- * from {@link StrAlgoArgs.Builder} and call the methods: {@code keys(…)} .
+ * Argument list builder for the Redis <a href="https://redis.io/commands/stralgo">STRALGO</a> command. Static import the
+ * methods from {@link StrAlgoArgs.Builder} and call the methods: {@code keys(…)} .
  * <p>
  * {@link StrAlgoArgs} is a mutable object and instances should be used only once to avoid shared mutable state.
  *

File: src/main/java/io/lettuce/core/XAutoClaimArgs.java
Patch:
@@ -212,4 +212,5 @@ public <K, V> void build(CommandArgs<K, V> args) {
             args.add(CommandKeyword.JUSTID);
         }
     }
+
 }

File: src/main/java/io/lettuce/core/XTrimArgs.java
Patch:
@@ -24,8 +24,8 @@
 import io.lettuce.core.protocol.CommandKeyword;
 
 /**
- * Argument list builder for the Redis <a href="https://redis.io/commands/xadd">XTRIM</a> command. Static import the methods from
- * {@link Builder} and call the methods: {@code maxlen(…)} .
+ * Argument list builder for the Redis <a href="https://redis.io/commands/xadd">XTRIM</a> command. Static import the methods
+ * from {@link Builder} and call the methods: {@code maxlen(…)} .
  * <p>
  * {@link XTrimArgs} is a mutable object and instances should be used only once to avoid shared mutable state.
  *
@@ -76,6 +76,7 @@ public static XTrimArgs maxlen(long count) {
         public static XTrimArgs minId(String minid) {
             return new XTrimArgs().minId(minid);
         }
+
     }
 
     /**

File: src/main/java/io/lettuce/core/api/StatefulConnection.java
Patch:
@@ -114,8 +114,8 @@ public interface StatefulConnection<K, V> extends AutoCloseable, AsyncCloseable
     void reset();
 
     /**
-     * Disable or enable auto-flush behavior. Default is {@code true}. If autoFlushCommands is disabled, multiple commands
-     * can be issued without writing them actually to the transport. Commands are buffered until a {@link #flushCommands()} is
+     * Disable or enable auto-flush behavior. Default is {@code true}. If autoFlushCommands is disabled, multiple commands can
+     * be issued without writing them actually to the transport. Commands are buffered until a {@link #flushCommands()} is
      * issued. After calling {@link #flushCommands()} commands are sent to the transport and executed by Redis.
      *
      * @param autoFlush state of autoFlush.

File: src/main/java/io/lettuce/core/api/async/RedisHLLAsyncCommands.java
Patch:
@@ -61,4 +61,5 @@ public interface RedisHLLAsyncCommands<K, V> {
      *         The approximated number of unique elements observed via {@code PFADD}.
      */
     RedisFuture<Long> pfcount(K... keys);
+
 }

File: src/main/java/io/lettuce/core/api/async/RedisScriptingAsyncCommands.java
Patch:
@@ -202,4 +202,5 @@ public interface RedisScriptingAsyncCommands<K, V> {
      * @since 6.0
      */
     String digest(byte[] script);
+
 }

File: src/main/java/io/lettuce/core/api/async/RedisSetAsyncCommands.java
Patch:
@@ -342,4 +342,5 @@ public interface RedisSetAsyncCommands<K, V> {
      * @return StreamScanCursor scan cursor.
      */
     RedisFuture<StreamScanCursor> sscan(ValueStreamingChannel<V> channel, K key, ScanCursor scanCursor);
+
 }

File: src/main/java/io/lettuce/core/api/async/RedisStreamAsyncCommands.java
Patch:
@@ -368,4 +368,5 @@ public interface RedisStreamAsyncCommands<K, V> {
      * @since 6.1
      */
     RedisFuture<Long> xtrim(K key, XTrimArgs args);
+
 }

File: src/main/java/io/lettuce/core/api/async/RedisStringAsyncCommands.java
Patch:
@@ -433,4 +433,5 @@ public interface RedisStringAsyncCommands<K, V> {
      * @return Long integer-reply the length of the string at {@code key}, or {@code 0} when {@code key} does not exist.
      */
     RedisFuture<Long> strlen(K key);
+
 }

File: src/main/java/io/lettuce/core/api/async/RedisTransactionalAsyncCommands.java
Patch:
@@ -72,4 +72,5 @@ public interface RedisTransactionalAsyncCommands<K, V> {
      * @return String simple-string-reply always {@code OK}.
      */
     RedisFuture<String> unwatch();
+
 }

File: src/main/java/io/lettuce/core/api/reactive/BaseRedisReactiveCommands.java
Patch:
@@ -79,7 +79,7 @@ public interface BaseRedisReactiveCommands<K, V> {
     Flux<K> pubsubShardChannels();
 
     /**
-     * Lists the currently *active shard channels*.     
+     * Lists the currently *active shard channels*.
      * 
      * @param pattern the pattern type: patternkey (pattern).
      * @return K array-reply a list of active channels, optionally matching the specified pattern.
@@ -123,8 +123,8 @@ public interface BaseRedisReactiveCommands<K, V> {
     /**
      * Return the role of the instance in the context of replication.
      *
-     * @return Object array-reply where the first element is one of master, slave, sentinel and the additional
-     *         elements are role-specific.
+     * @return Object array-reply where the first element is one of master, slave, sentinel and the additional elements are
+     *         role-specific.
      */
     Flux<Object> role();
 

File: src/main/java/io/lettuce/core/api/reactive/RedisHLLReactiveCommands.java
Patch:
@@ -42,4 +42,5 @@ public interface RedisHLLReactiveCommands<K, V> {
      *         The approximated number of unique elements observed via {@code PFADD}.
      */
     Mono<Long> pfcount(K... keys);
+
 }

File: src/main/java/io/lettuce/core/api/reactive/RedisStreamReactiveCommands.java
Patch:
@@ -369,4 +369,5 @@ public interface RedisStreamReactiveCommands<K, V> {
      * @since 6.1
      */
     Mono<Long> xtrim(K key, XTrimArgs args);
+
 }

File: src/main/java/io/lettuce/core/api/reactive/RedisStringReactiveCommands.java
Patch:
@@ -296,7 +296,8 @@ public interface RedisStringReactiveCommands<K, V> {
      * @param channel the channel.
      * @param keys the keys.
      * @return Long array-reply list of values at the specified keys.
-     * @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #mget}.
+     * @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by
+     *             {@link #mget}.
      */
     @Deprecated
     Mono<Long> mget(KeyValueStreamingChannel<K, V> channel, K... keys);
@@ -436,4 +437,5 @@ public interface RedisStringReactiveCommands<K, V> {
      * @return Long integer-reply the length of the string at {@code key}, or {@code 0} when {@code key} does not exist.
      */
     Mono<Long> strlen(K key);
+
 }

File: src/main/java/io/lettuce/core/api/reactive/RedisTransactionalReactiveCommands.java
Patch:
@@ -53,4 +53,5 @@ public interface RedisTransactionalReactiveCommands<K, V> {
      * @return String simple-string-reply always {@code OK}.
      */
     Mono<String> unwatch();
+
 }

File: src/main/java/io/lettuce/core/api/sync/BaseRedisCommands.java
Patch:
@@ -76,15 +76,15 @@ public interface BaseRedisCommands<K, V> {
      * @return List&lt;K&gt; array-reply a list of active channels.
      */
     List<K> pubsubShardChannels();
-    
+
     /**
      * Lists the currently *active shard channels*.
      *
      * @param pattern the pattern type: patternkey (pattern).
      * @return List&lt;K&gt; array-reply a list of active channels, optionally matching the specified pattern.
      */
     List<K> pubsubShardChannels(K pattern);
-    
+
     /**
      * Returns the number of subscribers (not counting clients subscribed to patterns) for the specified shard channels.
      *
@@ -204,4 +204,5 @@ public interface BaseRedisCommands<K, V> {
      */
     @Deprecated
     void reset();
+
 }

File: src/main/java/io/lettuce/core/api/sync/RedisHLLCommands.java
Patch:
@@ -59,4 +59,5 @@ public interface RedisHLLCommands<K, V> {
      *         The approximated number of unique elements observed via {@code PFADD}.
      */
     Long pfcount(K... keys);
+
 }

File: src/main/java/io/lettuce/core/api/sync/RedisHashCommands.java
Patch:
@@ -582,4 +582,5 @@ public interface RedisHashCommands<K, V> {
      *         associated timeout.
      */
     Boolean hpersist(K key, K... fields);
+
 }

File: src/main/java/io/lettuce/core/api/sync/RedisScriptingCommands.java
Patch:
@@ -201,4 +201,5 @@ public interface RedisScriptingCommands<K, V> {
      * @since 6.0
      */
     String digest(byte[] script);
+
 }

File: src/main/java/io/lettuce/core/api/sync/RedisSetCommands.java
Patch:
@@ -341,4 +341,5 @@ public interface RedisSetCommands<K, V> {
      * @return StreamScanCursor scan cursor.
      */
     StreamScanCursor sscan(ValueStreamingChannel<V> channel, K key, ScanCursor scanCursor);
+
 }

File: src/main/java/io/lettuce/core/api/sync/RedisStreamCommands.java
Patch:
@@ -368,4 +368,5 @@ public interface RedisStreamCommands<K, V> {
      * @since 6.1
      */
     Long xtrim(K key, XTrimArgs args);
+
 }

File: src/main/java/io/lettuce/core/api/sync/RedisStringCommands.java
Patch:
@@ -432,4 +432,5 @@ public interface RedisStringCommands<K, V> {
      * @return Long integer-reply the length of the string at {@code key}, or {@code 0} when {@code key} does not exist.
      */
     Long strlen(K key);
+
 }

File: src/main/java/io/lettuce/core/api/sync/RedisTransactionalCommands.java
Patch:
@@ -71,4 +71,5 @@ public interface RedisTransactionalCommands<K, V> {
      * @return String simple-string-reply always {@code OK}.
      */
     String unwatch();
+
 }

File: src/main/java/io/lettuce/core/cluster/DynamicNodeSelection.java
Patch:
@@ -50,7 +50,7 @@ class DynamicNodeSelection<API, CMD, K, V> extends AbstractNodeSelection<API, CM
     private final Function<StatefulRedisConnection<K, V>, API> apiExtractor;
 
     public DynamicNodeSelection(ClusterDistributionChannelWriter writer, Predicate<RedisClusterNode> selector,
-                                ConnectionIntent connectionIntent, Function<StatefulRedisConnection<K, V>, API> apiExtractor) {
+            ConnectionIntent connectionIntent, Function<StatefulRedisConnection<K, V>, API> apiExtractor) {
 
         this.selector = selector;
         this.connectionIntent = connectionIntent;

File: src/main/java/io/lettuce/core/cluster/RedisClusterClient.java
Patch:
@@ -684,7 +684,8 @@ private <K, V> CompletableFuture<StatefulRedisClusterConnection<K, V>> connectCl
                     .onErrorResume(t -> connect(socketAddressSupplier, endpoint, connection, commandHandlerSupplier));
         }
 
-        return connectionMono.doOnNext(
+        return connectionMono
+                .doOnNext(
                         c -> connection.registerCloseables(closeableResources, clusterWriter, pooledClusterConnectionProvider))
                 .map(it -> (StatefulRedisClusterConnection<K, V>) it).toFuture();
     }

File: src/main/java/io/lettuce/core/cluster/StaticNodeSelection.java
Patch:
@@ -50,7 +50,7 @@ class StaticNodeSelection<API, CMD, K, V> extends AbstractNodeSelection<API, CMD
     private final Function<StatefulRedisConnection<K, V>, API> apiExtractor;
 
     public StaticNodeSelection(ClusterDistributionChannelWriter writer, Predicate<RedisClusterNode> selector,
-                               ConnectionIntent connectionIntent, Function<StatefulRedisConnection<K, V>, API> apiExtractor) {
+            ConnectionIntent connectionIntent, Function<StatefulRedisConnection<K, V>, API> apiExtractor) {
 
         this.writer = writer;
         this.connectionIntent = connectionIntent;

File: src/main/java/io/lettuce/core/cluster/api/async/BaseNodeSelectionAsyncCommands.java
Patch:
@@ -78,7 +78,7 @@ public interface BaseNodeSelectionAsyncCommands<K, V> {
      */
     AsyncExecutions<List<K>> pubsubShardChannels();
 
-        /**
+    /**
      * Lists the currently *active shard channels*.
      *
      * @param pattern the pattern type: patternkey (pattern).
@@ -203,4 +203,5 @@ public interface BaseNodeSelectionAsyncCommands<K, V> {
      */
     <T> AsyncExecutions<T> dispatch(ProtocolKeyword type, Supplier<CommandOutput<K, V, T>> outputSupplier,
             CommandArgs<K, V> args);
+
 }

File: src/main/java/io/lettuce/core/cluster/api/async/NodeSelectionHLLAsyncCommands.java
Patch:
@@ -59,4 +59,5 @@ public interface NodeSelectionHLLAsyncCommands<K, V> {
      *         The approximated number of unique elements observed via {@code PFADD}.
      */
     AsyncExecutions<Long> pfcount(K... keys);
+
 }

File: src/main/java/io/lettuce/core/cluster/api/async/NodeSelectionScriptingAsyncCommands.java
Patch:
@@ -25,8 +25,8 @@
 import io.lettuce.core.ScriptOutputType;
 
 /**
- * Asynchronous executed commands on a node selection for Scripting. {@link java.lang.String Lua scripts} are encoded by using the configured
- * {@link io.lettuce.core.ClientOptions#getScriptCharset() charset}.
+ * Asynchronous executed commands on a node selection for Scripting. {@link java.lang.String Lua scripts} are encoded by using
+ * the configured {@link io.lettuce.core.ClientOptions#getScriptCharset() charset}.
  *
  * @param <K> Key type.
  * @param <V> Value type.
@@ -183,4 +183,5 @@ public interface NodeSelectionScriptingAsyncCommands<K, V> {
      * @since 6.0
      */
     AsyncExecutions<String> scriptLoad(byte[] script);
+
 }

File: src/main/java/io/lettuce/core/cluster/api/async/NodeSelectionSetAsyncCommands.java
Patch:
@@ -341,4 +341,5 @@ public interface NodeSelectionSetAsyncCommands<K, V> {
      * @return StreamScanCursor scan cursor.
      */
     AsyncExecutions<StreamScanCursor> sscan(ValueStreamingChannel<V> channel, K key, ScanCursor scanCursor);
+
 }

File: src/main/java/io/lettuce/core/cluster/api/async/NodeSelectionStreamAsyncCommands.java
Patch:
@@ -368,4 +368,5 @@ public interface NodeSelectionStreamAsyncCommands<K, V> {
      * @since 6.1
      */
     AsyncExecutions<Long> xtrim(K key, XTrimArgs args);
+
 }

File: src/main/java/io/lettuce/core/cluster/api/async/NodeSelectionStringAsyncCommands.java
Patch:
@@ -432,4 +432,5 @@ public interface NodeSelectionStringAsyncCommands<K, V> {
      * @return Long integer-reply the length of the string at {@code key}, or {@code 0} when {@code key} does not exist.
      */
     AsyncExecutions<Long> strlen(K key);
+
 }

File: src/main/java/io/lettuce/core/cluster/api/sync/BaseNodeSelectionCommands.java
Patch:
@@ -147,4 +147,5 @@ public interface BaseNodeSelectionCommands<K, V> {
      * @return number of replicas.
      */
     Executions<Long> waitForReplication(int replicas, long timeout);
+
 }

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionHLLCommands.java
Patch:
@@ -59,4 +59,5 @@ public interface NodeSelectionHLLCommands<K, V> {
      *         The approximated number of unique elements observed via {@code PFADD}.
      */
     Executions<Long> pfcount(K... keys);
+
 }

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionHashCommands.java
Patch:
@@ -580,4 +580,5 @@ public interface NodeSelectionHashCommands<K, V> {
      *         associated timeout.
      */
     Executions<Boolean> hpersist(K key, K... fields);
+
 }

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionScriptingCommands.java
Patch:
@@ -25,8 +25,8 @@
 import io.lettuce.core.ScriptOutputType;
 
 /**
- * Synchronous executed commands on a node selection for Scripting. {@link java.lang.String Lua scripts} are encoded by using the configured
- * {@link io.lettuce.core.ClientOptions#getScriptCharset() charset}.
+ * Synchronous executed commands on a node selection for Scripting. {@link java.lang.String Lua scripts} are encoded by using
+ * the configured {@link io.lettuce.core.ClientOptions#getScriptCharset() charset}.
  *
  * @param <K> Key type.
  * @param <V> Value type.
@@ -183,4 +183,5 @@ public interface NodeSelectionScriptingCommands<K, V> {
      * @since 6.0
      */
     Executions<String> scriptLoad(byte[] script);
+
 }

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionSetCommands.java
Patch:
@@ -341,4 +341,5 @@ public interface NodeSelectionSetCommands<K, V> {
      * @return StreamScanCursor scan cursor.
      */
     Executions<StreamScanCursor> sscan(ValueStreamingChannel<V> channel, K key, ScanCursor scanCursor);
+
 }

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionStreamCommands.java
Patch:
@@ -368,4 +368,5 @@ public interface NodeSelectionStreamCommands<K, V> {
      * @since 6.1
      */
     Executions<Long> xtrim(K key, XTrimArgs args);
+
 }

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionStringCommands.java
Patch:
@@ -432,4 +432,5 @@ public interface NodeSelectionStringCommands<K, V> {
      * @return Long integer-reply the length of the string at {@code key}, or {@code 0} when {@code key} does not exist.
      */
     Executions<Long> strlen(K key);
+
 }

File: src/main/java/io/lettuce/core/cluster/pubsub/RedisClusterPubSubListener.java
Patch:
@@ -75,7 +75,7 @@ public interface RedisClusterPubSubListener<K, V> {
      * @param message Message.
      * @since 7.0
      */
-    default void smessage(RedisClusterNode node, K shardChannel, V message){
+    default void smessage(RedisClusterNode node, K shardChannel, V message) {
         message(node, shardChannel, message);
     }
 

File: src/main/java/io/lettuce/core/cluster/pubsub/StatefulRedisClusterPubSubConnection.java
Patch:
@@ -155,8 +155,7 @@ public interface StatefulRedisClusterPubSubConnection<K, V> extends StatefulRedi
      * <p>
      * Node event propagation is disabled by default.
      *
-     * @param enabled {@code true} to enable node message propagation; {@code false} (default) to disable message
-     *        propagation.
+     * @param enabled {@code true} to enable node message propagation; {@code false} (default) to disable message propagation.
      */
     void setNodeMessagePropagation(boolean enabled);
 

File: src/main/java/io/lettuce/core/cluster/pubsub/api/async/NodeSelectionPubSubAsyncCommands.java
Patch:
@@ -50,4 +50,5 @@ public interface NodeSelectionPubSubAsyncCommands<K, V> {
      * @since 7.0
      */
     AsyncExecutions<Void> ssubscribe(K... shardChannels);
+
 }

File: src/main/java/io/lettuce/core/cluster/topology/Connections.java
Patch:
@@ -134,8 +134,7 @@ private Requests doRequest(Supplier<TimedAsyncCommand<String, String, String>> c
                 entry.getValue().dispatch(timedCommand);
                 requests.addRequest(entry.getKey(), timedCommand);
             }
-        }
-        finally {
+        } finally {
             lock.unlock();
         }
 

File: src/main/java/io/lettuce/core/cluster/topology/DefaultClusterTopologyRefresh.java
Patch:
@@ -131,8 +131,7 @@ public CompletionStage<Map<RedisURI, Partitions>> loadViews(Iterable<RedisURI> s
                                         .requestTopology(commandTimeoutNs, TimeUnit.NANOSECONDS).mergeWith(requestedTopology);
                                 Requests additionalInfo = newConnections.requestInfo(commandTimeoutNs, TimeUnit.NANOSECONDS)
                                         .mergeWith(requestedInfo);
-                                return CompletableFuture
-                                        .allOf(additionalTopology.allCompleted(), additionalInfo.allCompleted())
+                                return CompletableFuture.allOf(additionalTopology.allCompleted(), additionalInfo.allCompleted())
                                         .thenApplyAsync(ignore2 -> getNodeSpecificViews(additionalTopology, additionalInfo),
                                                 clientResources.eventExecutorGroup());
                             });

File: src/main/java/io/lettuce/core/dynamic/ReactiveTypes.java
Patch:
@@ -92,8 +92,8 @@ class ReactiveTypes {
     }
 
     /**
-     * Returns {@code true} if reactive support is available. More specifically, whether RxJava1/2 or Project Reactor
-     * libraries are on the class path.
+     * Returns {@code true} if reactive support is available. More specifically, whether RxJava1/2 or Project Reactor libraries
+     * are on the class path.
      *
      * @return {@code true} if reactive support is available.
      */

File: src/main/java/io/lettuce/core/dynamic/RedisCommandFactory.java
Patch:
@@ -155,8 +155,8 @@ public void setCommandOutputFactoryResolver(CommandOutputFactoryResolver command
     /**
      * Enables/disables command verification which checks the command name against Redis {@code COMMAND} and the argument count.
      *
-     * @param verifyCommandMethods {@code true} to enable command verification (default) or {@code false} to disable
-     *        command verification.
+     * @param verifyCommandMethods {@code true} to enable command verification (default) or {@code false} to disable command
+     *        verification.
      */
     public void setVerifyCommandMethods(boolean verifyCommandMethods) {
         this.verifyCommandMethods = verifyCommandMethods;

File: src/main/java/io/lettuce/core/dynamic/SimpleBatcher.java
Patch:
@@ -184,4 +184,5 @@ private List<RedisCommand<Object, Object, Object>> prepareDefaultFlush(int consu
     private <T> ArrayList<T> newDrainTarget() {
         return new ArrayList<>(Math.max(0, Math.min(batchSize, queue.size())));
     }
+
 }

File: src/main/java/io/lettuce/core/event/connection/ConnectionEventSupport.java
Patch:
@@ -84,4 +84,5 @@ public String toString() {
         sb.append(']');
         return sb.toString();
     }
+
 }

File: src/main/java/io/lettuce/core/event/metrics/JfrCommandLatencyEvent.java
Patch:
@@ -46,4 +46,5 @@ public JfrCommandLatencyEvent(CommandLatencyEvent commandLatencyEvent) {
             new JfrCommandLatency(commandLatencyId, commandMetrics).commit();
         });
     }
+
 }

File: src/main/java/io/lettuce/core/masterreplica/AutodiscoveryConnector.java
Patch:
@@ -130,7 +130,8 @@ private Mono<StatefulRedisMasterReplicaConnection<K, V>> initializeConnection(Re
 
             connectionProvider.setKnownNodes(nodes);
 
-            MasterReplicaChannelWriter channelWriter = new MasterReplicaChannelWriter(connectionProvider, redisClient.getResources(), redisClient.getOptions());
+            MasterReplicaChannelWriter channelWriter = new MasterReplicaChannelWriter(connectionProvider,
+                    redisClient.getResources(), redisClient.getOptions());
 
             StatefulRedisMasterReplicaConnectionImpl<K, V> connection = new StatefulRedisMasterReplicaConnectionImpl<>(
                     channelWriter, codec, redisURI.getTimeout());

File: src/main/java/io/lettuce/core/masterreplica/Connections.java
Patch:
@@ -43,6 +43,7 @@ class Connections extends CompletableEventLatchSupport<Tuple2<RedisURI, Stateful
         implements AsyncCloseable {
 
     private final Lock lock = new ReentrantLock();
+
     private final Map<RedisURI, StatefulRedisConnection<String, String>> connections = new TreeMap<>(
             ReplicaUtils.RedisURIComparator.INSTANCE);
 
@@ -110,8 +111,7 @@ public boolean isEmpty() {
         try {
             lock.lock();
             return this.connections.isEmpty();
-        }
-        finally {
+        } finally {
             lock.unlock();
         }
     }

File: src/main/java/io/lettuce/core/masterreplica/SentinelConnector.java
Patch:
@@ -94,6 +94,7 @@ private Mono<StatefulRedisMasterReplicaConnection<K, V>> initializeConnection(Re
             public CompletableFuture<Void> closeAsync() {
                 return CompletableFuture.allOf(super.closeAsync(), sentinelTopologyRefresh.closeAsync());
             }
+
         };
 
         StatefulRedisMasterReplicaConnectionImpl<K, V> connection = new StatefulRedisMasterReplicaConnectionImpl<>(

File: src/main/java/io/lettuce/core/masterreplica/StaticMasterReplicaConnector.java
Patch:
@@ -86,7 +86,8 @@ private Mono<StatefulRedisMasterReplicaConnection<K, V>> initializeConnection(Re
 
         connectionProvider.setKnownNodes(nodes);
 
-        MasterReplicaChannelWriter channelWriter = new MasterReplicaChannelWriter(connectionProvider, redisClient.getResources(), redisClient.getOptions());
+        MasterReplicaChannelWriter channelWriter = new MasterReplicaChannelWriter(connectionProvider,
+                redisClient.getResources(), redisClient.getOptions());
 
         StatefulRedisMasterReplicaConnectionImpl<K, V> connection = new StatefulRedisMasterReplicaConnectionImpl<>(
                 channelWriter, codec, seedNode.getTimeout());

File: src/main/java/io/lettuce/core/metrics/CommandLatencyCollector.java
Patch:
@@ -63,4 +63,5 @@ public boolean isEnabled() {
 
         };
     }
+
 }

File: src/main/java/io/lettuce/core/metrics/DefaultCommandLatencyCollectorOptions.java
Patch:
@@ -58,7 +58,6 @@ public class DefaultCommandLatencyCollectorOptions implements CommandLatencyColl
 
     private final Builder builder;
 
-
     protected DefaultCommandLatencyCollectorOptions(Builder builder) {
         this.targetUnit = builder.targetUnit;
         this.targetPercentiles = builder.targetPercentiles;
@@ -209,8 +208,8 @@ public Builder targetPercentiles(double[] targetPercentiles) {
         }
 
         /**
-         * Sets whether the recorded latencies should be reset once the metrics event was emitted. Defaults to {@code true}.
-         * See {@link DefaultCommandLatencyCollectorOptions#DEFAULT_RESET_LATENCIES_AFTER_EVENT}.
+         * Sets whether the recorded latencies should be reset once the metrics event was emitted. Defaults to {@code true}. See
+         * {@link DefaultCommandLatencyCollectorOptions#DEFAULT_RESET_LATENCIES_AFTER_EVENT}.
          *
          * @param resetLatenciesAfterEvent {@code true} if the recorded latencies should be reset once the metrics event was
          *        emitted
@@ -279,4 +278,5 @@ public boolean isEnabled() {
     public boolean usePauseDetector() {
         return usePauseDetector;
     }
+
 }

File: src/main/java/io/lettuce/core/models/command/CommandDetail.java
Patch:
@@ -79,7 +79,8 @@ public CommandDetail(String name, int arity, Set<Flag> flags, int firstKeyPositi
      * @param aclCategories command ACL details
      * @since 6.1
      */
-    public CommandDetail(String name, int arity, Set<Flag> flags, int firstKeyPosition, int lastKeyPosition, int keyStepCount, Set<AclCategory> aclCategories) {
+    public CommandDetail(String name, int arity, Set<Flag> flags, int firstKeyPosition, int lastKeyPosition, int keyStepCount,
+            Set<AclCategory> aclCategories) {
         this.name = name;
         this.arity = arity;
         this.flags = flags;
@@ -232,4 +233,5 @@ public enum Flag {
          */
         MOVABLEKEYS;
     }
+
 }

File: src/main/java/io/lettuce/core/models/stream/PendingMessage.java
Patch:
@@ -84,4 +84,5 @@ public String toString() {
         sb.append(']');
         return sb.toString();
     }
+
 }

File: src/main/java/io/lettuce/core/models/stream/PendingMessages.java
Patch:
@@ -72,4 +72,5 @@ public String toString() {
         sb.append(']');
         return sb.toString();
     }
+
 }

File: src/main/java/io/lettuce/core/output/DoubleListOutput.java
Patch:
@@ -48,6 +48,7 @@ public DoubleListOutput(RedisCodec<K, V> codec) {
     public void set(ByteBuffer bytes) {
         output.add(bytes != null ? parseDouble(decodeAscii(bytes)) : null);
     }
+
     @Override
     public void set(double number) {
         output.add(number);

File: src/main/java/io/lettuce/core/output/GenericMapOutput.java
Patch:
@@ -18,6 +18,7 @@
 public class GenericMapOutput<K, V> extends CommandOutput<K, V, Map<K, Object>> {
 
     boolean hasKey;
+
     private K key;
 
     public GenericMapOutput(RedisCodec<K, V> codec) {

File: src/main/java/io/lettuce/core/output/ListOfGenericMapsOutput.java
Patch:
@@ -89,4 +89,5 @@ public void set(long integer) {
     public void set(double number) {
         nested.set(number);
     }
+
 }

File: src/main/java/io/lettuce/core/output/ListOfMapsOutput.java
Patch:
@@ -84,4 +84,5 @@ public void multi(int count) {
     public void set(long integer) {
         nested.set(integer);
     }
+
 }

File: src/main/java/io/lettuce/core/protocol/CommandWrapper.java
Patch:
@@ -268,9 +268,8 @@ public static <K, V, T> RedisCommand<K, V, T> unwrap(RedisCommand<K, V, T> wrapp
      *
      * If the receiver implements the interface then the result is the receiver or a proxy for the receiver. If the receiver is
      * a wrapper and the wrapped object implements the interface then the result is the wrapped object or a proxy for the
-     * wrapped object. Otherwise return the result of calling <code>unwrap</code> recursively on the wrapped object or a
-     * proxy for that result. If the receiver is not a wrapper and does not implement the interface, then an {@code null} is
-     * returned.
+     * wrapped object. Otherwise return the result of calling <code>unwrap</code> recursively on the wrapped object or a proxy
+     * for that result. If the receiver is not a wrapper and does not implement the interface, then an {@code null} is returned.
      *
      * @param wrapped
      * @param iface A Class defining an interface that the result must implement.

File: src/main/java/io/lettuce/core/protocol/ConnectionWatchdog.java
Patch:
@@ -101,7 +101,6 @@ public class ConnectionWatchdog extends ChannelInboundHandlerAdapter {
 
     private volatile Timeout reconnectScheduleTimeout;
 
-
     /**
      * Create a new watchdog that adds to new connections to the supplied {@link ChannelGroup} and establishes a new
      * {@link Channel} when disconnected, while reconnect is true. The socketAddressSupplier can supply the reconnect address.

File: src/main/java/io/lettuce/core/protocol/DemandAware.java
Patch:
@@ -20,9 +20,8 @@ public interface DemandAware {
     interface Sink {
 
         /**
-         * Returns {@code true} if the {@link Sink} has demand or {@code false} if the source has no demand.
-         * {@code false} means either the {@link Sink} has no demand in general because data is not needed or the current
-         * demand is saturated.
+         * Returns {@code true} if the {@link Sink} has demand or {@code false} if the source has no demand. {@code false} means
+         * either the {@link Sink} has no demand in general because data is not needed or the current demand is saturated.
          *
          * @return {@code true} if the {@link Sink} demands data.
          */

File: src/main/java/io/lettuce/core/protocol/Endpoint.java
Patch:
@@ -57,4 +57,5 @@ public interface Endpoint extends PushHandler {
      * @since 6.1
      */
     String getId();
+
 }

File: src/main/java/io/lettuce/core/protocol/RedisStateMachine.java
Patch:
@@ -243,11 +243,12 @@ void reset() {
          */
         private static State[] createStates(int len) {
             final State[] stack = new State[len];
-            for (int i = 0;i < len; ++i) {
+            for (int i = 0; i < len; ++i) {
                 stack[i] = new State();
             }
             return stack;
         }
+
     }
 
     private final State[] stack = State.createStates(32);

File: src/main/java/io/lettuce/core/pubsub/PubSubCommandBuilder.java
Patch:
@@ -102,15 +102,15 @@ Command<K, V, Long> spublish(K shardChannel, V message) {
         CommandArgs<K, V> args = new CommandArgs<>(codec).addKey(shardChannel).addValue(message);
         return createCommand(SPUBLISH, new IntegerOutput<>(codec), args);
     }
-    
+
     @SafeVarargs
     final Command<K, V, V> ssubscribe(K... shardChannels) {
         LettuceAssert.notEmpty(shardChannels, "Shard channels " + MUST_NOT_BE_EMPTY);
 
         CommandArgs<K, V> args = new CommandArgs<>(codec).addKeys(shardChannels);
         return createCommand(SSUBSCRIBE, new PubSubOutput<>(codec), args);
     }
-    
+
     @SafeVarargs
     final Command<K, V, V> subscribe(K... channels) {
         LettuceAssert.notEmpty(channels, "Channels " + MUST_NOT_BE_EMPTY);

File: src/main/java/io/lettuce/core/pubsub/RedisPubSubAdapter.java
Patch:
@@ -60,7 +60,7 @@ public void punsubscribed(K pattern, long count) {
     }
 
     @Override
-    public void smessage(K shardChannel, V message) {  
+    public void smessage(K shardChannel, V message) {
         // empty adapter method
     }
 

File: src/main/java/io/lettuce/core/resource/DefaultClientResources.java
Patch:
@@ -694,8 +694,8 @@ public DefaultClientResources.Builder mutate() {
                 .commandLatencyPublisherOptions(commandLatencyPublisherOptions()).dnsResolver(dnsResolver())
                 .eventBus(eventBus()).eventExecutorGroup(eventExecutorGroup()).reconnectDelay(reconnectDelay)
                 .socketAddressResolver(socketAddressResolver()).nettyCustomizer(nettyCustomizer())
-                .threadFactoryProvider(threadFactoryProvider).timer(timer())
-                .tracing(tracing()).addressResolverGroup(addressResolverGroup());
+                .threadFactoryProvider(threadFactoryProvider).timer(timer()).tracing(tracing())
+                .addressResolverGroup(addressResolverGroup());
 
         builder.sharedCommandLatencyCollector = sharedEventLoopGroupProvider;
         builder.sharedEventExecutor = sharedEventExecutor;

File: src/main/java/io/lettuce/core/resource/MappingSocketAddressResolver.java
Patch:
@@ -55,8 +55,7 @@ private MappingSocketAddressResolver(DnsResolver dnsResolver, Function<HostAndPo
      * @return the {@link MappingSocketAddressResolver}.
      * @since 6.1
      */
-    public static MappingSocketAddressResolver create(
-            Function<HostAndPort, HostAndPort> mappingFunction) {
+    public static MappingSocketAddressResolver create(Function<HostAndPort, HostAndPort> mappingFunction) {
         return new MappingSocketAddressResolver(mappingFunction);
     }
 

File: src/main/java/io/lettuce/core/sentinel/RedisSentinelReactiveCommandsImpl.java
Patch:
@@ -165,7 +165,7 @@ public Mono<String> info(String section) {
         return createMono(() -> commandBuilder.info(section));
     }
 
-    @SuppressWarnings({"unchecked", "rawtypes"})
+    @SuppressWarnings({ "unchecked", "rawtypes" })
     @Override
     public <T> Flux<T> dispatch(ProtocolKeyword type, CommandOutput<K, V, ?> output) {
 
@@ -175,7 +175,7 @@ public <T> Flux<T> dispatch(ProtocolKeyword type, CommandOutput<K, V, ?> output)
         return (Flux) createFlux(() -> new Command<>(type, output));
     }
 
-    @SuppressWarnings({"unchecked", "rawtypes"})
+    @SuppressWarnings({ "unchecked", "rawtypes" })
     @Override
     public <T> Flux<T> dispatch(ProtocolKeyword type, CommandOutput<K, V, ?> output, CommandArgs<K, V> args) {
 

File: src/main/java/io/lettuce/core/sentinel/api/sync/RedisSentinelCommands.java
Patch:
@@ -197,7 +197,8 @@ public interface RedisSentinelCommands<K, V> {
     /**
      * Get the list of the current client connection.
      *
-     * @return String bulk-string-reply a unique string, formatted as a succession of property=value fields separated by a space character.
+     * @return String bulk-string-reply a unique string, formatted as a succession of property=value fields separated by a space
+     *         character.
      * @since 6.3
      */
     String clientInfo();
@@ -256,4 +257,5 @@ public interface RedisSentinelCommands<K, V> {
      * @return the underlying connection.
      */
     StatefulRedisSentinelConnection<K, V> getStatefulConnection();
+
 }

File: src/main/java/io/lettuce/core/support/AsyncConnectionPoolSupport.java
Patch:
@@ -220,6 +220,7 @@ public CompletableFuture<Void> destroy(T object) {
         public CompletableFuture<Boolean> validate(T object) {
             return CompletableFuture.completedFuture(object.isOpen());
         }
+
     }
 
     private static class AsyncPoolWrapper<T> implements Origin<T> {

File: src/main/java/io/lettuce/core/support/BasePoolConfig.java
Patch:
@@ -94,8 +94,8 @@ public Builder testOnCreate() {
          * Validation is performed by the {@link AsyncObjectFactory#validate(Object)} method of the factory associated with the
          * pool. If the object fails to validate, then acquire will fail.
          *
-         * @param testOnCreate {@code true} if newly created objects should be validated before being returned from the
-         *        acquire method. {@code true} to enable test on creation.
+         * @param testOnCreate {@code true} if newly created objects should be validated before being returned from the acquire
+         *        method. {@code true} to enable test on creation.
          *
          * @return {@code this} {@link Builder}.
          */

File: src/main/templates/io/lettuce/core/api/RedisHashCommands.java
Patch:
@@ -575,4 +575,5 @@ public interface RedisHashCommands<K, V> {
      *         associated timeout.
      */
     Boolean hpersist(K key, K... fields);
+
 }

File: src/main/templates/io/lettuce/core/api/RedisStreamCommands.java
Patch:
@@ -373,4 +373,5 @@ public interface RedisStreamCommands<K, V> {
      * @since 6.1
      */
     Long xtrim(K key, XTrimArgs args);
+
 }

File: src/test/java/biz/paluch/redis/extensibility/LettuceGeoDemo.java
Patch:
@@ -47,4 +47,5 @@ public static void main(String[] args) {
         redis.getStatefulConnection().close();
         redisClient.shutdown();
     }
+
 }

File: src/test/java/biz/paluch/redis/extensibility/MyExtendedRedisClient.java
Patch:
@@ -32,4 +32,5 @@ protected <K, V> StatefulRedisPubSubConnectionImpl<K, V> newStatefulRedisPubSubC
             RedisChannelWriter channelWriter, RedisCodec<K, V> codec, Duration timeout) {
         return new MyPubSubConnection<>(endpoint, channelWriter, codec, timeout);
     }
+
 }

File: src/test/java/biz/paluch/redis/extensibility/MyPubSubConnection.java
Patch:
@@ -28,7 +28,8 @@ class MyPubSubConnection<K, V> extends StatefulRedisPubSubConnectionImpl<K, V> {
      * @param codec Codec used to encode/decode keys and values.
      * @param timeout Maximum time to wait for a response.
      */
-    public MyPubSubConnection(PubSubEndpoint<K, V> endpoint, RedisChannelWriter writer, RedisCodec<K, V> codec, Duration timeout) {
+    public MyPubSubConnection(PubSubEndpoint<K, V> endpoint, RedisChannelWriter writer, RedisCodec<K, V> codec,
+            Duration timeout) {
         super(endpoint, writer, codec, timeout);
     }
 
@@ -41,4 +42,5 @@ public <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> command) {
 
         return super.dispatch(command);
     }
+
 }

File: src/test/java/io/lettuce/RedisBug.java
Patch:
@@ -14,5 +14,7 @@
 @Documented
 @Disabled("Redis Bug")
 public @interface RedisBug {
+
     String value() default "";
+
 }

File: src/test/java/io/lettuce/apigenerator/CreateSyncApi.java
Patch:
@@ -51,8 +51,8 @@ class CreateSyncApi {
      * @return
      */
     Function<String, String> commentMutator() {
-        return s -> s.replaceAll("\\$\\{intent\\}", "Synchronous executed commands") + "* @generated by "
-                + getClass().getName() + "\r\n ";
+        return s -> s.replaceAll("\\$\\{intent\\}", "Synchronous executed commands") + "* @generated by " + getClass().getName()
+                + "\r\n ";
     }
 
     /**
@@ -106,4 +106,5 @@ private CompilationUnitFactory createFactory(String templateName) {
         return new CompilationUnitFactory(templateFile, Constants.SOURCES, targetPackage, targetName, commentMutator(),
                 methodTypeMutator(), methodFilter(), importSupplier(), null, Function.identity());
     }
+
 }

File: src/test/java/io/lettuce/codec/CRC16UnitTests.java
Patch:
@@ -40,6 +40,7 @@ void testCRC16(Fixture fixture) {
     static class Fixture {
 
         final byte[] bytes;
+
         final int expected;
 
         Fixture(byte[] bytes, int expected) {
@@ -51,5 +52,7 @@ static class Fixture {
         public String toString() {
             return "Expects 0x" + Integer.toHexString(expected).toUpperCase();
         }
+
     }
+
 }

File: src/test/java/io/lettuce/core/AbstractRedisClientTest.java
Patch:
@@ -34,6 +34,7 @@
 public abstract class AbstractRedisClientTest extends TestSupport {
 
     protected static RedisClient client;
+
     protected RedisCommands<String, String> redis;
 
     @BeforeAll
@@ -81,4 +82,5 @@ public void closeConnection() throws Exception {
             redis.getStatefulConnection().close();
         }
     }
+
 }

File: src/test/java/io/lettuce/core/ByteBufferCodec.java
Patch:
@@ -34,4 +34,5 @@ public ByteBuffer encodeKey(ByteBuffer key) {
     public ByteBuffer encodeValue(ByteBuffer value) {
         return value.asReadOnlyBuffer();
     }
+
 }

File: src/test/java/io/lettuce/core/ClientMetricsIntegrationTests.java
Patch:
@@ -63,4 +63,5 @@ private void generateTestData(RedisCommands<String, String> redis) {
         redis.get(key);
         redis.get(key);
     }
+
 }

File: src/test/java/io/lettuce/core/ClientOptionsIntegrationTests.java
Patch:
@@ -548,4 +548,5 @@ void authenticatedPingBeforeConnectWithQueuedCommandsAndReconnect() {
             redisConnection.close();
         });
     }
+
 }

File: src/test/java/io/lettuce/core/ClientOptionsUnitTests.java
Patch:
@@ -59,4 +59,5 @@ void checkAssertions(ClientOptions sut) {
         assertThat(sut.isSuspendReconnectOnProtocolFailure()).isFalse();
         assertThat(sut.getDisconnectedBehavior()).isEqualTo(ClientOptions.DisconnectedBehavior.DEFAULT);
     }
+
 }

File: src/test/java/io/lettuce/core/ConnectMethodsIntegrationTests.java
Patch:
@@ -17,6 +17,7 @@
 class ConnectMethodsIntegrationTests {
 
     private final RedisClient redisClient;
+
     private final RedisClusterClient clusterClient;
 
     @Inject

File: src/test/java/io/lettuce/core/ConnectionFutureUnitTests.java
Patch:
@@ -63,7 +63,6 @@ void composeTransformShouldFailWhileTransformationRetainOriginalException() {
         Throwable t = new Throwable();
         foo.completeExceptionally(t);
 
-
         assertThat(transformed.toCompletableFuture()).isDone();
         assertThat(transformed.toCompletableFuture()).isCompletedExceptionally();
 
@@ -106,7 +105,8 @@ void shouldComposeWithErrorFlow() {
 
         assertThat(transformed2.toCompletableFuture()).isDone();
         assertThat(transformed2.toCompletableFuture()).isCompletedExceptionally();
-        assertThatThrownBy(transformed2::join).hasCauseInstanceOf(IllegalStateException.class).hasRootCauseInstanceOf(
-                IllegalArgumentException.class);
+        assertThatThrownBy(transformed2::join).hasCauseInstanceOf(IllegalStateException.class)
+                .hasRootCauseInstanceOf(IllegalArgumentException.class);
     }
+
 }

File: src/test/java/io/lettuce/core/GeoModelUnitTests.java
Patch:
@@ -82,4 +82,5 @@ void geoCoordinatesSlightlyDifferent() {
         assertThat(sut.toString()).isNotEqualTo(slightlyDifferent.toString());
 
     }
+
 }

File: src/test/java/io/lettuce/core/KeyValueUnitTests.java
Patch:
@@ -122,4 +122,5 @@ void toStringShouldRenderCorrectly() {
     KeyValue<String, String> kv(String key, String value) {
         return KeyValue.just(key, value);
     }
+
 }

File: src/test/java/io/lettuce/core/LimitUnitTests.java
Patch:
@@ -28,4 +28,5 @@ void unlimited() {
         assertThat(limit.getCount()).isEqualTo(-1);
         assertThat(limit.isLimited()).isFalse();
     }
+
 }

File: src/test/java/io/lettuce/core/PipeliningIntegrationTests.java
Patch:
@@ -27,6 +27,7 @@
 class PipeliningIntegrationTests extends TestSupport {
 
     private final RedisClient client;
+
     private final StatefulRedisConnection<String, String> connection;
 
     @Inject
@@ -109,4 +110,5 @@ String value(int i) {
     String key(int i) {
         return key + "-" + i;
     }
+
 }

File: src/test/java/io/lettuce/core/RangeUnitTests.java
Patch:
@@ -97,4 +97,5 @@ void lessOrEquals() {
         assertThat(lte.getUpper().getValue()).isEqualTo("zero");
         assertThat(lte.toString()).isEqualTo("Range [[unbounded] to [zero]");
     }
+
 }

File: src/test/java/io/lettuce/core/ReactiveBackpressurePropagationUnitTests.java
Patch:
@@ -39,6 +39,7 @@
 class ReactiveBackpressurePropagationUnitTests {
 
     private CommandHandler commandHandler;
+
     private EmbeddedChannel embeddedChannel;
 
     @Mock
@@ -183,6 +184,7 @@ static byte[] arrayHeader(int count) {
         static byte[] bulkString(String string) {
             return String.format("$%d\r\n%s\r\n", string.getBytes().length, string).getBytes();
         }
+
     }
 
 }

File: src/test/java/io/lettuce/core/RedisClientConnectIntegrationTests.java
Patch:
@@ -136,7 +136,7 @@ void shutdownSyncInRedisFutureTest() {
         CompletableFuture<String> f = connection.async().get("key1").whenComplete((result, e) -> {
             connection.close();
             redisClient.shutdown(0, 0, SECONDS); // deadlock expected.
-            }).toCompletableFuture();
+        }).toCompletableFuture();
 
         assertThatThrownBy(() -> TestFutures.awaitOrTimeout(f)).isInstanceOf(TimeoutException.class);
     }
@@ -200,8 +200,7 @@ void connectPubSubCodecOwnUri() {
     @Test
     void connectPubSubAsync() {
         RedisURI redisURI = redis(host, port).build();
-        ConnectionFuture<StatefulRedisPubSubConnection<String, String>> future = client.connectPubSubAsync(
-UTF8, redisURI);
+        ConnectionFuture<StatefulRedisPubSubConnection<String, String>> future = client.connectPubSubAsync(UTF8, redisURI);
         StatefulRedisPubSubConnection<String, String> connection = future.join();
         assertThat(connection.getTimeout()).isEqualTo(redisURI.getTimeout());
         connection.close();
@@ -278,4 +277,5 @@ private static RedisURI invalidSentinel() {
 
         return redisURI;
     }
+
 }

File: src/test/java/io/lettuce/core/RedisClientListenerIntegrationTests.java
Patch:
@@ -12,5 +12,4 @@
 @ExtendWith(LettuceExtension.class)
 class RedisClientListenerIntegrationTests extends TestSupport {
 
-
 }

File: src/test/java/io/lettuce/core/RedisClientUnitTests.java
Patch:
@@ -88,4 +88,5 @@ void shutdownShutsDownResourcesAfterChannels() throws Exception {
         verify(clientResources).shutdown(anyLong(), anyLong(), any());
         assertThat(future).isDone();
     }
+
 }

File: src/test/java/io/lettuce/core/ScanArgsUnitTests.java
Patch:
@@ -22,4 +22,5 @@ void shouldEncodeMatchUsingUtf8() {
 
         assertThat(commandArgs.toCommandString()).isEqualTo("MATCH w7Y=");
     }
+
 }

File: src/test/java/io/lettuce/core/ScanCursorUnitTests.java
Patch:
@@ -26,4 +26,5 @@ void setCursorOnImmutableInstance() {
     void setFinishedOnImmutableInstance() {
         assertThatThrownBy(() -> ScanCursor.INITIAL.setFinished(false)).isInstanceOf(UnsupportedOperationException.class);
     }
+
 }

File: src/test/java/io/lettuce/core/ScanStreamIntegrationTests.java
Patch:
@@ -46,6 +46,7 @@
 class ScanStreamIntegrationTests extends TestSupport {
 
     private final StatefulRedisConnection<String, String> connection;
+
     private final RedisCommands<String, String> redis;
 
     @Inject
@@ -176,4 +177,5 @@ void shouldCorrectlyEmitKeysWithConcurrentPoll() {
 
         assertThat(redis.scard(targetKey)).isEqualTo(5_000);
     }
+
 }

File: src/test/java/io/lettuce/core/ScoredValueStreamingAdapter.java
Patch:
@@ -10,6 +10,7 @@
  * @since 3.0
  */
 public class ScoredValueStreamingAdapter<T> implements ScoredValueStreamingChannel<T> {
+
     private List<ScoredValue<T>> list = new ArrayList<>();
 
     @Override
@@ -20,4 +21,5 @@ public void onValue(ScoredValue<T> value) {
     public List<ScoredValue<T>> getList() {
         return list;
     }
+
 }

File: src/test/java/io/lettuce/core/ScoredValueUnitTests.java
Patch:
@@ -124,4 +124,5 @@ void toStringShouldRenderCorrectly() {
         assertThat(value.toString()).contains("ScoredValue[12").contains("340000, hello]");
         assertThat(empty.toString()).contains(String.format("ScoredValue[%f].empty", 0d));
     }
+
 }

File: src/test/java/io/lettuce/core/SocketOptionsIntegrationTests.java
Patch:
@@ -50,4 +50,5 @@ void testConnectTimeout() {
             }
         }
     }
+
 }

File: src/test/java/io/lettuce/core/SslOptionsUnitTests.java
Patch:
@@ -82,4 +82,5 @@ void shouldApplyContextCustomizer() throws Exception {
         SslContext context = options.createSslContextBuilder().build();
         assertThat(context.cipherSuites()).containsOnly("TLS_RSA_WITH_AES_128_CBC_SHA");
     }
+
 }

File: src/test/java/io/lettuce/core/SyncAsyncApiConvergenceUnitTests.java
Patch:
@@ -61,7 +61,8 @@ void testSameResultType(Method syncMethod) throws Exception {
             }
         }
 
-        assertThat(returnType.toString()).describedAs(syncMethod.toString()).isEqualTo(
-                syncMethod.getGenericReturnType().toString());
+        assertThat(returnType.toString()).describedAs(syncMethod.toString())
+                .isEqualTo(syncMethod.getGenericReturnType().toString());
     }
+
 }

File: src/test/java/io/lettuce/core/TestRedisPublisher.java
Patch:
@@ -19,4 +19,5 @@ public TestRedisPublisher(Supplier<RedisCommand<K, V, T>> redisCommandSupplier,
             boolean dissolve) {
         super(redisCommandSupplier, connection, dissolve, ImmediateEventExecutor.INSTANCE);
     }
+
 }

File: src/test/java/io/lettuce/core/TimeoutOptionsUnitTests.java
Patch:
@@ -43,4 +43,5 @@ void fixedConnectionTimeout() {
         assertThat(timeoutOptions.isApplyConnectionTimeout()).isFalse();
         assertThat(source.getTimeout(null)).isEqualTo(TimeUnit.MINUTES.toNanos(1));
     }
+
 }

File: src/test/java/io/lettuce/core/UnixDomainSocketIntegrationTests.java
Patch:
@@ -32,7 +32,9 @@ class UnixDomainSocketIntegrationTests {
     private static RedisClient sentinelClient;
 
     private Logger log = LogManager.getLogger(getClass());
+
     private String key = "key";
+
     private String value = "value";
 
     @BeforeAll
@@ -169,8 +171,7 @@ private static RedisClient getRedisSentinelClient() {
     private void assumeTestSupported() {
         String osName = SystemPropertyUtil.get("os.name").toLowerCase(Locale.UK).trim();
         assumeTrue(Transports.NativeTransports.isDomainSocketSupported(),
-                "Only supported on Linux/OSX, your os is " + osName
-                + " with epoll/kqueue support.");
+                "Only supported on Linux/OSX, your os is " + osName + " with epoll/kqueue support.");
     }
 
     private static RedisURI getSocketRedisUri() throws IOException {

File: src/test/java/io/lettuce/core/Utf8StringCodecIntegrationTests.java
Patch:
@@ -51,4 +51,5 @@ void decodeHugeBuffer(StatefulRedisConnection<String, String> connection) {
         redis.set(key, value);
         assertThat(redis.get(key)).isEqualTo(value);
     }
+
 }

File: src/test/java/io/lettuce/core/ValueUnitTests.java
Patch:
@@ -126,8 +126,8 @@ void emptyValueGetValueOrElseShouldThrowException() {
 
         Value<String> value = Value.from(Optional.empty());
 
-        assertThatThrownBy(() -> value.getValueOrElseThrow(IllegalArgumentException::new)).isInstanceOf(
-                IllegalArgumentException.class);
+        assertThatThrownBy(() -> value.getValueOrElseThrow(IllegalArgumentException::new))
+                .isInstanceOf(IllegalArgumentException.class);
     }
 
     @Test
@@ -263,4 +263,5 @@ void streamShouldCreateAStream() {
 
         assertThat(empty.stream().count()).isEqualTo(1);
     }
+
 }

File: src/test/java/io/lettuce/core/ZAggregateArgsUnitTests.java
Patch:
@@ -48,4 +48,5 @@ void shouldOmitWeights() {
 
         assertThat(args.toString()).doesNotContain("WEIGHTS");
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/ByteCodecClusterIntegrationTests.java
Patch:
@@ -27,4 +27,5 @@ void testByteCodec(RedisClusterClient clusterClient) {
         connection.sync().set(key.getBytes(), value.getBytes());
         assertThat(connection.sync().get(key.getBytes())).isEqualTo(value.getBytes());
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/ClusterClientOptionsUnitTests.java
Patch:
@@ -26,8 +26,8 @@ void testCopy() {
         Predicate<RedisClusterNode> nodeFilter = it -> true;
         ClusterClientOptions options = ClusterClientOptions.builder().autoReconnect(false).requestQueueSize(100)
                 .suspendReconnectOnProtocolFailure(true).maxRedirects(1234).validateClusterNodeMembership(false)
-                .readOnlyCommands(command -> command.getType() == CommandType.PING)
-                .protocolVersion(ProtocolVersion.RESP2).nodeFilter(nodeFilter).build();
+                .readOnlyCommands(command -> command.getType() == CommandType.PING).protocolVersion(ProtocolVersion.RESP2)
+                .nodeFilter(nodeFilter).build();
 
         ClusterClientOptions copy = ClusterClientOptions.copyOf(options);
 
@@ -102,4 +102,5 @@ void builderFromClusterClientOptions() {
         assertThat(copy.getReadOnlyCommands().isReadOnly(new Command<>(CommandType.PING, null))).isTrue();
         assertThat(options.mutate()).isNotSameAs(copy.mutate());
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/ClusterCommandUnitTests.java
Patch:
@@ -30,6 +30,7 @@ class ClusterCommandUnitTests {
     private RedisChannelWriter writerMock;
 
     private ClusterCommand<String, String, String> sut;
+
     private Command<String, String, String> command = new Command<>(CommandType.TYPE, new StatusOutput<>(StringCodec.UTF8),
             null);
 
@@ -100,4 +101,5 @@ void testCompleteListener() {
         assertThat(sut.isCompleted()).isTrue();
         assertThat(someList.size()).describedAs("Inner listener has to add one element").isEqualTo(1);
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/ClusterNodeEndpointUnitTests.java
Patch:
@@ -145,4 +145,5 @@ private void prepareNewEndpoint() {
         sut = new ClusterNodeEndpoint(clientOptions, clientResources, clusterChannelWriter);
         disconnectedBuffer = (Queue) ReflectionTestUtils.getField(sut, "disconnectedBuffer");
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/ClusterReactiveCommandIntegrationTests.java
Patch:
@@ -25,7 +25,9 @@
 class ClusterReactiveCommandIntegrationTests {
 
     private final RedisClusterClient clusterClient;
+
     private final RedisClusterReactiveCommands<String, String> reactive;
+
     private final RedisClusterCommands<String, String> sync;
 
     @Inject
@@ -94,4 +96,5 @@ void clusterSlaves() {
 
         assertThat(result.size()).isGreaterThan(0);
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/ClusterTestUtil.java
Patch:
@@ -75,9 +75,9 @@ public static RedisCommands<String, String> redisCommandsOverCluster(
             StatefulRedisClusterConnection<String, String> connection) {
         StatefulRedisClusterConnectionImpl clusterConnection = (StatefulRedisClusterConnectionImpl) connection;
 
-        InvocationHandler h = new RoutingInvocationHandler(connection.async(),
-                clusterConnection.syncInvocationHandler());
+        InvocationHandler h = new RoutingInvocationHandler(connection.async(), clusterConnection.syncInvocationHandler());
         return (RedisCommands<String, String>) Proxy.newProxyInstance(ClusterTestUtil.class.getClassLoader(),
                 new Class[] { RedisCommands.class }, h);
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/ClusterTopologyRefreshSchedulerUnitTests.java
Patch:
@@ -273,4 +273,5 @@ void shouldRetrievePartitionsViaAdaptiveRefreshTriggeredEvent() {
 
         assertThat(capture.getPartitions()).isSameAs(partitions);
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/CommandSetIntegrationTests.java
Patch:
@@ -48,5 +48,7 @@ enum UnknownCommand implements ProtocolKeyword {
         public byte[] getBytes() {
             return name().getBytes();
         }
+
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/PartitionsConsensusTestSupport.java
Patch:
@@ -12,7 +12,7 @@
 class PartitionsConsensusTestSupport {
 
     static RedisClusterNode createNode(int nodeId) {
-        return new RedisClusterNode(RedisURI.create("localhost", 6379-2020 + nodeId), "" + nodeId, true, "", 0, 0, 0,
+        return new RedisClusterNode(RedisURI.create("localhost", 6379 - 2020 + nodeId), "" + nodeId, true, "", 0, 0, 0,
                 Collections.emptyList(), new HashSet<>());
     }
 
@@ -34,4 +34,5 @@ static Map<RedisURI, Partitions> createMap(Partitions... partitionses) {
 
         return partitionsMap;
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/PipelinedRedisFutureUnitTests.java
Patch:
@@ -38,4 +38,5 @@ void testCompleteExceptionally() {
         assertThat(TestFutures.getOrTimeout(sut.toCompletableFuture())).isEqualTo(other);
         assertThat(sut.getError()).isNull();
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/RedisClusterReadFromIntegrationTests.java
Patch:
@@ -45,7 +45,9 @@
 class RedisClusterReadFromIntegrationTests extends TestSupport {
 
     private final RedisClusterClient clusterClient;
+
     private StatefulRedisClusterConnection<String, String> connection;
+
     private RedisAdvancedClusterCommands<String, String> sync;
 
     @Inject

File: src/test/java/io/lettuce/core/cluster/RedisClusterURIUtilUnitTests.java
Patch:
@@ -94,4 +94,5 @@ void testSslWithPasswordMultipleHosts() {
         assertThat(host2.getHost()).isEqualTo("host2");
         assertThat(host2.getPort()).isEqualTo(6380);
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/ScanStreamIntegrationTests.java
Patch:
@@ -21,6 +21,7 @@
 class ScanStreamIntegrationTests extends TestSupport {
 
     private final StatefulRedisClusterConnection<String, String> connection;
+
     private final RedisClusterCommands<String, String> redis;
 
     @Inject
@@ -43,4 +44,5 @@ void shouldScanIteratively() {
                 .verifyComplete();
         StepVerifier.create(ScanStream.scan(reactive)).expectNextCount(1000).verifyComplete();
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/SingleThreadedReactiveClusterClientIntegrationTests.java
Patch:
@@ -55,4 +55,5 @@ void shouldPropagateAsynchronousConnections() {
 
         assertThat(keys).contains("key", "foo");
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/SlotHashUnitTests.java
Patch:
@@ -13,6 +13,7 @@
 class SlotHashUnitTests {
 
     private static final byte[] BYTES = "123456789".getBytes();
+
     private static final byte[] TAGGED = "key{123456789}a".getBytes();
 
     @Test
@@ -42,4 +43,5 @@ void testHashWithHash() {
         int result = SlotHash.getSlot((ByteBuffer) ByteBuffer.allocateDirect(TAGGED.length).put(TAGGED).flip());
         assertThat(result).isEqualTo(0x31C3);
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/commands/ListClusterCommandIntegrationTests.java
Patch:
@@ -27,7 +27,6 @@ class ListClusterCommandIntegrationTests extends ListCommandIntegrationTests {
         this.redis = connection.sync();
     }
 
-
     // re-implementation because keys have to be on the same slot
     @Test
     void brpoplpush() {
@@ -39,7 +38,6 @@ void brpoplpush() {
         assertThat(redis.lrange("br7EPz9bbj", 0, -1)).isEqualTo(list("2", "3", "4"));
     }
 
-
     @Test
     void brpoplpushTimeout() {
         assertThat(redis.brpoplpush(1, "UKPDHs8Zlp", "br7EPz9bbj")).isNull();
@@ -90,4 +88,5 @@ void rpoplpush() {
         assertThat(redis.lrange("UKPDHs8Zlp", 0, -1)).isEqualTo(list("1"));
         assertThat(redis.lrange("br7EPz9bbj", 0, -1)).isEqualTo(list("2", "3", "4"));
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/commands/reactive/HashClusterReactiveCommandIntegrationTests.java
Patch:
@@ -30,4 +30,5 @@ public void hgetall() {
     public void hgetallStreaming() {
 
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/commands/reactive/StringClusterReactiveCommandIntegrationTests.java
Patch:
@@ -24,6 +24,7 @@
 class StringClusterReactiveCommandIntegrationTests extends StringCommandIntegrationTests {
 
     private final StatefulRedisClusterConnection<String, String> connection;
+
     private final RedisClusterCommands<String, String> redis;
 
     @Inject
@@ -58,4 +59,5 @@ void mget() {
         Flux<KeyValue<String, String>> mget = reactive.mget(key, "key1", "key2");
         StepVerifier.create(mget.next()).expectNext(KeyValue.just(key, value)).verifyComplete();
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/models/partitions/RedisClusterNodeUnitTests.java
Patch:
@@ -54,4 +54,5 @@ void testToString() {
 
         assertThat(node.toString()).contains(RedisClusterNode.class.getSimpleName());
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/models/slots/ClusterSlotsParserUnitTests.java
Patch:
@@ -116,4 +116,5 @@ void testModel() {
 
         assertThat(range.toString()).contains(ClusterSlotRange.class.getSimpleName());
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/topology/RequestsUnitTests.java
Patch:
@@ -86,4 +86,5 @@ private TimedAsyncCommand getCommand(String response) {
         timedAsyncCommand.complete();
         return timedAsyncCommand;
     }
+
 }

File: src/test/java/io/lettuce/core/cluster/topology/TopologyComparatorsUnitTests.java
Patch:
@@ -43,7 +43,9 @@
 class TopologyComparatorsUnitTests {
 
     private RedisClusterNodeSnapshot node1 = createNode("1");
+
     private RedisClusterNodeSnapshot node2 = createNode("2");
+
     private RedisClusterNodeSnapshot node3 = createNode("3");
 
     private static RedisClusterNodeSnapshot createNode(String nodeId) {
@@ -367,4 +369,5 @@ void runTest(Map<String, Long> map, List<RedisClusterNodeSnapshot> expectation,
 
         assertThat(result).containsExactly(expectation.toArray(new RedisClusterNodeSnapshot[expectation.size()]));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/BitCommandIntegrationTests.java
Patch:
@@ -53,6 +53,7 @@
 public class BitCommandIntegrationTests extends TestSupport {
 
     private final RedisClient client;
+
     private final RedisCommands<String, String> redis;
 
     protected RedisCommands<String, String> bitstring;

File: src/test/java/io/lettuce/core/commands/BitStringCodec.java
Patch:
@@ -20,4 +20,5 @@ public String decodeValue(ByteBuffer bytes) {
         }
         return bits.toString();
     }
+
 }

File: src/test/java/io/lettuce/core/commands/HLLCommandIntegrationTests.java
Patch:
@@ -106,4 +106,5 @@ void pfaddPfmergePfCount() {
 
         assertThat(redis.pfcount("key8885")).isEqualTo(3);
     }
+
 }

File: src/test/java/io/lettuce/core/commands/NumericCommandIntegrationTests.java
Patch:
@@ -83,4 +83,5 @@ void incrbyfloat() {
         assertThat(redis.incrbyfloat(key, 3.0)).isEqualTo(3.0, offset(0.1));
         assertThat(redis.incrbyfloat(key, 0.2)).isEqualTo(3.2, offset(0.1));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/ServerCommandIntegrationTests.java
Patch:
@@ -208,7 +208,7 @@ void clientListExtended() {
     }
 
     @Test
-    @EnabledOnCommand("EVAL_RO")   // Redis 7.0
+    @EnabledOnCommand("EVAL_RO") // Redis 7.0
     void clientNoEvict() {
         assertThat(redis.clientNoEvict(true)).isEqualTo("OK");
         assertThat(redis.clientNoEvict(false)).isEqualTo("OK");
@@ -338,7 +338,7 @@ void configGet() {
     }
 
     @Test
-    @EnabledOnCommand("EVAL_RO")    // Redis 7.0
+    @EnabledOnCommand("EVAL_RO") // Redis 7.0
     void configGetMultipleParameters() {
         assertThat(redis.configGet("maxmemory", "*max-*-entries*")).containsEntry("maxmemory", "0")
                 .containsEntry("hash-max-listpack-entries", "512");
@@ -361,7 +361,7 @@ void configSet() {
     }
 
     @Test
-    @EnabledOnCommand("EVAL_RO")    // Redis 7.0
+    @EnabledOnCommand("EVAL_RO") // Redis 7.0
     void configSetMultipleParameters() {
         Map<String, String> original = redis.configGet("maxmemory", "hash-max-listpack-entries");
         Map<String, String> config = new HashMap<>();

File: src/test/java/io/lettuce/core/commands/SetCommandIntegrationTests.java
Patch:
@@ -241,7 +241,7 @@ void sremEmpty() {
 
     @Test
     void sremNulls() {
-        assertThatThrownBy(() -> redis.srem(key, new String[0])).isInstanceOf(IllegalArgumentException. class);
+        assertThatThrownBy(() -> redis.srem(key, new String[0])).isInstanceOf(IllegalArgumentException.class);
     }
 
     @Test
@@ -252,7 +252,7 @@ void sunion() {
 
     @Test
     void sunionEmpty() {
-        assertThatThrownBy(() -> redis.sunion()).isInstanceOf(IllegalArgumentException. class);
+        assertThatThrownBy(() -> redis.sunion()).isInstanceOf(IllegalArgumentException.class);
     }
 
     @Test

File: src/test/java/io/lettuce/core/commands/reactive/BitReactiveCommandIntegrationTests.java
Patch:
@@ -90,10 +90,11 @@ void bitfieldIncrBy() {
     @Test
     void bitfieldOverflow() {
 
-        BitFieldArgs bitFieldArgs = BitFieldArgs.Builder.overflow(FAIL).set(signed(8), 9, 5)
-                .incrBy(signed(8), Integer.MAX_VALUE);
+        BitFieldArgs bitFieldArgs = BitFieldArgs.Builder.overflow(FAIL).set(signed(8), 9, 5).incrBy(signed(8),
+                Integer.MAX_VALUE);
 
         StepVerifier.create(reactive.bitfield(key, bitFieldArgs)).expectNext(Value.just(0L)).expectNext(Value.empty())
                 .verifyComplete();
     }
+
 }

File: src/test/java/io/lettuce/core/commands/reactive/GeoReactiveCommandIntegrationTests.java
Patch:
@@ -50,4 +50,5 @@ public void geopos() {
     @Override
     public void geoposInTransaction() {
     }
+
 }

File: src/test/java/io/lettuce/core/commands/reactive/HLLReactiveCommandIntegrationTests.java
Patch:
@@ -15,4 +15,5 @@ class HLLReactiveCommandIntegrationTests extends HLLCommandIntegrationTests {
     HLLReactiveCommandIntegrationTests(StatefulRedisConnection<String, String> connection) {
         super(ReactiveSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/reactive/HashReactiveCommandIntegrationTests.java
Patch:
@@ -48,4 +48,5 @@ public void hgetall() {
     public void hgetallStreaming() {
 
     }
+
 }

File: src/test/java/io/lettuce/core/commands/reactive/KeyReactiveCommandIntegrationTests.java
Patch:
@@ -15,4 +15,5 @@ class KeyReactiveCommandIntegrationTests extends KeyCommandIntegrationTests {
     KeyReactiveCommandIntegrationTests(StatefulRedisConnection<String, String> connection) {
         super(ReactiveSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/reactive/ListReactiveCommandIntegrationTests.java
Patch:
@@ -15,4 +15,5 @@ class ListReactiveCommandIntegrationTests extends ListCommandIntegrationTests {
     ListReactiveCommandIntegrationTests(StatefulRedisConnection<String, String> connection) {
         super(ReactiveSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/reactive/NumericReactiveCommandIntegrationTests.java
Patch:
@@ -15,4 +15,5 @@ class NumericReactiveCommandIntegrationTests extends NumericCommandIntegrationTe
     NumericReactiveCommandIntegrationTests(StatefulRedisConnection<String, String> connection) {
         super(ReactiveSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/reactive/ScriptingReactiveCommandIntegrationTests.java
Patch:
@@ -16,4 +16,5 @@ class ScriptingReactiveCommandIntegrationTests extends ScriptingCommandIntegrati
     ScriptingReactiveCommandIntegrationTests(RedisClient client, StatefulRedisConnection<String, String> connection) {
         super(client, ReactiveSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/reactive/SetReactiveCommandIntegrationTests.java
Patch:
@@ -15,4 +15,5 @@ class SetReactiveCommandIntegrationTests extends SetCommandIntegrationTests {
     SetReactiveCommandIntegrationTests(StatefulRedisConnection<String, String> connection) {
         super(ReactiveSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/reactive/SortReactiveCommandIntegrationTests.java
Patch:
@@ -15,4 +15,5 @@ class SortReactiveCommandIntegrationTests extends SortCommandIntegrationTests {
     SortReactiveCommandIntegrationTests(StatefulRedisConnection<String, String> connection) {
         super(ReactiveSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/reactive/SortedSetReactiveCommandIntegrationTests.java
Patch:
@@ -41,4 +41,5 @@ public void zmscore() {
             assertThat(actual).isEqualTo(list(1.0, null, 2.0));
         }).verifyComplete();
     }
+
 }

File: src/test/java/io/lettuce/core/commands/reactive/StreamReactiveCommandIntegrationTests.java
Patch:
@@ -15,4 +15,5 @@ class StreamReactiveCommandIntegrationTests extends StreamCommandIntegrationTest
     StreamReactiveCommandIntegrationTests(StatefulRedisConnection<String, String> connection) {
         super(ReactiveSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/reactive/StringReactiveCommandIntegrationTests.java
Patch:
@@ -19,6 +19,7 @@
 class StringReactiveCommandIntegrationTests extends StringCommandIntegrationTests {
 
     private final RedisCommands<String, String> redis;
+
     private final RedisReactiveCommands<String, String> reactive;
 
     @Inject
@@ -47,4 +48,5 @@ void mgetEmpty() {
         Flux<KeyValue<String, String>> mget = reactive.mget("unknown");
         StepVerifier.create(mget.next()).expectNext(KeyValue.empty("unknown")).verifyComplete();
     }
+
 }

File: src/test/java/io/lettuce/core/commands/transactional/BitTxCommandIntegrationTests.java
Patch:
@@ -15,4 +15,5 @@ class BitTxCommandIntegrationTests extends BitCommandIntegrationTests {
     BitTxCommandIntegrationTests(RedisClient client, StatefulRedisConnection<String, String> connection) {
         super(client, TxSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/transactional/GeoTxCommandIntegrationTests.java
Patch:
@@ -56,4 +56,5 @@ public void geodistInTransaction() {
     @Override
     public void geohashInTransaction() {
     }
+
 }

File: src/test/java/io/lettuce/core/commands/transactional/HLLTxCommandIntegrationTests.java
Patch:
@@ -14,4 +14,5 @@ class HLLTxCommandIntegrationTests extends HLLCommandIntegrationTests {
     HLLTxCommandIntegrationTests(StatefulRedisConnection<String, String> connection) {
         super(TxSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/transactional/HashTxCommandIntegrationTests.java
Patch:
@@ -14,4 +14,5 @@ class HashTxCommandIntegrationTests extends HashCommandIntegrationTests {
     HashTxCommandIntegrationTests(StatefulRedisConnection<String, String> connection) {
         super(TxSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/transactional/KeyTxCommandIntegrationTests.java
Patch:
@@ -21,4 +21,5 @@ public class KeyTxCommandIntegrationTests extends KeyCommandIntegrationTests {
     @Override
     public void move() {
     }
+
 }

File: src/test/java/io/lettuce/core/commands/transactional/ListTxCommandIntegrationTests.java
Patch:
@@ -14,4 +14,5 @@ class ListTxCommandIntegrationTests extends ListCommandIntegrationTests {
     ListTxCommandIntegrationTests(StatefulRedisConnection<String, String> connection) {
         super(TxSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/transactional/SetTxCommandIntegrationTests.java
Patch:
@@ -14,4 +14,5 @@ class SetTxCommandIntegrationTests extends SetCommandIntegrationTests {
     SetTxCommandIntegrationTests(StatefulRedisConnection<String, String> connection) {
         super(TxSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/transactional/SortTxCommandIntegrationTests.java
Patch:
@@ -14,4 +14,5 @@ class SortTxCommandIntegrationTests extends SortCommandIntegrationTests {
     SortTxCommandIntegrationTests(StatefulRedisConnection<String, String> connection) {
         super(TxSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/transactional/SortedSetTxCommandIntegrationTests.java
Patch:
@@ -14,4 +14,5 @@ class SortedSetTxCommandIntegrationTests extends SortedSetCommandIntegrationTest
     SortedSetTxCommandIntegrationTests(StatefulRedisConnection<String, String> connection) {
         super(TxSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/commands/transactional/StringTxCommandIntegrationTests.java
Patch:
@@ -14,4 +14,5 @@ class StringTxCommandIntegrationTests extends StringCommandIntegrationTests {
     StringTxCommandIntegrationTests(StatefulRedisConnection<String, String> connection) {
         super(TxSyncInvocationHandler.sync(connection));
     }
+
 }

File: src/test/java/io/lettuce/core/dynamic/CommandSegmentCommandFactoryUnitTests.java
Patch:
@@ -188,12 +188,15 @@ private interface Commands {
 
         @Command("XYZ")
         boolean unknownCommand();
+
     }
 
     private static interface MethodsWithTimeout {
 
         Future<String> async(String key, Timeout timeout);
 
         String sync(String key, Timeout timeout);
+
     }
+
 }

File: src/test/java/io/lettuce/core/dynamic/DeclaredCommandMethodUnitTests.java
Patch:
@@ -52,5 +52,7 @@ private interface MyInterface {
         Future<String> getFuture();
 
         Flux<String> getFlux();
+
     }
+
 }

File: src/test/java/io/lettuce/core/dynamic/DefaultCommandMethodVerifierUnitTests.java
Patch:
@@ -132,5 +132,7 @@ private static interface MyInterface {
         void lpop(@Param("key") String key);
 
         void rpop(String key1, String key2);
+
     }
+
 }

File: src/test/java/io/lettuce/core/dynamic/ReactiveCommandSegmentCommandFactoryUnitTests.java
Patch:
@@ -81,5 +81,7 @@ private static interface ReactiveWithTimeout {
         Mono<String> getOne(String key);
 
         Flux<String> getMany(String key);
+
     }
+
 }

File: src/test/java/io/lettuce/core/dynamic/ReactiveTypeAdaptersUnitTests.java
Patch:
@@ -244,4 +244,5 @@ void toWrapperShouldConvertMonoToFlux() {
         Mono<String> foo = Mono.just("foo");
         assertThat(conversionService.convert(foo, Flux.class)).isInstanceOf(Flux.class);
     }
+
 }

File: src/test/java/io/lettuce/core/dynamic/RedisCommandsAsyncIntegrationTests.java
Patch:
@@ -40,6 +40,9 @@ void async() {
     }
 
     static interface MultipleExecutionModels extends Commands {
+
         Future<String> set(String key, String value);
+
     }
+
 }

File: src/test/java/io/lettuce/core/dynamic/RedisCommandsBatchingIntegrationTests.java
Patch:
@@ -218,6 +218,7 @@ static interface Batching extends Commands {
 
         @Command("LLEN")
         RedisFuture<Long> llenAsync(String key);
+
     }
 
     static interface SelectiveBatching extends Commands, BatchExecutor {

File: src/test/java/io/lettuce/core/dynamic/RedisCommandsClusterIntegrationTests.java
Patch:
@@ -86,6 +86,7 @@ interface SynchronousCommands extends Commands {
 
         @Command("MGET")
         List<Value<String>> mgetAsValues(String... keys);
+
     }
 
 }

File: src/test/java/io/lettuce/core/dynamic/RedisCommandsReactiveIntegrationTests.java
Patch:
@@ -94,5 +94,7 @@ interface MultipleExecutionModels extends Commands {
 
         @Command("GET")
         Maybe<String> getRxJava(String key);
+
     }
+
 }

File: src/test/java/io/lettuce/core/dynamic/RedisCommandsSyncIntegrationTests.java
Patch:
@@ -30,6 +30,7 @@
 class RedisCommandsSyncIntegrationTests extends TestSupport {
 
     private final RedisClient client;
+
     private final RedisCommands<String, String> redis;
 
     @Inject
@@ -118,6 +119,7 @@ static int someStaticMethod() {
 
         @Command("MGET")
         List<Value<String>> mgetAsValues(String... keys);
+
     }
 
 }

File: src/test/java/io/lettuce/core/dynamic/SimpleBatcherUnitTests.java
Patch:
@@ -127,4 +127,5 @@ void shouldBatchWithBatchControlFlush() {
     private static RedisCommand<Object, Object, Object> createCommand() {
         return new AsyncCommand<>(new Command<>(CommandType.COMMAND, null, null));
     }
+
 }

File: src/test/java/io/lettuce/core/dynamic/codec/AnnotationRedisCodecResolverUnitTests.java
Patch:
@@ -147,6 +147,7 @@ private static interface CommandMethods {
         String withWrappers(@Value Range<String> range, @Value io.lettuce.core.Value<Number> value);
 
         String withMap(Map<Integer, String> map);
+
     }
 
 }

File: src/test/java/io/lettuce/core/dynamic/codec/ParameterWrappersUnitTests.java
Patch:
@@ -127,6 +127,7 @@ String withWrappers(Range<String> range, io.lettuce.core.Value<Number> value,
         String withList(List<String> map);
 
         String withMap(Map<Integer, String> map);
+
     }
 
 }

File: src/test/java/io/lettuce/core/dynamic/output/CodecAwareOutputResolverUnitTests.java
Patch:
@@ -96,6 +96,7 @@ private static interface CommandMethods {
         String string();
 
         ByteBuffer byteBuffer();
+
     }
 
     private static class ByteBufferAndStringCodec implements RedisCodec<ByteBuffer, String> {
@@ -119,5 +120,7 @@ public ByteBuffer encodeKey(ByteBuffer key) {
         public ByteBuffer encodeValue(String value) {
             return null;
         }
+
     }
+
 }

File: src/test/java/io/lettuce/core/dynamic/output/OutputRegistryUnitTests.java
Patch:
@@ -93,12 +93,15 @@ private static abstract class IntermediateOutput<K1, V1> extends CommandOutput<K
         IntermediateOutput(RedisCodec<K1, V1> codec, V1 output) {
             super(codec, null);
         }
+
     }
 
     private static class KeyTypedOutput extends IntermediateOutput<ByteBuffer, byte[]> {
 
         KeyTypedOutput(RedisCodec<ByteBuffer, byte[]> codec) {
             super(codec, null);
         }
+
     }
+
 }

File: src/test/java/io/lettuce/core/dynamic/support/ParametrizedTypeInformationUnitTests.java
Patch:
@@ -93,6 +93,7 @@ private static interface TestType {
         List<?> anything();
 
         List<? extends Number> numberOrSubtype();
+
     }
 
     private static interface ListOfNumber extends List<Number> {
@@ -122,4 +123,5 @@ private static interface ListOfString extends List<String> {
     private static interface ListOfInteger extends List<Integer> {
 
     }
+
 }

File: src/test/java/io/lettuce/core/dynamic/support/WildcardTypeInformationUnitTests.java
Patch:
@@ -95,5 +95,7 @@ private static interface GenericReturnTypes {
         List<Float> exactFloat();
 
         List<? extends Number> atLeastNumber();
+
     }
+
 }

File: src/test/java/io/lettuce/core/event/ConnectionEventsTriggeredIntegrationTests.java
Patch:
@@ -37,4 +37,5 @@ void testConnectionEvents() {
 
         FastShutdown.shutdown(client);
     }
+
 }

File: src/test/java/io/lettuce/core/event/DefaultEventBusUnitTests.java
Patch:
@@ -45,4 +45,5 @@ void publishToMultipleSubscribers() throws Exception {
         assertThat(arrayQueue.take()).isEqualTo(event);
         disposable1.dispose();
     }
+
 }

File: src/test/java/io/lettuce/core/event/DefaultEventPublisherOptionsUnitTests.java
Patch:
@@ -36,4 +36,5 @@ void testBuilder() {
 
         assertThat(sut.eventEmitInterval()).isEqualTo(Duration.ofSeconds(1));
     }
+
 }

File: src/test/java/io/lettuce/core/internal/AbstractInvocationHandlerUnitTests.java
Patch:
@@ -57,10 +57,13 @@ static class InvocationHandler extends AbstractInvocationHandler {
         protected Object handleInvocation(Object proxy, Method method, Object[] args) {
             return 1;
         }
+
     }
 
     static interface ReturnOne {
+
         int returnOne();
+
     }
 
 }

File: src/test/java/io/lettuce/core/internal/FuturesUnitTests.java
Patch:
@@ -55,4 +55,5 @@ void awaitAllShouldSetInterruptedBit() {
 
         assertThat(Thread.currentThread().isInterrupted()).isTrue();
     }
+
 }

File: src/test/java/io/lettuce/core/internal/HostAndPortUnitTests.java
Patch:
@@ -168,4 +168,5 @@ private static void checkFromCompatCase(String hpString, String expectHost, int
         assertThat(hostAndPort.getPort()).isEqualTo(expectPort);
 
     }
+
 }

File: src/main/java/io/lettuce/core/protocol/CommandType.java
Patch:
@@ -46,7 +46,7 @@ public enum CommandType implements ProtocolKeyword {
 
     // Keys
 
-    COPY, DEL, DUMP, EXISTS, EXPIRE, EXPIREAT, EXPIRETIME, KEYS, MIGRATE, MOVE, OBJECT, PERSIST, PEXPIRE, PEXPIREAT, PEXPIRETIME, PTTL, RANDOMKEY, RENAME, RENAMENX, RESTORE, TOUCH, TTL, TYPE, SCAN, UNLINK,
+    COPY, DEL, DUMP, EXISTS, HEXPIRE, EXPIRE, HEXPIREAT, EXPIREAT, HEXPIRETIME, EXPIRETIME, KEYS, MIGRATE, MOVE, OBJECT, HPERSIST, PERSIST, PEXPIRE, PEXPIREAT, PEXPIRETIME, PTTL, RANDOMKEY, RENAME, RENAMENX, RESTORE, TOUCH, TTL, TYPE, SCAN, UNLINK,
 
     // String
 

File: src/main/java/io/lettuce/core/protocol/CommandKeyword.java
Patch:
@@ -41,7 +41,7 @@ public enum CommandKeyword implements ProtocolKeyword {
 
     IDLETIME, JUSTID, KILL, KEYSLOT, LEFT, LEN, LIMIT, LIST, LOAD, LOG, MATCH,
 
-    MAX, MAXLEN, MEET, MIN, MINID, MOVED, NO, NOACK, NOCOMMANDS, NODE, NODES, NOMKSTREAM, NOPASS, NOSAVE, NOT, NUMSUB, SHARDCHANNELS, SHARDNUMSUB, NUMPAT, NX, OFF, ON, ONE, OR, PAUSE,
+    MAX, MAXLEN, MEET, MIN, MINID, MOVED, NO, NOACK, NOCOMMANDS, NODE, NODES, NOMKSTREAM, NOPASS, NOSAVE, NOT, NOVALUES, NUMSUB, SHARDCHANNELS, SHARDNUMSUB, NUMPAT, NX, OFF, ON, ONE, OR, PAUSE,
 
     REFCOUNT, REMOVE, RELOAD, REPLACE, REPLICATE, REPLICAS, REV, RESET, RESETCHANNELS, RESETKEYS, RESETPASS,
 

File: src/main/java/io/lettuce/core/protocol/CommandKeyword.java
Patch:
@@ -25,6 +25,7 @@
  * @author Zhang Jessey
  * @author dengliming
  * @author Tihomir Mateev
+ * @author Ali Takavci
  */
 public enum CommandKeyword implements ProtocolKeyword {
 
@@ -36,7 +37,7 @@ public enum CommandKeyword implements ProtocolKeyword {
 
     IDLETIME, JUSTID, KILL, KEYSLOT, LEFT, LEN, LIMIT, LIST, LOAD, LOG, MATCH,
 
-    MAX, MAXLEN, MEET, MIN, MINID, MOVED, NO, NOACK, NOCOMMANDS, NODE, NODES, NOMKSTREAM, NOPASS, NOSAVE, NOT, NUMSUB, SHARDNUMSUB, NUMPAT, NX, OFF, ON, ONE, OR, PAUSE,
+    MAX, MAXLEN, MEET, MIN, MINID, MOVED, NO, NOACK, NOCOMMANDS, NODE, NODES, NOMKSTREAM, NOPASS, NOSAVE, NOT, NUMSUB, SHARDCHANNELS, SHARDNUMSUB, NUMPAT, NX, OFF, ON, ONE, OR, PAUSE,
 
     REFCOUNT, REMOVE, RELOAD, REPLACE, REPLICATE, REPLICAS, REV, RESET, RESETCHANNELS, RESETKEYS, RESETPASS,
 

File: src/main/java/io/lettuce/core/AbstractRedisClient.java
Patch:
@@ -30,6 +30,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import reactor.core.publisher.Mono;
 import io.lettuce.core.event.command.CommandListener;
 import io.lettuce.core.event.connection.ConnectEvent;
 import io.lettuce.core.event.connection.ConnectionCreatedEvent;
@@ -60,7 +61,6 @@
 import io.netty.util.concurrent.Future;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
-import reactor.core.publisher.Mono;
 
 /**
  * Base Redis client. This class holds the netty infrastructure, {@link ClientOptions} and the basic connection procedure. This
@@ -302,7 +302,8 @@ protected void channelType(ConnectionBuilder connectionBuilder, ConnectionPoint
 
         boolean domainSocket = LettuceStrings.isNotEmpty(connectionPoint.getSocket());
         connectionBuilder.bootstrap().group(
-                getEventLoopGroup(domainSocket ? NativeTransports.eventLoopGroupClass() : Transports.eventLoopGroupClass()));
+                getEventLoopGroup(
+                        domainSocket ? NativeTransports.eventLoopGroupClass(true) : Transports.eventLoopGroupClass()));
 
         if (connectionPoint.getSocket() != null) {
             NativeTransports.assertDomainSocketAvailable();

File: src/main/java/io/lettuce/core/ConnectionBuilder.java
Patch:
@@ -23,6 +23,8 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 
+import jdk.net.ExtendedSocketOptions;
+import reactor.core.publisher.Mono;
 import io.lettuce.core.internal.LettuceAssert;
 import io.lettuce.core.protocol.CommandEncoder;
 import io.lettuce.core.protocol.CommandHandler;
@@ -48,8 +50,6 @@
 import io.netty.util.AttributeKey;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
-import jdk.net.ExtendedSocketOptions;
-import reactor.core.publisher.Mono;
 
 /**
  * Connection builder for connections. This class is part of the internal API.
@@ -252,7 +252,7 @@ public void configureBootstrap(boolean domainSocket,
         if (domainSocket) {
 
             Transports.NativeTransports.assertDomainSocketAvailable();
-            eventLoopGroupClass = Transports.NativeTransports.eventLoopGroupClass();
+            eventLoopGroupClass = Transports.NativeTransports.eventLoopGroupClass(true);
             channelClass = Transports.NativeTransports.domainSocketChannelClass();
         } else {
             bootstrap.resolver(clientResources.addressResolverGroup());

File: src/main/java/io/lettuce/core/pubsub/PubSubEndpoint.java
Patch:
@@ -28,6 +28,7 @@
 import io.lettuce.core.RedisException;
 import io.lettuce.core.protocol.CommandType;
 import io.lettuce.core.protocol.DefaultEndpoint;
+import io.lettuce.core.protocol.ProtocolVersion;
 import io.lettuce.core.protocol.RedisCommand;
 import io.lettuce.core.resource.ClientResources;
 import io.netty.channel.Channel;
@@ -193,8 +194,8 @@ protected boolean containsViolatingCommands(Collection<? extends RedisCommand<?,
         return false;
     }
 
-    private static boolean isAllowed(RedisCommand<?, ?, ?> command) {
-        return ALLOWED_COMMANDS_SUBSCRIBED.contains(command.getType().name());
+    private boolean isAllowed(RedisCommand<?, ?, ?> command) {
+        return getProtocolVersion() == ProtocolVersion.RESP3 || ALLOWED_COMMANDS_SUBSCRIBED.contains(command.getType().name());
     }
 
     public boolean isSubscribed() {

File: src/main/java/io/lettuce/core/RedisCommandBuilder.java
Patch:
@@ -52,6 +52,7 @@
  * @author Tugdual Grall
  * @author dengliming
  * @author Mikhael Sokolov
+ * @author Tihomir Mateev
  */
 @SuppressWarnings({ "unchecked", "varargs" })
 class RedisCommandBuilder<K, V> extends BaseRedisCommandBuilder<K, V> {

File: src/main/java/io/lettuce/core/protocol/CommandKeyword.java
Patch:
@@ -24,6 +24,7 @@
  * @author Mark Paluch
  * @author Zhang Jessey
  * @author dengliming
+ * @author Tihomir Mateev
  */
 public enum CommandKeyword implements ProtocolKeyword {
 

File: src/main/templates/io/lettuce/core/api/BaseRedisCommands.java
Patch:
@@ -29,6 +29,7 @@
  * @param <K> Key type.
  * @param <V> Value type.
  * @author Mark Paluch
+ * @author Tihomir Mateev
  * @since 4.0
  */
 public interface BaseRedisCommands<K, V> {

File: src/test/jmh/io/lettuce/core/cluster/ClusterDistributionChannelWriterBenchmark.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
+import io.lettuce.core.protocol.ConnectionIntent;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.Scope;
 import org.openjdk.jmh.annotations.Setup;
@@ -69,7 +70,7 @@ public class ClusterDistributionChannelWriterBenchmark {
     @Setup
     public void setup() {
 
-        writer = new ClusterDistributionChannelWriter(CLIENT_OPTIONS, EMPTY_WRITER, ClusterEventListener.NO_OP);
+        writer = new ClusterDistributionChannelWriter(EMPTY_WRITER, CLIENT_OPTIONS, ClusterEventListener.NO_OP);
 
         Partitions partitions = new Partitions();
 

File: src/main/java/io/lettuce/core/RedisURI.java
Patch:
@@ -652,7 +652,7 @@ public String getLibraryName() {
      * Sets the library name to be applied on Redis connections.
      *
      * @param libraryName the library name.
-     * @since 4.4
+     * @since 6.3
      */
     public void setLibraryName(String libraryName) {
         if (libraryName != null && libraryName.indexOf(' ') != -1) {
@@ -675,7 +675,7 @@ public String getLibraryVersion() {
      * Sets the library version to be applied on Redis connections.
      *
      * @param libraryVersion the library version.
-     * @since 4.4
+     * @since 6.3
      */
     public void setLibraryVersion(String libraryVersion) {
         if (libraryVersion != null && libraryVersion.indexOf(' ') != -1) {

File: src/main/java/io/lettuce/core/SetArgs.java
Patch:
@@ -75,7 +75,7 @@ public static SetArgs ex(long timeout) {
         /**
          * Creates new {@link SetArgs} and enable {@literal EX}.
          *
-         * @param timeout expire time in seconds.
+         * @param timeout expire time as duration.
          * @return new {@link SetArgs} with {@literal EX} enabled.
          * @see SetArgs#ex(long)
          * @since 6.1

File: src/test/java/io/lettuce/core/masterreplica/MasterReplicaChannelWriterUnitTests.java
Patch:
@@ -55,8 +55,7 @@ class MasterReplicaChannelWriterUnitTests {
     @Mock
     private ClientResources clientResources;
 
-    @Mock
-    private ClientOptions clientOptions;
+    private ClientOptions clientOptions = ClientOptions.create();
 
     @Mock
     private StatefulRedisConnection<String, String> connection;

File: src/main/java/io/lettuce/core/XAddArgs.java
Patch:
@@ -29,7 +29,7 @@
  * @author dengliming
  * @since 5.1
  */
-public class XAddArgs {
+public class XAddArgs implements CompositeArgument {
 
     private String id;
 
@@ -89,6 +89,7 @@ public static XAddArgs nomkstream() {
         public static XAddArgs minId(String minid) {
             return new XAddArgs().minId(minid);
         }
+
     }
 
     /**

File: src/main/java/io/lettuce/core/XClaimArgs.java
Patch:
@@ -33,7 +33,7 @@
  * @author Mark Paluch
  * @since 5.1
  */
-public class XClaimArgs {
+public class XClaimArgs implements CompositeArgument {
 
     long minIdleTime;
 

File: src/main/java/io/lettuce/core/XGroupCreateArgs.java
Patch:
@@ -26,7 +26,7 @@
  * @author Mark Paluch
  * @since 5.2
  */
-public class XGroupCreateArgs {
+public class XGroupCreateArgs implements CompositeArgument {
 
     private boolean mkstream;
 

File: src/main/java/io/lettuce/core/XReadArgs.java
Patch:
@@ -30,7 +30,7 @@
  * @author Mark Paluch
  * @since 5.1
  */
-public class XReadArgs {
+public class XReadArgs implements CompositeArgument {
 
     private Long block;
 

File: src/main/java/io/lettuce/core/ConcurrentLruCache.java
Patch:
@@ -171,7 +171,7 @@ public int size() {
     }
 
     /**
-     * Return the the maximum number of entries in the cache (0 indicates no caching, always generating a new value).
+     * Return the maximum number of entries in the cache (0 indicates no caching, always generating a new value).
      *
      * @see #size()
      */

File: src/main/java/io/lettuce/core/SocketOptions.java
Patch:
@@ -324,7 +324,7 @@ private Builder() {
             }
 
             /**
-             * Set the the maximum number of keepalive probes TCP should send before dropping the connection. Defaults to
+             * Set the maximum number of keepalive probes TCP should send before dropping the connection. Defaults to
              * {@code 9}. See also {@link #DEFAULT_COUNT} and {@code TCP_KEEPCNT}.
              *
              * @param count the maximum number of keepalive probes TCP

File: src/main/java/io/lettuce/core/metrics/MetricCollector.java
Patch:
@@ -33,7 +33,7 @@ public interface MetricCollector<T> {
     /**
      * Returns the collected/aggregated metrics.
      *
-     * @return the the collected/aggregated metrics
+     * @return the collected/aggregated metrics
      */
     T retrieveMetrics();
 

File: src/main/java/io/lettuce/core/protocol/CommandWrapper.java
Patch:
@@ -264,7 +264,7 @@ public static <K, V, T> RedisCommand<K, V, T> unwrap(RedisCommand<K, V, T> wrapp
      *
      * If the receiver implements the interface then the result is the receiver or a proxy for the receiver. If the receiver is
      * a wrapper and the wrapped object implements the interface then the result is the wrapped object or a proxy for the
-     * wrapped object. Otherwise return the the result of calling <code>unwrap</code> recursively on the wrapped object or a
+     * wrapped object. Otherwise return the result of calling <code>unwrap</code> recursively on the wrapped object or a
      * proxy for that result. If the receiver is not a wrapper and does not implement the interface, then an {@code null} is
      * returned.
      *

File: src/main/java/io/lettuce/core/ReadFrom.java
Patch:
@@ -57,14 +57,14 @@ public abstract class ReadFrom {
     public static final ReadFrom UPSTREAM_PREFERRED = new ReadFromImpl.ReadFromUpstreamPreferred();
 
     /**
-     * Setting to read preferred from replica and fall back to upstream if no replica is not available.
+     * Setting to read preferred from replica and fall back to upstream if no replica is available.
      *
      * @since 5.2
      */
     public static final ReadFrom REPLICA_PREFERRED = new ReadFromImpl.ReadFromReplicaPreferred();
 
     /**
-     * Setting to read preferred from replicas and fall back to upstream if no replica is not available.
+     * Setting to read preferred from replicas and fall back to upstream if no replica is available.
      *
      * @since 4.4
      * @deprecated Renamed to {@link #REPLICA_PREFERRED}.

File: src/main/java/io/lettuce/core/RedisURI.java
Patch:
@@ -1461,7 +1461,7 @@ public Builder withSsl(RedisURI source) {
             LettuceAssert.notNull(source, "Source RedisURI must not be null");
 
             withSsl(source.isSsl());
-            withVerifyPeer(source.isVerifyPeer());
+            withVerifyPeer(source.getVerifyMode());
             withStartTls(source.isStartTls());
 
             return this;

File: src/main/java/io/lettuce/core/output/BooleanOutput.java
Patch:
@@ -16,6 +16,7 @@
 package io.lettuce.core.output;
 
 import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
 
 import io.lettuce.core.codec.RedisCodec;
 
@@ -41,7 +42,7 @@ public void set(long integer) {
 
     @Override
     public void set(ByteBuffer bytes) {
-        output = (bytes != null) ? Boolean.TRUE : Boolean.FALSE;
+        output = (bytes != null) ? Boolean.parseBoolean(StandardCharsets.UTF_8.decode(bytes).toString()) : Boolean.FALSE;
     }
 
     @Override

File: src/test/java/io/lettuce/core/commands/AclCommandIntegrationTests.java
Patch:
@@ -78,7 +78,7 @@ void aclDeluser() {
     void aclDryRun() {
         assertThatThrownBy(() -> redis.aclDryRun("non-existing", "GET", "foo", "bar"))
                 .isInstanceOf(RedisCommandExecutionException.class).hasMessageContaining("ERR User 'non-existing' not found");
-        assertThat(redis.aclDryRun("default", "GET", "foo", "bar")).isEqualTo("OK");
+        assertThat(redis.aclDryRun("default", "GET", "foo")).isEqualTo("OK");
 
         AclSetuserArgs args = AclSetuserArgs.Builder.on().addCommand(CommandType.GET).keyPattern("objects:*")
                 .addPassword("foobared");

File: src/main/java/io/lettuce/core/cluster/ClusterDistributionChannelWriter.java
Patch:
@@ -49,6 +49,7 @@
 import io.lettuce.core.protocol.CommandKeyword;
 import io.lettuce.core.protocol.CommandType;
 import io.lettuce.core.protocol.ConnectionFacade;
+import io.lettuce.core.protocol.ConnectionIntent;
 import io.lettuce.core.protocol.DefaultEndpoint;
 import io.lettuce.core.protocol.ProtocolKeyword;
 import io.lettuce.core.protocol.RedisCommand;

File: src/main/java/io/lettuce/core/cluster/ClusterFutureSyncInvocationHandler.java
Patch:
@@ -36,6 +36,7 @@
 import io.lettuce.core.internal.DefaultMethods;
 import io.lettuce.core.internal.Futures;
 import io.lettuce.core.internal.TimeoutProvider;
+import io.lettuce.core.protocol.ConnectionIntent;
 import io.lettuce.core.protocol.RedisCommand;
 
 /**

File: src/main/java/io/lettuce/core/cluster/ClusterNodeConnectionFactory.java
Patch:
@@ -21,6 +21,7 @@
 import io.lettuce.core.ConnectionFuture;
 import io.lettuce.core.api.StatefulRedisConnection;
 import io.lettuce.core.cluster.models.partitions.Partitions;
+import io.lettuce.core.protocol.ConnectionIntent;
 
 /**
  * Specialized {@link Function} to obtain connections for Redis Cluster nodes. Connecting to a node returns a

File: src/main/java/io/lettuce/core/cluster/DynamicNodeSelection.java
Patch:
@@ -24,6 +24,7 @@
 import io.lettuce.core.RedisURI;
 import io.lettuce.core.api.StatefulRedisConnection;
 import io.lettuce.core.cluster.models.partitions.RedisClusterNode;
+import io.lettuce.core.protocol.ConnectionIntent;
 
 /**
  * Dynamic selection of nodes.

File: src/main/java/io/lettuce/core/cluster/PooledClusterConnectionProvider.java
Patch:
@@ -49,6 +49,7 @@
 import io.lettuce.core.internal.HostAndPort;
 import io.lettuce.core.internal.LettuceAssert;
 import io.lettuce.core.models.role.RedisNodeDescription;
+import io.lettuce.core.protocol.ConnectionIntent;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 

File: src/main/java/io/lettuce/core/cluster/RedisAdvancedClusterAsyncCommandsImpl.java
Patch:
@@ -54,6 +54,7 @@
 import io.lettuce.core.protocol.AsyncCommand;
 import io.lettuce.core.protocol.Command;
 import io.lettuce.core.protocol.CommandType;
+import io.lettuce.core.protocol.ConnectionIntent;
 
 /**
  * An advanced asynchronous and thread-safe API for a Redis Cluster connection.

File: src/main/java/io/lettuce/core/cluster/RedisAdvancedClusterReactiveCommandsImpl.java
Patch:
@@ -48,6 +48,7 @@
 import io.lettuce.core.internal.LettuceLists;
 import io.lettuce.core.output.KeyStreamingChannel;
 import io.lettuce.core.output.KeyValueStreamingChannel;
+import io.lettuce.core.protocol.ConnectionIntent;
 
 /**
  * An advanced reactive and thread-safe API to a Redis Cluster connection.

File: src/main/java/io/lettuce/core/cluster/RedisClusterPubSubAsyncCommandsImpl.java
Patch:
@@ -35,6 +35,7 @@
 import io.lettuce.core.cluster.pubsub.api.async.PubSubAsyncNodeSelection;
 import io.lettuce.core.cluster.pubsub.api.async.RedisClusterPubSubAsyncCommands;
 import io.lettuce.core.codec.RedisCodec;
+import io.lettuce.core.protocol.ConnectionIntent;
 import io.lettuce.core.pubsub.RedisPubSubAsyncCommandsImpl;
 import io.lettuce.core.pubsub.StatefulRedisPubSubConnection;
 import io.lettuce.core.pubsub.api.async.RedisPubSubAsyncCommands;

File: src/main/java/io/lettuce/core/cluster/RedisClusterPubSubReactiveCommandsImpl.java
Patch:
@@ -34,6 +34,7 @@
 import io.lettuce.core.cluster.pubsub.api.reactive.PubSubReactiveNodeSelection;
 import io.lettuce.core.cluster.pubsub.api.reactive.RedisClusterPubSubReactiveCommands;
 import io.lettuce.core.codec.RedisCodec;
+import io.lettuce.core.protocol.ConnectionIntent;
 import io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl;
 import io.lettuce.core.pubsub.StatefulRedisPubSubConnection;
 import io.lettuce.core.pubsub.api.reactive.RedisPubSubReactiveCommands;

File: src/main/java/io/lettuce/core/cluster/StatefulRedisClusterPubSubConnectionImpl.java
Patch:
@@ -39,6 +39,7 @@
 import io.lettuce.core.cluster.pubsub.api.sync.RedisClusterPubSubCommands;
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.internal.LettuceAssert;
+import io.lettuce.core.protocol.ConnectionIntent;
 import io.lettuce.core.pubsub.RedisPubSubAsyncCommandsImpl;
 import io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl;
 import io.lettuce.core.pubsub.StatefulRedisPubSubConnection;

File: src/main/java/io/lettuce/core/cluster/StaticNodeSelection.java
Patch:
@@ -24,6 +24,7 @@
 import io.lettuce.core.RedisURI;
 import io.lettuce.core.api.StatefulRedisConnection;
 import io.lettuce.core.cluster.models.partitions.RedisClusterNode;
+import io.lettuce.core.protocol.ConnectionIntent;
 
 /**
  * Static selection of nodes.

File: src/test/java/io/lettuce/core/cluster/AsyncConnectionProviderIntegrationTests.java
Patch:
@@ -15,8 +15,7 @@
  */
 package io.lettuce.core.cluster;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.assertj.core.api.Assertions.*;
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
@@ -42,6 +41,7 @@
 import io.lettuce.core.cluster.ClusterNodeConnectionFactory.ConnectionKey;
 import io.lettuce.core.codec.StringCodec;
 import io.lettuce.core.internal.AsyncConnectionProvider;
+import io.lettuce.core.protocol.ConnectionIntent;
 import io.lettuce.core.protocol.ProtocolVersion;
 import io.lettuce.core.resource.ClientResources;
 import io.lettuce.test.LettuceExtension;

File: src/test/java/io/lettuce/core/cluster/ClusterDistributionChannelWriterUnitTests.java
Patch:
@@ -47,6 +47,7 @@
 import io.lettuce.core.protocol.CommandArgs;
 import io.lettuce.core.protocol.CommandExpiryWriter;
 import io.lettuce.core.protocol.CommandType;
+import io.lettuce.core.protocol.ConnectionIntent;
 import io.lettuce.core.protocol.DefaultEndpoint;
 import io.lettuce.core.protocol.RedisCommand;
 import io.lettuce.core.resource.ClientResources;

File: src/test/java/io/lettuce/core/cluster/PooledClusterConnectionProviderUnitTests.java
Patch:
@@ -53,6 +53,7 @@
 import io.lettuce.core.protocol.AsyncCommand;
 import io.lettuce.core.protocol.Command;
 import io.lettuce.core.protocol.CommandType;
+import io.lettuce.core.protocol.ConnectionIntent;
 import io.lettuce.core.resource.ClientResources;
 
 /**

File: src/test/java/io/lettuce/core/masterreplica/MasterReplicaConnectionProviderUnitTests.java
Patch:
@@ -39,6 +39,7 @@
 import io.lettuce.core.api.sync.RedisCommands;
 import io.lettuce.core.codec.StringCodec;
 import io.lettuce.core.models.role.RedisInstance;
+import io.lettuce.core.protocol.ConnectionIntent;
 
 /**
  * @author Mark Paluch
@@ -78,11 +79,12 @@ void shouldCloseConnections() {
         when(clientMock.connectAsync(eq(StringCodec.UTF8), any()))
                 .thenReturn(ConnectionFuture.completed(null, nodeConnectionMock));
 
-        StatefulRedisConnection<String, String> connection = sut.getConnection(MasterReplicaConnectionProvider.Intent.READ);
+        StatefulRedisConnection<String, String> connection = sut.getConnection(ConnectionIntent.READ);
         assertThat(connection).isNotNull();
 
         sut.close();
 
         verify(channelHandlerMock).closeAsync();
     }
+
 }

File: src/main/java/io/lettuce/core/resource/DecorrelatedJitterDelay.java
Patch:
@@ -63,7 +63,7 @@ class DecorrelatedJitterDelay extends Delay implements StatefulDelay {
     public Duration createDelay(long attempt) {
         long value = randomBetween(base, Math.max(base, prevDelay * 3));
         Duration delay = applyBounds(Duration.ofNanos(targetTimeUnit.toNanos(value)), lower, upper);
-        prevDelay = delay.toNanos();
+        prevDelay = targetTimeUnit.convert(delay.toNanos(), TimeUnit.NANOSECONDS);
         return delay;
     }
 

File: src/main/java/io/lettuce/core/resource/Delay.java
Patch:
@@ -325,7 +325,7 @@ public static Supplier<Delay> decorrelatedJitter(long lower, long upper, long ba
      * @see ThreadLocalRandom#nextLong(long, long)
      */
     protected static long randomBetween(long min, long max) {
-        if (min == max) {
+        if (min >= max) {
             return min;
         }
         return ThreadLocalRandom.current().nextLong(min, max);

File: src/main/java/io/lettuce/core/resource/ExponentialDelay.java
Patch:
@@ -91,8 +91,8 @@ protected static long calculatePowerOfTwo(long attempt) {
 
         if (attempt <= 0) { // safeguard against underflow
             return 0L;
-        } else if (attempt >= 64) { // safeguard against overflow in the bitshift operation
-            return Long.MAX_VALUE;
+        } else if (attempt >= 63) { // safeguard against overflow in the bitshift operation
+            return Long.MAX_VALUE - 1;
         } else {
             return 1L << (attempt - 1);
         }

File: src/main/java/io/lettuce/core/resource/FullJitterDelay.java
Patch:
@@ -53,7 +53,8 @@ class FullJitterDelay extends ExponentialDelay {
     public Duration createDelay(long attempt) {
 
         long upperTarget = targetTimeUnit.convert(upper.toNanos(), TimeUnit.NANOSECONDS);
-        long temp = Math.min(upperTarget, base * calculatePowerOfTwo(attempt));
+        long upperBase = base * calculatePowerOfTwo(attempt);
+        long temp = Math.min(upperTarget, 0 > upperBase ? upperTarget : upperBase);
         long delay = temp / 2 + randomBetween(0, temp / 2);
         return applyBounds(Duration.ofNanos(targetTimeUnit.toNanos(delay)));
     }

File: src/main/java/io/lettuce/core/api/async/RedisServerAsyncCommands.java
Patch:
@@ -188,7 +188,7 @@ public interface RedisServerAsyncCommands<K, V> {
      *
      * @param parameters patterns names of Redis server's configuration.
      * @return Map&lt;String, String&gt; bulk-string-reply.
-     * @since 7.0
+     * @since 6.2
      */
     RedisFuture<Map<String, String>> configGet(String... parameters);
 
@@ -221,7 +221,7 @@ public interface RedisServerAsyncCommands<K, V> {
      *
      * @param kvs the parameter name and value.
      * @return String simple-string-reply: {@code OK} when the configuration was set properly. Otherwise an error is returned.
-     * @since 7.0
+     * @since 6.2
      */
     RedisFuture<String> configSet(Map<String, String> kvs);
 

File: src/main/java/io/lettuce/core/api/reactive/RedisServerReactiveCommands.java
Patch:
@@ -188,7 +188,7 @@ public interface RedisServerReactiveCommands<K, V> {
      *
      * @param parameters patterns names of Redis server's configuration.
      * @return Map&lt;String, String&gt; bulk-string-reply.
-     * @since 7.0
+     * @since 6.2
      */
     Mono<Map<String, String>> configGet(String... parameters);
 
@@ -221,7 +221,7 @@ public interface RedisServerReactiveCommands<K, V> {
      *
      * @param kvs the parameter name and value.
      * @return String simple-string-reply: {@code OK} when the configuration was set properly. Otherwise an error is returned.
-     * @since 7.0
+     * @since 6.2
      */
     Mono<String> configSet(Map<String, String> kvs);
 

File: src/main/java/io/lettuce/core/api/sync/RedisServerCommands.java
Patch:
@@ -187,7 +187,7 @@ public interface RedisServerCommands<K, V> {
      *
      * @param parameters patterns names of Redis server's configuration.
      * @return Map&lt;String, String&gt; bulk-string-reply.
-     * @since 7.0
+     * @since 6.2
      */
     Map<String, String> configGet(String... parameters);
 
@@ -220,7 +220,7 @@ public interface RedisServerCommands<K, V> {
      *
      * @param kvs the parameter name and value.
      * @return String simple-string-reply: {@code OK} when the configuration was set properly. Otherwise an error is returned.
-     * @since 7.0
+     * @since 6.2
      */
     String configSet(Map<String, String> kvs);
 

File: src/main/java/io/lettuce/core/cluster/api/async/NodeSelectionServerAsyncCommands.java
Patch:
@@ -186,7 +186,7 @@ public interface NodeSelectionServerAsyncCommands<K, V> {
      *
      * @param parameters patterns names of Redis server's configuration.
      * @return Map&lt;String, String&gt; bulk-string-reply.
-     * @since 7.0
+     * @since 6.2
      */
     AsyncExecutions<Map<String, String>> configGet(String... parameters);
 
@@ -219,7 +219,7 @@ public interface NodeSelectionServerAsyncCommands<K, V> {
      *
      * @param kvs the parameter name and value.
      * @return String simple-string-reply: {@code OK} when the configuration was set properly. Otherwise an error is returned.
-     * @since 7.0
+     * @since 6.2
      */
     AsyncExecutions<String> configSet(Map<String, String> kvs);
 

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionServerCommands.java
Patch:
@@ -186,7 +186,7 @@ public interface NodeSelectionServerCommands<K, V> {
      *
      * @param parameters patterns names of Redis server's configuration.
      * @return Map&lt;String, String&gt; bulk-string-reply.
-     * @since 7.0
+     * @since 6.2
      */
     Executions<Map<String, String>> configGet(String... parameters);
 
@@ -219,7 +219,7 @@ public interface NodeSelectionServerCommands<K, V> {
      *
      * @param kvs the parameter name and value.
      * @return String simple-string-reply: {@code OK} when the configuration was set properly. Otherwise an error is returned.
-     * @since 7.0
+     * @since 6.2
      */
     Executions<String> configSet(Map<String, String> kvs);
 

File: src/main/templates/io/lettuce/core/api/RedisServerCommands.java
Patch:
@@ -185,7 +185,7 @@ public interface RedisServerCommands<K, V> {
      *
      * @param parameters patterns names of Redis server's configuration.
      * @return Map&lt;String, String&gt; bulk-string-reply.
-     * @since 7.0
+     * @since 6.2
      */
     Map<String, String> configGet(String... parameters);
 
@@ -218,7 +218,7 @@ public interface RedisServerCommands<K, V> {
      *
      * @param kvs the parameter name and value.
      * @return String simple-string-reply: {@code OK} when the configuration was set properly. Otherwise an error is returned.
-     * @since 7.0
+     * @since 6.2
      */
     String configSet(Map<String, String> kvs);
 

File: src/main/java/io/lettuce/core/AbstractRedisAsyncCommands.java
Patch:
@@ -2141,7 +2141,7 @@ public RedisFuture<Long> zintercard(K... keys) {
     }
 
     @Override
-    public RedisFuture<Long> zintercard(int limit, K... keys) {
+    public RedisFuture<Long> zintercard(long limit, K... keys) {
         return dispatch(commandBuilder.zintercard(limit, keys));
     }
 

File: src/main/java/io/lettuce/core/AbstractRedisReactiveCommands.java
Patch:
@@ -2214,7 +2214,7 @@ public Mono<Long> zintercard(K... keys) {
     }
 
     @Override
-    public Mono<Long> zintercard(int limit, K... keys) {
+    public Mono<Long> zintercard(long limit, K... keys) {
         return createMono(() -> commandBuilder.zintercard(limit, keys));
     }
 

File: src/main/java/io/lettuce/core/RedisCommandBuilder.java
Patch:
@@ -3098,7 +3098,7 @@ Command<K, V, Long> zintercard(K... keys) {
         return createCommand(ZINTERCARD, new IntegerOutput<>(codec), args);
     }
 
-    Command<K, V, Long> zintercard(int limit, K... keys) {
+    Command<K, V, Long> zintercard(long limit, K... keys) {
         notEmpty(keys);
 
         CommandArgs<K, V> args = new CommandArgs<>(codec).add(keys.length).addKeys(keys).add(LIMIT).add(limit);

File: src/main/java/io/lettuce/core/protocol/CommandArgs.java
Patch:
@@ -22,11 +22,11 @@
 import java.util.List;
 import java.util.Map;
 
-import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.codec.StringCodec;
 import io.lettuce.core.codec.ToByteBufEncoder;
 import io.lettuce.core.internal.LettuceAssert;
+import io.lettuce.core.internal.LettuceStrings;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.UnpooledByteBufAllocator;
 
@@ -497,7 +497,7 @@ static IntegerArgument of(long val) {
                 return IntegerCache.cache[(int) val];
             }
 
-            if (val < 0 && -val < IntegerCache.cache.length) {
+            if (val < 0 && val > Integer.MIN_VALUE && -val < IntegerCache.cache.length) {
                 return IntegerCache.negativeCache[(int) -val];
             }
 

File: src/main/java/io/lettuce/core/cluster/topology/Connections.java
Patch:
@@ -113,15 +113,15 @@ public Requests requestTopology(long timeout, TimeUnit timeUnit) {
     }
 
     /*
-     * Initiate {@code INFO CLIENTS} on all connections and return the {@link Requests}.
+     * Initiate {@code INFO} on all connections and return the {@link Requests}.
      * @return the {@link Requests}.
      */
-    public Requests requestClients(long timeout, TimeUnit timeUnit) {
+    public Requests requestInfo(long timeout, TimeUnit timeUnit) {
 
         return doRequest(() -> {
 
             Command<String, String, String> command = new Command<>(CommandType.INFO, new StatusOutput<>(StringCodec.UTF8),
-                    new CommandArgs<>(StringCodec.UTF8).add("CLIENTS"));
+                    new CommandArgs<>(StringCodec.UTF8));
             return new TimedAsyncCommand<>(command);
         }, timeout, timeUnit);
     }

File: src/test/java/io/lettuce/core/cluster/topology/RequestsUnitTests.java
Patch:
@@ -15,10 +15,9 @@
  */
 package io.lettuce.core.cluster.topology;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.*;
 
 import java.nio.ByteBuffer;
-import java.util.concurrent.TimeUnit;
 
 import org.junit.jupiter.api.Test;
 
@@ -53,7 +52,7 @@ void shouldCreateTopologyView() throws Exception {
         assertThat(nodeTopologyView.getConnectedClients()).isEqualTo(100);
         assertThat(nodeTopologyView.getPartitions()).hasSize(1);
         assertThat(nodeTopologyView.getClusterNodes()).isEqualTo(clusterNodesOutput);
-        assertThat(nodeTopologyView.getClientList()).isEqualTo(infoClientOutput);
+        assertThat(nodeTopologyView.getInfo()).isEqualTo(infoClientOutput);
     }
 
     @Test

File: src/main/java/io/lettuce/core/cluster/RedisClusterClient.java
Patch:
@@ -651,7 +651,7 @@ private <K, V> CompletableFuture<StatefulRedisClusterConnection<K, V>> connectCl
             writer = new CommandListenerWriter(writer, getCommandListeners());
         }
 
-        ClusterDistributionChannelWriter clusterWriter = new ClusterDistributionChannelWriter(getClusterClientOptions(), writer,
+        ClusterDistributionChannelWriter clusterWriter = new ClusterDistributionChannelWriter(writer, getClusterClientOptions(),
                 topologyRefreshScheduler);
         PooledClusterConnectionProvider<K, V> pooledClusterConnectionProvider = new PooledClusterConnectionProvider<>(this,
                 clusterWriter, codec, topologyRefreshScheduler);
@@ -748,7 +748,7 @@ private <K, V> CompletableFuture<StatefulRedisClusterPubSubConnection<K, V>> con
             writer = new CommandListenerWriter(writer, getCommandListeners());
         }
 
-        ClusterDistributionChannelWriter clusterWriter = new ClusterDistributionChannelWriter(getClusterClientOptions(), writer,
+        ClusterDistributionChannelWriter clusterWriter = new ClusterDistributionChannelWriter(writer, getClusterClientOptions(),
                 topologyRefreshScheduler);
 
         ClusterPubSubConnectionProvider<K, V> pooledClusterConnectionProvider = new ClusterPubSubConnectionProvider<>(this,

File: src/main/java/io/lettuce/core/api/async/RedisSortedSetAsyncCommands.java
Patch:
@@ -1034,7 +1034,7 @@ public interface RedisSortedSetAsyncCommands<K, V> {
      * @param max max score.
      * @param min min score.
      * @param offset the withscores.
-     * @param count the null.
+     * @param count the number of items.
      * @return List&lt;V&gt; array-reply list of elements in the specified score range.
      * @deprecated Use {@link #zrevrangebyscore(java.lang.Object, Range, Limit)}.
      */

File: src/main/java/io/lettuce/core/api/async/RedisStringAsyncCommands.java
Patch:
@@ -297,15 +297,15 @@ public interface RedisStringAsyncCommands<K, V> {
     /**
      * Set multiple keys to multiple values.
      *
-     * @param map the null.
+     * @param map the map.
      * @return String simple-string-reply always {@code OK} since {@code MSET} can't fail.
      */
     RedisFuture<String> mset(Map<K, V> map);
 
     /**
      * Set multiple keys to multiple values, only if none of the keys exist.
      *
-     * @param map the null.
+     * @param map the map.
      * @return Boolean integer-reply specifically:
      *
      *         {@code 1} if the all the keys were set. {@code 0} if no key was set (at least one key already existed).

File: src/main/java/io/lettuce/core/api/reactive/RedisSortedSetReactiveCommands.java
Patch:
@@ -1060,7 +1060,7 @@ public interface RedisSortedSetReactiveCommands<K, V> {
      * @param max max score.
      * @param min min score.
      * @param offset the withscores.
-     * @param count the null.
+     * @param count the number of items.
      * @return V array-reply list of elements in the specified score range.
      * @deprecated Use {@link #zrevrangebyscore(java.lang.Object, Range, Limit)}.
      */

File: src/main/java/io/lettuce/core/api/reactive/RedisStringReactiveCommands.java
Patch:
@@ -300,15 +300,15 @@ public interface RedisStringReactiveCommands<K, V> {
     /**
      * Set multiple keys to multiple values.
      *
-     * @param map the null.
+     * @param map the map.
      * @return String simple-string-reply always {@code OK} since {@code MSET} can't fail.
      */
     Mono<String> mset(Map<K, V> map);
 
     /**
      * Set multiple keys to multiple values, only if none of the keys exist.
      *
-     * @param map the null.
+     * @param map the map.
      * @return Boolean integer-reply specifically:
      *
      *         {@code 1} if the all the keys were set. {@code 0} if no key was set (at least one key already existed).

File: src/main/java/io/lettuce/core/api/sync/RedisSortedSetCommands.java
Patch:
@@ -1034,7 +1034,7 @@ public interface RedisSortedSetCommands<K, V> {
      * @param max max score.
      * @param min min score.
      * @param offset the withscores.
-     * @param count the null.
+     * @param count the number of items.
      * @return List&lt;V&gt; array-reply list of elements in the specified score range.
      * @deprecated Use {@link #zrevrangebyscore(java.lang.Object, Range, Limit)}.
      */

File: src/main/java/io/lettuce/core/api/sync/RedisStringCommands.java
Patch:
@@ -296,15 +296,15 @@ public interface RedisStringCommands<K, V> {
     /**
      * Set multiple keys to multiple values.
      *
-     * @param map the null.
+     * @param map the map.
      * @return String simple-string-reply always {@code OK} since {@code MSET} can't fail.
      */
     String mset(Map<K, V> map);
 
     /**
      * Set multiple keys to multiple values, only if none of the keys exist.
      *
-     * @param map the null.
+     * @param map the map.
      * @return Boolean integer-reply specifically:
      *
      *         {@code 1} if the all the keys were set. {@code 0} if no key was set (at least one key already existed).

File: src/main/java/io/lettuce/core/cluster/api/async/NodeSelectionSortedSetAsyncCommands.java
Patch:
@@ -1034,7 +1034,7 @@ public interface NodeSelectionSortedSetAsyncCommands<K, V> {
      * @param max max score.
      * @param min min score.
      * @param offset the withscores.
-     * @param count the null.
+     * @param count the number of items.
      * @return List&lt;V&gt; array-reply list of elements in the specified score range.
      * @deprecated Use {@link #zrevrangebyscore(java.lang.Object, Range, Limit)}.
      */

File: src/main/java/io/lettuce/core/cluster/api/async/NodeSelectionStringAsyncCommands.java
Patch:
@@ -296,15 +296,15 @@ public interface NodeSelectionStringAsyncCommands<K, V> {
     /**
      * Set multiple keys to multiple values.
      *
-     * @param map the null.
+     * @param map the map.
      * @return String simple-string-reply always {@code OK} since {@code MSET} can't fail.
      */
     AsyncExecutions<String> mset(Map<K, V> map);
 
     /**
      * Set multiple keys to multiple values, only if none of the keys exist.
      *
-     * @param map the null.
+     * @param map the map.
      * @return Boolean integer-reply specifically:
      *
      *         {@code 1} if the all the keys were set. {@code 0} if no key was set (at least one key already existed).

File: src/main/java/io/lettuce/core/cluster/api/async/RedisAdvancedClusterAsyncCommands.java
Patch:
@@ -226,7 +226,7 @@ default AsyncNodeSelection<K, V> all() {
      * Set multiple keys to multiple values, only if none of the keys exist with pipelining. Cross-slot keys will result in
      * multiple calls to the particular cluster nodes.
      *
-     * @param map the null
+     * @param map the map
      * @return Boolean integer-reply specifically:
      *
      *         {@code 1} if the all the keys were set. {@code 0} if no key was set (at least one key already existed).

File: src/main/java/io/lettuce/core/cluster/api/async/RedisClusterAsyncCommands.java
Patch:
@@ -321,7 +321,7 @@ public interface RedisClusterAsyncCommands<K, V> extends BaseRedisAsyncCommands<
      * Set multiple keys to multiple values with pipelining. Cross-slot keys will result in multiple calls to the particular
      * cluster nodes.
      *
-     * @param map the null
+     * @param map the map
      * @return RedisFuture&lt;String&gt; simple-string-reply always {@code OK} since {@code MSET} can't fail.
      */
     RedisFuture<String> mset(Map<K, V> map);
@@ -330,7 +330,7 @@ public interface RedisClusterAsyncCommands<K, V> extends BaseRedisAsyncCommands<
      * Set multiple keys to multiple values, only if none of the keys exist with pipelining. Cross-slot keys will result in
      * multiple calls to the particular cluster nodes.
      *
-     * @param map the null
+     * @param map the map
      * @return RedisFuture&lt;Boolean&gt; integer-reply specifically:
      *
      *         {@code 1} if the all the keys were set. {@code 0} if no key was set (at least one key already existed).

File: src/main/java/io/lettuce/core/cluster/api/reactive/RedisAdvancedClusterReactiveCommands.java
Patch:
@@ -119,7 +119,7 @@ public interface RedisAdvancedClusterReactiveCommands<K, V> extends RedisCluster
      * Set multiple keys to multiple values, only if none of the keys exist with pipelining. Cross-slot keys will result in
      * multiple calls to the particular cluster nodes.
      *
-     * @param map the null
+     * @param map the map
      * @return Boolean integer-reply specifically:
      *
      *         {@code 1} if the all the keys were set. {@code 0} if no key was set (at least one key already existed).

File: src/main/java/io/lettuce/core/cluster/api/reactive/RedisClusterReactiveCommands.java
Patch:
@@ -323,7 +323,7 @@ public interface RedisClusterReactiveCommands<K, V>
      * Set multiple keys to multiple values with pipelining. Cross-slot keys will result in multiple calls to the particular
      * cluster nodes.
      *
-     * @param map the null
+     * @param map the map
      * @return Flux&lt;String&gt; simple-string-reply always {@code OK} since {@code MSET} can't fail.
      */
     Mono<String> mset(Map<K, V> map);
@@ -332,7 +332,7 @@ public interface RedisClusterReactiveCommands<K, V>
      * Set multiple keys to multiple values, only if none of the keys exist with pipelining. Cross-slot keys will result in
      * multiple calls to the particular cluster nodes.
      *
-     * @param map the null
+     * @param map the map
      * @return Flux&lt;Boolean&gt; integer-reply specifically:
      *
      *         {@code 1} if the all the keys were set. {@code 0} if no key was set (at least one key already existed).

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionSortedSetCommands.java
Patch:
@@ -1034,7 +1034,7 @@ public interface NodeSelectionSortedSetCommands<K, V> {
      * @param max max score.
      * @param min min score.
      * @param offset the withscores.
-     * @param count the null.
+     * @param count the number of items.
      * @return List&lt;V&gt; array-reply list of elements in the specified score range.
      * @deprecated Use {@link #zrevrangebyscore(java.lang.Object, Range, Limit)}.
      */

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionStringCommands.java
Patch:
@@ -296,15 +296,15 @@ public interface NodeSelectionStringCommands<K, V> {
     /**
      * Set multiple keys to multiple values.
      *
-     * @param map the null.
+     * @param map the map.
      * @return String simple-string-reply always {@code OK} since {@code MSET} can't fail.
      */
     Executions<String> mset(Map<K, V> map);
 
     /**
      * Set multiple keys to multiple values, only if none of the keys exist.
      *
-     * @param map the null.
+     * @param map the map.
      * @return Boolean integer-reply specifically:
      *
      *         {@code 1} if the all the keys were set. {@code 0} if no key was set (at least one key already existed).

File: src/main/templates/io/lettuce/core/api/RedisSortedSetCommands.java
Patch:
@@ -1031,7 +1031,7 @@ Long zrangebyscoreWithScores(ScoredValueStreamingChannel<V> channel, K key, Stri
      * @param max max score.
      * @param min min score.
      * @param offset the withscores.
-     * @param count the null.
+     * @param count the number of items.
      * @return List&lt;V&gt; array-reply list of elements in the specified score range.
      * @deprecated Use {@link #zrevrangebyscore(java.lang.Object, Range, Limit)}.
      */

File: src/main/templates/io/lettuce/core/api/RedisStringCommands.java
Patch:
@@ -290,15 +290,15 @@ public interface RedisStringCommands<K, V> {
     /**
      * Set multiple keys to multiple values.
      *
-     * @param map the null.
+     * @param map the map containing key-value pairs.
      * @return String simple-string-reply always {@code OK} since {@code MSET} can't fail.
      */
     String mset(Map<K, V> map);
 
     /**
      * Set multiple keys to multiple values, only if none of the keys exist.
      *
-     * @param map the null.
+     * @param map the map containing key-value pairs.
      * @return Boolean integer-reply specifically:
      *
      *         {@code 1} if the all the keys were set. {@code 0} if no key was set (at least one key already existed).

File: src/main/java/io/lettuce/core/RedisPublisher.java
Patch:
@@ -542,7 +542,7 @@ void request(RedisSubscription<?> subscription, long n) {
                     }
 
                     subscription.potentiallyReadMore();
-                    onDataAvailable(subscription);
+                    subscription.state().onDataAvailable(subscription);
                 } else {
                     onError(subscription, Exceptions.nullOrNegativeRequestException(n));
                 }

File: src/main/java/io/lettuce/core/AclSetuserArgs.java
Patch:
@@ -474,7 +474,7 @@ public AclSetuserArgs removeCommand(CommandType command, ProtocolKeyword subComm
      * @return {@code this}
      */
     public AclSetuserArgs noCommands() {
-        this.noCommands = false;
+        this.noCommands = true;
         return this;
     }
 

File: src/main/java/io/lettuce/core/AclSetuserArgs.java
Patch:
@@ -651,7 +651,7 @@ public <K, V> void build(CommandArgs<K, V> args) {
             }
         }
 
-        if (removeCategories != null) {
+        if (addCategories != null) {
             for (AclCategory category : addCategories) {
                 args.add("+@" + category.name());
             }

File: src/main/java/io/lettuce/core/api/async/RedisScriptingAsyncCommands.java
Patch:
@@ -124,7 +124,7 @@ public interface RedisScriptingAsyncCommands<K, V> {
     /**
      * Remove all the scripts from the script cache using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/api/async/RedisServerAsyncCommands.java
Patch:
@@ -284,7 +284,7 @@ public interface RedisServerAsyncCommands<K, V> {
     /**
      * Remove all keys from all databases using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */
@@ -309,7 +309,7 @@ public interface RedisServerAsyncCommands<K, V> {
     /**
      * Remove all keys from the current database using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/api/reactive/RedisScriptingReactiveCommands.java
Patch:
@@ -123,7 +123,7 @@ public interface RedisScriptingReactiveCommands<K, V> {
     /**
      * Remove all the scripts from the script cache using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/api/reactive/RedisServerReactiveCommands.java
Patch:
@@ -284,7 +284,7 @@ public interface RedisServerReactiveCommands<K, V> {
     /**
      * Remove all keys from all databases using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */
@@ -309,7 +309,7 @@ public interface RedisServerReactiveCommands<K, V> {
     /**
      * Remove all keys from the current database using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/api/sync/RedisScriptingCommands.java
Patch:
@@ -123,7 +123,7 @@ public interface RedisScriptingCommands<K, V> {
     /**
      * Remove all the scripts from the script cache using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/api/sync/RedisServerCommands.java
Patch:
@@ -283,7 +283,7 @@ public interface RedisServerCommands<K, V> {
     /**
      * Remove all keys from all databases using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */
@@ -308,7 +308,7 @@ public interface RedisServerCommands<K, V> {
     /**
      * Remove all keys from the current database using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/cluster/api/async/NodeSelectionScriptingAsyncCommands.java
Patch:
@@ -123,7 +123,7 @@ public interface NodeSelectionScriptingAsyncCommands<K, V> {
     /**
      * Remove all the scripts from the script cache using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/cluster/api/async/NodeSelectionServerAsyncCommands.java
Patch:
@@ -269,7 +269,7 @@ public interface NodeSelectionServerAsyncCommands<K, V> {
     /**
      * Remove all keys from all databases using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */
@@ -294,7 +294,7 @@ public interface NodeSelectionServerAsyncCommands<K, V> {
     /**
      * Remove all keys from the current database using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionScriptingCommands.java
Patch:
@@ -123,7 +123,7 @@ public interface NodeSelectionScriptingCommands<K, V> {
     /**
      * Remove all the scripts from the script cache using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionServerCommands.java
Patch:
@@ -269,7 +269,7 @@ public interface NodeSelectionServerCommands<K, V> {
     /**
      * Remove all keys from all databases using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */
@@ -294,7 +294,7 @@ public interface NodeSelectionServerCommands<K, V> {
     /**
      * Remove all keys from the current database using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/templates/io/lettuce/core/api/RedisScriptingCommands.java
Patch:
@@ -122,7 +122,7 @@ public interface RedisScriptingCommands<K, V> {
     /**
      * Remove all the scripts from the script cache using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/templates/io/lettuce/core/api/RedisServerCommands.java
Patch:
@@ -282,7 +282,7 @@ public interface RedisServerCommands<K, V> {
     /**
      * Remove all keys from all databases using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */
@@ -307,7 +307,7 @@ public interface RedisServerCommands<K, V> {
     /**
      * Remove all keys from the current database using the specified {@link FlushMode}.
      *
-     * @param flushMode the flush mode (sync/asnync).
+     * @param flushMode the flush mode (sync/async).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/metrics/MicrometerOptions.java
Patch:
@@ -204,7 +204,7 @@ public Builder maxLatency(Duration maxLatency) {
          * @return this {@link Builder}.
          */
         public Builder minLatency(Duration minLatency) {
-            LettuceAssert.notNull(maxLatency, "Max Latency must not be null");
+            LettuceAssert.notNull(minLatency, "Min Latency must not be null");
             this.minLatency = minLatency;
             return this;
         }

File: src/main/java/io/lettuce/core/CopyArgs.java
Patch:
@@ -31,7 +31,7 @@ public class CopyArgs implements CompositeArgument {
 
 	private Long destinationDb;
 
-	private Boolean replace;
+    private boolean replace;
 
 	/**
 	 * Builder entry points for {@link CopyArgs}.
@@ -95,7 +95,7 @@ public <K, V> void build(CommandArgs<K, V> args) {
 			args.add(CommandKeyword.DB).add(destinationDb);
 		}
 
-		if(replace != null) {
+        if (replace) {
 			args.add(CommandKeyword.REPLACE);
 		}
 	}

File: src/main/java/io/lettuce/core/RedisClient.java
Patch:
@@ -290,7 +290,7 @@ private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandalone
         future.whenComplete((channelHandler, throwable) -> {
 
             if (throwable != null) {
-                connection.close();
+                connection.closeAsync();
             }
         });
 
@@ -602,8 +602,8 @@ private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnect
         return sync.thenApply(ignore -> (StatefulRedisSentinelConnection<K, V>) connection).whenComplete((ignore, e) -> {
 
             if (e != null) {
-                logger.warn("Cannot connect Redis Sentinel at " + redisURI + ": " + e.toString());
-                connection.close();
+                logger.warn("Cannot connect Redis Sentinel at " + redisURI + ": " + e);
+                connection.closeAsync();
             }
         });
     }

File: src/main/java/io/lettuce/core/cluster/RedisClusterClient.java
Patch:
@@ -552,7 +552,7 @@ <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisC
 
         return connectionFuture.whenComplete((conn, throwable) -> {
             if (throwable != null) {
-                connection.close();
+                connection.closeAsync();
             }
         });
     }
@@ -597,7 +597,7 @@ <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubToNode
                 () -> new PubSubCommandHandler<>(getClusterClientOptions(), getResources(), codec, endpoint));
         return connectionFuture.whenComplete((conn, throwable) -> {
             if (throwable != null) {
-                connection.close();
+                connection.closeAsync();
             }
         });
     }

File: src/main/java/io/lettuce/core/GetExArgs.java
Patch:
@@ -175,7 +175,7 @@ public static GetExArgs pxAt(Instant timestamp) {
          * Creates new {@link GetExArgs} and enable {@literal PERSIST}.
          *
          * @return new {@link GetExArgs} with {@literal PERSIST} enabled.
-         * @see GetExArgs#nx()
+         * @see GetExArgs#persist()
          */
         public static GetExArgs persist() {
             return new GetExArgs().persist();

File: src/main/java/io/lettuce/core/KillArgs.java
Patch:
@@ -222,7 +222,7 @@ public KillArgs id(long id) {
     }
 
     /**
-     * This closes the connections of all the clients in the specified {@link Type class}. Note that clients blocked into the
+     * This closes the connections of all the clients in the specified {@link KillArgs.Type}. Note that clients blocked into the
      * {@literal MONITOR} command are considered to belong to the normal class.
      *
      * @param type must not be {@code null}.

File: src/main/java/io/lettuce/core/RedisURI.java
Patch:
@@ -237,7 +237,6 @@ public RedisURI() {
      * @param host the host
      * @param port the port
      * @param timeout timeout value
-     * @param timeout unit of the timeout value
      */
     public RedisURI(String host, int port, Duration timeout) {
 
@@ -505,7 +504,7 @@ public void setTimeout(Duration timeout) {
     /**
      * Returns the Redis database number. Databases are only available for Redis Standalone and Redis Master/Slave.
      *
-     * @return
+     * @return the Redis database number
      */
     public int getDatabase() {
         return database;
@@ -526,7 +525,7 @@ public void setDatabase(int database) {
     /**
      * Returns the client name.
      *
-     * @return
+     * @return the client name.
      * @since 4.4
      */
     public String getClientName() {

File: src/main/java/io/lettuce/core/api/async/RedisGeoAsyncCommands.java
Patch:
@@ -74,7 +74,7 @@ public interface RedisGeoAsyncCommands<K, V> {
      * Multi geo add.
      *
      * @param key the key of the geo set.
-     * @param lngLatMember triplets of double longitude, double latitude and V member.
+     * @param values {@link io.lettuce.core.GeoValue} values to add.
      * @return Long integer-reply the number of elements that were added to the set.
      * @since 6.1
      */
@@ -85,7 +85,7 @@ public interface RedisGeoAsyncCommands<K, V> {
      *
      * @param key the key of the geo set.
      * @param args additional arguments.
-     * @param values {@link io.lettuce.core.GeoValue} values to add.
+     * @param lngLatMember triplets of double longitude, double latitude and V member.
      * @return Long integer-reply the number of elements that were added to the set.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/api/reactive/RedisGeoReactiveCommands.java
Patch:
@@ -72,7 +72,7 @@ public interface RedisGeoReactiveCommands<K, V> {
      * Multi geo add.
      *
      * @param key the key of the geo set.
-     * @param lngLatMember triplets of double longitude, double latitude and V member.
+     * @param values {@link io.lettuce.core.GeoValue} values to add.
      * @return Long integer-reply the number of elements that were added to the set.
      * @since 6.1
      */
@@ -83,7 +83,7 @@ public interface RedisGeoReactiveCommands<K, V> {
      *
      * @param key the key of the geo set.
      * @param args additional arguments.
-     * @param values {@link io.lettuce.core.GeoValue} values to add.
+     * @param lngLatMember triplets of double longitude, double latitude and V member.
      * @return Long integer-reply the number of elements that were added to the set.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/api/sync/RedisGeoCommands.java
Patch:
@@ -73,7 +73,7 @@ public interface RedisGeoCommands<K, V> {
      * Multi geo add.
      *
      * @param key the key of the geo set.
-     * @param lngLatMember triplets of double longitude, double latitude and V member.
+     * @param values {@link io.lettuce.core.GeoValue} values to add.
      * @return Long integer-reply the number of elements that were added to the set.
      * @since 6.1
      */
@@ -84,7 +84,7 @@ public interface RedisGeoCommands<K, V> {
      *
      * @param key the key of the geo set.
      * @param args additional arguments.
-     * @param values {@link io.lettuce.core.GeoValue} values to add.
+     * @param lngLatMember triplets of double longitude, double latitude and V member.
      * @return Long integer-reply the number of elements that were added to the set.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/cluster/api/async/NodeSelectionGeoAsyncCommands.java
Patch:
@@ -73,7 +73,7 @@ public interface NodeSelectionGeoAsyncCommands<K, V> {
      * Multi geo add.
      *
      * @param key the key of the geo set.
-     * @param lngLatMember triplets of double longitude, double latitude and V member.
+     * @param values {@link io.lettuce.core.GeoValue} values to add.
      * @return Long integer-reply the number of elements that were added to the set.
      * @since 6.1
      */
@@ -84,7 +84,7 @@ public interface NodeSelectionGeoAsyncCommands<K, V> {
      *
      * @param key the key of the geo set.
      * @param args additional arguments.
-     * @param values {@link io.lettuce.core.GeoValue} values to add.
+     * @param lngLatMember triplets of double longitude, double latitude and V member.
      * @return Long integer-reply the number of elements that were added to the set.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionGeoCommands.java
Patch:
@@ -73,7 +73,7 @@ public interface NodeSelectionGeoCommands<K, V> {
      * Multi geo add.
      *
      * @param key the key of the geo set.
-     * @param lngLatMember triplets of double longitude, double latitude and V member.
+     * @param values {@link io.lettuce.core.GeoValue} values to add.
      * @return Long integer-reply the number of elements that were added to the set.
      * @since 6.1
      */
@@ -84,7 +84,7 @@ public interface NodeSelectionGeoCommands<K, V> {
      *
      * @param key the key of the geo set.
      * @param args additional arguments.
-     * @param values {@link io.lettuce.core.GeoValue} values to add.
+     * @param lngLatMember triplets of double longitude, double latitude and V member.
      * @return Long integer-reply the number of elements that were added to the set.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/cluster/topology/ClusterTopologyRefresh.java
Patch:
@@ -34,9 +34,9 @@ public interface ClusterTopologyRefresh {
     /**
      * Create a new {@link ClusterTopologyRefresh} instance.
      *
-     * @param nodeConnectionFactory
-     * @param clientResources
-     * @return
+     * @param nodeConnectionFactory the connection factory to open connections to specific cluster nodes
+     * @param clientResources shared client resources
+     * @return a new {@link ClusterTopologyRefresh} instance.
      */
     static ClusterTopologyRefresh create(NodeConnectionFactory nodeConnectionFactory, ClientResources clientResources) {
         return new DefaultClusterTopologyRefresh(nodeConnectionFactory, clientResources);

File: src/main/java/io/lettuce/core/metrics/CommandLatencyRecorder.java
Patch:
@@ -33,7 +33,7 @@ public interface CommandLatencyRecorder {
     /**
      * Returns a disabled no-op {@link CommandLatencyRecorder}.
      *
-     * @return
+     * @return a disabled {@link CommandLatencyRecorder}.
      */
     static CommandLatencyRecorder disabled() {
 

File: src/main/java/io/lettuce/core/metrics/DefaultCommandLatencyCollector.java
Patch:
@@ -89,6 +89,7 @@ public DefaultCommandLatencyCollector(CommandLatencyCollectorOptions options) {
      * @param firstResponseLatency latency value in {@link TimeUnit#NANOSECONDS} from send to the first response
      * @param completionLatency latency value in {@link TimeUnit#NANOSECONDS} from send to the command completion
      */
+    @Override
     public void recordCommandLatency(SocketAddress local, SocketAddress remote, ProtocolKeyword commandType,
             long firstResponseLatency, long completionLatency) {
 

File: src/main/java/io/lettuce/core/tracing/Tracer.java
Patch:
@@ -83,15 +83,15 @@ public abstract static class Span {
          * Associate an {@link Throwable error} with this {@link Span}.
          *
          * @param throwable must not be {@code null}.
-         * @return
+         * @return {@literal this} {@link Span}.
          */
         public abstract Span error(Throwable throwable);
 
         /**
          * Associates an {@link Tracing.Endpoint} with this {@link Span}.
          *
          * @param endpoint must not be {@code null}.
-         * @return
+         * @return {@literal this} {@link Span}.
          */
         public abstract Span remoteEndpoint(Tracing.Endpoint endpoint);
 

File: src/main/templates/io/lettuce/core/api/RedisGeoCommands.java
Patch:
@@ -64,7 +64,7 @@ public interface RedisGeoCommands<K, V> {
      * Multi geo add.
      *
      * @param key the key of the geo set.
-     * @param lngLatMember triplets of double longitude, double latitude and V member.
+     * @param values {@link io.lettuce.core.GeoValue} values to add.
      * @return Long integer-reply the number of elements that were added to the set.
      * @since 6.1
      */
@@ -75,7 +75,7 @@ public interface RedisGeoCommands<K, V> {
      *
      * @param key the key of the geo set.
      * @param args additional arguments.
-     * @param values {@link io.lettuce.core.GeoValue} values to add.
+     * @param lngLatMember triplets of double longitude, double latitude and V member.
      * @return Long integer-reply the number of elements that were added to the set.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/SocketOptions.java
Patch:
@@ -280,7 +280,7 @@ public static class KeepAliveOptions {
 
         public static final Duration DEFAULT_IDLE = Duration.ofHours(2);
 
-        public static final Duration DEFAULT_INTERVAL = Duration.ofSeconds(1);
+        public static final Duration DEFAULT_INTERVAL = Duration.ofSeconds(75);
 
         private final int count;
 
@@ -390,7 +390,7 @@ public KeepAliveOptions.Builder idle(Duration idle) {
             }
 
             /**
-             * The time between individual keepalive probes. Defaults to {@code 1 second}. See also {@link #DEFAULT_INTERVAL}
+             * The time between individual keepalive probes. Defaults to {@code 75 second}. See also {@link #DEFAULT_INTERVAL}
              * and {@code TCP_KEEPINTVL}.
              * <p>
              * The time granularity of is seconds.

File: src/test/java/io/lettuce/core/KeepAliveOptionsUnitTests.java
Patch:
@@ -35,6 +35,9 @@ void testNew() {
         KeepAliveOptions disabled = KeepAliveOptions.builder().build();
 
         assertThat(disabled).isNotNull();
+        assertThat(disabled.getIdle()).hasHours(2);
+        assertThat(disabled.getInterval()).hasSeconds(75);
+        assertThat(disabled.getCount()).isEqualTo(9);
     }
 
     @Test

File: src/main/java/io/lettuce/core/FlushMode.java
Patch:
@@ -28,12 +28,12 @@
 public enum FlushMode implements ProtocolKeyword {
 
     /**
-     * flushes asynchronously
+     * flushes synchronously
      */
     SYNC,
 
     /**
-     * flushes synchronously
+     * flushes asynchronously
      */
     ASYNC;
 

File: src/main/java/io/lettuce/core/AbstractRedisAsyncCommands.java
Patch:
@@ -708,7 +708,7 @@ public RedisFuture<String> flushall(FlushMode flushMode) {
 
     @Override
     public RedisFuture<String> flushallAsync() {
-        return dispatch(commandBuilder.flushallAsync());
+        return flushall(FlushMode.ASYNC);
     }
 
     @Override
@@ -723,7 +723,7 @@ public RedisFuture<String> flushdb(FlushMode flushMode) {
 
     @Override
     public RedisFuture<String> flushdbAsync() {
-        return dispatch(commandBuilder.flushdbAsync());
+        return flushdb(FlushMode.ASYNC);
     }
 
     @Override

File: src/main/java/io/lettuce/core/AbstractRedisReactiveCommands.java
Patch:
@@ -766,7 +766,7 @@ public Mono<String> flushall(FlushMode flushMode) {
 
     @Override
     public Mono<String> flushallAsync() {
-        return createMono(commandBuilder::flushallAsync);
+        return flushall(FlushMode.ASYNC);
     }
 
     @Override
@@ -781,7 +781,7 @@ public Mono<String> flushdb(FlushMode flushMode) {
 
     @Override
     public Mono<String> flushdbAsync() {
-        return createMono(commandBuilder::flushdbAsync);
+        return flushdb(FlushMode.ASYNC);
     }
 
     @Override

File: src/main/java/io/lettuce/core/api/async/RedisScriptingAsyncCommands.java
Patch:
@@ -122,8 +122,9 @@ public interface RedisScriptingAsyncCommands<K, V> {
     RedisFuture<String> scriptFlush();
 
     /**
-     * Remove all the scripts from the script cache by the specified {@code flushMode}.
+     * Remove all the scripts from the script cache using the specified {@link FlushMode}.
      *
+     * @param flushMode the flush mode (sync/asnync).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/api/reactive/RedisScriptingReactiveCommands.java
Patch:
@@ -15,9 +15,9 @@
  */
 package io.lettuce.core.api.reactive;
 
-import io.lettuce.core.FlushMode;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
+import io.lettuce.core.FlushMode;
 import io.lettuce.core.ScriptOutputType;
 
 /**
@@ -121,8 +121,9 @@ public interface RedisScriptingReactiveCommands<K, V> {
     Mono<String> scriptFlush();
 
     /**
-     * Remove all the scripts from the script cache by the specified {@code flushMode}.
+     * Remove all the scripts from the script cache using the specified {@link FlushMode}.
      *
+     * @param flushMode the flush mode (sync/asnync).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/api/sync/RedisScriptingCommands.java
Patch:
@@ -121,8 +121,9 @@ public interface RedisScriptingCommands<K, V> {
     String scriptFlush();
 
     /**
-     * Remove all the scripts from the script cache by the specified {@code flushMode}.
+     * Remove all the scripts from the script cache using the specified {@link FlushMode}.
      *
+     * @param flushMode the flush mode (sync/asnync).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/cluster/api/async/NodeSelectionScriptingAsyncCommands.java
Patch:
@@ -121,8 +121,9 @@ public interface NodeSelectionScriptingAsyncCommands<K, V> {
     AsyncExecutions<String> scriptFlush();
 
     /**
-     * Remove all the scripts from the script cache by the specified {@code flushMode}.
+     * Remove all the scripts from the script cache using the specified {@link FlushMode}.
      *
+     * @param flushMode the flush mode (sync/asnync).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionScriptingCommands.java
Patch:
@@ -121,8 +121,9 @@ public interface NodeSelectionScriptingCommands<K, V> {
     Executions<String> scriptFlush();
 
     /**
-     * Remove all the scripts from the script cache by the specified {@code flushMode}.
+     * Remove all the scripts from the script cache using the specified {@link FlushMode}.
      *
+     * @param flushMode the flush mode (sync/asnync).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/templates/io/lettuce/core/api/RedisScriptingCommands.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.List;
 
+import io.lettuce.core.FlushMode;
 import io.lettuce.core.ScriptOutputType;
 
 /**
@@ -119,8 +120,9 @@ public interface RedisScriptingCommands<K, V> {
     String scriptFlush();
 
     /**
-     * Remove all the scripts from the script cache by the specified {@code flushMode}.
+     * Remove all the scripts from the script cache using the specified {@link FlushMode}.
      *
+     * @param flushMode the flush mode (sync/asnync).
      * @return String simple-string-reply.
      * @since 6.1
      */

File: src/main/java/io/lettuce/core/ReadFromImpl.java
Patch:
@@ -58,7 +58,6 @@ public List<RedisNodeDescription> select(Nodes nodes) {
 
             return Collections.emptyList();
         }
-
     }
 
     /**

File: src/main/java/io/lettuce/core/masterreplica/AutodiscoveryConnector.java
Patch:
@@ -31,6 +31,7 @@
 import io.lettuce.core.RedisURI;
 import io.lettuce.core.api.StatefulRedisConnection;
 import io.lettuce.core.codec.RedisCodec;
+import io.lettuce.core.event.jfr.EventRecorder;
 import io.lettuce.core.models.role.RedisNodeDescription;
 
 /**
@@ -120,6 +121,8 @@ private Mono<StatefulRedisMasterReplicaConnection<K, V>> initializeConnection(Re
 
         return refreshFuture.map(nodes -> {
 
+            EventRecorder.getInstance().record(new MasterReplicaTopologyChangedEvent(redisURI, nodes));
+
             connectionProvider.setKnownNodes(nodes);
 
             MasterReplicaChannelWriter channelWriter = new MasterReplicaChannelWriter(connectionProvider,

File: src/main/java/io/lettuce/core/masterreplica/StaticMasterReplicaConnector.java
Patch:
@@ -27,6 +27,7 @@
 import io.lettuce.core.RedisURI;
 import io.lettuce.core.api.StatefulRedisConnection;
 import io.lettuce.core.codec.RedisCodec;
+import io.lettuce.core.event.jfr.EventRecorder;
 import io.lettuce.core.models.role.RedisNodeDescription;
 
 /**
@@ -65,6 +66,8 @@ public CompletableFuture<StatefulRedisMasterReplicaConnection<K, V>> connectAsyn
 
         return refresh.getNodes(seedNode).flatMap(nodes -> {
 
+            EventRecorder.getInstance().record(new MasterReplicaTopologyChangedEvent(seedNode, nodes));
+
             if (nodes.isEmpty()) {
                 return Mono.error(new RedisException(String.format("Cannot determine topology from %s", redisURIs)));
             }

File: src/main/java/io/lettuce/core/protocol/ChannelLogDescriptor.java
Patch:
@@ -49,7 +49,7 @@ static String logDescriptor(Channel channel) {
         return buffer.toString();
     }
 
-    private static String getId(Channel channel) {
+    static String getId(Channel channel) {
         return String.format("0x%08x", channel.hashCode());
     }
 

File: src/test/java/io/lettuce/core/ScoredValueUnitTests.java
Patch:
@@ -118,6 +118,6 @@ void toStringShouldRenderCorrectly() {
         Value<String> empty = ScoredValue.fromNullable(34, null);
 
         assertThat(value.toString()).contains("ScoredValue[12").contains("340000, hello]");
-        assertThat(empty.toString()).contains("ScoredValue[0,000000].empty");
+        assertThat(empty.toString()).contains(String.format("ScoredValue[%f].empty", 0d));
     }
 }

File: src/main/java/io/lettuce/core/output/ScoredValueListOutput.java
Patch:
@@ -19,10 +19,10 @@
 import java.util.Collections;
 import java.util.List;
 
-import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.ScoredValue;
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.internal.LettuceAssert;
+import io.lettuce.core.internal.LettuceStrings;
 
 /**
  * {@link List} of values and their associated scores.
@@ -60,7 +60,7 @@ public void set(ByteBuffer bytes) {
     @Override
     public void set(double number) {
 
-        subscriber.onNext(output, ScoredValue.fromNullable(number, value));
+        subscriber.onNext(output, ScoredValue.just(number, value));
         value = null;
     }
 

File: src/main/java/io/lettuce/core/output/ScoredValueOutput.java
Patch:
@@ -17,9 +17,9 @@
 
 import java.nio.ByteBuffer;
 
-import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.ScoredValue;
 import io.lettuce.core.codec.RedisCodec;
+import io.lettuce.core.internal.LettuceStrings;
 
 /**
  * A single {@link ScoredValue}.

File: src/main/java/io/lettuce/core/output/ScoredValueStreamingOutput.java
Patch:
@@ -17,9 +17,9 @@
 
 import java.nio.ByteBuffer;
 
-import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.ScoredValue;
 import io.lettuce.core.codec.RedisCodec;
+import io.lettuce.core.internal.LettuceStrings;
 
 /**
  * Streaming-Output of of values and their associated scores. Returns the count of all values (including null).
@@ -54,7 +54,7 @@ public void set(ByteBuffer bytes) {
     @Override
     public void set(double number) {
 
-        channel.onValue(ScoredValue.fromNullable(number, value));
+        channel.onValue(ScoredValue.just(number, value));
         value = null;
         output = output.longValue() + 1;
     }

File: src/test/java/io/lettuce/core/TestSupport.java
Patch:
@@ -56,7 +56,7 @@ protected static KeyValue<String, String> kv(String key, String value) {
     }
 
     protected static ScoredValue<String> sv(double score, String value) {
-        return ScoredValue.fromNullable(score, value);
+        return ScoredValue.just(score, value);
     }
 
     protected static Set<String> set(String... args) {

File: src/test/java/io/lettuce/core/commands/SortedSetCommandIntegrationTests.java
Patch:
@@ -314,8 +314,8 @@ void zrandmember() {
         assertThat(redis.zrandmember("zset", 2)).hasSize(2).containsAnyOf("a", "b", "c");
         assertThat(redis.zrandmemberWithscores("zset")).isIn(ScoredValue.fromNullable(2.0, "a"),
                 ScoredValue.fromNullable(3.0, "b"), ScoredValue.fromNullable(4.0, "c"));
-        assertThat(redis.zrandmemberWithscores("zset", 2)).hasSize(2).containsAnyOf(ScoredValue.fromNullable(2.0, "a"),
-                ScoredValue.fromNullable(3.0, "b"), ScoredValue.fromNullable(4.0, "c"));
+        assertThat(redis.zrandmemberWithscores("zset", 2)).hasSize(2).containsAnyOf(ScoredValue.just(2.0, "a"),
+                ScoredValue.just(3.0, "b"), ScoredValue.just(4.0, "c"));
     }
 
     @Test

File: src/test/java/io/lettuce/core/output/ScoredValueListOutputUnitTests.java
Patch:
@@ -51,6 +51,6 @@ void commandOutputCorrectlyDecoded() {
         sut.set(ByteBuffer.wrap("4.567".getBytes()));
         sut.multi(-1);
 
-        assertThat(sut.get()).contains(ScoredValue.fromNullable(4.567, "key"));
+        assertThat(sut.get()).contains(ScoredValue.just(4.567, "key"));
     }
 }

File: src/main/java/io/lettuce/core/GeoCoordinates.java
Patch:
@@ -18,7 +18,8 @@
 import io.lettuce.core.internal.LettuceAssert;
 
 /**
- * A tuple consisting of numerical geo data points to describe geo coordinates.
+ * A tuple consisting of numerical geo data points to describe geo coordinates (longitude/latitude coordinates according to
+ * WGS84).
  *
  * @author Mark Paluch
  */

File: src/main/java/io/lettuce/core/GeoSearch.java
Patch:
@@ -26,6 +26,7 @@
  */
 public final class GeoSearch {
 
+    // TODO: Should be V
     /**
      * Create a {@link GeoRef} from a Geo set {@code member}.
      *

File: src/main/java/io/lettuce/core/MigrateArgs.java
Patch:
@@ -118,7 +118,6 @@ public static <K> MigrateArgs<K> keys(Iterable<K> keys) {
          * @see MigrateArgs#auth(CharSequence)
          */
         public static <K> MigrateArgs<K> auth(CharSequence password) {
-            // TODO : implement auth(username,password) when https://github.com/antirez/redis/pull/7035 is fixed
             return new MigrateArgs<K>().auth(password);
         }
 
@@ -240,7 +239,7 @@ public MigrateArgs<K> auth(CharSequence password) {
      */
     public MigrateArgs<K> auth2(CharSequence username, CharSequence password) {
 
-        LettuceAssert.notNull(username, "UserName must not be null");
+        LettuceAssert.notNull(username, "Username must not be null");
         LettuceAssert.notNull(password, "Password must not be null");
 
         char[] chars = new char[username.length()];

File: src/main/java/io/lettuce/core/api/reactive/RedisStringReactiveCommands.java
Patch:
@@ -80,7 +80,7 @@ public interface RedisStringReactiveCommands<K, V> {
      *         returned.
      *
      *         If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1, the function returns
-     *         the first bit not part of the string on the right. So if the string is tree bytes set to the value 0xff the
+     *         the first bit not part of the string on the right. So if the string is three bytes set to the value 0xff the
      *         command {@code BITPOS key 0} will return 24, since up to bit 23 all the bits are 1.
      *
      *         Basically the function consider the right of the string as padded with zeros if you look for clear bits and
@@ -100,7 +100,7 @@ public interface RedisStringReactiveCommands<K, V> {
      *         returned.
      *
      *         If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1, the function returns
-     *         the first bit not part of the string on the right. So if the string is tree bytes set to the value 0xff the
+     *         the first bit not part of the string on the right. So if the string is three bytes set to the value 0xff the
      *         command {@code BITPOS key 0} will return 24, since up to bit 23 all the bits are 1.
      *
      *         Basically the function consider the right of the string as padded with zeros if you look for clear bits and
@@ -122,7 +122,7 @@ public interface RedisStringReactiveCommands<K, V> {
      *         returned.
      *
      *         If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1, the function returns
-     *         the first bit not part of the string on the right. So if the string is tree bytes set to the value 0xff the
+     *         the first bit not part of the string on the right. So if the string is three bytes set to the value 0xff the
      *         command {@code BITPOS key 0} will return 24, since up to bit 23 all the bits are 1.
      *
      *         Basically the function consider the right of the string as padded with zeros if you look for clear bits and

File: src/test/java/io/lettuce/apigenerator/KotlinCompilationUnitFactory.java
Patch:
@@ -111,7 +111,7 @@ public void create() throws Exception {
         CompilationUnit template = JavaParser.parse(templateFile);
 
         JavaToken license = template.getTokenRange().get().getBegin();
-        result.append(license.asString().replaceAll("Copyright [\\d]{4}-[\\d]{4}", "Copyright 2020-$2"));
+        result.append(license.asString().replaceAll("Copyright ([\\d]{4})-([\\d]{4})", "Copyright 2020-$2"));
         result.append(license.getNextToken().get().asString());
         result.append("\n");
 

File: src/main/java/io/lettuce/core/KillArgs.java
Patch:
@@ -16,10 +16,10 @@
 package io.lettuce.core;
 
 import static io.lettuce.core.protocol.CommandKeyword.*;
-import static io.lettuce.core.protocol.CommandType.*;
-
+//
 import io.lettuce.core.internal.LettuceAssert;
 import io.lettuce.core.protocol.CommandArgs;
+import io.lettuce.core.protocol.CommandType;
 
 /**
  *
@@ -243,7 +243,7 @@ public <K, V> void build(CommandArgs<K, V> args) {
         }
 
         if (type != null) {
-            args.add(TYPE).add(type.name().toLowerCase());
+            args.add(CommandType.TYPE).add(type.name().toLowerCase());
         }
     }
 

File: src/main/java/io/lettuce/core/protocol/CommandKeyword.java
Patch:
@@ -41,7 +41,7 @@ public enum CommandKeyword implements ProtocolKeyword {
 
     RESETSTAT, RESTART, RETRYCOUNT, REWRITE, RIGHT, SAVECONFIG, SDSLEN, SETNAME, SETSLOT, SLOTS, STABLE,
 
-    MIGRATING, IMPORTING, SKIPME, SLAVES, STREAM, STORE, SUM, SEGFAULT, TRACKING, UNBLOCK, WEIGHTS,
+    MIGRATING, IMPORTING, SKIPME, SLAVES, STREAM, STORE, SUM, SEGFAULT, TRACKING, TYPE, UNBLOCK, WEIGHTS,
 
     WITHSCORES, XOR, YES, USAGE;
 

File: src/test/java/io/lettuce/core/ScanIteratorIntegrationTests.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.lettuce.core;
 
-import static org.assertj.core.api.AssertionsForClassTypes.fail;
+import static org.assertj.core.api.AssertionsForClassTypes.*;
 import static org.assertj.core.api.AssertionsForInterfaceTypes.assertThat;
 
 import java.util.ArrayList;

File: src/test/java/io/lettuce/core/ScanStreamIntegrationTests.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.lettuce.core;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.*;
 
 import java.util.List;
 import java.util.stream.IntStream;

File: src/main/java/io/lettuce/core/RedisClient.java
Patch:
@@ -75,7 +75,6 @@
  *
  * @author Will Glozer
  * @author Mark Paluch
- * @author Yohei Ueki
  * @see RedisURI
  * @see StatefulRedisConnection
  * @see RedisFuture

File: src/main/java/io/lettuce/core/SocketOptions.java
Patch:
@@ -403,7 +403,7 @@ public KeepAliveOptions.Builder interval(Duration interval) {
                 LettuceAssert.notNull(interval, "Idle time must not be null");
                 LettuceAssert.isTrue(!interval.isNegative(), "Idle time must not be begative");
 
-                this.idle = interval;
+                this.interval = interval;
                 return this;
             }
 

File: src/main/java/io/lettuce/core/cluster/RedisClusterClient.java
Patch:
@@ -135,7 +135,6 @@
  * possible.
  *
  * @author Mark Paluch
- * @author Yohei Ueki
  * @since 3.0
  * @see RedisURI
  * @see StatefulRedisClusterConnection

File: src/test/java/io/lettuce/core/KeepAliveOptionsUnitTests.java
Patch:
@@ -24,7 +24,6 @@
 import io.lettuce.core.SocketOptions.KeepAliveOptions;
 
 /**
- *
  * Unit tests for {@link KeepAliveOptions}.
  *
  * @author Mark Paluch
@@ -35,7 +34,7 @@ class KeepAliveOptionsUnitTests {
     void testNew() {
         KeepAliveOptions disabled = KeepAliveOptions.builder().build();
 
-        assertThat(disabled).isNull();
+        assertThat(disabled).isNotNull();
     }
 
     @Test

File: src/test/java/io/lettuce/core/UnixDomainSocketIntegrationTests.java
Patch:
@@ -30,6 +30,7 @@
 
 import io.lettuce.core.api.StatefulRedisConnection;
 import io.lettuce.core.api.sync.RedisCommands;
+import io.lettuce.core.resource.Transports;
 import io.lettuce.core.sentinel.api.StatefulRedisSentinelConnection;
 import io.lettuce.test.resource.FastShutdown;
 import io.lettuce.test.resource.TestClientResources;

File: src/main/java/io/lettuce/core/RedisURI.java
Patch:
@@ -788,7 +788,7 @@ private String getQueryString() {
             if (timeout.getNano() == 0) {
                 queryPairs.add(PARAMETER_NAME_TIMEOUT + "=" + timeout.getSeconds() + "s");
             } else {
-                queryPairs.add(PARAMETER_NAME_TIMEOUT + "=" + timeout.toMillis() + "ns");
+                queryPairs.add(PARAMETER_NAME_TIMEOUT + "=" + timeout.toNanos() + "ns");
             }
         }
 

File: src/main/java/io/lettuce/core/sentinel/api/async/RedisSentinelAsyncCommands.java
Patch:
@@ -206,13 +206,12 @@ public interface RedisSentinelAsyncCommands<K, V> {
     <T> RedisFuture<T> dispatch(ProtocolKeyword type, CommandOutput<K, V, T> output, CommandArgs<K, V> args);
 
     /**
-     * @return true if the connection is open (connected and not closed).
+     * @return {@code true} if the connection is open (connected and not closed).
      */
     boolean isOpen();
 
     /**
      * @return the underlying connection.
      */
     StatefulRedisSentinelConnection<K, V> getStatefulConnection();
-
 }

File: src/main/java/io/lettuce/core/sentinel/api/sync/RedisSentinelCommands.java
Patch:
@@ -40,7 +40,7 @@ public interface RedisSentinelCommands<K, V> {
      * Return the ip and port number of the master with that name.
      *
      * @param key the key.
-     * @return SocketAddress;.
+     * @return SocketAddress.
      */
     SocketAddress getMasterAddrByName(K key);
 
@@ -205,13 +205,12 @@ public interface RedisSentinelCommands<K, V> {
     <T> T dispatch(ProtocolKeyword type, CommandOutput<K, V, T> output, CommandArgs<K, V> args);
 
     /**
-     * @return true if the connection is open (connected and not closed).
+     * @return {@code true} if the connection is open (connected and not closed).
      */
     boolean isOpen();
 
     /**
      * @return the underlying connection.
      */
     StatefulRedisSentinelConnection<K, V> getStatefulConnection();
-
 }

File: src/test/java/io/lettuce/apigenerator/CreateReactiveApi.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 
-import org.jetbrains.annotations.NotNull;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
 

File: src/test/java/io/lettuce/apigenerator/CreateSyncApi.java
Patch:
@@ -39,7 +39,7 @@
  */
 class CreateSyncApi {
 
-    private Set<String> FILTER_METHODS = LettuceSets.unmodifiableSet("setAutoFlushCommands", "flushCommands");
+    private static final Set<String> FILTER_METHODS = LettuceSets.unmodifiableSet("setAutoFlushCommands", "flushCommands");
 
     /**
      * Mutate type comment.

File: src/main/java/io/lettuce/core/resource/DefaultClientResources.java
Patch:
@@ -357,13 +357,13 @@ public Builder commandLatencyRecorder(CommandLatencyRecorder commandLatencyRecor
          * Sets the thread pool size (number of threads to use) for computation operations (default value is the number of
          * CPUs). The thread pool size is only effective if no {@code eventExecutorGroup} is provided.
          *
-         * @param computationThreadPoolSize the thread pool size, must be greater {@code 0}.
+         * @param computationThreadPoolSize the thread pool size, must be greater than {@code 0}.
          * @return {@code this} {@link Builder}.
          */
         @Override
         public Builder computationThreadPoolSize(int computationThreadPoolSize) {
 
-            LettuceAssert.isTrue(computationThreadPoolSize > 0, "Computation thread pool size must be greater zero");
+            LettuceAssert.isTrue(computationThreadPoolSize > 0, "Computation thread pool size must be greater than zero");
 
             this.computationThreadPoolSize = computationThreadPoolSize;
             return this;

File: src/main/java/io/lettuce/core/protocol/CommandType.java
Patch:
@@ -23,6 +23,7 @@
  * @author Will Glozer
  * @author Mark Paluch
  * @author Zhang Jessey
+ * @author dengliming
  */
 public enum CommandType implements ProtocolKeyword {
 
@@ -72,11 +73,11 @@ public enum CommandType implements ProtocolKeyword {
 
     // Sets
 
-    SADD, SCARD, SDIFF, SDIFFSTORE, SINTER, SINTERSTORE, SISMEMBER, SMEMBERS, SMOVE, SPOP, SRANDMEMBER, SREM, SUNION, SUNIONSTORE, SSCAN, SMISMEMBER,
+    SADD, SCARD, SDIFF, SDIFFSTORE, SINTER, SINTERSTORE, SISMEMBER, SMISMEMBER, SMEMBERS, SMOVE, SPOP, SRANDMEMBER, SREM, SSCAN, SUNION, SUNIONSTORE,
 
     // Sorted Set
 
-    BZPOPMIN, BZPOPMAX, ZADD, ZCARD, ZCOUNT, ZINCRBY, ZINTERSTORE, ZPOPMIN, ZPOPMAX, ZRANGE, ZRANGEBYSCORE, ZRANK, ZREM, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZREVRANGE, ZREVRANGEBYLEX, ZREVRANGEBYSCORE, ZREVRANK, ZSCORE, ZUNIONSTORE, ZSCAN, ZLEXCOUNT, ZREMRANGEBYLEX, ZRANGEBYLEX, ZMSCORE,
+    BZPOPMIN, BZPOPMAX, ZADD, ZCARD, ZCOUNT, ZINCRBY, ZINTERSTORE, ZLEXCOUNT, ZMSCORE, ZPOPMIN, ZPOPMAX, ZRANGE, ZRANGEBYSCORE, ZRANK, ZREM, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZREVRANGE, ZREVRANGEBYLEX, ZREVRANGEBYSCORE, ZREVRANK, ZSCAN, ZSCORE, ZUNIONSTORE, ZREMRANGEBYLEX, ZRANGEBYLEX,
 
     // Scripting
 

File: src/test/java/io/lettuce/apigenerator/CreateReactiveApi.java
Patch:
@@ -58,6 +58,7 @@ public class CreateReactiveApi {
         resultSpec.put("geopos", "Flux<Value<GeoCoordinates>>");
         resultSpec.put("bitfield", "Flux<Value<Long>>");
         resultSpec.put("hgetall", "Flux<KeyValue<K, V>>");
+        resultSpec.put("zmscore", "Mono<List<Double>>"); // Redis returns null if element was not found
         resultSpec.put("hgetall(KeyValueStreamingChannel<K, V> channel, K key)", "Mono<Long>");
 
         RESULT_SPEC = resultSpec;

File: src/test/java/io/lettuce/core/SocketOptionsUnitTests.java
Patch:
@@ -37,11 +37,11 @@ void testNew() {
     @Test
     void testBuilder() {
 
-        SocketOptions sut = SocketOptions.builder().connectTimeout(1, TimeUnit.MINUTES).keepAlive(true).tcpNoDelay(true)
+        SocketOptions sut = SocketOptions.builder().connectTimeout(1, TimeUnit.MINUTES).keepAlive(true).tcpNoDelay(false)
                 .build();
 
         assertThat(sut.isKeepAlive()).isTrue();
-        assertThat(sut.isTcpNoDelay()).isTrue();
+        assertThat(sut.isTcpNoDelay()).isFalse();
         assertThat(sut.getConnectTimeout()).isEqualTo(Duration.ofMinutes(1));
     }
 
@@ -67,7 +67,7 @@ void testCopy() {
 
     void checkAssertions(SocketOptions sut) {
         assertThat(sut.isKeepAlive()).isFalse();
-        assertThat(sut.isTcpNoDelay()).isFalse();
+        assertThat(sut.isTcpNoDelay()).isTrue();
         assertThat(sut.getConnectTimeout()).isEqualTo(Duration.ofSeconds(10));
     }
 }

File: src/test/java/io/lettuce/test/settings/TestSettings.java
Patch:
@@ -90,7 +90,7 @@ public static String username() {
      *         {@code -Dpassword=YourPassword}
      */
     public static String password() {
-        return System.getProperty("password", "passwd");
+        return System.getProperty("password", "foobared");
     }
 
     /**

File: src/main/java/io/lettuce/core/AbstractRedisReactiveCommands.java
Patch:
@@ -785,8 +785,8 @@ public Mono<V> hget(K key, K field) {
     }
 
     @Override
-    public Mono<Map<K, V>> hgetall(K key) {
-        return createMono(() -> commandBuilder.hgetall(key));
+    public Flux<KeyValue<K, V>> hgetall(K key) {
+        return createDissolvingFlux(() -> commandBuilder.hgetallKeyValue(key));
     }
 
     @Override

File: src/main/java/io/lettuce/core/api/reactive/RedisHashReactiveCommands.java
Patch:
@@ -94,7 +94,7 @@ public interface RedisHashReactiveCommands<K, V> {
      * @return Map&lt;K,V&gt; array-reply list of fields and their values stored in the hash, or an empty list when {@code key}
      *         does not exist.
      */
-    Mono<Map<K, V>> hgetall(K key);
+    Flux<KeyValue<K, V>> hgetall(K key);
 
     /**
      * Stream over all the fields and values in a hash.

File: src/test/java/io/lettuce/core/commands/HashCommandIntegrationTests.java
Patch:
@@ -88,7 +88,7 @@ void hget() {
     }
 
     @Test
-    void hgetall() {
+    public void hgetall() {
         assertThat(redis.hgetall(key).isEmpty()).isTrue();
 
         redis.hset(key, "zero", "0");
@@ -102,7 +102,7 @@ void hgetall() {
     }
 
     @Test
-    void hgetallStreaming() {
+    public void hgetallStreaming() {
 
         KeyValueStreamingAdapter<String, String> adapter = new KeyValueStreamingAdapter<>();
 

File: src/test/java/io/lettuce/apigenerator/KotlinCompilationUnitFactory.java
Patch:
@@ -116,7 +116,7 @@ public void create() throws Exception {
         result.append(commentInjector.apply(extractJavadoc(clazz.getJavadoc().get())
                 .replaceAll("@author Mark Paluch", "@author \\${author}")
                 .replaceAll("@since [0-9].0", "@since \\${since}")
-                .replaceAll("\\*\\*/", "* @generated by \\${generator}\r\n **/")
+                .replaceAll("\\*\\*/", "* @generated by \\${generator}\r\n */")
         ));
 
         result.append("@ExperimentalLettuceCoroutinesApi").append("\n");
@@ -276,7 +276,7 @@ public static String extractJavadoc(Javadoc javadoc) {
                 .append(" * ")
                 .append(plainJavadoc)
                 .append("\n")
-                .append(" **/")
+                .append(" */")
                 .append("\n")
                 .toString();
     }

File: src/test/java/io/lettuce/core/codec/StringCodecUnitTests.java
Patch:
@@ -23,6 +23,7 @@
 import org.junit.jupiter.api.Test;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.Unpooled;
 
 /**
@@ -124,7 +125,7 @@ void estimateSize() {
     void sizeOf() {
 
         assertThat(new StringCodec(StandardCharsets.UTF_8).sizeOf(teststring, false))
-            .isEqualTo(teststring.length() * 3);
+            .isEqualTo(ByteBufUtil.utf8MaxBytes(teststring));
         assertThat(new StringCodec(StandardCharsets.US_ASCII).sizeOf(teststring, false))
             .isEqualTo(teststring.length());
         assertThat(new StringCodec(StandardCharsets.ISO_8859_1).sizeOf(teststring, false))

File: src/test/java/io/lettuce/core/cluster/RoundRobinSocketAddressSupplierUnitTests.java
Patch:
@@ -74,7 +74,7 @@ void before() {
     @Test
     void noOffset() {
 
-        RoundRobinSocketAddressSupplier sut = new RoundRobinSocketAddressSupplier(partitions,
+        RoundRobinSocketAddressSupplier sut = new RoundRobinSocketAddressSupplier(() -> partitions,
                 redisClusterNodes -> redisClusterNodes, clientResourcesMock);
 
         assertThat(sut.get()).isEqualTo(addr1);
@@ -88,7 +88,7 @@ void noOffset() {
     @Test
     void partitionTableChangesNewNode() {
 
-        RoundRobinSocketAddressSupplier sut = new RoundRobinSocketAddressSupplier(partitions,
+        RoundRobinSocketAddressSupplier sut = new RoundRobinSocketAddressSupplier(() -> partitions,
                 redisClusterNodes -> redisClusterNodes, clientResourcesMock);
 
         assertThat(sut.get()).isEqualTo(addr1);
@@ -106,7 +106,7 @@ void partitionTableChangesNewNode() {
     @Test
     void partitionTableChangesNodeRemoved() {
 
-        RoundRobinSocketAddressSupplier sut = new RoundRobinSocketAddressSupplier(partitions,
+        RoundRobinSocketAddressSupplier sut = new RoundRobinSocketAddressSupplier(() -> partitions,
                 redisClusterNodes -> redisClusterNodes, clientResourcesMock);
 
         assertThat(sut.get()).isEqualTo(addr1);

File: src/test/java/io/lettuce/core/pubsub/PubSubCommandTest.java
Patch:
@@ -217,6 +217,7 @@ void messageAsPushMessage() throws Exception {
 
         redis.publish(channel, message);
         assertThat(messages.take()).isEqualTo(message);
+        Wait.untilTrue(() -> messageRef.get() != null).waitOrTimeout();
 
         PushMessage pushMessage = messageRef.get();
         assertThat(pushMessage).isNotNull();

File: src/test/jmh/io/lettuce/core/protocol/RedisStateMachineBenchmark.java
Patch:
@@ -82,7 +82,7 @@ public void tearDown() {
 
     @Benchmark
     public void measureDecode() {
-        stateMachine.decode(masterBuffer, byteArrayCommand, byteArrayCommand.getOutput());
+        stateMachine.decode(masterBuffer, byteArrayCommand.getOutput());
         masterBuffer.readerIndex(0);
     }
 

File: src/main/java/io/lettuce/core/cluster/RedisAdvancedClusterReactiveCommandsImpl.java
Patch:
@@ -364,7 +364,7 @@ public Mono<String> scriptFlush() {
 
     @Override
     public Mono<String> scriptKill() {
-        Map<String, Publisher<String>> publishers = executeOnNodes(RedisScriptingReactiveCommands::scriptFlush, ALL_NODES);
+        Map<String, Publisher<String>> publishers = executeOnNodes(RedisScriptingReactiveCommands::scriptKill, ALL_NODES);
         return Flux.merge(publishers.values()).onErrorReturn("OK").last();
     }
 

File: src/test/java/io/lettuce/core/cluster/AdvancedClusterClientIntegrationTests.java
Patch:
@@ -51,6 +51,8 @@
 import io.lettuce.test.settings.TestSettings;
 
 /**
+ * Integration tests for {@link StatefulRedisClusterConnection}.
+ * 
  * @author Mark Paluch
  */
 @SuppressWarnings("rawtypes")
@@ -381,7 +383,7 @@ void scriptFlush() {
 
     @Test
     void scriptKill() {
-        assertThat(sync.scriptKill()).isEqualTo("OK");
+        assertThatThrownBy(sync::scriptKill).hasMessageContaining("NOTBUSY");
     }
 
     @Test

File: src/main/java/io/lettuce/core/AbstractRedisAsyncCommands.java
Patch:
@@ -17,20 +17,20 @@
 
 import static io.lettuce.core.protocol.CommandType.*;
 
-import java.nio.charset.Charset;
 import java.time.Duration;
 import java.util.Date;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.TimeUnit;
 
 import io.lettuce.core.GeoArgs.Unit;
 import io.lettuce.core.api.StatefulConnection;
 import io.lettuce.core.api.async.*;
 import io.lettuce.core.cluster.api.async.RedisClusterAsyncCommands;
+import io.lettuce.core.codec.Base16;
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.internal.LettuceAssert;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.models.stream.PendingMessage;
 import io.lettuce.core.models.stream.PendingMessages;
 import io.lettuce.core.output.*;
@@ -469,7 +469,7 @@ public String digest(String script) {
 
     @Override
     public String digest(byte[] script) {
-        return LettuceStrings.digest(script);
+        return Base16.digest(script);
     }
 
     @Override

File: src/main/java/io/lettuce/core/AbstractRedisReactiveCommands.java
Patch:
@@ -17,12 +17,13 @@
 
 import static io.lettuce.core.protocol.CommandType.*;
 
-import java.nio.charset.Charset;
 import java.time.Duration;
 import java.util.Date;
 import java.util.Map;
 import java.util.function.Supplier;
 
+import io.lettuce.core.codec.Base16;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.models.stream.PendingMessage;
 import io.lettuce.core.models.stream.PendingMessages;
 import reactor.core.publisher.Flux;
@@ -538,7 +539,7 @@ public String digest(String script) {
 
     @Override
     public String digest(byte[] script) {
-        return LettuceStrings.digest(script);
+        return Base16.digest(script);
     }
 
     @Override

File: src/main/java/io/lettuce/core/FutureSyncInvocationHandler.java
Patch:
@@ -22,6 +22,7 @@
 import io.lettuce.core.api.StatefulConnection;
 import io.lettuce.core.api.StatefulRedisConnection;
 import io.lettuce.core.internal.AbstractInvocationHandler;
+import io.lettuce.core.internal.Futures;
 import io.lettuce.core.internal.TimeoutProvider;
 import io.lettuce.core.protocol.RedisCommand;
 
@@ -68,7 +69,7 @@ protected Object handleInvocation(Object proxy, Method method, Object[] args) th
 
                 long timeout = getTimeoutNs(command);
 
-                return LettuceFutures.awaitOrCancel(command, timeout, TimeUnit.NANOSECONDS);
+                return Futures.awaitOrCancel(command, timeout, TimeUnit.NANOSECONDS);
             }
 
             return result;

File: src/main/java/io/lettuce/core/LettuceFutures.java
Patch:
@@ -27,7 +27,9 @@
  *
  * @author Mark Paluch
  * @since 3.0
+ * @deprecated since 6.0, use {@link Futures} instead.
  */
+@Deprecated
 public class LettuceFutures {
 
     private LettuceFutures() {

File: src/main/java/io/lettuce/core/ReadFrom.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.List;
 
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.models.role.RedisNodeDescription;
 
 /**

File: src/main/java/io/lettuce/core/RedisCommandBuilder.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.lettuce.core;
 
-import static io.lettuce.core.LettuceStrings.string;
+import static io.lettuce.core.internal.LettuceStrings.string;
 import static io.lettuce.core.protocol.CommandKeyword.*;
 import static io.lettuce.core.protocol.CommandType.*;
 

File: src/main/java/io/lettuce/core/RedisHandshake.java
Patch:
@@ -23,6 +23,7 @@
 
 import io.lettuce.core.codec.StringCodec;
 import io.lettuce.core.internal.Futures;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.protocol.AsyncCommand;
 import io.lettuce.core.protocol.Command;
 import io.lettuce.core.protocol.ConnectionInitializer;

File: src/main/java/io/lettuce/core/RedisURI.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.lettuce.core;
 
-import static io.lettuce.core.LettuceStrings.isEmpty;
-import static io.lettuce.core.LettuceStrings.isNotEmpty;
+import static io.lettuce.core.internal.LettuceStrings.isEmpty;
+import static io.lettuce.core.internal.LettuceStrings.isNotEmpty;
 
 import java.io.Serializable;
 import java.io.UnsupportedEncodingException;
@@ -31,6 +31,7 @@
 import io.lettuce.core.internal.HostAndPort;
 import io.lettuce.core.internal.LettuceAssert;
 import io.lettuce.core.internal.LettuceSets;
+import io.lettuce.core.internal.LettuceStrings;
 
 /**
  * Redis URI. Contains connection details for the Redis/Sentinel connections. You can provide the database, client name,

File: src/main/java/io/lettuce/core/SslOptions.java
Patch:
@@ -34,6 +34,7 @@
 import javax.net.ssl.TrustManagerFactory;
 
 import io.lettuce.core.internal.LettuceAssert;
+import io.lettuce.core.internal.LettuceStrings;
 import io.netty.handler.ssl.OpenSsl;
 import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.SslProvider;

File: src/main/java/io/lettuce/core/cluster/models/partitions/ClusterPartitionParser.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.*;
 
-import io.lettuce.core.LettuceStrings;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.RedisException;
 import io.lettuce.core.RedisURI;
 import io.lettuce.core.cluster.SlotHash;

File: src/main/java/io/lettuce/core/cluster/topology/DefaultClusterTopologyRefresh.java
Patch:
@@ -35,6 +35,7 @@
 import io.lettuce.core.internal.ExceptionFactory;
 import io.lettuce.core.internal.Exceptions;
 import io.lettuce.core.internal.Futures;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.resource.ClientResources;
 import io.netty.util.Timeout;
 import io.netty.util.concurrent.EventExecutorGroup;

File: src/main/java/io/lettuce/core/dynamic/AsyncExecutableCommand.java
Patch:
@@ -17,9 +17,7 @@
 
 import java.time.Duration;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
 
-import io.lettuce.core.LettuceFutures;
 import io.lettuce.core.api.StatefulConnection;
 import io.lettuce.core.dynamic.domain.Timeout;
 import io.lettuce.core.dynamic.parameter.ExecutionSpecificParameters;

File: src/main/java/io/lettuce/core/dynamic/BatchExecutableCommand.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.List;
 import java.util.concurrent.ExecutionException;
 
-import io.lettuce.core.LettuceFutures;
 import io.lettuce.core.RedisFuture;
 import io.lettuce.core.api.StatefulConnection;
 import io.lettuce.core.dynamic.batch.BatchException;

File: src/main/java/io/lettuce/core/dynamic/DefaultCommandMethodVerifier.java
Patch:
@@ -26,6 +26,7 @@
 import io.lettuce.core.dynamic.segment.CommandSegments;
 import io.lettuce.core.internal.LettuceAssert;
 import io.lettuce.core.internal.LettuceLists;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.models.command.CommandDetail;
 
 /**

File: src/main/java/io/lettuce/core/dynamic/segment/AnnotationCommandSegmentFactory.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.List;
 import java.util.regex.Pattern;
 
-import io.lettuce.core.LettuceStrings;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.dynamic.CommandMethod;
 import io.lettuce.core.dynamic.annotation.Command;
 import io.lettuce.core.dynamic.annotation.CommandNaming;

File: src/main/java/io/lettuce/core/dynamic/support/ParametrizedTypeInformation.java
Patch:
@@ -20,7 +20,7 @@
 import java.lang.reflect.TypeVariable;
 import java.util.*;
 
-import io.lettuce.core.LettuceStrings;
+import io.lettuce.core.internal.LettuceStrings;
 
 /**
  * Base class for all types that include parametrization of some kind. Crucial as we have to take note of the parent class we

File: src/main/java/io/lettuce/core/dynamic/support/ResolvableType.java
Patch:
@@ -19,7 +19,7 @@
 import java.lang.reflect.*;
 import java.util.*;
 
-import io.lettuce.core.LettuceStrings;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.dynamic.support.TypeWrapper.MethodParameterTypeProvider;
 import io.lettuce.core.dynamic.support.TypeWrapper.TypeProvider;
 import io.lettuce.core.internal.LettuceAssert;

File: src/main/java/io/lettuce/core/internal/HostAndPort.java
Patch:
@@ -15,8 +15,6 @@
  */
 package io.lettuce.core.internal;
 
-import io.lettuce.core.LettuceStrings;
-
 /**
  * An immutable representation of a host and port.
  *

File: src/main/java/io/lettuce/core/internal/LettuceAssert.java
Patch:
@@ -18,8 +18,6 @@
 import java.util.Collection;
 import java.util.function.Supplier;
 
-import io.lettuce.core.LettuceStrings;
-
 /**
  * Assertion utility class that assists in validating arguments. This class is part of the internal API and may change without
  * further notice.

File: src/main/java/io/lettuce/core/internal/LettuceClassUtils.java
Patch:
@@ -18,8 +18,6 @@
 import java.util.IdentityHashMap;
 import java.util.Map;
 
-import io.lettuce.core.JavaRuntime;
-
 /**
  * Miscellaneous class utility methods. Mainly for internal use within the framework.
  *
@@ -129,7 +127,7 @@ private static ClassLoader getDefaultClassLoader() {
         }
         if (cl == null) {
             // No thread context class loader -> use class loader of this class.
-            cl = JavaRuntime.class.getClassLoader();
+            cl = LettuceClassUtils.class.getClassLoader();
         }
         return cl;
     }

File: src/main/java/io/lettuce/core/output/KeyValueScoredValueOutput.java
Patch:
@@ -18,7 +18,7 @@
 import java.nio.ByteBuffer;
 
 import io.lettuce.core.KeyValue;
-import io.lettuce.core.LettuceStrings;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.ScoredValue;
 import io.lettuce.core.codec.RedisCodec;
 

File: src/main/java/io/lettuce/core/output/ScanOutput.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.nio.ByteBuffer;
 
-import io.lettuce.core.LettuceStrings;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.ScanCursor;
 import io.lettuce.core.codec.RedisCodec;
 

File: src/main/java/io/lettuce/core/output/ScoredValueListOutput.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.Collections;
 import java.util.List;
 
-import io.lettuce.core.LettuceStrings;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.ScoredValue;
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.internal.LettuceAssert;

File: src/main/java/io/lettuce/core/output/ScoredValueOutput.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.nio.ByteBuffer;
 
-import io.lettuce.core.LettuceStrings;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.ScoredValue;
 import io.lettuce.core.codec.RedisCodec;
 

File: src/main/java/io/lettuce/core/output/ScoredValueScanOutput.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.nio.ByteBuffer;
 
-import io.lettuce.core.LettuceStrings;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.ScoredValue;
 import io.lettuce.core.ScoredValueScanCursor;
 import io.lettuce.core.codec.RedisCodec;

File: src/main/java/io/lettuce/core/output/ScoredValueScanStreamingOutput.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.nio.ByteBuffer;
 
-import io.lettuce.core.LettuceStrings;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.ScoredValue;
 import io.lettuce.core.StreamScanCursor;
 import io.lettuce.core.codec.RedisCodec;

File: src/main/java/io/lettuce/core/output/ScoredValueStreamingOutput.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.nio.ByteBuffer;
 
-import io.lettuce.core.LettuceStrings;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.ScoredValue;
 import io.lettuce.core.codec.RedisCodec;
 

File: src/main/java/io/lettuce/core/protocol/CommandArgs.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.List;
 import java.util.Map;
 
-import io.lettuce.core.LettuceStrings;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.codec.StringCodec;
 import io.lettuce.core.codec.ToByteBufEncoder;

File: src/main/java/io/lettuce/core/protocol/RedisStateMachine.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
-import io.lettuce.core.LettuceStrings;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.output.CommandOutput;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;

File: src/main/java/io/lettuce/core/resource/DirContextDnsResolver.java
Patch:
@@ -33,7 +33,7 @@
 import javax.naming.directory.Attributes;
 import javax.naming.directory.InitialDirContext;
 
-import io.lettuce.core.LettuceStrings;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.internal.LettuceAssert;
 
 /**

File: src/main/java/io/lettuce/core/support/RedisClientFactoryBean.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.lettuce.core.support;
 
-import static io.lettuce.core.LettuceStrings.isNotEmpty;
+import static io.lettuce.core.internal.LettuceStrings.isNotEmpty;
 
 import io.lettuce.core.RedisClient;
 import io.lettuce.core.RedisURI;

File: src/main/java/io/lettuce/core/support/RedisClusterClientFactoryBean.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.lettuce.core.support;
 
-import static io.lettuce.core.LettuceStrings.isNotEmpty;
+import static io.lettuce.core.internal.LettuceStrings.isNotEmpty;
 
 import java.net.URI;
 import java.util.Collection;

File: src/test/java/io/lettuce/core/ConnectionCommandIntegrationTests.java
Patch:
@@ -32,6 +32,7 @@
 import io.lettuce.core.api.StatefulRedisConnection;
 import io.lettuce.core.api.async.RedisAsyncCommands;
 import io.lettuce.core.api.sync.RedisCommands;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.core.protocol.ProtocolVersion;
 import io.lettuce.test.*;
 import io.lettuce.test.condition.EnabledOnCommand;

File: src/test/java/io/lettuce/core/cluster/AdvancedClusterClientIntegrationTests.java
Patch:
@@ -41,6 +41,8 @@
 import io.lettuce.core.cluster.api.sync.RedisClusterCommands;
 import io.lettuce.core.cluster.models.partitions.Partitions;
 import io.lettuce.core.cluster.models.partitions.RedisClusterNode;
+import io.lettuce.core.codec.Base16;
+import io.lettuce.core.internal.LettuceStrings;
 import io.lettuce.test.TestFutures;
 import io.lettuce.test.KeysAndValues;
 import io.lettuce.test.LettuceExtension;
@@ -389,7 +391,7 @@ void scriptLoad() {
 
         String script = "return true";
 
-        String sha = LettuceStrings.digest(script.getBytes());
+        String sha = Base16.digest(script.getBytes());
         assertThat(sync.scriptExists(sha)).contains(false);
 
         String returnedSha = sync.scriptLoad(script);

File: src/test/java/io/lettuce/core/cluster/AdvancedClusterReactiveIntegrationTests.java
Patch:
@@ -30,6 +30,8 @@
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
 
+import io.lettuce.core.codec.Base16;
+import io.lettuce.core.internal.LettuceStrings;
 import reactor.core.publisher.Flux;
 import reactor.test.StepVerifier;
 import io.lettuce.core.*;
@@ -291,7 +293,7 @@ void scriptLoad() {
 
         String script = "return true";
 
-        String sha = LettuceStrings.digest(script.getBytes());
+        String sha = Base16.digest(script.getBytes());
 
         StepVerifier.create(commands.scriptExists(sha)).expectNext(false).verifyComplete();
 

File: src/main/java/io/lettuce/core/KqueueProvider.java
Patch:
@@ -23,6 +23,7 @@
  * @since 4.4
  * @deprecated since 6.0, use {@link io.lettuce.core.resource.KqueueProvider} instead.
  */
+@Deprecated
 public class KqueueProvider {
 
     /**

File: src/main/java/io/lettuce/core/ScanStream.java
Patch:
@@ -408,6 +408,7 @@ static class ScanSubscriber<T, C extends ScanCursor> extends BaseSubscriber<C> {
         private static final AtomicReferenceFieldUpdater<ScanSubscriber, ScanCursor> CURSOR = AtomicReferenceFieldUpdater
                 .newUpdater(ScanSubscriber.class, ScanCursor.class, "cursor");
 
+        @SuppressWarnings("rawtypes")
         private static final AtomicLongFieldUpdater<ScanSubscriber> EMITTED = AtomicLongFieldUpdater.newUpdater(
                 ScanSubscriber.class, "emitted");
 

File: src/main/java/io/lettuce/core/cluster/AsyncExecutionsImpl.java
Patch:
@@ -106,6 +106,7 @@ private CompletionStage<List<T>> publicStage() {
         return stage;
     }
 
+    @SuppressWarnings("rawtypes")
     private CompletableFuture<List<T>> createPublicStage(Map<RedisClusterNode, CompletableFuture<T>> map) {
 
         return CompletableFuture.allOf(map.values().toArray(new CompletableFuture[0])).thenApply(ignore -> {

File: src/main/java/io/lettuce/core/cluster/pubsub/api/async/RedisClusterPubSubAsyncCommands.java
Patch:
@@ -52,6 +52,7 @@ default PubSubAsyncNodeSelection<K, V> masters() {
      * @return API with asynchronous executed commands on a selection of replica cluster nodes.
      * @deprecated since 5.2, use {@link #replicas()}
      */
+    @Deprecated
     default PubSubAsyncNodeSelection<K, V> slaves() {
         return nodes(redisClusterNode -> redisClusterNode.is(RedisClusterNode.NodeFlag.SLAVE));
     }

File: src/main/java/io/lettuce/core/cluster/topology/DefaultClusterTopologyRefresh.java
Patch:
@@ -409,6 +409,7 @@ public void addConnection(RedisURI uri, CompletableFuture<StatefulRedisConnectio
             connections.put(uri, future);
         }
 
+        @SuppressWarnings("rawtypes")
         public CompletableFuture<Void> close() {
 
             CompletableFuture[] futures = connections.values().stream()
@@ -466,6 +467,7 @@ protected Map<RedisURI, StatefulRedisConnection<String, String>> collectConnecti
         }
     }
 
+    @SuppressWarnings("serial")
     static class CannotRetrieveClusterPartitions extends RedisException {
 
         private final Map<RedisURI, String> failure;

File: src/main/java/io/lettuce/core/sentinel/StatefulRedisSentinelConnectionImpl.java
Patch:
@@ -82,6 +82,7 @@ public RedisSentinelReactiveCommands<K, V> reactive() {
      * @param clientName
      * @deprecated since 6.0, use {@link RedisSentinelAsyncCommands#clientSetname(Object)}.
      */
+    @Deprecated
     public void setClientName(String clientName) {
 
         CommandArgs<String, String> args = new CommandArgs<>(StringCodec.UTF8).add(CommandKeyword.SETNAME).addValue(clientName);

File: src/main/java/io/lettuce/core/cluster/ClusterDistributionChannelWriter.java
Patch:
@@ -169,9 +169,9 @@ private static <K, V> void writeCommand(RedisCommand<K, V, ?> command, boolean a
 
             if (asking) { // set asking bit
                 writeCommands(Arrays.asList(asking(), command), ((RedisChannelHandler<K, V>) connection).getChannelWriter());
+            } else {
+                writeCommand(command, ((RedisChannelHandler<K, V>) connection).getChannelWriter());
             }
-
-            writeCommand(command, ((RedisChannelHandler<K, V>) connection).getChannelWriter());
         } catch (Exception e) {
             command.completeExceptionally(e);
         }

File: src/main/java/io/lettuce/core/cluster/ReadOnlyCommands.java
Patch:
@@ -59,7 +59,9 @@ enum CommandName {
         HVALS, INFO, KEYS, LINDEX, LLEN, LRANGE, MGET, PFCOUNT, PTTL, //
         RANDOMKEY, READWRITE, SCAN, SCARD, SCRIPT, //
         SDIFF, SINTER, SISMEMBER, SMEMBERS, SRANDMEMBER, SSCAN, STRLEN, //
-        SUNION, TIME, TTL, TYPE, ZCARD, ZCOUNT, ZLEXCOUNT, ZRANGE, //
+        SUNION, TIME, TTL, TYPE, //
+        XINFO, XLEN, XPENDING, XRANGE, XREVRANGE, XREAD, //
+        ZCARD, ZCOUNT, ZLEXCOUNT, ZRANGE, //
         ZRANGEBYLEX, ZRANGEBYSCORE, ZRANK, ZREVRANGE, ZREVRANGEBYLEX, ZREVRANGEBYSCORE, ZREVRANK, ZSCAN, ZSCORE, //
 
         // Pub/Sub commands are no key-space commands so they are safe to execute on replica nodes

File: src/main/java/io/lettuce/core/masterreplica/ReadOnlyCommands.java
Patch:
@@ -59,7 +59,9 @@ enum CommandName {
         HVALS, INFO, KEYS, LINDEX, LLEN, LRANGE, MGET, PFCOUNT, PTTL, //
         RANDOMKEY, READWRITE, SCAN, SCARD, SCRIPT, //
         SDIFF, SINTER, SISMEMBER, SMEMBERS, SRANDMEMBER, SSCAN, STRLEN, //
-        SUNION, TIME, TTL, TYPE, ZCARD, ZCOUNT, ZLEXCOUNT, ZRANGE, //
+        SUNION, TIME, TTL, TYPE, //
+        XINFO, XLEN, XPENDING, XRANGE, XREVRANGE, XREAD, //
+        ZCARD, ZCOUNT, ZLEXCOUNT, ZRANGE, //
         ZRANGEBYLEX, ZRANGEBYSCORE, ZRANK, ZREVRANGE, ZREVRANGEBYLEX, ZREVRANGEBYSCORE, ZREVRANK, ZSCAN, ZSCORE,
     }
 }

File: src/test/java/io/lettuce/core/cluster/ReadOnlyCommandsUnitTests.java
Patch:
@@ -29,7 +29,7 @@ class ReadOnlyCommandsUnitTests {
 
     @Test
     void testCount() {
-        assertThat(ReadOnlyCommands.getReadOnlyCommands()).hasSize(70);
+        assertThat(ReadOnlyCommands.getReadOnlyCommands()).hasSize(76);
     }
 
     @Test

File: src/main/java/io/lettuce/core/LettuceFutures.java
Patch:
@@ -73,5 +73,4 @@ public static boolean awaitAll(long timeout, TimeUnit unit, Future<?>... futures
     public static <T> T awaitOrCancel(RedisFuture<T> cmd, long timeout, TimeUnit unit) {
         return Futures.awaitOrCancel(cmd, timeout, unit);
     }
-
 }

File: src/main/java/io/lettuce/core/RedisURI.java
Patch:
@@ -406,7 +406,7 @@ public Duration getTimeout() {
     }
 
     /**
-     * Sets the command timeout for synchronous command execution.
+     * Sets the command timeout for synchronous command execution. A zero timeout value indicates to not time out.
      *
      * @param timeout the command timeout for synchronous command execution.
      * @since 5.0

File: src/main/java/io/lettuce/core/TimeoutOptions.java
Patch:
@@ -240,7 +240,8 @@ public static abstract class TimeoutSource {
          * required but a connect did not finish yet.
          *
          * @param command can be {@literal null}.
-         * @return the timeout value. Values less or equal to zero do not timeout the command.
+         * @return the timeout value. Zero disables the timeout. A value of {@code -1} applies the default timeout configured on
+         *         the connection.
          */
         public abstract long getTimeout(RedisCommand<?, ?, ?> command);
 

File: src/main/java/io/lettuce/core/api/StatefulConnection.java
Patch:
@@ -36,7 +36,7 @@
 public interface StatefulConnection<K, V> extends AutoCloseable, AsyncCloseable {
 
     /**
-     * Set the default command timeout for this connection.
+     * Set the default command timeout for this connection. A zero timeout value indicates to not time out.
      *
      * @param timeout Command timeout.
      * @since 5.0

File: src/main/java/io/lettuce/core/cluster/api/async/RedisClusterAsyncCommands.java
Patch:
@@ -38,7 +38,7 @@ public interface RedisClusterAsyncCommands<K, V> extends BaseRedisAsyncCommands<
         RedisSortedSetAsyncCommands<K, V>, RedisStreamAsyncCommands<K, V>, RedisStringAsyncCommands<K, V> {
 
     /**
-     * Set the default timeout for operations.
+     * Set the default timeout for operations. A zero timeout value indicates to not time out.
      *
      * @param timeout the timeout value
      * @since 5.0

File: src/main/java/io/lettuce/core/cluster/api/reactive/RedisClusterReactiveCommands.java
Patch:
@@ -39,7 +39,7 @@ public interface RedisClusterReactiveCommands<K, V> extends BaseRedisReactiveCom
         RedisStringReactiveCommands<K, V> {
 
     /**
-     * Set the default timeout for operations.
+     * Set the default timeout for operations. A zero timeout value indicates to not time out.
      *
      * @param timeout the timeout value
      * @since 5.0

File: src/test/java/io/lettuce/core/pubsub/PubSubCommandTest.java
Patch:
@@ -132,8 +132,8 @@ void authWithReconnect() {
 
             assertThat(channels.take()).isEqualTo(channel);
 
-            long id = findNamedClient("authWithReconnect");
             redis.auth(passwd);
+            long id = findNamedClient("authWithReconnect");
             redis.clientKill(KillArgs.Builder.id(id));
 
             Delay.delay(Duration.ofMillis(100));
@@ -347,7 +347,6 @@ void unsubscribe() throws Exception {
 
         assertThat(channels).isEmpty();
         assertThat(patterns).isEmpty();
-
     }
 
     @Test

File: src/main/java/io/lettuce/core/AbstractRedisAsyncCommands.java
Patch:
@@ -1065,7 +1065,7 @@ public RedisFuture<String> quit() {
     }
 
     @Override
-    public RedisFuture<V> randomkey() {
+    public RedisFuture<K> randomkey() {
         return dispatch(commandBuilder.randomkey());
     }
 

File: src/main/java/io/lettuce/core/AbstractRedisReactiveCommands.java
Patch:
@@ -1147,7 +1147,7 @@ public Mono<String> quit() {
     }
 
     @Override
-    public Mono<V> randomkey() {
+    public Mono<K> randomkey() {
         return createMono(commandBuilder::randomkey);
     }
 

File: src/main/java/io/lettuce/core/RedisCommandBuilder.java
Patch:
@@ -1494,8 +1494,8 @@ Command<K, V, String> quit() {
         return createCommand(QUIT, new StatusOutput<>(codec));
     }
 
-    Command<K, V, V> randomkey() {
-        return createCommand(RANDOMKEY, new ValueOutput<>(codec));
+    Command<K, V, K> randomkey() {
+        return createCommand(RANDOMKEY, new KeyOutput<>(codec));
     }
 
     Command<K, V, String> readOnly() {

File: src/main/java/io/lettuce/core/api/async/RedisKeyAsyncCommands.java
Patch:
@@ -235,9 +235,9 @@ public interface RedisKeyAsyncCommands<K, V> {
     /**
      * Return a random key from the keyspace.
      *
-     * @return V bulk-string-reply the random key, or {@literal null} when the database is empty.
+     * @return K bulk-string-reply the random key, or {@literal null} when the database is empty.
      */
-    RedisFuture<V> randomkey();
+    RedisFuture<K> randomkey();
 
     /**
      * Rename a key.

File: src/main/java/io/lettuce/core/api/reactive/RedisKeyReactiveCommands.java
Patch:
@@ -236,9 +236,9 @@ public interface RedisKeyReactiveCommands<K, V> {
     /**
      * Return a random key from the keyspace.
      *
-     * @return V bulk-string-reply the random key, or {@literal null} when the database is empty.
+     * @return K bulk-string-reply the random key, or {@literal null} when the database is empty.
      */
-    Mono<V> randomkey();
+    Mono<K> randomkey();
 
     /**
      * Rename a key.

File: src/main/java/io/lettuce/core/api/sync/RedisKeyCommands.java
Patch:
@@ -235,9 +235,9 @@ public interface RedisKeyCommands<K, V> {
     /**
      * Return a random key from the keyspace.
      *
-     * @return V bulk-string-reply the random key, or {@literal null} when the database is empty.
+     * @return K bulk-string-reply the random key, or {@literal null} when the database is empty.
      */
-    V randomkey();
+    K randomkey();
 
     /**
      * Rename a key.

File: src/main/java/io/lettuce/core/cluster/RedisAdvancedClusterAsyncCommandsImpl.java
Patch:
@@ -392,13 +392,13 @@ public RedisFuture<Boolean> msetnx(Map<K, V> map) {
     }
 
     @Override
-    public RedisFuture<V> randomkey() {
+    public RedisFuture<K> randomkey() {
 
         Partitions partitions = getStatefulConnection().getPartitions();
         int index = ThreadLocalRandom.current().nextInt(partitions.size());
         RedisClusterNode partition = partitions.getPartition(index);
 
-        CompletableFuture<V> future = getConnectionAsync(partition.getUri().getHost(), partition.getUri().getPort())
+        CompletableFuture<K> future = getConnectionAsync(partition.getUri().getHost(), partition.getUri().getPort())
                 .thenCompose(RedisKeyAsyncCommands::randomkey);
 
         return new PipelinedRedisFuture<>(future);

File: src/main/java/io/lettuce/core/cluster/RedisAdvancedClusterReactiveCommandsImpl.java
Patch:
@@ -347,7 +347,7 @@ public Mono<String> mset(Map<K, V> map) {
     }
 
     @Override
-    public Mono<V> randomkey() {
+    public Mono<K> randomkey() {
 
         Partitions partitions = getStatefulConnection().getPartitions();
         int index = ThreadLocalRandom.current().nextInt(partitions.size());

File: src/main/java/io/lettuce/core/cluster/api/async/NodeSelectionKeyAsyncCommands.java
Patch:
@@ -235,9 +235,9 @@ public interface NodeSelectionKeyAsyncCommands<K, V> {
     /**
      * Return a random key from the keyspace.
      *
-     * @return V bulk-string-reply the random key, or {@literal null} when the database is empty.
+     * @return K bulk-string-reply the random key, or {@literal null} when the database is empty.
      */
-    AsyncExecutions<V> randomkey();
+    AsyncExecutions<K> randomkey();
 
     /**
      * Rename a key.

File: src/main/java/io/lettuce/core/cluster/api/async/RedisAdvancedClusterAsyncCommands.java
Patch:
@@ -272,10 +272,10 @@ default AsyncNodeSelection<K, V> all() {
     /**
      * Return a random key from the keyspace on a random master.
      *
-     * @return V bulk-string-reply the random key, or {@literal null} when the database is empty.
+     * @return K bulk-string-reply the random key, or {@literal null} when the database is empty.
      * @see RedisKeyAsyncCommands#randomkey()
      */
-    RedisFuture<V> randomkey();
+    RedisFuture<K> randomkey();
 
     /**
      * Remove all the scripts from the script cache on all cluster nodes.

File: src/main/java/io/lettuce/core/cluster/api/reactive/RedisAdvancedClusterReactiveCommands.java
Patch:
@@ -178,10 +178,10 @@ public interface RedisAdvancedClusterReactiveCommands<K, V> extends RedisCluster
     /**
      * Return a random key from the keyspace on a random master.
      *
-     * @return V bulk-string-reply the random key, or {@literal null} when the database is empty.
+     * @return K bulk-string-reply the random key, or a {@link Mono} that completes empty when the database is empty.
      * @see RedisKeyReactiveCommands#randomkey()
      */
-    Mono<V> randomkey();
+    Mono<K> randomkey();
 
     /**
      * Remove all the scripts from the script cache on all cluster nodes.

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionKeyCommands.java
Patch:
@@ -235,9 +235,9 @@ public interface NodeSelectionKeyCommands<K, V> {
     /**
      * Return a random key from the keyspace.
      *
-     * @return V bulk-string-reply the random key, or {@literal null} when the database is empty.
+     * @return K bulk-string-reply the random key, or {@literal null} when the database is empty.
      */
-    Executions<V> randomkey();
+    Executions<K> randomkey();
 
     /**
      * Rename a key.

File: src/main/templates/io/lettuce/core/api/RedisKeyCommands.java
Patch:
@@ -234,9 +234,9 @@ public interface RedisKeyCommands<K, V> {
     /**
      * Return a random key from the keyspace.
      *
-     * @return V bulk-string-reply the random key, or {@literal null} when the database is empty.
+     * @return K bulk-string-reply the random key, or {@literal null} when the database is empty.
      */
-    V randomkey();
+    K randomkey();
 
     /**
      * Rename a key.

File: src/main/java/io/lettuce/core/resource/EpollProvider.java
Patch:
@@ -61,11 +61,11 @@ public class EpollProvider {
         EPOLL_AVAILABLE = availability;
 
         if (EPOLL_AVAILABLE) {
-            logger.info("Starting with epoll library");
+            logger.debug("Starting with epoll library");
             EPOLL_RESOURCES = AvailableEpollResources.INSTANCE;
 
         } else {
-            logger.info("Starting without optional epoll library");
+            logger.debug("Starting without optional epoll library");
             EPOLL_RESOURCES = UnavailableEpollResources.INSTANCE;
         }
     }

File: src/main/java/io/lettuce/core/cluster/RedisAdvancedClusterAsyncCommandsImpl.java
Patch:
@@ -421,7 +421,7 @@ public RedisFuture<String> scriptKill() {
     }
 
     @Override
-    public RedisFuture<String> scriptLoad(V script) {
+    public RedisFuture<String> scriptLoad(byte[] script) {
 
         Map<String, CompletableFuture<String>> executions = executeOnNodes(cmd -> cmd.scriptLoad(script),
                 redisClusterNode -> true);

File: src/main/java/io/lettuce/core/cluster/RedisAdvancedClusterReactiveCommandsImpl.java
Patch:
@@ -369,7 +369,7 @@ public Mono<String> scriptKill() {
     }
 
     @Override
-    public Mono<String> scriptLoad(V script) {
+    public Mono<String> scriptLoad(byte[] script) {
         Map<String, Publisher<String>> publishers = executeOnNodes((commands) -> commands.scriptLoad(script), ALL_NODES);
         return Flux.merge(publishers.values()).last();
     }

File: src/main/java/io/lettuce/core/protocol/CommandEncoder.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.EncoderException;
 import io.netty.handler.codec.MessageToByteEncoder;
+import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -40,7 +41,7 @@ public class CommandEncoder extends MessageToByteEncoder<Object> {
     private final boolean debugEnabled = logger.isDebugEnabled();
 
     public CommandEncoder() {
-        this(true);
+        this(PlatformDependent.directBufferPreferred());
     }
 
     public CommandEncoder(boolean preferDirect) {

File: src/main/java/io/lettuce/core/protocol/CommandHandler.java
Patch:
@@ -168,7 +168,7 @@ public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
 
         setState(LifecycleState.REGISTERED);
 
-        buffer = ctx.alloc().directBuffer(8192 * 8);
+        buffer = ctx.alloc().buffer(8192 * 8);
         rsm = new RedisStateMachine(ctx.alloc());
         ctx.fireChannelRegistered();
     }

File: src/main/java/io/lettuce/core/protocol/RedisStateMachine.java
Patch:
@@ -185,7 +185,7 @@ public String toString() {
      * Initialize a new instance.
      */
     public RedisStateMachine(ByteBufAllocator alloc) {
-        this.responseElementBuffer = alloc.directBuffer(1024);
+        this.responseElementBuffer = alloc.buffer(1024);
     }
 
     public boolean isDiscoverProtocol() {

File: src/main/java/io/lettuce/core/RedisURI.java
Patch:
@@ -962,7 +962,7 @@ public static class Builder {
         private String host;
         private String socket;
         private String sentinelMasterId;
-        private int port;
+        private int port = DEFAULT_REDIS_PORT;
         private int database;
         private String clientName;
         private String username;

File: src/test/java/io/lettuce/core/commands/ServerCommandIntegrationTests.java
Patch:
@@ -36,7 +36,6 @@
 import org.junit.jupiter.api.TestInstance;
 import org.junit.jupiter.api.extension.ExtendWith;
 
-import io.lettuce.RedisBug;
 import io.lettuce.core.*;
 import io.lettuce.core.api.StatefulRedisConnection;
 import io.lettuce.core.api.sync.RedisCommands;
@@ -90,7 +89,6 @@ void bgsave() {
     }
 
     @Test
-    @RedisBug("https://github.com/antirez/redis/issues/6036")
     void clientGetSetname() {
         assertThat(redis.clientGetname()).isNull();
         assertThat(redis.clientSetname("test")).isEqualTo("OK");

File: src/main/java/io/lettuce/core/ConnectionEventTrigger.java
Patch:
@@ -18,6 +18,7 @@
 import java.net.SocketAddress;
 
 import io.lettuce.core.event.EventBus;
+import io.lettuce.core.event.connection.ConnectionActivatedEvent;
 import io.lettuce.core.event.connection.ConnectionDeactivatedEvent;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
@@ -43,6 +44,7 @@ class ConnectionEventTrigger extends ChannelInboundHandlerAdapter {
     @Override
     public void channelActive(ChannelHandlerContext ctx) throws Exception {
         connectionEvents.fireEventRedisConnected(connection, ctx.channel().remoteAddress());
+        eventBus.publish(new ConnectionActivatedEvent(local(ctx), remote(ctx)));
         super.channelActive(ctx);
     }
 

File: src/main/java/io/lettuce/core/RedisCommandBuilder.java
Patch:
@@ -26,7 +26,6 @@
 import io.lettuce.core.XReadArgs.StreamOffset;
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.codec.StringCodec;
-import io.lettuce.core.codec.StringCodec;
 import io.lettuce.core.internal.LettuceAssert;
 import io.lettuce.core.output.*;
 import io.lettuce.core.protocol.*;
@@ -853,7 +852,7 @@ Command<K, V, Long> hdel(K key, K... fields) {
         return createCommand(HDEL, new IntegerOutput<>(codec), args);
     }
 
-    Command<String, String, Map<String, Object>> hello(int protocolVersion, byte[] user, byte password[], byte[] name) {
+    Command<String, String, Map<String, Object>> hello(int protocolVersion, String user, char[] password, String name) {
 
         CommandArgs<String, String> args = new CommandArgs<>(StringCodec.ASCII).add(protocolVersion);
 

File: src/main/java/io/lettuce/core/cluster/CommandSet.java
Patch:
@@ -24,17 +24,17 @@
 /**
  * Value object representing the current Redis state regarding its commands.
  * <p>
- * {@link RedisState} caches command details and uses {@link CommandType}.
+ * {@link CommandSet} caches command details and uses {@link CommandType}.
  *
  * @author Mark Paluch
  * @since 4.4
  */
-class RedisState {
+class CommandSet {
 
     private final Map<String, CommandDetail> commands;
     private final EnumSet<CommandType> availableCommands = EnumSet.noneOf(CommandType.class);
 
-    public RedisState(Collection<CommandDetail> commands) {
+    public CommandSet(Collection<CommandDetail> commands) {
 
         Map<String, CommandDetail> map = new HashMap<>();
 

File: src/main/java/io/lettuce/core/cluster/RedisAdvancedClusterAsyncCommandsImpl.java
Patch:
@@ -649,8 +649,8 @@ private RedisClusterAsyncCommands<K, V> findConnectionBySlot(int slot) {
         return null;
     }
 
-    private RedisState getRedisState() {
-        return ((StatefulRedisClusterConnectionImpl<K, V>) super.getConnection()).getState();
+    private CommandSet getRedisState() {
+        return ((StatefulRedisClusterConnectionImpl<K, V>) super.getConnection()).getCommandSet();
     }
 
     private boolean hasRedisState() {

File: src/main/java/io/lettuce/core/cluster/RedisAdvancedClusterReactiveCommandsImpl.java
Patch:
@@ -573,8 +573,8 @@ private Mono<RedisClusterReactiveCommands<K, V>> findConnectionBySlotReactive(in
         return Mono.error(new RedisException("No partition for slot " + slot));
     }
 
-    private RedisState getRedisState() {
-        return ((StatefulRedisClusterConnectionImpl<K, V>) super.getConnection()).getState();
+    private CommandSet getRedisState() {
+        return ((StatefulRedisClusterConnectionImpl<K, V>) super.getConnection()).getCommandSet();
     }
 
     private boolean hasRedisState() {

File: src/test/java/io/lettuce/core/cluster/RedisClusterClientIntegrationTests.java
Patch:
@@ -35,7 +35,6 @@
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
-import org.springframework.test.util.ReflectionTestUtils;
 
 import io.lettuce.core.*;
 import io.lettuce.core.api.StatefulRedisConnection;
@@ -517,11 +516,11 @@ void readOnlyOnCluster() {
 
         TestFutures.awaitOrTimeout(connection.async().quit());
 
-        assertThat(ReflectionTestUtils.getField(connection, "readOnly")).isEqualTo(Boolean.TRUE);
+        assertThat(connection).extracting("connectionState").extracting("readOnly").isEqualTo(Boolean.TRUE);
 
         sync.readWrite();
 
-        assertThat(ReflectionTestUtils.getField(connection, "readOnly")).isEqualTo(Boolean.FALSE);
+        assertThat(connection).extracting("connectionState").extracting("readOnly").isEqualTo(Boolean.FALSE);
         RedisClusterClient clusterClient = RedisClusterClient.create(TestClientResources.get(),
                 RedisURI.Builder.redis(host, 40400).build());
         try {

File: src/test/java/io/lettuce/core/pubsub/PubSubCommandHandlerUnitTests.java
Patch:
@@ -278,7 +278,7 @@ void shouldCompleteUnsubscribe() throws Exception {
         doAnswer((Answer<PubSubEndpoint<String, String>>) inv -> {
             PubSubOutput<String, String, String> out = inv.getArgument(0);
             if (out.type() == PubSubOutput.Type.message) {
-                throw new NullPointerException();
+                throw new NullPointerException("Expected exception");
             }
             return endpoint;
         }).when(endpoint).notifyMessage(any());

File: src/main/java/io/lettuce/core/RedisPublisher.java
Patch:
@@ -18,7 +18,6 @@
 import java.util.Collection;
 import java.util.Objects;
 import java.util.Queue;
-import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReference;
@@ -32,7 +31,6 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.util.context.Context;
-import sun.rmi.runtime.Log;
 import io.lettuce.core.api.StatefulConnection;
 import io.lettuce.core.api.StatefulRedisConnection;
 import io.lettuce.core.internal.LettuceAssert;
@@ -161,7 +159,6 @@ static class RedisSubscription<T> extends StreamingOutput.Subscriber<T> implemen
         final RedisCommand<?, ?, T> command;
         final boolean dissolve;
         private final Executor executor;
-        final ArrayBlockingQueue<Log> logs = new ArrayBlockingQueue<>(1024 * 4);
 
         // accessed via AtomicLongFieldUpdater
         @SuppressWarnings("unused")

File: src/main/java/io/lettuce/core/resource/ClientResources.java
Patch:
@@ -231,7 +231,7 @@ interface Builder {
      * Returns a builder to create new {@link ClientResources} whose settings are replicated from the current
      * {@link ClientResources}.
      *
-     * @return a a {@link ClientResources.Builder} to create new {@link ClientResources} whose settings are replicated from the
+     * @return a {@link ClientResources.Builder} to create new {@link ClientResources} whose settings are replicated from the
      *         current {@link ClientResources}
      *
      * @since 5.1

File: src/test/jmh/io/lettuce/core/protocol/RedisStateMachineBenchmark.java
Patch:
@@ -23,6 +23,7 @@
 import io.lettuce.core.codec.ByteArrayCodec;
 import io.lettuce.core.output.ArrayOutput;
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.PooledByteBufAllocator;
 
 /**
@@ -59,7 +60,7 @@ public void set(long integer) {
 
     private ByteBuf masterBuffer;
 
-    private final RedisStateMachine stateMachine = new RedisStateMachine();
+    private final RedisStateMachine stateMachine = new RedisStateMachine(ByteBufAllocator.DEFAULT);
     private final byte[] payload = ("*3\r\n" + //
             "$4\r\n" + //
             "LLEN\r\n" + //

File: src/test/java/io/lettuce/core/cluster/AdvancedClusterReactiveIntegrationTests.java
Patch:
@@ -251,6 +251,7 @@ void keysDoesNotRunIntoRaceConditions() {
         for (int i = 0; i < 1000; i++) {
             CompletableFuture<Long> future = commands.keys("*").count().toFuture();
             Futures.await(future);
+            assertThat(future).isCompletedWithValue(1000L);
         }
     }
 

File: src/test/java/io/lettuce/core/cluster/ScanIteratorIntegrationTests.java
Patch:
@@ -49,13 +49,14 @@ class ScanIteratorIntegrationTests extends TestSupport {
     @Inject
     ScanIteratorIntegrationTests(StatefulRedisClusterConnection<String, String> connection) {
         this.connection = connection;
-        this.connection.setReadFrom(ReadFrom.MASTER);
         this.redis = connection.sync();
+        this.connection.sync().flushall();
     }
 
     @BeforeEach
     void setUp() {
         this.redis.flushall();
+        this.connection.setReadFrom(ReadFrom.MASTER);
     }
 
     @Test
@@ -184,7 +185,6 @@ void sscanShouldThrowNoSuchElementExceptionOnEmpty() {
 
     @Test
     void setSinglePass() {
-
         redis.sadd(key, KeysAndValues.KEYS.toArray(new String[0]));
 
         ScanIterator<String> scan = ScanIterator.sscan(redis, key, ScanArgs.Builder.limit(50).match("key-11*"));

File: src/main/java/io/lettuce/core/dynamic/RedisCommandFactory.java
Patch:
@@ -271,7 +271,7 @@ private AbstractRedisReactiveCommands getReactiveCommands() {
                 reactive = ((StatefulRedisClusterConnection) connection).reactive();
             }
 
-            if (Proxy.isProxyClass(reactive.getClass())) {
+            if (reactive != null && Proxy.isProxyClass(reactive.getClass())) {
 
                 InvocationHandler invocationHandler = Proxy.getInvocationHandler(reactive);
                 reactive = ConnectionWrapping.unwrap(invocationHandler);
@@ -302,7 +302,8 @@ class BatchAwareCommandLookupStrategy implements ExecutableCommandLookupStrategy
         private Batcher batcher = Batcher.NONE;
         private BatchExecutableCommandLookupStrategy batchingStrategy;
 
-        public BatchAwareCommandLookupStrategy(ExecutableCommandLookupStrategy fallbackStrategy, RedisCommandsMetadata metadata) {
+        public BatchAwareCommandLookupStrategy(ExecutableCommandLookupStrategy fallbackStrategy,
+                RedisCommandsMetadata metadata) {
 
             this.fallbackStrategy = fallbackStrategy;
             this.verifier = verifyCommandMethods ? commandMethodVerifier : CommandMethodVerifier.NONE;

File: src/main/java/io/lettuce/core/dynamic/support/TypeWrapper.java
Patch:
@@ -209,9 +209,9 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl
                 return this.provider;
             }
 
-            if (Type.class == method.getReturnType() && args == null) {
+            if (Type.class == method.getReturnType()) {
                 return forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, -1));
-            } else if (Type[].class == method.getReturnType() && args == null) {
+            } else if (Type[].class == method.getReturnType()) {
                 Type[] result = new Type[((Type[]) method.invoke(this.provider.getType(), args)).length];
                 for (int i = 0; i < result.length; i++) {
                     result[i] = forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, i));

File: src/main/java/io/lettuce/core/support/ConnectionPoolSupport.java
Patch:
@@ -171,13 +171,13 @@ public void returnObject(T obj) {
 
         SoftReferenceObjectPool<T> pool = new SoftReferenceObjectPool<T>(new RedisPooledObjectFactory<>(connectionSupplier)) {
             @Override
-            public T borrowObject() throws Exception {
+            public synchronized T borrowObject() throws Exception {
                 return wrapConnections ? ConnectionWrapping.wrapConnection(super.borrowObject(), poolRef.get()) : super
                         .borrowObject();
             }
 
             @Override
-            public void returnObject(T obj) throws Exception {
+            public synchronized void returnObject(T obj) throws Exception {
 
                 if (wrapConnections && obj instanceof HasTargetConnection) {
                     super.returnObject((T) ((HasTargetConnection) obj).getTargetConnection());

File: src/main/java/io/lettuce/core/RedisAsyncCommandsImpl.java
Patch:
@@ -27,8 +27,8 @@
  * @param <V> Value type.
  * @author Mark Paluch
  */
-public class RedisAsyncCommandsImpl<K, V> extends AbstractRedisAsyncCommands<K, V> implements RedisAsyncCommands<K, V>,
-        RedisClusterAsyncCommands<K, V> {
+public class RedisAsyncCommandsImpl<K, V> extends AbstractRedisAsyncCommands<K, V>
+        implements RedisAsyncCommands<K, V>, RedisClusterAsyncCommands<K, V> {
 
     /**
      * Initialize a new instance.
@@ -42,7 +42,6 @@ public RedisAsyncCommandsImpl(StatefulRedisConnection<K, V> connection, RedisCod
     }
 
     @Override
-    @SuppressWarnings("unchecked")
     public StatefulRedisConnection<K, V> getStatefulConnection() {
         return (StatefulRedisConnection<K, V>) super.getConnection();
     }

File: src/main/java/io/lettuce/core/RedisReactiveCommandsImpl.java
Patch:
@@ -27,8 +27,8 @@
  * @param <V> Value type.
  * @author Mark Paluch
  */
-public class RedisReactiveCommandsImpl<K, V> extends AbstractRedisReactiveCommands<K, V> implements
-        RedisReactiveCommands<K, V>, RedisClusterReactiveCommands<K, V> {
+public class RedisReactiveCommandsImpl<K, V> extends AbstractRedisReactiveCommands<K, V>
+        implements RedisReactiveCommands<K, V>, RedisClusterReactiveCommands<K, V> {
 
     /**
      * Initialize a new instance.
@@ -42,7 +42,6 @@ public RedisReactiveCommandsImpl(StatefulRedisConnection<K, V> connection, Redis
     }
 
     @Override
-    @SuppressWarnings("unchecked")
     public StatefulRedisConnection<K, V> getStatefulConnection() {
         return (StatefulRedisConnection<K, V>) super.getConnection();
     }

File: src/main/java/io/lettuce/core/cluster/StatefulRedisClusterConnectionImpl.java
Patch:
@@ -170,7 +170,7 @@ public CompletableFuture<StatefulRedisConnection<K, V>> getConnectionAsync(Strin
         return provider.getConnectionAsync(ClusterConnectionProvider.Intent.WRITE, host, port);
     }
 
-    public ClusterDistributionChannelWriter getClusterDistributionChannelWriter() {
+    ClusterDistributionChannelWriter getClusterDistributionChannelWriter() {
         return (ClusterDistributionChannelWriter) super.getChannelWriter();
     }
 

File: src/main/java/io/lettuce/core/pubsub/RedisPubSubReactiveCommandsImpl.java
Patch:
@@ -32,9 +32,10 @@
  * @param <K> Key type.
  * @param <V> Value type.
  * @author Mark Paluch
+ * @since 5.0
  */
-public class RedisPubSubReactiveCommandsImpl<K, V> extends RedisReactiveCommandsImpl<K, V> implements
-        RedisPubSubReactiveCommands<K, V> {
+public class RedisPubSubReactiveCommandsImpl<K, V> extends RedisReactiveCommandsImpl<K, V>
+        implements RedisPubSubReactiveCommands<K, V> {
 
     private final PubSubCommandBuilder<K, V> commandBuilder;
 

File: src/test/java/io/lettuce/core/cluster/RedisClusterStressScenariosTest.java
Patch:
@@ -129,7 +129,7 @@ public void testClusterConnectionStability() {
         RedisAdvancedClusterAsyncCommandsImpl<String, String> connection = (RedisAdvancedClusterAsyncCommandsImpl<String, String>) clusterClient
                 .connect().async();
 
-        RedisChannelHandler<String, String> statefulConnection = connection.getStatefulConnection();
+        RedisChannelHandler<String, String> statefulConnection = (RedisChannelHandler) connection.getStatefulConnection();
 
         connection.set("a", "b");
         ClusterDistributionChannelWriter writer = (ClusterDistributionChannelWriter) statefulConnection.getChannelWriter();

File: src/main/java/io/lettuce/core/RedisURI.java
Patch:
@@ -38,7 +38,7 @@
  * Redis URI. Contains connection details for the Redis/Sentinel connections. You can provide the database, client name,
  * password and timeouts within the RedisURI.
  *
- * You have following possibilities to create a {@link RedisURI}:
+ * You have the following possibilities to create a {@link RedisURI}:
  *
  * <ul>
  * <li>Use an URI:

File: src/test/java/io/lettuce/core/cluster/ClusterPartiallyDownIntegrationTests.java
Patch:
@@ -111,7 +111,7 @@ void seedNodesAreOffline() {
             fail("Missing RedisException");
         } catch (RedisException e) {
             assertThat(e).hasCauseInstanceOf(RedisConnectionException.class);
-            assertThat(e.getCause()).hasMessage("Unable to establish a connection to Redis Cluster");
+            assertThat(e.getCause()).hasMessageStartingWith("Unable to establish a connection to Redis Cluster");
         }
     }
 

File: src/main/java/io/lettuce/core/AbstractRedisReactiveCommands.java
Patch:
@@ -402,10 +402,11 @@ private <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier,
         if (tracingEnabled) {
 
             return withTraceContext().flatMapMany(
-                    it -> Flux.from(new RedisPublisher<>(decorate(commandSupplier, it), connection, dissolve, getScheduler())));
+                    it -> Flux.from(new RedisPublisher<>(decorate(commandSupplier, it), connection, dissolve, getScheduler()
+                            .next())));
         }
 
-        return Flux.from(new RedisPublisher<>(commandSupplier, connection, dissolve, getScheduler()));
+        return Flux.from(new RedisPublisher<>(commandSupplier, connection, dissolve, getScheduler().next()));
     }
 
     private Mono<TraceContext> withTraceContext() {

File: src/main/java/io/lettuce/core/masterslave/StaticMasterSlaveTopologyProvider.java
Patch:
@@ -87,7 +87,7 @@ public CompletableFuture<List<RedisNodeDescription>> getNodesAsync() {
 
                             if (nodeDescriptions.isEmpty()) {
                                 return Mono.error(new RedisConnectionException(String.format(
-                                        "Failed to connect to at leas one node in %s", redisURIs)));
+                                        "Failed to connect to at least one node in %s", redisURIs)));
                             }
 
                             return Mono.just(nodeDescriptions);

File: src/main/java/io/lettuce/core/api/async/RedisTransactionalAsyncCommands.java
Patch:
@@ -41,7 +41,9 @@ public interface RedisTransactionalAsyncCommands<K, V> {
      *
      * @return List&lt;Object&gt; array-reply each element being the reply to each of the commands in the atomic transaction.
      *
-     *         When using {@code WATCH}, {@code EXEC} can return a
+     *         When using {@code WATCH}, {@code EXEC} can return a {@link TransactionResult#wasDiscarded discarded
+     *         TransactionResult}.
+     * @see TransactionResult#wasDiscarded
      */
     RedisFuture<TransactionResult> exec();
 

File: src/main/java/io/lettuce/core/api/reactive/RedisTransactionalReactiveCommands.java
Patch:
@@ -41,7 +41,9 @@ public interface RedisTransactionalReactiveCommands<K, V> {
      *
      * @return Object array-reply each element being the reply to each of the commands in the atomic transaction.
      *
-     *         When using {@code WATCH}, {@code EXEC} can return a
+     *         When using {@code WATCH}, {@code EXEC} can return a {@link TransactionResult#wasDiscarded discarded
+     *         TransactionResult}.
+     * @see TransactionResult#wasDiscarded
      */
     Mono<TransactionResult> exec();
 

File: src/main/java/io/lettuce/core/api/sync/RedisTransactionalCommands.java
Patch:
@@ -40,7 +40,9 @@ public interface RedisTransactionalCommands<K, V> {
      *
      * @return List&lt;Object&gt; array-reply each element being the reply to each of the commands in the atomic transaction.
      *
-     *         When using {@code WATCH}, {@code EXEC} can return a
+     *         When using {@code WATCH}, {@code EXEC} can return a {@link TransactionResult#wasDiscarded discarded
+     *         TransactionResult}.
+     * @see TransactionResult#wasDiscarded
      */
     TransactionResult exec();
 

File: src/main/templates/io/lettuce/core/api/RedisTransactionalCommands.java
Patch:
@@ -40,7 +40,9 @@ public interface RedisTransactionalCommands<K, V> {
      *
      * @return List&lt;Object&gt; array-reply each element being the reply to each of the commands in the atomic transaction.
      *
-     *         When using {@code WATCH}, {@code EXEC} can return a
+     *         When using {@code WATCH}, {@code EXEC} can return a {@link TransactionResult#wasDiscarded discarded
+     *         TransactionResult}.
+     * @see TransactionResult#wasDiscarded
      */
     TransactionResult exec();
 

File: src/main/java/io/lettuce/core/cluster/PooledClusterConnectionProvider.java
Patch:
@@ -104,9 +104,10 @@ public CompletableFuture<StatefulRedisConnection<K, V>> getConnectionAsync(Inten
             logger.debug("getConnection(" + intent + ", " + slot + ")");
         }
 
-        if (intent == Intent.READ && readFrom != null) {
+        if (intent == Intent.READ && readFrom != null && readFrom != ReadFrom.MASTER) {
             return getReadConnection(slot);
         }
+
         return getWriteConnection(slot).toCompletableFuture();
     }
 

File: src/test/java/io/lettuce/core/dynamic/RedisCommandsSyncIntegrationTests.java
Patch:
@@ -119,7 +119,7 @@ default byte[] getAsBytes() {
             return getAsBytes("key");
         }
 
-        @Command("GET")
+        @Command("GET ?0")
         byte[] getAsBytes(String key);
 
         @Command("SET")

File: src/test/java/io/lettuce/apigenerator/CreateAsyncApi.java
Patch:
@@ -38,7 +38,7 @@
  * @author Mark Paluch
  */
 @RunWith(Parameterized.class)
-class CreateAsyncApi {
+public class CreateAsyncApi {
 
     private Set<String> KEEP_METHOD_RESULT_TYPE = LettuceSets.unmodifiableSet("shutdown", "debugOom", "debugSegfault",
             "digest", "close", "isOpen", "BaseRedisCommands.reset", "getStatefulConnection", "setAutoFlushCommands",
@@ -47,7 +47,7 @@ class CreateAsyncApi {
     private CompilationUnitFactory factory;
 
     @Parameterized.Parameters(name = "Create {0}")
-    static List<Object[]> arguments() {
+    public static List<Object[]> arguments() {
         List<Object[]> result = new ArrayList<>();
 
         for (String templateName : Constants.TEMPLATE_NAMES) {
@@ -108,7 +108,7 @@ Supplier<List<String>> importSupplier() {
     }
 
     @Test
-    void createInterface() throws Exception {
+    public void createInterface() throws Exception {
         factory.createInterface();
     }
 }

File: src/test/java/io/lettuce/apigenerator/CreateAsyncNodeSelectionClusterApi.java
Patch:
@@ -39,15 +39,15 @@
  * @author Mark Paluch
  */
 @RunWith(Parameterized.class)
-class CreateAsyncNodeSelectionClusterApi {
+public class CreateAsyncNodeSelectionClusterApi {
 
     private Set<String> FILTER_METHODS = LettuceSets.unmodifiableSet("shutdown", "debugOom", "debugSegfault", "digest", "close",
             "isOpen", "BaseRedisCommands.reset", "readOnly", "readWrite", "setAutoFlushCommands", "flushCommands");
 
     private CompilationUnitFactory factory;
 
     @Parameterized.Parameters(name = "Create {0}")
-    static List<Object[]> arguments() {
+    public static List<Object[]> arguments() {
         List<Object[]> result = new ArrayList<>();
 
         for (String templateName : Constants.TEMPLATE_NAMES) {
@@ -114,7 +114,7 @@ Supplier<List<String>> importSupplier() {
     }
 
     @Test
-    void createInterface() throws Exception {
+    public void createInterface() throws Exception {
         factory.createInterface();
     }
 }

File: src/test/java/io/lettuce/apigenerator/CreateReactiveApi.java
Patch:
@@ -37,7 +37,7 @@
  * @author Mark Paluch
  */
 @RunWith(Parameterized.class)
-class CreateReactiveApi {
+public class CreateReactiveApi {
 
     private static Set<String> KEEP_METHOD_RESULT_TYPE = LettuceSets.unmodifiableSet("digest", "close", "isOpen",
             "BaseRedisCommands.reset", "getStatefulConnection", "setAutoFlushCommands", "flushCommands");
@@ -60,7 +60,7 @@ class CreateReactiveApi {
     private CompilationUnitFactory factory;
 
     @Parameterized.Parameters(name = "Create {0}")
-    static List<Object[]> arguments() {
+    public static List<Object[]> arguments() {
         List<Object[]> result = new ArrayList<>();
 
         for (String templateName : Constants.TEMPLATE_NAMES) {
@@ -175,7 +175,7 @@ Supplier<List<String>> importSupplier() {
     }
 
     @Test
-    void createInterface() throws Exception {
+    public void createInterface() throws Exception {
         factory.createInterface();
     }
 }

File: src/test/java/io/lettuce/apigenerator/CreateSyncApi.java
Patch:
@@ -39,14 +39,14 @@
  * @author Mark Paluch
  */
 @RunWith(Parameterized.class)
-class CreateSyncApi {
+public class CreateSyncApi {
 
     private Set<String> FILTER_METHODS = LettuceSets.unmodifiableSet("setAutoFlushCommands", "flushCommands");
 
     private CompilationUnitFactory factory;
 
     @Parameterized.Parameters(name = "Create {0}")
-    static List<Object[]> arguments() {
+    public static List<Object[]> arguments() {
         List<Object[]> result = new ArrayList<>();
 
         for (String templateName : Constants.TEMPLATE_NAMES) {
@@ -114,7 +114,7 @@ Supplier<List<String>> importSupplier() {
     }
 
     @Test
-    void createInterface() throws Exception {
+    public void createInterface() throws Exception {
         factory.createInterface();
     }
 }

File: src/test/java/io/lettuce/apigenerator/CreateSyncNodeSelectionClusterApi.java
Patch:
@@ -40,15 +40,15 @@
  * @author Mark Paluch
  */
 @RunWith(Parameterized.class)
-class CreateSyncNodeSelectionClusterApi {
+public class CreateSyncNodeSelectionClusterApi {
 
     private Set<String> FILTER_METHODS = LettuceSets.unmodifiableSet("shutdown", "debugOom", "debugSegfault", "digest",
             "close", "isOpen", "BaseRedisCommands.reset", "readOnly", "readWrite", "dispatch", "setAutoFlushCommands", "flushCommands");
 
     private CompilationUnitFactory factory;
 
     @Parameterized.Parameters(name = "Create {0}")
-    static List<Object[]> arguments() {
+    public static List<Object[]> arguments() {
         List<Object[]> result = new ArrayList<>();
 
         for (String templateName : Constants.TEMPLATE_NAMES) {
@@ -127,7 +127,7 @@ Supplier<List<String>> importSupplier() {
     }
 
     @Test
-    void createInterface() throws Exception {
+    public void createInterface() throws Exception {
         factory.createInterface();
     }
 }

File: src/main/java/io/lettuce/core/protocol/CommandHandler.java
Patch:
@@ -52,6 +52,7 @@
  * @author Mark Paluch
  * @author Jongyeol Choi
  * @author Grzegorz Szpak
+ * @author Daniel Albuquerque
  */
 public class CommandHandler extends ChannelDuplexHandler implements HasQueuedCommands {
 

File: src/main/java/io/lettuce/core/tracing/NoOpTracing.java
Patch:
@@ -21,6 +21,7 @@
  * No-Op {@link Tracing} support that does not trace at all.
  *
  * @author Mark Paluch
+ * @author Daniel Albuquerque
  * @since 5.1
  */
 enum NoOpTracing implements Tracing, TraceContextProvider, TracerProvider {

File: src/main/java/io/lettuce/core/pubsub/StatefulRedisPubSubConnectionImpl.java
Patch:
@@ -120,11 +120,11 @@ protected List<RedisFuture<Void>> resubscribe() {
 
         List<RedisFuture<Void>> result = new ArrayList<>();
 
-        if (!endpoint.getChannels().isEmpty()) {
+        if (endpoint.hasChannelSubscriptions()) {
             result.add(async().subscribe(toArray(endpoint.getChannels())));
         }
 
-        if (!endpoint.getPatterns().isEmpty()) {
+        if (endpoint.hasPatternSubscriptions()) {
             result.add(async().psubscribe(toArray(endpoint.getPatterns())));
         }
 

File: src/main/java/io/lettuce/core/metrics/CommandLatencyCollectorOptions.java
Patch:
@@ -51,7 +51,7 @@ static CommandLatencyCollectorOptions disabled() {
      * @since 5.1
      */
     static CommandLatencyCollectorOptions.Builder builder() {
-        return CommandLatencyCollectorOptions.builder();
+        return DefaultCommandLatencyCollectorOptions.builder();
     }
 
     /**

File: src/main/java/io/lettuce/core/dynamic/DeclaredCommandMethod.java
Patch:
@@ -79,8 +79,7 @@ private DeclaredCommandMethod(Method method, ExecutionSpecificParameters paramet
 
         ResolvableType actualReturnType = this.returnType;
 
-        while (Future.class.isAssignableFrom(actualReturnType.getRawClass())
-                || ReactiveTypes.supports(actualReturnType.getRawClass())) {
+        while (Future.class.isAssignableFrom(actualReturnType.getRawClass())) {
             ResolvableType[] generics = actualReturnType.getGenerics();
 
             if (generics.length != 1) {

File: src/test/java/io/lettuce/core/dynamic/DeclaredCommandMethodUnitTests.java
Patch:
@@ -52,15 +52,15 @@ void shouldResolveFluxComponentType() throws Exception {
 
         CommandMethod commandMethod = DeclaredCommandMethod.create(getMethod("getFlux"));
 
-        assertThat(commandMethod.getActualReturnType().getRawClass()).isEqualTo(String.class);
+        assertThat(commandMethod.getActualReturnType().getRawClass()).isEqualTo(Flux.class);
         assertThat(commandMethod.getReturnType().getRawClass()).isEqualTo(Flux.class);
     }
 
     private Method getMethod(String name) throws NoSuchMethodException {
         return MyInterface.class.getDeclaredMethod(name);
     }
 
-    private static interface MyInterface {
+    private interface MyInterface {
 
         String getString();
 

File: src/main/java/io/lettuce/core/internal/HostAndPort.java
Patch:
@@ -21,6 +21,7 @@
  * An immutable representation of a host and port.
  *
  * @author Mark Paluch
+ * @author Larry Battle
  * @since 4.2
  */
 public class HostAndPort {
@@ -91,11 +92,11 @@ public static HostAndPort parse(String hostPortString) {
         if (!LettuceStrings.isEmpty(portString)) {
             // Try to parse the whole port string as a number.
             // JDK7 accepts leading plus signs. We don't want to.
-            LettuceAssert.isTrue(!portString.startsWith("+"), String.format("Unparseable port number: %s", hostPortString));
+            LettuceAssert.isTrue(!portString.startsWith("+"), String.format("Cannot port number: %s", hostPortString));
             try {
                 port = Integer.parseInt(portString);
             } catch (NumberFormatException e) {
-                throw new IllegalArgumentException(String.format("Unparseable port number: %s" + hostPortString));
+                throw new IllegalArgumentException(String.format("Cannot parse port number: %s", hostPortString));
             }
             LettuceAssert.isTrue(isValidPort(port), String.format("Port number out of range: %s", hostPortString));
         }

File: src/main/java/io/lettuce/core/internal/HostAndPort.java
Patch:
@@ -192,7 +192,7 @@ private static String[] getHostAndPortFromBracketedHost(String hostPortString) {
         int closeBracketIndex = hostPortString.lastIndexOf(']');
 
         LettuceAssert.isTrue(colonIndex > -1 && closeBracketIndex > colonIndex,
-                String.format("Invalid bracketed host/port: ", hostPortString));
+                String.format("Invalid bracketed host/port: %s", hostPortString));
 
         String host = hostPortString.substring(1, closeBracketIndex);
         if (closeBracketIndex + 1 == hostPortString.length()) {

File: src/main/java/io/lettuce/core/RedisCommandBuilder.java
Patch:
@@ -572,7 +572,7 @@ <T> Command<K, V, T> eval(String script, ScriptOutputType type, K... keys) {
         LettuceAssert.notNull(keys, "Keys " + MUST_NOT_BE_NULL);
 
         CommandArgs<K, V> args = new CommandArgs<>(codec);
-        args.add(script).add(keys.length).addKeys(keys);
+        args.add(script.getBytes()).add(keys.length).addKeys(keys);
         CommandOutput<K, V, T> output = newScriptOutput(codec, type);
         return createCommand(EVAL, output, args);
     }
@@ -585,7 +585,7 @@ <T> Command<K, V, T> eval(String script, ScriptOutputType type, K[] keys, V... v
         LettuceAssert.notNull(values, "Values " + MUST_NOT_BE_NULL);
 
         CommandArgs<K, V> args = new CommandArgs<>(codec);
-        args.add(script).add(keys.length).addKeys(keys).addValues(values);
+        args.add(script.getBytes()).add(keys.length).addKeys(keys).addValues(values);
         CommandOutput<K, V, T> output = newScriptOutput(codec, type);
         return createCommand(EVAL, output, args);
     }

File: src/main/java/io/lettuce/core/AbstractRedisAsyncCommands.java
Patch:
@@ -1676,7 +1676,7 @@ public RedisFuture<Long> zcount(K key, Range<? extends Number> range) {
     }
 
     @Override
-    public RedisFuture<Double> zincrby(K key, double amount, K member) {
+    public RedisFuture<Double> zincrby(K key, double amount, V member) {
         return dispatch(commandBuilder.zincrby(key, amount, member));
     }
 

File: src/main/java/io/lettuce/core/AbstractRedisReactiveCommands.java
Patch:
@@ -1726,7 +1726,7 @@ public Mono<Long> zcount(K key, Range<? extends Number> range) {
     }
 
     @Override
-    public Mono<Double> zincrby(K key, double amount, K member) {
+    public Mono<Double> zincrby(K key, double amount, V member) {
         return createMono(() -> commandBuilder.zincrby(key, amount, member));
     }
 

File: src/main/java/io/lettuce/core/RedisCommandBuilder.java
Patch:
@@ -2445,10 +2445,10 @@ Command<K, V, Long> zcount(K key, Range<? extends Number> range) {
         return createCommand(ZCOUNT, new IntegerOutput<>(codec), args);
     }
 
-    Command<K, V, Double> zincrby(K key, double amount, K member) {
+    Command<K, V, Double> zincrby(K key, double amount, V member) {
         notNullKey(key);
 
-        CommandArgs<K, V> args = new CommandArgs<>(codec).addKey(key).add(amount).addKey(member);
+        CommandArgs<K, V> args = new CommandArgs<>(codec).addKey(key).add(amount).addValue(member);
         return createCommand(ZINCRBY, new DoubleOutput<>(codec), args);
     }
 

File: src/main/java/io/lettuce/core/api/async/RedisSortedSetAsyncCommands.java
Patch:
@@ -203,11 +203,11 @@ public interface RedisSortedSetAsyncCommands<K, V> {
      *
      * @param key the key
      * @param amount the increment type: long
-     * @param member the member type: key
+     * @param member the member type: value
      * @return Double bulk-string-reply the new score of {@code member} (a double precision floating point number), represented
      *         as string.
      */
-    RedisFuture<Double> zincrby(K key, double amount, K member);
+    RedisFuture<Double> zincrby(K key, double amount, V member);
 
     /**
      * Intersect multiple sorted sets and store the resulting sorted set in a new key.

File: src/main/java/io/lettuce/core/api/reactive/RedisSortedSetReactiveCommands.java
Patch:
@@ -203,11 +203,11 @@ public interface RedisSortedSetReactiveCommands<K, V> {
      *
      * @param key the key
      * @param amount the increment type: long
-     * @param member the member type: key
+     * @param member the member type: value
      * @return Double bulk-string-reply the new score of {@code member} (a double precision floating point number), represented
      *         as string.
      */
-    Mono<Double> zincrby(K key, double amount, K member);
+    Mono<Double> zincrby(K key, double amount, V member);
 
     /**
      * Intersect multiple sorted sets and store the resulting sorted set in a new key.

File: src/main/java/io/lettuce/core/api/sync/RedisSortedSetCommands.java
Patch:
@@ -203,11 +203,11 @@ public interface RedisSortedSetCommands<K, V> {
      *
      * @param key the key
      * @param amount the increment type: long
-     * @param member the member type: key
+     * @param member the member type: value
      * @return Double bulk-string-reply the new score of {@code member} (a double precision floating point number), represented
      *         as string.
      */
-    Double zincrby(K key, double amount, K member);
+    Double zincrby(K key, double amount, V member);
 
     /**
      * Intersect multiple sorted sets and store the resulting sorted set in a new key.

File: src/main/java/io/lettuce/core/cluster/api/async/NodeSelectionSortedSetAsyncCommands.java
Patch:
@@ -203,11 +203,11 @@ public interface NodeSelectionSortedSetAsyncCommands<K, V> {
      *
      * @param key the key
      * @param amount the increment type: long
-     * @param member the member type: key
+     * @param member the member type: value
      * @return Double bulk-string-reply the new score of {@code member} (a double precision floating point number), represented
      *         as string.
      */
-    AsyncExecutions<Double> zincrby(K key, double amount, K member);
+    AsyncExecutions<Double> zincrby(K key, double amount, V member);
 
     /**
      * Intersect multiple sorted sets and store the resulting sorted set in a new key.

File: src/main/java/io/lettuce/core/cluster/api/sync/NodeSelectionSortedSetCommands.java
Patch:
@@ -203,11 +203,11 @@ public interface NodeSelectionSortedSetCommands<K, V> {
      *
      * @param key the key
      * @param amount the increment type: long
-     * @param member the member type: key
+     * @param member the member type: value
      * @return Double bulk-string-reply the new score of {@code member} (a double precision floating point number), represented
      *         as string.
      */
-    Executions<Double> zincrby(K key, double amount, K member);
+    Executions<Double> zincrby(K key, double amount, V member);
 
     /**
      * Intersect multiple sorted sets and store the resulting sorted set in a new key.

File: src/main/templates/io/lettuce/core/api/RedisSortedSetCommands.java
Patch:
@@ -202,11 +202,11 @@ public interface RedisSortedSetCommands<K, V> {
      *
      * @param key the key
      * @param amount the increment type: long
-     * @param member the member type: key
+     * @param member the member type: value
      * @return Double bulk-string-reply the new score of {@code member} (a double precision floating point number), represented
      *         as string.
      */
-    Double zincrby(K key, double amount, K member);
+    Double zincrby(K key, double amount, V member);
 
     /**
      * Intersect multiple sorted sets and store the resulting sorted set in a new key.

File: src/main/java/io/lettuce/core/output/GeoWithinListOutput.java
Patch:
@@ -101,6 +101,7 @@ public void complete(int depth) {
             distance = null;
             geohash = null;
             coordinates = null;
+            x = null;
         }
     }
 

File: src/test/java/io/lettuce/core/commands/reactive/GeoReactiveCommandTest.java
Patch:
@@ -58,6 +58,6 @@ public void geopos() {
     @Test
     @Ignore("API differences")
     @Override
-    public void geoposWithTransaction() {
+    public void geoposInTransaction() {
     }
 }

File: src/main/java/io/lettuce/core/RedisClient.java
Patch:
@@ -39,7 +39,6 @@
 import io.lettuce.core.pubsub.StatefulRedisPubSubConnection;
 import io.lettuce.core.pubsub.StatefulRedisPubSubConnectionImpl;
 import io.lettuce.core.resource.ClientResources;
-import io.lettuce.core.resource.SocketAddressResolver;
 import io.lettuce.core.sentinel.StatefulRedisSentinelConnectionImpl;
 import io.lettuce.core.sentinel.api.StatefulRedisSentinelConnection;
 
@@ -587,7 +586,7 @@ private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectS
     private <K, V> Mono<StatefulRedisSentinelConnection<K, V>> connectSentinel(ConnectionBuilder connectionBuilder, RedisURI uri) {
 
         connectionBuilder.socketAddressSupplier(getSocketAddressSupplier(uri));
-        SocketAddress socketAddress = SocketAddressResolver.resolve(uri, clientResources.dnsResolver());
+        SocketAddress socketAddress = clientResources.socketAddressResolver().resolve(uri);
         logger.debug("Connecting to Redis Sentinel, address: " + socketAddress);
 
         Mono<StatefulRedisSentinelConnection<K, V>> connectionMono = Mono
@@ -698,7 +697,7 @@ protected Mono<SocketAddress> getSocketAddress(RedisURI redisURI) {
                                 + redisURI.getSentinelMasterId())));
 
             } else {
-                return Mono.fromCallable(() -> SocketAddressResolver.resolve(redisURI, clientResources.dnsResolver()));
+                return Mono.fromCallable(() -> clientResources.socketAddressResolver().resolve((redisURI)));
             }
         });
     }

File: src/main/java/io/lettuce/core/cluster/AbstractClusterNodeConnectionFactory.java
Patch:
@@ -23,7 +23,6 @@
 import io.lettuce.core.cluster.models.partitions.Partitions;
 import io.lettuce.core.cluster.models.partitions.RedisClusterNode;
 import io.lettuce.core.resource.ClientResources;
-import io.lettuce.core.resource.SocketAddressResolver;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -107,6 +106,6 @@ private SocketAddress getSocketAddress(String nodeId) {
     }
 
     private SocketAddress resolve(RedisURI redisURI) {
-        return SocketAddressResolver.resolve(redisURI, clientResources.dnsResolver());
+        return clientResources.socketAddressResolver().resolve(redisURI);
     }
 }

File: src/main/java/io/lettuce/core/cluster/RedisClusterClient.java
Patch:
@@ -57,7 +57,6 @@
 import io.lettuce.core.pubsub.StatefulRedisPubSubConnection;
 import io.lettuce.core.pubsub.StatefulRedisPubSubConnectionImpl;
 import io.lettuce.core.resource.ClientResources;
-import io.lettuce.core.resource.SocketAddressResolver;
 import io.netty.util.concurrent.ScheduledFuture;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -988,7 +987,7 @@ protected Mono<SocketAddress> getSocketAddressSupplier(Function<Partitions, Coll
 
             if (partitions.isEmpty()) {
                 return Mono.fromCallable(() -> {
-                    SocketAddress socketAddress = SocketAddressResolver.resolve(getFirstUri(), clientResources.dnsResolver());
+                    SocketAddress socketAddress = clientResources.socketAddressResolver().resolve(getFirstUri());
                     logger.debug("Resolved SocketAddress {} using {}", socketAddress, getFirstUri());
                     return socketAddress;
                 });

File: src/main/java/io/lettuce/core/cluster/RoundRobinSocketAddressSupplier.java
Patch:
@@ -23,7 +23,6 @@
 import io.lettuce.core.cluster.models.partitions.RedisClusterNode;
 import io.lettuce.core.internal.LettuceAssert;
 import io.lettuce.core.resource.ClientResources;
-import io.lettuce.core.resource.SocketAddressResolver;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -73,7 +72,7 @@ protected void resetRoundRobin() {
 
     protected SocketAddress getSocketAddress(RedisClusterNode redisClusterNode) {
 
-        SocketAddress resolvedAddress = SocketAddressResolver.resolve(redisClusterNode.getUri(), clientResources.dnsResolver());
+        SocketAddress resolvedAddress = clientResources.socketAddressResolver().resolve(redisClusterNode.getUri());
         logger.debug("Resolved SocketAddress {} using for Cluster node {}", resolvedAddress, redisClusterNode.getNodeId());
         return resolvedAddress;
     }

File: src/main/java/io/lettuce/core/cluster/topology/ClusterTopologyRefresh.java
Patch:
@@ -30,7 +30,6 @@
 import io.lettuce.core.cluster.topology.TopologyComparators.SortAction;
 import io.lettuce.core.codec.Utf8StringCodec;
 import io.lettuce.core.resource.ClientResources;
-import io.lettuce.core.resource.SocketAddressResolver;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -207,7 +206,7 @@ private AsyncConnections getConnections(Iterable<RedisURI> redisURIs) throws Int
             }
 
             try {
-                SocketAddress socketAddress = SocketAddressResolver.resolve(redisURI, clientResources.dnsResolver());
+                SocketAddress socketAddress = clientResources.socketAddressResolver().resolve(redisURI);
 
                 ConnectionFuture<StatefulRedisConnection<String, String>> connectionFuture = nodeConnectionFactory
                         .connectToNodeAsync(CODEC, socketAddress);

File: src/test/java/io/lettuce/core/cluster/RoundRobinSocketAddressSupplierTest.java
Patch:
@@ -34,6 +34,7 @@
 import io.lettuce.core.cluster.models.partitions.RedisClusterNode;
 import io.lettuce.core.resource.ClientResources;
 import io.lettuce.core.resource.DnsResolvers;
+import io.lettuce.core.resource.SocketAddressResolver;
 
 /**
  * @author Mark Paluch
@@ -61,7 +62,7 @@ public static void beforeClass() {
     @Before
     public void before() throws Exception {
 
-        when(clientResourcesMock.dnsResolver()).thenReturn(DnsResolvers.JVM_DEFAULT);
+        when(clientResourcesMock.socketAddressResolver()).thenReturn(SocketAddressResolver.create(DnsResolvers.JVM_DEFAULT));
 
         partitions = new Partitions();
         partitions.addPartition(new RedisClusterNode(hap1, "1", true, "", 0, 0, 0, new ArrayList<>(), new HashSet<>()));

File: src/test/java/io/lettuce/core/cluster/topology/ClusterTopologyRefreshTest.java
Patch:
@@ -50,6 +50,7 @@
 import io.lettuce.core.protocol.RedisCommand;
 import io.lettuce.core.resource.ClientResources;
 import io.lettuce.core.resource.DnsResolvers;
+import io.lettuce.core.resource.SocketAddressResolver;
 
 /**
  * @author Mark Paluch
@@ -95,7 +96,7 @@ public class ClusterTopologyRefreshTest {
     @Before
     public void before() {
 
-        when(clientResources.dnsResolver()).thenReturn(DnsResolvers.JVM_DEFAULT);
+        when(clientResources.socketAddressResolver()).thenReturn(SocketAddressResolver.create(DnsResolvers.JVM_DEFAULT));
         when(connection1.async()).thenReturn(asyncCommands1);
         when(connection2.async()).thenReturn(asyncCommands2);
         when(connection1.closeAsync()).thenReturn(CompletableFuture.completedFuture(null));

File: src/test/java/io/lettuce/core/commands/StreamCommandTest.java
Patch:
@@ -94,9 +94,7 @@ public void xtrim() {
         redis.xdel(key, ids.get(0), ids.get(2));
         assertThat(redis.xlen(key)).isBetween(8L, 10L);
 
-        Long xtrim = redis.xtrim(key, 8);
-
-        assertThat(xtrim).isNotZero();
+        redis.xtrim(key, 8);
 
         assertThat(redis.xlen(key)).isLessThanOrEqualTo(10);
     }

File: src/main/java/io/lettuce/core/resource/Delay.java
Patch:
@@ -107,7 +107,7 @@ public static Delay constant(int delay, TimeUnit timeUnit) {
 
     /**
      * Creates a new {@link ExponentialDelay} with default boundaries and factor (1, 2, 4, 8, 16, 32...). The delay begins with
-     * 1 and is capped at 30 milliseconds after reaching the 16th attempt.
+     * 1 and is capped at 30 {@link TimeUnit#SECONDS} after reaching the 16th attempt.
      *
      * @return a created {@link ExponentialDelay}.
      */

File: src/main/java/io/lettuce/core/event/metrics/DefaultCommandLatencyEventPublisher.java
Patch:
@@ -76,5 +76,4 @@ public void emitMetricsEvent() {
 
         eventBus.publish(new CommandLatencyEvent(commandLatencyCollector.retrieveMetrics()));
     }
-
 }

File: src/main/java/io/lettuce/core/metrics/CommandMetrics.java
Patch:
@@ -24,6 +24,7 @@
  * @author Mark Paluch
  */
 public class CommandMetrics {
+
     private final long count;
     private final TimeUnit timeUnit;
 

File: src/main/java/io/lettuce/core/metrics/DefaultCommandLatencyCollector.java
Patch:
@@ -396,7 +396,6 @@ public void release() {
                 instanceCounter.decrementAndGet();
                 pauseDetector.shutdown();
                 pauseDetector = null;
-
             }
         }
     }

File: src/main/java/io/lettuce/core/protocol/DefaultEndpoint.java
Patch:
@@ -807,9 +807,6 @@ static RetryListener newInstance(DefaultEndpoint endpoint, RedisCommand<?, ?, ?>
 
             RetryListener entry = RECYCLER.get();
 
-            if (command == null) {
-                System.out.println();
-            }
             entry.endpoint = endpoint;
             entry.sentCommand = command;
 

File: src/main/java/io/lettuce/core/protocol/CommandHandler.java
Patch:
@@ -728,7 +728,7 @@ private void recordLatency(WithLatency withLatency, ProtocolKeyword commandType)
 
         if (withLatency != null && clientResources.commandLatencyCollector().isEnabled() && channel != null && remote() != null) {
 
-            long firstResponseLatency = withLatency.getSent() - withLatency.getFirstResponse();
+            long firstResponseLatency = withLatency.getFirstResponse() - withLatency.getSent();
             long completionLatency = nanoTime() - withLatency.getSent();
 
             clientResources.commandLatencyCollector().recordCommandLatency(local(), remote(), commandType,

File: src/main/java/io/lettuce/core/protocol/CommandHandler.java
Patch:
@@ -561,7 +561,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Interrup
             }
 
             if (buffer.refCnt() != 0) {
-                buffer.discardReadBytes();
+                buffer.discardSomeReadBytes();
             }
 
             afterComplete(ctx, command);

File: src/main/java/io/lettuce/core/masterslave/RedisMasterSlaveNode.java
Patch:
@@ -22,13 +22,14 @@
  * A node within a Redis Master-Slave setup.
  *
  * @author Mark Paluch
+ * @author Adam McElwee
  */
 class RedisMasterSlaveNode implements RedisNodeDescription {
 
     private final RedisURI redisURI;
     private final Role role;
 
-    public RedisMasterSlaveNode(String host, int port, RedisURI seed, Role role) {
+    RedisMasterSlaveNode(String host, int port, RedisURI seed, Role role) {
 
         RedisURI.Builder builder = RedisURI.Builder
                 .redis(host, port)

File: src/main/java/io/lettuce/core/masterslave/MasterSlaveTopologyRefresh.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2017 the original author or authors.
+ * Copyright 2011-2018 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: src/main/java/io/lettuce/core/RedisClient.java
Patch:
@@ -26,7 +26,6 @@
 import java.util.function.Supplier;
 
 import reactor.core.publisher.Mono;
-import reactor.core.scheduler.Schedulers;
 import io.lettuce.core.api.StatefulRedisConnection;
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.codec.StringCodec;
@@ -703,8 +702,7 @@ protected Mono<SocketAddress> getSocketAddress(RedisURI redisURI) {
                                 + redisURI.getSentinelMasterId())));
 
             } else {
-                return Mono.fromCallable(() -> SocketAddressResolver.resolve(redisURI, clientResources.dnsResolver()))
-                        .subscribeOn(Schedulers.fromExecutor(clientResources.eventExecutorGroup()));
+                return Mono.fromCallable(() -> SocketAddressResolver.resolve(redisURI, clientResources.dnsResolver()));
             }
         });
     }

File: src/main/java/io/lettuce/core/cluster/RedisClusterClient.java
Patch:
@@ -29,7 +29,6 @@
 import java.util.function.Supplier;
 
 import reactor.core.publisher.Mono;
-import reactor.core.scheduler.Schedulers;
 import io.lettuce.core.*;
 import io.lettuce.core.api.StatefulRedisConnection;
 import io.lettuce.core.cluster.api.NodeSelectionSupport;
@@ -989,8 +988,7 @@ protected Mono<SocketAddress> getSocketAddressSupplier(Function<Partitions, Coll
                     SocketAddress socketAddress = SocketAddressResolver.resolve(getFirstUri(), clientResources.dnsResolver());
                     logger.debug("Resolved SocketAddress {} using {}", socketAddress, getFirstUri());
                     return socketAddress;
-
-                }).subscribeOn(Schedulers.fromExecutor(clientResources.eventExecutorGroup()));
+                });
             }
 
             return Mono.fromCallable(socketAddressSupplier::get);

File: src/main/java/io/lettuce/core/ConnectionBuilder.java
Patch:
@@ -45,7 +45,7 @@ public class ConnectionBuilder {
     private Supplier<SocketAddress> socketAddressSupplier;
     private ConnectionEvents connectionEvents;
     private RedisChannelHandler<?, ?> connection;
-    private DefaultEndpoint endpoint;
+    private Endpoint endpoint;
     private Supplier<CommandHandler> commandHandlerSupplier;
     private ChannelGroup channelGroup;
     private Timer timer;
@@ -183,7 +183,7 @@ public ConnectionBuilder bootstrap(Bootstrap bootstrap) {
         return this;
     }
 
-    public ConnectionBuilder endpoint(DefaultEndpoint endpoint) {
+    public ConnectionBuilder endpoint(Endpoint endpoint) {
         this.endpoint = endpoint;
         return this;
     }
@@ -218,7 +218,7 @@ public char[] password() {
         return password;
     }
 
-    public DefaultEndpoint endpoint() {
+    public Endpoint endpoint() {
         return endpoint;
     }
 

File: src/main/java/io/lettuce/core/cluster/ClusterPubSubConnectionProvider.java
Patch:
@@ -16,6 +16,7 @@
 package io.lettuce.core.cluster;
 
 import io.lettuce.core.ConnectionFuture;
+import io.lettuce.core.RedisChannelWriter;
 import io.lettuce.core.api.StatefulRedisConnection;
 import io.lettuce.core.cluster.models.partitions.Partitions;
 import io.lettuce.core.cluster.models.partitions.RedisClusterNode;
@@ -50,9 +51,8 @@ class ClusterPubSubConnectionProvider<K, V> extends PooledClusterConnectionProvi
      * @param redisCodec must not be {@literal null}.
      * @param notificationTarget must not be {@literal null}.
      */
-    public ClusterPubSubConnectionProvider(RedisClusterClient redisClusterClient,
-            ClusterDistributionChannelWriter clusterWriter, RedisCodec<K, V> redisCodec,
-            RedisClusterPubSubListener<K, V> notificationTarget) {
+    public ClusterPubSubConnectionProvider(RedisClusterClient redisClusterClient, RedisChannelWriter clusterWriter,
+            RedisCodec<K, V> redisCodec, RedisClusterPubSubListener<K, V> notificationTarget) {
 
         super(redisClusterClient, clusterWriter, redisCodec);
 

File: src/main/java/io/lettuce/core/masterslave/MasterSlave.java
Patch:
@@ -164,6 +164,7 @@ private static <K, V> StatefulRedisMasterSlaveConnection<K, V> connectSentinel(R
         MasterSlaveChannelWriter<K, V> channelWriter = new MasterSlaveChannelWriter<>(connectionProvider);
         StatefulRedisMasterSlaveConnectionImpl<K, V> connection = new StatefulRedisMasterSlaveConnectionImpl<>(channelWriter,
                 codec, redisURI.getTimeout());
+        connection.setOptions(redisClient.getOptions());
 
         connection.setOptions(redisClient.getOptions());
 
@@ -263,6 +264,7 @@ private static <K, V> StatefulRedisMasterSlaveConnection<K, V> connectStaticMast
 
             StatefulRedisMasterSlaveConnectionImpl<K, V> connection = new StatefulRedisMasterSlaveConnectionImpl<>(
                     channelWriter, codec, seedNode.getTimeout());
+            connection.setOptions(redisClient.getOptions());
 
             connection.setOptions(redisClient.getOptions());
 

File: src/test/jmh/io/lettuce/core/RedisClientBenchmark.java
Patch:
@@ -15,13 +15,13 @@
  */
 package io.lettuce.core;
 
+import java.time.Duration;
 import java.util.concurrent.TimeUnit;
 
 import org.openjdk.jmh.annotations.*;
 
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
-
 import io.lettuce.core.api.StatefulRedisConnection;
 import io.lettuce.core.codec.ByteArrayCodec;
 
@@ -57,6 +57,8 @@ public class RedisClientBenchmark {
     public void setup() {
 
         redisClient = RedisClient.create(RedisURI.create(TestSettings.host(), TestSettings.port()));
+        redisClient.setOptions(ClientOptions.builder()
+                .timeoutOptions(TimeoutOptions.builder().fixedTimeout(Duration.ofSeconds(10)).build()).build());
         connection = redisClient.connect(ByteArrayCodec.INSTANCE);
         commands = new RedisFuture[BATCH_SIZE];
         monos = new Mono[BATCH_SIZE];

File: src/test/java/io/lettuce/core/pubsub/PubSubCommandTest.java
Patch:
@@ -233,7 +233,7 @@ public void pubsubNumsub() throws Exception {
 
         Map<String, Long> result = redis.pubsubNumsub(channel);
         assertThat(result.size()).isGreaterThan(0);
-        assertThat(result.get(channel)).isGreaterThan(0); // Redis sometimes keeps old references
+        assertThat(result).containsKeys(channel);
     }
 
     @Test

File: src/test/java/io/lettuce/core/pubsub/PubSubReactiveTest.java
Patch:
@@ -32,7 +32,6 @@
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 import reactor.test.StepVerifier;
-
 import io.lettuce.Delay;
 import io.lettuce.TestClientResources;
 import io.lettuce.Wait;
@@ -250,7 +249,7 @@ public void pubsubNumsub() throws Exception {
 
         Map<String, Long> result = block(pubsub2.pubsubNumsub(channel));
         assertThat(result).hasSize(1);
-        assertThat(result.get(channel)).isGreaterThan(0);
+        assertThat(result).containsKeys(channel);
     }
 
     @Test

File: src/test/java/io/lettuce/core/server/MockTcpServer.java
Patch:
@@ -25,6 +25,7 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.util.concurrent.DefaultThreadFactory;
 
 /**
  * Tiny netty server to generate a response.
@@ -77,8 +78,8 @@ private static class Resources {
         private static final EventLoopGroup workerGroup;
 
         static {
-            bossGroup = new NioEventLoopGroup(1);
-            workerGroup = new NioEventLoopGroup();
+            bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory(NioEventLoopGroup.class, true));
+            workerGroup = new NioEventLoopGroup(5, new DefaultThreadFactory(NioEventLoopGroup.class, true));
 
             Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                 bossGroup.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);

File: src/main/java/io/lettuce/core/output/KeyListOutput.java
Patch:
@@ -42,7 +42,7 @@ public KeyListOutput(RedisCodec<K, V> codec) {
 
     @Override
     public void set(ByteBuffer bytes) {
-        subscriber.onNext(output, codec.decodeKey(bytes));
+        subscriber.onNext(output, bytes == null ? null : codec.decodeKey(bytes));
     }
 
     @Override

File: src/main/java/io/lettuce/core/output/MapOutput.java
Patch:
@@ -42,7 +42,7 @@ public MapOutput(RedisCodec<K, V> codec) {
     public void set(ByteBuffer bytes) {
 
         if (key == null) {
-            key = codec.decodeKey(bytes);
+            key = (bytes == null) ? null : codec.decodeKey(bytes);
             return;
         }
 

File: src/main/java/io/lettuce/core/AbstractRedisClient.java
Patch:
@@ -347,7 +347,7 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {
         } catch (ExecutionException e) {
 
             if (e.getCause() instanceof RedisCommandExecutionException) {
-                throw new RedisCommandExecutionException(e.getCause().getMessage(), e.getCause());
+                throw ExceptionFactory.createExecutionException(e.getCause().getMessage(), e.getCause());
             }
 
             throw new RedisException(e.getCause());

File: src/main/java/io/lettuce/core/LettuceFutures.java
Patch:
@@ -82,7 +82,7 @@ public static boolean awaitAll(long timeout, TimeUnit unit, Future<?>... futures
         } catch (ExecutionException e) {
 
             if (e.getCause() instanceof RedisCommandExecutionException) {
-                throw new RedisCommandExecutionException(e.getCause().getMessage(), e.getCause());
+                throw ExceptionFactory.createExecutionException(e.getCause().getMessage(), e.getCause());
             }
 
             throw new RedisException(e.getCause());
@@ -119,7 +119,7 @@ public static <T> T awaitOrCancel(RedisFuture<T> cmd, long timeout, TimeUnit uni
         } catch (ExecutionException e) {
 
             if (e.getCause() instanceof RedisCommandExecutionException) {
-                throw new RedisCommandExecutionException(e.getCause().getMessage(), e.getCause());
+                throw ExceptionFactory.createExecutionException(e.getCause().getMessage(), e.getCause());
             }
 
             throw new RedisException(e.getCause());

File: src/main/java/io/lettuce/core/RedisPublisher.java
Patch:
@@ -628,7 +628,7 @@ public void complete() {
                     Object result = getOutput().get();
 
                     if (getOutput().hasError()) {
-                        onError(new RedisCommandExecutionException(getOutput().getError()));
+                        onError(ExceptionFactory.createExecutionException(getOutput().getError()));
                         completed = true;
                         return;
                     }

File: src/main/java/io/lettuce/core/cluster/NodeSelectionInvocationHandler.java
Patch:
@@ -24,6 +24,7 @@
 
 import org.reactivestreams.Publisher;
 
+import io.lettuce.core.ExceptionFactory;
 import io.lettuce.core.RedisCommandExecutionException;
 import io.lettuce.core.RedisCommandInterruptedException;
 import io.lettuce.core.RedisCommandTimeoutException;
@@ -231,7 +232,8 @@ private RedisCommandExecutionException createExecutionException(Map<RedisCluster
             }
         });
 
-        RedisCommandExecutionException e = new RedisCommandExecutionException(
+        RedisCommandExecutionException e = ExceptionFactory
+                .createExecutionException(
                 "Multi-node command execution failed on node(s): " + getNodeDescription(failed));
 
         executions.forEach((redisClusterNode, completionStage) -> {

File: src/main/java/io/lettuce/core/output/MultiOutput.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.List;
 import java.util.Queue;
 
-import io.lettuce.core.RedisCommandExecutionException;
+import io.lettuce.core.ExceptionFactory;
 import io.lettuce.core.TransactionResult;
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.internal.LettuceFactories;
@@ -104,7 +104,7 @@ public void complete(int depth) {
         if (depth == 1) {
             RedisCommand<K, V, ?> cmd = queue.remove();
             CommandOutput<K, V, ?> o = cmd.getOutput();
-            responses.add(!o.hasError() ? o.get() : new RedisCommandExecutionException(o.getError()));
+            responses.add(!o.hasError() ? o.get() : ExceptionFactory.createExecutionException(o.getError()));
             cmd.complete();
         } else if (depth == 0 && !queue.isEmpty()) {
             for (RedisCommand<K, V, ?> cmd : queue) {

File: src/main/java/io/lettuce/core/protocol/AsyncCommand.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.Consumer;
 
-import io.lettuce.core.RedisCommandExecutionException;
+import io.lettuce.core.ExceptionFactory;
 import io.lettuce.core.RedisCommandInterruptedException;
 import io.lettuce.core.RedisFuture;
 import io.lettuce.core.internal.LettuceAssert;
@@ -115,7 +115,7 @@ protected void completeResult() {
         if (command.getOutput() == null) {
             complete(null);
         } else if (command.getOutput().hasError()) {
-            doCompleteExceptionally(new RedisCommandExecutionException(command.getOutput().getError()));
+            doCompleteExceptionally(ExceptionFactory.createExecutionException(command.getOutput().getError()));
         } else {
             complete(command.getOutput().get());
         }

File: src/test/java/io/lettuce/core/commands/ScriptingCommandTest.java
Patch:
@@ -32,6 +32,7 @@
 import io.lettuce.core.AbstractRedisClientTest;
 import io.lettuce.core.RedisException;
 import io.lettuce.core.api.StatefulRedisConnection;
+import io.lettuce.core.RedisNoScriptException;
 
 /**
  * @author Will Glozer
@@ -95,6 +96,7 @@ public void evalsha() throws Exception {
         String digest = redis.digest(script);
         assertThat((Number) redis.eval(script, INTEGER)).isEqualTo(2L);
         assertThat((Number) redis.evalsha(digest, INTEGER)).isEqualTo(2L);
+        exception.expect(RedisNoScriptException.class);
         exception.expectMessage("NOSCRIPT No matching script. Please use EVAL.");
         redis.evalsha(redis.digest("return 1 + 1 == 4"), INTEGER);
     }
@@ -103,6 +105,7 @@ public void evalsha() throws Exception {
     public void evalshaWithMulti() throws Exception {
         redis.scriptFlush();
         String digest = redis.digest("return {1234, 5678}");
+        exception.expect(RedisNoScriptException.class);
         exception.expectMessage("NOSCRIPT No matching script. Please use EVAL.");
         redis.evalsha(digest, MULTI);
     }

File: src/main/java/io/lettuce/core/output/GeoCoordinatesListOutput.java
Patch:
@@ -60,7 +60,7 @@ public void set(ByteBuffer bytes) {
     public void multi(int count) {
 
         if (!initialized) {
-            output = OutputFactory.newList(count / 2);
+            output = OutputFactory.newList(count);
             initialized = true;
         }
 

File: src/main/java/io/lettuce/core/cluster/RedisClusterClient.java
Patch:
@@ -1003,12 +1003,12 @@ protected Iterable<RedisURI> getTopologyRefreshSource() {
     }
 
     /**
-     * Returns {@link true} if {@link ClusterTopologyRefreshOptions#useDynamicRefreshSources() dynamic refresh sources} are
+     * Returns {@literal true} if {@link ClusterTopologyRefreshOptions#useDynamicRefreshSources() dynamic refresh sources} are
      * enabled.
      * <p>
      * Subclasses of {@link RedisClusterClient} may override that method.
      *
-     * @return {@link true} if dynamic refresh sources are used.
+     * @return {@literal true} if dynamic refresh sources are used.
      * @see ClusterTopologyRefreshOptions#useDynamicRefreshSources()
      */
     protected boolean useDynamicRefreshSources() {

File: src/main/java/io/lettuce/core/codec/ToByteBufEncoder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2016 the original author or authors.
+ * Copyright 2011-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -51,7 +51,7 @@ public interface ToByteBufEncoder<K, V> {
      * Estimates the size of the resulting byte stream. This method is called for keys and values to estimate the size for the
      * temporary buffer to allocate.
      *
-     * @param keyOrValue the key or value, may be {@link null}.
+     * @param keyOrValue the key or value, may be {@literal null}.
      * @return the estimated number of bytes in the encoded representation.
      */
     int estimateSize(Object keyOrValue);

File: src/main/java/io/lettuce/core/RedisClient.java
Patch:
@@ -542,7 +542,7 @@ private <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<
                 connectionBuilder.socketAddressSupplier(getSocketAddressSupplier(uri));
 
                 if (logger.isDebugEnabled()) {
-                    SocketAddress socketAddress = SocketAddressResolver.resolve(redisURI, clientResources.dnsResolver());
+                    SocketAddress socketAddress = SocketAddressResolver.resolve(uri, clientResources.dnsResolver());
                     logger.debug("Connecting to Redis Sentinel, address: " + socketAddress);
                 }
                 try {

File: src/main/java/io/lettuce/core/AbstractRedisClient.java
Patch:
@@ -157,7 +157,7 @@ protected void connectionBuilder(Supplier<SocketAddress> socketAddressSupplier,
             redisBootstrap.option(ChannelOption.TCP_NODELAY, socketOptions.isTcpNoDelay());
         }
 
-        connectionBuilder.timeout(redisURI.getTimeoutDuration());
+        connectionBuilder.timeout(redisURI.getTimeout());
         connectionBuilder.password(redisURI.getPassword());
 
         connectionBuilder.bootstrap(redisBootstrap);

File: src/main/java/io/lettuce/core/cluster/RedisClusterClient.java
Patch:
@@ -175,7 +175,7 @@ protected RedisClusterClient(ClientResources clientResources, Iterable<RedisURI>
 
         this.initialUris = Collections.unmodifiableList(LettuceLists.newList(redisURIs));
 
-        setDefaultTimeout(getFirstUri().getTimeout(), getFirstUri().getUnit());
+        setDefaultTimeout(getFirstUri().getTimeout());
         setOptions(ClusterClientOptions.builder().build());
     }
 

File: src/main/java/io/lettuce/core/cluster/topology/ClusterTopologyRefresh.java
Patch:
@@ -30,7 +30,6 @@
 import io.lettuce.core.codec.Utf8StringCodec;
 import io.lettuce.core.resource.ClientResources;
 import io.lettuce.core.resource.SocketAddressResolver;
-
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -269,6 +268,6 @@ private static <E> Set<E> difference(Set<E> set1, Set<E> set2) {
     private long getCommandTimeoutNs(Iterable<RedisURI> redisURIs) {
 
         RedisURI redisURI = redisURIs.iterator().next();
-        return redisURI.getUnit().toNanos(redisURI.getTimeout());
+        return redisURI.getTimeout().toNanos();
     }
 }

File: src/main/java/io/lettuce/core/dynamic/AsyncExecutableCommand.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.time.Duration;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
 
 import io.lettuce.core.LettuceFutures;
 import io.lettuce.core.api.StatefulConnection;
@@ -79,7 +78,7 @@ protected Object dispatchCommand(Object[] arguments, RedisCommand<Object, Object
             }
         }
 
-        LettuceFutures.awaitAll(timeout.toNanos(), TimeUnit.NANOSECONDS, asyncCommand);
+        LettuceFutures.awaitAll(timeout, asyncCommand);
 
         return asyncCommand.get();
     }

File: src/main/java/io/lettuce/core/dynamic/BatchExecutableCommand.java
Patch:
@@ -19,7 +19,6 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
 
 import io.lettuce.core.LettuceFutures;
 import io.lettuce.core.RedisFuture;
@@ -91,7 +90,7 @@ protected static Object synchronize(BatchTasks batchTasks, StatefulConnection<Ob
         for (RedisCommand<?, ?, ?> batchTask : batchTasks) {
 
             try {
-                LettuceFutures.awaitAll(timeout.toNanos(), TimeUnit.NANOSECONDS, (RedisFuture) batchTask);
+                LettuceFutures.awaitAll(timeout, (RedisFuture) batchTask);
             } catch (Exception e) {
                 if (exception == null) {
                     failures = new ArrayList<>();

File: src/main/java/io/lettuce/core/masterslave/MasterSlave.java
Patch:
@@ -163,7 +163,7 @@ private static <K, V> StatefulRedisMasterSlaveConnection<K, V> connectSentinel(R
 
         MasterSlaveChannelWriter<K, V> channelWriter = new MasterSlaveChannelWriter<>(connectionProvider);
         StatefulRedisMasterSlaveConnectionImpl<K, V> connection = new StatefulRedisMasterSlaveConnectionImpl<>(channelWriter,
-                codec, redisURI.getTimeoutDuration());
+                codec, redisURI.getTimeout());
 
         Runnable runnable = () -> {
             try {
@@ -222,7 +222,7 @@ private static <K, V> StatefulRedisMasterSlaveConnection<K, V> connectMasterSlav
             MasterSlaveChannelWriter<K, V> channelWriter = new MasterSlaveChannelWriter<>(connectionProvider);
 
             StatefulRedisMasterSlaveConnectionImpl<K, V> connection = new StatefulRedisMasterSlaveConnectionImpl<>(
-                    channelWriter, codec, redisURI.getTimeoutDuration());
+                    channelWriter, codec, redisURI.getTimeout());
 
             return connection;
 
@@ -258,7 +258,7 @@ private static <K, V> StatefulRedisMasterSlaveConnection<K, V> connectStaticMast
             MasterSlaveChannelWriter<K, V> channelWriter = new MasterSlaveChannelWriter<>(connectionProvider);
 
             StatefulRedisMasterSlaveConnectionImpl<K, V> connection = new StatefulRedisMasterSlaveConnectionImpl<>(
-                    channelWriter, codec, seedNode.getTimeoutDuration());
+                    channelWriter, codec, seedNode.getTimeout());
 
             return connection;
 

File: src/main/java/io/lettuce/core/masterslave/SentinelTopologyProvider.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2016 the original author or authors.
+ * Copyright 2011-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -68,7 +68,7 @@ public SentinelTopologyProvider(String masterId, RedisClient redisClient, RedisU
         this.masterId = masterId;
         this.redisClient = redisClient;
         this.sentinelUri = sentinelUri;
-        this.timeout = sentinelUri.getTimeoutDuration();
+        this.timeout = sentinelUri.getTimeout();
     }
 
     @Override

File: src/main/java/io/lettuce/core/FutureSyncInvocationHandler.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.util.concurrent.TimeUnit;
 
 import io.lettuce.core.api.StatefulConnection;
 import io.lettuce.core.api.StatefulRedisConnection;
@@ -58,7 +59,7 @@ protected Object handleInvocation(Object proxy, Method method, Object[] args) th
                     return null;
                 }
 
-                LettuceFutures.awaitOrCancel(command, connection.getTimeout(), connection.getTimeoutUnit());
+                LettuceFutures.awaitOrCancel(command, connection.getTimeout().toNanos(), TimeUnit.NANOSECONDS);
                 return command.get();
             }
 

File: src/main/java/io/lettuce/core/cluster/ClusterFutureSyncInvocationHandler.java
Patch:
@@ -21,6 +21,7 @@
 import java.lang.reflect.Proxy;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.TimeUnit;
 import java.util.function.Predicate;
 
 import io.lettuce.core.LettuceFutures;
@@ -114,7 +115,7 @@ protected Object handleInvocation(Object proxy, Method method, Object[] args) th
                         return null;
                     }
                 }
-                return LettuceFutures.awaitOrCancel(command, connection.getTimeout(), connection.getTimeoutUnit());
+                return LettuceFutures.awaitOrCancel(command, connection.getTimeout().toNanos(), TimeUnit.NANOSECONDS);
             }
 
             return result;
@@ -176,7 +177,7 @@ protected Object nodes(Predicate<RedisClusterNode> predicate, ClusterConnectionP
         }
 
         NodeSelectionInvocationHandler h = new NodeSelectionInvocationHandler((AbstractNodeSelection<?, ?, ?, ?>) selection,
-                asyncCommandsInterface, connection.getTimeout(), connection.getTimeoutUnit());
+                asyncCommandsInterface, connection.getTimeout());
         return Proxy.newProxyInstance(NodeSelectionSupport.class.getClassLoader(), new Class<?>[] {
                 nodeSelectionCommandsInterface, nodeSelectionInterface }, h);
     }

File: src/main/java/io/lettuce/core/dynamic/BatchExecutableCommand.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.lettuce.core.dynamic;
 
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ExecutionException;
@@ -83,15 +84,14 @@ protected static Object synchronize(BatchTasks batchTasks, StatefulConnection<Ob
             return null;
         }
 
-        long timeout = connection.getTimeout();
-        TimeUnit unit = connection.getTimeoutUnit();
+        Duration timeout = connection.getTimeout();
 
         BatchException exception = null;
         List<RedisCommand<?, ?, ?>> failures = null;
         for (RedisCommand<?, ?, ?> batchTask : batchTasks) {
 
             try {
-                LettuceFutures.awaitAll(timeout, unit, (RedisFuture) batchTask);
+                LettuceFutures.awaitAll(timeout.toNanos(), TimeUnit.NANOSECONDS, (RedisFuture) batchTask);
             } catch (Exception e) {
                 if (exception == null) {
                     failures = new ArrayList<>();

File: src/main/java/io/lettuce/core/masterslave/MasterSlave.java
Patch:
@@ -163,7 +163,7 @@ private static <K, V> StatefulRedisMasterSlaveConnection<K, V> connectSentinel(R
 
         MasterSlaveChannelWriter<K, V> channelWriter = new MasterSlaveChannelWriter<>(connectionProvider);
         StatefulRedisMasterSlaveConnectionImpl<K, V> connection = new StatefulRedisMasterSlaveConnectionImpl<>(channelWriter,
-                codec, redisURI.getTimeout(), redisURI.getUnit());
+                codec, redisURI.getTimeoutDuration());
 
         Runnable runnable = () -> {
             try {
@@ -222,7 +222,7 @@ private static <K, V> StatefulRedisMasterSlaveConnection<K, V> connectMasterSlav
             MasterSlaveChannelWriter<K, V> channelWriter = new MasterSlaveChannelWriter<>(connectionProvider);
 
             StatefulRedisMasterSlaveConnectionImpl<K, V> connection = new StatefulRedisMasterSlaveConnectionImpl<>(
-                    channelWriter, codec, redisURI.getTimeout(), redisURI.getUnit());
+                    channelWriter, codec, redisURI.getTimeoutDuration());
 
             return connection;
 
@@ -258,7 +258,7 @@ private static <K, V> StatefulRedisMasterSlaveConnection<K, V> connectStaticMast
             MasterSlaveChannelWriter<K, V> channelWriter = new MasterSlaveChannelWriter<>(connectionProvider);
 
             StatefulRedisMasterSlaveConnectionImpl<K, V> connection = new StatefulRedisMasterSlaveConnectionImpl<>(
-                    channelWriter, codec, seedNode.getTimeout(), seedNode.getUnit());
+                    channelWriter, codec, seedNode.getTimeoutDuration());
 
             return connection;
 

File: src/main/java/io/lettuce/core/masterslave/MasterSlaveTopologyRefresh.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2016 the original author or authors.
+ * Copyright 2011-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,7 +32,6 @@
 import io.lettuce.core.cluster.models.partitions.Partitions;
 import io.lettuce.core.codec.StringCodec;
 import io.lettuce.core.models.role.RedisNodeDescription;
-
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -101,7 +100,7 @@ private List<RedisNodeDescription> getNodeSpecificViews(Requests requestedPing,
 
         List<RedisNodeDescription> result = new ArrayList<>();
 
-        long timeout = seed.getUnit().toNanos(seed.getTimeout());
+        long timeout = seed.getTimeoutDuration().toNanos();
         Map<RedisNodeDescription, Long> latencies = new HashMap<>();
 
         requestedPing.await(timeout, TimeUnit.NANOSECONDS);

File: src/main/java/io/lettuce/core/protocol/ConnectionWatchdog.java
Patch:
@@ -199,7 +199,7 @@ public synchronized void scheduleReconnect() {
             attempts++;
 
             final int attempt = attempts;
-            int timeout = (int) reconnectDelay.getTimeUnit().toMillis(reconnectDelay.createDelay(attempt));
+            int timeout = (int) reconnectDelay.createDelay(attempt).toMillis();
             logger.debug("{} Reconnect attempt {}, delay {}ms", logPrefix(), attempt, timeout);
 
             this.reconnectScheduleTimeout = timer.newTimeout(it -> {

File: src/test/java/io/lettuce/core/ClientOptionsTest.java
Patch:
@@ -21,6 +21,7 @@
 import static org.assertj.core.api.Assertions.fail;
 
 import java.net.ServerSocket;
+import java.time.Duration;
 import java.util.concurrent.TimeUnit;
 
 import org.junit.Test;
@@ -32,7 +33,6 @@
 import io.lettuce.core.codec.Utf8StringCodec;
 import io.lettuce.core.output.StatusOutput;
 import io.lettuce.core.protocol.*;
-
 import io.netty.channel.Channel;
 
 /**
@@ -230,7 +230,7 @@ protected void run(RedisClient client) throws Exception {
                 try (ServerSocket serverSocket = new ServerSocket(0)) {
 
                     RedisURI redisURI = RedisURI.builder().redis(TestSettings.host(), serverSocket.getLocalPort())
-                            .withPassword(passwd).withTimeout(500, TimeUnit.MILLISECONDS).build();
+                            .withPassword(passwd).withTimeout(Duration.ofMillis(500)).build();
 
                     try {
                         client.connect(redisURI);

File: src/test/java/io/lettuce/core/ClientTest.java
Patch:
@@ -29,9 +29,6 @@
 import io.lettuce.Wait;
 import io.lettuce.core.api.StatefulRedisConnection;
 import io.lettuce.core.api.async.RedisAsyncCommands;
-import io.lettuce.core.protocol.Command;
-import io.lettuce.core.protocol.CommandWrapper;
-import io.lettuce.core.protocol.RedisCommand;
 
 /**
  * @author Will Glozer

File: src/test/java/io/lettuce/core/cluster/ClusterClientOptionsTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2016 the original author or authors.
+ * Copyright 2011-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -34,7 +34,6 @@ public void testCopy() throws Exception {
         ClusterClientOptions copy = ClusterClientOptions.copyOf(options);
 
         assertThat(copy.getRefreshPeriod()).isEqualTo(options.getRefreshPeriod());
-        assertThat(copy.getRefreshPeriodUnit()).isEqualTo(options.getRefreshPeriodUnit());
         assertThat(copy.isCloseStaleConnections()).isEqualTo(options.isCloseStaleConnections());
         assertThat(copy.isRefreshClusterView()).isEqualTo(options.isRefreshClusterView());
         assertThat(copy.isValidateClusterNodeMembership()).isEqualTo(options.isValidateClusterNodeMembership());

File: src/test/java/io/lettuce/core/cluster/ClusterPartitionParserTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2016 the original author or authors.
+ * Copyright 2011-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,9 +19,9 @@
 import static org.hamcrest.CoreMatchers.hasItem;
 import static org.junit.Assert.assertThat;
 
+import java.time.Duration;
 import java.util.Collections;
 import java.util.HashSet;
-import java.util.concurrent.TimeUnit;
 
 import org.junit.Test;
 
@@ -139,7 +139,7 @@ protected RedisClusterNode mockRedisClusterNode() {
         node.setPongReceivedTimestamp(3);
         node.setSlaveOf("me");
         node.setSlots(LettuceLists.unmodifiableList(1, 2, 3));
-        node.setUri(new RedisURI("localhost", 1, 1, TimeUnit.DAYS));
+        node.setUri(new RedisURI("localhost", 1, Duration.ofDays(1)));
         return node;
     }
 

File: src/test/java/io/lettuce/core/dynamic/RedisCommandsClusterSyncTest.java
Patch:
@@ -17,8 +17,8 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
+import java.time.Duration;
 import java.util.List;
-import java.util.concurrent.TimeUnit;
 
 import org.junit.*;
 
@@ -79,7 +79,7 @@ public void sync() {
 
         SynchronousCommands api = factory.getCommands(SynchronousCommands.class);
 
-        api.setSync(key, value, Timeout.create(10, TimeUnit.SECONDS));
+        api.setSync(key, value, Timeout.create(Duration.ofSeconds(10)));
         assertThat(api.get("key")).isEqualTo("value");
         assertThat(api.getAsBytes("key")).isEqualTo("value".getBytes());
     }

File: src/main/java/io/lettuce/core/AbstractRedisAsyncCommands.java
Patch:
@@ -205,7 +205,7 @@ public RedisFuture<Long> commandCount() {
     }
 
     @Override
-    public RedisFuture<List<String>> configGet(String parameter) {
+    public RedisFuture<Map<String, String>> configGet(String parameter) {
         return dispatch(commandBuilder.configGet(parameter));
     }
 

File: src/main/java/io/lettuce/core/AbstractRedisReactiveCommands.java
Patch:
@@ -199,8 +199,8 @@ public Mono<Long> commandCount() {
     }
 
     @Override
-    public Flux<String> configGet(String parameter) {
-        return createDissolvingFlux(() -> commandBuilder.configGet(parameter));
+    public Mono<Map<String, String>> configGet(String parameter) {
+        return createMono(() -> commandBuilder.configGet(parameter));
     }
 
     @Override

File: src/main/java/io/lettuce/core/RedisCommandBuilder.java
Patch:
@@ -260,12 +260,12 @@ public Command<K, V, String> configRewrite() {
         return createCommand(CONFIG, new StatusOutput<K, V>(codec), args);
     }
 
-    public Command<K, V, List<String>> configGet(String parameter) {
+    public Command<K, V, Map<String, String>> configGet(String parameter) {
         LettuceAssert.notNull(parameter, "Parameter " + MUST_NOT_BE_NULL);
         LettuceAssert.notEmpty(parameter, "Parameter " + MUST_NOT_BE_EMPTY);
 
-        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).add(GET).add(parameter);
-        return createCommand(CONFIG, new StringListOutput<K, V>(codec), args);
+        CommandArgs<K, V> args = new CommandArgs<>((RedisCodec) STRING_CODEC).add(GET).add(parameter);
+        return createCommand(CONFIG, new MapOutput<>((RedisCodec) STRING_CODEC), args);
     }
 
     public Command<K, V, String> configResetstat() {

File: src/main/templates/io/lettuce/core/api/RedisServerCommands.java
Patch:
@@ -126,9 +126,9 @@ public interface RedisServerCommands<K, V> {
      * Get the value of a configuration parameter.
      *
      * @param parameter name of the parameter
-     * @return List&lt;String&gt; bulk-string-reply
+     * @return Map&lt;String, String&gt; bulk-string-reply
      */
-    List<String> configGet(String parameter);
+    Map<String, String> configGet(String parameter);
 
     /**
      * Reset the stats returned by INFO.

File: src/main/java/io/lettuce/core/cluster/RedisClusterClient.java
Patch:
@@ -529,6 +529,7 @@ <K, V> StatefulRedisClusterConnectionImpl<K, V> connectClusterImpl(RedisCodec<K,
             try {
                 connectStateful(connection, endpoint, getFirstUri(), socketAddressSupplier, () -> new CommandHandler(
                         clientOptions, clientResources, endpoint));
+                connection.inspectRedisState();
                 connected = true;
                 break;
             } catch (RedisException e) {
@@ -546,6 +547,7 @@ <K, V> StatefulRedisClusterConnectionImpl<K, V> connectClusterImpl(RedisCodec<K,
 
         connection.registerCloseables(closeableResources, clusterWriter, pooledClusterConnectionProvider);
 
+
         return connection;
     }
 
@@ -592,6 +594,7 @@ <K, V> StatefulRedisClusterPubSubConnection<K, V> connectClusterPubSubImpl(Redis
             try {
                 connectStateful(connection, endpoint, getFirstUri(), socketAddressSupplier,
                         () -> new PubSubCommandHandler<K, V>(clientOptions, clientResources, codec, endpoint));
+                connection.inspectRedisState();
                 connected = true;
                 break;
             } catch (RedisException e) {

File: src/main/java/io/lettuce/core/protocol/CommandType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2016 the original author or authors.
+ * Copyright 2011-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -79,7 +79,7 @@ public enum CommandType implements ProtocolKeyword {
     BITCOUNT, BITFIELD, BITOP, GETBIT, SETBIT, BITPOS,
 
     // Geo
-    GEOADD, GEORADIUS, GEORADIUSBYMEMBER, GEOENCODE, GEODECODE, GEOPOS, GEODIST, GEOHASH,
+    GEOADD, GEORADIUS, GEORADIUS_RO, GEORADIUSBYMEMBER, GEORADIUSBYMEMBER_RO, GEOENCODE, GEODECODE, GEOPOS, GEODIST, GEOHASH,
 
     // Others
     TIME, WAIT,

File: src/main/java/io/lettuce/core/cluster/ClusterDistributionChannelWriter.java
Patch:
@@ -105,7 +105,8 @@ public <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {
         ClusterCommand<K, V, T> commandToSend = getCommandToSend(command);
         CommandArgs<K, V> args = command.getArgs();
 
-        if (args != null) {
+        // exclude CLIENT commands from cluster routing
+        if (args != null && !CommandType.CLIENT.equals(commandToSend.getType())) {
 
             ByteBuffer encodedKey = args.getFirstEncodedKey();
             if (encodedKey != null) {

File: src/main/java/io/lettuce/core/cluster/RedisAdvancedClusterReactiveCommandsImpl.java
Patch:
@@ -242,6 +242,8 @@ public Mono<String> clientSetname(K name) {
 
         List<Publisher<String>> publishers = new ArrayList<>();
 
+        publishers.add(super.clientSetname(name));
+
         for (RedisClusterNode redisClusterNode : getStatefulConnection().getPartitions()) {
 
             Mono<RedisClusterReactiveCommands<K, V>> byNodeId = getConnectionReactive(redisClusterNode.getNodeId());

File: src/test/java/io/lettuce/core/cluster/AdvancedClusterClientTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2016 the original author or authors.
+ * Copyright 2011-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -290,6 +290,8 @@ public void clientSetname() throws Exception {
                     .getConnection(redisClusterNode.getNodeId());
             assertThat(nodeConnection.clientList()).contains(name);
         }
+
+        assertThat(syncCommands.clientGetname()).isEqualTo(name);
     }
 
     @Test(expected = RedisCommandExecutionException.class)

File: src/test/java/io/lettuce/core/cluster/AdvancedClusterReactiveTest.java
Patch:
@@ -173,6 +173,8 @@ public void clientSetname() {
                     .getConnection(redisClusterNode.getNodeId());
             assertThat(nodeConnection.clientList()).contains(name);
         }
+
+        StepVerifier.create(commands.clientGetname()).expectNext(name).verifyComplete();
     }
 
     @Test
@@ -371,7 +373,6 @@ public void clusterScanStreamingWithArgs() {
 
         assertThat(adapter.getList()).containsAll(
                 KeysAndValues.KEYS.stream().filter(k -> k.startsWith("a")).collect(Collectors.toList()));
-
     }
 
     private void writeKeysToTwoNodes() {

File: src/main/java/io/lettuce/core/dynamic/RedisCommandFactory.java
Patch:
@@ -26,6 +26,7 @@
 import io.lettuce.core.codec.RedisCodec;
 import io.lettuce.core.codec.StringCodec;
 import io.lettuce.core.dynamic.batch.BatchSize;
+import io.lettuce.core.dynamic.intercept.DefaultMethodInvokingInterceptor;
 import io.lettuce.core.dynamic.intercept.InvocationProxyFactory;
 import io.lettuce.core.dynamic.intercept.MethodInterceptor;
 import io.lettuce.core.dynamic.intercept.MethodInvocation;
@@ -180,7 +181,9 @@ public <T extends Commands> T getCommands(Class<T> commandInterface) {
         BatchAwareCommandLookupStrategy lookupStrategy = new BatchAwareCommandLookupStrategy(
                 new CompositeCommandLookupStrategy(), metadata);
 
+        factory.addInterceptor(new DefaultMethodInvokingInterceptor());
         factory.addInterceptor(new CommandFactoryExecutorMethodInterceptor(metadata, lookupStrategy));
+
         return factory.createProxy(commandInterface.getClassLoader());
     }
 

File: src/main/java/io/lettuce/core/dynamic/intercept/InvocationProxyFactory.java
Patch:
@@ -98,7 +98,7 @@ static class InterceptorChainInvocationHandler extends AbstractInvocationHandler
 
         @Override
         protected Object handleInvocation(Object proxy, Method method, Object[] args) throws Throwable {
-            return context.invoke(method, args);
+            return context.invoke(proxy, method, args);
         }
     }
 }

File: src/main/java/io/lettuce/core/PlainChannelInitializer.java
Patch:
@@ -23,12 +23,12 @@
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
 
+import io.lettuce.core.ConnectionEvents.PingBeforeActivate;
 import io.lettuce.core.event.connection.ConnectedEvent;
 import io.lettuce.core.event.connection.ConnectionActivatedEvent;
 import io.lettuce.core.event.connection.DisconnectedEvent;
 import io.lettuce.core.protocol.AsyncCommand;
 import io.lettuce.core.resource.ClientResources;
-
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
@@ -126,7 +126,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
     static void pingBeforeActivate(AsyncCommand<?, ?, ?> cmd, CompletableFuture<Boolean> initializedFuture,
             ChannelHandlerContext ctx, ClientResources clientResources, long timeout, TimeUnit timeUnit) throws Exception {
 
-        ctx.channel().writeAndFlush(cmd);
+        ctx.fireUserEventTriggered(new PingBeforeActivate(cmd));
 
         Runnable timeoutGuard = () -> {
 

File: src/main/java/io/lettuce/core/RedisClient.java
Patch:
@@ -248,7 +248,7 @@ private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandalone
         StatefulRedisConnectionImpl<K, V> connection = newStatefulRedisConnection(endpoint, codec, timeout.timeout,
                 timeout.timeUnit);
         ConnectionFuture<StatefulRedisConnection<K, V>> future = connectStatefulAsync(connection, endpoint, redisURI,
-                () -> new CommandHandler(clientResources, endpoint));
+                () -> new CommandHandler(clientOptions, clientResources, endpoint));
 
         future.whenComplete((channelHandler, throwable) -> {
 
@@ -386,7 +386,7 @@ private <K, V> StatefulRedisPubSubConnection<K, V> connectPubSub(RedisCodec<K, V
                 timeout.timeout, timeout.timeUnit);
 
         ConnectionFuture<StatefulRedisConnectionImpl<K, V>> future = connectStatefulAsync(connection, endpoint, redisURI,
-                () -> new PubSubCommandHandler<>(clientResources, codec, endpoint));
+                () -> new PubSubCommandHandler<>(clientOptions, clientResources, codec, endpoint));
 
         getConnection(future.whenComplete((conn, throwable) -> {
 
@@ -462,7 +462,7 @@ private <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<
 
         logger.debug("Trying to get a Redis Sentinel connection for one of: " + redisURI.getSentinels());
 
-        connectionBuilder.endpoint(endpoint).commandHandler(() -> new CommandHandler(clientResources, endpoint))
+        connectionBuilder.endpoint(endpoint).commandHandler(() -> new CommandHandler(clientOptions, clientResources, endpoint))
                 .connection(connection);
         connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, redisURI);
 

File: src/test/java/io/lettuce/core/ReactiveBackpressurePropagationTest.java
Patch:
@@ -73,7 +73,7 @@ public void before() throws Exception {
             return command;
         });
 
-        commandHandler = new CommandHandler(clientResources, endpoint);
+        commandHandler = new CommandHandler(ClientOptions.create(), clientResources, endpoint);
 
         embeddedChannel = new EmbeddedChannel(commandHandler);
         embeddedChannel.connect(new LocalAddress("remote"));

File: src/test/jmh/io/lettuce/core/protocol/CommandHandlerBenchmark.java
Patch:
@@ -46,7 +46,7 @@ public class CommandHandlerBenchmark {
     @Setup
     public void setup() {
 
-        commandHandler = new CommandHandler(EmptyClientResources.INSTANCE, new DefaultEndpoint(CLIENT_OPTIONS));
+        commandHandler = new CommandHandler(CLIENT_OPTIONS, EmptyClientResources.INSTANCE, new DefaultEndpoint(CLIENT_OPTIONS));
         command = new Command(CommandType.GET, new ValueOutput<>(CODEC), new CommandArgs(CODEC).addKey(KEY));
 
         commandHandler.setState(CommandHandler.LifecycleState.CONNECTED);
@@ -58,6 +58,6 @@ public void measureNettyWrite() throws Exception {
         commandHandler.write(CHANNEL_HANDLER_CONTEXT, command, null);
 
         // Prevent OOME
-        commandHandler.getQueue().clear();
+        commandHandler.getStack().clear();
     }
 }

File: src/main/java/io/lettuce/core/EpollProvider.java
Patch:
@@ -36,6 +36,7 @@
  * the {@literal netty-transport-native-epoll} library during runtime. Internal API.
  *
  * @author Mark Paluch
+ * @since 4.4
  */
 public class EpollProvider {
 
@@ -88,7 +89,7 @@ static void checkForEpollLibrary() {
         LettuceAssert
                 .assertState(
                         isAvailable(),
-                        "Cannot connect using sockets without Epoll support. Make sure netty-transport-native-epoll library on the class path and supported by your operating system.");
+                        "netty-transport-native-epoll is not available. Make sure netty-transport-native-epoll library on the class path and supported by your operating system.");
     }
 
     /**

File: src/main/java/io/lettuce/core/protocol/ChannelLogDescriptor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2016 the original author or authors.
+ * Copyright 2011-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -33,7 +33,7 @@ static String logDescriptor(Channel channel) {
         buffer.append("channel=").append(getId(channel)).append(", ");
 
         if (channel.localAddress() != null && channel.remoteAddress() != null) {
-            buffer.append(channel.localAddress()).append(" -> ");
+            buffer.append(channel.localAddress()).append(" -> ").append(channel.remoteAddress());
         } else {
             buffer.append(channel);
         }

File: src/main/java/io/lettuce/core/protocol/CommandHandler.java
Patch:
@@ -548,8 +548,8 @@ protected String logPrefix() {
         }
 
         StringBuilder buffer = new StringBuilder(64);
-        buffer.append('[').append("chid=0x").append(Long.toHexString(commandHandlerId)).append(", ")
-                .append(ChannelLogDescriptor.logDescriptor(channel)).append(']');
+        buffer.append('[').append(ChannelLogDescriptor.logDescriptor(channel)).append(", ")
+                .append("chid=0x").append(Long.toHexString(commandHandlerId)).append(']');
         return logPrefix = buffer.toString();
     }
 

File: src/main/java/io/lettuce/core/protocol/ConnectionWatchdog.java
Patch:
@@ -346,8 +346,8 @@ private String logPrefix() {
         }
 
         StringBuilder buffer = new StringBuilder(64);
-        buffer.append('[').append("Last known addr=").append(remoteAddress).append(", ")
-                .append(ChannelLogDescriptor.logDescriptor(channel)).append(']');
+        buffer.append('[')
+                .append(ChannelLogDescriptor.logDescriptor(channel)).append(", last known addr=").append(remoteAddress).append(']');
         return logPrefix = buffer.toString();
     }
 

File: src/main/java/io/lettuce/core/protocol/DefaultEndpoint.java
Patch:
@@ -570,8 +570,8 @@ protected String logPrefix() {
         }
 
         StringBuffer buffer = new StringBuffer(64);
-        buffer.append('[').append("epid=0x").append(Long.toHexString(endpointId)).append(", ")
-                .append(ChannelLogDescriptor.logDescriptor(channel)).append(']');
+        buffer.append('[').append(ChannelLogDescriptor.logDescriptor(channel)).append(", ")
+                .append("epid=0x").append(Long.toHexString(endpointId)).append(']');
         return logPrefix = buffer.toString();
     }
 

File: src/main/java/io/lettuce/core/Transports.java
Patch:
@@ -34,7 +34,7 @@ class Transports {
      */
     static Class<? extends EventLoopGroup> eventLoopGroupClass() {
 
-        if (NativeTransports.isSocketSupport()) {
+        if (NativeTransports.isSocketSupported()) {
             return NativeTransports.eventLoopGroupClass();
         }
 
@@ -46,7 +46,7 @@ static Class<? extends EventLoopGroup> eventLoopGroupClass() {
      */
     static Class<? extends Channel> socketChannelClass() {
 
-        if (NativeTransports.isSocketSupport()) {
+        if (NativeTransports.isSocketSupported()) {
             return NativeTransports.socketChannelClass();
         }
 
@@ -61,7 +61,7 @@ static class NativeTransports {
         /**
          * @return {@literal true} if a native transport is available.
          */
-        static boolean isSocketSupport() {
+        static boolean isSocketSupported() {
             return EpollProvider.isAvailable();
         }
 

File: src/main/java/io/lettuce/core/output/ScoredValueScanOutput.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2016 the original author or authors.
+ * Copyright 2011-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 
 import java.nio.ByteBuffer;
 
+import io.lettuce.core.LettuceStrings;
 import io.lettuce.core.ScoredValue;
 import io.lettuce.core.ScoredValueScanCursor;
 import io.lettuce.core.codec.RedisCodec;
@@ -44,7 +45,7 @@ protected void setOutput(ByteBuffer bytes) {
             return;
         }
 
-        double score = Double.parseDouble(decodeAscii(bytes));
+        double score = LettuceStrings.toDouble(decodeAscii(bytes));
         output.getValues().add(ScoredValue.fromNullable(score, value));
         value = null;
     }

File: src/main/java/io/lettuce/core/output/ScoredValueScanStreamingOutput.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2016 the original author or authors.
+ * Copyright 2011-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 
 import java.nio.ByteBuffer;
 
+import io.lettuce.core.LettuceStrings;
 import io.lettuce.core.ScoredValue;
 import io.lettuce.core.StreamScanCursor;
 import io.lettuce.core.codec.RedisCodec;
@@ -45,7 +46,7 @@ protected void setOutput(ByteBuffer bytes) {
             return;
         }
 
-        double score = Double.parseDouble(decodeAscii(bytes));
+        double score = LettuceStrings.toDouble(decodeAscii(bytes));
         channel.onValue(ScoredValue.fromNullable(score, value));
         value = null;
         output.setCount(output.getCount() + 1);

File: src/main/java/io/lettuce/core/output/ScoredValueStreamingOutput.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2016 the original author or authors.
+ * Copyright 2011-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 
 import java.nio.ByteBuffer;
 
+import io.lettuce.core.LettuceStrings;
 import io.lettuce.core.ScoredValue;
 import io.lettuce.core.codec.RedisCodec;
 
@@ -44,7 +45,7 @@ public void set(ByteBuffer bytes) {
             return;
         }
 
-        double score = Double.parseDouble(decodeAscii(bytes));
+        double score = LettuceStrings.toDouble(decodeAscii(bytes));
         channel.onValue(ScoredValue.fromNullable(score, value));
         value = null;
         output = output.longValue() + 1;

File: src/main/java/io/lettuce/core/cluster/RedisAdvancedClusterAsyncCommandsImpl.java
Patch:
@@ -61,7 +61,6 @@
 public class RedisAdvancedClusterAsyncCommandsImpl<K, V> extends AbstractRedisAsyncCommands<K, V> implements
         RedisAdvancedClusterAsyncCommands<K, V> {
 
-    private final Random random = ThreadLocalRandom.current();
     private final RedisCodec<K, V> codec;
 
     /**
@@ -355,7 +354,7 @@ public RedisFuture<String> scriptKill() {
     public RedisFuture<V> randomkey() {
 
         Partitions partitions = getStatefulConnection().getPartitions();
-        int index = random.nextInt(partitions.size());
+        int index = ThreadLocalRandom.current().nextInt(partitions.size());
         RedisClusterNode partition = partitions.getPartition(index);
 
         CompletableFuture<V> future = getConnectionAsync(partition.getUri().getHost(), partition.getUri().getPort())

File: src/main/java/io/lettuce/core/cluster/RedisAdvancedClusterReactiveCommandsImpl.java
Patch:
@@ -52,7 +52,6 @@
 public class RedisAdvancedClusterReactiveCommandsImpl<K, V> extends AbstractRedisReactiveCommands<K, V> implements
         RedisAdvancedClusterReactiveCommands<K, V> {
 
-    private final Random random = ThreadLocalRandom.current();
     private final RedisCodec<K, V> codec;
 
     /**
@@ -310,7 +309,7 @@ public Mono<Long> keys(KeyStreamingChannel<K> channel, K pattern) {
     public Mono<V> randomkey() {
 
         Partitions partitions = getStatefulConnection().getPartitions();
-        int index = random.nextInt(partitions.size());
+        int index = ThreadLocalRandom.current().nextInt(partitions.size());
 
         Mono<RedisClusterReactiveCommands<K, V>> connection = getConnectionReactive(partitions.getPartition(index).getNodeId());
         return connection.flatMap(RedisKeyReactiveCommands::randomkey);

File: src/test/java/com/lambdaworks/redis/cluster/AdvancedClusterReactiveTest.java
Patch:
@@ -174,9 +174,8 @@ public void clientSetname() throws Exception {
     }
 
     @Test
-    @Ignore("Multi-node-execution signals two errors")
     public void clientSetnameRunOnError() throws Exception {
-        StepVerifier.create(commands.clientSetname("not allowed")).expectError(RedisCommandExecutionException.class).verify();
+        StepVerifier.create(commands.clientSetname("not allowed")).expectError().verify();
     }
 
     @Test

File: src/test/java/com/lambdaworks/redis/commands/reactive/StringReactiveCommandTest.java
Patch:
@@ -46,7 +46,7 @@ public void mget() throws Exception {
         connection.sync().set("key2", value);
 
         Flux<KeyValue<String, String>> mget = connection.reactive().mget(key, "key1", "key2");
-        StepVerifier.create(mget.next()).expectNext(KeyValue.just(key, value)).thenCancel().verify();
+        StepVerifier.create(mget.next()).expectNext(KeyValue.just(key, value)).verifyComplete();
 
         connection.close();
     }
@@ -59,7 +59,7 @@ public void mgetEmpty() throws Exception {
         connection.sync().set(key, value);
 
         Flux<KeyValue<String, String>> mget = connection.reactive().mget("unknown");
-        StepVerifier.create(mget.next()).expectNext(KeyValue.empty("unknown")).thenCancel().verify();
+        StepVerifier.create(mget.next()).expectNext(KeyValue.empty("unknown")).verifyComplete();
 
         connection.close();
     }

File: src/main/java/com/lambdaworks/redis/RedisClient.java
Patch:
@@ -204,7 +204,9 @@ private <K, V> StatefulRedisConnection<K, V> connectStandalone(RedisCodec<K, V>
         return getConnection(future);
     }
 
-    private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec,
+    @SuppressWarnings("unused")
+    // Required by ReflectiveNodeConnectionFactory.
+    <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec,
             RedisURI redisURI) {
         return connectStandaloneAsync(codec, redisURI, Timeout.from(redisURI));
     }

File: src/main/java/com/lambdaworks/redis/cluster/RedisClusterClient.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2016 the original author or authors.
+ * Copyright 2011-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,7 +19,6 @@
 import java.net.SocketAddress;
 import java.net.URI;
 import java.util.*;
-import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
@@ -1045,7 +1044,7 @@ public <K, V> StatefulRedisConnection<K, V> connectToNode(RedisCodec<K, V> codec
         }
 
         @Override
-        public <K, V> CompletableFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec,
+        public <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec,
                 SocketAddress socketAddress) {
             return RedisClusterClient.this.connectToNodeAsync(codec, socketAddress.toString(), null, () -> socketAddress);
         }

File: src/main/java/com/lambdaworks/redis/cluster/topology/NodeConnectionFactory.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2016 the original author or authors.
+ * Copyright 2011-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,8 +16,8 @@
 package com.lambdaworks.redis.cluster.topology;
 
 import java.net.SocketAddress;
-import java.util.concurrent.CompletableFuture;
 
+import com.lambdaworks.redis.ConnectionFuture;
 import com.lambdaworks.redis.api.StatefulRedisConnection;
 import com.lambdaworks.redis.codec.RedisCodec;
 
@@ -50,6 +50,6 @@ public interface NodeConnectionFactory {
      * @return a new {@link StatefulRedisConnection}
      * @since 4.4
      */
-    <K, V> CompletableFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec,
+    <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec,
             SocketAddress socketAddress);
 }

File: src/main/java/com/lambdaworks/redis/dynamic/intercept/InvocationProxyFactory.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2016 the original author or authors.
+ * Copyright 2011-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -90,7 +90,7 @@ public void addInterceptor(MethodInterceptor interceptor) {
     /**
      * {@link MethodInterceptor}-based {@link InterceptorChainInvocationHandler}.
      */
-    private static class InterceptorChainInvocationHandler extends AbstractInvocationHandler {
+    static class InterceptorChainInvocationHandler extends AbstractInvocationHandler {
 
         private final List<MethodInterceptor> interceptors;
 
@@ -112,6 +112,7 @@ protected Object handleInvocation(Object proxy, Method method, Object[] args) th
 
         private DefaultMethodInvocation getInvocation(final Method method, final Object[] args,
                 final Iterator<MethodInterceptor> iterator) {
+
             return new DefaultMethodInvocation(method, args) {
 
                 @Override

File: src/main/java/com/lambdaworks/redis/protocol/ReconnectionHandler.java
Patch:
@@ -149,6 +149,7 @@ void setTimeout(long timeout) {
 
     void prepareClose() {
 
+        ChannelFuture currentFuture = this.currentFuture;
         if (currentFuture != null && !currentFuture.isDone()) {
             currentFuture.cancel(true);
         }

File: src/main/java/com/lambdaworks/redis/dynamic/CommandFactoryResolver.java
Patch:
@@ -17,11 +17,13 @@
 
 /**
  * Strategy interface to resolve a {@link CommandFactory}.
+ * 
+ * @since 5.0
  */
 interface CommandFactoryResolver {
 
     /**
-     * Resolve a {@link CommandFactory} given a{@link CommandMethod} and {@link RedisCommandsMetadata}.
+     * Resolve a {@link CommandFactory} given a{@link DeclaredCommandMethod} and {@link RedisCommandsMetadata}.
      * 
      * @param method must not be {@literal null}.
      * @param redisCommandsMetadata must not be {@literal null}.

File: src/main/java/com/lambdaworks/redis/dynamic/CommandMethodVerifier.java
Patch:
@@ -18,7 +18,10 @@
 import com.lambdaworks.redis.dynamic.segment.CommandSegments;
 
 /**
+ * Verifies {@link CommandMethod} declarations by checking available Redis commands.
+ * 
  * @author Mark Paluch
+ * @since 5.0
  */
 interface CommandMethodVerifier {
 

File: src/main/java/com/lambdaworks/redis/dynamic/ExecutableCommandLookupStrategy.java
Patch:
@@ -29,8 +29,8 @@ interface ExecutableCommandLookupStrategy {
      * Resolve a {@link ExecutableCommand} given the {@link Method} and {@link RedisCommandsMetadata}.
      * 
      * @param method must not be {@literal null}.
-     * @param commandsMetadata must not be {@literal null}.
+     * @param metadata must not be {@literal null}.
      * @return the {@link ExecutableCommand}.
      */
-    ExecutableCommand resolveCommandMethod(Method method, RedisCommandsMetadata commandsMetadata);
+    ExecutableCommand resolveCommandMethod(CommandMethod method, RedisCommandsMetadata metadata);
 }

File: src/test/java/com/lambdaworks/redis/dynamic/CommandSegmentCommandFactoryTest.java
Patch:
@@ -128,7 +128,7 @@ public void syncWithTimeout() {
     }
 
     private CommandMethod methodOf(Class<?> commandInterface, String methodName, Class... args) {
-        return new CommandMethod(ReflectionUtils.findMethod(commandInterface, methodName, args));
+        return DeclaredCommandMethod.create(ReflectionUtils.findMethod(commandInterface, methodName, args));
     }
 
     @SuppressWarnings("unchecked")

File: src/test/java/com/lambdaworks/redis/dynamic/DefaultCommandMethodVerifierTest.java
Patch:
@@ -109,7 +109,7 @@ public void methodDoesNotAcceptParameters() {
     private void validateMethod(String methodName, Class<?>... parameterTypes) {
 
         Method method = ReflectionUtils.findMethod(MyInterface.class, methodName, parameterTypes);
-        CommandMethod commandMethod = new CommandMethod(method);
+        CommandMethod commandMethod = DeclaredCommandMethod.create(method);
 
         sut.validate(new CommandSegments(Collections.singletonList(CommandSegment.constant(methodName))), commandMethod);
     }

File: src/test/java/com/lambdaworks/redis/dynamic/ParameterBinderTest.java
Patch:
@@ -149,7 +149,7 @@ public void rejectsStringUpperValue() {
     @Test
     public void bindsValueRangeCorrectly() {
 
-        CommandMethod commandMethod = new CommandMethod(
+        CommandMethod commandMethod = DeclaredCommandMethod.create(
                 ReflectionUtils.findMethod(MyCommands.class, "valueRange", Range.class));
 
         CommandArgs<String, String> args = bind(commandMethod,
@@ -162,7 +162,7 @@ public void bindsValueRangeCorrectly() {
     @Test
     public void bindsUnboundedValueRangeCorrectly() {
 
-        CommandMethod commandMethod = new CommandMethod(
+        CommandMethod commandMethod = DeclaredCommandMethod.create(
                 ReflectionUtils.findMethod(MyCommands.class, "valueRange", Range.class));
 
         CommandArgs<String, String> args = bind(commandMethod, Range.unbounded());
@@ -188,7 +188,7 @@ public void bindsProtocolKeywordCorrectly() {
     }
 
     private CommandArgs<String, String> bind(Object object) {
-        CommandMethod commandMethod = new CommandMethod(
+        CommandMethod commandMethod = DeclaredCommandMethod.create(
                 ReflectionUtils.findMethod(MyCommands.class, "justObject", Object.class));
         return bind(commandMethod, object);
     }

File: src/test/java/com/lambdaworks/redis/dynamic/ReactiveCommandSegmentCommandFactoryTest.java
Patch:
@@ -70,7 +70,7 @@ public void commandCreationWithTimeoutShouldFail() {
 
         Method method = ReflectionUtils.findMethod(interfaceClass, methodName, parameterTypes);
 
-        CommandMethod commandMethod = new CommandMethod(method);
+        CommandMethod commandMethod = DeclaredCommandMethod.create(method);
 
         AnnotationCommandSegmentFactory segmentFactory = new AnnotationCommandSegmentFactory();
         CommandSegments commandSegments = segmentFactory.createCommandSegments(commandMethod);

File: src/test/java/com/lambdaworks/redis/dynamic/output/CodecAwareOutputResolverTest.java
Patch:
@@ -26,6 +26,7 @@
 
 import com.lambdaworks.redis.codec.RedisCodec;
 import com.lambdaworks.redis.dynamic.CommandMethod;
+import com.lambdaworks.redis.dynamic.DeclaredCommandMethod;
 import com.lambdaworks.redis.dynamic.support.ReflectionUtils;
 import com.lambdaworks.redis.output.*;
 
@@ -87,7 +88,7 @@ public void shouldResolveMapsOutput() {
     protected CommandOutput<?, ?, ?> getCommandOutput(String methodName) {
 
         Method method = ReflectionUtils.findMethod(CommandMethods.class, methodName);
-        CommandMethod commandMethod = new CommandMethod(method);
+        CommandMethod commandMethod = DeclaredCommandMethod.create(method);
 
         CommandOutputFactory factory = resolver
                 .resolveCommandOutput(new OutputSelector(commandMethod.getReturnType(), new ByteBufferAndStringCodec()));

File: src/test/java/com/lambdaworks/redis/dynamic/output/OutputRegistryCommandOutputFactoryResolverTest.java
Patch:
@@ -27,7 +27,7 @@
 import com.lambdaworks.redis.ScoredValue;
 import com.lambdaworks.redis.Value;
 import com.lambdaworks.redis.codec.StringCodec;
-import com.lambdaworks.redis.dynamic.CommandMethod;
+import com.lambdaworks.redis.dynamic.DeclaredCommandMethod;
 import com.lambdaworks.redis.dynamic.support.ReflectionUtils;
 import com.lambdaworks.redis.output.*;
 
@@ -151,7 +151,7 @@ public void stringWildcardValueCollectionIsAssignableFromOutputs() {
     private OutputSelector getOutputSelector(String methodName) {
 
         Method method = ReflectionUtils.findMethod(CommandMethods.class, methodName);
-        return new OutputSelector(new CommandMethod(method).getActualReturnType(), StringCodec.UTF8);
+        return new OutputSelector(DeclaredCommandMethod.create(method).getActualReturnType(), StringCodec.UTF8);
     }
 
     private static interface CommandMethods {

File: src/test/java/com/lambdaworks/Wait.java
Patch:
@@ -96,7 +96,7 @@ public static <T> WaitBuilder<T> untilNotEquals(T expectation, Supplier<T> actua
 
             if (o instanceof Number && expectation instanceof Number) {
                 Number actualNumber = (Number) o;
-                Number expectedNumber = (Number) o;
+                Number expectedNumber = (Number) expectation;
 
                 if (actualNumber.doubleValue() == expectedNumber.doubleValue()) {
                     return false;

File: src/test/java/com/lambdaworks/redis/support/ConnectionPoolSupportTest.java
Patch:
@@ -184,7 +184,7 @@ public void wrappedMasterSlaveConnectionShouldUseWrappers() throws Exception {
     @Test
     public void wrappedClusterConnectionShouldUseWrappers() throws Exception {
 
-        RedisClusterClient redisClusterClient = RedisClusterClient.create(TestClientResources.create(),
+        RedisClusterClient redisClusterClient = RedisClusterClient.create(TestClientResources.get(),
                 RedisURI.create(TestSettings.host(), 7379));
 
         GenericObjectPool<StatefulRedisClusterConnection<String, String>> pool = ConnectionPoolSupport

File: src/main/java/com/lambdaworks/redis/cluster/models/partitions/Partitions.java
Patch:
@@ -146,7 +146,7 @@ public void addPartition(RedisClusterNode partition) {
 
         LettuceAssert.notNull(partition, "Partition must not be null");
 
-        synchronized (this) {
+        synchronized (partitions) {
             slotCache = EMPTY;
             partitions.add(partition);
         }
@@ -179,7 +179,7 @@ public void reload(List<RedisClusterNode> partitions) {
 
         LettuceAssert.noNullElements(partitions, "Partitions must not contain null elements");
 
-        synchronized (partitions) {
+        synchronized (this.partitions) {
             this.partitions.clear();
             this.partitions.addAll(partitions);
             updateCache();

File: src/main/java/com/lambdaworks/redis/dynamic/CommandSegmentCommandFactory.java
Patch:
@@ -48,7 +48,7 @@ public CommandSegmentCommandFactory(CommandSegments commandSegments, CommandMeth
         this.redisCodec = redisCodec;
         this.outputResolver = outputResolver;
 
-        OutputSelector outputSelector = new OutputSelector(commandMethod.getActualReturnType());
+        OutputSelector outputSelector = new OutputSelector(commandMethod.getActualReturnType(), redisCodec);
         CommandOutputFactory factory = resolveCommandOutputFactory(outputSelector);
 
         if (factory == null) {

File: src/main/java/com/lambdaworks/redis/dynamic/support/ClassTypeInformation.java
Patch:
@@ -43,7 +43,7 @@ public class ClassTypeInformation<S> extends TypeDiscoverer<S> {
 
     static {
         for (ClassTypeInformation<?> info : Arrays.asList(COLLECTION, LIST, SET, MAP, OBJECT)) {
-            CACHE.put(info.getType(), new WeakReference<ClassTypeInformation<?>>(info));
+            CACHE.put(info.getType(), new WeakReference<>(info));
         }
     }
 

File: src/test/java/com/lambdaworks/redis/dynamic/support/ParametrizedTypeInformationTest.java
Patch:
@@ -88,7 +88,6 @@ public void isAssignableShouldConsiderNestedParameterTypes() throws Exception {
         TypeInformation<Object> target = ClassTypeInformation
                 .fromReturnTypeOf(ReflectionUtils.findMethod(TestType.class, "collectionOfIterableOfNumber"));
 
-        assertThat(target.isAssignableFrom(ClassTypeInformation.from(ListOfIterableOfNumber.class))).isTrue();
         assertThat(target.isAssignableFrom(ClassTypeInformation.from(ListOfIterableOfInteger.class))).isFalse();
         assertThat(target.isAssignableFrom(ClassTypeInformation.from(ListOfListOfNumber.class))).isFalse();
         assertThat(target.isAssignableFrom(ClassTypeInformation.from(ListOfSetOfNumber.class))).isFalse();

File: src/main/java/com/lambdaworks/redis/dynamic/support/GenericArrayTypeInformation.java
Patch:
@@ -46,7 +46,7 @@ protected GenericArrayTypeInformation(GenericArrayType type, TypeDiscoverer<?> p
     @Override
     @SuppressWarnings("unchecked")
     public Class<S> getType() {
-        return (Class<S>) Array.newInstance(resolveType(type.getGenericComponentType()), 0).getClass();
+        return (Class<S>) Array.newInstance(resolveClass(type.getGenericComponentType()), 0).getClass();
     }
 
     @Override

File: src/test/java/com/lambdaworks/redis/commands/GeoCommandTest.java
Patch:
@@ -118,8 +118,7 @@ public void geodist() throws Exception {
         assertThat(result).isGreaterThan(2.5).isLessThan(2.9);
     }
 
-    // See https://github.com/antirez/redis/issues/3512 and https://github.com/mp911de/lettuce/issues/362
-    @Test(expected = RedisException.class)
+    @Test
     public void geodistMissingElements() throws Exception {
 
         prepareGeo();
@@ -256,7 +255,8 @@ public void geohashUnknownKey() throws Exception {
 
         List<Value<String>> geohash = redis.geohash("dunno", "member");
 
-        assertThat(geohash).isEmpty();
+        assertThat(geohash).hasSize(1);
+        assertThat(geohash.get(0)).isIn(null, Value.empty());
     }
 
     @Test

File: src/main/java/com/lambdaworks/redis/dynamic/CommandSegmentCommandFactory.java
Patch:
@@ -89,7 +89,7 @@ protected CommandOutputFactory resolveCommandOutputFactory(OutputSelector output
         com.lambdaworks.redis.protocol.Command<?, ?, ?> command = new com.lambdaworks.redis.protocol.Command<>(
                 this.segments.getCommandType(), output, args);
 
-        parameterBinder.bind(args, segments, parametersAccessor);
+        parameterBinder.bind(args, redisCodec, segments, parametersAccessor);
 
         return command;
     }

File: src/test/java/com/lambdaworks/redis/dynamic/ParameterBinderTest.java
Patch:
@@ -146,7 +146,7 @@ public void rejectsStringUpperValue() {
         bind(Range.from(Range.Boundary.including(11), Range.Boundary.excluding("hello")));
     }
 
-    @Test(expected = UnsupportedOperationException.class)
+    @Test
     public void bindsValueRangeCorrectly() {
 
         CommandMethod commandMethod = new CommandMethod(
@@ -159,7 +159,7 @@ public void bindsValueRangeCorrectly() {
                 Base64Utils.encodeToString("(upper".getBytes())));
     }
 
-    @Test(expected = UnsupportedOperationException.class)
+    @Test
     public void bindsUnboundedValueRangeCorrectly() {
 
         CommandMethod commandMethod = new CommandMethod(
@@ -198,7 +198,7 @@ private CommandArgs<String, String> bind(CommandMethod commandMethod, Object obj
                 object);
 
         CommandArgs<String, String> args = new CommandArgs<>(new StringCodec());
-        binder.bind(args, segments, parametersAccessor);
+        binder.bind(args, StringCodec.UTF8, segments, parametersAccessor);
 
         return args;
     }

File: src/main/java/com/lambdaworks/redis/protocol/CommandArgs.java
Patch:
@@ -63,7 +63,6 @@ public class CommandArgs<K, V> {
     private K firstKey;
 
     /**
-     *
      * @param codec Codec used to encode/decode keys and values, must not be {@literal null}.
      */
     public CommandArgs(RedisCodec<K, V> codec) {

File: src/main/java/com/lambdaworks/redis/ScanIterator.java
Patch:
@@ -38,7 +38,7 @@
  * @author Mark Paluch
  * @since 4.4
  */
-abstract public class ScanIterator<T> implements Iterator<T> {
+public abstract class ScanIterator<T> implements Iterator<T> {
 
     /**
      * Sequentially iterate over keys in the keyspace. This method uses {@code SCAN} to perform an iterative scan.

File: src/main/java/com/lambdaworks/redis/masterslave/MasterSlaveConnectionProvider.java
Patch:
@@ -253,6 +253,9 @@ public StatefulRedisConnection<K, V> apply(ConnectionKey key) {
                 builder.withPassword(new String(initialRedisUri.getPassword()));
             }
 
+            if (initialRedisUri.getClientName() != null) {
+                builder.withClientName(initialRedisUri.getClientName());
+            }
             builder.withDatabase(initialRedisUri.getDatabase());
 
             StatefulRedisConnection<K, V> connection = redisClient.connect(redisCodec, builder.build());

File: src/main/java/com/lambdaworks/redis/resource/DefaultEventLoopGroupProvider.java
Patch:
@@ -132,6 +132,7 @@ private <T extends EventLoopGroup> T getOrCreate(Class<T> type) {
      * @throws IllegalArgumentException if the {@code type} is not supported.
      */
     public static <T extends EventExecutorGroup> EventExecutorGroup createEventLoopGroup(Class<T> type, int numberOfThreads) {
+
         if (DefaultEventExecutorGroup.class.equals(type)) {
             return new DefaultEventExecutorGroup(numberOfThreads, new DefaultThreadFactory("lettuce-eventExecutorLoop", true));
         }
@@ -140,9 +141,10 @@ public static <T extends EventExecutorGroup> EventExecutorGroup createEventLoopG
             return new NioEventLoopGroup(numberOfThreads, new DefaultThreadFactory("lettuce-nioEventLoop", true));
         }
 
-        if (EpollProvider.epollEventLoopGroupClass != null && EpollProvider.epollEventLoopGroupClass.equals(type)) {
+        if (EpollProvider.isAvailable() && EpollProvider.isEventLoopGroup(type)) {
             return EpollProvider.newEventLoopGroup(numberOfThreads, new DefaultThreadFactory("lettuce-epollEventLoop", true));
         }
+
         throw new IllegalArgumentException("Type " + type.getName() + " not supported");
     }
 

File: src/test/java/com/lambdaworks/redis/dynamic/ReactiveTypeAdaptersTest.java
Patch:
@@ -113,7 +113,7 @@ public void toWrapperShouldConvertRxJava2FlowableToFlux() {
     public void toWrapperShouldCastRxJava2FlowableToPublisher() {
 
         io.reactivex.Flowable<String> foo = io.reactivex.Flowable.just("foo");
-        assertThat(conversionService.convert(foo, Publisher.class)).isInstanceOf(Flowable.class);
+        assertThat(conversionService.convert(foo, Publisher.class)).isInstanceOf(Publisher.class);
     }
 
     @Test

File: src/main/java/com/lambdaworks/redis/dynamic/ReactiveTypeAdapters.java
Patch:
@@ -202,7 +202,7 @@ public enum RxJava1SingleToMonoAdapter implements Function<Single<?>, Mono<?>> {
 
         @Override
         public Mono<?> apply(Single<?> source) {
-            return Mono.defer(() -> Mono.from(RxReactiveStreams.toPublisher(source)));
+            return Mono.defer(() -> Mono.from((Publisher<?>) RxReactiveStreams.toPublisher(source)));
         }
     }
 
@@ -267,7 +267,7 @@ public enum RxJava1ObservableToMonoAdapter implements Function<Observable<?>, Mo
 
         @Override
         public Mono<?> apply(Observable<?> source) {
-            return Mono.defer(() -> Mono.from(RxReactiveStreams.toPublisher(source)));
+            return Mono.defer(() -> Mono.from((Publisher<?>) RxReactiveStreams.toPublisher(source)));
         }
     }
 
@@ -280,7 +280,7 @@ public enum RxJava1ObservableToFluxAdapter implements Function<Observable<?>, Fl
 
         @Override
         public Flux<?> apply(Observable<?> source) {
-            return Flux.defer(() -> Flux.from(RxReactiveStreams.toPublisher(source)));
+            return Flux.defer(() -> Flux.from((Publisher<?>) RxReactiveStreams.toPublisher(source)));
         }
     }
 

File: src/test/java/com/lambdaworks/redis/dynamic/ReactiveTypeAdaptersTest.java
Patch:
@@ -113,7 +113,7 @@ public void toWrapperShouldConvertRxJava2FlowableToFlux() {
     public void toWrapperShouldCastRxJava2FlowableToPublisher() {
 
         io.reactivex.Flowable<String> foo = io.reactivex.Flowable.just("foo");
-        assertThat(conversionService.convert(foo, Publisher.class)).isInstanceOf(Flux.class);
+        assertThat(conversionService.convert(foo, Publisher.class)).isInstanceOf(Flowable.class);
     }
 
     @Test

File: src/main/java/com/lambdaworks/redis/BitFieldArgs.java
Patch:
@@ -16,7 +16,7 @@
  * @author Mark Paluch
  * @since 4.2
  */
-public class BitFieldArgs {
+public class BitFieldArgs implements CompositeArgument {
 
     private List<SubCommand> commands;
 
@@ -528,7 +528,7 @@ private abstract static class SubCommand {
         abstract <K, V> void build(CommandArgs<K, V> args);
     }
 
-    <K, V> void build(CommandArgs<K, V> args) {
+    public <K, V> void build(CommandArgs<K, V> args) {
 
         for (SubCommand command : commands) {
             command.build(args);

File: src/main/java/com/lambdaworks/redis/GeoArgs.java
Patch:
@@ -9,7 +9,7 @@
  * 
  * @author Mark Paluch
  */
-public class GeoArgs {
+public class GeoArgs implements CompositeArgument {
 
     private boolean withdistance;
     private boolean withcoordinates;

File: src/main/java/com/lambdaworks/redis/GeoRadiusStoreArgs.java
Patch:
@@ -10,7 +10,7 @@
  *
  * @author Mark Paluch
  */
-public class GeoRadiusStoreArgs<K> {
+public class GeoRadiusStoreArgs<K> implements CompositeArgument {
 
     private K storeKey;
     private K storeDistKey;

File: src/main/java/com/lambdaworks/redis/KillArgs.java
Patch:
@@ -13,7 +13,7 @@
  * @author Mark Paluch
  * @since 3.0
  */
-public class KillArgs {
+public class KillArgs implements CompositeArgument {
 
     private static enum Type {
         NORMAL, SLAVE, PUBSUB
@@ -86,7 +86,7 @@ public KillArgs type(Type type) {
         return this;
     }
 
-    <K, V> void build(CommandArgs<K, V> args) {
+    public <K, V> void build(CommandArgs<K, V> args) {
 
         if (skipme != null) {
             args.add(SKIPME).add(skipme.booleanValue() ? "yes" : "no");

File: src/main/java/com/lambdaworks/redis/MigrateArgs.java
Patch:
@@ -15,7 +15,7 @@
  *
  * @author Mark Paluch
  */
-public class MigrateArgs<K> {
+public class MigrateArgs<K> implements CompositeArgument {
 
     private boolean copy = false;
     private boolean replace = false;

File: src/main/java/com/lambdaworks/redis/SetArgs.java
Patch:
@@ -11,7 +11,7 @@
  * 
  * @author Vincent Rischmann
  */
-public class SetArgs {
+public class SetArgs implements CompositeArgument {
 
     private Long ex;
     private Long px;

File: src/main/java/com/lambdaworks/redis/ZAddArgs.java
Patch:
@@ -8,7 +8,7 @@
  * 
  * @author Mark Paluch
  */
-public class ZAddArgs {
+public class ZAddArgs implements CompositeArgument {
 
     private boolean nx = false;
     private boolean xx = false;

File: src/main/java/com/lambdaworks/redis/ZStoreArgs.java
Patch:
@@ -16,7 +16,7 @@
  * 
  * @author Will Glozer
  */
-public class ZStoreArgs {
+public class ZStoreArgs implements CompositeArgument {
 
     private static enum Aggregate {
         SUM, MIN, MAX
@@ -96,7 +96,7 @@ private static double[] toDoubleArray(long[] weights) {
         return result;
     }
 
-    <K, V> void build(CommandArgs<K, V> args) {
+    public <K, V> void build(CommandArgs<K, V> args) {
 
         if (weights != null) {
 

File: src/main/java/com/lambdaworks/redis/resource/DefaultClientResources.java
Patch:
@@ -395,8 +395,8 @@ public Builder reconnectDelay(Delay reconnectDelay) {
         }
 
         /**
-         * Sets the stateful reconnect {@link Supplier} to delay reconnect attempts. Defaults to binary exponential delay capped
-         * at {@literal 30 SECONDS}.
+         * Sets the stateful reconnect {@link Supplier} to delay reconnect attempts. Defaults to binary exponential delay capped at
+         * {@literal 30 SECONDS}.
          *
          * @param reconnectDelay the reconnect delay, must not be {@literal null}.
          * @return this

File: src/test/java/com/lambdaworks/redis/commands/reactive/BitReactiveCommandTest.java
Patch:
@@ -97,6 +97,6 @@ public void bitfieldOverflow() throws Exception {
 
         List<Value<Long>> values = reactive.bitfield(key, bitFieldArgs).collectList().block();
 
-        assertThat(values).containsExactly(Value.just(0L), Value.empty());
+        assertThat(values).contains(Value.empty());
     }
 }

File: src/main/java/com/lambdaworks/redis/cluster/RedisAdvancedClusterReactiveCommandsImpl.java
Patch:
@@ -197,7 +197,7 @@ public Mono<Long> mget(KeyValueStreamingChannel<K, V> channel, Iterable<K> keys)
     public Mono<Boolean> msetnx(Map<K, V> map) {
 
         return pipeliningWithMap(map, kvMap -> RedisAdvancedClusterReactiveCommandsImpl.super.msetnx(kvMap).flux(),
-                booleanFlux -> booleanFlux).reduce((accu, next) -> accu || next);
+                booleanFlux -> booleanFlux).reduce((accu, next) -> accu && next);
     }
 
     @Override

File: src/test/java/com/lambdaworks/redis/cluster/commands/StringClusterCommandTest.java
Patch:
@@ -56,8 +56,9 @@ public void msetnx() throws Exception {
         Map<String, String> map = new LinkedHashMap<>();
         map.put("one", "1");
         map.put("two", "2");
-        assertThat(redis.msetnx(map)).isTrue();
+        assertThat(redis.msetnx(map)).isFalse();
         redis.del("one");
+        redis.del("two"); // probably set on a different node
         assertThat(redis.msetnx(map)).isTrue();
         assertThat(redis.get("two")).isEqualTo("2");
     }

File: src/test/java/com/lambdaworks/redis/cluster/commands/reactive/StringClusterReactiveCommandTest.java
Patch:
@@ -59,8 +59,9 @@ public void msetnx() throws Exception {
         Map<String, String> map = new LinkedHashMap<>();
         map.put("one", "1");
         map.put("two", "2");
-        assertThat(redis.msetnx(map)).isTrue();
+        assertThat(redis.msetnx(map)).isFalse();
         redis.del("one");
+        redis.del("two"); // probably set on a different node
         assertThat(redis.msetnx(map)).isTrue();
         assertThat(redis.get("two")).isEqualTo("2");
     }

File: src/test/java/com/lambdaworks/redis/ConnectionCommandTest.java
Patch:
@@ -122,7 +122,7 @@ public void selectInvalid() throws Exception {
             async.select(1024);
             fail("Selected invalid db index");
         } catch (RedisException e) {
-            assertThat(e.getMessage()).isEqualTo("ERR invalid DB index");
+            assertThat(e.getMessage()).startsWith("ERR");
             StatefulRedisConnection<String, String> statefulRedisCommands = async.getStatefulConnection();
             assertThat(ReflectionTestUtils.getField(statefulRedisCommands, "db")).isEqualTo(0);
         } finally {

File: src/test/java/com/lambdaworks/apigenerator/Constants.java
Patch:
@@ -7,7 +7,8 @@
  */
 class Constants {
 
-    public final static String[] TEMPLATE_NAMES = { "RedisSortedSetCommands",
+    public final static String[] TEMPLATE_NAMES = { "RedisHashCommands", "RedisHLLCommands", "RedisKeyCommands",
+            "RedisListCommands", "RedisScriptingCommands", "RedisServerCommands", "RedisSetCommands", "RedisSortedSetCommands",
             "RedisStringCommands", "RedisTransactionalCommands", "RedisSentinelCommands", "BaseRedisCommands",
             "RedisGeoCommands" };
 

File: src/test/java/com/lambdaworks/apigenerator/CreateAsyncApi.java
Patch:
@@ -97,7 +97,7 @@ protected Function<MethodDeclaration, Type> methodTypeMutator() {
     }
 
     /**
-     * Supply addititional imports.
+     * Supply additional imports.
      *
      * @return
      */

File: src/test/java/com/lambdaworks/apigenerator/CreateAsyncNodeSelectionClusterApi.java
Patch:
@@ -107,7 +107,7 @@ protected Function<MethodDeclaration, Type> methodTypeMutator() {
     }
 
     /**
-     * Supply addititional imports.
+     * Supply additional imports.
      *
      * @return
      */

File: src/test/java/com/lambdaworks/apigenerator/CreateSyncApi.java
Patch:
@@ -98,7 +98,7 @@ protected Function<MethodDeclaration, Type> methodTypeMutator() {
     }
 
     /**
-     * Supply addititional imports.
+     * Supply additional imports.
      * 
      * @return
      */

File: src/test/java/com/lambdaworks/apigenerator/CreateSyncNodeSelectionClusterApi.java
Patch:
@@ -111,7 +111,7 @@ protected Function<MethodDeclaration, Type> methodTypeMutator() {
     }
 
     /**
-     * Supply addititional imports.
+     * Supply additional imports.
      *
      * @return
      */

File: src/test/java/com/lambdaworks/apigenerator/GenerateCommandInterfaces.java
Patch:
@@ -4,11 +4,13 @@
 import org.junit.runners.Suite;
 
 /**
+ * Entrypoint to generate all Redis command interfaces from {@code src/main/templates}.
+ * 
  * @author Mark Paluch
  */
 @RunWith(Suite.class)
 @Suite.SuiteClasses({ CreateAsyncApi.class, CreateSyncApi.class, CreateReactiveApi.class,
         CreateAsyncNodeSelectionClusterApi.class, CreateSyncNodeSelectionClusterApi.class })
-public class CreateSyncAsyncRxApis {
+public class GenerateCommandInterfaces {
 
 }

File: src/test/java/com/lambdaworks/apigenerator/Constants.java
Patch:
@@ -7,8 +7,7 @@
  */
 class Constants {
 
-    public final static String[] TEMPLATE_NAMES = { "RedisHashCommands", "RedisHLLCommands", "RedisKeyCommands",
-            "RedisListCommands", "RedisScriptingCommands", "RedisServerCommands", "RedisSetCommands", "RedisSortedSetCommands",
+    public final static String[] TEMPLATE_NAMES = { "RedisSortedSetCommands",
             "RedisStringCommands", "RedisTransactionalCommands", "RedisSentinelCommands", "BaseRedisCommands",
             "RedisGeoCommands" };
 

File: src/test/java/com/lambdaworks/redis/ClientTest.java
Patch:
@@ -4,7 +4,6 @@
 
 import static com.google.code.tempusfugit.temporal.Duration.seconds;
 import static com.google.code.tempusfugit.temporal.WaitFor.waitOrTimeout;
-import static com.lambdaworks.ConnectionTestUtil.getStatefulConnection;
 import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.concurrent.TimeUnit;
@@ -76,7 +75,7 @@ public void listenerTest() throws Exception {
 
         RedisAsyncCommands<String, String> connection = client.connect().async();
 
-        StatefulRedisConnection<String, String> statefulRedisConnection = getStatefulConnection(connection);
+        StatefulRedisConnection<String, String> statefulRedisConnection = connection.getStatefulConnection();
 
         waitOrTimeout(() -> listener.onConnected != null, Timeout.timeout(seconds(2)));
 

File: src/main/java/com/lambdaworks/redis/AbstractRedisAsyncCommands.java
Patch:
@@ -1729,7 +1729,7 @@ public RedisFuture<Long> georadiusbymember(K key, V member, double distance, Uni
     }
 
     @Override
-    public RedisFuture<List<Value<GeoCoordinates>>> geopos(K key, V... members) {
+    public RedisFuture<List<GeoCoordinates>> geopos(K key, V... members) {
         return dispatch(commandBuilder.geopos(key, members));
     }
 

File: src/main/java/com/lambdaworks/redis/AbstractRedisReactiveCommands.java
Patch:
@@ -1740,7 +1740,7 @@ public Mono<Long> georadiusbymember(K key, V member, double distance, Unit unit,
 
     @Override
     public Flux<Value<GeoCoordinates>> geopos(K key, V... members) {
-        return createDissolvingFlux(() -> commandBuilder.geopos(key, members));
+        return createDissolvingFlux(() -> commandBuilder.geoposValues(key, members));
     }
 
     @Override

File: src/main/java/com/lambdaworks/redis/api/async/RedisGeoAsyncCommands.java
Patch:
@@ -130,7 +130,7 @@ public interface RedisGeoAsyncCommands<K, V> {
      * @return a list of {@link GeoCoordinates}s representing the x,y position of each element specified in the arguments. For
      *         missing elements {@literal null} is returned.
      */
-    RedisFuture<List<Value<GeoCoordinates>>> geopos(K key, V... members);
+    RedisFuture<List<GeoCoordinates>> geopos(K key, V... members);
 
     /**
      *

File: src/main/java/com/lambdaworks/redis/api/sync/RedisGeoCommands.java
Patch:
@@ -130,7 +130,7 @@ public interface RedisGeoCommands<K, V> {
      * @return a list of {@link GeoCoordinates}s representing the x,y position of each element specified in the arguments. For
      *         missing elements {@literal null} is returned.
      */
-    List<Value<GeoCoordinates>> geopos(K key, V... members);
+    List<GeoCoordinates> geopos(K key, V... members);
 
     /**
      *

File: src/main/java/com/lambdaworks/redis/cluster/api/async/NodeSelectionGeoAsyncCommands.java
Patch:
@@ -130,7 +130,7 @@ public interface NodeSelectionGeoAsyncCommands<K, V> {
      * @return a list of {@link GeoCoordinates}s representing the x,y position of each element specified in the arguments. For
      *         missing elements {@literal null} is returned.
      */
-    AsyncExecutions<List<Value<GeoCoordinates>>> geopos(K key, V... members);
+    AsyncExecutions<List<GeoCoordinates>> geopos(K key, V... members);
 
     /**
      *

File: src/main/java/com/lambdaworks/redis/cluster/api/sync/NodeSelectionGeoCommands.java
Patch:
@@ -130,7 +130,7 @@ public interface NodeSelectionGeoCommands<K, V> {
      * @return a list of {@link GeoCoordinates}s representing the x,y position of each element specified in the arguments. For
      *         missing elements {@literal null} is returned.
      */
-    Executions<List<Value<GeoCoordinates>>> geopos(K key, V... members);
+    Executions<List<GeoCoordinates>> geopos(K key, V... members);
 
     /**
      *

File: src/main/templates/com/lambdaworks/redis/api/RedisGeoCommands.java
Patch:
@@ -132,7 +132,7 @@ public interface RedisGeoCommands<K, V> {
      * @return a list of {@link GeoCoordinates}s representing the x,y position of each element specified in the arguments. For
      *         missing elements {@literal null} is returned.
      */
-    List<Value<GeoCoordinates>> geopos(K key, V... members);
+    List<GeoCoordinates> geopos(K key, V... members);
 
     /**
      *

File: src/test/java/biz/paluch/redis/extensibility/LettuceGeoDemo.java
Patch:
@@ -40,8 +40,8 @@ public static void main(String[] args) {
         System.out.println("Distance: " + weinheim.distance);
         System.out.println("Coordinates: " + weinheim.coordinates.x + "/" + weinheim.coordinates.y);
 
-        List<Value<GeoCoordinates>> geopos = redis.geopos(key, "Weinheim", "Train station");
-        GeoCoordinates weinheimGeopos = geopos.get(0).getValue();
+        List<GeoCoordinates> geopos = redis.geopos(key, "Weinheim", "Train station");
+        GeoCoordinates weinheimGeopos = geopos.get(0);
         System.out.println("Coordinates: " + weinheimGeopos.x + "/" + weinheimGeopos.y);
 
         redis.getStatefulConnection().close();

File: src/main/java/com/lambdaworks/redis/TransactionResult.java
Patch:
@@ -37,6 +37,7 @@ public interface TransactionResult extends Iterable<Object> {
      * Returns the element at the specified position in this {@link TransactionResult}.
      *
      * @param index index of the element to return
+     * @param <T> inferred type
      * @return the element at the specified position in this {@link TransactionResult}
      * @throws IndexOutOfBoundsException if the index is out of range (<tt>index &lt; 0 || index &gt;= size()</tt>)
      */

File: src/main/java/com/lambdaworks/redis/api/async/RedisGeoAsyncCommands.java
Patch:
@@ -69,7 +69,7 @@ public interface RedisGeoAsyncCommands<K, V> {
     RedisFuture<List<GeoWithin<V>>> georadius(K key, double longitude, double latitude, double distance, GeoArgs.Unit unit, GeoArgs geoArgs);
 
     /**
-     * Perform a {@link #georadius(Object, double, double, double, Unit, GeoArgs)} query and store the results in a sorted set.
+     * Perform a {@link #georadius(Object, double, double, double, GeoArgs.Unit, GeoArgs)} query and store the results in a sorted set.
      *
      * @param key the key of the geo set
      * @param longitude the longitude coordinate according to WGS84
@@ -109,7 +109,7 @@ public interface RedisGeoAsyncCommands<K, V> {
     RedisFuture<List<GeoWithin<V>>> georadiusbymember(K key, V member, double distance, GeoArgs.Unit unit, GeoArgs geoArgs);
 
     /**
-     * Perform a {@link #georadiusbymember(Object, Object, double, Unit, GeoArgs)} query and store the results in a sorted set.
+     * Perform a {@link #georadiusbymember(Object, Object, double, GeoArgs.Unit, GeoArgs)} query and store the results in a sorted set.
      *
      * @param key the key of the geo set
      * @param member reference member

File: src/main/java/com/lambdaworks/redis/api/reactive/RedisGeoReactiveCommands.java
Patch:
@@ -71,7 +71,7 @@ public interface RedisGeoReactiveCommands<K, V> {
     Flux<GeoWithin<V>> georadius(K key, double longitude, double latitude, double distance, GeoArgs.Unit unit, GeoArgs geoArgs);
 
     /**
-     * Perform a {@link #georadius(Object, double, double, double, Unit, GeoArgs)} query and store the results in a sorted set.
+     * Perform a {@link #georadius(Object, double, double, double, GeoArgs.Unit, GeoArgs)} query and store the results in a sorted set.
      *
      * @param key the key of the geo set
      * @param longitude the longitude coordinate according to WGS84
@@ -111,7 +111,7 @@ public interface RedisGeoReactiveCommands<K, V> {
     Flux<GeoWithin<V>> georadiusbymember(K key, V member, double distance, GeoArgs.Unit unit, GeoArgs geoArgs);
 
     /**
-     * Perform a {@link #georadiusbymember(Object, Object, double, Unit, GeoArgs)} query and store the results in a sorted set.
+     * Perform a {@link #georadiusbymember(Object, Object, double, GeoArgs.Unit, GeoArgs)} query and store the results in a sorted set.
      *
      * @param key the key of the geo set
      * @param member reference member

File: src/main/java/com/lambdaworks/redis/api/reactive/RedisServerReactiveCommands.java
Patch:
@@ -268,6 +268,7 @@ public interface RedisServerReactiveCommands<K, V> {
      * Synchronously save the dataset to disk and then shut down the server.
      * 
      * @param save {@literal true} force save operation
+     * @return nothing
      */
     Mono<Void> shutdown(boolean save);
 

File: src/main/java/com/lambdaworks/redis/api/reactive/package-info.java
Patch:
@@ -1,4 +1,4 @@
 /**
- * Standalone Redis API for reactive commands.
+ * Standalone Redis API for commands executed in a reactive manner.
  */
 package com.lambdaworks.redis.api.reactive;
\ No newline at end of file

File: src/main/java/com/lambdaworks/redis/api/sync/RedisGeoCommands.java
Patch:
@@ -109,7 +109,7 @@ public interface RedisGeoCommands<K, V> {
     List<GeoWithin<V>> georadiusbymember(K key, V member, double distance, GeoArgs.Unit unit, GeoArgs geoArgs);
 
     /**
-     * Perform a {@link #georadiusbymember(Object, Object, double, Unit, GeoArgs)} query and store the results in a sorted set.
+     * Perform a {@link #georadiusbymember(Object, Object, double, GeoArgs.Unit, GeoArgs)} query and store the results in a sorted set.
      *
      * @param key the key of the geo set
      * @param member reference member

File: src/main/java/com/lambdaworks/redis/cluster/RedisClusterClient.java
Patch:
@@ -27,6 +27,7 @@
 import com.lambdaworks.redis.codec.StringCodec;
 import com.lambdaworks.redis.internal.LettuceAssert;
 import com.lambdaworks.redis.internal.LettuceLists;
+import com.lambdaworks.redis.output.KeyValueStreamingChannel;
 import com.lambdaworks.redis.output.ValueStreamingChannel;
 import com.lambdaworks.redis.protocol.DefaultEndpoint;
 import com.lambdaworks.redis.protocol.CommandHandler;
@@ -53,7 +54,7 @@
  * </p>
  * <p>
  * The Redis cluster client provides a {@link RedisAdvancedClusterCommands sync}, {@link RedisAdvancedClusterAsyncCommands
- * async} and {@link com.lambdaworks.redis.cluster.api.rx.RedisAdvancedClusterReactiveCommands reactive} API.
+ * async} and {@link com.lambdaworks.redis.cluster.api.reactive.RedisAdvancedClusterReactiveCommands reactive} API.
  * </p>
  *
  * <p>
@@ -70,7 +71,7 @@
  * <li>{@link RedisAdvancedClusterAsyncCommands#del(Object[]) DEL}</li>
  * <li>{@link RedisAdvancedClusterAsyncCommands#unlink(Object[]) UNLINK}</li>
  * <li>{@link RedisAdvancedClusterAsyncCommands#mget(Object[]) MGET}</li>
- * <li>{@link RedisAdvancedClusterAsyncCommands#mget(ValueStreamingChannel, Object[]) MGET with streaming}</li>
+ * <li>{@link RedisAdvancedClusterAsyncCommands#mget(KeyValueStreamingChannel, Object[])} ) MGET with streaming}</li>
  * <li>{@link RedisAdvancedClusterAsyncCommands#mset(Map) MSET}</li>
  * <li>{@link RedisAdvancedClusterAsyncCommands#msetnx(Map) MSETNX}</li>
  * </ul>

File: src/main/java/com/lambdaworks/redis/cluster/api/async/BaseNodeSelectionAsyncCommands.java
Patch:
@@ -125,11 +125,11 @@ public interface BaseNodeSelectionAsyncCommands<K, V> {
      *
      * @param autoFlush state of autoFlush.
      */
-    AsyncExecutions<Void> setAutoFlushCommands(boolean autoFlush);
+    void setAutoFlushCommands(boolean autoFlush);
 
     /**
      * Flush pending commands. This commands forces a flush on the channel and can be used to buffer ("pipeline") commands to
      * achieve batching. No-op if channel is not connected.
      */
-    AsyncExecutions<Void> flushCommands();
+    void flushCommands();
 }

File: src/main/java/com/lambdaworks/redis/cluster/api/async/NodeSelectionGeoAsyncCommands.java
Patch:
@@ -69,7 +69,7 @@ public interface NodeSelectionGeoAsyncCommands<K, V> {
     AsyncExecutions<List<GeoWithin<V>>> georadius(K key, double longitude, double latitude, double distance, GeoArgs.Unit unit, GeoArgs geoArgs);
 
     /**
-     * Perform a {@link #georadius(Object, double, double, double, Unit, GeoArgs)} query and store the results in a sorted set.
+     * Perform a {@link #georadius(Object, double, double, double, GeoArgs.Unit, GeoArgs)} query and store the results in a sorted set.
      *
      * @param key the key of the geo set
      * @param longitude the longitude coordinate according to WGS84
@@ -109,7 +109,7 @@ public interface NodeSelectionGeoAsyncCommands<K, V> {
     AsyncExecutions<List<GeoWithin<V>>> georadiusbymember(K key, V member, double distance, GeoArgs.Unit unit, GeoArgs geoArgs);
 
     /**
-     * Perform a {@link #georadiusbymember(Object, Object, double, Unit, GeoArgs)} query and store the results in a sorted set.
+     * Perform a {@link #georadiusbymember(Object, Object, double, GeoArgs.Unit, GeoArgs)} query and store the results in a sorted set.
      *
      * @param key the key of the geo set
      * @param member reference member

File: src/main/java/com/lambdaworks/redis/cluster/api/reactive/package-info.java
Patch:
@@ -1,4 +1,4 @@
 /**
- * Redis Cluster API for reactive commands.
+ * Redis Cluster API for commands executed in a reactive manner.
  */
 package com.lambdaworks.redis.cluster.api.reactive;
\ No newline at end of file

File: src/main/java/com/lambdaworks/redis/cluster/api/sync/BaseNodeSelectionCommands.java
Patch:
@@ -103,11 +103,12 @@ public interface BaseNodeSelectionCommands<K, V> {
      *
      * @param autoFlush state of autoFlush.
      */
-    Executions<Void> setAutoFlushCommands(boolean autoFlush);
+    void setAutoFlushCommands(boolean autoFlush);
 
     /**
      * Flush pending commands. This commands forces a flush on the channel and can be used to buffer ("pipeline") commands to
      * achieve batching. No-op if channel is not connected.
+     *
      */
-    Executions<Void> flushCommands();
+    void flushCommands();
 }

File: src/main/java/com/lambdaworks/redis/cluster/api/sync/NodeSelectionGeoCommands.java
Patch:
@@ -69,7 +69,7 @@ public interface NodeSelectionGeoCommands<K, V> {
     Executions<List<GeoWithin<V>>> georadius(K key, double longitude, double latitude, double distance, GeoArgs.Unit unit, GeoArgs geoArgs);
 
     /**
-     * Perform a {@link #georadius(Object, double, double, double, Unit, GeoArgs)} query and store the results in a sorted set.
+     * Perform a {@link #georadius(Object, double, double, double, GeoArgs.Unit, GeoArgs)} query and store the results in a sorted set.
      *
      * @param key the key of the geo set
      * @param longitude the longitude coordinate according to WGS84
@@ -109,7 +109,7 @@ public interface NodeSelectionGeoCommands<K, V> {
     Executions<List<GeoWithin<V>>> georadiusbymember(K key, V member, double distance, GeoArgs.Unit unit, GeoArgs geoArgs);
 
     /**
-     * Perform a {@link #georadiusbymember(Object, Object, double, Unit, GeoArgs)} query and store the results in a sorted set.
+     * Perform a {@link #georadiusbymember(Object, Object, double, GeoArgs.Unit, GeoArgs)} query and store the results in a sorted set.
      *
      * @param key the key of the geo set
      * @param member reference member

File: src/main/java/com/lambdaworks/redis/internal/LettuceAssert.java
Patch:
@@ -122,6 +122,7 @@ public static void isTrue(boolean value, String message) {
      * calling method.
      *
      * @param condition a boolean expression
+     * @param message the exception message to use if the assertion fails
      * @throws IllegalStateException if {@code expression} is false
      */
     public static void assertState(boolean condition, String message) {

File: src/main/java/com/lambdaworks/redis/pubsub/StatefulRedisPubSubConnectionImpl.java
Patch:
@@ -38,7 +38,8 @@ public class StatefulRedisPubSubConnectionImpl<K, V> extends StatefulRedisConnec
     /**
      * Initialize a new connection.
      *
-     * @param writer the channel writer
+     * @param endpoint the {@link PubSubEndpoint}
+     * @param writer the writer used to write commands
      * @param codec Codec used to encode/decode keys and values.
      * @param timeout Maximum time to wait for a response.
      * @param unit Unit of time for the timeout.

File: src/main/java/com/lambdaworks/redis/pubsub/api/reactive/package-info.java
Patch:
@@ -1,4 +1,4 @@
 /**
- * Pub/Sub Redis API for reactive commands.
+ * Pub/Sub Redis API for commands executed in a reactive manner.
  */
 package com.lambdaworks.redis.pubsub.api.reactive;
\ No newline at end of file

File: src/test/java/com/lambdaworks/redis/cluster/commands/reactive/ListClusterReactiveCommandTest.java
Patch:
@@ -20,7 +20,7 @@
 /**
  * @author Mark Paluch
  */
-public class ListClusterRxCommandTest extends ListCommandTest {
+public class ListClusterReactiveCommandTest extends ListCommandTest {
     private static RedisClusterClient redisClusterClient;
     private StatefulRedisClusterConnection<String, String> clusterConnection;
 

File: src/test/java/com/lambdaworks/redis/sentinel/reactive/SentinelReactiveCommandTest.java
Patch:
@@ -12,7 +12,7 @@
 /**
  * @author Mark Paluch
  */
-public class SentinelRxCommandTest extends SentinelCommandTest {
+public class SentinelReactiveCommandTest extends SentinelCommandTest {
 
     @Override
     public void openConnection() throws Exception {

File: src/main/java/com/lambdaworks/redis/RedisCommandBuilder.java
Patch:
@@ -1402,8 +1402,8 @@ public Command<K, V, Long> zadd(K key, ZAddArgs zAddArgs, Object... scoresAndVal
             for (Object o : scoresAndValues) {
                 ScoredValue<V> scoredValue = (ScoredValue<V>) o;
 
-                args.add(scoredValue.score);
-                args.addValue(scoredValue.value);
+                args.add(scoredValue.getScore());
+                args.addValue(scoredValue.getValue());
             }
 
         } else {

File: src/main/java/com/lambdaworks/redis/output/KeyValueOutput.java
Patch:
@@ -29,7 +29,7 @@ public void set(ByteBuffer bytes) {
                 key = codec.decodeKey(bytes);
             } else {
                 V value = codec.decodeValue(bytes);
-                output = new KeyValue<K, V>(key, value);
+                output = KeyValue.fromNullable(key, value);
             }
         }
     }

File: src/main/java/com/lambdaworks/redis/output/ScoredValueListOutput.java
Patch:
@@ -36,7 +36,7 @@ public void set(ByteBuffer bytes) {
         }
 
         double score = Double.parseDouble(decodeAscii(bytes));
-        subscriber.onNext(new ScoredValue<>(score, value));
+        subscriber.onNext(ScoredValue.fromNullable(score, value));
         value = null;
     }
 

File: src/main/java/com/lambdaworks/redis/output/ScoredValueScanOutput.java
Patch:
@@ -30,7 +30,7 @@ protected void setOutput(ByteBuffer bytes) {
         }
 
         double score = Double.parseDouble(decodeAscii(bytes));
-        output.getValues().add(new ScoredValue<V>(score, value));
+        output.getValues().add(ScoredValue.fromNullable(score, value));
         value = null;
     }
 

File: src/main/java/com/lambdaworks/redis/output/ScoredValueScanStreamingOutput.java
Patch:
@@ -31,7 +31,7 @@ protected void setOutput(ByteBuffer bytes) {
         }
 
         double score = Double.parseDouble(decodeAscii(bytes));
-        channel.onValue(new ScoredValue<V>(score, value));
+        channel.onValue(ScoredValue.fromNullable(score, value));
         value = null;
         output.setCount(output.getCount() + 1);
     }

File: src/main/java/com/lambdaworks/redis/output/ScoredValueStreamingOutput.java
Patch:
@@ -30,7 +30,7 @@ public void set(ByteBuffer bytes) {
         }
 
         double score = Double.parseDouble(decodeAscii(bytes));
-        channel.onValue(new ScoredValue<V>(score, value));
+        channel.onValue(ScoredValue.fromNullable(score, value));
         value = null;
         output = output.longValue() + 1;
     }

File: src/test/java/com/lambdaworks/redis/AbstractTest.java
Patch:
@@ -40,11 +40,11 @@ public static List<ScoredValue<String>> svlist(ScoredValue<String>... args) {
     }
 
     public static KeyValue<String, String> kv(String key, String value) {
-        return new KeyValue<>(key, value);
+        return KeyValue.fromNullable(key, value);
     }
 
     public static ScoredValue<String> sv(double score, String value) {
-        return new ScoredValue<String>(score, value);
+        return ScoredValue.fromNullable(score, value);
     }
 
     public static Set<String> set(String... args) {

File: src/test/java/com/lambdaworks/redis/ListStreamingAdapter.java
Patch:
@@ -13,7 +13,7 @@
  * ValueStreamingChannels.
  * 
  * @author Mark Paluch
- * @param <T> Valu-Type.
+ * @param <T> Value-Type.
  * @since 3.0
  */
 public class ListStreamingAdapter<T> implements KeyStreamingChannel<T>, ValueStreamingChannel<T>,
@@ -37,6 +37,6 @@ public List<T> getList() {
 
     @Override
     public void onValue(ScoredValue<T> value) {
-        list.add(value.value);
+        list.add(value.getValue());
     }
 }

File: src/test/java/com/lambdaworks/redis/commands/GeoCommandTest.java
Patch:
@@ -275,7 +275,7 @@ public void georadiusStoreWithCountAndSort() throws Exception {
 
         List<ScoredValue<String>> results = redis.zrangeWithScores(resultKey, 0, -1);
         assertThat(results).hasSize(1);
-        assertThat(results.get(0).score).isGreaterThan(99999);
+        assertThat(results.get(0).getScore()).isGreaterThan(99999);
     }
 
     @Test
@@ -305,7 +305,7 @@ public void georadiusStoreDistWithCountAndSort() throws Exception {
         List<ScoredValue<String>> dist = redis.zrangeWithScores(resultKey, 0, -1);
         assertThat(dist).hasSize(1);
 
-        assertThat(dist.get(0).score).isBetween(2d, 3d);
+        assertThat(dist.get(0).getScore()).isBetween(2d, 3d);
     }
 
     @Test(expected = IllegalArgumentException.class)
@@ -343,7 +343,7 @@ public void georadiusbymemberStoreDistWithCountAndSort() throws Exception {
         List<ScoredValue<String>> dist = redis.zrangeWithScores(resultKey, 0, -1);
         assertThat(dist).hasSize(1);
 
-        assertThat(dist.get(0).score).isBetween(2d, 3d);
+        assertThat(dist.get(0).getScore()).isBetween(2d, 3d);
     }
 
     @Test

File: src/test/java/com/lambdaworks/redis/output/ScoredValueListOutputTest.java
Patch:
@@ -33,6 +33,6 @@ public void commandOutputCorrectlyDecoded() throws Exception {
         sut.set(ByteBuffer.wrap("4.567".getBytes()));
         sut.multi(-1);
 
-        assertThat(sut.get()).contains(new ScoredValue<>(4.567, "key"));
+        assertThat(sut.get()).contains(ScoredValue.fromNullable(4.567, "key"));
     }
 }
\ No newline at end of file

File: src/main/java/com/lambdaworks/redis/api/rx/RedisReactiveCommands.java
Patch:
@@ -6,6 +6,7 @@
 
 import com.lambdaworks.redis.api.StatefulRedisConnection;
 import com.lambdaworks.redis.cluster.api.rx.RedisClusterReactiveCommands;
+import rx.Single;
 
 /**
  * A complete reactive and thread-safe Redis API with 400+ Methods.
@@ -35,15 +36,15 @@ public interface RedisReactiveCommands<K, V> extends RedisHashReactiveCommands<K
      * @param password the password
      * @return String simple-string-reply
      */
-    Observable<String> auth(String password);
+    Single<String> auth(String password);
 
     /**
      * Change the selected database for the current connection.
      * 
      * @param db the database number
      * @return String simple-string-reply
      */
-    Observable<String> select(int db);
+    Single<String> select(int db);
 
     /**
      * @return the underlying connection.

File: src/main/java/com/lambdaworks/redis/protocol/CommandHandler.java
Patch:
@@ -210,7 +210,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Interrup
             try {
                 command.complete();
             } catch (Exception e) {
-                logger.warn("{} Unexpected exception during command completion: {}", logPrefix, e.toString(), e);
+                logger.warn("{} Unexpected exception during request: {}", logPrefix, e.toString(), e);
             }
 
             if (buffer.refCnt() != 0) {

File: src/test/java/com/lambdaworks/apigenerator/CreateAsyncNodeSelectionClusterApi.java
Patch:
@@ -53,7 +53,6 @@ public CreateAsyncNodeSelectionClusterApi(String templateName) {
         File templateFile = new File(Constants.TEMPLATES, "com/lambdaworks/redis/api/" + templateName + ".java");
         String targetPackage = "com.lambdaworks.redis.cluster.api.async";
 
-        // todo: remove AutoCloseable from BaseNodeSelectionAsyncCommands
         factory = new CompilationUnitFactory(templateFile, Constants.SOURCES, targetPackage, targetName, commentMutator(),
                 methodTypeMutator(), methodFilter(), importSupplier(), null, null);
     }

File: src/test/java/com/lambdaworks/redis/cluster/commands/CustomClusterCommandTest.java
Patch:
@@ -20,6 +20,7 @@
 import com.lambdaworks.redis.protocol.*;
 
 import rx.Observable;
+import rx.Single;
 
 /**
  * @author Mark Paluch
@@ -103,7 +104,7 @@ public void standaloneReactivePing() throws Exception {
         ReactiveCommandDispatcher<String, String, String> dispatcher = new ReactiveCommandDispatcher<>(command,
                 redisClusterConnection, false);
 
-        String result = Observable.create(dispatcher).toBlocking().first();
+        String result = Single.create(dispatcher.getSingleSubscriber()).toBlocking().value();
 
         assertThat(result).isEqualTo("PONG");
     }

File: src/test/java/com/lambdaworks/redis/commands/CustomCommandTest.java
Patch:
@@ -92,7 +92,7 @@ public void standaloneReactivePing() throws Exception {
         ReactiveCommandDispatcher<String, String, String> dispatcher = new ReactiveCommandDispatcher<>(command,
                 getStandaloneConnection(), false);
 
-        String result = Observable.create(dispatcher).toBlocking().first();
+        String result = Observable.create(dispatcher.getObservableSubscriber()).toBlocking().first();
 
         assertThat(result).isEqualTo("PONG");
     }

File: src/test/java/com/lambdaworks/redis/event/DefaultEventPublisherOptionsTest.java
Patch:
@@ -32,7 +32,7 @@ public void testDisabled() throws Exception {
     @Test
     public void testBuilder() throws Exception {
 
-        DefaultEventPublisherOptions sut = new DefaultEventPublisherOptions.Builder().eventEmitInterval(1, TimeUnit.SECONDS)
+        DefaultEventPublisherOptions sut = DefaultEventPublisherOptions.builder().eventEmitInterval(1, TimeUnit.SECONDS)
                 .build();
 
         assertThat(sut.eventEmitInterval()).isEqualTo(1);

File: src/main/java/com/lambdaworks/redis/cluster/RedisClusterClient.java
Patch:
@@ -25,7 +25,6 @@
 import com.lambdaworks.redis.cluster.topology.TopologyComparators;
 import com.lambdaworks.redis.codec.RedisCodec;
 import com.lambdaworks.redis.codec.StringCodec;
-import com.lambdaworks.redis.codec.Utf8StringCodec;
 import com.lambdaworks.redis.internal.LettuceAssert;
 import com.lambdaworks.redis.internal.LettuceFactories;
 import com.lambdaworks.redis.internal.LettuceLists;
@@ -503,7 +502,7 @@ <K, V> StatefulRedisClusterConnectionImpl<K, V> connectClusterImpl(RedisCodec<K,
         CommandHandler<K, V> handler = new CommandHandler<K, V>(clientOptions, clientResources, queue);
 
         ClusterDistributionChannelWriter<K, V> clusterWriter = new ClusterDistributionChannelWriter<K, V>(clientOptions,
-                handler, clusterTopologyRefreshScheduler);
+                handler, clusterTopologyRefreshScheduler, getResources().eventExecutorGroup());
         PooledClusterConnectionProvider<K, V> pooledClusterConnectionProvider = new PooledClusterConnectionProvider<K, V>(this,
                 clusterWriter, codec);
 
@@ -566,7 +565,7 @@ <K, V> StatefulRedisPubSubConnectionImpl<K, V> connectClusterPubSubImpl(RedisCod
         PubSubCommandHandler<K, V> handler = new PubSubCommandHandler<K, V>(clientOptions, clientResources, queue, codec);
 
         ClusterDistributionChannelWriter<K, V> clusterWriter = new ClusterDistributionChannelWriter<K, V>(clientOptions,
-                handler, clusterTopologyRefreshScheduler);
+                handler, clusterTopologyRefreshScheduler, getResources().eventExecutorGroup());
         PooledClusterConnectionProvider<K, V> pooledClusterConnectionProvider = new PooledClusterConnectionProvider<K, V>(this,
                 clusterWriter, codec);
 

File: src/main/java/com/lambdaworks/redis/masterslave/MasterSlaveTopologyProvider.java
Patch:
@@ -25,11 +25,11 @@
 public class MasterSlaveTopologyProvider implements TopologyProvider {
 
     public final static Pattern ROLE_PATTERN = Pattern.compile("^role\\:([a-z]+)$", Pattern.MULTILINE);
-    public final static Pattern SLAVE_PATTERN = Pattern.compile("^slave(\\d+)\\:([a-zA-Z\\,\\=\\d\\.]+)$", Pattern.MULTILINE);
-    public final static Pattern MASTER_HOST_PATTERN = Pattern.compile("^master_host\\:([a-zA-Z\\,\\=\\d\\.]+)$",
+    public final static Pattern SLAVE_PATTERN = Pattern.compile("^slave(\\d+)\\:([a-zA-Z\\,\\=\\d\\.\\:]+)$", Pattern.MULTILINE);
+    public final static Pattern MASTER_HOST_PATTERN = Pattern.compile("^master_host\\:([a-zA-Z\\,\\=\\d\\.\\:]+)$",
             Pattern.MULTILINE);
     public final static Pattern MASTER_PORT_PATTERN = Pattern.compile("^master_port\\:(\\d+)$", Pattern.MULTILINE);
-    public final static Pattern IP_PATTERN = Pattern.compile("ip\\=([a-z\\d\\.]+)");
+    public final static Pattern IP_PATTERN = Pattern.compile("ip\\=([a-zA-Z\\d\\.\\:]+)");
     public final static Pattern PORT_PATTERN = Pattern.compile("port\\=([\\d]+)");
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(MasterSlaveTopologyProvider.class);

File: src/main/java/com/lambdaworks/redis/AbstractRedisAsyncCommands.java
Patch:
@@ -982,7 +982,7 @@ public RedisFuture<V> srandmember(K key) {
     }
 
     @Override
-    public RedisFuture<Set<V>> srandmember(K key, long count) {
+    public RedisFuture<List<V>> srandmember(K key, long count) {
         return dispatch(commandBuilder.srandmember(key, count));
     }
 

File: src/main/java/com/lambdaworks/redis/RedisCommandBuilder.java
Patch:
@@ -1262,11 +1262,11 @@ public Command<K, V, V> srandmember(K key) {
         return createCommand(SRANDMEMBER, new ValueOutput<K, V>(codec), key);
     }
 
-    public Command<K, V, Set<V>> srandmember(K key, long count) {
+    public Command<K, V, List<V>> srandmember(K key, long count) {
         notNullKey(key);
 
         CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).add(count);
-        return createCommand(SRANDMEMBER, new ValueSetOutput<K, V>(codec), args);
+        return createCommand(SRANDMEMBER, new ValueListOutput<K, V>(codec), args);
     }
 
     public Command<K, V, Long> srandmember(ValueStreamingChannel<V> channel, K key, long count) {

File: src/main/java/com/lambdaworks/redis/RedisSetsAsyncConnection.java
Patch:
@@ -1,5 +1,6 @@
 package com.lambdaworks.redis;
 
+import java.util.List;
 import java.util.Set;
 
 import com.lambdaworks.redis.api.async.RedisSetAsyncCommands;
@@ -165,7 +166,7 @@ public interface RedisSetsAsyncConnection<K, V> {
      * @return RedisFuture&lt;Set&lt;V&gt;&gt; bulk-string-reply without the additional {@code count} argument the command
      *         returns a Bulk Reply with the randomly selected element, or {@literal null} when {@code key} does not exist.
      */
-    RedisFuture<Set<V>> srandmember(K key, long count);
+    RedisFuture<List<V>> srandmember(K key, long count);
 
     /**
      * Get one or multiple random members from a set.

File: src/main/java/com/lambdaworks/redis/RedisSetsConnection.java
Patch:
@@ -1,5 +1,6 @@
 package com.lambdaworks.redis;
 
+import java.util.List;
 import java.util.Set;
 
 import com.lambdaworks.redis.api.sync.RedisSetCommands;
@@ -165,7 +166,7 @@ public interface RedisSetsConnection<K, V> {
      * @return Set&lt;V&gt; bulk-string-reply without the additional {@code count} argument the command returns a Bulk Reply
      *         with the randomly selected element, or {@literal null} when {@code key} does not exist.
      */
-    Set<V> srandmember(K key, long count);
+    List<V> srandmember(K key, long count);
 
     /**
      * Get one or multiple random members from a set.

File: src/main/java/com/lambdaworks/redis/api/async/RedisSetAsyncCommands.java
Patch:
@@ -1,5 +1,6 @@
 package com.lambdaworks.redis.api.async;
 
+import java.util.List;
 import java.util.Set;
 import com.lambdaworks.redis.ScanArgs;
 import com.lambdaworks.redis.ScanCursor;
@@ -167,7 +168,7 @@ public interface RedisSetAsyncCommands<K, V> {
      * @return Set&lt;V&gt; bulk-string-reply without the additional {@code count} argument the command returns a Bulk Reply
      *         with the randomly selected element, or {@literal null} when {@code key} does not exist.
      */
-    RedisFuture<Set<V>> srandmember(K key, long count);
+    RedisFuture<List<V>> srandmember(K key, long count);
 
     /**
      * Get one or multiple random members from a set.

File: src/main/java/com/lambdaworks/redis/api/sync/RedisSetCommands.java
Patch:
@@ -1,5 +1,6 @@
 package com.lambdaworks.redis.api.sync;
 
+import java.util.List;
 import java.util.Set;
 import com.lambdaworks.redis.ScanArgs;
 import com.lambdaworks.redis.ScanCursor;
@@ -166,7 +167,7 @@ public interface RedisSetCommands<K, V> {
      * @return Set&lt;V&gt; bulk-string-reply without the additional {@code count} argument the command returns a Bulk Reply
      *         with the randomly selected element, or {@literal null} when {@code key} does not exist.
      */
-    Set<V> srandmember(K key, long count);
+    List<V> srandmember(K key, long count);
 
     /**
      * Get one or multiple random members from a set.

File: src/main/java/com/lambdaworks/redis/cluster/api/async/NodeSelectionSetAsyncCommands.java
Patch:
@@ -1,5 +1,6 @@
 package com.lambdaworks.redis.cluster.api.async;
 
+import java.util.List;
 import java.util.Set;
 import com.lambdaworks.redis.ScanArgs;
 import com.lambdaworks.redis.ScanCursor;
@@ -167,7 +168,7 @@ public interface NodeSelectionSetAsyncCommands<K, V> {
      * @return Set&lt;V&gt; bulk-string-reply without the additional {@code count} argument the command returns a Bulk Reply
      *         with the randomly selected element, or {@literal null} when {@code key} does not exist.
      */
-    AsyncExecutions<Set<V>> srandmember(K key, long count);
+    AsyncExecutions<List<V>> srandmember(K key, long count);
 
     /**
      * Get one or multiple random members from a set.

File: src/main/java/com/lambdaworks/redis/cluster/api/sync/NodeSelectionSetCommands.java
Patch:
@@ -1,5 +1,6 @@
 package com.lambdaworks.redis.cluster.api.sync;
 
+import java.util.List;
 import java.util.Set;
 import com.lambdaworks.redis.ScanArgs;
 import com.lambdaworks.redis.ScanCursor;
@@ -166,7 +167,7 @@ public interface NodeSelectionSetCommands<K, V> {
      * @return Set&lt;V&gt; bulk-string-reply without the additional {@code count} argument the command returns a Bulk Reply
      *         with the randomly selected element, or {@literal null} when {@code key} does not exist.
      */
-    Executions<Set<V>> srandmember(K key, long count);
+    Executions<List<V>> srandmember(K key, long count);
 
     /**
      * Get one or multiple random members from a set.

File: src/main/templates/com/lambdaworks/redis/api/RedisSetCommands.java
Patch:
@@ -166,7 +166,7 @@ public interface RedisSetCommands<K, V> {
      * @return Set&lt;V&gt; bulk-string-reply without the additional {@code count} argument the command returns a Bulk Reply
      *         with the randomly selected element, or {@literal null} when {@code key} does not exist.
      */
-    Set<V> srandmember(K key, long count);
+    List<V> srandmember(K key, long count);
 
     /**
      * Get one or multiple random members from a set.

File: src/test/java/com/lambdaworks/redis/protocol/CommandInternalsTest.java
Patch:
@@ -115,7 +115,7 @@ public String get() throws RedisException {
     public void nestedMultiError() throws Exception {
         NestedMultiOutput<String, String> output = new NestedMultiOutput<String, String>(codec);
         output.setError(buffer("Oops!"));
-        assertThat(output.get().get(0) instanceof RedisException).isTrue();
+        assertThat(output.getError()).isNotNull();
     }
 
     @Test

File: src/main/java/com/lambdaworks/redis/cluster/ClusterDistributionChannelWriter.java
Patch:
@@ -70,11 +70,13 @@ public <T, C extends RedisCommand<K, V, T>> C write(C command) {
             ClusterCommand<K, V, T> clusterCommand = (ClusterCommand<K, V, T>) commandToSend;
             if (clusterCommand.isMoved() || clusterCommand.isAsk()) {
                 HostAndPort target;
+                boolean asking = false;
                 if (clusterCommand.isMoved()) {
                     target = getMoveTarget(clusterCommand.getError());
                     clusterEventListener.onMovedRedirection();
                 } else {
                     target = getAskTarget(clusterCommand.getError());
+                    asking = true;
                     clusterEventListener.onAskRedirection();
                 }
 
@@ -83,7 +85,7 @@ public <T, C extends RedisCommand<K, V, T>> C write(C command) {
                         .getConnection(ClusterConnectionProvider.Intent.WRITE, target.getHostText(), target.getPort());
                 channelWriter = connection.getChannelWriter();
 
-                if (clusterCommand.isAsk()) {
+                if (asking) {
                     // set asking bit
                     StatefulRedisConnection<K, V> statefulRedisConnection = (StatefulRedisConnection<K, V>) connection;
                     statefulRedisConnection.async().asking();

File: src/main/java/com/lambdaworks/redis/resource/DefaultClientResources.java
Patch:
@@ -57,8 +57,8 @@ public class DefaultClientResources implements ClientResources {
     public static final Delay DEFAULT_RECONNECT_DELAY = Delay.exponential();
 
     static {
-        int threads = Math.max(1,
-                SystemPropertyUtil.getInt("io.netty.eventLoopThreads", Runtime.getRuntime().availableProcessors()));
+        int threads = Math.max(1, SystemPropertyUtil.getInt("io.netty.eventLoopThreads",
+                Math.max(MIN_IO_THREADS, Runtime.getRuntime().availableProcessors())));
 
         DEFAULT_IO_THREADS = threads;
         DEFAULT_COMPUTATION_THREADS = threads;

File: src/test/java/com/lambdaworks/redis/commands/StringCommandTest.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.List;
 import java.util.Map;
 
+import com.lambdaworks.redis.codec.ByteArrayCodec;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;

File: src/test/java/com/lambdaworks/redis/reliability/AtMostOnceTest.java
Patch:
@@ -152,6 +152,7 @@ public void encode(ByteBuf buf) {
         assertThat(command.isCancelled()).isFalse();
         assertThat(command.isDone()).isTrue();
         assertThat(getException(command)).isInstanceOf(EncoderException.class);
+        getQueue(getRedisChannelHandler(connection)).clear();
 
         assertThat(connection.get(key)).isEqualTo("2");
 

File: src/test/java/com/lambdaworks/redis/protocol/CommandArgsTest.java
Patch:
@@ -121,7 +121,7 @@ public void addValueUsingDirectByteCodec() throws Exception {
         args.encode(buffer);
 
         ByteBuf expected = Unpooled.buffer();
-        expected.writeBytes(("one").getBytes());
+        expected.writeBytes(("$3\r\n" + "one\r\n").getBytes());
 
         assertThat(buffer.toString(LettuceCharsets.ASCII)).isEqualTo(expected.toString(LettuceCharsets.ASCII));
     }
@@ -136,7 +136,7 @@ public void addKeyUsingDirectByteCodec() throws Exception {
         args.encode(buffer);
 
         ByteBuf expected = Unpooled.buffer();
-        expected.writeBytes(("one").getBytes());
+        expected.writeBytes(("$3\r\n" + "one\r\n").getBytes());
 
         assertThat(buffer.toString(LettuceCharsets.ASCII)).isEqualTo(expected.toString(LettuceCharsets.ASCII));
     }

File: src/main/java/com/lambdaworks/redis/AbstractRedisClient.java
Patch:
@@ -372,7 +372,7 @@ public ClientOptions getOptions() {
      * @param clientOptions client options for the client and connections that are created after setting the options
      */
     protected void setOptions(ClientOptions clientOptions) {
-        LettuceAssert.notNull(clientOptions, "clientOptions must not be null");
+        LettuceAssert.notNull(clientOptions, "ClientOptions must not be null");
         this.clientOptions = clientOptions;
     }
 }

File: src/main/java/com/lambdaworks/redis/GeoArgs.java
Patch:
@@ -54,7 +54,7 @@ public GeoArgs withHash() {
      * @return {@code this}
      */
     public GeoArgs withCount(long count) {
-        LettuceAssert.isTrue(count > 0, "count must be greater 0");
+        LettuceAssert.isTrue(count > 0, "Count must be greater 0");
         this.count = count;
         return this;
     }
@@ -108,7 +108,7 @@ public GeoArgs desc() {
      * @return {@code this}
      */
     public GeoArgs sort(Sort sort) {
-        LettuceAssert.notNull(sort, "sort must not be null");
+        LettuceAssert.notNull(sort, "Sort must not be null");
 
         this.sort = sort;
         return this;
@@ -142,7 +142,6 @@ public enum Unit {
          * meter.
          */
         m,
-
         /**
          * kilometer.
          */

File: src/main/java/com/lambdaworks/redis/MigrateArgs.java
Patch:
@@ -62,21 +62,21 @@ public MigrateArgs<K> replace() {
     }
 
     public MigrateArgs<K> key(K key) {
-        LettuceAssert.notNull(key, "key must not be null");
+        LettuceAssert.notNull(key, "Key must not be null");
         this.keys.add(key);
         return this;
     }
 
     public MigrateArgs<K> keys(K... keys) {
-        LettuceAssert.notEmpty(keys, "keys must not be empty");
+        LettuceAssert.notEmpty(keys, "Keys must not be empty");
         for (K key : keys) {
             this.keys.add(key);
         }
         return this;
     }
 
     public MigrateArgs<K> keys(Iterable<K> keys) {
-        LettuceAssert.notNull(keys, "keys must not be null");
+        LettuceAssert.notNull(keys, "Keys must not be null");
         Iterator<K> iterator = keys.iterator();
         while (iterator.hasNext()) {
             this.keys.add(iterator.next());

File: src/main/java/com/lambdaworks/redis/ReadFrom.java
Patch:
@@ -49,7 +49,7 @@ public abstract class ReadFrom {
      */
     public static ReadFrom valueOf(String name) {
         if (LettuceStrings.isEmpty(name)) {
-            throw new IllegalArgumentException("name must not be empty");
+            throw new IllegalArgumentException("Name must not be empty");
         }
 
         if (name.equalsIgnoreCase("master")) {

File: src/main/java/com/lambdaworks/redis/RedisChannelHandler.java
Patch:
@@ -200,7 +200,7 @@ public ClientOptions getOptions() {
     }
 
     public void setOptions(ClientOptions clientOptions) {
-        LettuceAssert.notNull(clientOptions, "clientOptions must not be null");
+        LettuceAssert.notNull(clientOptions, "ClientOptions must not be null");
         synchronized (this) {
             this.clientOptions = clientOptions;
         }

File: src/main/java/com/lambdaworks/redis/RedisClient.java
Patch:
@@ -136,7 +136,7 @@ public static RedisClient create(RedisURI redisURI) {
      * @return a new instance of {@link RedisClient}
      */
     public static RedisClient create(String uri) {
-        LettuceAssert.notEmpty(uri, "uri must not be empty");
+        LettuceAssert.notEmpty(uri, "URI must not be empty");
         return new RedisClient(null, RedisURI.create(uri));
     }
 
@@ -165,7 +165,7 @@ public static RedisClient create(ClientResources clientResources) {
      */
     public static RedisClient create(ClientResources clientResources, String uri) {
         assertNotNull(clientResources);
-        LettuceAssert.notEmpty(uri, "uri must not be empty");
+        LettuceAssert.notEmpty(uri, "URI must not be empty");
         return create(clientResources, RedisURI.create(uri));
     }
 

File: src/main/java/com/lambdaworks/redis/RedisURI.java
Patch:
@@ -208,7 +208,7 @@ public static RedisURI create(String host, int port) {
      * @return An instance of {@link RedisURI} containing details from the URI.
      */
     public static RedisURI create(String uri) {
-        LettuceAssert.notEmpty(uri, "uri must not be empty");
+        LettuceAssert.notEmpty(uri, "URI must not be empty");
         return create(URI.create(uri));
     }
 

File: src/main/java/com/lambdaworks/redis/ScanArgs.java
Patch:
@@ -2,6 +2,7 @@
 
 import static com.lambdaworks.redis.protocol.CommandKeyword.*;
 
+import com.lambdaworks.redis.internal.LettuceAssert;
 import com.lambdaworks.redis.protocol.CommandArgs;
 
 /**
@@ -56,6 +57,7 @@ public static ScanArgs matches(String matches) {
      * @return the current instance of {@link ScanArgs}
      */
     public ScanArgs match(String match) {
+        LettuceAssert.notNull(match, "Match must not be null");
         this.match = match;
         return this;
     }

File: src/main/java/com/lambdaworks/redis/SslConnectionBuilder.java
Patch:
@@ -51,8 +51,8 @@ public SslConnectionBuilder ssl(RedisURI redisURI) {
 
     @Override
     protected List<ChannelHandler> buildHandlers() {
-        LettuceAssert.assertState(redisURI != null, "redisURI must not be null");
-        LettuceAssert.assertState(redisURI.isSsl(), "redisURI is not configured for SSL (ssl is false)");
+        LettuceAssert.assertState(redisURI != null, "RedisURI must not be null");
+        LettuceAssert.assertState(redisURI.isSsl(), "RedisURI is not configured for SSL (ssl is false)");
 
         return super.buildHandlers();
     }

File: src/main/java/com/lambdaworks/redis/cluster/NodeSelectionInvocationHandler.java
Patch:
@@ -48,8 +48,8 @@ public NodeSelectionInvocationHandler(AbstractNodeSelection<?, ?, ?, ?> selectio
 
     public NodeSelectionInvocationHandler(AbstractNodeSelection<?, ?, ?, ?> selection, boolean sync, long timeout, TimeUnit unit) {
         if (sync) {
-            LettuceAssert.isTrue(timeout > 0, "timeout must be greater 0 when using sync mode");
-            LettuceAssert.notNull(unit, "unit must not be null when using sync mode");
+            LettuceAssert.isTrue(timeout > 0, "Timeout must be greater 0 when using sync mode");
+            LettuceAssert.notNull(unit, "Unit must not be null when using sync mode");
         }
 
         this.selection = selection;

File: src/main/java/com/lambdaworks/redis/cluster/RedisClusterClient.java
Patch:
@@ -243,7 +243,7 @@ public static RedisClusterClient create(Iterable<RedisURI> redisURIs) {
      * @return a new instance of {@link RedisClusterClient}
      */
     public static RedisClusterClient create(String uri) {
-        LettuceAssert.notNull(uri, "uri must not be null");
+        LettuceAssert.notNull(uri, "URI must not be null");
         return create(RedisURI.create(uri));
     }
 
@@ -273,7 +273,7 @@ public static RedisClusterClient create(ClientResources clientResources, RedisUR
      */
     public static RedisClusterClient create(ClientResources clientResources, String uri) {
         assertNotNull(clientResources);
-        LettuceAssert.notNull(uri, "uri must not be null");
+        LettuceAssert.notNull(uri, "URI must not be null");
         return create(clientResources, RedisURI.create(uri));
     }
 

File: src/main/java/com/lambdaworks/redis/cluster/StatefulRedisClusterConnectionImpl.java
Patch:
@@ -26,6 +26,7 @@
 import com.lambdaworks.redis.cluster.models.partitions.RedisClusterNode;
 import com.lambdaworks.redis.codec.RedisCodec;
 import com.lambdaworks.redis.internal.AbstractInvocationHandler;
+import com.lambdaworks.redis.internal.LettuceAssert;
 import com.lambdaworks.redis.protocol.CompleteableCommand;
 import com.lambdaworks.redis.protocol.ConnectionWatchdog;
 import com.lambdaworks.redis.protocol.RedisCommand;
@@ -209,9 +210,7 @@ public Partitions getPartitions() {
 
     @Override
     public void setReadFrom(ReadFrom readFrom) {
-        if (readFrom == null) {
-            throw new IllegalArgumentException("readFrom must not be null");
-        }
+        LettuceAssert.notNull(readFrom, "ReadFrom must not be null");
         getClusterDistributionChannelWriter().setReadFrom(readFrom);
     }
 

File: src/main/java/com/lambdaworks/redis/cluster/models/partitions/RedisClusterNode.java
Patch:
@@ -84,7 +84,7 @@ public RedisURI getUri() {
      * @param uri the {@link RedisURI}, must not be {@literal null}
      */
     public void setUri(RedisURI uri) {
-        LettuceAssert.notNull(uri, "uri must not be null");
+        LettuceAssert.notNull(uri, "RedisURI must not be null");
         this.uri = uri;
     }
 
@@ -98,7 +98,7 @@ public String getNodeId() {
      * @param nodeId the {@code nodeId}
      */
     public void setNodeId(String nodeId) {
-        LettuceAssert.notNull(nodeId, "nodeId must not be null");
+        LettuceAssert.notNull(nodeId, "NodeId must not be null");
         this.nodeId = nodeId;
     }
 
@@ -180,7 +180,7 @@ public List<Integer> getSlots() {
      * @param slots list of slots, must not be {@literal null} but may be empty
      */
     public void setSlots(List<Integer> slots) {
-        LettuceAssert.notNull(slots, "slots must not be null");
+        LettuceAssert.notNull(slots, "Slots must not be null");
 
         this.slots = slots;
     }

File: src/main/java/com/lambdaworks/redis/event/DefaultEventPublisherOptions.java
Patch:
@@ -46,8 +46,8 @@ public Builder() {
          * @return this
          */
         public Builder eventEmitInterval(long eventEmitInterval, TimeUnit eventEmitIntervalUnit) {
-            LettuceAssert.isTrue(eventEmitInterval >= 0, "eventEmitInterval must be greater or equal to 0");
-            LettuceAssert.notNull(eventEmitIntervalUnit, "eventEmitIntervalUnit must not be null");
+            LettuceAssert.isTrue(eventEmitInterval >= 0, "EventEmitInterval must be greater or equal to 0");
+            LettuceAssert.notNull(eventEmitIntervalUnit, "EventEmitIntervalUnit must not be null");
 
             this.eventEmitInterval = eventEmitInterval;
             this.eventEmitIntervalUnit = eventEmitIntervalUnit;

File: src/main/java/com/lambdaworks/redis/event/connection/ConnectionEventSupport.java
Patch:
@@ -14,8 +14,8 @@ abstract class ConnectionEventSupport implements ConnectionEvent {
     private final SocketAddress remote;
 
     ConnectionEventSupport(SocketAddress local, SocketAddress remote) {
-        LettuceAssert.notNull(local, "local must not be null");
-        LettuceAssert.notNull(remote, "remote must not be null");
+        LettuceAssert.notNull(local, "Local must not be null");
+        LettuceAssert.notNull(remote, "Remote must not be null");
 
         this.local = local;
         this.remote = remote;

File: src/main/java/com/lambdaworks/redis/internal/HostAndPort.java
Patch:
@@ -63,7 +63,7 @@ public int getPort() {
      */
     public static HostAndPort parse(String hostPortString) {
 
-        LettuceAssert.notNull(hostPortString, "hostPortString must not be null");
+        LettuceAssert.notNull(hostPortString, "HostPortString must not be null");
         String host;
         String portString = null;
 

File: src/main/java/com/lambdaworks/redis/masterslave/MasterSlaveChannelWriter.java
Patch:
@@ -26,7 +26,7 @@ public MasterSlaveChannelWriter(MasterSlaveConnectionProvider masterSlaveConnect
     @Override
     public <T, C extends RedisCommand<K, V, T>> C write(C command) {
 
-        LettuceAssert.notNull(command, "command must not be null");
+        LettuceAssert.notNull(command, "Command must not be null");
 
         if (closed) {
             throw new RedisException("Connection is closed");

File: src/main/java/com/lambdaworks/redis/metrics/CommandLatencyId.java
Patch:
@@ -19,9 +19,9 @@ public class CommandLatencyId implements Serializable, Comparable<CommandLatency
     private final ProtocolKeyword commandType;
 
     protected CommandLatencyId(SocketAddress localAddress, SocketAddress remoteAddress, ProtocolKeyword commandType) {
-        LettuceAssert.notNull(localAddress, "localAddress must not be null");
-        LettuceAssert.notNull(remoteAddress, "remoteAddress must not be null");
-        LettuceAssert.notNull(commandType, "commandType must not be null");
+        LettuceAssert.notNull(localAddress, "LocalAddress must not be null");
+        LettuceAssert.notNull(remoteAddress, "RemoteAddress must not be null");
+        LettuceAssert.notNull(commandType, "CommandType must not be null");
 
         this.localAddress = localAddress;
         this.remoteAddress = remoteAddress;

File: src/main/java/com/lambdaworks/redis/metrics/DefaultCommandLatencyCollectorOptions.java
Patch:
@@ -100,7 +100,7 @@ public Builder disable() {
          *
          */
         public Builder targetUnit(TimeUnit targetUnit) {
-            LettuceAssert.notNull(targetUnit, "targetUnit must not be null");
+            LettuceAssert.notNull(targetUnit, "TargetUnit must not be null");
             this.targetUnit = targetUnit;
             return this;
         }
@@ -114,7 +114,7 @@ public Builder targetUnit(TimeUnit targetUnit) {
          * @return this
          */
         public Builder targetPercentiles(double[] targetPercentiles) {
-            LettuceAssert.notNull(targetPercentiles, "targetPercentiles must not be null");
+            LettuceAssert.notNull(targetPercentiles, "TargetPercentiles must not be null");
             this.targetPercentiles = targetPercentiles;
             return this;
         }

File: src/main/java/com/lambdaworks/redis/models/role/RedisMasterInstance.java
Patch:
@@ -28,7 +28,7 @@ public RedisMasterInstance() {
      * @param slaves list of slaves, must not be {@literal null} but may be empty
      */
     public RedisMasterInstance(long replicationOffset, List<ReplicationPartner> slaves) {
-        LettuceAssert.notNull(slaves, "slaves must not be null");
+        LettuceAssert.notNull(slaves, "Slaves must not be null");
         this.replicationOffset = replicationOffset;
         this.slaves = slaves;
     }
@@ -55,7 +55,7 @@ public void setReplicationOffset(long replicationOffset) {
     }
 
     public void setSlaves(List<ReplicationPartner> slaves) {
-        LettuceAssert.notNull(slaves, "slaves must not be null");
+        LettuceAssert.notNull(slaves, "Slaves must not be null");
         this.slaves = slaves;
     }
 

File: src/main/java/com/lambdaworks/redis/models/role/RedisSentinelInstance.java
Patch:
@@ -25,7 +25,7 @@ public RedisSentinelInstance() {
      * @param monitoredMasters list of monitored masters, must not be {@literal null} but may be empty
      */
     public RedisSentinelInstance(List<String> monitoredMasters) {
-        LettuceAssert.notNull(monitoredMasters, "list of monitoredMasters must not be null");
+        LettuceAssert.notNull(monitoredMasters, "List of monitoredMasters must not be null");
         this.monitoredMasters = monitoredMasters;
     }
 
@@ -47,7 +47,7 @@ public List<String> getMonitoredMasters() {
     }
 
     public void setMonitoredMasters(List<String> monitoredMasters) {
-        LettuceAssert.notNull(monitoredMasters, "list of monitoredMasters must not be null");
+        LettuceAssert.notNull(monitoredMasters, "List of monitoredMasters must not be null");
         this.monitoredMasters = monitoredMasters;
     }
 

File: src/main/java/com/lambdaworks/redis/models/role/ReplicationPartner.java
Patch:
@@ -27,7 +27,7 @@ public ReplicationPartner() {
      * @param replicationOffset the replication offset
      */
     public ReplicationPartner(HostAndPort host, long replicationOffset) {
-        LettuceAssert.notNull(host, "host must not be null");
+        LettuceAssert.notNull(host, "Host must not be null");
         this.host = host;
         this.replicationOffset = replicationOffset;
     }
@@ -49,7 +49,7 @@ public long getReplicationOffset() {
     }
 
     public void setHost(HostAndPort host) {
-        LettuceAssert.notNull(host, "host must not be null");
+        LettuceAssert.notNull(host, "Host must not be null");
         this.host = host;
     }
 

File: src/main/java/com/lambdaworks/redis/output/BooleanListOutput.java
Patch:
@@ -31,7 +31,7 @@ public void set(long integer) {
 
     @Override
     public void setSubscriber(Subscriber<Boolean> subscriber) {
-        LettuceAssert.notNull(subscriber, "subscriber must not be null");
+        LettuceAssert.notNull(subscriber, "Subscriber must not be null");
         this.subscriber = subscriber;
     }
 

File: src/main/java/com/lambdaworks/redis/output/GeoCoordinatesListOutput.java
Patch:
@@ -48,7 +48,7 @@ public void multi(int count) {
 
 	@Override
 	public void setSubscriber(Subscriber<GeoCoordinates> subscriber) {
-        LettuceAssert.notNull(subscriber, "subscriber must not be null");
+        LettuceAssert.notNull(subscriber, "Subscriber must not be null");
 		this.subscriber = subscriber;
 	}
 

File: src/main/java/com/lambdaworks/redis/output/GeoWithinListOutput.java
Patch:
@@ -91,7 +91,7 @@ public void complete(int depth) {
 
     @Override
     public void setSubscriber(Subscriber<GeoWithin<V>> subscriber) {
-        LettuceAssert.notNull(subscriber, "subscriber must not be null");
+        LettuceAssert.notNull(subscriber, "Subscriber must not be null");
         this.subscriber = subscriber;
     }
 

File: src/main/java/com/lambdaworks/redis/output/KeyListOutput.java
Patch:
@@ -33,7 +33,7 @@ public void set(ByteBuffer bytes) {
 
     @Override
     public void setSubscriber(Subscriber<K> subscriber) {
-        LettuceAssert.notNull(subscriber, "subscriber must not be null");
+        LettuceAssert.notNull(subscriber, "Subscriber must not be null");
         this.subscriber = subscriber;
     }
 

File: src/main/java/com/lambdaworks/redis/output/ListSubscriber.java
Patch:
@@ -16,7 +16,7 @@ class ListSubscriber<T> implements Subscriber<T> {
 
     private ListSubscriber(List<T> target) {
 
-        LettuceAssert.notNull(target, "target must not be null");
+        LettuceAssert.notNull(target, "Target must not be null");
 		this.target = target;
     }
 

File: src/main/java/com/lambdaworks/redis/output/ScoredValueListOutput.java
Patch:
@@ -42,7 +42,7 @@ public void set(ByteBuffer bytes) {
 
     @Override
     public void setSubscriber(Subscriber<ScoredValue<V>> subscriber) {
-        LettuceAssert.notNull(subscriber, "subscriber must not be null");
+        LettuceAssert.notNull(subscriber, "Subscriber must not be null");
         this.subscriber = subscriber;
     }
 

File: src/main/java/com/lambdaworks/redis/output/StringListOutput.java
Patch:
@@ -32,7 +32,7 @@ public void set(ByteBuffer bytes) {
 
 	@Override
 	public void setSubscriber(Subscriber<String> subscriber) {
-        LettuceAssert.notNull(subscriber, "subscriber must not be null");
+        LettuceAssert.notNull(subscriber, "Subscriber must not be null");
 		this.subscriber = subscriber;
 	}
 

File: src/main/java/com/lambdaworks/redis/output/ValueListOutput.java
Patch:
@@ -33,7 +33,7 @@ public void set(ByteBuffer bytes) {
 
     @Override
     public void setSubscriber(Subscriber<V> subscriber) {
-        LettuceAssert.notNull(subscriber, "subscriber must not be null");
+        LettuceAssert.notNull(subscriber, "Subscriber must not be null");
         this.subscriber = subscriber;
     }
 

File: src/main/java/com/lambdaworks/redis/protocol/ConnectionWatchdog.java
Patch:
@@ -72,7 +72,7 @@ public ConnectionWatchdog(Delay reconnectDelay, ClientOptions clientOptions, Boo
         LettuceAssert.notNull(clientOptions, "ClientOptions must not be null");
         LettuceAssert.notNull(bootstrap, "Bootstrap must not be null");
         LettuceAssert.notNull(timer, "Timer must not be null");
-        LettuceAssert.notNull(reconnectWorkers, "reconnectWorkers must not be null");
+        LettuceAssert.notNull(reconnectWorkers, "ReconnectWorkers must not be null");
         LettuceAssert.notNull(reconnectionListener, "ReconnectionListener must not be null");
 
         this.reconnectDelay = reconnectDelay;

File: src/main/java/com/lambdaworks/redis/resource/Futures.java
Patch:
@@ -68,7 +68,7 @@ static class PromiseAggregator<V, F extends Future<V>> implements GenericFutureL
          * @param aggregatePromise the {@link Promise} to notify
          */
         public PromiseAggregator(Promise<V> aggregatePromise) {
-            LettuceAssert.notNull(aggregatePromise, "aggregatePromise must not be null");
+            LettuceAssert.notNull(aggregatePromise, "AggregatePromise must not be null");
             this.aggregatePromise = aggregatePromise;
         }
 
@@ -103,7 +103,7 @@ public void arm() {
         @SafeVarargs
         public final PromiseAggregator<V, F> add(Promise<V>... promises) {
 
-            LettuceAssert.notNull(promises, "promises must not be null");
+            LettuceAssert.notNull(promises, "Promises must not be null");
             LettuceAssert.assertState(armed,
                     "Aggregator is not armed and does not allow adding promises in that state. Call arm() first.");
 

File: src/main/java/com/lambdaworks/redis/protocol/RedisStateMachine.java
Patch:
@@ -101,7 +101,7 @@ public boolean decode(ByteBuf buffer, RedisCommand<K, V, ?> command, CommandOutp
         ByteBuffer bytes;
 
         if (debugEnabled) {
-            logger.debug("Decode " + command);
+            logger.debug("Decode {}",command);
         }
 
         if (isEmpty(stack)) {
@@ -198,7 +198,7 @@ public boolean decode(ByteBuf buffer, RedisCommand<K, V, ?> command, CommandOutp
         }
 
         if (debugEnabled) {
-            logger.debug("Decoded " + command + ", empty stack: " + isEmpty(stack));
+            logger.debug("Decoded {}, empty stack: {}", command, isEmpty(stack));
         }
 
         return isEmpty(stack);

File: src/test/java/biz/paluch/redis/extensibility/MyExtendedRedisClient.java
Patch:
@@ -7,6 +7,7 @@
 import com.lambdaworks.redis.pubsub.StatefulRedisPubSubConnectionImpl;
 
 import javax.enterprise.inject.Alternative;
+import java.util.concurrent.TimeUnit;
 
 /**
  * Demo code for extending a RedisClient.
@@ -32,7 +33,7 @@ public MyExtendedRedisClient(RedisURI redisURI) {
 
     @Override
     protected <K, V> StatefulRedisPubSubConnectionImpl<K, V> newStatefulRedisPubSubConnection(
-            PubSubCommandHandler<K, V> handler, RedisCodec<K, V> codec) {
-        return new MyPubSubConnection<>(handler, codec, timeout, unit);
+            PubSubCommandHandler<K, V> commandHandler, RedisCodec<K, V> codec, long timeout, TimeUnit unit) {
+        return new MyPubSubConnection<>(commandHandler, codec, timeout, unit);
     }
 }

File: src/main/java/com/lambdaworks/redis/RedisSetsAsyncConnection.java
Patch:
@@ -103,7 +103,7 @@ public interface RedisSetsAsyncConnection<K, V> {
     /**
      * Move a member from one set to another.
      * 
-     * @param source the source type: key
+     * @param source the source key
      * @param destination the destination type: key
      * @param member the member type: value
      * @return RedisFuture&lt;Boolean&gt; integer-reply specifically:

File: src/main/java/com/lambdaworks/redis/RedisSetsConnection.java
Patch:
@@ -103,7 +103,7 @@ public interface RedisSetsConnection<K, V> {
     /**
      * Move a member from one set to another.
      * 
-     * @param source the source type: key
+     * @param source the source key
      * @param destination the destination type: key
      * @param member the member type: value
      * @return Boolean integer-reply specifically:

File: src/main/java/com/lambdaworks/redis/api/async/RedisSetAsyncCommands.java
Patch:
@@ -105,7 +105,7 @@ public interface RedisSetAsyncCommands<K, V> {
     /**
      * Move a member from one set to another.
      * 
-     * @param source the source type: key
+     * @param source the source key
      * @param destination the destination type: key
      * @param member the member type: value
      * @return Boolean integer-reply specifically:

File: src/main/java/com/lambdaworks/redis/api/rx/RedisSetReactiveCommands.java
Patch:
@@ -105,7 +105,7 @@ public interface RedisSetReactiveCommands<K, V> {
     /**
      * Move a member from one set to another.
      * 
-     * @param source the source type: key
+     * @param source the source key
      * @param destination the destination type: key
      * @param member the member type: value
      * @return Boolean integer-reply specifically:

File: src/main/java/com/lambdaworks/redis/api/sync/RedisSetCommands.java
Patch:
@@ -104,7 +104,7 @@ public interface RedisSetCommands<K, V> {
     /**
      * Move a member from one set to another.
      * 
-     * @param source the source type: key
+     * @param source the source key
      * @param destination the destination type: key
      * @param member the member type: value
      * @return Boolean integer-reply specifically:

File: src/main/java/com/lambdaworks/redis/cluster/api/async/NodeSelectionSetAsyncCommands.java
Patch:
@@ -105,7 +105,7 @@ public interface NodeSelectionSetAsyncCommands<K, V> {
     /**
      * Move a member from one set to another.
      * 
-     * @param source the source type: key
+     * @param source the source key
      * @param destination the destination type: key
      * @param member the member type: value
      * @return Boolean integer-reply specifically:

File: src/main/java/com/lambdaworks/redis/cluster/api/sync/NodeSelectionSetCommands.java
Patch:
@@ -104,7 +104,7 @@ public interface NodeSelectionSetCommands<K, V> {
     /**
      * Move a member from one set to another.
      * 
-     * @param source the source type: key
+     * @param source the source key
      * @param destination the destination type: key
      * @param member the member type: value
      * @return Boolean integer-reply specifically:

File: src/main/templates/com/lambdaworks/redis/api/RedisSetCommands.java
Patch:
@@ -104,7 +104,7 @@ public interface RedisSetCommands<K, V> {
     /**
      * Move a member from one set to another.
      * 
-     * @param source the source type: key
+     * @param source the source key
      * @param destination the destination type: key
      * @param member the member type: value
      * @return Boolean integer-reply specifically:

File: src/main/java/com/lambdaworks/redis/AbstractRedisReactiveCommands.java
Patch:
@@ -1738,7 +1738,7 @@ public Observable<Double> geodist(K key, V from, V to, GeoArgs.Unit unit) {
     }
 
     @Override
-    public <T> Observable<T> dispatch(ProtocolKeyword type, CommandOutput<K, V, T> output) {
+    public <T> Observable<T> dispatch(ProtocolKeyword type, CommandOutput<K, V, ?> output) {
 
         LettuceAssert.notNull(type, "Command type must not be null");
         LettuceAssert.notNull(output, "CommandOutput type must not be null");
@@ -1747,7 +1747,7 @@ public <T> Observable<T> dispatch(ProtocolKeyword type, CommandOutput<K, V, T> o
     }
 
     @Override
-    public <T> Observable<T> dispatch(ProtocolKeyword type, CommandOutput<K, V, T> output, CommandArgs<K, V> args) {
+    public <T> Observable<T> dispatch(ProtocolKeyword type, CommandOutput<K, V, ?> output, CommandArgs<K, V> args) {
 
         LettuceAssert.notNull(type, "Command type must not be null");
         LettuceAssert.notNull(output, "CommandOutput type must not be null");

File: src/main/java/com/lambdaworks/redis/api/rx/BaseRedisReactiveCommands.java
Patch:
@@ -1,5 +1,6 @@
 package com.lambdaworks.redis.api.rx;
 
+import java.util.Collection;
 import java.util.Map;
 
 import com.lambdaworks.redis.output.CommandOutput;
@@ -120,7 +121,7 @@ public interface BaseRedisReactiveCommands<K, V> extends AutoCloseable {
      * @param <T> response type
      * @return the command response
      */
-    <T> Observable<T> dispatch(ProtocolKeyword type, CommandOutput<K, V, T> output);
+    <T> Observable<T> dispatch(ProtocolKeyword type, CommandOutput<K, V, ?> output);
 
     /**
      * Dispatch a command to the Redis Server. Please note the command output type must fit to the command response.
@@ -131,7 +132,7 @@ public interface BaseRedisReactiveCommands<K, V> extends AutoCloseable {
      * @param <T> response type
      * @return the command response
      */
-    <T> Observable<T> dispatch(ProtocolKeyword type, CommandOutput<K, V, T> output, CommandArgs<K, V> args);
+    <T> Observable<T> dispatch(ProtocolKeyword type, CommandOutput<K, V, ?> output, CommandArgs<K, V> args);
 
     /**
      * Close the connection. The connection will become not usable anymore as soon as this method was called.

File: src/main/java/com/lambdaworks/redis/cluster/RedisClusterClient.java
Patch:
@@ -493,7 +493,7 @@ <K, V> StatefulRedisClusterConnectionImpl<K, V> connectClusterImpl(RedisCodec<K,
         logger.debug("connectCluster(" + initialUris + ")");
         Queue<RedisCommand<K, V, ?>> queue = LettuceFactories.newConcurrentQueue();
 
-        Supplier<SocketAddress> socketAddressSupplier = getSocketAddressSupplier(TopologyComparators::sortByLatency);
+        Supplier<SocketAddress> socketAddressSupplier = getSocketAddressSupplier(TopologyComparators::sortByClientCount);
 
         CommandHandler<K, V> handler = new CommandHandler<K, V>(clientOptions, clientResources, queue);
 

File: src/main/java/com/lambdaworks/redis/cluster/RoundRobinSocketAddressSupplier.java
Patch:
@@ -29,15 +29,16 @@ class RoundRobinSocketAddressSupplier implements Supplier<SocketAddress> {
     private RoundRobin<? extends RedisClusterNode> roundRobin;
 
     public RoundRobinSocketAddressSupplier(Collection<RedisClusterNode> partitions,
-            Function<Collection<RedisClusterNode>, Collection<RedisClusterNode>> sortFunction, ClientResources clientResources) {
+            Function<? extends Collection<RedisClusterNode>, Collection<RedisClusterNode>> sortFunction,
+            ClientResources clientResources) {
 
         LettuceAssert.notNull(partitions, "Partitions must not be null");
         LettuceAssert.notNull(sortFunction, "Sort-Function must not be null");
 
         this.partitions = partitions;
         this.clusterNodes.addAll(partitions);
         this.roundRobin = new RoundRobin<>(clusterNodes);
-        this.sortFunction = sortFunction;
+        this.sortFunction = (Function) sortFunction;
         this.clientResources = clientResources;
         resetRoundRobin();
     }

File: src/main/java/com/lambdaworks/redis/cluster/topology/Connections.java
Patch:
@@ -1,6 +1,5 @@
 package com.lambdaworks.redis.cluster.topology;
 
-import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
@@ -19,7 +18,7 @@
 class Connections {
 
     private Map<RedisURI, StatefulRedisConnection<String, String>> connections = new TreeMap<>(
-            TopologyComparators.RedisUriComparator.INSTANCE);
+            TopologyComparators.RedisURIComparator.INSTANCE);
 
     public Connections() {
     }
@@ -104,7 +103,7 @@ public Set<RedisURI> connectedNodes() {
     public Connections mergeWith(Connections discoveredConnections) {
 
         Map<RedisURI, StatefulRedisConnection<String, String>> result = new TreeMap<>(
-                TopologyComparators.RedisUriComparator.INSTANCE);
+                TopologyComparators.RedisURIComparator.INSTANCE);
         result.putAll(this.connections);
         result.putAll(discoveredConnections.connections);
 

File: src/main/java/com/lambdaworks/redis/cluster/topology/NodeTopologyViews.java
Patch:
@@ -46,7 +46,7 @@ public Set<RedisURI> getClusterNodes() {
 
     public Map<RedisURI, Partitions> toMap() {
 
-        Map<RedisURI, Partitions> nodeSpecificViews = new TreeMap<>(TopologyComparators.RedisUriComparator.INSTANCE);
+        Map<RedisURI, Partitions> nodeSpecificViews = new TreeMap<>(TopologyComparators.RedisURIComparator.INSTANCE);
 
         for (NodeTopologyView view : views) {
             nodeSpecificViews.put(view.getRedisURI(), view.getPartitions());

File: src/main/java/com/lambdaworks/redis/cluster/topology/Requests.java
Patch:
@@ -14,7 +14,7 @@
 class Requests {
 
     Map<RedisURI, TimedAsyncCommand<String, String, String>> rawViews = new TreeMap<>(
-            TopologyComparators.RedisUriComparator.INSTANCE);
+            TopologyComparators.RedisURIComparator.INSTANCE);
 
     Requests() {
     }
@@ -64,7 +64,7 @@ TimedAsyncCommand<String, String, String> getRequest(RedisURI redisURI) {
     Requests mergeWith(Requests requests) {
 
         Map<RedisURI, TimedAsyncCommand<String, String, String>> result = new TreeMap<>(
-                TopologyComparators.RedisUriComparator.INSTANCE);
+                TopologyComparators.RedisURIComparator.INSTANCE);
         result.putAll(this.rawViews);
         result.putAll(requests.rawViews);
 

File: src/main/java/com/lambdaworks/redis/protocol/CommandHandler.java
Patch:
@@ -390,9 +390,9 @@ private boolean isRejectCommand() {
         }
     }
 
-    private boolean isConnected() {
+    boolean isConnected() {
         return lifecycleState.ordinal() >= LifecycleState.CONNECTED.ordinal()
-                && lifecycleState.ordinal() <= LifecycleState.DISCONNECTED.ordinal();
+                && lifecycleState.ordinal() < LifecycleState.DISCONNECTED.ordinal();
     }
 
     @Override

File: src/test/java/com/lambdaworks/redis/commands/RunOnlyOnceServerCommandTest.java
Patch:
@@ -10,6 +10,7 @@
 
 import com.lambdaworks.redis.*;
 import org.junit.FixMethodOrder;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runners.MethodSorters;
 
@@ -75,6 +76,7 @@ public void migrateCopyReplace() throws Exception {
      * @throws Exception
      */
     @Test
+    @Ignore
     public void shutdown() throws Exception {
 
         final RedisAsyncConnection<String, String> connection = client.connectAsync(RedisURI.Builder.redis(host(), port(2))

File: src/main/java/com/lambdaworks/redis/RedisChannelHandler.java
Patch:
@@ -34,7 +34,7 @@ public abstract class RedisChannelHandler<K, V> extends ChannelInboundHandlerAda
     private CloseEvents closeEvents = new CloseEvents();
     private boolean closed;
     private final RedisChannelWriter<K, V> channelWriter;
-    private boolean active = true;
+    private volatile boolean active = true;
     private ClientOptions clientOptions;
     
     // If DEBUG level logging has been enabled at startup.

File: src/main/java/com/lambdaworks/redis/protocol/CommandHandler.java
Patch:
@@ -549,7 +549,7 @@ protected void activateCommandHandlerAndExecuteBufferedCommands(ChannelHandlerCo
         connectionError = null;
 
         if (debugEnabled) {
-            logger.debug("{} activateCommandHandlerAndExecuteBufferedCommands {} command(s) queued", logPrefix(), commandBuffer.size());
+            logger.debug("{} activateCommandHandlerAndExecuteBufferedCommands {} command(s) buffered", logPrefix(), commandBuffer.size());
         }
 
         channel = ctx.channel();
@@ -592,7 +592,7 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
                 // Shift all commands to the commandBuffer so the queue is empty.
                 // Allows to run onConnect commands before executing buffered commands
                 commandBuffer.addAll(queue);
-                queue.clear();
+                queue.removeAll(commandBuffer);
 
             } finally {
                 unlockWritersExclusive();

File: src/test/java/com/lambdaworks/redis/cluster/NodeSelectionAsyncTest.java
Patch:
@@ -7,6 +7,7 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
 
+import com.google.code.tempusfugit.temporal.WaitFor;
 import com.lambdaworks.redis.internal.LettuceSets;
 import org.junit.After;
 import org.junit.Before;
@@ -220,6 +221,7 @@ public void testSlavesWithReadOnly() throws Exception {
         });
 
         CompletableFuture.allOf(keys.futures()).exceptionally(throwable -> null).get();
+        Wait.untilEquals(1, () -> t.size()).waitOrTimeout();
 
         assertThat(t).hasSize(1);
         assertThat(strings).hasSize(1).contains(value);

File: src/test/java/com/lambdaworks/redis/resource/DirContextDnsResolverTest.java
Patch:
@@ -61,7 +61,7 @@ public void shouldResolvePreferIpv4WithProperties() throws Exception {
     @Test
     public void shouldResolveWithDnsServer() throws Exception {
 
-        resolver = new DirContextDnsResolver("8.8.8.8");
+        resolver = new DirContextDnsResolver(Arrays.asList("[2001:4860:4860::8888]", "8.8.8.8"));
 
         InetAddress[] resolved = resolver.resolve("google.com");
 
@@ -109,7 +109,7 @@ public void shouldPreferIpv6AndNotIpv4() throws Exception {
     @Test(expected = UnknownHostException.class)
     public void shouldFailWithUnknownHost() throws Exception {
 
-        resolver = new DirContextDnsResolver(Arrays.asList("8.8.8.8"));
+        resolver = new DirContextDnsResolver("8.8.8.8");
 
         resolver.resolve("unknown-domain-name");
     }
@@ -169,4 +169,4 @@ public void shouldWorkWithIpv6Addresses() throws Exception {
         assertThat(resolved[0]).isInstanceOf(Inet6Address.class);
         assertThat(resolved[0].getHostAddress()).isEqualTo("2a00:1450:4001:816:0:0:0:200e");
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/SslTest.java
Patch:
@@ -59,7 +59,7 @@ public void regularSsl() throws Exception {
     @Test
     public void pingBeforeActivate() throws Exception {
         RedisURI redisUri = RedisURI.Builder.redis(host(), sslPort()).withSsl(true).withVerifyPeer(false).build();
-        redisClient.setOptions(new ClientOptions.Builder().pingBeforeActivateConnection(true).build());
+        redisClient.setOptions(ClientOptions.builder().pingBeforeActivateConnection(true).build());
 
         RedisConnection<String, String> connection = redisClient.connect(redisUri).sync();
         connection.set("key", "value");
@@ -115,7 +115,7 @@ public void pubSubSslAndBreakConnection() throws Exception {
 
         RedisURI redisUri = RedisURI.Builder.redis(host(), sslPort()).withSsl(true).withVerifyPeer(false).build();
 
-        redisClient.setOptions(new ClientOptions.Builder().suspendReconnectOnProtocolFailure(true).build());
+        redisClient.setOptions(ClientOptions.builder().suspendReconnectOnProtocolFailure(true).build());
 
         RedisPubSubAsyncCommands<String, String> connection = redisClient.connectPubSub(redisUri).async();
         connection.subscribe("c1").get();

File: src/test/java/com/lambdaworks/examples/ConnectToRedisClusterWithTopologyRefreshing.java
Patch:
@@ -16,12 +16,12 @@ public static void main(String[] args) {
         // Syntax: redis://[password@]host[:port]
 
         RedisClusterClient redisClient = RedisClusterClient.create("redis://password@localhost:7379");
-        ClusterTopologyRefreshOptions clusterTopologyRefreshOptions = new ClusterTopologyRefreshOptions.Builder()//
+        ClusterTopologyRefreshOptions clusterTopologyRefreshOptions = ClusterTopologyRefreshOptions.builder()//
                 .enablePeriodicRefresh(30, TimeUnit.MINUTES)//
                 .enableAllAdaptiveRefreshTriggers()//
                 .build();
 
-        ClusterClientOptions clusterClientOptions = new ClusterClientOptions.Builder()//
+        ClusterClientOptions clusterClientOptions = ClusterClientOptions.builder()//
                 .topologyRefreshOptions(clusterTopologyRefreshOptions)//
                 .build();
 

File: src/test/java/com/lambdaworks/redis/AbstractRedisClientTest.java
Patch:
@@ -29,7 +29,7 @@ protected RedisCommands<String, String> connect() {
 
     @Before
     public void openConnection() throws Exception {
-        client.setOptions(new ClientOptions.Builder().build());
+        client.setOptions(ClientOptions.builder().build());
         redis = connect();
         boolean scriptRunning;
         do {

File: src/test/java/com/lambdaworks/redis/cluster/AdvancedClusterClientTest.java
Patch:
@@ -451,7 +451,7 @@ public void getConnectionToNotAClusterMemberForbidden() throws Exception {
     @Test
     public void getConnectionToNotAClusterMemberAllowed() throws Exception {
 
-        clusterClient.setOptions(new ClusterClientOptions.Builder().validateClusterNodeMembership(false).build());
+        clusterClient.setOptions(ClusterClientOptions.builder().validateClusterNodeMembership(false).build());
         StatefulRedisClusterConnection<String, String> connection = clusterClient.connect();
         connection.getConnection(TestSettings.host(), TestSettings.port());
         connection.close();

File: src/test/java/com/lambdaworks/redis/cluster/ClusterClientOptionsTest.java
Patch:
@@ -12,7 +12,7 @@ public class ClusterClientOptionsTest {
     @Test
     public void testCopy() throws Exception {
 
-        ClusterClientOptions options = new ClusterClientOptions.Builder().closeStaleConnections(true).refreshClusterView(true)
+        ClusterClientOptions options = ClusterClientOptions.builder().closeStaleConnections(true).refreshClusterView(true)
                 .autoReconnect(false).requestQueueSize(100).suspendReconnectOnProtocolFailure(true).maxRedirects(1234)
                 .validateClusterNodeMembership(false).build();
 

File: src/test/java/com/lambdaworks/redis/cluster/ClusterTopologyRefreshOptionsTest.java
Patch:
@@ -16,7 +16,7 @@ public class ClusterTopologyRefreshOptionsTest {
     @Test
     public void testBuilder() throws Exception {
 
-        ClusterTopologyRefreshOptions options = new ClusterTopologyRefreshOptions.Builder()//
+        ClusterTopologyRefreshOptions options = ClusterTopologyRefreshOptions.builder()//
                 .enablePeriodicRefresh(true).refreshPeriod(10, TimeUnit.MINUTES)//
                 .dynamicRefreshSources(false) //
                 .enableAdaptiveRefreshTrigger(RefreshTrigger.MOVED_REDIRECT)//
@@ -39,7 +39,7 @@ public void testBuilder() throws Exception {
     @Test
     public void testCopy() throws Exception {
 
-        ClusterTopologyRefreshOptions master = new ClusterTopologyRefreshOptions.Builder()//
+        ClusterTopologyRefreshOptions master = ClusterTopologyRefreshOptions.builder()//
                 .enablePeriodicRefresh(true).refreshPeriod(10, TimeUnit.MINUTES)//
                 .dynamicRefreshSources(false) //
                 .enableAdaptiveRefreshTrigger(RefreshTrigger.MOVED_REDIRECT)//

File: src/test/java/com/lambdaworks/redis/cluster/RedisClusterClientTest.java
Patch:
@@ -230,7 +230,7 @@ public void testClusterRedirection() throws Exception {
     @SuppressWarnings({ "rawtypes" })
     public void testClusterRedirectionLimit() throws Exception {
 
-        clusterClient.setOptions(new ClusterClientOptions.Builder().maxRedirects(0).build());
+        clusterClient.setOptions(ClusterClientOptions.builder().maxRedirects(0).build());
         RedisAdvancedClusterAsyncCommands<String, String> connection = clusterClient.connect().async();
         Partitions partitions = clusterClient.getPartitions();
 

File: src/test/java/com/lambdaworks/redis/cluster/RedisClusterPasswordSecuredSslTest.java
Patch:
@@ -37,7 +37,7 @@ public class RedisClusterPasswordSecuredSslTest extends AbstractTest {
     public static final String SLOT_1_KEY = "8HMdi";
     public static final String SLOT_16352_KEY = "UyAa4KqoWgPGKa";
 
-    public static RedisURI redisURI = new RedisURI.Builder().redis(host(), CLUSTER_PORT_SSL_1).withPassword("foobared")
+    public static RedisURI redisURI = RedisURI.builder().redis(host(), CLUSTER_PORT_SSL_1).withPassword("foobared")
             .withSsl(true).withVerifyPeer(false).build();
     public static RedisClusterClient redisClient = RedisClusterClient.create(redisURI);
 
@@ -121,7 +121,7 @@ public void nodeSelectionApiShouldWork() throws Exception {
     @Test
     public void connectionWithoutPasswordShouldFail() throws Exception {
 
-        RedisURI redisURI = new RedisURI.Builder().redis(host(), CLUSTER_PORT_SSL_1).withSsl(true).withVerifyPeer(false)
+        RedisURI redisURI = RedisURI.builder().redis(host(), CLUSTER_PORT_SSL_1).withSsl(true).withVerifyPeer(false)
                 .build();
         RedisClusterClient redisClusterClient = RedisClusterClient.create(redisURI);
 
@@ -137,7 +137,7 @@ public void connectionWithoutPasswordShouldFail() throws Exception {
     @Test
     public void connectionWithoutPasswordShouldFail2() throws Exception {
 
-        RedisURI redisURI = new RedisURI.Builder().redis(host(), CLUSTER_PORT_SSL_1).withSsl(true).withVerifyPeer(false)
+        RedisURI redisURI = RedisURI.builder().redis(host(), CLUSTER_PORT_SSL_1).withSsl(true).withVerifyPeer(false)
                 .build();
         RedisClusterClient redisClusterClient = RedisClusterClient.create(redisURI);
 

File: src/test/java/com/lambdaworks/redis/commands/rx/TransactionRxCommandTest.java
Patch:
@@ -31,7 +31,7 @@ protected RedisCommands<String, String> connect() {
 
     @Before
     public void openConnection() throws Exception {
-        client.setOptions(new ClientOptions.Builder().build());
+        client.setOptions(ClientOptions.builder().build());
         redis = connect();
         redis.flushall();
         redis.flushdb();

File: src/test/java/com/lambdaworks/redis/metrics/DefaultDefaultCommandLatencyCollectorOptionsTest.java
Patch:
@@ -31,7 +31,7 @@ public void testDisabled() throws Exception {
     @Test
     public void testBuilder() throws Exception {
 
-        DefaultCommandLatencyCollectorOptions sut = new DefaultCommandLatencyCollectorOptions.Builder()
+        DefaultCommandLatencyCollectorOptions sut = DefaultCommandLatencyCollectorOptions.builder()
                 .targetUnit(TimeUnit.HOURS).targetPercentiles(new double[] { 1, 2, 3 }).build();
 
         assertThat(sut.targetPercentiles()).hasSize(3);

File: src/test/java/com/lambdaworks/redis/reliability/AtLeastOnceTest.java
Patch:
@@ -49,7 +49,7 @@ public class AtLeastOnceTest extends AbstractRedisClientTest {
 
     @Before
     public void before() throws Exception {
-        client.setOptions(new ClientOptions.Builder().autoReconnect(true).build());
+        client.setOptions(ClientOptions.builder().autoReconnect(true).build());
 
         // needs to be increased on slow systems...perhaps...
         client.setDefaultTimeout(3, TimeUnit.SECONDS);

File: src/test/java/com/lambdaworks/redis/reliability/AtMostOnceTest.java
Patch:
@@ -49,7 +49,7 @@ public class AtMostOnceTest extends AbstractRedisClientTest {
 
     @Before
     public void before() throws Exception {
-        client.setOptions(new ClientOptions.Builder().autoReconnect(false).build());
+        client.setOptions(ClientOptions.builder().autoReconnect(false).build());
 
         // needs to be increased on slow systems...perhaps...
         client.setDefaultTimeout(3, TimeUnit.SECONDS);

File: src/test/java/com/lambdaworks/apigenerator/CreateSyncNodeSelectionClusterApi.java
Patch:
@@ -9,7 +9,6 @@
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 
-import com.lambdaworks.redis.internal.LettuceSets;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -19,6 +18,7 @@
 import com.github.javaparser.ast.type.ClassOrInterfaceType;
 import com.github.javaparser.ast.type.ReferenceType;
 import com.github.javaparser.ast.type.Type;
+import com.lambdaworks.redis.internal.LettuceSets;
 
 /**
  * Create sync API based on the templates.
@@ -28,8 +28,8 @@
 @RunWith(Parameterized.class)
 public class CreateSyncNodeSelectionClusterApi {
 
-    private Set<String> FILTER_METHODS = LettuceSets.unmodifiableSet("shutdown", "debugOom", "debugSegfault",
-            "digest", "close", "isOpen", "BaseRedisCommands.reset", "readOnly", "readWrite");
+    private Set<String> FILTER_METHODS = LettuceSets.unmodifiableSet("shutdown", "debugOom", "debugSegfault", "digest", "close",
+            "isOpen", "BaseRedisCommands.reset", "readOnly", "readWrite", "dispatch");
 
     private CompilationUnitFactory factory;
 

File: src/main/java/com/lambdaworks/redis/cluster/event/ClusterTopologyChangedEvent.java
Patch:
@@ -1,5 +1,6 @@
 package com.lambdaworks.redis.cluster.event;
 
+import java.util.Collections;
 import java.util.List;
 
 import com.lambdaworks.redis.cluster.models.partitions.RedisClusterNode;
@@ -22,8 +23,8 @@ public class ClusterTopologyChangedEvent implements Event {
      * @param after the cluster topology view after the topology changed, must not be {@literal null}
      */
     public ClusterTopologyChangedEvent(List<RedisClusterNode> before, List<RedisClusterNode> after) {
-        this.before = before;
-        this.after = after;
+        this.before = Collections.unmodifiableList(before);
+        this.after = Collections.unmodifiableList(after);
     }
 
     /**

File: src/test/java/com/lambdaworks/Wait.java
Patch:
@@ -123,7 +123,7 @@ public static <T> WaitBuilder<T> untilEquals(T expectation, Supplier<T> actualSu
 
             if (o instanceof Number && expectation instanceof Number) {
                 Number actualNumber = (Number) o;
-                Number expectedNumber = (Number) o;
+                Number expectedNumber = (Number) expectation;
 
                 if (actualNumber.doubleValue() == expectedNumber.doubleValue()) {
                     return true;

File: src/test/java/com/lambdaworks/redis/resource/DirContextDnsResolverTest.java
Patch:
@@ -118,11 +118,11 @@ public void shouldFailWithUnknownHost() throws Exception {
     public void shouldResolveCname() throws Exception {
 
         resolver = new DirContextDnsResolver();
-        InetAddress[] resolved = resolver.resolve("redis.paluch.biz");
+        InetAddress[] resolved = resolver.resolve("www.github.io");
 
         assertThat(resolved.length).isGreaterThan(0);
         assertThat(resolved[0]).isInstanceOf(InetAddress.class);
-        assertThat(resolved[0].getHostName()).isEqualTo("redis.paluch.biz");
+        assertThat(resolved[0].getHostName()).isEqualTo("www.github.io");
     }
 
     @Test

File: src/main/java/com/lambdaworks/redis/output/GeoCoordinatesListOutput.java
Patch:
@@ -27,6 +27,7 @@ public GeoCoordinatesListOutput(RedisCodec<K, V> codec) {
 
     @Override
     public void set(ByteBuffer bytes) {
+
         Double value = (bytes == null) ? 0 : parseDouble(decodeAscii(bytes));
 
         if (x == null) {

File: src/main/java/com/lambdaworks/redis/cluster/PooledClusterConnectionProvider.java
Patch:
@@ -21,6 +21,7 @@
 import com.lambdaworks.redis.models.role.RedisInstance;
 import com.lambdaworks.redis.models.role.RedisNodeDescription;
 
+import com.lambdaworks.redis.resource.SocketAddressResolver;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -415,7 +416,7 @@ private Supplier<SocketAddress> getSocketAddressSupplier(final ConnectionKey con
     protected SocketAddress getSocketAddress(String nodeId) {
         for (RedisClusterNode partition : partitions) {
             if (partition.getNodeId().equals(nodeId)) {
-                return partition.getUri().getResolvedAddress();
+                return SocketAddressResolver.resolve(partition.getUri(), redisClusterClient.getResources().dnsResolver());
             }
         }
         return null;

File: src/main/java/com/lambdaworks/redis/EpollProvider.java
Patch:
@@ -1,12 +1,12 @@
 package com.lambdaworks.redis;
 
-import static com.google.common.base.Preconditions.checkState;
-
 import java.lang.reflect.Constructor;
 import java.net.SocketAddress;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ThreadFactory;
 
+import com.lambdaworks.redis.internal.LettuceAssert;
+
 import io.netty.channel.Channel;
 import io.netty.channel.EventLoopGroup;
 import io.netty.util.internal.logging.InternalLogger;
@@ -59,7 +59,7 @@ private static <T> Class<T> getClass(String className) {
      */
     static void checkForEpollLibrary() {
 
-        checkState(domainSocketAddressClass != null && epollDomainSocketChannelClass != null,
+        LettuceAssert.assertState(domainSocketAddressClass != null && epollDomainSocketChannelClass != null,
                 "Cannot connect using sockets without the optional netty-transport-native-epoll library on the class path");
     }
 

File: src/main/java/com/lambdaworks/redis/KeyScanCursor.java
Patch:
@@ -12,7 +12,7 @@
  */
 public class KeyScanCursor<K> extends ScanCursor {
 
-    private final List<K> keys = new ArrayList<K>();
+    private final List<K> keys = new ArrayList<>();
 
     public List<K> getKeys() {
         return keys;

File: src/main/java/com/lambdaworks/redis/LettuceStrings.java
Patch:
@@ -7,7 +7,7 @@
 import com.lambdaworks.codec.Base16;
 
 /**
- * Helper for {@link String} checks.
+ * Helper for {@link String} checks. This class is part of the internal API and may change without further notice.
  * 
  * @author Mark Paluch
  * @since 3.0

File: src/main/java/com/lambdaworks/redis/MapScanCursor.java
Patch:
@@ -1,9 +1,8 @@
 package com.lambdaworks.redis;
 
+import java.util.LinkedHashMap;
 import java.util.Map;
 
-import com.google.common.collect.Maps;
-
 /**
  * Scan cursor for maps.
  * 
@@ -14,7 +13,7 @@
  */
 public class MapScanCursor<K, V> extends ScanCursor {
 
-    private final Map<K, V> map = Maps.newLinkedHashMap();
+    private final Map<K, V> map = new LinkedHashMap<>();
 
     /**
      * 

File: src/main/java/com/lambdaworks/redis/RedisFuture.java
Patch:
@@ -4,8 +4,6 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import com.google.common.util.concurrent.ListenableFuture;
-
 /**
  * Redis Future, extends a Listenable Future (Notification on Complete). The execution of the notification happens either on
  * finish of the future execution or, if the future is completed already, immediately.

File: src/main/java/com/lambdaworks/redis/ScoredValueScanCursor.java
Patch:
@@ -12,7 +12,7 @@
  */
 public class ScoredValueScanCursor<V> extends ScanCursor {
 
-    private final List<ScoredValue<V>> values = new ArrayList<ScoredValue<V>>();
+    private final List<ScoredValue<V>> values = new ArrayList<>();
 
     public ScoredValueScanCursor() {
     }

File: src/main/java/com/lambdaworks/redis/ValueScanCursor.java
Patch:
@@ -12,7 +12,7 @@
  */
 public class ValueScanCursor<V> extends ScanCursor {
 
-    private final List<V> values = new ArrayList<V>();
+    private final List<V> values = new ArrayList<>();
 
     public ValueScanCursor() {
     }

File: src/main/java/com/lambdaworks/redis/cluster/AsyncExecutionsImpl.java
Patch:
@@ -1,11 +1,12 @@
 package com.lambdaworks.redis.cluster;
 
 import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
 
-import com.google.common.collect.ImmutableMap;
 import com.lambdaworks.redis.cluster.api.async.AsyncExecutions;
 import com.lambdaworks.redis.cluster.models.partitions.RedisClusterNode;
 
@@ -17,7 +18,7 @@ class AsyncExecutionsImpl<T> implements AsyncExecutions<T> {
     private Map<RedisClusterNode, CompletionStage<T>> executions;
 
     public AsyncExecutionsImpl(Map<RedisClusterNode, CompletionStage<T>> executions) {
-        this.executions = ImmutableMap.copyOf(executions);
+        this.executions = Collections.unmodifiableMap(new HashMap<>(executions));
     }
 
     @Override

File: src/main/java/com/lambdaworks/redis/cluster/ClusterScanSupport.java
Patch:
@@ -136,8 +136,7 @@ static String getCurrentNodeId(ScanCursor cursor, List<String> nodeIds) {
      * @return
      */
     private static List<String> getNodeIds(StatefulRedisClusterConnection<?, ?> connection) {
-        List<String> nodeIds;
-        nodeIds = new ArrayList<>();
+        List<String> nodeIds = new ArrayList<>();
 
         PartitionAccessor partitionAccessor = new PartitionAccessor(connection.getPartitions());
         for (RedisClusterNode redisClusterNode : partitionAccessor.getMasters()) {

File: src/main/java/com/lambdaworks/redis/cluster/PartitionAccessor.java
Patch:
@@ -1,10 +1,10 @@
 package com.lambdaworks.redis.cluster;
 
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import java.util.function.Predicate;
 
-import com.google.common.collect.Lists;
 import com.lambdaworks.redis.cluster.models.partitions.RedisClusterNode;
 
 /**
@@ -42,7 +42,7 @@ List<RedisClusterNode> getReadCandidates(RedisClusterNode master) {
 
     List<RedisClusterNode> get(Predicate<RedisClusterNode> test) {
 
-        List<RedisClusterNode> result = Lists.newArrayListWithExpectedSize(partitions.size());
+        List<RedisClusterNode> result = new ArrayList<>(partitions.size());
         for (RedisClusterNode partition : partitions) {
             if (test.test(partition)) {
                 result.add(partition);

File: src/main/java/com/lambdaworks/redis/cluster/ReadOnlyCommands.java
Patch:
@@ -1,8 +1,8 @@
 package com.lambdaworks.redis.cluster;
 
+import java.util.HashSet;
 import java.util.Set;
 
-import com.google.common.collect.Sets;
 import com.lambdaworks.redis.protocol.CommandType;
 import com.lambdaworks.redis.protocol.ProtocolKeyword;
 
@@ -17,7 +17,7 @@ class ReadOnlyCommands {
 
     static {
 
-        Set<ProtocolKeyword> set = Sets.newHashSet();
+        Set<ProtocolKeyword> set = new HashSet<ProtocolKeyword>(CommandName.values().length);
 
         for (CommandName commandNames : CommandName.values()) {
             set.add(CommandType.valueOf(commandNames.name()));

File: src/main/java/com/lambdaworks/redis/cluster/StatefulRedisClusterConnectionImpl.java
Patch:
@@ -12,7 +12,6 @@
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
 import com.google.common.cache.LoadingCache;
-import com.google.common.reflect.AbstractInvocationHandler;
 import com.lambdaworks.redis.*;
 import com.lambdaworks.redis.api.StatefulRedisConnection;
 import com.lambdaworks.redis.api.sync.RedisCommands;
@@ -26,6 +25,7 @@
 import com.lambdaworks.redis.cluster.models.partitions.Partitions;
 import com.lambdaworks.redis.cluster.models.partitions.RedisClusterNode;
 import com.lambdaworks.redis.codec.RedisCodec;
+import com.lambdaworks.redis.internal.AbstractInvocationHandler;
 import com.lambdaworks.redis.protocol.CompleteableCommand;
 import com.lambdaworks.redis.protocol.ConnectionWatchdog;
 import com.lambdaworks.redis.protocol.RedisCommand;

File: src/main/java/com/lambdaworks/redis/cluster/SyncExecutionsImpl.java
Patch:
@@ -1,11 +1,11 @@
 package com.lambdaworks.redis.cluster;
 
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.ExecutionException;
 
-import com.google.common.collect.Maps;
 import com.lambdaworks.redis.cluster.api.sync.Executions;
 import com.lambdaworks.redis.cluster.models.partitions.RedisClusterNode;
 
@@ -19,7 +19,7 @@ class SyncExecutionsImpl<T> implements Executions<T> {
     public SyncExecutionsImpl(Map<RedisClusterNode, CompletionStage<T>> executions) throws ExecutionException,
             InterruptedException {
 
-        Map<RedisClusterNode, T> result = Maps.newHashMap();
+        Map<RedisClusterNode, T> result = new HashMap<>();
         for (Map.Entry<RedisClusterNode, CompletionStage<T>> entry : executions.entrySet()) {
             result.put(entry.getKey(), entry.getValue().toCompletableFuture().get());
         }

File: src/main/java/com/lambdaworks/redis/masterslave/MasterSlaveChannelWriter.java
Patch:
@@ -1,12 +1,11 @@
 package com.lambdaworks.redis.masterslave;
 
-import static com.google.common.base.Preconditions.checkArgument;
-
 import com.lambdaworks.redis.ReadFrom;
 import com.lambdaworks.redis.RedisChannelHandler;
 import com.lambdaworks.redis.RedisChannelWriter;
 import com.lambdaworks.redis.RedisException;
 import com.lambdaworks.redis.api.StatefulRedisConnection;
+import com.lambdaworks.redis.internal.LettuceAssert;
 import com.lambdaworks.redis.protocol.ProtocolKeyword;
 import com.lambdaworks.redis.protocol.RedisCommand;
 
@@ -26,7 +25,7 @@ public MasterSlaveChannelWriter(MasterSlaveConnectionProvider masterSlaveConnect
 
     @Override
     public <T, C extends RedisCommand<K, V, T>> C write(C command) {
-        checkArgument(command != null, "command must not be null");
+        LettuceAssert.notNull(command, "command must not be null");
 
         if (closed) {
             throw new RedisException("Connection is closed");

File: src/main/java/com/lambdaworks/redis/masterslave/MasterSlaveTopologyProvider.java
Patch:
@@ -1,10 +1,10 @@
 package com.lambdaworks.redis.masterslave;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import com.google.common.collect.Lists;
 import com.lambdaworks.redis.RedisException;
 import com.lambdaworks.redis.RedisURI;
 import com.lambdaworks.redis.api.StatefulRedisConnection;
@@ -52,7 +52,7 @@ public List<RedisNodeDescription> getNodes() {
     }
 
     protected List<RedisNodeDescription> getNodesFromInfo(String info) {
-        List<RedisNodeDescription> result = Lists.newArrayList();
+        List<RedisNodeDescription> result = new ArrayList<>();
 
         result.add(getMasterFromInfo(info));
         result.addAll(getSlavesFromInfo(info));
@@ -61,7 +61,7 @@ protected List<RedisNodeDescription> getNodesFromInfo(String info) {
 
     private List<RedisNodeDescription> getSlavesFromInfo(String info) {
 
-        List<RedisNodeDescription> slaves = Lists.newArrayList();
+        List<RedisNodeDescription> slaves = new ArrayList<>();
 
         Matcher matcher = SLAVE_PATTERN.matcher(info);
         while (matcher.find()) {

File: src/main/java/com/lambdaworks/redis/masterslave/ReadOnlyCommands.java
Patch:
@@ -1,8 +1,8 @@
 package com.lambdaworks.redis.masterslave;
 
+import java.util.HashSet;
 import java.util.Set;
 
-import com.google.common.collect.Sets;
 import com.lambdaworks.redis.protocol.CommandType;
 import com.lambdaworks.redis.protocol.ProtocolKeyword;
 
@@ -17,7 +17,7 @@ class ReadOnlyCommands {
 
     static {
 
-        Set<ProtocolKeyword> set = Sets.newHashSet();
+        Set<ProtocolKeyword> set = new HashSet<ProtocolKeyword>(CommandName.values().length);
 
         for (CommandName commandNames : CommandName.values()) {
             set.add(CommandType.valueOf(commandNames.name()));

File: src/main/java/com/lambdaworks/redis/masterslave/SentinelTopologyProvider.java
Patch:
@@ -2,14 +2,14 @@
 
 import static com.lambdaworks.redis.masterslave.MasterSlaveUtils.CODEC;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.stream.Collectors;
 
-import com.google.common.collect.Lists;
 import com.lambdaworks.redis.RedisClient;
 import com.lambdaworks.redis.RedisException;
 import com.lambdaworks.redis.RedisFuture;
@@ -54,7 +54,7 @@ public List<RedisNodeDescription> getNodes() {
             RedisFuture<Map<String, String>> masterFuture = connection.async().master(masterId);
             RedisFuture<List<Map<String, String>>> slavesFuture = connection.async().slaves(masterId);
 
-            List<RedisNodeDescription> result = Lists.newArrayList();
+            List<RedisNodeDescription> result = new ArrayList<>();
             try {
                 Map<String, String> master = masterFuture.get(timeout, timeUnit);
                 List<Map<String, String>> slaves = slavesFuture.get(timeout, timeUnit);

File: src/main/java/com/lambdaworks/redis/output/BooleanListOutput.java
Patch:
@@ -2,12 +2,11 @@
 
 package com.lambdaworks.redis.output;
 
-import static com.google.common.base.Preconditions.*;
-
 import java.util.ArrayList;
 import java.util.List;
 
 import com.lambdaworks.redis.codec.RedisCodec;
+import com.lambdaworks.redis.internal.LettuceAssert;
 
 /**
  * {@link java.util.List} of boolean output.
@@ -32,7 +31,7 @@ public void set(long integer) {
 
     @Override
     public void setSubscriber(Subscriber<Boolean> subscriber) {
-        checkArgument(subscriber != null, "subscriber must not be null");
+        LettuceAssert.notNull(subscriber, "subscriber must not be null");
         this.subscriber = subscriber;
     }
 

File: src/main/java/com/lambdaworks/redis/output/CommandOutput.java
Patch:
@@ -2,11 +2,10 @@
 
 package com.lambdaworks.redis.output;
 
-import static com.google.common.base.Preconditions.checkArgument;
-
 import java.nio.ByteBuffer;
 
 import com.lambdaworks.redis.codec.RedisCodec;
+import com.lambdaworks.redis.internal.LettuceAssert;
 
 /**
  * Abstract representation of the output of a redis command.
@@ -29,7 +28,7 @@ public abstract class CommandOutput<K, V, T> {
      * @param output Initial value of output.
      */
     public CommandOutput(RedisCodec<K, V> codec, T output) {
-        checkArgument(codec != null, "RedisCodec must not be null");
+        LettuceAssert.notNull(codec, "RedisCodec must not be null");
         this.codec = codec;
         this.output = output;
     }

File: src/main/java/com/lambdaworks/redis/output/GeoCoordinatesListOutput.java
Patch:
@@ -1,6 +1,5 @@
 package com.lambdaworks.redis.output;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static java.lang.Double.parseDouble;
 
 import java.nio.ByteBuffer;
@@ -9,6 +8,7 @@
 
 import com.lambdaworks.redis.GeoCoordinates;
 import com.lambdaworks.redis.codec.RedisCodec;
+import com.lambdaworks.redis.internal.LettuceAssert;
 
 /**
  * A list output that creates a list with {@link GeoCoordinates}'s.
@@ -21,7 +21,7 @@ public class GeoCoordinatesListOutput<K, V> extends CommandOutput<K, V, List<Geo
 	private Subscriber<GeoCoordinates> subscriber;
 
 	public GeoCoordinatesListOutput(RedisCodec<K, V> codec) {
-		super(codec, new ArrayList<>());
+        super(codec, new ArrayList<>());
 		setSubscriber(ListSubscriber.of(output));
 	}
 
@@ -47,7 +47,7 @@ public void multi(int count) {
 
 	@Override
 	public void setSubscriber(Subscriber<GeoCoordinates> subscriber) {
-		checkArgument(subscriber != null, "subscriber must not be null");
+        LettuceAssert.notNull(subscriber, "subscriber must not be null");
 		this.subscriber = subscriber;
 	}
 

File: src/main/java/com/lambdaworks/redis/output/GeoWithinListOutput.java
Patch:
@@ -1,6 +1,5 @@
 package com.lambdaworks.redis.output;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static java.lang.Double.parseDouble;
 
 import java.nio.ByteBuffer;
@@ -10,6 +9,7 @@
 import com.lambdaworks.redis.GeoCoordinates;
 import com.lambdaworks.redis.GeoWithin;
 import com.lambdaworks.redis.codec.RedisCodec;
+import com.lambdaworks.redis.internal.LettuceAssert;
 
 /**
  * A list output that creates a list with either double/long or {@link GeoCoordinates}'s.
@@ -90,7 +90,7 @@ public void complete(int depth) {
 
 	@Override
 	public void setSubscriber(Subscriber<GeoWithin<V>> subscriber) {
-		checkArgument(subscriber != null, "subscriber must not be null");
+        LettuceAssert.notNull(subscriber, "subscriber must not be null");
 		this.subscriber = subscriber;
 	}
 

File: src/main/java/com/lambdaworks/redis/output/ListSubscriber.java
Patch:
@@ -1,9 +1,8 @@
 package com.lambdaworks.redis.output;
 
-import static com.google.common.base.Preconditions.checkArgument;
-
 import java.util.List;
 
+import com.lambdaworks.redis.internal.LettuceAssert;
 import com.lambdaworks.redis.output.StreamingOutput.Subscriber;
 
 /**
@@ -17,7 +16,7 @@ class ListSubscriber<T> implements Subscriber<T> {
 
     private ListSubscriber(List<T> target) {
 
-		checkArgument(target != null, "target must not be null");
+        LettuceAssert.notNull(target, "target must not be null");
 		this.target = target;
     }
 

File: src/main/java/com/lambdaworks/redis/output/MapOutput.java
Patch:
@@ -3,9 +3,9 @@
 package com.lambdaworks.redis.output;
 
 import java.nio.ByteBuffer;
+import java.util.LinkedHashMap;
 import java.util.Map;
 
-import com.google.common.collect.Maps;
 import com.lambdaworks.redis.codec.RedisCodec;
 
 /**
@@ -20,7 +20,7 @@ public class MapOutput<K, V> extends CommandOutput<K, V, Map<K, V>> {
     private K key;
 
     public MapOutput(RedisCodec<K, V> codec) {
-        super(codec, Maps.newLinkedHashMap());
+        super(codec, new LinkedHashMap<>());
     }
 
     @Override

File: src/main/java/com/lambdaworks/redis/output/MultiOutput.java
Patch:
@@ -4,12 +4,12 @@
 
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 
 import com.lambdaworks.redis.RedisCommandExecutionException;
 import com.lambdaworks.redis.codec.RedisCodec;
+import com.lambdaworks.redis.internal.LettuceFactories;
 import com.lambdaworks.redis.protocol.RedisCommand;
 
 /**
@@ -23,8 +23,8 @@ public class MultiOutput<K, V> extends CommandOutput<K, V, List<Object>> {
     private final Queue<RedisCommand<K, V, ?>> queue;
 
     public MultiOutput(RedisCodec<K, V> codec) {
-        super(codec, new ArrayList<Object>());
-        queue = new LinkedList<RedisCommand<K, V, ?>>();
+        super(codec, new ArrayList<>());
+        queue = LettuceFactories.newSpScQueue();
     }
 
     public void add(RedisCommand<K, V, ?> cmd) {

File: src/main/java/com/lambdaworks/redis/output/ScoredValueListOutput.java
Patch:
@@ -2,14 +2,13 @@
 
 package com.lambdaworks.redis.output;
 
-import static com.google.common.base.Preconditions.*;
-
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
 
 import com.lambdaworks.redis.ScoredValue;
 import com.lambdaworks.redis.codec.RedisCodec;
+import com.lambdaworks.redis.internal.LettuceAssert;
 
 /**
  * {@link List} of values and their associated scores.
@@ -43,7 +42,7 @@ public void set(ByteBuffer bytes) {
 
     @Override
     public void setSubscriber(Subscriber<ScoredValue<V>> subscriber) {
-        checkArgument(subscriber != null, "subscriber must not be null");
+        LettuceAssert.notNull(subscriber, "subscriber must not be null");
         this.subscriber = subscriber;
     }
 

File: src/main/java/com/lambdaworks/redis/output/ValueListOutput.java
Patch:
@@ -2,13 +2,12 @@
 
 package com.lambdaworks.redis.output;
 
-import static com.google.common.base.Preconditions.*;
-
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
 
 import com.lambdaworks.redis.codec.RedisCodec;
+import com.lambdaworks.redis.internal.LettuceAssert;
 
 /**
  * {@link List} of values output.
@@ -34,7 +33,7 @@ public void set(ByteBuffer bytes) {
 
     @Override
     public void setSubscriber(Subscriber<V> subscriber) {
-        checkArgument(subscriber != null, "subscriber must not be null");
+        LettuceAssert.notNull(subscriber, "subscriber must not be null");
         this.subscriber = subscriber;
     }
 

File: src/main/java/com/lambdaworks/redis/output/ValueSetOutput.java
Patch:
@@ -18,7 +18,7 @@
  */
 public class ValueSetOutput<K, V> extends CommandOutput<K, V, Set<V>> {
     public ValueSetOutput(RedisCodec<K, V> codec) {
-        super(codec, new HashSet<V>());
+        super(codec, new HashSet<>());
     }
 
     @Override

File: src/main/java/com/lambdaworks/redis/protocol/Command.java
Patch:
@@ -2,8 +2,7 @@
 
 package com.lambdaworks.redis.protocol;
 
-import static com.google.common.base.Preconditions.checkArgument;
-
+import com.lambdaworks.redis.internal.LettuceAssert;
 import com.lambdaworks.redis.output.CommandOutput;
 import io.netty.buffer.ByteBuf;
 
@@ -48,7 +47,7 @@ public Command(ProtocolKeyword type, CommandOutput<K, V, T> output) {
      * @param args Command args, can be {@literal null}
      */
     public Command(ProtocolKeyword type, CommandOutput<K, V, T> output, CommandArgs<K, V> args) {
-        checkArgument(type != null, "Command type must not be null");
+        LettuceAssert.notNull(type, "Command type must not be null");
         this.type = type;
         this.output = output;
         this.args = args;

File: src/main/java/com/lambdaworks/redis/protocol/CommandArgs.java
Patch:
@@ -2,15 +2,14 @@
 
 package com.lambdaworks.redis.protocol;
 
-import static com.google.common.base.Preconditions.checkArgument;
-
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
 import com.lambdaworks.redis.codec.ByteArrayCodec;
 import com.lambdaworks.redis.codec.RedisCodec;
+import com.lambdaworks.redis.internal.LettuceAssert;
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.UnpooledByteBufAllocator;
@@ -40,7 +39,7 @@ public class CommandArgs<K, V> {
      * @param codec Codec used to encode/decode keys and values, must not be {@literal null}.
      */
     public CommandArgs(RedisCodec<K, V> codec) {
-        checkArgument(codec != null, "RedisCodec must not be null");
+        LettuceAssert.notNull(codec, "RedisCodec must not be null");
         this.codec = codec;
     }
 

File: src/main/java/com/lambdaworks/redis/protocol/CommandWrapper.java
Patch:
@@ -1,9 +1,9 @@
 package com.lambdaworks.redis.protocol;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.function.Consumer;
 
-import com.google.common.collect.Lists;
 import com.lambdaworks.redis.output.CommandOutput;
 import io.netty.buffer.ByteBuf;
 
@@ -15,7 +15,7 @@
 public class CommandWrapper<K, V, T> implements RedisCommand<K, V, T>, CompleteableCommand<T>, DecoratedCommand<K, V, T> {
 
     protected RedisCommand<K, V, T> command;
-    private List<Consumer<? super T>> onComplete = Lists.newArrayList();
+    private List<Consumer<? super T>> onComplete = new ArrayList<>();
 
     public CommandWrapper(RedisCommand<K, V, T> command) {
         this.command = command;

File: src/main/java/com/lambdaworks/redis/resource/DefaultEventLoopGroupProvider.java
Patch:
@@ -2,12 +2,12 @@
 
 import static com.lambdaworks.redis.resource.Futures.toBooleanPromise;
 
+import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
 
-import com.google.common.collect.Maps;
 import com.lambdaworks.redis.EpollProvider;
 
 import io.netty.channel.EventLoopGroup;
@@ -153,7 +153,7 @@ public Promise<Boolean> release(EventExecutorGroup eventLoopGroup, long quietPer
     private Class<?> getKey(EventExecutorGroup eventLoopGroup) {
         Class<?> key = null;
 
-        Map<Class<? extends EventExecutorGroup>, EventExecutorGroup> copy = Maps.newHashMap(eventLoopGroups);
+        Map<Class<? extends EventExecutorGroup>, EventExecutorGroup> copy = new HashMap<>(eventLoopGroups);
         for (Map.Entry<Class<? extends EventExecutorGroup>, EventExecutorGroup> entry : copy.entrySet()) {
             if (entry.getValue() == eventLoopGroup) {
                 key = entry.getKey();
@@ -173,7 +173,7 @@ public int threadPoolSize() {
     public Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {
         shutdownCalled = true;
 
-        Map<Class<? extends EventExecutorGroup>, EventExecutorGroup> copy = Maps.newHashMap(eventLoopGroups);
+        Map<Class<? extends EventExecutorGroup>, EventExecutorGroup> copy = new HashMap<>(eventLoopGroups);
 
         DefaultPromise<Boolean> overall = new DefaultPromise<Boolean>(GlobalEventExecutor.INSTANCE);
         DefaultPromise<Boolean> lastRelease = new DefaultPromise<Boolean>(GlobalEventExecutor.INSTANCE);

File: src/main/java/com/lambdaworks/redis/sentinel/RedisSentinelAsyncCommandsImpl.java
Patch:
@@ -1,7 +1,5 @@
 package com.lambdaworks.redis.sentinel;
 
-import static com.google.common.base.Preconditions.checkArgument;
-
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.util.List;
@@ -13,6 +11,7 @@
 import com.lambdaworks.redis.RedisSentinelAsyncConnection;
 import com.lambdaworks.redis.api.StatefulConnection;
 import com.lambdaworks.redis.codec.RedisCodec;
+import com.lambdaworks.redis.internal.LettuceAssert;
 import com.lambdaworks.redis.protocol.AsyncCommand;
 import com.lambdaworks.redis.protocol.Command;
 import com.lambdaworks.redis.protocol.RedisCommand;
@@ -59,7 +58,7 @@ protected void completeResult() {
             }
 
             if (!list.isEmpty()) {
-                checkArgument(list.size() == 2, "List must contain exact 2 entries (Hostname, Port)");
+                LettuceAssert.isTrue(list.size() == 2, "List must contain exact 2 entries (Hostname, Port)");
                 String hostname = (String) list.get(0);
                 String port = (String) list.get(1);
                 ref.set(new InetSocketAddress(hostname, Integer.parseInt(port)));

File: src/main/java/com/lambdaworks/redis/support/AbstractCdiBean.java
Patch:
@@ -12,7 +12,6 @@
 import javax.enterprise.inject.spi.BeanManager;
 import javax.enterprise.inject.spi.InjectionPoint;
 
-import com.google.common.collect.ImmutableSet;
 import com.lambdaworks.redis.RedisURI;
 import com.lambdaworks.redis.resource.ClientResources;
 
@@ -40,7 +39,7 @@ public AbstractCdiBean(Bean<RedisURI> redisURIBean, Bean<ClientResources> client
     @Override
     @SuppressWarnings("unchecked")
     public Set<Type> getTypes() {
-        return (Set<Type>) ImmutableSet.of((Type) getBeanClass());
+        return Collections.singleton(getBeanClass());
     }
 
     @Override
@@ -60,7 +59,7 @@ public Class<? extends Annotation> getScope() {
 
     @Override
     public Set<Class<? extends Annotation>> getStereotypes() {
-        Set<Class<? extends Annotation>> stereotypes = new HashSet<Class<? extends Annotation>>();
+        Set<Class<? extends Annotation>> stereotypes = new HashSet<>();
 
         for (Annotation annotation : getQualifiers()) {
             Class<? extends Annotation> annotationType = annotation.annotationType();

File: src/main/java/com/lambdaworks/redis/support/RedisClusterClientFactoryBean.java
Patch:
@@ -1,12 +1,12 @@
 package com.lambdaworks.redis.support;
 
-import static com.google.common.base.Preconditions.*;
-import static com.lambdaworks.redis.LettuceStrings.*;
+import static com.lambdaworks.redis.LettuceStrings.isNotEmpty;
 
 import java.net.URI;
 
 import com.lambdaworks.redis.RedisURI;
 import com.lambdaworks.redis.cluster.RedisClusterClient;
+import com.lambdaworks.redis.internal.LettuceAssert;
 
 /**
  * Factory Bean for {@link RedisClusterClient} instances. Needs either a {@link URI} or a {@link RedisURI} as input and allows
@@ -33,7 +33,7 @@ public void afterPropertiesSet() throws Exception {
         if (getRedisURI() == null) {
             URI uri = getUri();
 
-            checkArgument(!uri.getScheme().equals(RedisURI.URI_SCHEME_REDIS_SENTINEL),
+            LettuceAssert.isTrue(!uri.getScheme().equals(RedisURI.URI_SCHEME_REDIS_SENTINEL),
                     "Sentinel mode not supported when using RedisClusterClient");
 
             RedisURI redisURI = RedisURI.create(uri);

File: src/test/java/biz/paluch/redis/extensibility/MyPubSubConnection.java
Patch:
@@ -1,10 +1,8 @@
 package biz.paluch.redis.extensibility;
 
-import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import com.google.common.collect.Sets;
 import com.lambdaworks.redis.RedisChannelWriter;
 import com.lambdaworks.redis.codec.RedisCodec;
 import com.lambdaworks.redis.protocol.CommandType;

File: src/test/java/com/lambdaworks/apigenerator/CompilationUnitFactory.java
Patch:
@@ -82,7 +82,7 @@ public void createInterface() throws Exception {
         }
 
         if (!templateTypeDeclaration.getTypeParameters().isEmpty()) {
-            resultType.setTypeParameters(new ArrayList<TypeParameter>());
+            resultType.setTypeParameters(new ArrayList<>());
             for (TypeParameter typeParameter : templateTypeDeclaration.getTypeParameters()) {
                 resultType.getTypeParameters().add(new TypeParameter(typeParameter.getName(), typeParameter.getTypeBound()));
             }

File: src/test/java/com/lambdaworks/redis/AbstractTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.lambdaworks.redis;
 
 import java.util.Arrays;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
@@ -10,6 +9,7 @@
 
 import com.lambdaworks.CapturingLogRule;
 import com.lambdaworks.LoggingTestRule;
+import com.lambdaworks.redis.internal.LettuceSets;
 
 /**
  * @author Mark Paluch
@@ -51,6 +51,6 @@ public static ScoredValue<String> sv(double score, String value) {
     }
 
     public static Set<String> set(String... args) {
-        return new HashSet<String>(Arrays.asList(args));
+        return LettuceSets.newHashSet(args);
     }
 }

File: src/test/java/com/lambdaworks/redis/AsyncConnectionTest.java
Patch:
@@ -63,7 +63,7 @@ public void watch() throws Exception {
     @Test(timeout = 10000)
     public void futureListener() throws Exception {
 
-        final List<Object> run = new ArrayList<Object>();
+        final List<Object> run = new ArrayList<>();
 
         Runnable listener = new Runnable() {
             @Override
@@ -96,7 +96,7 @@ public void run() {
     @Test(timeout = 1000)
     public void futureListenerCompleted() throws Exception {
 
-        final List<Object> run = new ArrayList<Object>();
+        final List<Object> run = new ArrayList<>();
 
         Runnable listener = new Runnable() {
             @Override

File: src/test/java/com/lambdaworks/redis/KeyValueStreamingAdapter.java
Patch:
@@ -1,8 +1,8 @@
 package com.lambdaworks.redis;
 
+import java.util.LinkedHashMap;
 import java.util.Map;
 
-import com.google.common.collect.Maps;
 import com.lambdaworks.redis.output.KeyStreamingChannel;
 import com.lambdaworks.redis.output.KeyValueStreamingChannel;
 
@@ -16,7 +16,7 @@
  */
 public class KeyValueStreamingAdapter<K, V> implements KeyValueStreamingChannel<K, V> {
 
-    private final Map<K, V> map = Maps.newLinkedHashMap();
+    private final Map<K, V> map = new LinkedHashMap<>();
 
     @Override
     public void onKeyValue(K key, V value) {

File: src/test/java/com/lambdaworks/redis/ReactiveConnectionTest.java
Patch:
@@ -3,6 +3,7 @@
 import static com.google.code.tempusfugit.temporal.Duration.millis;
 import static org.assertj.core.api.Assertions.assertThat;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
@@ -16,7 +17,6 @@
 import rx.Observable;
 import rx.Subscriber;
 
-import com.google.common.collect.Lists;
 import com.lambdaworks.Delay;
 import com.lambdaworks.Wait;
 import com.lambdaworks.redis.api.StatefulRedisConnection;
@@ -71,7 +71,7 @@ public void getStatefulConnection() throws Exception {
     @Test
     public void testCancelCommand() throws Exception {
 
-        List<Object> result = Lists.newArrayList();
+        List<Object> result = new ArrayList<>();
         reactive.clientPause(1000).subscribe();
         reactive.set(key, value).subscribe(new CompletionSubscriber(result));
         Delay.delay(millis(100));
@@ -89,7 +89,7 @@ public void testEcho() throws Exception {
     @Test
     public void testMultiCancel() throws Exception {
 
-        List<Object> result = Lists.newArrayList();
+        List<Object> result = new ArrayList<>();
         reactive.clientPause(1000).subscribe();
 
         Observable<String> set = reactive.set(key, value);

File: src/test/java/com/lambdaworks/redis/ScoredValueStreamingAdapter.java
Patch:
@@ -10,7 +10,7 @@
  * @since 3.0
  */
 public class ScoredValueStreamingAdapter<T> implements ScoredValueStreamingChannel<T> {
-    private List<ScoredValue<T>> list = new ArrayList<ScoredValue<T>>();
+    private List<ScoredValue<T>> list = new ArrayList<>();
 
     @Override
     public void onValue(ScoredValue<T> value) {

File: src/test/java/com/lambdaworks/redis/cluster/AbstractClusterTest.java
Patch:
@@ -3,11 +3,11 @@
 import java.util.concurrent.TimeUnit;
 
 import com.lambdaworks.redis.FastShutdown;
+import com.lambdaworks.redis.internal.LettuceLists;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Rule;
 
-import com.google.common.collect.ImmutableList;
 import com.lambdaworks.redis.AbstractTest;
 import com.lambdaworks.redis.RedisURI;
 import com.lambdaworks.redis.TestSettings;
@@ -45,7 +45,7 @@ public class AbstractClusterTest extends AbstractTest {
 
     @BeforeClass
     public static void setupClusterClient() throws Exception {
-        clusterClient = RedisClusterClient.create(ImmutableList.of(RedisURI.Builder.redis(host, port1).build()));
+        clusterClient = RedisClusterClient.create(LettuceLists.unmodifiableList(RedisURI.Builder.redis(host, port1).build()));
     }
 
     @AfterClass

File: src/test/java/com/lambdaworks/redis/cluster/ClusterCommandInternalsTest.java
Patch:
@@ -2,13 +2,13 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
 import org.junit.Before;
 import org.junit.Test;
 
-import com.google.common.collect.Lists;
 import com.lambdaworks.redis.codec.Utf8StringCodec;
 import com.lambdaworks.redis.output.StatusOutput;
 import com.lambdaworks.redis.protocol.AsyncCommand;
@@ -52,7 +52,7 @@ public void testComplete() throws Exception {
     @Test
     public void testCompleteListener() throws Exception {
 
-        final List<String> someList = Lists.newArrayList();
+        final List<String> someList = new ArrayList<>();
 
         AsyncCommand<?, ?, ?> asyncCommand = new AsyncCommand<>(sut);
 

File: src/test/java/com/lambdaworks/redis/cluster/ClusterCommandTest.java
Patch:
@@ -9,6 +9,7 @@
 import java.util.concurrent.TimeoutException;
 
 import com.lambdaworks.redis.cluster.api.async.RedisClusterAsyncCommands;
+import com.lambdaworks.redis.internal.LettuceLists;
 import org.junit.After;
 import org.junit.AfterClass;
 import org.junit.Before;
@@ -18,7 +19,6 @@
 import org.junit.runners.MethodSorters;
 
 import com.google.code.tempusfugit.temporal.WaitFor;
-import com.google.common.collect.ImmutableList;
 import com.lambdaworks.redis.FastShutdown;
 import com.lambdaworks.redis.RedisAsyncConnection;
 import com.lambdaworks.redis.RedisClient;
@@ -46,7 +46,7 @@ public class ClusterCommandTest extends AbstractClusterTest {
     @BeforeClass
     public static void setupClient() throws Exception {
         client = RedisClient.create(RedisURI.Builder.redis(host, port1).build());
-        clusterClient = RedisClusterClient.create(ImmutableList.of(RedisURI.Builder.redis(host, port1).build()));
+        clusterClient = RedisClusterClient.create(LettuceLists.newList(RedisURI.Builder.redis(host, port1).build()));
 
     }
 

File: src/test/java/com/lambdaworks/redis/cluster/ClusterReactiveCommandTest.java
Patch:
@@ -5,6 +5,7 @@
 
 import java.util.List;
 
+import com.lambdaworks.redis.internal.LettuceLists;
 import org.junit.After;
 import org.junit.AfterClass;
 import org.junit.Before;
@@ -15,7 +16,6 @@
 
 import rx.Observable;
 
-import com.google.common.collect.ImmutableList;
 import com.lambdaworks.redis.FastShutdown;
 import com.lambdaworks.redis.RedisClient;
 import com.lambdaworks.redis.RedisURI;
@@ -37,7 +37,7 @@ public class ClusterReactiveCommandTest extends AbstractClusterTest {
     public static void setupClient() throws Exception {
         setupClusterClient();
         client = RedisClient.create(RedisURI.Builder.redis(host, port1).build());
-        clusterClient = RedisClusterClient.create(ImmutableList.of(RedisURI.Builder.redis(host, port1).build()));
+        clusterClient = RedisClusterClient.create(LettuceLists.unmodifiableList(RedisURI.Builder.redis(host, port1).build()));
 
     }
 

File: src/test/java/com/lambdaworks/redis/cluster/PipelinedRedisFutureTest.java
Patch:
@@ -4,7 +4,7 @@
 
 import org.junit.Test;
 
-import com.google.common.collect.Maps;
+import java.util.HashMap;
 
 /**
  * @author Mark Paluch
@@ -18,7 +18,7 @@ public void testComplete() throws Exception {
 
         String other = "other";
 
-        sut = new PipelinedRedisFuture<>(Maps.newHashMap(), o -> other);
+        sut = new PipelinedRedisFuture<>(new HashMap<>(), o -> other);
 
         sut.complete("");
         assertThat(sut.get()).isEqualTo(other);
@@ -31,7 +31,7 @@ public void testCompleteExceptionally() throws Exception {
 
         String other = "other";
 
-        sut = new PipelinedRedisFuture<>(Maps.newHashMap(), o -> other);
+        sut = new PipelinedRedisFuture<>(new HashMap<>(), o -> other);
 
         sut.completeExceptionally(new Exception());
         assertThat(sut.get()).isEqualTo(other);

File: src/test/java/com/lambdaworks/redis/cluster/RedisClusterReadFromTest.java
Patch:
@@ -11,12 +11,13 @@
 import org.junit.Test;
 import org.junit.runners.MethodSorters;
 
-import com.google.common.collect.ImmutableList;
 import com.lambdaworks.redis.FastShutdown;
 import com.lambdaworks.redis.RedisURI;
 import com.lambdaworks.redis.cluster.api.StatefulRedisClusterConnection;
 import com.lambdaworks.redis.cluster.api.sync.RedisAdvancedClusterCommands;
 
+import java.util.Collections;
+
 @FixMethodOrder(MethodSorters.NAME_ASCENDING)
 @SuppressWarnings("unchecked")
 public class RedisClusterReadFromTest extends AbstractClusterTest {
@@ -27,7 +28,7 @@ public class RedisClusterReadFromTest extends AbstractClusterTest {
     @BeforeClass
     public static void setupClient() throws Exception {
         setupClusterClient();
-        clusterClient = new RedisClusterClient(ImmutableList.of(RedisURI.Builder.redis(host, port1).build()));
+        clusterClient = new RedisClusterClient(Collections.singletonList(RedisURI.Builder.redis(host, port1).build()));
     }
 
     @AfterClass

File: src/test/jmh/com/lambdaworks/redis/protocol/CommandHandlerBenchmark.java
Patch:
@@ -13,7 +13,7 @@
 import io.netty.channel.embedded.EmbeddedChannel;
 
 /**
- * Benchmark for {@link Command}. Test cases:
+ * Benchmark for {@link CommandHandler}. Test cases:
  * <ul>
  * <li>user command writes</li>
  * <li>netty (in-eventloop) writes</li>

File: src/test/java/com/lambdaworks/redis/ClientTest.java
Patch:
@@ -68,8 +68,6 @@ public void statefulConnectionFromReactive() throws Exception {
         assertThat(async.getStatefulConnection().reactive().getStatefulConnection()).isSameAs(async.getStatefulConnection());
     }
 
-
-
     @Test
     public void listenerTest() throws Exception {
 

File: src/main/java/com/lambdaworks/redis/AbstractRedisClient.java
Patch:
@@ -217,7 +217,7 @@ protected <K, V, T extends RedisChannelHandler<K, V>> T initializeChannel(Connec
         SocketAddress redisAddress = connectionBuilder.socketAddress();
         try {
 
-            logger.debug("Connecting to Redis, address: " + redisAddress);
+            logger.debug("Connecting to Redis at {}", redisAddress);
 
             Bootstrap redisBootstrap = connectionBuilder.bootstrap();
             RedisChannelInitializer initializer = connectionBuilder.build();

File: src/main/java/com/lambdaworks/redis/cluster/RedisClusterClient.java
Patch:
@@ -794,7 +794,9 @@ private Supplier<SocketAddress> getSocketAddressSupplier(
         final RoundRobinSocketAddressSupplier socketAddressSupplier = new RoundRobinSocketAddressSupplier(partitions, sort);
         return () -> {
             if (partitions.isEmpty()) {
-                return getFirstUri().getResolvedAddress();
+                SocketAddress socketAddress = getFirstUri().getResolvedAddress();
+                logger.debug("Resolved SocketAddress {} using {}", socketAddress, getFirstUri());
+                return socketAddress;
             }
 
             return socketAddressSupplier.get();

File: src/main/java/com/lambdaworks/redis/protocol/ConnectionWatchdog.java
Patch:
@@ -214,7 +214,7 @@ public void run(Timeout timeout) throws Exception {
 
     private void reconnect(InternalLogLevel infoLevel, InternalLogLevel warnLevel) throws Exception {
 
-        logger.log(infoLevel, "Reconnecting, last destination was " + remoteAddress);
+        logger.log(infoLevel, "Reconnecting, last destination was {}", remoteAddress);
 
         if (socketAddressSupplier != null) {
             try {
@@ -228,6 +228,7 @@ private void reconnect(InternalLogLevel infoLevel, InternalLogLevel warnLevel) t
         try {
             long timeLeft = timeoutUnit.toNanos(timeout);
             long start = System.nanoTime();
+            logger.debug("Connecting to Redis at {}", remoteAddress);
             currentFuture = bootstrap.connect(remoteAddress);
             if (!currentFuture.await(timeLeft, TimeUnit.NANOSECONDS)) {
                 if (currentFuture.isCancellable()) {
@@ -256,7 +257,7 @@ private void reconnect(InternalLogLevel infoLevel, InternalLogLevel warnLevel) t
             try {
                 timeLeft -= System.nanoTime() - start;
                 channelInitializer.channelInitialized().get(Math.max(0, timeLeft), TimeUnit.NANOSECONDS);
-                logger.log(infoLevel, "Reconnected to " + remoteAddress);
+                logger.log(infoLevel, "Reconnected to {}", remoteAddress);
             } catch (TimeoutException e) {
                 channelInitializer.channelInitialized().cancel(true);
             } catch (Exception e) {

File: src/test/java/biz/paluch/redis/extensibility/MyExtendedRedisClientTest.java
Patch:
@@ -49,4 +49,4 @@ public void testPubsub() throws Exception {
         connection.close();
 
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/ClientOptionsTest.java
Patch:
@@ -234,4 +234,4 @@ protected void run(RedisClient client) throws Exception {
             }
         };
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/JavaRuntimeTest.java
Patch:
@@ -27,4 +27,4 @@ public void testJava9() {
     public void testNotPresentClass() {
         assertThat(JavaRuntime.isPresent("total.fancy.class.name")).isFalse();
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/RedisClientConnectionTest.java
Patch:
@@ -161,4 +161,4 @@ public void connectSentineAsynclOwnUri() throws Exception {
     public void connectSentinelAsyncCodecOwnUri() throws Exception {
         client.connectSentinelAsync(new Utf8StringCodec(), redis(host, port).build()).close();
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/RedisClientTest.java
Patch:
@@ -108,4 +108,4 @@ private Map<Class<? extends EventExecutorGroup>, EventExecutorGroup> getExecutor
         eventLoopGroupsField.setAccessible(true);
         return (Map) eventLoopGroupsField.get(clientResources.eventLoopGroupProvider());
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/TimeTest.java
Patch:
@@ -7,6 +7,8 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 public class TimeTest {
     RedisClient client = RedisClient.create();
 
@@ -22,6 +24,6 @@ public void after() throws Exception {
 
     @Test
     public void testTime() throws Exception {
-        Assert.assertEquals(15000, client.makeTimeout());
+        assertThat(client.makeTimeout()).isEqualTo(15000);
     }
 }

File: src/test/java/com/lambdaworks/redis/cluster/ClusterClientOptionsTest.java
Patch:
@@ -29,4 +29,4 @@ public void testCopy() throws Exception {
         assertThat(copy.isSuspendReconnectOnProtocolFailure()).isEqualTo(options.isSuspendReconnectOnProtocolFailure());
         assertThat(copy.getMaxRedirects()).isEqualTo(options.getMaxRedirects());
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/cluster/ClusterTopologyRefreshTest.java
Patch:
@@ -249,4 +249,4 @@ protected void createClientCommand(Map<RedisURI, AsyncCommand<String, String, St
 
         commands.put(RedisURI.create("redis://localhost:" + duration), command1);
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/cluster/LatencyComparatorTest.java
Patch:
@@ -86,4 +86,4 @@ protected void runTest(Map<String, Long> map, List<RedisClusterNodeSnapshot> exp
 
         assertThat(result).containsExactly(expectation.toArray(new RedisClusterNodeSnapshot[expectation.size()]));
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/cluster/ReadFromTest.java
Patch:
@@ -103,4 +103,4 @@ public Iterator<RedisNodeDescription> iterator() {
         };
 
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/cluster/ReadOnlyCommandsTest.java
Patch:
@@ -22,4 +22,4 @@ public void testResolvableCommandNames() throws Exception {
             assertThat(readOnlyCommand.name()).isEqualTo(CommandType.valueOf(readOnlyCommand.name()).name());
         }
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/cluster/RedisClusterClientTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import static com.lambdaworks.redis.cluster.ClusterTestUtil.getOwnPartition;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
+import static org.assertj.core.api.Assertions.fail;
 
 import java.util.ArrayList;
 import java.util.List;

File: src/test/java/com/lambdaworks/redis/cluster/RedisClusterReadFromTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.lambdaworks.redis.cluster;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
 
 import com.lambdaworks.redis.ReadFrom;
 import org.junit.After;

File: src/test/java/com/lambdaworks/redis/cluster/RoundRobinSocketAddressSupplierTest.java
Patch:
@@ -70,4 +70,4 @@ public void partitionTableChanges() throws Exception {
         assertThat(sut.get()).isEqualTo(hap1.getResolvedAddress());
     }
 
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/cluster/commands/rx/StringClusterRxCommandTest.java
Patch:
@@ -55,10 +55,10 @@ public void msetnx() throws Exception {
         Map<String, String> map = Maps.newLinkedHashMap();
         map.put("one", "1");
         map.put("two", "2");
-        assertTrue(redis.msetnx(map));
+        assertThat(redis.msetnx(map)).isTrue();
         redis.del("one");
-        assertTrue(redis.msetnx(map));
-        Assert.assertEquals("2", redis.get("two"));
+        assertThat(redis.msetnx(map)).isTrue();
+        assertThat(redis.get("two")).isEqualTo("2");
     }
 
     @Test

File: src/test/java/com/lambdaworks/redis/codec/CompressionCodecTest.java
Patch:
@@ -74,4 +74,4 @@ private byte[] toBytes(ByteBuffer buffer) {
         }
         return bytes;
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/masterslave/MasterSlaveSentinelTest.java
Patch:
@@ -54,4 +54,4 @@ protected void assertThatServerIs(String server, String expectation) {
         assertThat(matcher.group(1)).isEqualTo(expectation);
     }
 
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/masterslave/MasterSlaveTest.java
Patch:
@@ -103,4 +103,4 @@ protected MasterSlaveConnectionProvider getConnectionProvider() {
         MasterSlaveChannelWriter<String, String> writer = connection.getChannelWriter();
         return writer.getMasterSlaveConnectionProvider();
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/masterslave/MasterSlaveTopologyProviderTest.java
Patch:
@@ -88,4 +88,4 @@ public void testSlaves() throws Exception {
         assertThat(slave2.getUri().getHost()).isEqualTo("127.0.0.1");
         assertThat(slave2.getUri().getPort()).isEqualTo(6484);
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/resource/DefaultEventLoopGroupProviderTest.java
Patch:
@@ -32,4 +32,4 @@ public void getAfterShutdown() throws Exception {
         sut.shutdown(10, 10, TimeUnit.MILLISECONDS).get();
         sut.allocate(NioEventLoopGroup.class);
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/redis/sentinel/SentinelCommandTest.java
Patch:
@@ -3,7 +3,7 @@
 import static com.google.code.tempusfugit.temporal.Duration.millis;
 import static com.lambdaworks.redis.TestSettings.hostAddr;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
+import static org.assertj.core.api.Assertions.fail;
 
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;

File: src/test/java/com/lambdaworks/redis/support/RedisClusterClientFactoryBeanTest.java
Patch:
@@ -48,4 +48,4 @@ public void validUriPasswordOverride() throws Exception {
         assertThat(sut.getRedisURI().getHost()).isEqualTo("host");
         assertThat(sut.getRedisURI().getPassword()).isEqualTo("thepassword".toCharArray());
     }
-}
\ No newline at end of file
+}

File: src/test/java/com/lambdaworks/apigenerator/CreateSyncAsyncRxApis.java
Patch:
@@ -8,7 +8,7 @@
  */
 @RunWith(Suite.class)
 @Suite.SuiteClasses({ CreateAsyncApi.class, CreateSyncApi.class, CreateReactiveApi.class,
-        CreateAsyncNodeSelectionClusterApi.class })
+        CreateAsyncNodeSelectionClusterApi.class, CreateSyncNodeSelectionClusterApi.class })
 public class CreateSyncAsyncRxApis {
 
 }

File: src/main/java/com/lambdaworks/redis/resource/DefaultClientResources.java
Patch:
@@ -93,7 +93,7 @@ protected DefaultClientResources(Builder builder) {
 
         if (builder.eventExecutorGroup == null) {
             int computationThreadPoolSize = builder.computationThreadPoolSize;
-            if (computationThreadPoolSize < MIN_IO_THREADS) {
+            if (computationThreadPoolSize < MIN_COMPUTATION_THREADS) {
 
                 logger.info("computationThreadPoolSize is less than {} ({}), setting to: {}", MIN_COMPUTATION_THREADS,
                         computationThreadPoolSize, MIN_COMPUTATION_THREADS);

File: src/main/java/com/lambdaworks/redis/protocol/CommandArgs.java
Patch:
@@ -21,7 +21,7 @@
 public class CommandArgs<K, V> {
     private static final byte[] CRLF = "\r\n".getBytes(LettuceCharsets.ASCII);
 
-    private final RedisCodec<K, V> codec;
+    protected final RedisCodec<K, V> codec;
     private ByteBuffer buffer;
     private ByteBuffer firstEncodedKey;
     private int count;
@@ -137,7 +137,7 @@ public CommandArgs<K, V> add(ProtocolKeyword keyword) {
         return write(keyword.getBytes());
     }
 
-    private CommandArgs<K, V> write(ByteBuffer arg) {
+    protected CommandArgs<K, V> write(ByteBuffer arg) {
         buffer.mark();
 
         if (buffer.remaining() < arg.remaining()) {

File: src/test/java/com/lambdaworks/redis/cluster/RoundRobinSocketAddressSupplierTest.java
Patch:
@@ -43,7 +43,7 @@ public void before() throws Exception {
     @Test
     public void noOffset() throws Exception {
 
-        RoundRobinSocketAddressSupplier sut = new RoundRobinSocketAddressSupplier(partitions);
+        RoundRobinSocketAddressSupplier sut = new RoundRobinSocketAddressSupplier(partitions, redisClusterNodes -> redisClusterNodes);
 
         assertThat(sut.get()).isEqualTo(hap1.getResolvedAddress());
         assertThat(sut.get()).isEqualTo(hap2.getResolvedAddress());
@@ -56,7 +56,7 @@ public void noOffset() throws Exception {
     @Test
     public void partitionTableChanges() throws Exception {
 
-        RoundRobinSocketAddressSupplier sut = new RoundRobinSocketAddressSupplier(partitions);
+        RoundRobinSocketAddressSupplier sut = new RoundRobinSocketAddressSupplier(partitions, redisClusterNodes -> redisClusterNodes);
 
         assertThat(sut.get()).isEqualTo(hap1.getResolvedAddress());
         assertThat(sut.get()).isEqualTo(hap2.getResolvedAddress());

File: src/main/java/com/lambdaworks/redis/resource/EventLoopGroupProvider.java
Patch:
@@ -27,7 +27,8 @@ public interface EventLoopGroupProvider {
 
     /**
      * Retrieve a {@link EventLoopGroup} for the type {@code type}. Do not terminate or shutdown the instance. Call the
-     * {@link #shutdown(long, long, TimeUnit)} method to free the resources.
+     * {@link #release(EventExecutorGroup, long, long, TimeUnit)} to release an individual instance or
+     * {@link #shutdown(long, long, TimeUnit)} method to free the all resources.
      *
      * @param type type of the event loop group, must not be {@literal null}
      * @param <T> type parameter
@@ -44,7 +45,7 @@ public interface EventLoopGroupProvider {
     int threadPoolSize();
 
     /**
-     * Release the {@code eventLoopGroup} instance. The method will shutdown/terminate the event loop group if it is no longer
+     * Release a {@code eventLoopGroup} instance. The method will shutdown/terminate the event loop group if it is no longer
      * needed.
      * 
      * @param eventLoopGroup the eventLoopGroup instance, must not be {@literal null}

File: src/main/java/com/lambdaworks/redis/api/rx/BaseRedisReactiveCommands.java
Patch:
@@ -29,15 +29,15 @@ public interface BaseRedisReactiveCommands<K, V> extends AutoCloseable {
     /**
      * Lists the currently *active channels*.
      * 
-     * @return List&lt;K&gt; array-reply a list of active channels, optionally matching the specified pattern.
+     * @return K array-reply a list of active channels, optionally matching the specified pattern.
      */
     Observable<K> pubsubChannels();
 
     /**
      * Lists the currently *active channels*.
      * 
      * @param channel the key
-     * @return List&lt;K&gt; array-reply a list of active channels, optionally matching the specified pattern.
+     * @return K array-reply a list of active channels, optionally matching the specified pattern.
      */
     Observable<K> pubsubChannels(K channel);
 
@@ -67,7 +67,7 @@ public interface BaseRedisReactiveCommands<K, V> extends AutoCloseable {
     /**
      * Return the role of the instance in the context of replication.
      *
-     * @return List&lt;Object&gt; array-reply where the first element is one of master, slave, sentinel and the additional
+     * @return Object array-reply where the first element is one of master, slave, sentinel and the additional
      *         elements are role-specific.
      */
     Observable<Object> role();

File: src/main/java/com/lambdaworks/redis/api/rx/RedisHashReactiveCommands.java
Patch:
@@ -97,7 +97,7 @@ public interface RedisHashReactiveCommands<K, V> {
      * Get all the fields in a hash.
      * 
      * @param key the key
-     * @return List&lt;K&gt; array-reply list of fields in the hash, or an empty list when {@code key} does not exist.
+     * @return K array-reply list of fields in the hash, or an empty list when {@code key} does not exist.
      */
     Observable<K> hkeys(K key);
 
@@ -124,7 +124,7 @@ public interface RedisHashReactiveCommands<K, V> {
      * 
      * @param key the key
      * @param fields the field type: key
-     * @return List&lt;V&gt; array-reply list of values associated with the given fields, in the same
+     * @return V array-reply list of values associated with the given fields, in the same
      */
     Observable<V> hmget(K key, K... fields);
 
@@ -264,7 +264,7 @@ public interface RedisHashReactiveCommands<K, V> {
      * Get all the values in a hash.
      *
      * @param key the key
-     * @return List&lt;V&gt; array-reply list of values in the hash, or an empty list when {@code key} does not exist.
+     * @return V array-reply list of values in the hash, or an empty list when {@code key} does not exist.
      */
     Observable<V> hvals(K key);
 

File: src/main/java/com/lambdaworks/redis/api/rx/RedisKeyReactiveCommands.java
Patch:
@@ -94,7 +94,7 @@ public interface RedisKeyReactiveCommands<K, V> {
      * Find all keys matching the given pattern.
      * 
      * @param pattern the pattern type: patternkey (pattern)
-     * @return List&lt;K&gt; array-reply list of keys matching {@code pattern}.
+     * @return K array-reply list of keys matching {@code pattern}.
      */
     Observable<K> keys(K pattern);
 
@@ -250,7 +250,7 @@ public interface RedisKeyReactiveCommands<K, V> {
      * Sort the elements in a list, set or sorted set.
      * 
      * @param key the key
-     * @return List&lt;V&gt; array-reply list of sorted elements.
+     * @return V array-reply list of sorted elements.
      */
     Observable<V> sort(K key);
 
@@ -268,7 +268,7 @@ public interface RedisKeyReactiveCommands<K, V> {
      * 
      * @param key the key
      * @param sortArgs sort arguments
-     * @return List&lt;V&gt; array-reply list of sorted elements.
+     * @return V array-reply list of sorted elements.
      */
     Observable<V> sort(K key, SortArgs sortArgs);
 

File: src/main/java/com/lambdaworks/redis/api/rx/RedisListReactiveCommands.java
Patch:
@@ -114,7 +114,7 @@ public interface RedisListReactiveCommands<K, V> {
      * @param key the key
      * @param start the start type: long
      * @param stop the stop type: long
-     * @return List&lt;V&gt; array-reply list of elements in the specified range.
+     * @return V array-reply list of elements in the specified range.
      */
     Observable<V> lrange(K key, long start, long stop);
 

File: src/main/java/com/lambdaworks/redis/api/rx/RedisScriptingReactiveCommands.java
Patch:
@@ -65,7 +65,7 @@ public interface RedisScriptingReactiveCommands<K, V> {
      * Check existence of scripts in the script cache.
      * 
      * @param digests script digests
-     * @return List&lt;Boolean&gt; array-reply The command returns an array of integers that correspond to the specified SHA1
+     * @return Boolean array-reply The command returns an array of integers that correspond to the specified SHA1
      *         digest arguments. For every corresponding SHA1 digest of a script that actually exists in the script cache, an 1
      *         is returned, otherwise 0 is returned.
      */

File: src/main/java/com/lambdaworks/redis/api/rx/RedisStringReactiveCommands.java
Patch:
@@ -218,7 +218,7 @@ public interface RedisStringReactiveCommands<K, V> {
      * Get the values of all the given keys.
      * 
      * @param keys the key
-     * @return List&lt;V&gt; array-reply list of values at the specified keys.
+     * @return V array-reply list of values at the specified keys.
      */
     Observable<V> mget(K... keys);
 

File: src/main/java/com/lambdaworks/redis/api/rx/RedisTransactionalReactiveCommands.java
Patch:
@@ -24,7 +24,7 @@ public interface RedisTransactionalReactiveCommands<K, V> {
     /**
      * Execute all commands issued after MULTI.
      *
-     * @return List&lt;Object&gt; array-reply each element being the reply to each of the commands in the atomic transaction.
+     * @return Object array-reply each element being the reply to each of the commands in the atomic transaction.
      *
      *         When using {@code WATCH}, {@code EXEC} can return a
      */

File: src/main/java/com/lambdaworks/redis/sentinel/api/rx/RedisSentinelReactiveCommands.java
Patch:
@@ -45,7 +45,7 @@ public interface RedisSentinelReactiveCommands<K, V> extends Closeable {
      * Provides a list of slaves for the master with the specified name.
      * 
      * @param key the key
-     * @return List&lt;Map&lt;K, V&gt;&gt;
+     * @return Map&lt;K, V&gt;
      */
     Observable<Map<K, V>> slaves(K key);
 

File: src/test/java/com/lambdaworks/apigenerator/CreateAsyncApi.java
Patch:
@@ -65,7 +65,7 @@ public CreateAsyncApi(String templateName) {
         }
 
         factory = new CompilationUnitFactory(templateFile, Constants.SOURCES, targetPackage, targetName, commentMutator(),
-                methodTypeMutator(), methodDeclaration -> true, importSupplier(), typeMutator());
+                methodTypeMutator(), methodDeclaration -> true, importSupplier(), typeMutator(), null);
     }
 
     private Consumer<ClassOrInterfaceDeclaration> typeMutator() {

File: src/test/java/com/lambdaworks/apigenerator/CreateAsyncNodeSelectionClusterApi.java
Patch:
@@ -58,7 +58,7 @@ public CreateAsyncNodeSelectionClusterApi(String templateName) {
 
         // todo: remove AutoCloseable from BaseNodeSelectionAsyncCommands
         factory = new CompilationUnitFactory(templateFile, Constants.SOURCES, targetPackage, targetName, commentMutator(),
-                methodTypeMutator(), methodFilter(), importSupplier(), null);
+                methodTypeMutator(), methodFilter(), importSupplier(), null, null);
     }
 
     /**

File: src/test/java/com/lambdaworks/apigenerator/CreateSyncApi.java
Patch:
@@ -52,7 +52,7 @@ public CreateSyncApi(String templateName) {
         }
 
         factory = new CompilationUnitFactory(templateFile, Constants.SOURCES, targetPackage, targetName, commentMutator(),
-                methodTypeMutator(), methodDeclaration -> true, importSupplier(), null);
+                methodTypeMutator(), methodDeclaration -> true, importSupplier(), null, null);
     }
 
     /**

File: src/test/java/com/lambdaworks/apigenerator/CreateSyncNodeSelectionClusterApi.java
Patch:
@@ -58,7 +58,7 @@ public CreateSyncNodeSelectionClusterApi(String templateName) {
 
         // todo: remove AutoCloseable from BaseNodeSelectionAsyncCommands
         factory = new CompilationUnitFactory(templateFile, Constants.SOURCES, targetPackage, targetName, commentMutator(),
-                methodTypeMutator(), methodFilter(), importSupplier(), null);
+                methodTypeMutator(), methodFilter(), importSupplier(), null, null);
     }
 
     /**

File: src/main/java/com/lambdaworks/redis/cluster/ClusterTopologyRefresh.java
Patch:
@@ -232,6 +232,9 @@ private Map<RedisURI, StatefulRedisConnection<String, String>> getConnections(It
 
             try {
                 StatefulRedisConnection<String, String> connection = client.connectToNode(redisURI.getResolvedAddress());
+                if(redisURI.getPassword() != null && redisURI.getPassword().length != 0) {
+                    connection.sync().auth(new String(redisURI.getPassword()));
+                }
                 connections.put(redisURI, connection);
             } catch (RedisConnectionException e) {
                 if (logger.isDebugEnabled()) {

File: src/main/java/com/lambdaworks/redis/cluster/ClusterTopologyRefresh.java
Patch:
@@ -221,7 +221,7 @@ protected Map<RedisURI, RedisAsyncConnectionImpl<String, String>> getConnections
                 RedisAsyncConnectionImpl<String, String> connection = client.connectAsyncImpl(redisURI.getResolvedAddress());
                 if (redisURI.getPassword() != null) {
                     String password = new String(redisURI.getPassword());
-                    if (!"".equals(password)) {
+                    if (!"".equals(password.trim())) {
                         connection.auth(password);
                     }
                 }

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnectionImpl.java
Patch:
@@ -813,7 +813,7 @@ public RedisFuture<String> set(K key, V value) {
     }
 
     @Override
-    public RedisFuture<V> set(K key, V value, SetArgs setArgs) {
+    public RedisFuture<String> set(K key, V value, SetArgs setArgs) {
         return dispatch(commandBuilder.set(key, value, setArgs));
     }
 

File: src/main/java/com/lambdaworks/redis/RedisCommandBuilder.java
Patch:
@@ -794,10 +794,10 @@ public Command<K, V, String> set(K key, V value) {
         return createCommand(SET, new StatusOutput<K, V>(codec), key, value);
     }
 
-    public Command<K, V, V> set(K key, V value, SetArgs setArgs) {
+    public Command<K, V, String> set(K key, V value, SetArgs setArgs) {
         CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).addValue(value);
         setArgs.build(args);
-        return createCommand(SET, new ValueOutput<K, V>(codec), args);
+        return createCommand(SET, new StatusOutput<K, V>(codec), args);
     }
 
     public Command<K, V, Long> setbit(K key, long offset, int value) {

File: src/main/java/com/lambdaworks/redis/RedisStringsAsyncConnection.java
Patch:
@@ -271,7 +271,7 @@ public interface RedisStringsAsyncConnection<K, V> {
      * 
      * @return RedisFuture&lt;V&gt; simple-string-reply {@code OK} if {@code SET} was executed correctly.
      */
-    RedisFuture<V> set(K key, V value, SetArgs setArgs);
+    RedisFuture<String> set(K key, V value, SetArgs setArgs);
 
     /**
      * Sets or clears the bit at offset in the string value stored at key.

File: src/main/java/com/lambdaworks/redis/RedisStringsConnection.java
Patch:
@@ -265,9 +265,9 @@ public interface RedisStringsConnection<K, V> {
      * @param value the value
      * @param setArgs the setArgs
      * 
-     * @return V simple-string-reply {@code OK} if {@code SET} was executed correctly.
+     * @return String simple-string-reply {@code OK} if {@code SET} was executed correctly.
      */
-    V set(K key, V value, SetArgs setArgs);
+    String set(K key, V value, SetArgs setArgs);
 
     /**
      * Sets or clears the bit at offset in the string value stored at key.

File: src/main/java/com/lambdaworks/redis/AbstractRedisAsyncCommands.java
Patch:
@@ -817,7 +817,7 @@ public RedisFuture<String> set(K key, V value) {
     }
 
     @Override
-    public RedisFuture<V> set(K key, V value, SetArgs setArgs) {
+    public RedisFuture<String> set(K key, V value, SetArgs setArgs) {
         return dispatch(commandBuilder.set(key, value, setArgs));
     }
 

File: src/main/java/com/lambdaworks/redis/AbstractRedisReactiveCommands.java
Patch:
@@ -801,7 +801,7 @@ public Observable<String> set(K key, V value) {
     }
 
     @Override
-    public Observable<V> set(K key, V value, SetArgs setArgs) {
+    public Observable<String> set(K key, V value, SetArgs setArgs) {
         return createObservable(() -> commandBuilder.set(key, value, setArgs));
     }
 

File: src/main/java/com/lambdaworks/redis/RedisCommandBuilder.java
Patch:
@@ -804,10 +804,10 @@ public Command<K, V, String> set(K key, V value) {
         return createCommand(SET, new StatusOutput<K, V>(codec), key, value);
     }
 
-    public Command<K, V, V> set(K key, V value, SetArgs setArgs) {
+    public Command<K, V, String> set(K key, V value, SetArgs setArgs) {
         CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).addValue(value);
         setArgs.build(args);
-        return createCommand(SET, new ValueOutput<K, V>(codec), args);
+        return createCommand(SET, new StatusOutput<K, V>(codec), args);
     }
 
     public Command<K, V, Long> setbit(K key, long offset, int value) {

File: src/main/java/com/lambdaworks/redis/RedisStringsAsyncConnection.java
Patch:
@@ -273,7 +273,7 @@ public interface RedisStringsAsyncConnection<K, V> {
      * 
      * @return RedisFuture&lt;V&gt; simple-string-reply {@code OK} if {@code SET} was executed correctly.
      */
-    RedisFuture<V> set(K key, V value, SetArgs setArgs);
+    RedisFuture<String> set(K key, V value, SetArgs setArgs);
 
     /**
      * Sets or clears the bit at offset in the string value stored at key.

File: src/main/java/com/lambdaworks/redis/RedisStringsConnection.java
Patch:
@@ -267,9 +267,9 @@ public interface RedisStringsConnection<K, V> {
      * @param value the value
      * @param setArgs the setArgs
      * 
-     * @return V simple-string-reply {@code OK} if {@code SET} was executed correctly.
+     * @return String simple-string-reply {@code OK} if {@code SET} was executed correctly.
      */
-    V set(K key, V value, SetArgs setArgs);
+    String set(K key, V value, SetArgs setArgs);
 
     /**
      * Sets or clears the bit at offset in the string value stored at key.

File: src/main/java/com/lambdaworks/redis/api/async/RedisStringAsyncCommands.java
Patch:
@@ -267,9 +267,9 @@ public interface RedisStringAsyncCommands<K, V> {
      * @param value the value
      * @param setArgs the setArgs
      * 
-     * @return V simple-string-reply {@code OK} if {@code SET} was executed correctly.
+     * @return String simple-string-reply {@code OK} if {@code SET} was executed correctly.
      */
-    RedisFuture<V> set(K key, V value, SetArgs setArgs);
+    RedisFuture<String> set(K key, V value, SetArgs setArgs);
 
     /**
      * Sets or clears the bit at offset in the string value stored at key.

File: src/main/java/com/lambdaworks/redis/api/rx/RedisStringReactiveCommands.java
Patch:
@@ -267,9 +267,9 @@ public interface RedisStringReactiveCommands<K, V> {
      * @param value the value
      * @param setArgs the setArgs
      * 
-     * @return V simple-string-reply {@code OK} if {@code SET} was executed correctly.
+     * @return String simple-string-reply {@code OK} if {@code SET} was executed correctly.
      */
-    Observable<V> set(K key, V value, SetArgs setArgs);
+    Observable<String> set(K key, V value, SetArgs setArgs);
 
     /**
      * Sets or clears the bit at offset in the string value stored at key.

File: src/main/java/com/lambdaworks/redis/api/sync/RedisStringCommands.java
Patch:
@@ -266,9 +266,9 @@ public interface RedisStringCommands<K, V> {
      * @param value the value
      * @param setArgs the setArgs
      * 
-     * @return V simple-string-reply {@code OK} if {@code SET} was executed correctly.
+     * @return String simple-string-reply {@code OK} if {@code SET} was executed correctly.
      */
-    V set(K key, V value, SetArgs setArgs);
+    String set(K key, V value, SetArgs setArgs);
 
     /**
      * Sets or clears the bit at offset in the string value stored at key.

File: src/main/java/com/lambdaworks/redis/cluster/api/async/NodeSelectionStringAsyncCommands.java
Patch:
@@ -267,9 +267,9 @@ public interface NodeSelectionStringAsyncCommands<K, V> {
      * @param value the value
      * @param setArgs the setArgs
      * 
-     * @return V simple-string-reply {@code OK} if {@code SET} was executed correctly.
+     * @return String simple-string-reply {@code OK} if {@code SET} was executed correctly.
      */
-    AsyncExecutions<V> set(K key, V value, SetArgs setArgs);
+    AsyncExecutions<String> set(K key, V value, SetArgs setArgs);
 
     /**
      * Sets or clears the bit at offset in the string value stored at key.

File: src/main/java/com/lambdaworks/redis/cluster/api/sync/NodeSelectionStringCommands.java
Patch:
@@ -266,9 +266,9 @@ public interface NodeSelectionStringCommands<K, V> {
      * @param value the value
      * @param setArgs the setArgs
      * 
-     * @return V simple-string-reply {@code OK} if {@code SET} was executed correctly.
+     * @return String simple-string-reply {@code OK} if {@code SET} was executed correctly.
      */
-    Executions<V> set(K key, V value, SetArgs setArgs);
+    Executions<String> set(K key, V value, SetArgs setArgs);
 
     /**
      * Sets or clears the bit at offset in the string value stored at key.

File: src/main/templates/com/lambdaworks/redis/api/RedisStringCommands.java
Patch:
@@ -265,9 +265,9 @@ public interface RedisStringCommands<K, V> {
      * @param value the value
      * @param setArgs the setArgs
      * 
-     * @return V simple-string-reply {@code OK} if {@code SET} was executed correctly.
+     * @return String simple-string-reply {@code OK} if {@code SET} was executed correctly.
      */
-    V set(K key, V value, SetArgs setArgs);
+    String set(K key, V value, SetArgs setArgs);
 
     /**
      * Sets or clears the bit at offset in the string value stored at key.

File: src/test/java/com/lambdaworks/redis/ClientOptionsTest.java
Patch:
@@ -29,6 +29,7 @@ protected void checkAssertions(ClientOptions sut) {
         assertThat(sut.isCancelCommandsOnReconnectFailure()).isEqualTo(false);
         assertThat(sut.isPingBeforeActivateConnection()).isEqualTo(false);
         assertThat(sut.isSuspendReconnectOnProtocolFailure()).isEqualTo(false);
+        assertThat(sut.getDisconnectedBehavior()).isEqualTo(ClientOptions.DisconnectedBehavior.DEFAULT);
     }
 
 }
\ No newline at end of file

File: src/test/java/com/lambdaworks/redis/reliability/AtMostOnceTest.java
Patch:
@@ -256,7 +256,7 @@ public void noCommandsExecutedAfterConnectionIsDisconnected() throws Exception {
 
             connection2.incr(key);
         } catch (Exception e) {
-            assertThat(e).isExactlyInstanceOf(RedisException.class).hasMessageContaining("reconnect is disabled");
+            assertThat(e).isExactlyInstanceOf(RedisException.class).hasMessageContaining("not connected");
         }
 
         connection2.close();

File: src/test/java/com/lambdaworks/redis/cluster/ClusterTestUtil.java
Patch:
@@ -6,6 +6,7 @@
 import com.lambdaworks.redis.RedisClusterConnection;
 import com.lambdaworks.redis.api.sync.RedisCommands;
 import com.lambdaworks.redis.cluster.api.StatefulRedisClusterConnection;
+import com.lambdaworks.redis.cluster.api.sync.RedisClusterCommands;
 import com.lambdaworks.redis.cluster.models.partitions.ClusterPartitionParser;
 import com.lambdaworks.redis.cluster.models.partitions.Partitions;
 import com.lambdaworks.redis.cluster.models.partitions.RedisClusterNode;
@@ -16,7 +17,7 @@
  */
 public class ClusterTestUtil {
 
-    public static String getNodeId(RedisClusterConnection<String, String> connection) {
+    public static String getNodeId(RedisClusterCommands<String, String> connection) {
         RedisClusterNode ownPartition = getOwnPartition(connection);
         if (ownPartition != null) {
             return ownPartition.getNodeId();
@@ -25,7 +26,7 @@ public static String getNodeId(RedisClusterConnection<String, String> connection
         return null;
     }
 
-    public static RedisClusterNode getOwnPartition(RedisClusterConnection<String, String> connection) {
+    public static RedisClusterNode getOwnPartition(RedisClusterCommands<String, String> connection) {
         Partitions partitions = ClusterPartitionParser.parse(connection.clusterNodes());
 
         for (RedisClusterNode partition : partitions) {

File: src/test/java/com/lambdaworks/redis/cluster/NodeSelectionSyncTest.java
Patch:
@@ -160,7 +160,6 @@ public void testAsynchronicityOfMultiNodeExecution() throws Exception {
         }
 
         Executions<String> kill = commands.masters().commands().scriptKill();
-
     }
 
     @Test

File: src/test/java/com/lambdaworks/redis/commands/ServerCommandTest.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.regex.Pattern;
 
 import org.junit.FixMethodOrder;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runners.MethodSorters;
 
@@ -327,6 +328,7 @@ public void slowlog() throws Exception {
     }
 
     @Test
+    @Ignore("Run me manually, I eat up 5 seconds.")
     public void sync() throws Exception {
         assertThat(redis.sync().startsWith("REDIS")).isTrue();
     }

File: src/test/java/com/lambdaworks/redis/pubsub/PubSubCommandTest.java
Patch:
@@ -84,7 +84,7 @@ protected void run(RedisClient client) throws Exception {
                 connection.quit();
                 Wait.untilTrue(() -> {
                     return !connection.isOpen();
-                });
+                }).waitOrTimeout();
 
                 connection.subscribe(channel);
                 assertThat(channels.take()).isEqualTo(channel);

File: src/test/java/com/lambdaworks/redis/resource/DefaultClientResourcesTest.java
Patch:
@@ -68,7 +68,7 @@ public void testBuilder() throws Exception {
         assertThat(sut.commandLatencyCollector()).isNotNull();
         assertThat(sut.commandLatencyCollector().isEnabled()).isFalse();
 
-        assertThat(sut.shutdown(10, 10, TimeUnit.MILLISECONDS).get()).isTrue();
+        assertThat(sut.shutdown(0, 0, TimeUnit.MILLISECONDS).get()).isTrue();
     }
 
     @Test
@@ -108,7 +108,7 @@ public void testSmallPoolSize() throws Exception {
         assertThat(eventLoopGroup.executorCount()).isEqualTo(3);
         assertThat(sut.ioThreadPoolSize()).isEqualTo(3);
 
-        assertThat(sut.shutdown(10, 10, TimeUnit.MILLISECONDS).get()).isTrue();
+        assertThat(sut.shutdown(0, 0, TimeUnit.MILLISECONDS).get()).isTrue();
     }
 
     @Test
@@ -133,7 +133,7 @@ public boolean isSatisfied() {
         }, timeout(seconds(2)));
 
         assertThat(subject.getOnNextEvents()).contains(event);
-        assertThat(sut.shutdown(10, 10, TimeUnit.MILLISECONDS).get()).isTrue();
+        assertThat(sut.shutdown(0, 0, TimeUnit.MILLISECONDS).get()).isTrue();
     }
 
 }

File: src/test/java/com/lambdaworks/redis/support/CdiTest.java
Patch:
@@ -7,6 +7,7 @@
 import javax.enterprise.inject.Produces;
 
 import com.lambdaworks.redis.AbstractRedisClientTest;
+import com.lambdaworks.redis.FastShutdown;
 import org.apache.webbeans.cditest.CdiTestContainer;
 import org.apache.webbeans.cditest.CdiTestContainerLoader;
 import org.junit.AfterClass;
@@ -46,7 +47,7 @@ public ClientResources clientResources() {
     }
 
     public void shutdownClientResources(@Disposes ClientResources clientResources) throws Exception {
-        clientResources.shutdown().get();
+        FastShutdown.shutdown(clientResources);
     }
 
     @PersonDB

File: src/main/java/com/lambdaworks/redis/RedisURI.java
Patch:
@@ -222,7 +222,8 @@ private static void parseTimeout(Builder builder, String queryParam) {
                 // no-op, leave defaults
             }
         } else {
-            long timeoutValue = Long.parseLong(timeoutString, 0, numbersEnd, 10);
+            String timeoutValueString = timeoutString.substring(0, numbersEnd);
+            long timeoutValue = Long.parseLong(timeoutValueString);
             builder.withTimeout(timeoutValue, TimeUnit.MILLISECONDS);
 
             String suffix = timeoutString.substring(numbersEnd);

File: src/main/java/com/lambdaworks/redis/protocol/CommandKeyword.java
Patch:
@@ -12,11 +12,11 @@ public enum CommandKeyword implements ProtocolKeyword {
 
     FAILOVER, FORGET, FLUSH, FORCE, FLUSHSLOTS, GETNAME, GETKEYSINSLOT, HTSTATS, ID, IDLETIME, KILL, KEYSLOT, LEN, LIMIT, LIST, LOAD, MATCH,
 
-    MAX, MEET, MIN, MOVED, NO, NODE, NODES, NOSAVE, NOT, NUMSUB, NUMPAT, ONE, OR, PAUSE, REFCOUNT, REPLICATE, RESET,
+    MAX, MEET, MIN, MOVED, NO, NODE, NODES, NOSAVE, NOT, NUMSUB, NUMPAT, ONE, OR, PAUSE, REFCOUNT, REMOVE, RELOAD, REPLICATE, RESET,
 
-    REWRITE, RESETSTAT, SAVECONFIG, SETNAME, SETSLOT, SLOTS, MIGRATING, IMPORTING, SKIPME, SLAVES, STORE, SUM, SEGFAULT, WEIGHTS,
+    RESETSTAT, RESTART, REWRITE, SAVECONFIG, SDSLEN, SETNAME, SETSLOT, SLOTS, MIGRATING, IMPORTING, SKIPME, SLAVES, STORE, SUM, SEGFAULT, WEIGHTS,
 
-    WITHSCORES, XOR, REMOVE;
+    WITHSCORES, XOR;
 
     public final byte[] bytes;
 

File: src/main/java/com/lambdaworks/redis/cluster/ClusterTopologyRefresh.java
Patch:
@@ -52,7 +52,7 @@ public ClusterTopologyRefresh(RedisClusterClient client) {
      * @param o2 the second object to be compared.
      * @return {@literal true} if {@code MASTER} or {@code SLAVE} flags changed or the responsible slots changed.
      */
-    public boolean isChanged(Partitions o1, Partitions o2) {
+    public static boolean isChanged(Partitions o1, Partitions o2) {
 
         if (o1.size() != o2.size()) {
             return true;
@@ -74,7 +74,7 @@ public boolean isChanged(Partitions o1, Partitions o2) {
      * @param o2 the second object to be compared.
      * @return {@literal true} if {@code MASTER} or {@code SLAVE} flags changed or the responsible slots changed.
      */
-    protected boolean essentiallyEqualsTo(RedisClusterNode o1, RedisClusterNode o2) {
+    protected static boolean essentiallyEqualsTo(RedisClusterNode o1, RedisClusterNode o2) {
 
         if (o2 == null) {
             return false;
@@ -95,7 +95,7 @@ protected boolean essentiallyEqualsTo(RedisClusterNode o1, RedisClusterNode o2)
         return true;
     }
 
-    private boolean sameFlags(RedisClusterNode base, RedisClusterNode other, RedisClusterNode.NodeFlag flag) {
+    private static boolean sameFlags(RedisClusterNode base, RedisClusterNode other, RedisClusterNode.NodeFlag flag) {
         if (base.getFlags().contains(flag)) {
             if (!other.getFlags().contains(flag)) {
                 return false;

File: src/main/java/com/lambdaworks/redis/cluster/PooledClusterConnectionProvider.java
Patch:
@@ -514,7 +514,7 @@ public StatefulRedisConnection<K, V> load(ConnectionKey key) throws Exception {
                     }
                 }
 
-                // Host and port connections provide command recovery due to cluster reconfiguration
+                // Host and port connections do provide command recovery due to cluster reconfiguration
                 connection = redisClusterClient.connectToNode(redisCodec, key.host + ":" + key.port, clusterWriter,
                         getSocketAddressSupplier(key));
             }

File: src/test/java/com/lambdaworks/redis/ClientOptionsTest.java
Patch:
@@ -11,7 +11,7 @@ public class ClientOptionsTest {
 
     @Test
     public void testNew() throws Exception {
-        checkAssertions(new ClientOptions());
+        checkAssertions(ClientOptions.create());
     }
 
     @Test

File: src/test/java/com/lambdaworks/redis/protocol/CustomCommandTest.java
Patch:
@@ -1,7 +1,9 @@
-package com.lambdaworks.redis;
+package com.lambdaworks.redis.protocol;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
+import com.lambdaworks.redis.AbstractRedisClientTest;
+import com.lambdaworks.redis.ReactiveCommandDispatcher;
 import org.junit.Test;
 
 import rx.Observable;

File: src/main/java/com/lambdaworks/redis/cluster/RedisClusterClient.java
Patch:
@@ -53,7 +53,7 @@ public class RedisClusterClient extends AbstractRedisClient {
     private Iterable<RedisURI> initialUris = ImmutableSet.of();
 
     private RedisClusterClient() {
-        setOptions(new ClusterClientOptions.Builder().build());
+        setOptions(ClusterClientOptions.create());
     }
 
     /**

File: src/main/java/com/lambdaworks/redis/event/DefaultEventPublisherOptions.java
Patch:
@@ -39,7 +39,7 @@ public Builder() {
 
         /**
          * Sets the emit interval and the interval unit. Event emission will be disabled if the {@code eventEmitInterval} is set
-         * to 0} . Defaults to 10} {@link TimeUnit#MINUTES}. See {@link DefaultEventPublisherOptions#DEFAULT_EMIT_INTERVAL}
+         * to 0}. Defaults to 10} {@link TimeUnit#MINUTES}. See {@link DefaultEventPublisherOptions#DEFAULT_EMIT_INTERVAL}
          * {@link DefaultEventPublisherOptions#DEFAULT_EMIT_INTERVAL_UNIT}.
          *
          * @param eventEmitInterval the event interval, must be greater or equal to 0}

File: src/main/java/com/lambdaworks/redis/resource/DefaultClientResources.java
Patch:
@@ -374,7 +374,7 @@ public EventPublisherOptions commandLatencyPublisherOptions() {
     /**
      * Create a new {@link DefaultClientResources} using default settings.
      * 
-     * @return a new instance of a default client resources instance.
+     * @return a new instance of a default client resources.
      */
     public static DefaultClientResources create() {
         return new Builder().build();

File: src/test/java/com/lambdaworks/redis/ClientOptionsTest.java
Patch:
@@ -11,7 +11,7 @@ public class ClientOptionsTest {
 
     @Test
     public void testNew() throws Exception {
-        checkAssertions(new ClientOptions());
+        checkAssertions(ClientOptions.create());
     }
 
     @Test

File: src/test/java/com/lambdaworks/redis/ClientTest.java
Patch:
@@ -153,7 +153,7 @@ public void pingBeforeConnectFails() throws Exception {
      * 
      * @throws Exception
      */
-    @Test(timeout = 10000)
+    @Test(timeout = 120000)
     public void pingBeforeConnectFailOnReconnect() throws Exception {
 
         client.setOptions(new ClientOptions.Builder().pingBeforeActivateConnection(true)

File: src/main/java/com/lambdaworks/redis/RedisCommandBuilder.java
Patch:
@@ -1757,7 +1757,7 @@ public Command<K, V, String> clusterReset(boolean hard) {
     }
 
     public Command<K, V, Long> geoadd(K key, double longitude, double latitude, V member) {
-        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).add(latitude).add(longitude).addValue(member);
+        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).add(longitude).add(latitude).addValue(member);
         return createCommand(GEOADD, new IntegerOutput<K, V>(codec), args);
     }
 

File: src/test/java/com/lambdaworks/redis/commands/GeoCommandTest.java
Patch:
@@ -41,7 +41,8 @@ public void geoaddMultiWrongArgument() throws Exception {
     }
 
     protected void prepareGeo() {
-        redis.geoadd(key, 8.6638775, 49.5282537, "Weinheim", 8.3796281, 48.9978127, "EFS9", 8.665351, 49.553302, "Bahn");
+        redis.geoadd(key, 8.6638775, 49.5282537, "Weinheim");
+        redis.geoadd(key, 8.3796281, 48.9978127, "EFS9", 8.665351, 49.553302, "Bahn");
     }
 
     @Test

File: src/main/java/com/lambdaworks/redis/RedisCommandBuilder.java
Patch:
@@ -1694,7 +1694,7 @@ public Command<K, V, String> clusterReset(boolean hard) {
     }
 
     public Command<K, V, Long> geoadd(K key, double longitude, double latitude, V member) {
-        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).add(latitude).add(longitude).addValue(member);
+        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).add(longitude).add(latitude).addValue(member);
         return createCommand(GEOADD, new IntegerOutput<K, V>(codec), args);
     }
 

File: src/test/java/com/lambdaworks/redis/GeoCommandTest.java
Patch:
@@ -39,7 +39,8 @@ public void geoaddMultiWrongArgument() throws Exception {
     }
 
     protected void prepareGeo() {
-        redis.geoadd(key, 8.6638775, 49.5282537, "Weinheim", 8.3796281, 48.9978127, "EFS9", 8.665351, 49.553302, "Bahn");
+        redis.geoadd(key, 8.6638775, 49.5282537, "Weinheim");
+        redis.geoadd(key, 8.3796281, 48.9978127, "EFS9", 8.665351, 49.553302, "Bahn");
     }
 
     @Test

File: src/main/java/com/lambdaworks/redis/RedisHashesAsyncConnection.java
Patch:
@@ -254,6 +254,7 @@ public interface RedisHashesAsyncConnection<K, V> {
      * Get the string length of the field value in a hash.
      *
      * @param key the key
+     * @param field the field type: key
      * @return RedisFuture&lt;Long&gt; integer-reply the string length of the {@code field} value, or {@code 0} when
      *         {@code field} is not present in the hash or {@code key} does not exist at all.
      */

File: src/main/java/com/lambdaworks/redis/RedisHashesConnection.java
Patch:
@@ -252,6 +252,7 @@ public interface RedisHashesConnection<K, V> {
      * Get the string length of the field value in a hash.
      *
      * @param key the key
+     * @param field the field type: key
      * @return Long integer-reply the string length of the {@code field} value, or {@code 0} when {@code field} is not present
      *         in the hash or {@code key} does not exist at all.
      */

File: src/main/java/com/lambdaworks/redis/api/async/RedisHashAsyncCommands.java
Patch:
@@ -254,6 +254,7 @@ public interface RedisHashAsyncCommands<K, V> {
      * Get the string length of the field value in a hash.
      *
      * @param key the key
+     * @param field the field type: key
      * @return Long integer-reply the string length of the {@code field} value, or {@code 0} when {@code field} is not present
      *         in the hash or {@code key} does not exist at all.
      */

File: src/main/java/com/lambdaworks/redis/api/rx/RedisHashReactiveCommands.java
Patch:
@@ -254,6 +254,7 @@ public interface RedisHashReactiveCommands<K, V> {
      * Get the string length of the field value in a hash.
      *
      * @param key the key
+     * @param field the field type: key
      * @return Long integer-reply the string length of the {@code field} value, or {@code 0} when {@code field} is not present
      *         in the hash or {@code key} does not exist at all.
      */

File: src/main/java/com/lambdaworks/redis/api/sync/RedisHashCommands.java
Patch:
@@ -253,6 +253,7 @@ public interface RedisHashCommands<K, V> {
      * Get the string length of the field value in a hash.
      *
      * @param key the key
+     * @param field the field type: key
      * @return Long integer-reply the string length of the {@code field} value, or {@code 0} when {@code field} is not present
      *         in the hash or {@code key} does not exist at all.
      */

File: src/main/java/com/lambdaworks/redis/cluster/api/async/NodeSelectionHashAsyncCommands.java
Patch:
@@ -123,6 +123,7 @@ public interface NodeSelectionHashAsyncCommands<K, V> {
      * Get the string length of the field value in a hash.
      *
      * @param key the key
+     * @param field the field type: key
      * @return Long integer-reply the string length of the {@code field} value, or {@code 0} when {@code field} is not present
      *         in the hash or {@code key} does not exist at all.
      */

File: src/main/java/com/lambdaworks/redis/cluster/api/sync/NodeSelectionHashCommands.java
Patch:
@@ -253,6 +253,7 @@ public interface NodeSelectionHashCommands<K, V> {
      * Get the string length of the field value in a hash.
      *
      * @param key the key
+     * @param field the field type: key
      * @return Long integer-reply the string length of the {@code field} value, or {@code 0} when {@code field} is not present
      *         in the hash or {@code key} does not exist at all.
      */

File: src/main/templates/com/lambdaworks/redis/api/RedisHashCommands.java
Patch:
@@ -253,6 +253,7 @@ public interface RedisHashCommands<K, V> {
      * Get the string length of the field value in a hash.
      *
      * @param key the key
+     * @param field the field type: key
      * @return Long integer-reply the string length of the {@code field} value, or {@code 0} when {@code field} is not present
      *         in the hash or {@code key} does not exist at all.
      */

File: src/test/java/com/lambdaworks/redis/ClientTest.java
Patch:
@@ -166,7 +166,7 @@ public void pingBeforeConnectFails() throws Exception {
      * 
      * @throws Exception
      */
-    @Test(timeout = 10000)
+    @Test(timeout = 120000)
     public void pingBeforeConnectFailOnReconnect() throws Exception {
 
         client.setOptions(new ClientOptions.Builder().pingBeforeActivateConnection(true)

File: src/main/java/com/lambdaworks/redis/protocol/CommandKeyword.java
Patch:
@@ -8,7 +8,7 @@
  * @author Will Glozer
  */
 public enum CommandKeyword implements ProtocolKeyword {
-    ADDR, ADDSLOTS, AFTER, AGGREGATE, ALPHA, AND, ASC, BEFORE, BY, CHANNELS, COUNT, DELSLOTS, DESC, SOFT, HARD, ENCODING,
+    ADDR, ADDSLOTS, AFTER, AGGREGATE, ALPHA, AND, ASC, BEFORE, BY, CHANNELS, COUNT, DELSLOTS, DESC, SOFT, HARD, HTSTATS, ENCODING,
 
     FAILOVER, FORGET, FLUSH, FORCE, FLUSHSLOTS, GETNAME, GETKEYSINSLOT, ID, IDLETIME, KILL, LEN, LIMIT, LIST, LOAD, MATCH,
 

File: src/main/java/com/lambdaworks/redis/protocol/CommandKeyword.java
Patch:
@@ -8,7 +8,7 @@
  * @author Will Glozer
  */
 public enum CommandKeyword implements ProtocolKeyword {
-    ADDR, ADDSLOTS, AFTER, AGGREGATE, ALPHA, AND, ASC, BEFORE, BY, CHANNELS, COUNT, DELSLOTS, DESC, SOFT, HARD, ENCODING,
+    ADDR, ADDSLOTS, AFTER, AGGREGATE, ALPHA, AND, ASC, BEFORE, BY, CHANNELS, COUNT, DELSLOTS, DESC, SOFT, HARD, HTSTATS, ENCODING,
 
     FAILOVER, FORGET, FLUSH, FORCE, FLUSHSLOTS, GETNAME, GETKEYSINSLOT, ID, IDLETIME, KILL, LEN, LIMIT, LIST, LOAD, MATCH,
 

File: src/main/java/com/lambdaworks/redis/ConnectionEvents.java
Patch:
@@ -52,4 +52,7 @@ public SettableFuture<Boolean> getPrepareCloseFuture() {
     public static class Close {
     }
 
+    public static class Activated {
+    }
+
 }

File: src/main/java/com/lambdaworks/redis/FutureSyncInvocationHandler.java
Patch:
@@ -59,11 +59,11 @@ protected Object handleInvocation(Object proxy, Method method, Object[] args) th
                         return null;
                     }
                 }
-                return LettuceFutures.await(command, connection.getTimeout(), connection.getTimeoutUnit());
-            }
 
+                LettuceFutures.awaitOrCancel(command, connection.getTimeout(), connection.getTimeoutUnit());
+                return command.get();
+            }
             return result;
-
         } catch (InvocationTargetException e) {
             throw e.getTargetException();
         }

File: src/test/java/com/lambdaworks/redis/cluster/RedisClusterClientTest.java
Patch:
@@ -1,3 +1,4 @@
+
 package com.lambdaworks.redis.cluster;
 
 import static com.lambdaworks.redis.cluster.ClusterTestUtil.getOwnPartition;

File: src/test/java/com/lambdaworks/redis/commands/CommandInternalsTest.java
Patch:
@@ -5,6 +5,7 @@
 import static com.lambdaworks.redis.protocol.LettuceCharsets.buffer;
 import static org.assertj.core.api.Assertions.assertThat;
 
+import com.lambdaworks.redis.RedisCommandInterruptedException;
 import org.junit.Before;
 import org.junit.Test;
 

File: src/main/java/com/lambdaworks/redis/ConnectionEvents.java
Patch:
@@ -52,4 +52,7 @@ public SettableFuture<Boolean> getPrepareCloseFuture() {
     public static class Close {
     }
 
+    public static class Activated {
+    }
+
 }

File: src/main/java/com/lambdaworks/redis/cluster/PooledClusterConnectionProvider.java
Patch:
@@ -94,7 +94,9 @@ public void close() {
         this.connections.invalidateAll();
         resetPartitions();
         for (RedisAsyncConnection<K, V> kvRedisAsyncConnection : copy.values()) {
-            kvRedisAsyncConnection.close();
+            if (kvRedisAsyncConnection.isOpen()) {
+                kvRedisAsyncConnection.close();
+            }
         }
     }
 

File: src/main/java/com/lambdaworks/redis/protocol/CommandEncoder.java
Patch:
@@ -20,7 +20,7 @@
 @ChannelHandler.Sharable
 public class CommandEncoder extends MessageToByteEncoder<RedisCommand> {
 
-    private static final InternalLogger logger = InternalLoggerFactory.getInstance(CommandHandler.class);
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(CommandEncoder.class);
 
     /**
      * If TRACE level logging has been enabled at startup.

File: src/main/java/com/lambdaworks/redis/api/async/RedisServerAsyncCommands.java
Patch:
@@ -157,14 +157,12 @@ public interface RedisServerAsyncCommands<K, V> {
 
     /**
      * Make the server crash: Invalid pointer access.
-     * 
      * @return nothing, because the server crashes before returning.
      */
     void debugSegfault();
 
     /**
      * Make the server crash: Out of memory.
-     * 
      * @return nothing, because the server crashes before returning.
      */
     void debugOom();

File: src/main/java/com/lambdaworks/redis/api/sync/RedisServerCommands.java
Patch:
@@ -156,14 +156,12 @@ public interface RedisServerCommands<K, V> {
 
     /**
      * Make the server crash: Invalid pointer access.
-     * 
      * @return nothing, because the server crashes before returning.
      */
     void debugSegfault();
 
     /**
      * Make the server crash: Out of memory.
-     * 
      * @return nothing, because the server crashes before returning.
      */
     void debugOom();

File: src/main/java/com/lambdaworks/redis/output/NumericAndGeoTupleListOutput.java
Patch:
@@ -8,7 +8,6 @@
 import com.google.common.collect.Lists;
 import com.lambdaworks.redis.GeoTuple;
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * A list output that creates a list with either double/long or {@link GeoTuple}'s.

File: src/main/java/com/lambdaworks/redis/protocol/CommandType.java
Patch:
@@ -65,7 +65,7 @@ public enum CommandType implements ProtocolKeyword {
     BITCOUNT, BITOP, GETBIT, SETBIT, BITPOS,
 
     // Geo
-    GEOADD, GEORADIUS, GEORADIUSBYMEMBER, GEOENCODE, GEODECODE,
+    GEOADD, GEORADIUS, GEORADIUSBYMEMBER, GEOENCODE, GEODECODE, GEOPOS, GEODIST,
 
     // Others
     TIME, WAIT,

File: src/main/java/com/lambdaworks/redis/protocol/CommandType.java
Patch:
@@ -65,7 +65,7 @@ public enum CommandType implements ProtocolKeyword {
     BITCOUNT, BITOP, GETBIT, SETBIT, BITPOS,
 
     // Geo
-    GEOADD, GEORADIUS, GEORADIUSBYMEMBER, GEOENCODE, GEODECODE,
+    GEOADD, GEORADIUS, GEORADIUSBYMEMBER, GEOENCODE, GEODECODE, GEOPOS, GEODIST,
 
     // Others
     TIME, WAIT,

File: src/main/java/com/lambdaworks/redis/RedisChannelHandler.java
Patch:
@@ -101,7 +101,7 @@ public void channelRead(Object msg) {
 
     protected <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> cmd) {
 
-        if (clientOptions != null && !clientOptions.isAutoReconnect() && !active) {
+        if (!active && clientOptions != null && !clientOptions.isAutoReconnect()) {
             cmd.setException(new RedisException(
                     "Connection is in a disconnected state and reconnect is disabled. Commands are not accepted."));
             cmd.complete();

File: src/main/java/com/lambdaworks/redis/pubsub/PubSubCommandHandler.java
Patch:
@@ -46,7 +46,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Interrup
             if (!rsm.decode(buffer, currentOutput)) {
                 return;
             }
-            queue.take().complete();
+            queue.poll().complete();
             buffer.discardReadBytes();
             if (currentOutput instanceof PubSubOutput) {
                 ctx.fireChannelRead(currentOutput);

File: src/main/java/com/lambdaworks/redis/cluster/ClusterDistributionChannelWriter.java
Patch:
@@ -63,9 +63,10 @@ public <T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {
 
         }
 
-        if (channelWriter == null && args != null && !args.getKeys().isEmpty()) {
+        byte encodedKey[] = args.getEncodedKey();
+        if (channelWriter == null && args != null && encodedKey != null) {
 
-            int hash = getHash(args.getEncodedKey(0));
+            int hash = getHash(encodedKey);
             RedisAsyncConnectionImpl<K, V> connection = clusterConnectionProvider.getConnection(
                     ClusterConnectionProvider.Intent.WRITE, hash);
 

File: src/main/java/com/lambdaworks/redis/cluster/models/partitions/ClusterPartitionParser.java
Patch:
@@ -62,10 +62,12 @@ public static Partitions parse(String nodes) {
                 RedisClusterNode partition = parseNode(node);
                 result.addPartition(partition);
             }
+
         } catch (Exception e) {
             throw new RedisException("Cannot parse " + nodes, e);
         }
 
+        result.updateCache();
         return result;
     }
 

File: src/test/java/com/lambdaworks/redis/cluster/ClusterPartitionParserTest.java
Patch:
@@ -54,7 +54,6 @@ public void testParse() throws Exception {
         assertThat(p3.toString()).contains(RedisClusterNode.class.getSimpleName());
         assertThat(result.toString()).contains(Partitions.class.getSimpleName());
 
-        assertThat(result.getPartitionBySlot(Integer.MAX_VALUE)).isNull();
 
     }
 

File: src/test/java/com/lambdaworks/redis/cluster/RedisClusterClientTest.java
Patch:
@@ -380,6 +380,7 @@ public void testClusterRedirection() throws Exception {
                 partition.getSlots().addAll(Ints.asList(createSlots(0, 16384)));
             }
         }
+        partitions.updateCache();
 
         // appropriate cluster node
         RedisFuture<String> setB = connection.set("b", "myValue1");

File: src/main/java/com/lambdaworks/redis/AbstractRedisReactiveCommands.java
Patch:
@@ -217,12 +217,12 @@ public Observable<String> debugObject(K key) {
 
     @Override
     public Observable<Void> debugSegfault() {
-        return (Observable<Void>) createObservable(commandBuilder::debugSegfault);
+        return createObservable(commandBuilder::debugSegfault);
     }
 
     @Override
     public Observable<Void> debugOom() {
-        return (Observable<Void>) createObservable(commandBuilder::debugOom);
+        return createObservable(commandBuilder::debugOom);
     }
 
     @Override
@@ -778,6 +778,7 @@ public Observable<Long> setrange(K key, long offset, V value) {
     }
 
     @Override
+    @SuppressWarnings("unchecked")
     public Observable<Void> shutdown(boolean save) {
         return (Observable) createObservable(() -> commandBuilder.shutdown(save));
     }

File: src/main/java/com/lambdaworks/redis/PlainChannelInitializer.java
Patch:
@@ -20,7 +20,7 @@
  */
 class PlainChannelInitializer extends io.netty.channel.ChannelInitializer<Channel> implements RedisChannelInitializer {
 
-    final static RedisCommandBuilder INITIALIZING_CMD_BUILDER = new RedisCommandBuilder(new Utf8StringCodec());
+    final static RedisCommandBuilder<String, String> INITIALIZING_CMD_BUILDER = new RedisCommandBuilder<>(new Utf8StringCodec());
 
     protected boolean pingBeforeActivate;
     private List<ChannelHandler> handlers;
@@ -112,7 +112,7 @@ static void pingBeforeActivate(final AsyncCommand<?, ?, ?> cmd, final SettableFu
 
         for (ChannelHandler handler : handlers) {
             if (handler instanceof CommandHandler) {
-                CommandHandler ch = (CommandHandler) handler;
+                CommandHandler<?, ?> ch = (CommandHandler<?, ?>) handler;
                 ch.write(ctx, cmd, ctx.newPromise());
                 ctx.flush();
             }

File: src/main/java/com/lambdaworks/redis/RedisChannelHandler.java
Patch:
@@ -104,7 +104,7 @@ public void channelRead(Object msg) {
 
     protected <T, C extends RedisCommand<K, V, T>> C dispatch(C cmd) {
 
-        logger.debug("dispatching command {}",cmd);
+        logger.debug("dispatching command {}", cmd);
         if (clientOptions != null && !clientOptions.isAutoReconnect() && !active) {
             cmd.completeExceptionally(new RedisException(
                     "Connection is in a disconnected state and reconnect is disabled. Commands are not accepted."));
@@ -205,7 +205,7 @@ public long getTimeout() {
         return timeout;
     }
 
-    protected <T> T syncHandler(Object asyncApi, Class... interfaces) {
+    protected <T> T syncHandler(Object asyncApi, Class<?>... interfaces) {
         FutureSyncInvocationHandler<K, V> h = new FutureSyncInvocationHandler<>((StatefulConnection) this, asyncApi);
         return (T) Proxy.newProxyInstance(AbstractRedisClient.class.getClassLoader(), interfaces, h);
     }

File: src/main/java/com/lambdaworks/redis/RedisClient.java
Patch:
@@ -300,7 +300,7 @@ private <K, V> StatefulRedisConnection<K, V> connectStateful(RedisCodec<K, V> co
 
         CommandHandler<K, V> handler = new CommandHandler<K, V>(clientOptions, queue);
 
-        StatefulRedisConnectionImpl connection = newStatefulRedisConnection(handler, codec);
+        StatefulRedisConnectionImpl<K, V> connection = newStatefulRedisConnection(handler, codec);
         connectStateful(handler, connection, redisURI);
         return connection;
     }

File: src/main/java/com/lambdaworks/redis/cluster/DynamicNodeSelection.java
Patch:
@@ -10,7 +10,7 @@
 /**
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>
  */
-class DynamicNodeSelection<T, CMDType, K, V> extends AbstractNodeSelection<T, CMDType, K, V> {
+abstract class DynamicNodeSelection<T, CMDType, K, V> extends AbstractNodeSelection<T, CMDType, K, V> {
 
     private final Predicate<RedisClusterNode> selector;
 

File: src/main/java/com/lambdaworks/redis/cluster/PipelinedRedisFuture.java
Patch:
@@ -20,7 +20,7 @@ class PipelinedRedisFuture<V> extends CompletableFuture<V> implements RedisFutur
     public PipelinedRedisFuture(Map<Integer, ? extends RedisFuture<?>> executions,
             Function<PipelinedRedisFuture<V>, V> converter) {
 
-        CompletableFuture.allOf(executions.values().toArray(new CompletableFuture[executions.size()]))
+        CompletableFuture.allOf(executions.values().toArray(new CompletableFuture<?>[executions.size()]))
                 .thenRun(() -> complete(converter.apply(this))).exceptionally(throwable -> {
                     completeExceptionally(throwable);
                     return null;

File: src/main/java/com/lambdaworks/redis/cluster/RedisAdvancedClusterAsyncCommandsImpl.java
Patch:
@@ -220,7 +220,7 @@ protected AsyncNodeSelection<K, V> nodes(Predicate<RedisClusterNode> predicate,
 
         NodeSelectionInvocationHandler h = new NodeSelectionInvocationHandler((AbstractNodeSelection<?, ?, ?, ?>) selection,
                 false);
-        return (AsyncNodeSelection<K, V>) Proxy.newProxyInstance(NodeSelection.class.getClassLoader(), new Class[] {
+        return (AsyncNodeSelection<K, V>) Proxy.newProxyInstance(NodeSelection.class.getClassLoader(), new Class<?>[] {
                 NodeSelectionAsyncCommands.class, AsyncNodeSelection.class }, h);
     }
 

File: src/main/java/com/lambdaworks/redis/cluster/StatefulRedisClusterConnectionImpl.java
Patch:
@@ -75,7 +75,7 @@ public RedisAdvancedClusterCommands<K, V> sync() {
         if (sync == null) {
             InvocationHandler h = syncInvocationHandler();
             sync = (RedisAdvancedClusterCommands) Proxy.newProxyInstance(AbstractRedisClient.class.getClassLoader(),
-                    new Class[] { RedisAdvancedClusterConnection.class, RedisAdvancedClusterCommands.class }, h);
+                    new Class<?>[] { RedisAdvancedClusterConnection.class, RedisAdvancedClusterCommands.class }, h);
         }
 
         return sync;
@@ -241,12 +241,12 @@ protected Object handleInvocation(Object proxy, Method method, Object[] args) th
                     Method targetMethod = connection.getClass().getMethod(method.getName(), method.getParameterTypes());
                     Object result = targetMethod.invoke(connection, args);
                     if (result instanceof StatefulRedisClusterConnection) {
-                        StatefulRedisClusterConnection connection = (StatefulRedisClusterConnection) result;
+                        StatefulRedisClusterConnection<K, V> connection = (StatefulRedisClusterConnection<K, V>) result;
                         return connection.sync();
                     }
 
                     if (result instanceof StatefulRedisConnection) {
-                        StatefulRedisConnection connection = (StatefulRedisConnection) result;
+                        StatefulRedisConnection<K, V> connection = (StatefulRedisConnection<K, V>) result;
                         return connection.sync();
                     }
                 }

File: src/main/java/com/lambdaworks/redis/cluster/StaticNodeSelection.java
Patch:
@@ -10,7 +10,7 @@
 /**
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>
  */
-class StaticNodeSelection<T, CMDType, K, V> extends AbstractNodeSelection<T, CMDType, K, V> {
+abstract class StaticNodeSelection<T, CMDType, K, V> extends AbstractNodeSelection<T, CMDType, K, V> {
 
     private final List<RedisClusterNode> redisClusterNodes;
 

File: src/main/java/com/lambdaworks/redis/protocol/ConnectionWatchdog.java
Patch:
@@ -171,7 +171,7 @@ private void reconnect(InternalLogLevel infoLevel, InternalLogLevel warnLevel) t
         connect.sync().await();
 
         RedisChannelInitializer channelInitializer = connect.channel().pipeline().get(RedisChannelInitializer.class);
-        CommandHandler commandHandler = connect.channel().pipeline().get(CommandHandler.class);
+        CommandHandler<?, ?> commandHandler = connect.channel().pipeline().get(CommandHandler.class);
         try {
 
             channelInitializer.channelInitialized().get();

File: src/test/java/com/lambdaworks/redis/AbstractTest.java
Patch:
@@ -39,7 +39,7 @@ public static List<ScoredValue<String>> svlist(ScoredValue<String>... args) {
     }
 
     public static KeyValue<String, String> kv(String key, String value) {
-        return new KeyValue<String, String>(key, value);
+        return new KeyValue<>(key, value);
     }
 
     public static ScoredValue<String> sv(double score, String value) {

File: src/test/java/com/lambdaworks/redis/cluster/commands/HashClusterCommandTest.java
Patch:
@@ -54,6 +54,7 @@ public void openConnection() throws Exception {
     protected RedisCommands<String, String> connect() {
         clusterConnection = (StatefulRedisClusterConnectionImpl) redisClusterClient.connectCluster().getStatefulConnection();
         InvocationHandler h = clusterConnection.syncInvocationHandler();
-        return (RedisCommands) Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] { RedisCommands.class }, h);
+        return (RedisCommands<String, String>) Proxy.newProxyInstance(getClass().getClassLoader(),
+                new Class[] { RedisCommands.class }, h);
     }
 }

File: src/test/java/com/lambdaworks/redis/cluster/commands/ListClusterCommandTest.java
Patch:
@@ -58,7 +58,8 @@ protected void flushClusterDb() {
     protected RedisCommands<String, String> connect() {
         clusterConnection = (StatefulRedisClusterConnectionImpl) redisClusterClient.connectCluster().getStatefulConnection();
         InvocationHandler h = clusterConnection.syncInvocationHandler();
-        return (RedisCommands) Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] { RedisCommands.class }, h);
+        return (RedisCommands<String, String>) Proxy.newProxyInstance(getClass().getClassLoader(),
+                new Class[] { RedisCommands.class }, h);
     }
 
     // re-implementation because keys have to be on the same slot

File: src/test/java/com/lambdaworks/redis/cluster/commands/StringClusterCommandTest.java
Patch:
@@ -65,7 +65,8 @@ protected void flushClusterDb() {
     protected RedisCommands<String, String> connect() {
         clusterConnection = (StatefulRedisClusterConnectionImpl) redisClusterClient.connectCluster().getStatefulConnection();
         InvocationHandler h = clusterConnection.syncInvocationHandler();
-        return (RedisCommands) Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] { RedisCommands.class }, h);
+        return (RedisCommands<String, String>) Proxy.newProxyInstance(getClass().getClassLoader(),
+                new Class[] { RedisCommands.class }, h);
     }
 
     @Test

File: src/test/java/com/lambdaworks/redis/commands/SetCommandTest.java
Patch:
@@ -164,7 +164,7 @@ public void sremEmpty() throws Exception {
 
     @Test(expected = IllegalArgumentException.class)
     public void sremNulls() throws Exception {
-        redis.srem(key, null);
+        redis.srem(key, new String[0]);
     }
 
     @Test

File: src/test/java/com/lambdaworks/redis/commands/rx/RxSyncInvocationHandler.java
Patch:
@@ -83,20 +83,20 @@ public static <K, V> RedisCommands<K, V> sync(StatefulRedisConnection<K, V> conn
 
         RxSyncInvocationHandler<K, V> handler = new RxSyncInvocationHandler<>(connection, connection.reactive());
         return (RedisCommands<K, V>) Proxy.newProxyInstance(handler.getClass().getClassLoader(),
-                new Class[] { RedisCommands.class }, handler);
+                new Class<?>[] { RedisCommands.class }, handler);
     }
 
     public static <K, V> RedisCommands<K, V> sync(StatefulRedisClusterConnection<K, V> connection) {
 
         RxSyncInvocationHandler<K, V> handler = new RxSyncInvocationHandler<>(connection, connection.reactive());
         return (RedisCommands<K, V>) Proxy.newProxyInstance(handler.getClass().getClassLoader(),
-                new Class[] { RedisCommands.class }, handler);
+                new Class<?>[] { RedisCommands.class }, handler);
     }
 
     public static <K, V> RedisSentinelCommands<K, V> sync(StatefulRedisSentinelConnection<K, V> connection) {
 
         RxSyncInvocationHandler<K, V> handler = new RxSyncInvocationHandler<>(connection, connection.reactive());
         return (RedisSentinelCommands<K, V>) Proxy.newProxyInstance(handler.getClass().getClassLoader(),
-                new Class[] { RedisSentinelCommands.class }, handler);
+                new Class<?>[] { RedisSentinelCommands.class }, handler);
     }
 }
\ No newline at end of file

File: src/test/java/com/lambdaworks/redis/commands/rx/BitRxCommandTest.java
Patch:
@@ -7,7 +7,7 @@
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>
  * @since 16.06.15 14:54
  */
-public class BitCommandRxTest extends BitCommandTest {
+public class BitRxCommandTest extends BitCommandTest {
     @Override
     protected RedisCommands<String, String> connect() {
         bitstring = RxSyncInvocationHandler.sync(client.connectAsync(new BitStringCodec()).getStatefulConnection());

File: src/test/java/com/lambdaworks/Wait.java
Patch:
@@ -102,12 +102,12 @@ public static class WaitBuilder<T> {
         private Predicate<T> check;
         private WaitCondition waitCondition;
 
-        public WaitBuilder during(Duration duration) {
+        public WaitBuilder<T> during(Duration duration) {
             this.duration = duration;
             return this;
         }
 
-        public WaitBuilder message(String message) {
+        public WaitBuilder<T> message(String message) {
             this.messageFunction = o -> message;
             return this;
         }

File: src/test/java/com/lambdaworks/redis/sentinel/SentinelConnectionTest.java
Patch:
@@ -88,13 +88,15 @@ public void testSyncClose() throws Exception {
 
         StatefulRedisSentinelConnection<String, String> statefulConnection = sentinel.getStatefulConnection();
         statefulConnection.sync().close();
+        assertThat(sentinel.isOpen()).isFalse();
         assertThat(statefulConnection.isOpen()).isFalse();
     }
 
     @Test
     public void testAsyncClose() throws Exception {
         StatefulRedisSentinelConnection<String, String> statefulConnection = sentinel.getStatefulConnection();
         statefulConnection.async().close();
+        assertThat(sentinel.isOpen()).isFalse();
         assertThat(statefulConnection.isOpen()).isFalse();
 
     }

File: src/test/java/com/lambdaworks/redis/commands/ServerCommandTest.java
Patch:
@@ -217,7 +217,7 @@ public void save() throws Exception {
     @Test
     public void slaveof() throws Exception {
 
-        assertThat(redis.slaveof(TestSettin.host(), 0)).isEqualTo("OK");
+        assertThat(redis.slaveof(TestSettings.host(), 0)).isEqualTo("OK");
         redis.slaveofNoOne();
     }
 

File: src/main/java/com/lambdaworks/redis/AbstractRedisAsyncCommands.java
Patch:
@@ -41,7 +41,7 @@
 
 /**
  * An asynchronous thread-safe API to a redis connection.
- * 
+ *
  * @param <K> Key type.
  * @param <V> Value type.
  * @author Will Glozer
@@ -65,6 +65,8 @@ public abstract class AbstractRedisAsyncCommands<K, V> implements RedisHashesAsy
     /**
      * Initialize a new instance.
      *
+     * @param connection the connection to operate on
+     * @param codec the codec for command encoding
      */
     public AbstractRedisAsyncCommands(StatefulConnection<K, V> connection, RedisCodec<K, V> codec) {
         this.connection = connection;
@@ -325,7 +327,6 @@ public RedisFuture<Boolean> expireat(K key, long timestamp) {
 
     @Override
     public RedisFuture<List<Object>> exec() {
-
         return dispatch(EXEC, null);
     }
 
@@ -1621,5 +1622,4 @@ public void reset() {
     public StatefulConnection<K, V> getConnection() {
         return connection;
     }
-
 }

File: src/main/java/com/lambdaworks/redis/AbstractRedisClient.java
Patch:
@@ -328,11 +328,11 @@ public ClientOptions getOptions() {
     /**
      * Set the {@link ClientOptions} for the client.
      * 
-     * @param clientOptions
+     * @param clientOptions the new client options
+     * @throws IllegalArgumentException if {@literal clientOptions} is null
      */
     public void setOptions(ClientOptions clientOptions) {
         checkArgument(clientOptions != null, "clientOptions must not be null");
-
         this.clientOptions = clientOptions;
     }
 }

File: src/main/java/com/lambdaworks/redis/RedisChannelWriter.java
Patch:
@@ -20,6 +20,7 @@ public interface RedisChannelWriter<K, V> extends Closeable {
      * 
      * @param command the redis command
      * @param <T> result type
+     * @param <C> command type
      * @return the written redis command
      */
     <T, C extends RedisCommand<K, V, T>> C write(C command);

File: src/main/java/com/lambdaworks/redis/cluster/RedisClusterClient.java
Patch:
@@ -178,7 +178,7 @@ <K, V> StatefulRedisClusterConnectionImpl<K, V> connectClusterImpl(RedisCodec<K,
 
         final ClusterDistributionChannelWriter<K, V> clusterWriter = new ClusterDistributionChannelWriter<K, V>(handler,
                 pooledClusterConnectionProvider);
-        StatefulRedisClusterConnectionImpl<K, V> connection = new StatefulRedisClusterConnectionImpl(clusterWriter, codec,
+        StatefulRedisClusterConnectionImpl<K, V> connection = new StatefulRedisClusterConnectionImpl<>(clusterWriter, codec,
                 timeout, unit);
 
         connection.setPartitions(partitions);

File: src/main/java/com/lambdaworks/redis/protocol/RedisCommand.java
Patch:
@@ -68,9 +68,10 @@ public interface RedisCommand<K, V, T> {
     boolean isCancelled();
 
     /**
-     * Set a new output.
+     * Set a new output. Only possible as long as the command is not completed/cancelled.
      * 
-     * @param output
+     * @param output the new command output
+     * @throws IllegalStateException if the command is cancelled/completed
      */
     void setOutput(CommandOutput<K, V, T> output);
 }

File: src/main/java/com/lambdaworks/redis/pubsub/PubSubCommandHandler.java
Patch:
@@ -30,13 +30,14 @@ public class PubSubCommandHandler<K, V> extends CommandHandler<K, V> {
     /**
      * Initialize a new instance.
      * 
+     * @param clientOptions client options for the connection
      * @param queue Command queue.
      * @param codec Codec.
      */
     public PubSubCommandHandler(ClientOptions clientOptions, BlockingQueue<RedisCommand<K, V, ?>> queue, RedisCodec<K, V> codec) {
         super(clientOptions, queue);
         this.codec = codec;
-        this.output = new PubSubOutput<K, V, V>(codec);
+        this.output = new PubSubOutput<>(codec);
     }
 
     @Override

File: src/test/java/com/lambdaworks/apigenerator/CompilationUnitFactory.java
Patch:
@@ -98,7 +98,7 @@ public void createInterface() throws Exception {
     /**
      * Simple visitor implementation for visiting MethodDeclaration nodes.
      */
-    private class MethodVisitor extends VoidVisitorAdapter {
+    private class MethodVisitor extends VoidVisitorAdapter<Object> {
 
         @Override
         public void visit(MethodDeclaration n, Object arg) {

File: src/test/java/com/lambdaworks/redis/cluster/ClusterCommandTest.java
Patch:
@@ -5,13 +5,13 @@
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
-import com.lambdaworks.redis.protocol.AsyncCommand;
 import org.junit.Before;
 import org.junit.Test;
 
 import com.google.common.collect.Lists;
 import com.lambdaworks.redis.codec.Utf8StringCodec;
 import com.lambdaworks.redis.output.StatusOutput;
+import com.lambdaworks.redis.protocol.AsyncCommand;
 import com.lambdaworks.redis.protocol.Command;
 import com.lambdaworks.redis.protocol.CommandType;
 
@@ -58,7 +58,7 @@ public void testCompleteListener() throws Exception {
 
         final List<String> someList = Lists.newArrayList();
 
-        AsyncCommand asyncCommand = new AsyncCommand(sut);
+        AsyncCommand<?, ?, ?> asyncCommand = new AsyncCommand<>(sut);
 
         asyncCommand.thenRun(() -> someList.add(""));
         asyncCommand.complete();

File: src/test/java/com/lambdaworks/redis/cluster/ClusterRule.java
Patch:
@@ -42,13 +42,13 @@ public Statement apply(final Statement base, Description description) {
         final Statement beforeCluster = new Statement() {
             @Override
             public void evaluate() throws Throwable {
-                List<Future> futures = Lists.newArrayList();
+                List<Future<?>> futures = Lists.newArrayList();
 
                 for (RedisClusterAsyncConnection<?, ?> connection : connectionCache.values()) {
                     futures.add(connection.flushall());
                 }
 
-                for (Future future : futures) {
+                for (Future<?> future : futures) {
                     try {
                         future.get();
                     } catch (Exception e) {

File: src/test/java/com/lambdaworks/redis/commands/ScriptingCommandTest.java
Patch:
@@ -30,20 +30,20 @@ public void eval() throws Exception {
         assertThat((Number) redis.eval("return 1 + 1", INTEGER)).isEqualTo(2L);
         assertThat((String) redis.eval("return {ok='status'}", STATUS)).isEqualTo("status");
         assertThat((String) redis.eval("return 'one'", VALUE)).isEqualTo("one");
-        assertThat((List) redis.eval("return {1, 'one', {2}}", MULTI)).isEqualTo(list(1L, "one", list(2L)));
+        assertThat((List<?>) redis.eval("return {1, 'one', {2}}", MULTI)).isEqualTo(list(1L, "one", list(2L)));
         exception.expectMessage("Oops!");
         redis.eval("return {err='Oops!'}", STATUS);
     }
 
     @Test
     public void evalWithKeys() throws Exception {
-        assertThat((List) redis.eval("return {KEYS[1], KEYS[2]}", MULTI, "one", "two")).isEqualTo(list("one", "two"));
+        assertThat((List<?>) redis.eval("return {KEYS[1], KEYS[2]}", MULTI, "one", "two")).isEqualTo(list("one", "two"));
     }
 
     @Test
     public void evalWithArgs() throws Exception {
         String[] keys = new String[0];
-        assertThat((List) redis.eval("return {ARGV[1], ARGV[2]}", MULTI, keys, "a", "b")).isEqualTo(list("a", "b"));
+        assertThat((List<?>) redis.eval("return {ARGV[1], ARGV[2]}", MULTI, keys, "a", "b")).isEqualTo(list("a", "b"));
     }
 
     @Test

File: src/test/java/com/lambdaworks/redis/protocol/CommandHandlerTest.java
Patch:
@@ -57,10 +57,10 @@ public void testExceptionWithQueue() throws Exception {
 
         sut.channelActive(context);
 
-        Command<String, String, String> command = new Command<String, String, String>(CommandType.APPEND,
-                new StatusOutput<String, String>(new Utf8StringCodec()), null);
+        Command<String, String, String> command = new Command<String, String, String>(CommandType.APPEND, new StatusOutput<>(
+                new Utf8StringCodec()), null);
 
-        AsyncCommand<String, String, String> async = new AsyncCommand(command);
+        AsyncCommand<String, String, String> async = new AsyncCommand<>(command);
         q.add(async);
         sut.exceptionCaught(context, new Exception());
 

File: src/main/java/com/lambdaworks/redis/AbstractRedisClient.java
Patch:
@@ -201,7 +201,7 @@ protected <K, V, T extends RedisChannelHandler<K, V>> T initializeChannel(Connec
                 initializer.channelInitialized().get(connectionBuilder.getTimeout(), connectionBuilder.getTimeUnit());
             } catch (TimeoutException e) {
                 throw new RedisConnectionException("Could not initialize channel within " + connectionBuilder.getTimeout()
-                        + " " + connectionBuilder.getTimeUnit());
+                        + " " + connectionBuilder.getTimeUnit(), e);
             }
             connection.registerCloseables(closeableResources, connection, connectionBuilder.commandHandler());
 

File: src/main/java/com/lambdaworks/redis/BaseRedisAsyncCommands.java
Patch:
@@ -25,10 +25,9 @@
 import com.lambdaworks.redis.protocol.AsyncCommand;
 import com.lambdaworks.redis.protocol.Command;
 import com.lambdaworks.redis.protocol.CommandArgs;
-import com.lambdaworks.redis.protocol.CommandOutput;
+import com.lambdaworks.redis.output.CommandOutput;
 import com.lambdaworks.redis.protocol.CommandType;
 import com.lambdaworks.redis.protocol.RedisCommand;
-import com.lambdaworks.redis.protocol.SetArgs;
 
 /**
  * An asynchronous thread-safe API to a redis connection.

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnection.java
Patch:
@@ -17,7 +17,7 @@
 import com.lambdaworks.redis.pubsub.StatefulRedisPubSubConnection;
 
 /**
- * Complete async Redis API with 400+ Methods.
+ * A complete asynchronous and thread-safe Redis API with 400+ Methods.
  * 
  * @param <K> Key type.
  * @param <V> Value type.

File: src/main/java/com/lambdaworks/redis/RedisClient.java
Patch:
@@ -122,7 +122,7 @@ public <K, V> RedisConnectionPool<RedisConnection<K, V>> pool(final RedisCodec<K
 
         long maxWait = makeTimeout();
         RedisConnectionPool<RedisConnection<K, V>> pool = new RedisConnectionPool<RedisConnection<K, V>>(
-                new RedisConnectionProvider<RedisConnection<K, V>>() {
+                new RedisConnectionPool.RedisConnectionProvider<RedisConnection<K, V>>() {
                     @Override
                     public RedisConnection<K, V> createConnection() {
                         return connect(codec, redisURI);
@@ -196,7 +196,7 @@ public <K, V> RedisConnectionPool<RedisAsyncConnection<K, V>> asyncPool(final Re
         checkForRedisURI();
         long maxWait = makeTimeout();
         RedisConnectionPool<RedisAsyncConnection<K, V>> pool = new RedisConnectionPool<RedisAsyncConnection<K, V>>(
-                new RedisConnectionProvider<RedisAsyncConnection<K, V>>() {
+                new RedisConnectionPool.RedisConnectionProvider<RedisAsyncConnection<K, V>>() {
                     @Override
                     public RedisAsyncConnection<K, V> createConnection() {
                         return connectStateful(codec, redisURI).async();

File: src/main/java/com/lambdaworks/redis/RedisClusterAsyncConnection.java
Patch:
@@ -16,7 +16,7 @@
 import com.lambdaworks.redis.api.async.RedisStringsAsyncConnection;
 
 /**
- * Complete asynchronous cluster Redis API with 400+ Methods..
+ * A complete asynchronous and thread-safe cluster Redis API with 400+ Methods.
  * 
  * @param <K> Key type.
  * @param <V> Value type.

File: src/main/java/com/lambdaworks/redis/RedisConnection.java
Patch:
@@ -7,7 +7,7 @@
 
 /**
  * 
- * Complete synchronous Redis API with 400+ Methods.
+ * A complete synchronous and thread-safe Redis API with 400+ Methods.
  * 
  * @param <K> Key type.
  * @param <V> Value type.

File: src/main/java/com/lambdaworks/redis/SetArgs.java
Patch:
@@ -1,7 +1,9 @@
 // Copyright (C) 2011 - Will Glozer.  All rights reserved.
 // Copyright (C) 2013 - Vincent Rischmann.  All rights reserved.
 
-package com.lambdaworks.redis.protocol;
+package com.lambdaworks.redis;
+
+import com.lambdaworks.redis.protocol.CommandArgs;
 
 /**
  * Argument list builder for the new redis <a href="http://redis.io/commands/set">SET</a> command starting from Redis 2.6.12.

File: src/main/java/com/lambdaworks/redis/StatefulRedisConnectionImpl.java
Patch:
@@ -24,7 +24,7 @@
 import io.netty.channel.ChannelHandler;
 
 /**
- * An thread-safe connection to a redis server. Multiple threads may share one {@link StatefulRedisConnectionImpl}
+ * A thread-safe connection to a redis server. Multiple threads may share one {@link StatefulRedisConnectionImpl}
  *
  * A {@link ConnectionWatchdog} monitors each connection and reconnects automatically until {@link #close} is called. All
  * pending commands will be (re)sent after successful reconnection.

File: src/main/java/com/lambdaworks/redis/api/StatefulConnection.java
Patch:
@@ -13,10 +13,10 @@
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>
  * @since 4.0
  */
-public interface StatefulConnection<K, V> {
+public interface StatefulConnection<K, V> extends AutoCloseable {
 
     /**
-     * Set the command timeout for this connection.
+     * Set the default command timeout for this connection.
      *
      * @param timeout Command timeout.
      * @param unit Unit of time for the timeout.

File: src/main/java/com/lambdaworks/redis/api/async/RedisStringsAsyncConnection.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.List;
 import java.util.Map;
 import com.lambdaworks.redis.output.ValueStreamingChannel;
-import com.lambdaworks.redis.protocol.SetArgs;
+import com.lambdaworks.redis.SetArgs;
 import com.lambdaworks.redis.RedisFuture;
 
 /**

File: src/main/java/com/lambdaworks/redis/api/sync/RedisStringsConnection.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.List;
 import java.util.Map;
 import com.lambdaworks.redis.output.ValueStreamingChannel;
-import com.lambdaworks.redis.protocol.SetArgs;
+import com.lambdaworks.redis.SetArgs;
 
 /**
  * Synchronous executed commands for Strings.

File: src/main/java/com/lambdaworks/redis/cluster/ClusterCommand.java
Patch:
@@ -4,12 +4,10 @@
 import java.util.List;
 
 import com.lambdaworks.redis.RedisChannelWriter;
-import com.lambdaworks.redis.RedisCommandExecutionException;
 import com.lambdaworks.redis.protocol.AsyncCommand;
-import com.lambdaworks.redis.protocol.Command;
 import com.lambdaworks.redis.protocol.CommandArgs;
 import com.lambdaworks.redis.protocol.CommandKeyword;
-import com.lambdaworks.redis.protocol.CommandOutput;
+import com.lambdaworks.redis.output.CommandOutput;
 import com.lambdaworks.redis.protocol.ProtocolKeyword;
 import com.lambdaworks.redis.protocol.RedisCommand;
 import io.netty.buffer.ByteBuf;

File: src/main/java/com/lambdaworks/redis/output/ArrayOutput.java
Patch:
@@ -4,7 +4,6 @@
 import java.util.*;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * {@link java.util.List} of objects and lists to support dynamic nested structures (List with mixed content of values and

File: src/main/java/com/lambdaworks/redis/output/BooleanListOutput.java
Patch:
@@ -6,7 +6,6 @@
 import java.util.List;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * {@link java.util.List} of boolean output.

File: src/main/java/com/lambdaworks/redis/output/BooleanOutput.java
Patch:
@@ -5,7 +5,6 @@
 import java.nio.ByteBuffer;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * Boolean output. The actual value is returned as an integer where 0 indicates false and 1 indicates true, or as a null bulk

File: src/main/java/com/lambdaworks/redis/output/ByteArrayOutput.java
Patch:
@@ -5,7 +5,6 @@
 import java.nio.ByteBuffer;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * Byte array output.

File: src/main/java/com/lambdaworks/redis/output/CommandOutput.java
Patch:
@@ -1,6 +1,6 @@
 // Copyright (C) 2011 - Will Glozer.  All rights reserved.
 
-package com.lambdaworks.redis.protocol;
+package com.lambdaworks.redis.output;
 
 import java.nio.ByteBuffer;
 

File: src/main/java/com/lambdaworks/redis/output/DateOutput.java
Patch:
@@ -5,7 +5,6 @@
 import java.util.Date;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * Date output with no milliseconds.

File: src/main/java/com/lambdaworks/redis/output/DoubleOutput.java
Patch:
@@ -5,7 +5,6 @@
 import java.nio.ByteBuffer;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 import static java.lang.Double.parseDouble;
 

File: src/main/java/com/lambdaworks/redis/output/IntegerOutput.java
Patch:
@@ -5,7 +5,6 @@
 import java.nio.ByteBuffer;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * 64-bit integer output, may be null.

File: src/main/java/com/lambdaworks/redis/output/KeyListOutput.java
Patch:
@@ -7,7 +7,6 @@
 import java.util.List;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * {@link List} of keys output.

File: src/main/java/com/lambdaworks/redis/output/KeyOutput.java
Patch:
@@ -5,7 +5,6 @@
 import java.nio.ByteBuffer;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * Key output.

File: src/main/java/com/lambdaworks/redis/output/KeyStreamingOutput.java
Patch:
@@ -3,7 +3,6 @@
 import java.nio.ByteBuffer;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * Streaming-Output of Keys. Returns the count of all keys (including null).

File: src/main/java/com/lambdaworks/redis/output/KeyValueOutput.java
Patch:
@@ -4,7 +4,6 @@
 
 import com.lambdaworks.redis.KeyValue;
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 import java.nio.ByteBuffer;
 

File: src/main/java/com/lambdaworks/redis/output/KeyValueStreamingOutput.java
Patch:
@@ -5,7 +5,6 @@
 import java.nio.ByteBuffer;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * Streaming-Output of Key Value Pairs. Returns the count of all Key-Value pairs (including null).

File: src/main/java/com/lambdaworks/redis/output/ListOfMapsOutput.java
Patch:
@@ -9,7 +9,6 @@
 import java.util.Map;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * {@link java.util.List} of maps output.

File: src/main/java/com/lambdaworks/redis/output/MapOutput.java
Patch:
@@ -7,7 +7,6 @@
 import java.util.Map;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * {@link Map} of keys and values output.

File: src/main/java/com/lambdaworks/redis/output/MultiOutput.java
Patch:
@@ -10,7 +10,6 @@
 
 import com.lambdaworks.redis.RedisCommandExecutionException;
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 import com.lambdaworks.redis.protocol.RedisCommand;
 
 /**

File: src/main/java/com/lambdaworks/redis/output/NestedMultiOutput.java
Patch:
@@ -10,7 +10,6 @@
 
 import com.lambdaworks.redis.RedisCommandExecutionException;
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * {@link List} of command outputs, possibly deeply nested.

File: src/main/java/com/lambdaworks/redis/output/ScanOutput.java
Patch:
@@ -5,7 +5,6 @@
 import com.lambdaworks.redis.LettuceStrings;
 import com.lambdaworks.redis.ScanCursor;
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * Cursor handling output.

File: src/main/java/com/lambdaworks/redis/output/ScoredValueListOutput.java
Patch:
@@ -8,7 +8,6 @@
 
 import com.lambdaworks.redis.ScoredValue;
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * {@link List} of values and their associated scores.

File: src/main/java/com/lambdaworks/redis/output/ScoredValueStreamingOutput.java
Patch:
@@ -4,7 +4,6 @@
 
 import com.lambdaworks.redis.ScoredValue;
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * Streaming-Output of of values and their associated scores. Returns the count of all values (including null).

File: src/main/java/com/lambdaworks/redis/output/StatusOutput.java
Patch:
@@ -5,7 +5,6 @@
 import java.nio.ByteBuffer;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 import static com.lambdaworks.redis.protocol.LettuceCharsets.buffer;
 

File: src/main/java/com/lambdaworks/redis/output/StringListOutput.java
Patch:
@@ -7,7 +7,6 @@
 import java.util.List;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * {@link List} of string output.

File: src/main/java/com/lambdaworks/redis/output/ValueListOutput.java
Patch:
@@ -7,7 +7,6 @@
 import java.util.List;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * {@link List} of values output.

File: src/main/java/com/lambdaworks/redis/output/ValueOutput.java
Patch:
@@ -5,7 +5,6 @@
 import java.nio.ByteBuffer;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * Value output.

File: src/main/java/com/lambdaworks/redis/output/ValueSetOutput.java
Patch:
@@ -7,7 +7,6 @@
 import java.util.Set;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * {@link Set} of value output.

File: src/main/java/com/lambdaworks/redis/output/ValueStreamingOutput.java
Patch:
@@ -3,7 +3,6 @@
 import java.nio.ByteBuffer;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
 
 /**
  * Streaming-Output of Values. Returns the count of all values (including null).

File: src/main/java/com/lambdaworks/redis/protocol/AsyncCommand.java
Patch:
@@ -7,6 +7,7 @@
 import com.lambdaworks.redis.RedisCommandExecutionException;
 import com.lambdaworks.redis.RedisCommandInterruptedException;
 import com.lambdaworks.redis.RedisFuture;
+import com.lambdaworks.redis.output.CommandOutput;
 import io.netty.buffer.ByteBuf;
 
 /**

File: src/main/java/com/lambdaworks/redis/protocol/Command.java
Patch:
@@ -2,6 +2,7 @@
 
 package com.lambdaworks.redis.protocol;
 
+import com.lambdaworks.redis.output.CommandOutput;
 import io.netty.buffer.ByteBuf;
 
 /**

File: src/main/java/com/lambdaworks/redis/protocol/RedisCommand.java
Patch:
@@ -1,5 +1,6 @@
 package com.lambdaworks.redis.protocol;
 
+import com.lambdaworks.redis.output.CommandOutput;
 import io.netty.buffer.ByteBuf;
 
 /**

File: src/main/java/com/lambdaworks/redis/protocol/RedisStateMachine.java
Patch:
@@ -11,6 +11,7 @@
 
 import com.lambdaworks.redis.RedisException;
 
+import com.lambdaworks.redis.output.CommandOutput;
 import io.netty.buffer.ByteBuf;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;

File: src/main/java/com/lambdaworks/redis/pubsub/PubSubCommandHandler.java
Patch:
@@ -7,7 +7,7 @@
 import com.lambdaworks.redis.ClientOptions;
 import com.lambdaworks.redis.codec.RedisCodec;
 import com.lambdaworks.redis.protocol.CommandHandler;
-import com.lambdaworks.redis.protocol.CommandOutput;
+import com.lambdaworks.redis.output.CommandOutput;
 import com.lambdaworks.redis.protocol.RedisCommand;
 
 import io.netty.buffer.ByteBuf;

File: src/main/java/com/lambdaworks/redis/pubsub/PubSubOutput.java
Patch:
@@ -5,7 +5,7 @@
 import java.nio.ByteBuffer;
 
 import com.lambdaworks.redis.codec.RedisCodec;
-import com.lambdaworks.redis.protocol.CommandOutput;
+import com.lambdaworks.redis.output.CommandOutput;
 
 /**
  * One element of the redis pub/sub stream. May be a message or notification of subscription details.

File: src/main/java/com/lambdaworks/redis/pubsub/RedisPubSubAsyncConnection.java
Patch:
@@ -4,6 +4,8 @@
 import com.lambdaworks.redis.RedisFuture;
 
 /**
+ * Asynchronous and thread-safe Redis PubSub API.
+ *
  * @param <K> Key type.
  * @param <V> Value type.
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>

File: src/main/java/com/lambdaworks/redis/pubsub/RedisPubSubConnection.java
Patch:
@@ -3,6 +3,9 @@
 import com.lambdaworks.redis.RedisConnection;
 
 /**
+ * 
+ * Synchronous and thread-safe Redis PubSub API.
+ * 
  * @param <K> Key type.
  * @param <V> Value type.
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>

File: src/main/templates/com/lambdaworks/redis/api/RedisSentinelConnection.java
Patch:
@@ -7,7 +7,7 @@
 import java.util.concurrent.Future;
 
 /**
- * ${intent} for Sentinel.
+ * ${intent} for Redis Sentinel.
  * 
  * @param <K> Key type.
  * @param <V> Value type.

File: src/main/templates/com/lambdaworks/redis/api/RedisStringsConnection.java
Patch:
@@ -4,7 +4,7 @@
 import java.util.Map;
 
 import com.lambdaworks.redis.output.ValueStreamingChannel;
-import com.lambdaworks.redis.protocol.SetArgs;
+import com.lambdaworks.redis.SetArgs;
 
 /**
  * ${intent} for Strings.

File: src/test/java/com/lambdaworks/redis/ConnectionCommandTest.java
Patch:
@@ -83,6 +83,7 @@ public void selectReconnect() throws Exception {
         redis.select(1);
         redis.set(key, value);
         redis.quit();
+        Thread.sleep(200);
         Assertions.assertThat(redis.get(key)).isEqualTo(value);
     }
 

File: src/test/java/com/lambdaworks/redis/PoolConnectionTest.java
Patch:
@@ -62,7 +62,7 @@ public void connectionCloseDoesNotClose() throws Exception {
     private RedisConnection assertConnectionStillThere(RedisConnection<String, String> c1) {
         // unwrap code from RedisConnectionPool destroyObject
         if (Proxy.isProxyClass(c1.getClass())) {
-            PooledConnectionInvocationHandler<RedisConnection> invocationHandler = (PooledConnectionInvocationHandler<RedisConnection>) Proxy
+            RedisConnectionPool.PooledConnectionInvocationHandler<RedisConnection> invocationHandler = (RedisConnectionPool.PooledConnectionInvocationHandler<RedisConnection>) Proxy
                     .getInvocationHandler(c1);
 
             RedisConnection connection = invocationHandler.getConnection();

File: src/test/java/com/lambdaworks/redis/cluster/AbstractClusterTest.java
Patch:
@@ -27,8 +27,6 @@ public class AbstractClusterTest {
 
     protected Logger log = Logger.getLogger(getClass());
 
-    protected RedisClusterAsyncConnection<String, String> redis1;
-
     protected String key = "key";
     protected String value = "value";
 

File: src/test/java/com/lambdaworks/redis/commands/CommandInternalsTest.java
Patch:
@@ -21,7 +21,7 @@
 import com.lambdaworks.redis.protocol.Command;
 import com.lambdaworks.redis.protocol.CommandArgs;
 import com.lambdaworks.redis.protocol.CommandKeyword;
-import com.lambdaworks.redis.protocol.CommandOutput;
+import com.lambdaworks.redis.output.CommandOutput;
 import com.lambdaworks.redis.protocol.CommandType;
 import com.lambdaworks.redis.protocol.ProtocolKeyword;
 

File: src/test/java/com/lambdaworks/redis/protocol/StateMachineTest.java
Patch:
@@ -9,6 +9,7 @@
 import java.util.Arrays;
 import java.util.List;
 
+import com.lambdaworks.redis.output.CommandOutput;
 import org.junit.Before;
 import org.junit.Test;
 

File: src/main/java/com/lambdaworks/redis/RedisChannelHandler.java
Patch:
@@ -102,9 +102,8 @@ public void channelRead(Object msg) {
     protected <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> cmd) {
 
         if (clientOptions != null && !clientOptions.isAutoReconnect() && !active) {
-            cmd.setException(new RedisException(
+            cmd.completeExceptionally(new RedisException(
                     "Connection is in a disconnected state and reconnect is disabled. Commands are not accepted."));
-            cmd.complete();
             return cmd;
         }
 

File: src/test/java/com/lambdaworks/redis/CommandInternalsTest.java
Patch:
@@ -32,7 +32,7 @@ public void isCancelled() throws Exception {
         assertThat(command.isCancelled()).isFalse();
         assertThat(command.cancel(true)).isTrue();
         assertThat(command.isCancelled()).isTrue();
-        assertThat(command.cancel(true)).isFalse();
+        assertThat(command.cancel(true)).isTrue();
     }
 
     @Test
@@ -85,13 +85,13 @@ public void awaitTimeout() throws Exception {
         assertThat(command.await(2, TimeUnit.MICROSECONDS)).isFalse();
     }
 
-    @Test(expected = RedisCommandInterruptedException.class, timeout = 10)
+    @Test(expected = InterruptedException.class, timeout = 10)
     public void getInterrupted() throws Exception {
         Thread.currentThread().interrupt();
         command.get();
     }
 
-    @Test(expected = RedisCommandInterruptedException.class, timeout = 10)
+    @Test(expected = InterruptedException.class, timeout = 10)
     public void getInterrupted2() throws Exception {
         Thread.currentThread().interrupt();
         command.get(5, TimeUnit.MILLISECONDS);

File: src/main/java/com/lambdaworks/redis/RedisSortedSetsConnection.java
Patch:
@@ -482,7 +482,7 @@ public interface RedisSortedSetsConnection<K, V> {
      * @param count the count
      * @return List&lt;V&gt; array-reply list of elements in the specified score range.
      */
-    List<ScoredValue<ScoredValue<V>>> zrevrangebyscoreWithScores(K key, String max, String min, long offset, long count);
+    List<ScoredValue<V>> zrevrangebyscoreWithScores(K key, String max, String min, long offset, long count);
 
     /**
      * Stream over a range of members in a sorted set, by index, with scores ordered from high to low.

File: src/main/java/com/lambdaworks/redis/protocol/CommandHandler.java
Patch:
@@ -146,7 +146,7 @@ public <T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {
 
             try {
                 writeLock.lock();
-                if (channel != null) {
+                if (channel != null && connected) {
                     if (logger.isDebugEnabled()) {
                         logger.debug("[" + this + "] write() writeAndFlush Command " + command);
                     }

File: src/main/java/com/lambdaworks/redis/protocol/ConnectionWatchdog.java
Patch:
@@ -108,14 +108,15 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
      * Schedule reconnect if channel is not available/not active.
      */
     public void scheduleReconnect() {
-
+        logger.debug("scheduleReconnect()");
         if (channel == null || !channel.isActive()) {
-            logger.debug("scheduleReconnect()");
             if (attempts < RETRY_TIMEOUT_MAX) {
                 attempts++;
             }
             int timeout = 2 << attempts;
             timer.newTimeout(this, timeout, TimeUnit.MILLISECONDS);
+        } else {
+            logger.debug("Skipping scheduleReconnect() because I have an active channel");
         }
     }
 

File: src/main/java/com/lambdaworks/redis/cluster/RedisClusterClient.java
Patch:
@@ -136,7 +136,7 @@ <K, V> RedisAsyncConnectionImpl<K, V> connectAsyncImpl(RedisCodec<K, V> codec, f
             public SocketAddress get() {
                 return socketAddress;
             }
-        }, true);
+        });
 
         connection.registerCloseables(closeableResources, connection);
 
@@ -175,7 +175,7 @@ <K, V> RedisAsyncConnectionImpl<K, V> connectClusterAsyncImpl(RedisCodec<K, V> c
                 pooledClusterConnectionProvider);
         RedisAsyncConnectionImpl<K, V> connection = newRedisAsyncConnectionImpl(clusterWriter, codec, timeout, unit);
 
-        connectAsyncImpl(handler, connection, socketAddressSupplier, true);
+        connectAsyncImpl(handler, connection, socketAddressSupplier);
 
         connection.registerCloseables(closeableResources, connection, clusterWriter, pooledClusterConnectionProvider);
 

File: src/test/java/com/lambdaworks/redis/AbstractCommandTest.java
Patch:
@@ -41,6 +41,7 @@ public static void shutdownClient() {
 
     @Before
     public void openConnection() throws Exception {
+        client.setOptions(new ClientOptions.Builder().build());
         redis = client.connect();
         redis.flushall();
         redis.flushdb();

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnectionImpl.java
Patch:
@@ -1579,14 +1579,14 @@ protected <T> RedisCommand<K, V, T> dispatch(CommandType type, CommandOutput<K,
         return dispatch(type, output, null);
     }
 
-    protected synchronized <T> RedisCommand<K, V, T> dispatch(CommandType type, CommandOutput<K, V, T> output,
+    protected <T> RedisCommand<K, V, T> dispatch(CommandType type, CommandOutput<K, V, T> output,
             CommandArgs<K, V> args) {
         Command<K, V, T> cmd = new Command<K, V, T>(type, output, args, multi != null);
         return dispatch(cmd);
     }
 
     @Override
-    public synchronized <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> cmd) {
+    public <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> cmd) {
         if (multi != null && cmd instanceof Command) {
             Command<K, V, T> command = (Command<K, V, T>) cmd;
             command.setMulti(true);

File: src/main/java/com/lambdaworks/redis/ScriptOutputType.java
Patch:
@@ -10,7 +10,7 @@
  * <li>{@link #INTEGER} 64-bit integer</li>
  * <li>{@link #STATUS} status string</li>
  * <li>{@link #VALUE} value</li>
- * <li>{@link #MULTI} of these types</li>.
+ * <li>{@link #MULTI} of these types</li>
  * </ul>
  * 
  * <strong>Redis to Lua</strong> conversion table.

File: src/main/java/com/lambdaworks/redis/support/RedisClientFactoryBean.java
Patch:
@@ -9,7 +9,8 @@
  * Factory Bean for RedisClient instances. Needs either a URI or a RedisURI as input. URI Formats:
  * {@code
  *     redis-sentinel://host[:port][,host2[:port2]][/databaseNumber]#sentinelMasterId
- * } <br/>
+ * }
+ *
  * {@code
  *     redis://host[:port][/databaseNumber]
  * }

File: src/main/java/com/lambdaworks/codec/CRC16.java
Patch:
@@ -45,7 +45,7 @@ private CRC16() {
     /**
      * Create a CRC16 checksum from the bytes.
      * 
-     * @param bytes
+     * @param bytes input bytes
      * @return CRC16 as interger value
      */
     public static int crc16(byte[] bytes) {

File: src/main/java/com/lambdaworks/redis/KeyValue.java
Patch:
@@ -10,13 +10,14 @@
  * @author Will Glozer
  */
 public class KeyValue<K, V> {
+
     public final K key;
     public final V value;
 
     /**
      * 
-     * @param key
-     * @param value
+     * @param key the key
+     * @param value the value
      */
     public KeyValue(K key, V value) {
         this.key = key;

File: src/main/java/com/lambdaworks/redis/KillArgs.java
Patch:
@@ -8,7 +8,7 @@
 /**
  *
  * Argument list builder for the redis <a href="http://redis.io/commands/client-kill">CLIENT KILL</a> command. Static import the
- * methods from {@link Builder} and chain the method calls: <code>id(1).skipme()</code>.
+ * methods from {@link Builder} and chain the method calls: {@code id(1).skipme()}.
  *
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>
  * @since 3.0

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnectionImpl.java
Patch:
@@ -43,7 +43,7 @@ public class RedisAsyncConnectionImpl<K, V> extends RedisChannelHandler<K, V> im
     /**
      * Initialize a new connection.
      * 
-     * @param writer
+     * @param writer the channel writer
      * @param codec Codec used to encode/decode keys and values.
      * @param timeout Maximum time to wait for a response.
      * @param unit Unit of time for the timeout.

File: src/main/java/com/lambdaworks/redis/RedisHLLAsyncConnection.java
Patch:
@@ -29,7 +29,7 @@ public interface RedisHLLAsyncConnection<K, V> {
      * @param sourcekey the source key
      * @param moreSourceKeys more source keys
      * 
-     * @return RedisFuture&lt;Long&gt; simple-string-reply The command just returns <code>OK</code>.
+     * @return RedisFuture&lt;Long&gt; simple-string-reply The command just returns {@code OK}.
      */
     RedisFuture<Long> pfmerge(K destkey, K sourcekey, K... moreSourceKeys);
 
@@ -41,7 +41,7 @@ public interface RedisHLLAsyncConnection<K, V> {
      * 
      * @return RedisFuture&lt;Long&gt; integer-reply specifically:
      * 
-     *         The approximated number of unique elements observed via <code>PFADD</code>.
+     *         The approximated number of unique elements observed via {@code PFADD}.
      */
     RedisFuture<Long> pfcount(K key, K... moreKeys);
 

File: src/main/java/com/lambdaworks/redis/RedisHLLConnection.java
Patch:
@@ -29,7 +29,7 @@ public interface RedisHLLConnection<K, V> {
      * @param sourcekey the source key
      * @param moreSourceKeys more source keys
      * 
-     * @return Long simple-string-reply The command just returns <code>OK</code>.
+     * @return Long simple-string-reply The command just returns {@code OK}.
      */
     Long pfmerge(K destkey, K sourcekey, K... moreSourceKeys);
 
@@ -41,7 +41,7 @@ public interface RedisHLLConnection<K, V> {
      * 
      * @return Long integer-reply specifically:
      * 
-     *         The approximated number of unique elements observed via <code>PFADD</code>.
+     *         The approximated number of unique elements observed via {@code PFADD}.
      */
     Long pfcount(K key, K... moreKeys);
 

File: src/main/java/com/lambdaworks/redis/SortArgs.java
Patch:
@@ -18,7 +18,7 @@
 
 /**
  * Argument list builder for the redis <a href="http://redis.io/commands/sort">SORT</a> command. Static import the methods from
- * {@link Builder} and chain the method calls: <code>by("weight_*").desc().limit(0, 2)</code>.
+ * {@link Builder} and chain the method calls: {@code by("weight_*").desc().limit(0, 2)}.
  * 
  * @author Will Glozer
  */

File: src/main/java/com/lambdaworks/redis/ZStoreArgs.java
Patch:
@@ -16,7 +16,7 @@
 /**
  * Argument list builder for the redis <a href="http://redis.io/commands/zunionstore">ZUNIONSTORE</a> and <a
  * href="http://redis.io/commands/zinterstore">ZINTERSTORE</a> commands. Static import the methods from {@link Builder} and
- * chain the method calls: <code>weights(1, 2).max()</code>.
+ * chain the method calls: {@code weights(1, 2).max()}.
  * 
  * @author Will Glozer
  */

File: src/main/java/com/lambdaworks/redis/cluster/SlotHash.java
Patch:
@@ -28,7 +28,7 @@ private SlotHash() {
     /**
      * Calculate the slot from the given key.
      * 
-     * @param key
+     * @param key the key
      * @return slot
      */
     public static final int getSlot(String key) {
@@ -38,7 +38,7 @@ public static final int getSlot(String key) {
     /**
      * Calculate the slot from the given key.
      * 
-     * @param key
+     * @param key the key
      * @return slot
      */
     public static final int getSlot(byte[] key) {

File: src/main/java/com/lambdaworks/redis/cluster/models/partitions/ClusterPartitionParser.java
Patch:
@@ -48,7 +48,7 @@ private ClusterPartitionParser() {
     /**
      * Parse partition lines into Partitions object.
      * 
-     * @param nodes
+     * @param nodes output of CLUSTER NODES
      * @return the partitions object.
      */
     public static Partitions parse(String nodes) {

File: src/main/java/com/lambdaworks/redis/cluster/models/partitions/Partitions.java
Patch:
@@ -15,7 +15,7 @@ public class Partitions implements Iterable<RedisClusterNode> {
     /**
      * Retrieve a {@link RedisClusterNode} by it's slot number. This method does not distinguish between masters and slaves.
      * 
-     * @param slot
+     * @param slot the slot
      * @return RedisClusterNode or {@literal null}
      */
     public RedisClusterNode getPartitionBySlot(int slot) {

File: src/main/java/com/lambdaworks/redis/cluster/models/slots/ClusterSlotsParser.java
Patch:
@@ -28,7 +28,7 @@ private ClusterSlotsParser() {
      * Parse the output of the redis CLUSTER SLOTS command and convert it to a list of
      * {@link com.lambdaworks.redis.cluster.models.slots.ClusterSlotRange}
      * 
-     * @param clusterSlotsOutput
+     * @param clusterSlotsOutput output of CLUSTER SLOTS command
      * @return List&gt;ClusterSlotRange&gt;
      */
     public static List<ClusterSlotRange> parse(List<?> clusterSlotsOutput) {

File: src/main/java/com/lambdaworks/redis/models/role/RoleParser.java
Patch:
@@ -34,7 +34,7 @@ private RoleParser() {
     /**
      * Parse the output of the redis ROLE command and convert to a RedisInstance.
      * 
-     * @param roleOutput
+     * @param roleOutput output of the redis ROLE command
      * @return RedisInstance
      */
     public static RedisInstance parse(List<?> roleOutput) {

File: src/main/java/com/lambdaworks/redis/output/KeyScanStreamingOutput.java
Patch:
@@ -6,8 +6,8 @@
 import com.lambdaworks.redis.codec.RedisCodec;
 
 /**
- * Streaming API for multiple Keys. You can implement this interface in order to receive a call to <code>onKey</code> on every
- * key. Key uniqueness is not guaranteed.
+ * Streaming API for multiple Keys. You can implement this interface in order to receive a call to {@code onKey} on every key.
+ * Key uniqueness is not guaranteed.
  * 
  * @param <K> Key type.
  * @param <V> Value type.

File: src/main/java/com/lambdaworks/redis/output/KeyStreamingChannel.java
Patch:
@@ -1,8 +1,8 @@
 package com.lambdaworks.redis.output;
 
 /**
- * Streaming API for multiple Keys. You can implement this interface in order to receive a call to <code>onKey</code> on every
- * key. Key uniqueness is not guaranteed.
+ * Streaming API for multiple Keys. You can implement this interface in order to receive a call to {@code onKey} on every key.
+ * Key uniqueness is not guaranteed.
  * 
  * @param <K> Key type.
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>
@@ -12,7 +12,7 @@ public interface KeyStreamingChannel<K> {
     /**
      * Called on every incoming key.
      * 
-     * @param key
+     * @param key the key
      */
     void onKey(K key);
 }

File: src/main/java/com/lambdaworks/redis/output/ScoredValueStreamingChannel.java
Patch:
@@ -3,7 +3,7 @@
 import com.lambdaworks.redis.ScoredValue;
 
 /**
- * Streaming API for multiple Keys. You can implement this interface in order to receive a call to <code>onValue</code> on every
+ * Streaming API for multiple Keys. You can implement this interface in order to receive a call to {@code onValue} on every
  * value.
  * 
  * @param <V> Value type.
@@ -14,7 +14,7 @@ public interface ScoredValueStreamingChannel<V> {
     /**
      * Called on every incoming ScoredValue.
      * 
-     * @param value
+     * @param value the scored value
      */
     void onValue(ScoredValue<V> value);
 }

File: src/main/java/com/lambdaworks/redis/output/ValueScanStreamingOutput.java
Patch:
@@ -6,8 +6,8 @@
 import com.lambdaworks.redis.codec.RedisCodec;
 
 /**
- * Streaming API for multiple Values. You can implement this interface in order to receive a call to <code>onValue</code> on
- * every key.
+ * Streaming API for multiple Values. You can implement this interface in order to receive a call to {@code onValue} on every
+ * key.
  * 
  * @param <K> Key type.
  * @param <V> Value type.

File: src/main/java/com/lambdaworks/redis/output/ValueStreamingChannel.java
Patch:
@@ -1,7 +1,7 @@
 package com.lambdaworks.redis.output;
 
 /**
- * Streaming API for multiple Keys. You can implement this interface in order to receive a call to <code>onValue</code> on every
+ * Streaming API for multiple Keys. You can implement this interface in order to receive a call to {@code onValue} on every
  * value.
  * 
  * @param <V> Value type.
@@ -12,7 +12,7 @@ public interface ValueStreamingChannel<V> {
     /**
      * Called on every incoming value.
      * 
-     * @param value
+     * @param value the value
      */
     void onValue(V value);
 }

File: src/main/java/com/lambdaworks/redis/protocol/ConnectionWatchdog.java
Patch:
@@ -58,7 +58,7 @@ public ConnectionWatchdog(Bootstrap bootstrap, Timer timer) {
      * 
      * @param bootstrap Configuration for new channels.
      * @param timer Timer used for delayed reconnect.
-     * @param socketAddressSupplier
+     * @param socketAddressSupplier the socket address suplier for gaining an address to reconnect to
      */
     public ConnectionWatchdog(Bootstrap bootstrap, Timer timer, Supplier<SocketAddress> socketAddressSupplier) {
         this.bootstrap = bootstrap;

File: src/main/java/com/lambdaworks/redis/protocol/LettuceCharsets.java
Patch:
@@ -32,7 +32,7 @@ private LettuceCharsets() {
     /**
      * Create a ByteBuffer from a string using ASCII encoding.
      * 
-     * @param s
+     * @param s the string
      * @return ByteBuffer
      */
     public static ByteBuffer buffer(String s) {

File: src/main/java/com/lambdaworks/redis/protocol/RedisCommand.java
Patch:
@@ -16,7 +16,7 @@ public interface RedisCommand<K, V, T> extends ListenableFuture<T>, RedisFuture<
     /**
      * The command output. Can be null.
      * 
-     * @return CommandOutput<K, V, T>
+     * @return the command output.
      */
     CommandOutput<K, V, T> getOutput();
 
@@ -27,14 +27,14 @@ public interface RedisCommand<K, V, T> extends ListenableFuture<T>, RedisFuture<
 
     /**
      * 
-     * @return CommandArgs<K, V>
+     * @return the current command args
      */
     CommandArgs<K, V> getArgs();
 
     /**
      * Encode the command.
      * 
-     * @param buf
+     * @param buf byte buffer to operate on.
      */
     void encode(ByteBuf buf);
 

File: src/main/java/com/lambdaworks/redis/protocol/SetArgs.java
Patch:
@@ -5,7 +5,7 @@
 
 /**
  * Argument list builder for the new redis <a href="http://redis.io/commands/set">SET</a> command starting from Redis 2.6.12.
- * Static import the methods from {@link Builder} and chain the method calls: <code>ex(10).nx()</code>.
+ * Static import the methods from {@link Builder} and chain the method calls: {@code ex(10).nx()}.
  * 
  * @author Vincent Rischmann
  */

File: src/main/java/com/lambdaworks/redis/pubsub/RedisPubSubConnectionImpl.java
Patch:
@@ -44,7 +44,7 @@ public class RedisPubSubConnectionImpl<K, V> extends RedisAsyncConnectionImpl<K,
     /**
      * Initialize a new connection.
      * 
-     * @param writer
+     * @param writer the channel writer
      * @param codec Codec used to encode/decode keys and values.
      * @param timeout Maximum time to wait for a responses.
      * @param unit Unit of time for the timeout.

File: src/main/java/com/lambdaworks/redis/support/RedisClusterClientFactoryBean.java
Patch:
@@ -8,9 +8,10 @@
 import com.lambdaworks.redis.cluster.RedisClusterClient;
 
 /**
- * Factory Bean for RedisClient instances. Needs either a URI or a RedisURI as input. URI Format: <code>
+ * Factory Bean for RedisClient instances. Needs either a URI or a RedisURI as input. URI Format:
+ * {@code
  *     redis://host[:port][/databaseNumber]
- * </code>
+ * }
  * 
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>
  * @since 3.0

File: src/main/java/com/lambdaworks/redis/support/WithConnection.java
Patch:
@@ -29,7 +29,7 @@ public WithConnection(RedisConnectionPool<T> pool) {
     /**
      * Execution method. Will be called with a valid redis connection.
      * 
-     * @param connection
+     * @param connection the connection
      */
     protected abstract void run(T connection);
 }

File: src/main/java/com/lambdaworks/codec/CRC16.java
Patch:
@@ -15,7 +15,7 @@
  */
 public class CRC16 {
 
-    private static final int LOOKUP_TABLE[] = { 0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7, 0x8108, 0x9129,
+    private static final int[] LOOKUP_TABLE = { 0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7, 0x8108, 0x9129,
             0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF, 0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
             0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE, 0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7,
             0x44A4, 0x5485, 0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D, 0x3653, 0x2672, 0x1611, 0x0630,

File: src/main/java/com/lambdaworks/redis/AbstractRedisClient.java
Patch:
@@ -147,7 +147,6 @@ protected <K, V, T extends RedisChannelHandler<K, V>> T initializeChannel(Connec
         } catch (Exception e) {
             connection.close();
             throw new RedisConnectionException("Unable to connect", e);
-        } finally {
         }
     }
 

File: src/main/java/com/lambdaworks/redis/RedisChannelHandler.java
Patch:
@@ -63,6 +63,7 @@ public void setTimeout(long timeout, TimeUnit unit) {
     /**
      * Close the connection.
      */
+    @Override
     public synchronized void close() {
         logger.debug("close()");
 

File: src/main/java/com/lambdaworks/redis/SslConnectionBuilder.java
Patch:
@@ -150,6 +150,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
 
         }
 
+        @Override
         public Future<Boolean> channelInitialized() {
             return initializedFuture;
         }

File: src/main/java/com/lambdaworks/redis/cluster/models/slots/ClusterSlotRange.java
Patch:
@@ -81,7 +81,7 @@ public void setSlaves(List<HostAndPort> slaves) {
 
     @Override
     public String toString() {
-        final StringBuffer sb = new StringBuffer();
+        final StringBuilder sb = new StringBuilder();
         sb.append(getClass().getSimpleName());
         sb.append(" [from=").append(from);
         sb.append(", to=").append(to);

File: src/main/java/com/lambdaworks/redis/models/command/CommandDetail.java
Patch:
@@ -89,7 +89,7 @@ public void setKeyStepCount(int keyStepCount) {
 
     @Override
     public String toString() {
-        final StringBuffer sb = new StringBuffer();
+        final StringBuilder sb = new StringBuilder();
         sb.append(getClass().getSimpleName());
         sb.append(" [name='").append(name).append('\'');
         sb.append(", arity=").append(arity);

File: src/main/java/com/lambdaworks/redis/models/role/RedisMasterInstance.java
Patch:
@@ -62,7 +62,7 @@ public void setSlaves(List<ReplicationPartner> slaves) {
 
     @Override
     public String toString() {
-        final StringBuffer sb = new StringBuffer();
+        final StringBuilder sb = new StringBuilder();
         sb.append(getClass().getSimpleName());
         sb.append(" [replicationOffset=").append(replicationOffset);
         sb.append(", slaves=").append(slaves);

File: src/main/java/com/lambdaworks/redis/models/role/RedisSentinelInstance.java
Patch:
@@ -53,7 +53,7 @@ public void setMonitoredMasters(List<String> monitoredMasters) {
 
     @Override
     public String toString() {
-        final StringBuffer sb = new StringBuffer();
+        final StringBuilder sb = new StringBuilder();
         sb.append(getClass().getSimpleName());
         sb.append(" [monitoredMasters=").append(monitoredMasters);
         sb.append(']');

File: src/main/java/com/lambdaworks/redis/models/role/RedisSlaveInstance.java
Patch:
@@ -93,7 +93,7 @@ public enum State {
 
     @Override
     public String toString() {
-        final StringBuffer sb = new StringBuffer();
+        final StringBuilder sb = new StringBuilder();
         sb.append(getClass().getSimpleName());
         sb.append(" [master=").append(master);
         sb.append(", state=").append(state);

File: src/main/java/com/lambdaworks/redis/models/role/ReplicationPartner.java
Patch:
@@ -60,7 +60,7 @@ public void setReplicationOffset(long replicationOffset) {
 
     @Override
     public String toString() {
-        final StringBuffer sb = new StringBuffer();
+        final StringBuilder sb = new StringBuilder();
         sb.append(getClass().getSimpleName());
         sb.append(" [host=").append(host);
         sb.append(", replicationOffset=").append(replicationOffset);

File: src/main/java/com/lambdaworks/redis/output/ListOfMapsOutput.java
Patch:
@@ -37,7 +37,7 @@ public void set(ByteBuffer bytes) {
     @Override
     public void complete(int depth) {
 
-        if (counts.size() > 0) {
+        if (!counts.isEmpty()) {
             int expectedSize = counts.get(0);
 
             if (nested.get().size() == expectedSize) {

File: src/main/java/com/lambdaworks/redis/output/NestedMultiOutput.java
Patch:
@@ -54,7 +54,7 @@ public void complete(int depth) {
 
     @Override
     public void multi(int count) {
-        ArrayList<Object> a = new ArrayList<Object>(count);
+        List<Object> a = new ArrayList<Object>(count);
         output.add(a);
         stack.push(output);
         output = a;

File: src/main/java/com/lambdaworks/redis/protocol/CommandArgs.java
Patch:
@@ -199,7 +199,7 @@ public List<CommandKeyword> getKeywords() {
 
     @Override
     public String toString() {
-        final StringBuffer sb = new StringBuffer();
+        final StringBuilder sb = new StringBuilder();
         sb.append(getClass().getSimpleName());
         sb.append(" [keys=").append(keys);
         sb.append(", keywords=").append(keywords);

File: src/main/java/com/lambdaworks/codec/CRC16.java
Patch:
@@ -45,7 +45,7 @@ private CRC16() {
     /**
      * Create a CRC16 checksum from the bytes.
      * 
-     * @param bytes
+     * @param bytes input bytes
      * @return CRC16 as interger value
      */
     public static int crc16(byte[] bytes) {

File: src/main/java/com/lambdaworks/redis/KeyValue.java
Patch:
@@ -10,13 +10,14 @@
  * @author Will Glozer
  */
 public class KeyValue<K, V> {
+
     public final K key;
     public final V value;
 
     /**
      * 
-     * @param key
-     * @param value
+     * @param key the key
+     * @param value the value
      */
     public KeyValue(K key, V value) {
         this.key = key;

File: src/main/java/com/lambdaworks/redis/KillArgs.java
Patch:
@@ -8,7 +8,7 @@
 /**
  *
  * Argument list builder for the redis <a href="http://redis.io/commands/client-kill">CLIENT KILL</a> command. Static import the
- * methods from {@link Builder} and chain the method calls: <code>id(1).skipme()</code>.
+ * methods from {@link Builder} and chain the method calls: {@code id(1).skipme()}.
  *
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>
  * @since 3.0

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnectionImpl.java
Patch:
@@ -43,7 +43,7 @@ public class RedisAsyncConnectionImpl<K, V> extends RedisChannelHandler<K, V> im
     /**
      * Initialize a new connection.
      * 
-     * @param writer
+     * @param writer the channel writer
      * @param codec Codec used to encode/decode keys and values.
      * @param timeout Maximum time to wait for a response.
      * @param unit Unit of time for the timeout.

File: src/main/java/com/lambdaworks/redis/RedisHLLAsyncConnection.java
Patch:
@@ -29,7 +29,7 @@ public interface RedisHLLAsyncConnection<K, V> {
      * @param sourcekey the source key
      * @param moreSourceKeys more source keys
      * 
-     * @return RedisFuture&lt;Long&gt; simple-string-reply The command just returns <code>OK</code>.
+     * @return RedisFuture&lt;Long&gt; simple-string-reply The command just returns {@code OK}.
      */
     RedisFuture<Long> pfmerge(K destkey, K sourcekey, K... moreSourceKeys);
 
@@ -41,7 +41,7 @@ public interface RedisHLLAsyncConnection<K, V> {
      * 
      * @return RedisFuture&lt;Long&gt; integer-reply specifically:
      * 
-     *         The approximated number of unique elements observed via <code>PFADD</code>.
+     *         The approximated number of unique elements observed via {@code PFADD}.
      */
     RedisFuture<Long> pfcount(K key, K... moreKeys);
 

File: src/main/java/com/lambdaworks/redis/RedisHLLConnection.java
Patch:
@@ -29,7 +29,7 @@ public interface RedisHLLConnection<K, V> {
      * @param sourcekey the source key
      * @param moreSourceKeys more source keys
      * 
-     * @return Long simple-string-reply The command just returns <code>OK</code>.
+     * @return Long simple-string-reply The command just returns {@code OK}.
      */
     Long pfmerge(K destkey, K sourcekey, K... moreSourceKeys);
 
@@ -41,7 +41,7 @@ public interface RedisHLLConnection<K, V> {
      * 
      * @return Long integer-reply specifically:
      * 
-     *         The approximated number of unique elements observed via <code>PFADD</code>.
+     *         The approximated number of unique elements observed via {@code PFADD}.
      */
     Long pfcount(K key, K... moreKeys);
 

File: src/main/java/com/lambdaworks/redis/SortArgs.java
Patch:
@@ -18,7 +18,7 @@
 
 /**
  * Argument list builder for the redis <a href="http://redis.io/commands/sort">SORT</a> command. Static import the methods from
- * {@link Builder} and chain the method calls: <code>by("weight_*").desc().limit(0, 2)</code>.
+ * {@link Builder} and chain the method calls: {@code by("weight_*").desc().limit(0, 2)}.
  * 
  * @author Will Glozer
  */

File: src/main/java/com/lambdaworks/redis/ZStoreArgs.java
Patch:
@@ -16,7 +16,7 @@
 /**
  * Argument list builder for the redis <a href="http://redis.io/commands/zunionstore">ZUNIONSTORE</a> and <a
  * href="http://redis.io/commands/zinterstore">ZINTERSTORE</a> commands. Static import the methods from {@link Builder} and
- * chain the method calls: <code>weights(1, 2).max()</code>.
+ * chain the method calls: {@code weights(1, 2).max()}.
  * 
  * @author Will Glozer
  */

File: src/main/java/com/lambdaworks/redis/cluster/SlotHash.java
Patch:
@@ -28,7 +28,7 @@ private SlotHash() {
     /**
      * Calculate the slot from the given key.
      * 
-     * @param key
+     * @param key the key
      * @return slot
      */
     public static final int getSlot(String key) {
@@ -38,7 +38,7 @@ public static final int getSlot(String key) {
     /**
      * Calculate the slot from the given key.
      * 
-     * @param key
+     * @param key the key
      * @return slot
      */
     public static final int getSlot(byte[] key) {

File: src/main/java/com/lambdaworks/redis/cluster/models/partitions/ClusterPartitionParser.java
Patch:
@@ -47,7 +47,7 @@ private ClusterPartitionParser() {
     /**
      * Parse partition lines into Partitions object.
      * 
-     * @param nodes
+     * @param nodes output of CLUSTER NODES
      * @return the partitions object.
      */
     public static Partitions parse(String nodes) {

File: src/main/java/com/lambdaworks/redis/cluster/models/partitions/Partitions.java
Patch:
@@ -15,7 +15,7 @@ public class Partitions implements Iterable<RedisClusterNode> {
     /**
      * Retrieve a {@link RedisClusterNode} by it's slot number. This method does not distinguish between masters and slaves.
      * 
-     * @param slot
+     * @param slot the slot
      * @return RedisClusterNode or {@literal null}
      */
     public RedisClusterNode getPartitionBySlot(int slot) {

File: src/main/java/com/lambdaworks/redis/cluster/models/slots/ClusterSlotsParser.java
Patch:
@@ -28,7 +28,7 @@ private ClusterSlotsParser() {
      * Parse the output of the redis CLUSTER SLOTS command and convert it to a list of
      * {@link com.lambdaworks.redis.cluster.models.slots.ClusterSlotRange}
      * 
-     * @param clusterSlotsOutput
+     * @param clusterSlotsOutput output of CLUSTER SLOTS command
      * @return List&gt;ClusterSlotRange&gt;
      */
     public static List<ClusterSlotRange> parse(List<?> clusterSlotsOutput) {

File: src/main/java/com/lambdaworks/redis/models/role/RoleParser.java
Patch:
@@ -43,7 +43,7 @@ private RoleParser() {
     /**
      * Parse the output of the redis ROLE command and convert to a RedisInstance.
      * 
-     * @param roleOutput
+     * @param roleOutput output of the redis ROLE command
      * @return RedisInstance
      */
     public static RedisInstance parse(List<?> roleOutput) {

File: src/main/java/com/lambdaworks/redis/output/KeyScanStreamingOutput.java
Patch:
@@ -6,8 +6,8 @@
 import com.lambdaworks.redis.codec.RedisCodec;
 
 /**
- * Streaming API for multiple Keys. You can implement this interface in order to receive a call to <code>onKey</code> on every
- * key. Key uniqueness is not guaranteed.
+ * Streaming API for multiple Keys. You can implement this interface in order to receive a call to {@code onKey} on every key.
+ * Key uniqueness is not guaranteed.
  * 
  * @param <K> Key type.
  * @param <V> Value type.

File: src/main/java/com/lambdaworks/redis/output/KeyStreamingChannel.java
Patch:
@@ -1,8 +1,8 @@
 package com.lambdaworks.redis.output;
 
 /**
- * Streaming API for multiple Keys. You can implement this interface in order to receive a call to <code>onKey</code> on every
- * key. Key uniqueness is not guaranteed.
+ * Streaming API for multiple Keys. You can implement this interface in order to receive a call to {@code onKey} on every key.
+ * Key uniqueness is not guaranteed.
  * 
  * @param <K> Key type.
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>
@@ -12,7 +12,7 @@ public interface KeyStreamingChannel<K> {
     /**
      * Called on every incoming key.
      * 
-     * @param key
+     * @param key the key
      */
     void onKey(K key);
 }

File: src/main/java/com/lambdaworks/redis/output/ScoredValueStreamingChannel.java
Patch:
@@ -3,7 +3,7 @@
 import com.lambdaworks.redis.ScoredValue;
 
 /**
- * Streaming API for multiple Keys. You can implement this interface in order to receive a call to <code>onValue</code> on every
+ * Streaming API for multiple Keys. You can implement this interface in order to receive a call to {@code onValue} on every
  * value.
  * 
  * @param <V> Value type.
@@ -14,7 +14,7 @@ public interface ScoredValueStreamingChannel<V> {
     /**
      * Called on every incoming ScoredValue.
      * 
-     * @param value
+     * @param value the scored value
      */
     void onValue(ScoredValue<V> value);
 }

File: src/main/java/com/lambdaworks/redis/output/ValueScanStreamingOutput.java
Patch:
@@ -6,8 +6,8 @@
 import com.lambdaworks.redis.codec.RedisCodec;
 
 /**
- * Streaming API for multiple Values. You can implement this interface in order to receive a call to <code>onValue</code> on
- * every key.
+ * Streaming API for multiple Values. You can implement this interface in order to receive a call to {@code onValue} on every
+ * key.
  * 
  * @param <K> Key type.
  * @param <V> Value type.

File: src/main/java/com/lambdaworks/redis/output/ValueStreamingChannel.java
Patch:
@@ -1,7 +1,7 @@
 package com.lambdaworks.redis.output;
 
 /**
- * Streaming API for multiple Keys. You can implement this interface in order to receive a call to <code>onValue</code> on every
+ * Streaming API for multiple Keys. You can implement this interface in order to receive a call to {@code onValue} on every
  * value.
  * 
  * @param <V> Value type.
@@ -12,7 +12,7 @@ public interface ValueStreamingChannel<V> {
     /**
      * Called on every incoming value.
      * 
-     * @param value
+     * @param value the value
      */
     void onValue(V value);
 }

File: src/main/java/com/lambdaworks/redis/protocol/ConnectionWatchdog.java
Patch:
@@ -63,7 +63,7 @@ public ConnectionWatchdog(Bootstrap bootstrap, Timer timer) {
      * 
      * @param bootstrap Configuration for new channels.
      * @param timer Timer used for delayed reconnect.
-     * @param socketAddressSupplier
+     * @param socketAddressSupplier the socket address suplier for gaining an address to reconnect to
      */
     public ConnectionWatchdog(Bootstrap bootstrap, Timer timer, Supplier<SocketAddress> socketAddressSupplier) {
         this.bootstrap = bootstrap;

File: src/main/java/com/lambdaworks/redis/protocol/LettuceCharsets.java
Patch:
@@ -32,7 +32,7 @@ private LettuceCharsets() {
     /**
      * Create a ByteBuffer from a string using ASCII encoding.
      * 
-     * @param s
+     * @param s the string
      * @return ByteBuffer
      */
     public static ByteBuffer buffer(String s) {

File: src/main/java/com/lambdaworks/redis/protocol/RedisCommand.java
Patch:
@@ -16,7 +16,7 @@ public interface RedisCommand<K, V, T> extends ListenableFuture<T>, RedisFuture<
     /**
      * The command output. Can be null.
      * 
-     * @return CommandOutput<K, V, T>
+     * @return the command output.
      */
     CommandOutput<K, V, T> getOutput();
 
@@ -27,14 +27,14 @@ public interface RedisCommand<K, V, T> extends ListenableFuture<T>, RedisFuture<
 
     /**
      * 
-     * @return CommandArgs<K, V>
+     * @return the current command args
      */
     CommandArgs<K, V> getArgs();
 
     /**
      * Encode the command.
      * 
-     * @param buf
+     * @param buf byte buffer to operate on.
      */
     void encode(ByteBuf buf);
 

File: src/main/java/com/lambdaworks/redis/protocol/SetArgs.java
Patch:
@@ -5,7 +5,7 @@
 
 /**
  * Argument list builder for the new redis <a href="http://redis.io/commands/set">SET</a> command starting from Redis 2.6.12.
- * Static import the methods from {@link Builder} and chain the method calls: <code>ex(10).nx()</code>.
+ * Static import the methods from {@link Builder} and chain the method calls: {@code ex(10).nx()}.
  * 
  * @author Vincent Rischmann
  */

File: src/main/java/com/lambdaworks/redis/pubsub/RedisPubSubConnectionImpl.java
Patch:
@@ -44,7 +44,7 @@ public class RedisPubSubConnectionImpl<K, V> extends RedisAsyncConnectionImpl<K,
     /**
      * Initialize a new connection.
      * 
-     * @param writer
+     * @param writer the channel writer
      * @param codec Codec used to encode/decode keys and values.
      * @param timeout Maximum time to wait for a responses.
      * @param unit Unit of time for the timeout.

File: src/main/java/com/lambdaworks/redis/support/RedisClusterClientFactoryBean.java
Patch:
@@ -8,9 +8,10 @@
 import com.lambdaworks.redis.cluster.RedisClusterClient;
 
 /**
- * Factory Bean for RedisClient instances. Needs either a URI or a RedisURI as input. URI Format: <code>
+ * Factory Bean for RedisClient instances. Needs either a URI or a RedisURI as input. URI Format:
+ * {@code
  *     redis://host[:port][/databaseNumber]
- * </code>
+ * }
  * 
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>
  * @since 3.0

File: src/main/java/com/lambdaworks/redis/support/WithConnection.java
Patch:
@@ -29,7 +29,7 @@ public WithConnection(RedisConnectionPool<T> pool) {
     /**
      * Execution method. Will be called with a valid redis connection.
      * 
-     * @param connection
+     * @param connection the connection
      */
     protected abstract void run(T connection);
 }

File: src/main/java/com/lambdaworks/redis/codec/Utf8StringCodec.java
Patch:
@@ -50,8 +50,7 @@ public byte[] encodeValue(String value) {
         return encode(value);
     }
 
-    private String decode(ByteBuffer bytes) {
-        synchronized (chars) {
+    private synchronized String decode(ByteBuffer bytes) {
             chars.clear();
             bytes.mark();
 
@@ -62,7 +61,6 @@ private String decode(ByteBuffer bytes) {
             }
 
             return chars.flip().toString();
-        }
     }
 
     private byte[] encode(String string) {

File: src/main/java/com/lambdaworks/redis/codec/Utf8StringCodec.java
Patch:
@@ -50,8 +50,7 @@ public byte[] encodeValue(String value) {
         return encode(value);
     }
 
-    private String decode(ByteBuffer bytes) {
-        synchronized (chars) {
+    private synchronized String decode(ByteBuffer bytes) {
             chars.clear();
             bytes.mark();
 
@@ -62,7 +61,6 @@ private String decode(ByteBuffer bytes) {
             }
 
             return chars.flip().toString();
-        }
     }
 
     private byte[] encode(String string) {

File: src/main/java/com/lambdaworks/redis/protocol/Command.java
Patch:
@@ -74,7 +74,6 @@ protected void interruptTask() {
 
         if (latch.getCount() == 1) {
             latch.countDown();
-            output = null;
         }
     }
 

File: src/main/java/com/lambdaworks/redis/PooledConnectionInvocationHandler.java
Patch:
@@ -39,7 +39,6 @@ protected Object handleInvocation(Object proxy, Method method, Object[] args) th
 
         if (method.getName().equals("close")) {
             pool.freeConnection((T) proxy);
-            connection = null;
             return null;
         }
 

File: src/main/java/com/lambdaworks/redis/PooledConnectionInvocationHandler.java
Patch:
@@ -39,7 +39,6 @@ protected Object handleInvocation(Object proxy, Method method, Object[] args) th
 
         if (method.getName().equals("close")) {
             pool.freeConnection((T) proxy);
-            connection = null;
             return null;
         }
 

File: src/test/java/com/lambdaworks/redis/PubSubCommandTest.java
Patch:
@@ -53,7 +53,7 @@ public void auth() throws Exception {
         new WithPasswordRequired() {
             @Override
             protected void run(RedisClient client) throws Exception {
-                RedisPubSubConnectionImpl<String, String> connection = client.connectPubSub();
+                RedisPubSubConnection<String, String> connection = client.connectPubSub();
                 connection.addListener(PubSubCommandTest.this);
                 connection.auth(passwd);
 

File: src/main/java/com/lambdaworks/redis/RedisClient.java
Patch:
@@ -47,6 +47,7 @@ public class RedisClient extends AbstractRedisClient {
      */
     public RedisClient() {
         redisURI = null;
+        setDefaultTimeout(60, TimeUnit.MINUTES);
     }
 
     /**
@@ -55,7 +56,7 @@ public RedisClient() {
      * @param host Server hostname.
      */
     public RedisClient(String host) {
-        this(host, 6379);
+        this(host, RedisURI.DEFAULT_REDIS_PORT);
     }
 
     /**

File: src/test/java/com/lambdaworks/SslTest.java
Patch:
@@ -62,7 +62,7 @@ public void regularSslWithReconnect() throws Exception {
 
     @Test(expected = RedisConnectionException.class)
     public void sslWithVerificationWillFail() throws Exception {
-        RedisURI redisUri = RedisURI.Builder.redis(host(), sslPort()).withSsl(true).withVerifyPeer(true).build();
+        RedisURI redisUri = RedisURI.create("rediss://" + host() + ":" + sslPort());
 
         RedisConnection<String, String> connection = redisClient.connect(redisUri);
         connection.set("key", "value");

File: src/main/java/com/lambdaworks/redis/pubsub/RedisPubSubConnectionImpl.java
Patch:
@@ -97,12 +97,10 @@ public void activated() {
 
         if (!channels.isEmpty()) {
             subscribe(toArray(channels));
-            channels.clear();
         }
 
         if (!patterns.isEmpty()) {
             psubscribe(toArray(patterns));
-            patterns.clear();
         }
     }
 

File: src/main/java/com/lambdaworks/redis/pubsub/RedisPubSubConnectionImpl.java
Patch:
@@ -97,12 +97,10 @@ public void activated() {
 
         if (!channels.isEmpty()) {
             subscribe(toArray(channels));
-            channels.clear();
         }
 
         if (!patterns.isEmpty()) {
             psubscribe(toArray(patterns));
-            patterns.clear();
         }
     }
 

File: src/main/java/com/lambdaworks/redis/pubsub/PubSubCommandHandler.java
Patch:
@@ -46,6 +46,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Interrup
                 return;
             }
             queue.take().complete();
+            buffer.discardReadBytes();
             if (output instanceof PubSubOutput) {
                 ctx.fireChannelRead(output);
             }

File: src/main/java/com/lambdaworks/redis/pubsub/PubSubCommandHandler.java
Patch:
@@ -54,6 +54,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Interrup
         while (rsm.decode(buffer, output)) {
             ctx.fireChannelRead(output);
             output = new PubSubOutput<K, V>(codec);
+            buffer.discardReadBytes();
         }
     }
 

File: src/main/java/com/lambdaworks/redis/pubsub/PubSubCommandHandler.java
Patch:
@@ -55,6 +55,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Interrup
             ctx.fireChannelRead(output);
             output = new PubSubOutput<K, V>(codec);
         }
+        
+        buffer.discardReadBytes();
     }
 
 }

File: src/main/java/com/lambdaworks/redis/RedisClusterConnection.java
Patch:
@@ -52,7 +52,7 @@ public interface RedisClusterConnection<K, V> extends RedisHashesConnection<K, V
 
     String clusterFlushslots();
 
-    Map<K, V> clusterSlaves();
+    List<String> clusterSlaves(String nodeId);
 
     void close();
 

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnectionImpl.java
Patch:
@@ -1258,7 +1258,7 @@ public RedisFuture<KeyScanCursor<K>> scan(ScanArgs scanArgs) {
 
     @Override
     public RedisFuture<KeyScanCursor<K>> scan(ScanCursor scanCursor, ScanArgs scanArgs) {
-        return dispatch(commandBuilder.scan(scanArgs));
+        return dispatch(commandBuilder.scan(scanCursor, scanArgs));
     }
 
     @Override

File: src/main/java/com/lambdaworks/redis/BaseRedisAsyncConnection.java
Patch:
@@ -43,11 +43,11 @@ public interface BaseRedisAsyncConnection<K, V> extends Closeable {
 
     /**
      * Returns the number of subscribers (not counting clients subscribed to patterns) for the specified channels.
-     * 
+     *
      * @param channels
      * @return array-reply a list of channels and number of subscribers for every channel.
      */
-    RedisFuture<Map<K, String>> pubsubNumsub(K... channels);
+    RedisFuture<Map<K, Long>> pubsubNumsub(K... channels);
 
     /**
      * Returns the number of subscriptions to patterns.

File: src/main/java/com/lambdaworks/redis/BaseRedisConnection.java
Patch:
@@ -1,6 +1,7 @@
 package com.lambdaworks.redis;
 
 import java.io.Closeable;
+import java.io.Serializable;
 import java.util.List;
 import java.util.Map;
 
@@ -41,11 +42,11 @@ public interface BaseRedisConnection<K, V> extends Closeable {
 
     /**
      * Returns the number of subscribers (not counting clients subscribed to patterns) for the specified channels.
-     * 
+     *
      * @param channels
      * @return array-reply a list of channels and number of subscribers for every channel.
      */
-    Map<K, String> pubsubNumsub(K... channels);
+    Map<K, Long> pubsubNumsub(K... channels);
 
     /**
      * Returns the number of subscriptions to patterns.

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnectionImpl.java
Patch:
@@ -627,7 +627,7 @@ public RedisFuture<List<K>> pubsubChannels(K channel) {
     }
 
     @Override
-    public RedisFuture<Map<K, String>> pubsubNumsub(K... channels) {
+    public RedisFuture<Map<K, Long>> pubsubNumsub(K... channels) {
         return dispatch(commandBuilder.pubsubNumsub(channels));
     }
 

File: src/main/java/com/lambdaworks/redis/RedisCommandBuilder.java
Patch:
@@ -3,6 +3,7 @@
 import static com.lambdaworks.redis.protocol.CommandKeyword.*;
 import static com.lambdaworks.redis.protocol.CommandType.*;
 
+import java.io.Serializable;
 import java.util.Date;
 import java.util.List;
 import java.util.Map;
@@ -545,7 +546,7 @@ public Command<K, V, List<K>> pubsubChannels(K pattern) {
     }
 
     @SuppressWarnings({ "unchecked", "rawtypes" })
-    public Command<K, V, Map<K, String>> pubsubNumsub(K... pattern) {
+    public Command<K, V, Map<K, Long>> pubsubNumsub(K... pattern) {
         CommandArgs<K, V> args = new CommandArgs<K, V>(codec).add(NUMSUB).addKeys(pattern);
         return createCommand(PUBSUB, (MapOutput) new MapOutput<K, Long>((RedisCodec) codec), args);
     }

File: src/test/java/com/lambdaworks/redis/PubSubCommandTest.java
Patch:
@@ -118,9 +118,9 @@ public void pubsubNumsub() throws Exception {
         pubsub.subscribe(channel);
         Thread.sleep(100);
 
-        Map<String, String> result = redis.pubsubNumsub(channel);
+        Map<String, Long> result = redis.pubsubNumsub(channel);
         assertThat(result).hasSize(1);
-        assertThat(result.get(channel)).isEqualTo("1");
+        assertThat(result.get(channel)).isEqualTo(1L);
     }
 
     @Test

File: src/test/java/com/lambdaworks/redis/ScriptingCommandTest.java
Patch:
@@ -9,10 +9,13 @@
 import static com.lambdaworks.redis.ScriptOutputType.VALUE;
 import static org.assertj.core.api.Assertions.assertThat;
 
+import org.junit.FixMethodOrder;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
+import org.junit.runners.MethodSorters;
 
+@FixMethodOrder(MethodSorters.NAME_ASCENDING)
 public class ScriptingCommandTest extends AbstractCommandTest {
     @Rule
     public ExpectedException exception = ExpectedException.none();

File: lettuce/src/test/java/com/lambdaworks/redis/ConnectionCommandTest.java
Patch:
@@ -93,9 +93,6 @@ public void isValidAsyncExceptions() throws Exception {
         RedisFuture<String> future = mock(RedisFuture.class);
         when(connection.ping()).thenReturn(future);
 
-        when(future.get()).thenThrow(new InterruptedException());
-        assertThat(Connections.isValid(connection)).isFalse();
-
         when(future.get()).thenThrow(new ExecutionException(new RuntimeException()));
         assertThat(Connections.isValid(connection)).isFalse();
 

File: lettuce/src/main/java/com/lambdaworks/redis/FutureSyncInvocationHandler.java
Patch:
@@ -5,7 +5,6 @@
 import java.util.concurrent.TimeUnit;
 
 import com.google.common.reflect.AbstractInvocationHandler;
-import com.lambdaworks.redis.protocol.Command;
 import com.lambdaworks.redis.protocol.RedisCommand;
 
 /**
@@ -50,7 +49,7 @@ protected Object handleInvocation(Object proxy, Method method, Object[] args) th
             Object result = targetMethod.invoke(connection, args);
 
             if (result instanceof RedisCommand) {
-                Command<?, ?, ?> command = (Command<?, ?, ?>) result;
+                RedisCommand<?, ?, ?> command = (RedisCommand<?, ?, ?>) result;
                 if (!method.getName().equals("exec") && !method.getName().equals("multi")) {
                     if (connection.isMulti()) {
                         return null;

File: lettuce/src/main/java/com/lambdaworks/redis/cluster/ClusterDistributionChannelWriter.java
Patch:
@@ -79,7 +79,7 @@ public <T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {
         }
 
         commandToSend.getOutput().setError((String) null);
-        if (channelWriter != this && channelWriter != defaultWriter) {
+        if (channelWriter != null && channelWriter != this && channelWriter != defaultWriter) {
             return channelWriter.write(commandToSend);
         }
 

File: lettuce/src/main/java/com/lambdaworks/redis/Connections.java
Patch:
@@ -87,11 +87,13 @@ public static void close(Object connection) {
             if (connection instanceof RedisAsyncConnection<?, ?>) {
                 RedisAsyncConnection<?, ?> redisAsyncConnection = (RedisAsyncConnection<?, ?>) connection;
                 redisAsyncConnection.close();
+                return;
             }
 
             if (connection instanceof RedisConnection<?, ?>) {
                 RedisConnection<?, ?> redisConnection = (RedisConnection<?, ?>) connection;
                 redisConnection.close();
+                return;
             }
         } catch (RuntimeException e) {
             // silent;

File: lettuce/src/main/java/com/lambdaworks/redis/BaseRedisAsyncConnection.java
Patch:
@@ -45,7 +45,7 @@ public interface BaseRedisAsyncConnection<K, V> extends Closeable {
      * @param channels
      * @return array-reply a list of channels and number of subscribers for every channel.
      */
-    RedisFuture<Map<K, Long>> pubsubNumsub(K... channels);
+    RedisFuture<Map<K, String>> pubsubNumsub(K... channels);
 
     /**
      * Returns the number of subscriptions to patterns.

File: lettuce/src/main/java/com/lambdaworks/redis/BaseRedisConnection.java
Patch:
@@ -45,7 +45,7 @@ public interface BaseRedisConnection<K, V> extends Closeable {
      * @param channels
      * @return array-reply a list of channels and number of subscribers for every channel.
      */
-    Map<K, Long> pubsubNumsub(K... channels);
+    Map<K, String> pubsubNumsub(K... channels);
 
     /**
      * Returns the number of subscriptions to patterns.

File: lettuce/src/main/java/com/lambdaworks/redis/FutureSyncInvocationHandler.java
Patch:
@@ -5,10 +5,8 @@
 import java.util.concurrent.TimeUnit;
 
 import com.google.common.reflect.AbstractInvocationHandler;
-import com.lambdaworks.redis.RedisAsyncConnectionImpl;
 import com.lambdaworks.redis.protocol.Command;
 import com.lambdaworks.redis.protocol.RedisCommand;
-import com.lambdaworks.redis.support.LettuceFutures;
 
 /**
  * Invocation-handler to synchronize API calls which use Futures as backend. This class leverages the need to implement a full

File: lettuce/src/main/java/com/lambdaworks/redis/RedisAsyncConnectionImpl.java
Patch:
@@ -26,7 +26,6 @@
 import com.lambdaworks.redis.protocol.ConnectionWatchdog;
 import com.lambdaworks.redis.protocol.RedisCommand;
 import com.lambdaworks.redis.protocol.SetArgs;
-import com.lambdaworks.redis.support.LettuceFutures;
 import io.netty.channel.ChannelHandler;
 
 /**
@@ -603,7 +602,7 @@ public RedisFuture<List<K>> pubsubChannels(K channel) {
     }
 
     @Override
-    public RedisFuture<Map<K, Long>> pubsubNumsub(K... channels) {
+    public RedisFuture<Map<K, String>> pubsubNumsub(K... channels) {
         return dispatch(commandBuilder.pubsubNumsub(channels));
     }
 

File: lettuce/src/main/java/com/lambdaworks/redis/RedisCommandBuilder.java
Patch:
@@ -164,7 +164,7 @@ public Command<K, V, String> debugObject(K key) {
 
     public Command<K, V, Void> debugSegfault() {
         CommandArgs<K, V> args = new CommandArgs<K, V>(codec).add(SEGFAULT);
-        return createCommand(DEBUG, new VoidOutput<K, V>(codec), args);
+        return createCommand(DEBUG, null, args);
     }
 
     public Command<K, V, Long> decr(K key) {
@@ -516,7 +516,8 @@ public Command<K, V, List<K>> pubsubChannels(K pattern) {
         return createCommand(PUBSUB, new KeyListOutput<K, V>(codec), args);
     }
 
-    public Command<K, V, Map<K, Long>> pubsubNumsub(K... pattern) {
+    @SuppressWarnings("unchecked")
+    public Command<K, V, Map<K, String>> pubsubNumsub(K... pattern) {
         CommandArgs<K, V> args = new CommandArgs<K, V>(codec).add(NUMSUB).addKeys(pattern);
         return createCommand(PUBSUB, (MapOutput) new MapOutput<K, Long>((RedisCodec) codec), args);
     }

File: lettuce/src/main/java/com/lambdaworks/redis/RedisConnectionPool.java
Patch:
@@ -3,8 +3,6 @@
 import java.io.Closeable;
 import java.lang.reflect.Proxy;
 
-import com.lambdaworks.redis.support.Connections;
-import com.lambdaworks.redis.support.PooledConnectionInvocationHandler;
 import org.apache.commons.pool2.BasePooledObjectFactory;
 import org.apache.commons.pool2.PooledObject;
 import org.apache.commons.pool2.PooledObjectFactory;
@@ -134,7 +132,7 @@ public void close() {
         closeEvents = null;
     }
 
-    public Class<?> getComponentType() {
+    public Class<? extends T> getComponentType() {
         return redisConnectionProvider.getComponentType();
     }
 

File: lettuce/src/main/java/com/lambdaworks/redis/RedisConnectionProvider.java
Patch:
@@ -10,5 +10,5 @@
 interface RedisConnectionProvider<T> {
     T createConnection();
 
-    Class<?> getComponentType();
+    Class<? extends T> getComponentType();
 }

File: lettuce/src/main/java/com/lambdaworks/redis/RedisURI.java
Patch:
@@ -124,7 +124,7 @@ public SocketAddress getResolvedAddress() {
 
     @Override
     public String toString() {
-        final StringBuffer sb = new StringBuffer();
+        final StringBuilder sb = new StringBuilder();
         sb.append(getClass().getSimpleName());
         sb.append(" [host='").append(host).append('\'');
         sb.append(", port=").append(port);

File: lettuce/src/main/java/com/lambdaworks/redis/cluster/ClusterDistributionChannelWriter.java
Patch:
@@ -6,7 +6,7 @@
 
 import com.google.common.base.Splitter;
 import com.google.common.net.HostAndPort;
-import com.lambdaworks.redis.support.LettuceStrings;
+import com.lambdaworks.redis.LettuceStrings;
 import com.lambdaworks.redis.RedisAsyncConnectionImpl;
 import com.lambdaworks.redis.RedisChannelHandler;
 import com.lambdaworks.redis.RedisChannelWriter;

File: lettuce/src/main/java/com/lambdaworks/redis/cluster/Partitions.java
Patch:
@@ -37,7 +37,7 @@ public void addPartition(RedisClusterNode partition) {
 
     @Override
     public String toString() {
-        final StringBuffer sb = new StringBuffer();
+        final StringBuilder sb = new StringBuilder();
         sb.append(getClass().getSimpleName());
         sb.append(" ").append(partitions);
         return sb.toString();

File: lettuce/src/main/java/com/lambdaworks/redis/cluster/PooledClusterConnectionProvider.java
Patch:
@@ -10,7 +10,7 @@
 import org.apache.commons.pool2.impl.GenericKeyedObjectPool;
 import org.apache.commons.pool2.impl.GenericKeyedObjectPoolConfig;
 
-import com.lambdaworks.redis.support.LettuceStrings;
+import com.lambdaworks.redis.LettuceStrings;
 import com.lambdaworks.redis.RedisAsyncConnection;
 import com.lambdaworks.redis.RedisAsyncConnectionImpl;
 import com.lambdaworks.redis.RedisException;

File: lettuce/src/main/java/com/lambdaworks/redis/cluster/RedisClusterClient.java
Patch:
@@ -188,9 +188,9 @@ public void reloadPartitions() {
         if (partitions == null) {
             initializePartitions();
         } else {
-            Partitions partitions = getPartitions();
+            Partitions loadedPartitions = getPartitions();
             this.partitions.getPartitions().clear();
-            this.partitions.getPartitions().addAll(partitions.getPartitions());
+            this.partitions.getPartitions().addAll(loadedPartitions.getPartitions());
         }
     }
 

File: lettuce/src/main/java/com/lambdaworks/redis/cluster/RedisClusterNode.java
Patch:
@@ -127,7 +127,7 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        final StringBuffer sb = new StringBuffer();
+        final StringBuilder sb = new StringBuilder();
         sb.append(getClass().getSimpleName());
         sb.append(" [uri=").append(uri);
         sb.append(", nodeId='").append(nodeId).append('\'');

File: lettuce/src/main/java/com/lambdaworks/redis/output/NestedMultiOutput.java
Patch:
@@ -4,6 +4,7 @@
 
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.Deque;
 import java.util.LinkedList;
 import java.util.List;
 
@@ -19,7 +20,7 @@
  * @author Will Glozer
  */
 public class NestedMultiOutput<K, V> extends CommandOutput<K, V, List<Object>> {
-    private final LinkedList<List<Object>> stack;
+    private final Deque<List<Object>> stack;
     private int depth;
 
     public NestedMultiOutput(RedisCodec<K, V> codec) {

File: lettuce/src/main/java/com/lambdaworks/redis/output/ScanOutput.java
Patch:
@@ -2,7 +2,7 @@
 
 import java.nio.ByteBuffer;
 
-import com.lambdaworks.redis.support.LettuceStrings;
+import com.lambdaworks.redis.LettuceStrings;
 import com.lambdaworks.redis.ScanCursor;
 import com.lambdaworks.redis.codec.RedisCodec;
 import com.lambdaworks.redis.protocol.CommandOutput;

File: lettuce/src/main/java/com/lambdaworks/redis/protocol/CommandKeyword.java
Patch:
@@ -10,7 +10,7 @@
 public enum CommandKeyword {
     ADDSLOTS, AFTER, AGGREGATE, ALPHA, AND, ASC, BEFORE, BY, CHANNELS, COUNT, DELSLOTS, DESC, SOFT, HARD, ENCODING, FAILOVER, FORGET, FLUSH, FORCE, FLUSHSLOTS, GETNAME, GETKEYSINSLOT, IDLETIME, KILL, LEN, LIMIT, LIST, LOAD, MATCH, MAX, MEET, MIN, MOVED, NO, NODE, NODES, NOSAVE, NOT, NUMSUB, NUMPAT, ONE, OR, PAUSE, REFCOUNT, REPLICATE, RESET, REWRITE, RESETSTAT, SETNAME, SETSLOT, MIGRATING, IMPORTING, SLAVES, STORE, SUM, SEGFAULT, WEIGHTS, WITHSCORES, XOR, REMOVE;
 
-    public byte[] bytes;
+    public final byte[] bytes;
 
     private CommandKeyword() {
         bytes = name().getBytes(LettuceCharsets.ASCII);

File: lettuce/src/main/java/com/lambdaworks/redis/protocol/CommandOutput.java
Patch:
@@ -115,7 +115,7 @@ protected String decodeAscii(ByteBuffer bytes) {
 
     @Override
     public String toString() {
-        final StringBuffer sb = new StringBuffer();
+        final StringBuilder sb = new StringBuilder();
         sb.append(getClass().getSimpleName());
         sb.append(" [output=").append(output);
         sb.append(", error='").append(error).append('\'');

File: lettuce/src/main/java/com/lambdaworks/redis/protocol/CommandType.java
Patch:
@@ -73,7 +73,7 @@ public enum CommandType {
     // CLUSTER
     ASKING, CLUSTER;
 
-    public byte[] bytes;
+    public final byte[] bytes;
 
     private CommandType() {
         bytes = name().getBytes(LettuceCharsets.ASCII);

File: lettuce/src/main/java/com/lambdaworks/redis/pubsub/PubSubOutput.java
Patch:
@@ -73,6 +73,8 @@ public void set(ByteBuffer bytes) {
             case unsubscribe:
                 channel = codec.decodeKey(bytes);
                 break;
+            default:
+                throw new UnsupportedOperationException("Operation " + type + " not supported");
         }
     }
 

File: lettuce/src/main/java/com/lambdaworks/redis/support/RedisClientFactoryBean.java
Patch:
@@ -4,6 +4,7 @@
 
 import java.net.URI;
 
+import com.lambdaworks.redis.LettuceStrings;
 import org.springframework.beans.factory.config.AbstractFactoryBean;
 
 import com.google.common.net.HostAndPort;
@@ -46,7 +47,7 @@ public void afterPropertiesSet() throws Exception {
                 }
 
                 if (builder == null && LettuceStrings.isNotEmpty(uri.getAuthority())) {
-                    String hosts[] = uri.getAuthority().split("\\,");
+                    String[] hosts = uri.getAuthority().split("\\,");
                     for (String host : hosts) {
                         HostAndPort hostAndPort = HostAndPort.fromString(host);
                         if (builder == null) {

File: lettuce/src/test/java/com/lambdaworks/redis/BitCommandTest.java
Patch:
@@ -17,7 +17,7 @@ public class BitCommandTest extends AbstractCommandTest {
 
     @Before
     public final void openBitStringConnection() throws Exception {
-        bitstring = (RedisConnection) client.connect(new BitStringCodec());
+        bitstring = client.connect(new BitStringCodec());
     }
 
     @After

File: lettuce/src/test/java/com/lambdaworks/redis/CommandInternalsTest.java
Patch:
@@ -120,8 +120,5 @@ public void nestedMultiError() throws Exception {
     public void sillyTestsForEmmaCoverage() throws Exception {
         assertEquals(CommandType.APPEND, CommandType.valueOf("APPEND"));
         assertEquals(CommandKeyword.AFTER, CommandKeyword.valueOf("AFTER"));
-        assertNotNull(new ZStoreArgs.Builder());
-        assertNotNull(new SortArgs.Builder());
-        assertNotNull(new LettuceCharsets());
     }
 }

File: lettuce/src/test/java/com/lambdaworks/redis/ConnectionCommandTest.java
Patch:
@@ -81,7 +81,7 @@ public void getSetReconnect() throws Exception {
 
     @Test
     public void authInvalidPassword() throws Exception {
-        RedisAsyncConnection async = client.connectAsync();
+        RedisAsyncConnection<String, String> async = client.connectAsync();
         try {
             async.auth("invalid");
             fail("Authenticated with invalid password");

File: lettuce/src/test/java/com/lambdaworks/redis/CustomCodecTest.java
Patch:
@@ -20,7 +20,7 @@
 public class CustomCodecTest extends AbstractCommandTest {
     @Test
     public void test() throws Exception {
-        RedisConnection<String, Object> connection = (RedisConnection) client.connect(new SerializedObjectCodec());
+        RedisConnection<String, Object> connection = client.connect(new SerializedObjectCodec());
         List<String> list = list("one", "two");
         connection.set(key, list);
         assertEquals(list, connection.get(key));

File: lettuce/src/test/java/com/lambdaworks/redis/PoolConnectionTest.java
Patch:
@@ -159,7 +159,7 @@ public void syncPoolPerformanceTest() throws Exception {
 
         long elapsed = stopwatch.stop().elapsed(TimeUnit.MILLISECONDS);
 
-        System.out.println("syncPoolPerformanceTest Duration: " + elapsed + "ms");
+        log.info("syncPoolPerformanceTest Duration: " + elapsed + "ms");
 
     }
 
@@ -178,7 +178,7 @@ public void asyncPoolPerformanceTest() throws Exception {
 
         long elapsed = stopwatch.stop().elapsed(TimeUnit.MILLISECONDS);
 
-        System.out.println("asyncPoolPerformanceTest Duration: " + elapsed + "ms");
+        log.info("asyncPoolPerformanceTest Duration: " + elapsed + "ms");
 
     }
 

File: lettuce/src/test/java/com/lambdaworks/redis/PubSubCommandTest.java
Patch:
@@ -119,7 +119,7 @@ public void pubsubNumsub() throws Exception {
         pubsub.subscribe(channel);
         Thread.sleep(100);
 
-        Map<String, Long> result = redis.pubsubNumsub(channel);
+        Map<String, String> result = redis.pubsubNumsub(channel);
         assertEquals(1, result.size());
         assertEquals("1", result.get(channel));
     }

File: lettuce/src/test/java/com/lambdaworks/redis/SentinelCommandTest.java
Patch:
@@ -104,8 +104,8 @@ public void reset() throws Exception {
     @Test
     public void failover() throws Exception {
 
-        RedisCommand result = (RedisCommand) sentinel.failover("mymaster");
-        result.get();
+        RedisFuture<String> mymaster = sentinel.failover("mymaster");
+        mymaster.get();
 
     }
 

File: lettuce/src/test/java/com/lambdaworks/redis/SetCommandTest.java
Patch:
@@ -140,7 +140,7 @@ public void sunionStreaming() throws Exception {
 
         assertEquals(5, count.longValue());
 
-        assertEquals(new TreeSet(list("c", "a", "b", "e", "d")), new TreeSet(adapter.getList()));
+        assertEquals(new TreeSet<String>(list("c", "a", "b", "e", "d")), new TreeSet<String>(adapter.getList()));
     }
 
     @Test
@@ -197,7 +197,7 @@ public void sscanMultiple() throws Exception {
             check.addAll(cursor.getValues());
         }
 
-        assertEquals(new TreeSet(expect), new TreeSet(check));
+        assertEquals(new TreeSet<String>(expect), new TreeSet<String>(check));
     }
 
     @Test

File: lettuce/src/main/java/com/lambdaworks/redis/FutureSyncInvocationHandler.java
Patch:
@@ -5,10 +5,8 @@
 import java.util.concurrent.TimeUnit;
 
 import com.google.common.reflect.AbstractInvocationHandler;
-import com.lambdaworks.redis.RedisAsyncConnectionImpl;
 import com.lambdaworks.redis.protocol.Command;
 import com.lambdaworks.redis.protocol.RedisCommand;
-import com.lambdaworks.redis.support.LettuceFutures;
 
 /**
  * Invocation-handler to synchronize API calls which use Futures as backend. This class leverages the need to implement a full

File: lettuce/src/main/java/com/lambdaworks/redis/RedisAsyncConnectionImpl.java
Patch:
@@ -26,7 +26,6 @@
 import com.lambdaworks.redis.protocol.ConnectionWatchdog;
 import com.lambdaworks.redis.protocol.RedisCommand;
 import com.lambdaworks.redis.protocol.SetArgs;
-import com.lambdaworks.redis.support.LettuceFutures;
 import io.netty.channel.ChannelHandler;
 
 /**

File: lettuce/src/main/java/com/lambdaworks/redis/RedisCommandBuilder.java
Patch:
@@ -164,7 +164,7 @@ public Command<K, V, String> debugObject(K key) {
 
     public Command<K, V, Void> debugSegfault() {
         CommandArgs<K, V> args = new CommandArgs<K, V>(codec).add(SEGFAULT);
-        return createCommand(DEBUG, new VoidOutput<K, V>(codec), args);
+        return createCommand(DEBUG, null, args);
     }
 
     public Command<K, V, Long> decr(K key) {

File: lettuce/src/main/java/com/lambdaworks/redis/RedisConnectionPool.java
Patch:
@@ -3,8 +3,6 @@
 import java.io.Closeable;
 import java.lang.reflect.Proxy;
 
-import com.lambdaworks.redis.support.Connections;
-import com.lambdaworks.redis.support.PooledConnectionInvocationHandler;
 import org.apache.commons.pool2.BasePooledObjectFactory;
 import org.apache.commons.pool2.PooledObject;
 import org.apache.commons.pool2.PooledObjectFactory;
@@ -134,7 +132,7 @@ public void close() {
         closeEvents = null;
     }
 
-    public Class<?> getComponentType() {
+    public Class<? extends T> getComponentType() {
         return redisConnectionProvider.getComponentType();
     }
 

File: lettuce/src/main/java/com/lambdaworks/redis/RedisConnectionProvider.java
Patch:
@@ -10,5 +10,5 @@
 interface RedisConnectionProvider<T> {
     T createConnection();
 
-    Class<?> getComponentType();
+    Class<? extends T> getComponentType();
 }

File: lettuce/src/main/java/com/lambdaworks/redis/RedisURI.java
Patch:
@@ -124,7 +124,7 @@ public SocketAddress getResolvedAddress() {
 
     @Override
     public String toString() {
-        final StringBuffer sb = new StringBuffer();
+        final StringBuilder sb = new StringBuilder();
         sb.append(getClass().getSimpleName());
         sb.append(" [host='").append(host).append('\'');
         sb.append(", port=").append(port);

File: lettuce/src/main/java/com/lambdaworks/redis/cluster/ClusterDistributionChannelWriter.java
Patch:
@@ -6,7 +6,7 @@
 
 import com.google.common.base.Splitter;
 import com.google.common.net.HostAndPort;
-import com.lambdaworks.redis.support.LettuceStrings;
+import com.lambdaworks.redis.LettuceStrings;
 import com.lambdaworks.redis.RedisAsyncConnectionImpl;
 import com.lambdaworks.redis.RedisChannelHandler;
 import com.lambdaworks.redis.RedisChannelWriter;

File: lettuce/src/main/java/com/lambdaworks/redis/cluster/Partitions.java
Patch:
@@ -37,7 +37,7 @@ public void addPartition(RedisClusterNode partition) {
 
     @Override
     public String toString() {
-        final StringBuffer sb = new StringBuffer();
+        final StringBuilder sb = new StringBuilder();
         sb.append(getClass().getSimpleName());
         sb.append(" ").append(partitions);
         return sb.toString();

File: lettuce/src/main/java/com/lambdaworks/redis/cluster/PooledClusterConnectionProvider.java
Patch:
@@ -10,7 +10,7 @@
 import org.apache.commons.pool2.impl.GenericKeyedObjectPool;
 import org.apache.commons.pool2.impl.GenericKeyedObjectPoolConfig;
 
-import com.lambdaworks.redis.support.LettuceStrings;
+import com.lambdaworks.redis.LettuceStrings;
 import com.lambdaworks.redis.RedisAsyncConnection;
 import com.lambdaworks.redis.RedisAsyncConnectionImpl;
 import com.lambdaworks.redis.RedisException;

File: lettuce/src/main/java/com/lambdaworks/redis/cluster/RedisClusterClient.java
Patch:
@@ -188,9 +188,9 @@ public void reloadPartitions() {
         if (partitions == null) {
             initializePartitions();
         } else {
-            Partitions partitions = getPartitions();
+            Partitions loadedPartitions = getPartitions();
             this.partitions.getPartitions().clear();
-            this.partitions.getPartitions().addAll(partitions.getPartitions());
+            this.partitions.getPartitions().addAll(loadedPartitions.getPartitions());
         }
     }
 

File: lettuce/src/main/java/com/lambdaworks/redis/cluster/RedisClusterNode.java
Patch:
@@ -127,7 +127,7 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        final StringBuffer sb = new StringBuffer();
+        final StringBuilder sb = new StringBuilder();
         sb.append(getClass().getSimpleName());
         sb.append(" [uri=").append(uri);
         sb.append(", nodeId='").append(nodeId).append('\'');

File: lettuce/src/main/java/com/lambdaworks/redis/output/NestedMultiOutput.java
Patch:
@@ -4,6 +4,7 @@
 
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.Deque;
 import java.util.LinkedList;
 import java.util.List;
 
@@ -19,7 +20,7 @@
  * @author Will Glozer
  */
 public class NestedMultiOutput<K, V> extends CommandOutput<K, V, List<Object>> {
-    private final LinkedList<List<Object>> stack;
+    private final Deque<List<Object>> stack;
     private int depth;
 
     public NestedMultiOutput(RedisCodec<K, V> codec) {

File: lettuce/src/main/java/com/lambdaworks/redis/output/ScanOutput.java
Patch:
@@ -2,7 +2,7 @@
 
 import java.nio.ByteBuffer;
 
-import com.lambdaworks.redis.support.LettuceStrings;
+import com.lambdaworks.redis.LettuceStrings;
 import com.lambdaworks.redis.ScanCursor;
 import com.lambdaworks.redis.codec.RedisCodec;
 import com.lambdaworks.redis.protocol.CommandOutput;

File: lettuce/src/main/java/com/lambdaworks/redis/protocol/CommandKeyword.java
Patch:
@@ -10,7 +10,7 @@
 public enum CommandKeyword {
     ADDSLOTS, AFTER, AGGREGATE, ALPHA, AND, ASC, BEFORE, BY, CHANNELS, COUNT, DELSLOTS, DESC, SOFT, HARD, ENCODING, FAILOVER, FORGET, FLUSH, FORCE, FLUSHSLOTS, GETNAME, GETKEYSINSLOT, IDLETIME, KILL, LEN, LIMIT, LIST, LOAD, MATCH, MAX, MEET, MIN, MOVED, NO, NODE, NODES, NOSAVE, NOT, NUMSUB, NUMPAT, ONE, OR, PAUSE, REFCOUNT, REPLICATE, RESET, REWRITE, RESETSTAT, SETNAME, SETSLOT, MIGRATING, IMPORTING, SLAVES, STORE, SUM, SEGFAULT, WEIGHTS, WITHSCORES, XOR, REMOVE;
 
-    public byte[] bytes;
+    public final byte[] bytes;
 
     private CommandKeyword() {
         bytes = name().getBytes(LettuceCharsets.ASCII);

File: lettuce/src/main/java/com/lambdaworks/redis/protocol/CommandOutput.java
Patch:
@@ -115,7 +115,7 @@ protected String decodeAscii(ByteBuffer bytes) {
 
     @Override
     public String toString() {
-        final StringBuffer sb = new StringBuffer();
+        final StringBuilder sb = new StringBuilder();
         sb.append(getClass().getSimpleName());
         sb.append(" [output=").append(output);
         sb.append(", error='").append(error).append('\'');

File: lettuce/src/main/java/com/lambdaworks/redis/protocol/CommandType.java
Patch:
@@ -73,7 +73,7 @@ public enum CommandType {
     // CLUSTER
     ASKING, CLUSTER;
 
-    public byte[] bytes;
+    public final byte[] bytes;
 
     private CommandType() {
         bytes = name().getBytes(LettuceCharsets.ASCII);

File: lettuce/src/main/java/com/lambdaworks/redis/pubsub/PubSubOutput.java
Patch:
@@ -73,6 +73,8 @@ public void set(ByteBuffer bytes) {
             case unsubscribe:
                 channel = codec.decodeKey(bytes);
                 break;
+            default:
+                throw new UnsupportedOperationException("Operation " + type + " not supported");
         }
     }
 

File: lettuce/src/main/java/com/lambdaworks/redis/support/RedisClientFactoryBean.java
Patch:
@@ -4,6 +4,7 @@
 
 import java.net.URI;
 
+import com.lambdaworks.redis.LettuceStrings;
 import org.springframework.beans.factory.config.AbstractFactoryBean;
 
 import com.google.common.net.HostAndPort;
@@ -46,7 +47,7 @@ public void afterPropertiesSet() throws Exception {
                 }
 
                 if (builder == null && LettuceStrings.isNotEmpty(uri.getAuthority())) {
-                    String hosts[] = uri.getAuthority().split("\\,");
+                    String[] hosts = uri.getAuthority().split("\\,");
                     for (String host : hosts) {
                         HostAndPort hostAndPort = HostAndPort.fromString(host);
                         if (builder == null) {

File: lettuce/src/test/java/com/lambdaworks/redis/AbstractCommandTest.java
Patch:
@@ -27,8 +27,6 @@ public abstract class AbstractCommandTest {
 
     @BeforeClass
     public static void setupClient() {
-        // LogManager.resetConfiguration();
-        // PropertyConfigurator.configure(AbstractCommandTest.class.getClassLoader().getResource("log4j.properties"));
         client = getRedisClient();
     }
 

File: lettuce/src/test/java/com/lambdaworks/redis/AsyncConnectionTest.java
Patch:
@@ -12,7 +12,6 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import com.lambdaworks.redis.support.LettuceFutures;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;

File: lettuce/src/test/java/com/lambdaworks/redis/CommandInternalsTest.java
Patch:
@@ -120,8 +120,5 @@ public void nestedMultiError() throws Exception {
     public void sillyTestsForEmmaCoverage() throws Exception {
         assertEquals(CommandType.APPEND, CommandType.valueOf("APPEND"));
         assertEquals(CommandKeyword.AFTER, CommandKeyword.valueOf("AFTER"));
-        assertNotNull(new ZStoreArgs.Builder());
-        assertNotNull(new SortArgs.Builder());
-        assertNotNull(new LettuceCharsets());
     }
 }

File: lettuce/src/main/java/com/lambdaworks/redis/BaseRedisAsyncConnection.java
Patch:
@@ -45,7 +45,7 @@ public interface BaseRedisAsyncConnection<K, V> extends Closeable {
      * @param channels
      * @return array-reply a list of channels and number of subscribers for every channel.
      */
-    RedisFuture<Map<K, Long>> pubsubNumsub(K... channels);
+    RedisFuture<Map<K, String>> pubsubNumsub(K... channels);
 
     /**
      * Returns the number of subscriptions to patterns.

File: lettuce/src/main/java/com/lambdaworks/redis/BaseRedisConnection.java
Patch:
@@ -45,7 +45,7 @@ public interface BaseRedisConnection<K, V> extends Closeable {
      * @param channels
      * @return array-reply a list of channels and number of subscribers for every channel.
      */
-    Map<K, Long> pubsubNumsub(K... channels);
+    Map<K, String> pubsubNumsub(K... channels);
 
     /**
      * Returns the number of subscriptions to patterns.

File: lettuce/src/main/java/com/lambdaworks/redis/RedisAsyncConnectionImpl.java
Patch:
@@ -603,7 +603,7 @@ public RedisFuture<List<K>> pubsubChannels(K channel) {
     }
 
     @Override
-    public RedisFuture<Map<K, Long>> pubsubNumsub(K... channels) {
+    public RedisFuture<Map<K, String>> pubsubNumsub(K... channels) {
         return dispatch(commandBuilder.pubsubNumsub(channels));
     }
 

File: lettuce/src/main/java/com/lambdaworks/redis/RedisCommandBuilder.java
Patch:
@@ -516,7 +516,8 @@ public Command<K, V, List<K>> pubsubChannels(K pattern) {
         return createCommand(PUBSUB, new KeyListOutput<K, V>(codec), args);
     }
 
-    public Command<K, V, Map<K, Long>> pubsubNumsub(K... pattern) {
+    @SuppressWarnings("unchecked")
+    public Command<K, V, Map<K, String>> pubsubNumsub(K... pattern) {
         CommandArgs<K, V> args = new CommandArgs<K, V>(codec).add(NUMSUB).addKeys(pattern);
         return createCommand(PUBSUB, (MapOutput) new MapOutput<K, Long>((RedisCodec) codec), args);
     }

File: lettuce/src/test/java/com/lambdaworks/redis/BitCommandTest.java
Patch:
@@ -17,7 +17,7 @@ public class BitCommandTest extends AbstractCommandTest {
 
     @Before
     public final void openBitStringConnection() throws Exception {
-        bitstring = (RedisConnection) client.connect(new BitStringCodec());
+        bitstring = client.connect(new BitStringCodec());
     }
 
     @After

File: lettuce/src/test/java/com/lambdaworks/redis/ConnectionCommandTest.java
Patch:
@@ -81,7 +81,7 @@ public void getSetReconnect() throws Exception {
 
     @Test
     public void authInvalidPassword() throws Exception {
-        RedisAsyncConnection async = client.connectAsync();
+        RedisAsyncConnection<String, String> async = client.connectAsync();
         try {
             async.auth("invalid");
             fail("Authenticated with invalid password");

File: lettuce/src/test/java/com/lambdaworks/redis/CustomCodecTest.java
Patch:
@@ -20,7 +20,7 @@
 public class CustomCodecTest extends AbstractCommandTest {
     @Test
     public void test() throws Exception {
-        RedisConnection<String, Object> connection = (RedisConnection) client.connect(new SerializedObjectCodec());
+        RedisConnection<String, Object> connection = client.connect(new SerializedObjectCodec());
         List<String> list = list("one", "two");
         connection.set(key, list);
         assertEquals(list, connection.get(key));

File: lettuce/src/test/java/com/lambdaworks/redis/PoolConnectionTest.java
Patch:
@@ -159,7 +159,7 @@ public void syncPoolPerformanceTest() throws Exception {
 
         long elapsed = stopwatch.stop().elapsed(TimeUnit.MILLISECONDS);
 
-        System.out.println("syncPoolPerformanceTest Duration: " + elapsed + "ms");
+        log.info("syncPoolPerformanceTest Duration: " + elapsed + "ms");
 
     }
 
@@ -178,7 +178,7 @@ public void asyncPoolPerformanceTest() throws Exception {
 
         long elapsed = stopwatch.stop().elapsed(TimeUnit.MILLISECONDS);
 
-        System.out.println("asyncPoolPerformanceTest Duration: " + elapsed + "ms");
+        log.info("asyncPoolPerformanceTest Duration: " + elapsed + "ms");
 
     }
 

File: lettuce/src/test/java/com/lambdaworks/redis/PubSubCommandTest.java
Patch:
@@ -119,7 +119,7 @@ public void pubsubNumsub() throws Exception {
         pubsub.subscribe(channel);
         Thread.sleep(100);
 
-        Map<String, Long> result = redis.pubsubNumsub(channel);
+        Map<String, String> result = redis.pubsubNumsub(channel);
         assertEquals(1, result.size());
         assertEquals("1", result.get(channel));
     }

File: lettuce/src/test/java/com/lambdaworks/redis/SentinelCommandTest.java
Patch:
@@ -104,8 +104,8 @@ public void reset() throws Exception {
     @Test
     public void failover() throws Exception {
 
-        RedisCommand result = (RedisCommand) sentinel.failover("mymaster");
-        result.get();
+        RedisFuture<String> mymaster = sentinel.failover("mymaster");
+        mymaster.get();
 
     }
 

File: lettuce/src/test/java/com/lambdaworks/redis/SetCommandTest.java
Patch:
@@ -140,7 +140,7 @@ public void sunionStreaming() throws Exception {
 
         assertEquals(5, count.longValue());
 
-        assertEquals(new TreeSet(list("c", "a", "b", "e", "d")), new TreeSet(adapter.getList()));
+        assertEquals(new TreeSet<String>(list("c", "a", "b", "e", "d")), new TreeSet<String>(adapter.getList()));
     }
 
     @Test
@@ -197,7 +197,7 @@ public void sscanMultiple() throws Exception {
             check.addAll(cursor.getValues());
         }
 
-        assertEquals(new TreeSet(expect), new TreeSet(check));
+        assertEquals(new TreeSet<String>(expect), new TreeSet<String>(check));
     }
 
     @Test

File: lettuce/src/test/java/com/lambdaworks/redis/AbstractCommandTest.java
Patch:
@@ -2,6 +2,7 @@
 
 package com.lambdaworks.redis;
 
+import org.apache.log4j.Logger;
 import org.junit.After;
 import org.junit.AfterClass;
 import org.junit.Before;
@@ -19,6 +20,7 @@ public abstract class AbstractCommandTest {
     public static final String passwd = "passwd";
 
     protected static RedisClient client;
+    protected Logger log = Logger.getLogger(getClass());
     protected RedisConnection<String, String> redis;
     protected String key = "key";
     protected String value = "value";

File: lettuce/src/test/java/com/lambdaworks/redis/ServerCommandTest.java
Patch:
@@ -48,11 +48,10 @@ public void clientPause() throws Exception {
 
     @Test
     public void clientKill() throws Exception {
-        Pattern p = Pattern.compile("addr=([^ ]+)");
+        Pattern p = Pattern.compile(".*addr=([^ ]+).*");
         String clients = redis.clientList();
         Matcher m = p.matcher(clients);
 
-        log.info("Client List: " + clients);
         assertTrue(m.lookingAt());
         assertEquals("OK", redis.clientKill(m.group(1)));
     }

File: lettuce/src/test/java/com/lambdaworks/redis/AbstractCommandTest.java
Patch:
@@ -2,6 +2,7 @@
 
 package com.lambdaworks.redis;
 
+import org.apache.log4j.Logger;
 import org.junit.After;
 import org.junit.AfterClass;
 import org.junit.Before;
@@ -19,6 +20,7 @@ public abstract class AbstractCommandTest {
     public static final String passwd = "passwd";
 
     protected static RedisClient client;
+    protected Logger log = Logger.getLogger(getClass());
     protected RedisConnection<String, String> redis;
     protected String key = "key";
     protected String value = "value";

File: lettuce/src/test/java/com/lambdaworks/redis/PubSubCommandTest.java
Patch:
@@ -13,6 +13,7 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 
+import com.lambdaworks.redis.pubsub.RedisPubSubConnection;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -22,7 +23,7 @@
 import com.lambdaworks.redis.pubsub.RedisPubSubListener;
 
 public class PubSubCommandTest extends AbstractCommandTest implements RedisPubSubListener<String, String> {
-    private RedisPubSubConnectionImpl<String, String> pubsub;
+    private RedisPubSubConnection<String, String> pubsub;
 
     private BlockingQueue<String> channels;
     private BlockingQueue<String> patterns;

File: lettuce/src/main/java/com/lambdaworks/redis/RedisServerAsyncConnection.java
Patch:
@@ -38,6 +38,8 @@ public interface RedisServerAsyncConnection<K, V> {
 
     RedisFuture<String> debugObject(K key);
 
+    void debugSegfault();
+
     RedisFuture<String> flushall();
 
     RedisFuture<String> flushdb();

File: lettuce/src/main/java/com/lambdaworks/redis/RedisServerConnection.java
Patch:
@@ -38,6 +38,8 @@ public interface RedisServerConnection<K, V> {
 
     String debugObject(K key);
 
+    void debugSegfault();
+
     String flushall();
 
     String flushdb();

File: lettuce/src/main/java/com/lambdaworks/redis/protocol/CommandKeyword.java
Patch:
@@ -8,7 +8,7 @@
  * @author Will Glozer
  */
 public enum CommandKeyword {
-    ADDSLOTS, AFTER, AGGREGATE, ALPHA, AND, ASC, BEFORE, BY, COUNT, DELSLOTS, DESC, SOFT, HARD, ENCODING, FAILOVER, FORGET, FLUSH, FORCE, FLUSHSLOTS, GETNAME, GETKEYSINSLOT, IDLETIME, KILL, LEN, LIMIT, LIST, LOAD, MATCH, MAX, MEET, MIN, MOVED, NO, NODE, NODES, NOSAVE, NOT, ONE, OR, PAUSE, REFCOUNT, REPLICATE, RESET, REWRITE, RESETSTAT, SETNAME, SETSLOT, MIGRATING, IMPORTING, SLAVES, STORE, SUM, WEIGHTS, WITHSCORES, XOR, REMOVE;
+    ADDSLOTS, AFTER, AGGREGATE, ALPHA, AND, ASC, BEFORE, BY, COUNT, DELSLOTS, DESC, SOFT, HARD, ENCODING, FAILOVER, FORGET, FLUSH, FORCE, FLUSHSLOTS, GETNAME, GETKEYSINSLOT, IDLETIME, KILL, LEN, LIMIT, LIST, LOAD, MATCH, MAX, MEET, MIN, MOVED, NO, NODE, NODES, NOSAVE, NOT, ONE, OR, PAUSE, REFCOUNT, REPLICATE, RESET, REWRITE, RESETSTAT, SETNAME, SETSLOT, MIGRATING, IMPORTING, SLAVES, STORE, SUM, SEGFAULT, WEIGHTS, WITHSCORES, XOR, REMOVE;
 
     public byte[] bytes;
 

File: src/main/java/com/lambdaworks/redis/protocol/CommandHandler.java
Patch:
@@ -92,7 +92,9 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Interrup
         while (!queue.isEmpty() && rsm.decode(buffer, queue.peek(), queue.peek().getOutput())) {
             RedisCommand<K, V, ?> cmd = queue.take();
             cmd.complete();
-            buffer.discardReadBytes();
+            if (buffer != null && buffer.refCnt() != 0) {
+                buffer.discardReadBytes();
+            }
         }
     }
 

File: src/main/java/com/lambdaworks/redis/RedisClient.java
Patch:
@@ -236,9 +236,8 @@ public RedisPubSubConnectionImpl<String, String> connectPubSub() {
      * @return A new connection.
      */
     @SuppressWarnings("unchecked")
-    public <K, V, T extends BaseRedisConnection<K, V>> T connect(RedisCodec<K, V> codec) {
-
-        return (T) connect(codec, true);
+    public <K, V> RedisConnection<K, V> connect(RedisCodec<K, V> codec) {
+        return connect(codec, true);
     }
 
     @SuppressWarnings({ "rawtypes", "unchecked" })

File: src/main/java/com/lambdaworks/redis/support/PoolingProxyFactory.java
Patch:
@@ -21,14 +21,14 @@ public class PoolingProxyFactory {
      * @return Transparent pooling proxy.
      */
     @SuppressWarnings("unchecked")
-    public static <T, C extends T> C create(RedisConnectionPool<T> connectionPool) {
+    public static <T> T create(RedisConnectionPool<T> connectionPool) {
         Class<?> componentType = connectionPool.getComponentType();
 
         TransparentPoolingInvocationHandler<T> h = new TransparentPoolingInvocationHandler<T>(connectionPool);
 
         Object o = Proxy.newProxyInstance(PoolingProxyFactory.class.getClassLoader(), new Class<?>[] { componentType }, h);
 
-        return (C) o;
+        return (T) o;
     }
 
 }

File: src/main/java/com/lambdaworks/redis/RedisClient.java
Patch:
@@ -78,6 +78,7 @@ public RedisClient(RedisURI redisURI) {
      * 
      * @return A new connection.
      */
+    @SuppressWarnings("unchecked")
     public RedisConnection<String, String> connect() {
         return (RedisConnection<String, String>) connect((RedisCodec) codec);
     }

File: src/main/java/com/lambdaworks/redis/RedisConnectionPool.java
Patch:
@@ -38,6 +38,7 @@ public RedisConnectionPool(RedisConnectionProvider<T> redisConnectionProvider, i
     private PooledObjectFactory<T> createFactory(final RedisConnectionProvider<T> redisConnectionProvider) {
         return new BasePooledObjectFactory<T>() {
             @Override
+            @SuppressWarnings("unckecked")
             public T create() throws Exception {
 
                 T connection = redisConnectionProvider.createConnection();

File: src/main/java/com/lambdaworks/redis/protocol/CommandHandler.java
Patch:
@@ -107,6 +107,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Interrup
      *      io.netty.channel.ChannelPromise)
      */
     @Override
+    @SuppressWarnings("unchecked")
     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
 
         final RedisCommand<K, V, ?> cmd = (RedisCommand<K, V, ?>) msg;

File: src/test/java/com/lambdaworks/redis/BitCommandTest.java
Patch:
@@ -17,7 +17,7 @@ public class BitCommandTest extends AbstractCommandTest {
 
     @Before
     public final void openBitStringConnection() throws Exception {
-        bitstring = client.connect(new BitStringCodec());
+        bitstring = (RedisConnection) client.connect(new BitStringCodec());
     }
 
     @After

File: src/test/java/com/lambdaworks/redis/SetCommandTest.java
Patch:
@@ -15,6 +15,7 @@
 
 import org.junit.Test;
 
+@SuppressWarnings("unchecked")
 public class SetCommandTest extends AbstractCommandTest {
     @Test
     public void sadd() throws Exception {

File: src/test/java/com/lambdaworks/redis/cluster/RedisClusterClientTest.java
Patch:
@@ -35,6 +35,7 @@
 import com.lambdaworks.redis.RedisURI;
 
 @FixMethodOrder(MethodSorters.NAME_ASCENDING)
+@SuppressWarnings("unchecked")
 public class RedisClusterClientTest {
 
     public static final String host = "127.0.0.1";

File: src/test/java/com/lambdaworks/redis/support/PoolingProxyFactoryTest.java
Patch:
@@ -10,13 +10,14 @@
 import com.lambdaworks.redis.RedisConnectionPool;
 import com.lambdaworks.redis.RedisException;
 
+@SuppressWarnings("unchecked")
 public class PoolingProxyFactoryTest extends AbstractCommandTest {
 
     @Test
     public void testCreateDefault() throws Exception {
 
         RedisConnectionPool<RedisConnection<String, String>> pool = client.pool();
-        RedisConnection<String, String> connection = PoolingProxyFactory.create(pool);
+        RedisConnection<String, String> connection = (RedisConnection) PoolingProxyFactory.create(pool);
 
         connection.set("a", "b");
         connection.set("x", "y");
@@ -38,7 +39,7 @@ public void testCloseReturnsConnection() throws Exception {
     @Test
     public void testCreate() throws Exception {
 
-        RedisConnection<String, String> connection = PoolingProxyFactory.create(client.pool());
+        RedisConnection<String, String> connection = (RedisConnection) PoolingProxyFactory.create(client.pool());
 
         connection.set("a", "b");
         connection.close();

File: src/main/java/com/lambdaworks/redis/RedisClient.java
Patch:
@@ -79,7 +79,7 @@ public RedisClient(RedisURI redisURI) {
      * @return A new connection.
      */
     public RedisConnection<String, String> connect() {
-        return (RedisConnection<String, String>) connect(codec);
+        return (RedisConnection<String, String>) connect((RedisCodec) codec);
     }
 
     /**

File: src/main/java/com/lambdaworks/redis/RedisConnectionPool.java
Patch:
@@ -61,6 +61,7 @@ public boolean validateObject(PooledObject<T> p) {
             }
 
             @Override
+            @SuppressWarnings("unchecked")
             public void destroyObject(PooledObject<T> p) throws Exception {
 
                 T object = p.getObject();

File: src/main/java/com/lambdaworks/redis/cluster/PooledClusterConnectionProvider.java
Patch:
@@ -48,6 +48,7 @@ public PooledClusterConnectionProvider(RedisClusterClient redisClusterClient, Pa
     }
 
     @Override
+    @SuppressWarnings("unchecked")
     public <K, V> RedisAsyncConnectionImpl<K, V> getConnection(Intent intent, int slot) {
         logger.debug("getConnection(" + intent + ", " + slot + ")");
         RedisClusterNode partition = partitions.getPartitionBySlot(slot);
@@ -66,7 +67,8 @@ public <K, V> RedisAsyncConnectionImpl<K, V> getConnection(Intent intent, int sl
     }
 
     @Override
-    public RedisAsyncConnectionImpl<K, V> getConnection(Intent intent, String host, int port) {
+    @SuppressWarnings("unchecked")
+    public <K, V> RedisAsyncConnectionImpl<K, V> getConnection(Intent intent, String host, int port) {
         try {
             logger.debug("getConnection(" + intent + ", " + host + ", " + port + ")");
             PoolKey key = new PoolKey(intent, host, port);

File: src/main/java/com/lambdaworks/redis/protocol/CommandHandler.java
Patch:
@@ -109,7 +109,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Interrup
     @Override
     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
 
-        final RedisCommand<?, ?, ?> cmd = (RedisCommand<?, ?, ?>) msg;
+        final RedisCommand<K, V, ?> cmd = (RedisCommand<K, V, ?>) msg;
         ByteBuf buf = ctx.alloc().heapBuffer();
         cmd.encode(buf);
         if (logger.isDebugEnabled()) {
@@ -118,7 +118,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
 
         synchronized (queue) {
             if (!queue.contains(cmd)) {
-                queue.put((RedisCommand) cmd);
+                queue.put(cmd);
             }
             ctx.write(buf, promise);
         }

File: src/main/java/com/lambdaworks/redis/support/PoolingProxyFactory.java
Patch:
@@ -20,6 +20,7 @@ public class PoolingProxyFactory {
      * @param <T> Type of the connection.
      * @return Transparent pooling proxy.
      */
+    @SuppressWarnings("unchecked")
     public static <T, C extends T> C create(RedisConnectionPool<T> connectionPool) {
         Class<?> componentType = connectionPool.getComponentType();
 

File: src/test/java/com/lambdaworks/redis/SentinelCommandTest.java
Patch:
@@ -51,7 +51,7 @@ public void getMasterAddr() throws Exception {
 
         InetSocketAddress socketAddress = (InetSocketAddress) result.get();
 
-        assertEquals("localhost", socketAddress.getHostName());
+        assertThat(socketAddress.getHostName(), containsString("localhost"));
     }
 
     @Test

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnectionImpl.java
Patch:
@@ -1515,4 +1515,5 @@ public void activated() {
             dispatch(commandBuilder.select(db));
         }
     }
+
 }

File: src/main/java/com/lambdaworks/redis/RedisClient.java
Patch:
@@ -319,7 +319,7 @@ public SocketAddress get() {
         };
     }
 
-    private SocketAddress getSocketAddress() throws InterruptedException, TimeoutException, ExecutionException {
+    protected SocketAddress getSocketAddress() throws InterruptedException, TimeoutException, ExecutionException {
         SocketAddress redisAddress;
 
         if (redisURI.getSentinelMasterId() != null && !redisURI.getSentinels().isEmpty()) {

File: src/main/java/com/lambdaworks/redis/protocol/Command.java
Patch:
@@ -242,4 +242,7 @@ public String toString() {
         return sb.toString();
     }
 
+    public void setOutput(CommandOutput<K, V, T> output) {
+        this.output = output;
+    }
 }

File: src/main/java/com/lambdaworks/redis/protocol/RedisStateMachine.java
Patch:
@@ -170,7 +170,8 @@ private int findLineEnd(ByteBuf buffer) {
     }
 
     private State.Type readReplyType(ByteBuf buffer) {
-        switch (buffer.readByte()) {
+        byte b = buffer.readByte();
+        switch (b) {
             case '+':
                 return SINGLE;
             case '-':
@@ -182,7 +183,7 @@ private State.Type readReplyType(ByteBuf buffer) {
             case '*':
                 return MULTI;
             default:
-                throw new RedisException("Invalid first byte");
+                throw new RedisException("Invalid first byte: " + Byte.toString(b));
         }
     }
 

File: src/test/java/com/lambdaworks/redis/SetCommandTest.java
Patch:
@@ -205,7 +205,7 @@ public void scanMatch() throws Exception {
         Set<String> expect = new HashSet<String>();
         setup100KeyValues(expect);
 
-        ValueScanCursor<String> cursor = redis.sscan(key, ScanArgs.Builder.count(100).match("value1*"));
+        ValueScanCursor<String> cursor = redis.sscan(key, ScanArgs.Builder.count(200).match("value1*"));
 
         assertEquals("0", cursor.getCursor());
         assertTrue(cursor.isFinished());

File: src/main/java/com/lambdaworks/redis/RedisChannelHandler.java
Patch:
@@ -79,7 +79,7 @@ public void channelRead(Object msg) {
 
     }
 
-    public synchronized <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> cmd) {
+    public <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> cmd) {
 
         return channelWriter.write(cmd);
     }

File: src/main/java/com/lambdaworks/redis/protocol/CommandHandler.java
Patch:
@@ -75,7 +75,7 @@ public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
         ByteBuf input = (ByteBuf) msg;
         try {
-            if (!input.isReadable()) {
+            if (!input.isReadable() || input.refCnt() == 0) {
                 return;
             }
 

File: src/test/java/com/lambdaworks/redis/SetCommandTest.java
Patch:
@@ -189,7 +189,6 @@ public void sscanMultiple() throws Exception {
         assertNotEquals("0", cursor.getCursor());
         assertFalse(cursor.isFinished());
 
-        assertEquals(5, cursor.getValues().size());
         check.addAll(cursor.getValues());
 
         while (!cursor.isFinished()) {

File: src/test/java/com/lambdaworks/redis/cluster/RedisClusterClientTest.java
Patch:
@@ -136,7 +136,7 @@ public void before() throws Exception {
             public boolean isSatisfied() {
                 try {
                     String info = redis1.clusterInfo().get();
-
+                    System.out.println(info);
                     if (info != null && info.contains("cluster_state:ok")) {
                         return true;
                     }
@@ -146,7 +146,7 @@ public boolean isSatisfied() {
 
                 return false;
             }
-        }, Timeout.timeout(Duration.seconds(2)), new ThreadSleep(Duration.millis(200)));
+        }, Timeout.timeout(Duration.seconds(5)), new ThreadSleep(Duration.millis(500)));
     }
 
     @After

File: src/main/java/com/lambdaworks/redis/AbstractRedisClient.java
Patch:
@@ -45,7 +45,7 @@ public abstract class AbstractRedisClient {
 
     public AbstractRedisClient() {
         timer = new HashedWheelTimer();
-        group = new NioEventLoopGroup(20);
+        group = new NioEventLoopGroup();
         channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
         timer.start();
     }

File: src/main/java/com/lambdaworks/redis/cluster/ClusterDistributionChannelWriter.java
Patch:
@@ -27,7 +27,7 @@ public class ClusterDistributionChannelWriter<K, V> implements RedisChannelWrite
 
     private RedisChannelWriter<K, V> defaultWriter;
     private ClusterConnectionProvider clusterConnectionProvider;
-    private boolean closed = true;
+    private boolean closed = false;
     private int executionLimit = 5;
 
     public ClusterDistributionChannelWriter(RedisChannelWriter<K, V> defaultWriter,

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnectionImpl.java
Patch:
@@ -1412,7 +1412,7 @@ public RedisFuture<String> clusterDelSlots(int... slots) {
     }
 
     @Override
-    public RedisFuture<List<String>> clusterInfo() {
+    public RedisFuture<String> clusterInfo() {
         return dispatch(commandBuilder.clusterInfo());
     }
 

File: src/main/java/com/lambdaworks/redis/RedisClusterAsyncConnection.java
Patch:
@@ -23,7 +23,7 @@ public interface RedisClusterAsyncConnection<K, V> extends RedisHashesAsyncConne
 
     RedisFuture<String> clusterDelSlots(int... slots);
 
-    RedisFuture<List<String>> clusterInfo();
+    RedisFuture<String> clusterInfo();
 
     RedisFuture<String> clusterNodes();
 

File: src/main/java/com/lambdaworks/redis/RedisCommandBuilder.java
Patch:
@@ -1323,10 +1323,10 @@ public Command<K, V, String> clusterDelslots(int[] slots) {
         return createCommand(CLUSTER, new StatusOutput<K, V>(codec), args);
     }
 
-    public Command<K, V, List<String>> clusterInfo() {
+    public Command<K, V, String> clusterInfo() {
         CommandArgs<K, V> args = new CommandArgs<K, V>(codec).add(INFO);
 
-        return createCommand(CLUSTER, new StringListOutput<K, V>(codec), args);
+        return createCommand(CLUSTER, new StatusOutput<K, V>(codec), args);
     }
 
     public Command<K, V, String> clusterNodes() {

File: src/main/java/com/lambdaworks/redis/cluster/PooledClusterConnectionProvider.java
Patch:
@@ -51,6 +51,9 @@ public PooledClusterConnectionProvider(RedisClusterClient redisClusterClient, Pa
     public RedisAsyncConnectionImpl<K, V> getConnection(Intent intent, int slot) {
         logger.debug("getConnection(" + intent + ", " + slot + ")");
         RedisClusterNode partition = partitions.getPartitionBySlot(slot);
+        if (partition == null) {
+            throw new RedisException("Cannot determine a partition for slot " + slot + " (Partitions: " + partitions + ")");
+        }
 
         try {
             PoolKey key = new PoolKey(intent, partition.getUri());

File: src/main/java/com/lambdaworks/redis/RedisSentinelAsyncConnection.java
Patch:
@@ -14,9 +14,9 @@
 public interface RedisSentinelAsyncConnection<K, V> extends Closeable {
     Future<SocketAddress> getMasterAddrByName(K key);
 
-    Future<Map<K, V>> getMaster(K key);
+    Future<Map<K, V>> master(K key);
 
-    Future<Map<K, V>> getSlaves(K key);
+    Future<Map<K, V>> slaves(K key);
 
     Future<Long> reset(K key);
 

File: src/main/java/com/lambdaworks/redis/RedisSentinelAsyncConnectionImpl.java
Patch:
@@ -50,13 +50,13 @@ public SocketAddress apply(List<V> input) {
     }
 
     @Override
-    public Future<Map<K, V>> getMaster(K key) {
+    public Future<Map<K, V>> master(K key) {
 
         return dispatch(commandBuilder.master(key));
     }
 
     @Override
-    public Future<Map<K, V>> getSlaves(K key) {
+    public Future<Map<K, V>> slaves(K key) {
 
         return dispatch(commandBuilder.slaves(key));
     }

File: src/test/java/com/lambdaworks/redis/SentinelCommandTest.java
Patch:
@@ -68,7 +68,7 @@ public void getSlaveAddr() throws Exception {
     @Test
     public void getSlaveDownstate() throws Exception {
 
-        Future<Map> result = sentinel.getMaster("myslave");
+        Future<Map> result = sentinel.master("myslave");
         Map map = result.get();
         assertThat((String) map.get("flags"), containsString("disconnected"));
 
@@ -77,7 +77,7 @@ public void getSlaveDownstate() throws Exception {
     @Test
     public void getMaster() throws Exception {
 
-        Future<Map> result = sentinel.getMaster("mymaster");
+        Future<Map> result = sentinel.master("mymaster");
         Map map = result.get();
         System.out.println(map);
         assertEquals("127.0.0.1", map.get("ip")); // !! IPv4/IPv6
@@ -88,7 +88,7 @@ public void getMaster() throws Exception {
     @Test
     public void getSlaves() throws Exception {
 
-        Future<Map> result = sentinel.getSlaves("mymaster");
+        Future<Map> result = sentinel.slaves("mymaster");
         Map map = result.get();
 
     }

File: src/main/java/com/lambdaworks/redis/BaseRedisAsyncConnection.java
Patch:
@@ -1,5 +1,6 @@
 package com.lambdaworks.redis;
 
+import java.io.Closeable;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
@@ -10,7 +11,7 @@
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>
  * @since 17.05.14 21:05
  */
-public interface BaseRedisAsyncConnection<K, V> extends AutoCloseable {
+public interface BaseRedisAsyncConnection<K, V> extends Closeable {
     void setTimeout(long timeout, TimeUnit unit);
 
     String auth(String password);

File: src/main/java/com/lambdaworks/redis/BaseRedisConnection.java
Patch:
@@ -1,5 +1,6 @@
 package com.lambdaworks.redis;
 
+import java.io.Closeable;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
@@ -10,7 +11,7 @@
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>
  * @since 17.05.14 21:05
  */
-public interface BaseRedisConnection<K, V> extends AutoCloseable {
+public interface BaseRedisConnection<K, V> extends Closeable {
     void setTimeout(long timeout, TimeUnit unit);
 
     String auth(String password);

File: src/main/java/com/lambdaworks/redis/FutureSyncInvocationHandler.java
Patch:
@@ -46,7 +46,7 @@ protected Object handleInvocation(Object proxy, Method method, Object[] args) th
                     }
                 }
 
-                return Futures.await(command, timeout, unit);
+                return LettuceFutures.await(command, timeout, unit);
             }
 
             return result;

File: src/main/java/com/lambdaworks/redis/LettuceFutures.java
Patch:
@@ -11,9 +11,9 @@
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>
  * @since 14.05.14 15:17
  */
-public class Futures {
+class LettuceFutures {
 
-    private Futures() {
+    private LettuceFutures() {
 
     }
 

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnectionImpl.java
Patch:
@@ -71,7 +71,7 @@ public RedisFuture<Long> append(K key, V value) {
     @Override
     public String auth(String password) {
         Command<K, V, String> cmd = dispatch(commandBuilder.auth(password));
-        String status = Futures.await(cmd, timeout, unit);
+        String status = LettuceFutures.await(cmd, timeout, unit);
         if ("OK".equals(status))
             this.password = password;
         return status;
@@ -657,7 +657,7 @@ public RedisFuture<Long> sdiffstore(K destination, K... keys) {
     @Override
     public String select(int db) {
         Command<K, V, String> cmd = dispatch(commandBuilder.select(db));
-        String status = Futures.await(cmd, timeout, unit);
+        String status = LettuceFutures.await(cmd, timeout, unit);
         if ("OK".equals(status))
             this.db = db;
         return status;

File: src/main/java/com/lambdaworks/redis/RedisSentinelAsyncConnection.java
Patch:
@@ -1,5 +1,6 @@
 package com.lambdaworks.redis;
 
+import java.io.Closeable;
 import java.net.SocketAddress;
 import java.util.Map;
 import java.util.concurrent.Future;
@@ -10,7 +11,7 @@
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>
  * @since 15.05.14 21:04
  */
-public interface RedisSentinelAsyncConnection<K, V> extends AutoCloseable {
+public interface RedisSentinelAsyncConnection<K, V> extends Closeable {
     Future<SocketAddress> getMasterAddrByName(K key);
 
     Future<Map<K, V>> getMaster(K key);

File: src/main/java/com/lambdaworks/redis/codec/Utf8StringCodec.java
Patch:
@@ -7,7 +7,7 @@
 import java.nio.charset.*;
 
 import static java.nio.charset.CoderResult.OVERFLOW;
-import com.lambdaworks.redis.protocol.Charsets;
+import com.lambdaworks.redis.protocol.LettuceCharsets;
 
 /**
  * A {@link RedisCodec} that handles UTF-8 encoded keys and values.
@@ -23,7 +23,7 @@ public class Utf8StringCodec extends RedisCodec<String, String> {
      * Initialize a new instance that encodes and decodes strings using the UTF-8 charset;
      */
     public Utf8StringCodec() {
-        charset = Charsets.UTF8;
+        charset = LettuceCharsets.UTF8;
         decoder = charset.newDecoder();
         chars = CharBuffer.allocate(1024);
     }

File: src/main/java/com/lambdaworks/redis/output/StatusOutput.java
Patch:
@@ -7,11 +7,11 @@
 
 import java.nio.ByteBuffer;
 
-import static com.lambdaworks.redis.protocol.Charsets.buffer;
+import static com.lambdaworks.redis.protocol.LettuceCharsets.buffer;
 
 /**
  * Status message output.
- *
+ * 
  * @author Will Glozer
  */
 public class StatusOutput<K, V> extends CommandOutput<K, V, String> {

File: src/main/java/com/lambdaworks/redis/protocol/Command.java
Patch:
@@ -19,7 +19,7 @@
  * @author Will Glozer
  */
 public class Command<K, V, T> extends AbstractFuture<T> implements RedisFuture<T> {
-    private static final byte[] CRLF = "\r\n".getBytes(Charsets.ASCII);
+    private static final byte[] CRLF = "\r\n".getBytes(LettuceCharsets.ASCII);
 
     public final CommandType type;
     protected CommandArgs<K, V> args;

File: src/main/java/com/lambdaworks/redis/protocol/CommandArgs.java
Patch:
@@ -12,18 +12,18 @@
 
 /**
  * Redis command argument encoder.
- *
+ * 
  * @author Will Glozer
  */
 public class CommandArgs<K, V> {
-    private static final byte[] CRLF = "\r\n".getBytes(Charsets.ASCII);
+    private static final byte[] CRLF = "\r\n".getBytes(LettuceCharsets.ASCII);
 
     private RedisCodec<K, V> codec;
     private ByteBuffer buffer;
     private int count;
 
     public CommandArgs(RedisCodec<K, V> codec) {
-        this.codec  = codec;
+        this.codec = codec;
         this.buffer = ByteBuffer.allocate(32);
     }
 

File: src/main/java/com/lambdaworks/redis/protocol/CommandKeyword.java
Patch:
@@ -13,6 +13,6 @@ public enum CommandKeyword {
     public byte[] bytes;
 
     private CommandKeyword() {
-        bytes = name().getBytes(Charsets.ASCII);
+        bytes = name().getBytes(LettuceCharsets.ASCII);
     }
 }

File: src/main/java/com/lambdaworks/redis/protocol/CommandType.java
Patch:
@@ -69,6 +69,6 @@ public enum CommandType {
     public byte[] bytes;
 
     private CommandType() {
-        bytes = name().getBytes(Charsets.ASCII);
+        bytes = name().getBytes(LettuceCharsets.ASCII);
     }
 }

File: src/main/java/com/lambdaworks/redis/protocol/LettuceCharsets.java
Patch:
@@ -10,7 +10,7 @@
  * 
  * @author Will Glozer
  */
-public class Charsets {
+public class LettuceCharsets {
     public static final Charset ASCII = Charset.forName("US-ASCII");
     public static final Charset UTF8 = Charset.forName("UTF-8");
 

File: src/main/java/com/lambdaworks/redis/protocol/RedisStateMachine.java
Patch:
@@ -8,7 +8,7 @@
 import java.nio.ByteBuffer;
 import java.util.LinkedList;
 
-import static com.lambdaworks.redis.protocol.Charsets.buffer;
+import static com.lambdaworks.redis.protocol.LettuceCharsets.buffer;
 import static com.lambdaworks.redis.protocol.RedisStateMachine.State.Type.*;
 
 /**

File: src/test/java/com/lambdaworks/redis/AsyncConnectionTest.java
Patch:
@@ -142,7 +142,7 @@ public void awaitAll() throws Exception {
         Future<String> get2 = async.get(key);
         Future<Long> append = async.append(key, value);
 
-        assertTrue(Futures.awaitAll(1, TimeUnit.SECONDS, get1, set, get2, append));
+        assertTrue(LettuceFutures.awaitAll(1, TimeUnit.SECONDS, get1, set, get2, append));
 
         assertNull(get1.get());
         assertEquals("OK", set.get());
@@ -153,6 +153,6 @@ public void awaitAll() throws Exception {
     @Test(timeout = 100)
     public void awaitAllTimeout() throws Exception {
         Future<KeyValue<String, String>> blpop = async.blpop(1, key);
-        assertFalse(Futures.awaitAll(1, TimeUnit.NANOSECONDS, blpop));
+        assertFalse(LettuceFutures.awaitAll(1, TimeUnit.NANOSECONDS, blpop));
     }
 }

File: src/test/java/com/lambdaworks/redis/CommandInternalsTest.java
Patch:
@@ -13,7 +13,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static com.lambdaworks.redis.protocol.Charsets.buffer;
+import static com.lambdaworks.redis.protocol.LettuceCharsets.buffer;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -122,6 +122,6 @@ public void sillyTestsForEmmaCoverage() throws Exception {
         assertEquals(CommandKeyword.AFTER, CommandKeyword.valueOf("AFTER"));
         assertNotNull(new ZStoreArgs.Builder());
         assertNotNull(new SortArgs.Builder());
-        assertNotNull(new Charsets());
+        assertNotNull(new LettuceCharsets());
     }
 }

File: src/test/java/com/lambdaworks/redis/SentinelCommandTest.java
Patch:
@@ -22,7 +22,7 @@
 public class SentinelCommandTest extends AbstractCommandTest {
 
     private static RedisClient sentinelClient;
-    private RedisSentinelAsyncConnectionImpl sentinel;
+    private RedisSentinelAsyncConnection sentinel;
 
     @BeforeClass
     public static void setupClient() {

File: src/main/java/com/lambdaworks/redis/RedisSentinelAsyncConnection.java
Patch:
@@ -5,10 +5,12 @@
 import java.util.concurrent.Future;
 
 /**
+ * Asynchronous executed commands for Sentinel.
+ * 
  * @author <a href="mailto:mpaluch@paluch.biz">Mark Paluch</a>
  * @since 15.05.14 21:04
  */
-public interface RedisSentinelConnection<K, V> extends AutoCloseable {
+public interface RedisSentinelAsyncConnection<K, V> extends AutoCloseable {
     Future<SocketAddress> getMasterAddrByName(K key);
 
     Future<Map<K, V>> getMaster(K key);

File: src/main/java/com/lambdaworks/redis/RedisSentinelAsyncConnectionImpl.java
Patch:
@@ -21,10 +21,10 @@
  * @since 15.05.14 16:27
  */
 @ChannelHandler.Sharable
-public class RedisSentinelConnectionImpl<K, V> extends RedisChannelHandler implements RedisSentinelConnection<K, V> {
+public class RedisSentinelAsyncConnectionImpl<K, V> extends RedisChannelHandler implements RedisSentinelAsyncConnection<K, V> {
     private SentinelCommandBuilder<K, V> commandBuilder;
 
-    public RedisSentinelConnectionImpl(RedisCodec<K, V> codec, BlockingQueue queue, long timeout, TimeUnit unit) {
+    public RedisSentinelAsyncConnectionImpl(RedisCodec<K, V> codec, BlockingQueue queue, long timeout, TimeUnit unit) {
         super(queue, timeout, unit);
         commandBuilder = new SentinelCommandBuilder<K, V>(codec);
 

File: src/test/java/com/lambdaworks/redis/SentinelCommandTest.java
Patch:
@@ -22,7 +22,7 @@
 public class SentinelCommandTest extends AbstractCommandTest {
 
     private static RedisClient sentinelClient;
-    private RedisSentinelConnectionImpl sentinel;
+    private RedisSentinelAsyncConnectionImpl sentinel;
 
     @BeforeClass
     public static void setupClient() {
@@ -146,6 +146,6 @@ public void connectToRedisUsingSentinel() throws Exception {
     }
 
     protected static RedisClient getRedisSentinelClient() {
-        return new RedisClient(RedisURI.Builder.sentinel("localhost", "mymaster", 1234).sentinel("localhost").build());
+        return new RedisClient(RedisURI.Builder.sentinel("localhost", 1234, "mymaster").withSentinel("localhost").build());
     }
 }

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnection.java
Patch:
@@ -243,6 +243,7 @@ public Future<Boolean> expireat(K key, long timestamp) {
     public Future<List<Object>> exec() {
         MultiOutput<K, V> multi = this.multi;
         this.multi = null;
+        if (multi == null) multi = new MultiOutput<K, V>(codec);
         return dispatch(EXEC, multi);
     }
 

File: src/main/java/com/lambdaworks/redis/output/MultiOutput.java
Patch:
@@ -39,7 +39,8 @@ public void set(ByteBuffer bytes) {
 
     @Override
     public void setError(ByteBuffer error) {
-        queue.peek().getOutput().setError(error);
+        CommandOutput<K, V, ?> output = queue.isEmpty() ? this : queue.peek().getOutput();
+        output.setError(decodeAscii(error));
     }
 
     @Override

File: src/test/java/com/lambdaworks/redis/AsyncConnectionTest.java
Patch:
@@ -49,8 +49,10 @@ public void watch() throws Exception {
         redis.set(key, value + "X");
 
         async.multi();
+        Future<String> set = async.set(key, value);
         Future<Long> append = async.append(key, "foo");
         assertEquals(list(), async.exec().get());
+        assertNull(set.get());
         assertNull(append.get());
     }
 

File: src/main/java/com/lambdaworks/redis/protocol/CommandArgs.java
Patch:
@@ -60,7 +60,7 @@ public CommandArgs<K, V> addValues(V... values) {
 
     public CommandArgs<K, V> add(Map<K, V> map) {
         if (map.size() > 2) {
-            realloc(16 * map.size());
+            realloc(buffer.capacity() + 16 * map.size());
         }
 
         for (Map.Entry<K, V> entry : map.entrySet()) {

File: src/main/java/com/lambdaworks/redis/pubsub/PubSubCommandHandler.java
Patch:
@@ -36,7 +36,7 @@ public PubSubCommandHandler(BlockingQueue<Command<K, V, ?>> queue, RedisCodec<K,
 
     @Override
     protected void decode(ChannelHandlerContext ctx, ChannelBuffer buffer) throws InterruptedException {
-        while (!queue.isEmpty()) {
+        while (output.type() == null && !queue.isEmpty()) {
             CommandOutput<K, V, ?> output = queue.peek().getOutput();
             if (!rsm.decode(buffer, output)) return;
             queue.take().complete();

File: src/main/java/com/lambdaworks/redis/pubsub/PubSubCommandHandler.java
Patch:
@@ -20,6 +20,7 @@
  */
 public class PubSubCommandHandler<K, V> extends CommandHandler<K, V> {
     private RedisCodec<K, V> codec;
+    private PubSubOutput<K, V> output;
 
     /**
      * Initialize a new instance.
@@ -29,7 +30,8 @@ public class PubSubCommandHandler<K, V> extends CommandHandler<K, V> {
      */
     public PubSubCommandHandler(BlockingQueue<Command<K, V, ?>> queue, RedisCodec<K, V> codec) {
         super(queue);
-        this.codec = codec;
+        this.codec  = codec;
+        this.output = new PubSubOutput<K, V>(codec);
     }
 
     @Override
@@ -41,7 +43,6 @@ protected void decode(ChannelHandlerContext ctx, ChannelBuffer buffer) throws In
             if (output instanceof PubSubOutput) Channels.fireMessageReceived(ctx, output);
         }
 
-        PubSubOutput<K, V> output = new PubSubOutput<K, V>(codec);
         while (rsm.decode(buffer, output)) {
             Channels.fireMessageReceived(ctx, output);
             output = new PubSubOutput<K, V>(codec);

File: src/main/java/com/lambdaworks/redis/RedisClient.java
Patch:
@@ -106,10 +106,10 @@ public RedisPubSubConnection<String, String> connectPubSub() {
      */
     public <K, V> RedisConnection<K, V> connect(RedisCodec<K, V> codec) {
         try {
-            BlockingQueue<Command<?>> queue = new LinkedBlockingQueue<Command<?>>();
+            BlockingQueue<Command<K, V, ?>> queue = new LinkedBlockingQueue<Command<K, V, ?>>();
 
             ConnectionWatchdog watchdog = new ConnectionWatchdog(bootstrap, channels, timer);
-            CommandHandler handler = new CommandHandler(queue);
+            CommandHandler handler = new CommandHandler<K, V>(queue);
             RedisConnection<K, V> connection = new RedisConnection<K, V>(queue, codec, timeout, unit);
 
             ChannelPipeline pipeline = Channels.pipeline(watchdog, handler, connection);
@@ -140,7 +140,7 @@ public <K, V> RedisConnection<K, V> connect(RedisCodec<K, V> codec) {
      */
     public <K, V> RedisPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec) {
         try {
-            BlockingQueue<Command<?>> queue = new LinkedBlockingQueue<Command<?>>();
+            BlockingQueue<Command<K, V, ?>> queue = new LinkedBlockingQueue<Command<K, V, ?>>();
 
             ConnectionWatchdog watchdog = new ConnectionWatchdog(bootstrap, channels, timer);
             PubSubCommandHandler<K, V> handler = new PubSubCommandHandler<K, V>(queue, codec);

File: src/main/java/com/lambdaworks/redis/RedisCommandInterruptedException.java
Patch:
@@ -8,6 +8,7 @@
  *
  * @author Will Glozer
  */
+@SuppressWarnings("serial")
 public class RedisCommandInterruptedException extends RedisException {
     public RedisCommandInterruptedException(Throwable e) {
         super("Command interrupted", e);

File: src/main/java/com/lambdaworks/redis/RedisException.java
Patch:
@@ -8,6 +8,7 @@
  *
  * @author Will Glozer
  */
+@SuppressWarnings("serial")
 public class RedisException extends RuntimeException {
     public RedisException(String msg) {
         super(msg);

File: src/main/java/com/lambdaworks/redis/output/BooleanOutput.java
Patch:
@@ -11,10 +11,10 @@
  *
  * @author Will Glozer
  */
-public class BooleanOutput extends CommandOutput<Boolean> {
+public class BooleanOutput<K, V> extends CommandOutput<K, V, Boolean> {
     private Boolean value;
 
-    public BooleanOutput(RedisCodec<?, ?> codec) {
+    public BooleanOutput(RedisCodec<K, V> codec) {
         super(codec);
     }
 

File: src/main/java/com/lambdaworks/redis/output/DateOutput.java
Patch:
@@ -12,10 +12,10 @@
  *
  * @author Will Glozer
  */
-public class DateOutput extends CommandOutput<Date> {
+public class DateOutput<K, V> extends CommandOutput<K, V, Date> {
     private Date value;
 
-    public DateOutput(RedisCodec<?, ?> codec) {
+    public DateOutput(RedisCodec<K, V> codec) {
         super(codec);
     }
 

File: src/main/java/com/lambdaworks/redis/output/DoubleOutput.java
Patch:
@@ -14,10 +14,10 @@
  *
  * @author Will Glozer
  */
-public class DoubleOutput extends CommandOutput<Double> {
+public class DoubleOutput<K, V> extends CommandOutput<K, V, Double> {
     private Double value;
 
-    public DoubleOutput(RedisCodec<?, ?> codec) {
+    public DoubleOutput(RedisCodec<K, V> codec) {
         super(codec);
     }
 

File: src/main/java/com/lambdaworks/redis/output/IntegerOutput.java
Patch:
@@ -12,10 +12,10 @@
  *
  * @author Will Glozer
  */
-public class IntegerOutput extends CommandOutput<Long> {
+public class IntegerOutput<K, V> extends CommandOutput<K, V, Long> {
     private Long value;
 
-    public IntegerOutput(RedisCodec<?, ?> codec) {
+    public IntegerOutput(RedisCodec<K, V> codec) {
         super(codec);
     }
 

File: src/main/java/com/lambdaworks/redis/output/StatusOutput.java
Patch:
@@ -12,12 +12,12 @@
  *
  * @author Will Glozer
  */
-public class StatusOutput extends CommandOutput<String> {
+public class StatusOutput<K, V> extends CommandOutput<K, V, String> {
     private static final ByteBuffer OK = ByteBuffer.wrap("OK".getBytes());
 
     private String status;
 
-    public StatusOutput(RedisCodec<?, ?> codec) {
+    public StatusOutput(RedisCodec<K, V> codec) {
         super(codec);
     }
 

File: src/main/java/com/lambdaworks/redis/output/StringListOutput.java
Patch:
@@ -14,10 +14,10 @@
  *
  * @author Will Glozer
  */
-public class StringListOutput extends CommandOutput<List<String>> {
+public class StringListOutput<K, V> extends CommandOutput<K, V, List<String>> {
     private List<String> list = new ArrayList<String>();
 
-    public StringListOutput(RedisCodec<?, ?> codec) {
+    public StringListOutput(RedisCodec<K, V> codec) {
         super(codec);
     }
 

File: src/main/java/com/lambdaworks/redis/protocol/CommandOutput.java
Patch:
@@ -14,8 +14,8 @@
  *
  * @author Will Glozer
  */
-public abstract class CommandOutput<T> {
-    protected RedisCodec<?, ?> codec;
+public abstract class CommandOutput<K, V, T> {
+    protected RedisCodec<K, V> codec;
     protected String error;
 
     /**
@@ -24,7 +24,7 @@ public abstract class CommandOutput<T> {
      *
      * @param codec Codec used to encode/decode keys and values.
      */
-    public CommandOutput(RedisCodec<?, ?> codec) {
+    public CommandOutput(RedisCodec<K, V> codec) {
         this.codec = codec;
     }
 

File: src/main/java/com/lambdaworks/redis/protocol/CommandType.java
Patch:
@@ -3,7 +3,7 @@
 package com.lambdaworks.redis.protocol;
 
 /**
- * All redis commands as of version 2.2.4.
+ * Redis commands.
  *
  * @author Will Glozer
  */

File: src/main/java/com/lambdaworks/redis/protocol/RedisStateMachine.java
Patch:
@@ -16,7 +16,7 @@
  *
  * @author Will Glozer
  */
-public class RedisStateMachine {
+public class RedisStateMachine<K, V> {
     private static final ByteBuffer QUEUED = ByteBuffer.wrap("QUEUED".getBytes());
 
     static class State {
@@ -43,7 +43,7 @@ public RedisStateMachine() {
      *
      * @return true if a complete response was read.
      */
-    public boolean decode(ChannelBuffer buffer, CommandOutput<?> output) {
+    public boolean decode(ChannelBuffer buffer, CommandOutput<K, V, ?> output) {
         int length, end;
         ByteBuffer bytes;
 

File: src/test/java/com/lambdaworks/redis/AsyncConnectionTest.java
Patch:
@@ -71,6 +71,7 @@ public void multiCommand() throws Exception {
     }
 
     @Test
+    @SuppressWarnings({"unchecked", "varargs"})
     public void scoredValueListCommand() throws Exception {
         assertNull(async.zadd(key, 1.0, "a"));
         assertNull(async.zadd(key, 2.0, "b"));

File: src/test/java/com/lambdaworks/redis/StringCommandTest.java
Patch:
@@ -6,8 +6,7 @@
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
-import java.util.HashMap;
-import java.util.Map;
+import java.util.*;
 
 import static org.junit.Assert.*;
 

