File: dexlib2/src/main/java/org/jf/dexlib2/analysis/reflection/util/ReflectionUtils.java
Patch:
@@ -68,6 +68,6 @@ public static String dexToJavaName(String dexName) {
             return primitiveMap.inverse().get(dexName);
         }
 
-        return dexName.replace('/', '.').substring(1, dexName.length()-2);
+        return dexName.replace('/', '.').substring(1, dexName.length()-1);
     }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/writer/DexWriter.java
Patch:
@@ -69,6 +69,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.security.MessageDigest;
@@ -916,7 +917,7 @@ private void writeAnnotationDirectories(@Nonnull DexDataWriter writer) throws IO
                 tempBuffer.order(ByteOrder.LITTLE_ENDIAN);
             }
 
-            tempBuffer.clear();
+            ((Buffer) tempBuffer).clear();
 
             int fieldAnnotations = 0;
             int methodAnnotations = 0;

File: dexlib2/src/main/java/org/jf/dexlib2/rewriter/TypeRewriter.java
Patch:
@@ -57,7 +57,7 @@ public class TypeRewriter implements Rewriter<String> {
      * @return The modified version of the unwrapped type. This will be re-array-ified if the original wrapped type was
      * an array.
      */
-    @Nonnull public String rewriteUnwrappedType(@Nonnull String value) {
+    @Nonnull protected String rewriteUnwrappedType(@Nonnull String value) {
         return value;
     }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/rewriter/InstructionRewriter.java
Patch:
@@ -81,7 +81,7 @@ protected BaseRewrittenReferenceInstruction(@Nonnull T instruction) {
         }
 
         @Override @Nonnull public Reference getReference() {
-            switch (getReferenceType()) {
+            switch (instruction.getReferenceType()) {
                 case ReferenceType.TYPE:
                     return RewriterUtils.rewriteTypeReference(rewriters.getTypeRewriter(),
                             (TypeReference)instruction.getReference());

File: baksmali/src/main/java/org/jf/baksmali/AnalysisArguments.java
Patch:
@@ -34,6 +34,7 @@
 import com.beust.jcommander.Parameter;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
+import org.jf.dexlib2.VersionMap;
 import org.jf.dexlib2.analysis.ClassPath;
 import org.jf.dexlib2.analysis.ClassPathResolver;
 import org.jf.dexlib2.dexbacked.DexBackedDexFile;
@@ -101,6 +102,8 @@ public ClassPath loadClassPathForDexFile(@Nonnull File dexFileDir,
             if (container instanceof OatFile) {
                 checkPackagePrivateAccess = true;
                 oatVersion = ((OatFile) container).getOatVersion();
+            } else {
+                oatVersion = VersionMap.mapApiToArtVersion(dexEntry.getDexFile().getOpcodes().api);
             }
         } else {
             // this should always be true for ART

File: dexlib2/src/main/java/org/jf/dexlib2/util/Preconditions.java
Patch:
@@ -220,13 +220,13 @@ public static int checkArrayPayloadElementWidth(int elementWidth) {
     }
 
     public static <L extends List<? extends Number>> L checkArrayPayloadElements(int elementWidth, L elements) {
-        // mask of all bits that do not fit into an 'elementWidth'-bit number
-        long bitmask = -1L << elementWidth;
+        // mask of all bits that do not fit into an 'elementWidth'-byte number
+        long bitmask = -1L << (elementWidth * 8);
 
         for (Number element : elements) {
             if ((element.longValue() & bitmask) != 0) {
                 throw new IllegalArgumentException(
-                        String.format("Number %d must fit into a %d-bit number", element.longValue(), elementWidth));
+                        String.format("Number %d must fit into a %d-byte number", element.longValue(), elementWidth));
             }
         }
 

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedMethod.java
Patch:
@@ -192,7 +192,7 @@ public Set<? extends Annotation> getAnnotations() {
     @Override
     public DexBackedMethodImplementation getImplementation() {
         if (codeOffset > 0) {
-            return new DexBackedMethodImplementation(dexFile, this, codeOffset);
+            return dexFile.createMethodImplementation(dexFile, this, codeOffset);
         }
         return null;
     }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedMethodImplementation.java
Patch:
@@ -52,7 +52,7 @@
 public class DexBackedMethodImplementation implements MethodImplementation {
     @Nonnull public final DexBackedDexFile dexFile;
     @Nonnull public final DexBackedMethod method;
-    private final int codeOffset;
+    protected final int codeOffset;
 
     protected DexBackedMethodImplementation(@Nonnull DexBackedDexFile dexFile,
                                   @Nonnull DexBackedMethod method,

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/raw/HeaderItem.java
Patch:
@@ -84,6 +84,9 @@ public class HeaderItem {
     public static final int CLASS_COUNT_OFFSET = 96;
     public static final int CLASS_START_OFFSET = 100;
 
+    public static final int DATA_SIZE_OFFSET = 104;
+    public static final int DATA_START_OFFSET = 108;
+
     @Nonnull private DexBackedDexFile dexFile;
 
     public HeaderItem(@Nonnull DexBackedDexFile dexFile) {

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/raw/SectionAnnotator.java
Patch:
@@ -48,7 +48,7 @@ public abstract class SectionAnnotator {
     public final int sectionOffset;
     public final int itemCount;
 
-    private Map<Integer, String> itemIdentities = Maps.newHashMap();
+    protected Map<Integer, String> itemIdentities = Maps.newHashMap();
 
     public SectionAnnotator(@Nonnull DexAnnotator annotator, @Nonnull MapItem mapItem) {
         this.annotator = annotator;

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/OatFile.java
Patch:
@@ -614,6 +614,9 @@ private class DexEntryIterator implements Iterator<DexEntry> {
             if (getOatVersion() >= 127) {
                 offset += 4; // method bss mapping offset
             }
+            if (getOatVersion() >= 135) {
+                offset += 8; // type bss mapping and string bss mapping offsets
+            }
             if (getOatVersion() < 75) {
                 // prior to 75, the class offsets are included here directly
                 int classCount = readSmallUint(dexOffset + HeaderItem.CLASS_COUNT_OFFSET);

File: dexlib2/src/main/java/org/jf/dexlib2/builder/MutableMethodImplementation.java
Patch:
@@ -473,6 +473,9 @@ private void fixInstructions() {
     private int mapCodeAddressToIndex(@Nonnull int[] codeAddressToIndex, int codeAddress) {
         int index;
         do {
+            if (codeAddress >= codeAddressToIndex.length) {
+                codeAddress = codeAddressToIndex.length - 1;
+            }
             index = codeAddressToIndex[codeAddress];
             if (index < 0) {
                 codeAddress--;

File: smalidea/src/main/java/org/jf/smalidea/SmaliTokens.java
Patch:
@@ -120,6 +120,7 @@ public static IElementType getElementType(int tokenType) {
     @SuppressWarnings({"UnusedDeclaration"}) public static IElementType INSTRUCTION_FORMAT32x;
     @SuppressWarnings({"UnusedDeclaration"}) public static IElementType INSTRUCTION_FORMAT35c_METHOD;
     @SuppressWarnings({"UnusedDeclaration"}) public static IElementType INSTRUCTION_FORMAT35c_METHOD_ODEX;
+    @SuppressWarnings({"UnusedDeclaration"}) public static IElementType INSTRUCTION_FORMAT35c_METHOD_OR_METHOD_HANDLE_TYPE;
     @SuppressWarnings({"UnusedDeclaration"}) public static IElementType INSTRUCTION_FORMAT35c_TYPE;
     @SuppressWarnings({"UnusedDeclaration"}) public static IElementType INSTRUCTION_FORMAT35mi_METHOD;
     @SuppressWarnings({"UnusedDeclaration"}) public static IElementType INSTRUCTION_FORMAT35ms_METHOD;
@@ -238,6 +239,7 @@ public static IElementType getElementType(int tokenType) {
         tokenColors.put("INSTRUCTION_FORMAT32x", SmaliHighlightingColors.INSTRUCTION);
         tokenColors.put("INSTRUCTION_FORMAT35c_METHOD", SmaliHighlightingColors.INSTRUCTION);
         tokenColors.put("INSTRUCTION_FORMAT35c_METHOD_ODEX", SmaliHighlightingColors.INSTRUCTION);
+        tokenColors.put("INSTRUCTION_FORMAT35c_METHOD_OR_METHOD_HANDLE_TYPE", SmaliHighlightingColors.INSTRUCTION);
         tokenColors.put("INSTRUCTION_FORMAT35c_TYPE", SmaliHighlightingColors.INSTRUCTION);
         tokenColors.put("INSTRUCTION_FORMAT35mi_METHOD", SmaliHighlightingColors.INSTRUCTION);
         tokenColors.put("INSTRUCTION_FORMAT35ms_METHOD", SmaliHighlightingColors.INSTRUCTION);
@@ -343,6 +345,7 @@ public static IElementType getElementType(int tokenType) {
                 INSTRUCTION_FORMAT32x,
                 INSTRUCTION_FORMAT35c_METHOD,
                 INSTRUCTION_FORMAT35c_METHOD_ODEX,
+                INSTRUCTION_FORMAT35c_METHOD_OR_METHOD_HANDLE_TYPE,
                 INSTRUCTION_FORMAT35c_TYPE,
                 INSTRUCTION_FORMAT35mi_METHOD,
                 INSTRUCTION_FORMAT35ms_METHOD,

File: dexlib2/src/test/java/org/jf/dexlib2/writer/CallSiteTest.java
Patch:
@@ -74,7 +74,7 @@ public void testPoolCallSite() throws IOException {
                                 new ImmutableMethodImplementation(10, ImmutableList.of(
                                         new ImmutableInstruction35c(Opcode.INVOKE_CUSTOM, 0, 0, 0, 0, 0, 0,
                                                 new ImmutableCallSiteReference("call_site_1",
-                                                        new ImmutableMethodHandleReference(MethodHandleType.STATIC_INVOKE,
+                                                        new ImmutableMethodHandleReference(MethodHandleType.INVOKE_STATIC,
                                                                 new ImmutableMethodReference("Lcls1", "loader",
                                                                         ImmutableList.of("Ljava/lang/invoke/Lookup;",
                                                                                 "Ljava/lang/String;",
@@ -96,7 +96,7 @@ public void testBuilderCallSite() throws IOException {
 
         BuilderCallSiteReference callSite = dexBuilder.internCallSite(new ImmutableCallSiteReference("call_site_1",
                 new ImmutableMethodHandleReference(
-                        MethodHandleType.STATIC_INVOKE,
+                        MethodHandleType.INVOKE_STATIC,
                         new ImmutableMethodReference("Lcls1", "loader", ImmutableList.of("Ljava/lang/invoke/Lookup;",
                                 "Ljava/lang/String;",
                                 "Ljava/lang/invoke/MethodType;"),

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/ReferenceFormatter.java
Patch:
@@ -60,8 +60,8 @@ public static void writeCallSiteReference(IndentingWriter writer, CallSiteRefere
         }
         writer.write(")@");
         MethodHandleReference methodHandle = callSite.getMethodHandle();
-        if (methodHandle.getMethodHandleType() != MethodHandleType.STATIC_INVOKE) {
-            throw new IllegalArgumentException("The linker method handle for a call site must be of type static-invoke");
+        if (methodHandle.getMethodHandleType() != MethodHandleType.INVOKE_STATIC) {
+            throw new IllegalArgumentException("The linker method handle for a call site must be of type invoke-static");
         }
         writeReference(writer, ReferenceType.METHOD, callSite.getMethodHandle().getMemberReference());
     }

File: dexlib2/src/main/java/org/jf/dexlib2/iface/reference/MethodHandleReference.java
Patch:
@@ -48,9 +48,6 @@ public interface MethodHandleReference extends Reference, Comparable<MethodHandl
     /**
      * Gets the member that is being referenced by this method handle.
      *
-     * For STATIC_INVOKE and INSTANCE_INVOKE method handle types, this should be a MethodReference.
-     * For the other method handle types, this should be a FieldReference.
-     *
      * @return A MethodReference or FieldReference, depending on the method handle type
      */
     @Nonnull Reference getMemberReference();

File: dexlib2/src/main/java/org/jf/dexlib2/util/ReferenceUtil.java
Patch:
@@ -192,8 +192,8 @@ public static void writeCallSite(Writer writer, CallSiteReference callSiteRefere
         }
         writer.write(")@");
         MethodHandleReference methodHandle = callSiteReference.getMethodHandle();
-        if (methodHandle.getMethodHandleType() != MethodHandleType.STATIC_INVOKE) {
-            throw new IllegalArgumentException("The linker method handle for a call site must be of type static-invoke");
+        if (methodHandle.getMethodHandleType() != MethodHandleType.INVOKE_STATIC) {
+            throw new IllegalArgumentException("The linker method handle for a call site must be of type invoke-static");
         }
         writeMethodDescriptor(writer, (MethodReference)callSiteReference.getMethodHandle().getMemberReference());
     }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/instruction/DexBackedInstruction45cc.java
Patch:
@@ -91,7 +91,7 @@ public int getReferenceType() {
     @Override
     public Reference getReference2() {
         return DexBackedReference.makeReference(dexFile, opcode.referenceType2,
-                dexFile.readUshort(instructionStart + 3));
+                dexFile.readUshort(instructionStart + 6));
     }
 
     @Override

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/instruction/DexBackedInstruction4rcc.java
Patch:
@@ -70,7 +70,7 @@ public int getReferenceType() {
     @Override
     public Reference getReference2() {
         return DexBackedReference.makeReference(dexFile, opcode.referenceType2,
-                dexFile.readUshort(instructionStart + 3));
+                dexFile.readUshort(instructionStart + 6));
     }
 
     @Override

File: util/src/main/java/org/jf/util/jcommander/HelpFormatter.java
Patch:
@@ -34,9 +34,9 @@
 import com.beust.jcommander.JCommander;
 import com.beust.jcommander.ParameterDescription;
 import com.beust.jcommander.Parameters;
-import com.beust.jcommander.internal.Lists;
 import com.google.common.base.Joiner;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
 import org.jf.util.WrappedIndentingWriter;
 
 import javax.annotation.Nonnull;

File: dexlib2/src/test/java/org/jf/dexlib2/DexEntryFinderTest.java
Patch:
@@ -31,8 +31,8 @@
 
 package org.jf.dexlib2;
 
-import com.beust.jcommander.internal.Maps;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import org.jf.dexlib2.DexFileFactory.DexEntryFinder;
 import org.jf.dexlib2.DexFileFactory.DexFileNotFoundException;
 import org.jf.dexlib2.DexFileFactory.MultipleMatchingDexEntriesException;

File: dexlib2/src/main/java/org/jf/dexlib2/writer/pool/DexPool.java
Patch:
@@ -58,8 +58,8 @@ public class DexPool extends DexWriter<CharSequence, StringReference, CharSequen
         ClassPool, CallSitePool, MethodHandlePool, TypeListPool, AnnotationPool, AnnotationSetPool, EncodedArrayPool> {
 
     private final Markable[] sections = new Markable[] {
-            stringSection, typeSection, protoSection, fieldSection, methodSection, classSection, typeListSection,
-            annotationSection, annotationSetSection
+            stringSection, typeSection, protoSection, fieldSection, methodSection, classSection, callSiteSection,
+            methodHandleSection, typeListSection, annotationSection, annotationSetSection, encodedArraySection
     };
 
     public DexPool(Opcodes opcodes) {

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/ClassPathResolver.java
Patch:
@@ -31,10 +31,10 @@
 
 package org.jf.dexlib2.analysis;
 
-import com.beust.jcommander.internal.Sets;
 import com.google.common.base.Joiner;
 import com.google.common.base.Splitter;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
 import org.jf.dexlib2.DexFileFactory;
 import org.jf.dexlib2.DexFileFactory.UnsupportedFileTypeException;
 import org.jf.dexlib2.Opcodes;

File: dexlib2/src/main/java/org/jf/dexlib2/writer/io/MemoryDataStore.java
Patch:
@@ -82,7 +82,7 @@ protected void growBufferIfNeeded(int minSize) {
                     }
                     return 0;
                 }
-                System.arraycopy(buf, position, b, 0, readLength);
+                System.arraycopy(buf, position, b, off, readLength);
                 position += readLength;
                 return readLength;
             }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/reference/DexBackedMethodHandleReference.java
Patch:
@@ -66,8 +66,8 @@ public Reference getMemberReference() {
             case MethodHandleType.STATIC_GET:
             case MethodHandleType.STATIC_PUT:
                 return new DexBackedFieldReference(dexFile, memberIndex);
-            case MethodHandleType.INVOKE_INSTANCE:
-            case MethodHandleType.INVOKE_STATIC:
+            case MethodHandleType.INSTANCE_INVOKE:
+            case MethodHandleType.STATIC_INVOKE:
                 return new DexBackedMethodReference(dexFile, memberIndex);
             default:
                 throw new ExceptionWithContext("Invalid method handle type: %d", getMethodHandleType());

File: dexlib2/src/main/java/org/jf/dexlib2/iface/reference/MethodHandleReference.java
Patch:
@@ -48,7 +48,7 @@ public interface MethodHandleReference extends Reference, Comparable<MethodHandl
     /**
      * Gets the member that is being referenced by this method handle.
      *
-     * For INVOKE_STATIC and INVOKE_INSTANCE method handle types, this should be a MethodReference.
+     * For STATIC_INVOKE and INSTANCE_INVOKE method handle types, this should be a MethodReference.
      * For the other method handle types, this should be a FieldReference.
      *
      * @return A MethodReference or FieldReference, depending on the method handle type

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/reference/ImmutableMethodHandleReference.java
Patch:
@@ -71,8 +71,8 @@ public static ImmutableMethodHandleReference of(@Nonnull MethodHandleReference m
                 memberReference = ImmutableFieldReference.of(
                         (FieldReference) methodHandleReference.getMemberReference());
                 break;
-            case MethodHandleType.INVOKE_INSTANCE:
-            case MethodHandleType.INVOKE_STATIC:
+            case MethodHandleType.INSTANCE_INVOKE:
+            case MethodHandleType.STATIC_INVOKE:
                 memberReference = ImmutableMethodReference.of(
                         (MethodReference) methodHandleReference.getMemberReference());
                 break;

File: dexlib2/src/main/java/org/jf/dexlib2/writer/DexWriter.java
Patch:
@@ -588,8 +588,8 @@ private void writeMethodHandles(DexDataWriter writer) throws IOException {
                     memberIndex = fieldSection.getItemIndex(
                             methodHandleSection.getFieldReference(methodHandleReference));
                     break;
-                case MethodHandleType.INVOKE_INSTANCE:
-                case MethodHandleType.INVOKE_STATIC:
+                case MethodHandleType.INSTANCE_INVOKE:
+                case MethodHandleType.STATIC_INVOKE:
                     memberIndex = methodSection.getItemIndex(
                             methodHandleSection.getMethodReference(methodHandleReference));
                     break;

File: dexlib2/src/main/java/org/jf/dexlib2/writer/builder/BuilderMethodHandlePool.java
Patch:
@@ -68,8 +68,8 @@ public BuilderMethodHandleReference internMethodHandle(MethodHandleReference met
                 memberReference = dexBuilder.internFieldReference(
                         (FieldReference) methodHandleReference.getMemberReference());
                 break;
-            case MethodHandleType.INVOKE_INSTANCE:
-            case MethodHandleType.INVOKE_STATIC:
+            case MethodHandleType.INSTANCE_INVOKE:
+            case MethodHandleType.STATIC_INVOKE:
                 memberReference = dexBuilder.internMethodReference(
                         (MethodReference) methodHandleReference.getMemberReference());
                 break;

File: dexlib2/src/main/java/org/jf/dexlib2/writer/pool/MethodHandlePool.java
Patch:
@@ -56,8 +56,8 @@ public void intern(MethodHandleReference methodHandleReference) {
                 case MethodHandleType.STATIC_PUT:
                     dexPool.fieldSection.intern((FieldReference) methodHandleReference.getMemberReference());
                     break;
-                case MethodHandleType.INVOKE_INSTANCE:
-                case MethodHandleType.INVOKE_STATIC:
+                case MethodHandleType.INSTANCE_INVOKE:
+                case MethodHandleType.STATIC_INVOKE:
                     dexPool.methodSection.intern((MethodReference) methodHandleReference.getMemberReference());
                     break;
                 default:

File: dexlib2/src/test/java/org/jf/dexlib2/writer/CallSiteTest.java
Patch:
@@ -74,7 +74,7 @@ public void testPoolCallSite() throws IOException {
                                 new ImmutableMethodImplementation(10, ImmutableList.of(
                                         new ImmutableInstruction35c(Opcode.INVOKE_CUSTOM, 0, 0, 0, 0, 0, 0,
                                                 new ImmutableCallSiteReference("call_site_1",
-                                                        new ImmutableMethodHandleReference(MethodHandleType.INVOKE_STATIC,
+                                                        new ImmutableMethodHandleReference(MethodHandleType.STATIC_INVOKE,
                                                                 new ImmutableMethodReference("Lcls1", "loader",
                                                                         ImmutableList.of("Ljava/lang/invoke/Lookup;",
                                                                                 "Ljava/lang/String;",
@@ -96,7 +96,7 @@ public void testBuilderCallSite() throws IOException {
 
         BuilderCallSiteReference callSite = dexBuilder.internCallSite(new ImmutableCallSiteReference("call_site_1",
                 new ImmutableMethodHandleReference(
-                        MethodHandleType.INVOKE_STATIC,
+                        MethodHandleType.STATIC_INVOKE,
                         new ImmutableMethodReference("Lcls1", "loader", ImmutableList.of("Ljava/lang/invoke/Lookup;",
                                 "Ljava/lang/String;",
                                 "Ljava/lang/invoke/MethodType;"),

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/value/DexBackedMethodEncodedValue.java
Patch:
@@ -41,14 +41,14 @@
 
 public class DexBackedMethodEncodedValue extends BaseMethodEncodedValue {
     @Nonnull public final DexBackedDexFile dexFile;
-    private final int MethodIndex;
+    private final int methodIndex;
 
     public DexBackedMethodEncodedValue(@Nonnull DexReader reader, int valueArg) {
         this.dexFile = reader.dexBuf;
-        MethodIndex = reader.readSizedSmallUint(valueArg + 1);
+        methodIndex = reader.readSizedSmallUint(valueArg + 1);
     }
 
     @Nonnull @Override public MethodReference getValue() {
-        return new DexBackedMethodReference(dexFile, MethodIndex);
+        return new DexBackedMethodReference(dexFile, methodIndex);
     }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/iface/reference/MethodProtoReference.java
Patch:
@@ -69,9 +69,9 @@ public interface MethodProtoReference extends Reference, Comparable<MethodProtoR
     @Override int hashCode();
 
     /**
-     * Compares this MethodTypeReference to another MethodProtoReference for equality.
+     * Compares this MethodProtoReference to another MethodProtoReference for equality.
      *
-     * This MethodTypeReference is equal to another MethodProtoReference if all of it's "fields" are equal. That is, if
+     * This MethodProtoReference is equal to another MethodProtoReference if all of it's "fields" are equal. That is, if
      * the return values of getReturnType() and getParameterTypes() are all equal.
      *
      * Equality for getParameters() should be tested by comparing the string representation of each element. I.e.
@@ -83,7 +83,7 @@ public interface MethodProtoReference extends Reference, Comparable<MethodProtoR
     @Override boolean equals(@Nullable Object o);
 
     /**
-     * Compare this MethodTypeReference to another MethodProtoReference.
+     * Compare this MethodProtoReference to another MethodProtoReference.
      *
      * The comparison is based on the comparison of the return values of getReturnType() and getParameters(),
      * in that order. getParameters() should be compared using the semantics of

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/Format/InstructionMethodItem.java
Patch:
@@ -501,7 +501,7 @@ protected void writeCommentIfLikelyFloat(IndentingWriter writer, int val) throws
                 writer.write("Float.POSITIVE_INFINITY");
             else if (fval == Float.NEGATIVE_INFINITY)
                 writer.write("Float.NEGATIVE_INFINITY");
-            else if (fval == Float.NaN)
+            else if (Float.isNaN(fval))
                 writer.write("Float.NaN");
             else if (fval == Float.MAX_VALUE)
                 writer.write("Float.MAX_VALUE");
@@ -528,7 +528,7 @@ protected void writeCommentIfLikelyDouble(IndentingWriter writer, long val) thro
                 writer.write("Double.POSITIVE_INFINITY");
             else if (dval == Double.NEGATIVE_INFINITY)
                 writer.write("Double.NEGATIVE_INFINITY");
-            else if (dval == Double.NaN)
+            else if (Double.isNaN(dval))
                 writer.write("Double.NaN");
             else if (dval == Double.MAX_VALUE)
                 writer.write("Double.MAX_VALUE");

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/raw/DebugInfoItem.java
Patch:
@@ -52,8 +52,8 @@ public static SectionAnnotator makeAnnotator(@Nonnull DexAnnotator annotator, @N
             public void annotateItem(@Nonnull AnnotatedBytes out, int itemIndex, @Nullable String itemIdentity) {
                 DexReader reader = dexFile.readerAt(out.getCursor());
 
-                int lineStart = reader.readSmallUleb128();
-                out.annotateTo(reader.getOffset(), "line_start = %d", lineStart);
+                int lineStart = reader.readBigUleb128();
+                out.annotateTo(reader.getOffset(), "line_start = %d", lineStart & 0xFFFFFFFFL);
 
                 int parametersSize = reader.readSmallUleb128();
                 out.annotateTo(reader.getOffset(), "parameters_size = %d", parametersSize);

File: dexlib2/src/main/java/org/jf/dexlib2/writer/DexDataWriter.java
Patch:
@@ -127,7 +127,7 @@ public void writeUbyte(int value) throws IOException {
     }
 
     public static void writeUleb128(OutputStream out, int value) throws IOException {
-        while (value > 0x7f) {
+        while ((value & 0xffffffffL) > 0x7f) {
             out.write((value & 0x7f) | 0x80);
             value >>>= 7;
         }

File: smalidea/src/main/java/org/jf/smalidea/dexlib/instruction/SmalideaPackedSwitchPayload.java
Patch:
@@ -86,7 +86,7 @@ public SmalideaPackedSwitchPayload(@Nonnull SmaliInstruction instruction) {
                         return 0;
                     }
 
-                    return label.getOffset() - baseOffset;
+                    return (label.getOffset() - baseOffset) / 2;
                 }
             });
         }

File: smalidea/src/main/java/org/jf/smalidea/dexlib/instruction/SmalideaSparseSwitchPayload.java
Patch:
@@ -79,7 +79,7 @@ public SmalideaSparseSwitchPayload(@Nonnull SmaliInstruction instruction) {
                             return 0;
                         }
 
-                        return label.getOffset() - baseOffset;
+                        return (label.getOffset() - baseOffset) / 2;
                     }
                 };
             }

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/MethodDefinition.java
Patch:
@@ -432,7 +432,8 @@ public boolean writeTo(IndentingWriter writer) throws IOException {
                 });
             }
 
-            if (classDef.options.accessorComments && (instruction instanceof ReferenceInstruction)) {
+            if (classDef.options.accessorComments && classDef.options.syntheticAccessorResolver != null &&
+                    (instruction instanceof ReferenceInstruction)) {
                 Opcode opcode = instruction.getOpcode();
 
                 if (opcode.referenceType == ReferenceType.METHOD) {

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/ClassPathResolver.java
Patch:
@@ -232,7 +232,7 @@ private void loadEntry(@Nonnull File entryFile, boolean loadOatDependencies)
         List<String> entryNames = container.getDexEntryNames();
 
         if (entryNames.size() == 0) {
-            throw new NoDexException("%s contains no dex file");
+            throw new NoDexException("%s contains no dex file", entryFile);
         }
 
         loadedFiles.add(entryFile);

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/AnalyzedInstruction.java
Patch:
@@ -374,7 +374,8 @@ public boolean setsRegister(int registerNumber) {
             if (previousInstruction != null &&
                     previousInstruction.instruction.getOpcode() == Opcode.INSTANCE_OF &&
                     registerNumber == ((Instruction22c)previousInstruction.instruction).getRegisterB() &&
-                    MethodAnalyzer.canNarrowAfterInstanceOf(previousInstruction, this, methodAnalyzer.getClassPath())) {
+                    MethodAnalyzer.canPropogateTypeAfterInstanceOf(
+                            previousInstruction, this, methodAnalyzer.getClassPath())) {
                 return true;
             }
         }

File: dexlib2/src/main/java/org/jf/dexlib2/writer/MethodSection.java
Patch:
@@ -39,6 +39,7 @@
 public interface MethodSection<StringKey, TypeKey, ProtoRefKey extends MethodProtoReference,
         MethodRefKey extends MethodReference, MethodKey>
         extends IndexSection<MethodRefKey> {
+    @Nonnull MethodRefKey getMethodReference(@Nonnull MethodKey key);
     @Nonnull TypeKey getDefiningClass(@Nonnull MethodRefKey key);
     @Nonnull ProtoRefKey getPrototype(@Nonnull MethodRefKey key);
     @Nonnull ProtoRefKey getPrototype(@Nonnull MethodKey key);

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedMethodImplementation.java
Patch:
@@ -84,7 +84,7 @@ protected Instruction readNextItem(@Nonnull DexReader reader) {
                         // Does the instruction extend past the end of the method?
                         int offset = reader.getOffset();
                         if (offset > endOffset || offset < 0) {
-                            throw new ExceptionWithContext("The last instruction in the method is truncated");
+                            throw new ExceptionWithContext("The last instruction in method %s is truncated", method);
                         }
                         return instruction;
                     }

File: dexlib2/src/main/java/org/jf/dexlib2/writer/builder/BuilderAnnotationSet.java
Patch:
@@ -39,7 +39,7 @@
 import java.util.Iterator;
 import java.util.Set;
 
-class BuilderAnnotationSet extends AbstractSet<BuilderAnnotation> {
+public class BuilderAnnotationSet extends AbstractSet<BuilderAnnotation> {
     public static final BuilderAnnotationSet EMPTY =
             new BuilderAnnotationSet(ImmutableSet.<BuilderAnnotation>of());
 

File: dexlib2/src/main/java/org/jf/dexlib2/Opcode.java
Patch:
@@ -305,8 +305,8 @@ public enum Opcode
     SPARSE_SWITCH_PAYLOAD(0x200, "sparse-switch-payload", ReferenceType.NONE, Format.SparseSwitchPayload, 0),
     ARRAY_PAYLOAD(0x300, "array-payload", ReferenceType.NONE, Format.ArrayPayload, 0),
 
-    INVOKE_POLYMORPHIC(firstApi(0xfa, 26), "invoke-polymorphic", ReferenceType.METHOD, ReferenceType.METHOD_PROTO, Format.Format45cc, Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_RESULT),
-    INVOKE_POLYMORPHIC_RANGE(firstApi(0xfb, 26), "invoke-polymorphic/range", ReferenceType.METHOD, ReferenceType.METHOD_PROTO, Format.Format4rcc, Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_RESULT);
+    INVOKE_POLYMORPHIC(firstArtVersion(0xfa, 87), "invoke-polymorphic", ReferenceType.METHOD, ReferenceType.METHOD_PROTO, Format.Format45cc, Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_RESULT),
+    INVOKE_POLYMORPHIC_RANGE(firstArtVersion(0xfb, 87), "invoke-polymorphic/range", ReferenceType.METHOD, ReferenceType.METHOD_PROTO, Format.Format4rcc, Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_RESULT);
 
     //if the instruction can throw an exception
     public static final int CAN_THROW = 0x1;

File: dexlib2/src/main/java/org/jf/dexlib2/Opcodes.java
Patch:
@@ -92,9 +92,9 @@ private Opcodes(int api, int artVersion) {
 
         int version;
         if (isArt()) {
-            version = artVersion;
+            version = this.artVersion;
         } else {
-            version = api;
+            version = this.api;
         }
 
         for (Opcode opcode: Opcode.values()) {

File: baksmali/src/main/java/org/jf/baksmali/DisassembleCommand.java
Patch:
@@ -167,7 +167,7 @@ public void run() {
         }
 
         if (analysisArguments.classPathDirectories == null || analysisArguments.classPathDirectories.isEmpty()) {
-            analysisArguments.classPathDirectories = Lists.newArrayList(new File(input).getParent());
+            analysisArguments.classPathDirectories = Lists.newArrayList(inputFile.getAbsoluteFile().getParent());
         }
 
         if (!Baksmali.disassembleDexFile(dexFile, outputDirectoryFile, jobs, getOptions())) {

File: baksmali/src/main/java/org/jf/baksmali/ListDependenciesCommand.java
Patch:
@@ -99,7 +99,7 @@ public ListDependenciesCommand(@Nonnull List<JCommander> commandAncestors) {
         }
 
         try {
-            DexBackedOdexFile odexFile = DexBackedOdexFile.fromInputStream(Opcodes.forApi(15), inputStream);
+            DexBackedOdexFile odexFile = DexBackedOdexFile.fromInputStream(Opcodes.getDefault(), inputStream);
             for (String entry: odexFile.getDependencies()) {
                 System.out.println(entry);
             }

File: baksmali/src/main/java/org/jf/baksmali/ListDexCommand.java
Patch:
@@ -89,7 +89,7 @@ public ListDexCommand(@Nonnull List<JCommander> commandAncestors) {
         List<String> entries;
         try {
             MultiDexContainer<? extends DexBackedDexFile> container =
-                    DexFileFactory.loadDexContainer(file, Opcodes.forApi(15));
+                    DexFileFactory.loadDexContainer(file, Opcodes.getDefault());
             entries = container.getDexEntryNames();
         } catch (IOException ex) {
             throw new RuntimeException(ex);

File: baksmali/src/test/java/org/jf/baksmali/AnalysisTest.java
Patch:
@@ -36,6 +36,7 @@
 import junit.framework.Assert;
 import org.jf.baksmali.Adaptors.ClassDefinition;
 import org.jf.dexlib2.DexFileFactory;
+import org.jf.dexlib2.Opcodes;
 import org.jf.dexlib2.analysis.ClassPath;
 import org.jf.dexlib2.iface.ClassDef;
 import org.jf.dexlib2.iface.DexFile;
@@ -85,7 +86,7 @@ public void LocalTest() throws IOException, URISyntaxException {
     public void runTest(String test, boolean registerInfo) throws IOException, URISyntaxException {
         String dexFilePath = String.format("%s%sclasses.dex", test, File.separatorChar);
 
-        DexFile dexFile = DexFileFactory.loadDexFile(findResource(dexFilePath));
+        DexFile dexFile = DexFileFactory.loadDexFile(findResource(dexFilePath), Opcodes.getDefault());
 
         BaksmaliOptions options = new BaksmaliOptions();
         if (registerInfo) {

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/ClassPath.java
Patch:
@@ -104,7 +104,7 @@ private void loadPrimitiveType(String type) {
 
     private static ClassProvider getBasicClasses() {
         // fallbacks for some special classes that we assume are present
-        return new DexClassProvider(new ImmutableDexFile(Opcodes.forApi(19), ImmutableSet.of(
+        return new DexClassProvider(new ImmutableDexFile(Opcodes.getDefault(), ImmutableSet.of(
                 new ReflectionClassDef(Class.class),
                 new ReflectionClassDef(Cloneable.class),
                 new ReflectionClassDef(Object.class),

File: dexlib2/src/test/java/org/jf/dexlib2/AccessorTest.java
Patch:
@@ -79,7 +79,7 @@ public class AccessorTest {
     public void testAccessors() throws IOException {
         URL url = AccessorTest.class.getClassLoader().getResource("accessorTest.dex");
         Assert.assertNotNull(url);
-        DexFile f = DexFileFactory.loadDexFile(url.getFile());
+        DexFile f = DexFileFactory.loadDexFile(url.getFile(), Opcodes.getDefault());
 
         SyntheticAccessorResolver sar = new SyntheticAccessorResolver(f.getOpcodes(), f.getClasses());
 

File: dexlib2/src/test/java/org/jf/dexlib2/analysis/CommonSuperclassTest.java
Patch:
@@ -54,7 +54,7 @@ public class CommonSuperclassTest {
     private final ClassPath classPath;
 
     public CommonSuperclassTest() throws IOException {
-        classPath = new ClassPath(new DexClassProvider(new ImmutableDexFile(Opcodes.forApi(19),
+        classPath = new ClassPath(new DexClassProvider(new ImmutableDexFile(Opcodes.getDefault(),
                 ImmutableSet.of(
                         TestUtils.makeClassDef("Ljava/lang/Object;", null),
                         TestUtils.makeClassDef("Ltest/one;", "Ljava/lang/Object;"),

File: dexlib2/src/test/java/org/jf/dexlib2/analysis/CustomMethodInlineTableTest.java
Patch:
@@ -68,7 +68,7 @@ public void testCustomMethodInlineTable_Virtual() throws IOException {
         ClassDef classDef = new ImmutableClassDef("Lblah;", AccessFlags.PUBLIC.getValue(), "Ljava/lang/Object;", null,
                 null, null, null, null, null, ImmutableList.of(method));
 
-        DexFile dexFile = new ImmutableDexFile(Opcodes.forApi(19), ImmutableList.of(classDef));
+        DexFile dexFile = new ImmutableDexFile(Opcodes.getDefault(), ImmutableList.of(classDef));
 
         ClassPathResolver resolver = new ClassPathResolver(ImmutableList.<String>of(),
                 ImmutableList.<String>of(), ImmutableList.<String>of(), dexFile);
@@ -97,7 +97,7 @@ public void testCustomMethodInlineTable_Static() throws IOException {
         ClassDef classDef = new ImmutableClassDef("Lblah;", AccessFlags.PUBLIC.getValue(), "Ljava/lang/Object;", null,
                 null, null, null, null, ImmutableList.of(method), null);
 
-        DexFile dexFile = new ImmutableDexFile(Opcodes.forApi(19), ImmutableList.of(classDef));
+        DexFile dexFile = new ImmutableDexFile(Opcodes.getDefault(), ImmutableList.of(classDef));
 
         ClassPathResolver resolver = new ClassPathResolver(ImmutableList.<String>of(),
                 ImmutableList.<String>of(), ImmutableList.<String>of(), dexFile);
@@ -126,7 +126,7 @@ public void testCustomMethodInlineTable_Direct() throws IOException {
         ClassDef classDef = new ImmutableClassDef("Lblah;", AccessFlags.PUBLIC.getValue(), "Ljava/lang/Object;", null,
                 null, null, null, null, ImmutableList.of(method), null);
 
-        DexFile dexFile = new ImmutableDexFile(Opcodes.forApi(19), ImmutableList.of(classDef));
+        DexFile dexFile = new ImmutableDexFile(Opcodes.getDefault(), ImmutableList.of(classDef));
 
         ClassPathResolver resolver = new ClassPathResolver(ImmutableList.<String>of(),
                 ImmutableList.<String>of(), ImmutableList.<String>of(), dexFile);

File: dexlib2/src/test/java/org/jf/dexlib2/analysis/MethodAnalyzerTest.java
Patch:
@@ -76,7 +76,7 @@ public void testInstanceOfNarrowingEqz() throws IOException {
                 AccessFlags.PUBLIC.getValue(), null, methodImplementation);
         ClassDef classDef = new ImmutableClassDef("Lmain;", AccessFlags.PUBLIC.getValue(), "Ljava/lang/Object;", null,
                 null, null, null, Collections.singletonList(method));
-        DexFile dexFile = new ImmutableDexFile(Opcodes.forApi(15), Collections.singletonList(classDef));
+        DexFile dexFile = new ImmutableDexFile(Opcodes.getDefault(), Collections.singletonList(classDef));
 
         ClassPath classPath = new ClassPath(new DexClassProvider(dexFile));
         MethodAnalyzer methodAnalyzer = new MethodAnalyzer(classPath, method, null, false);
@@ -107,7 +107,7 @@ public void testInstanceOfNarrowingNez() throws IOException {
                 AccessFlags.PUBLIC.getValue(), null, methodImplementation);
         ClassDef classDef = new ImmutableClassDef("Lmain;", AccessFlags.PUBLIC.getValue(), "Ljava/lang/Object;", null,
                 null, null, null, Collections.singletonList(method));
-        DexFile dexFile = new ImmutableDexFile(Opcodes.forApi(15), Collections.singletonList(classDef));
+        DexFile dexFile = new ImmutableDexFile(Opcodes.getDefault(), Collections.singletonList(classDef));
 
         ClassPath classPath = new ClassPath(new DexClassProvider(dexFile));
         MethodAnalyzer methodAnalyzer = new MethodAnalyzer(classPath, method, null, false);
@@ -139,7 +139,7 @@ public void testInstanceOfNarrowingAfterMove() throws IOException {
                 AccessFlags.PUBLIC.getValue(), null, methodImplementation);
         ClassDef classDef = new ImmutableClassDef("Lmain;", AccessFlags.PUBLIC.getValue(), "Ljava/lang/Object;", null,
                 null, null, null, Collections.singletonList(method));
-        DexFile dexFile = new ImmutableDexFile(Opcodes.forApi(15), Collections.singletonList(classDef));
+        DexFile dexFile = new ImmutableDexFile(Opcodes.getDefault(), Collections.singletonList(classDef));
 
         ClassPath classPath = new ClassPath(new DexClassProvider(dexFile));
         MethodAnalyzer methodAnalyzer = new MethodAnalyzer(classPath, method, null, false);

File: dexlib2/src/test/java/org/jf/dexlib2/analysis/util/SuperclassChainTest.java
Patch:
@@ -57,7 +57,7 @@ public void testGetSuperclassChain() throws IOException {
         ImmutableSet<ClassDef> classes = ImmutableSet.<ClassDef>of(
                 objectClassDef, oneClassDef, twoClassDef, threeClassDef);
 
-        ClassPath classPath = new ClassPath(new DexClassProvider(new ImmutableDexFile(Opcodes.forApi(19), classes)));
+        ClassPath classPath = new ClassPath(new DexClassProvider(new ImmutableDexFile(Opcodes.getDefault(), classes)));
 
         TypeProto objectClassProto = classPath.getClass("Ljava/lang/Object;");
         TypeProto oneClassProto = classPath.getClass("Ltest/one;");
@@ -88,7 +88,7 @@ public void testGetSuperclassChain_Unresolved() throws IOException {
         ClassDef twoClassDef = TestUtils.makeClassDef("Ltest/two;", "Ltest/one;");
         ClassDef threeClassDef = TestUtils.makeClassDef("Ltest/three;", "Ltest/two;");
         ImmutableSet<ClassDef> classes = ImmutableSet.<ClassDef>of(twoClassDef, threeClassDef);
-        ClassPath classPath = new ClassPath(new DexClassProvider(new ImmutableDexFile(Opcodes.forApi(19), classes)));
+        ClassPath classPath = new ClassPath(new DexClassProvider(new ImmutableDexFile(Opcodes.getDefault(), classes)));
 
         TypeProto unknownClassProto = classPath.getUnknownClass();
         TypeProto oneClassProto = classPath.getClass("Ltest/one;");

File: smalidea/src/main/java/org/jf/smalidea/psi/impl/SmaliInstruction.java
Patch:
@@ -76,7 +76,7 @@ public SmaliInstruction() {
             assert instructionNode != null;
 
             // TODO: put a project level Opcodes instance with the appropriate api level somewhere
-            opcode = Opcodes.forApi(15).getOpcodeByName(instructionNode.getText());
+            opcode = Opcodes.getDefault().getOpcodeByName(instructionNode.getText());
             if (opcode == null) {
                 if (instructionNode.getText().equals(".packed-switch")) {
                     return Opcode.PACKED_SWITCH_PAYLOAD;

File: baksmali/src/main/java/org/jf/baksmali/DeodexCommand.java
Patch:
@@ -39,7 +39,6 @@
 import org.jf.dexlib2.analysis.CustomInlineMethodResolver;
 import org.jf.dexlib2.analysis.InlineMethodResolver;
 import org.jf.dexlib2.dexbacked.DexBackedOdexFile;
-import org.jf.dexlib2.iface.DexFile;
 import org.jf.util.jcommander.ExtendedParameter;
 import org.jf.util.jcommander.ExtendedParameters;
 
@@ -68,8 +67,8 @@ public DeodexCommand(@Nonnull List<JCommander> commandAncestors) {
         super(commandAncestors);
     }
 
-    @Override protected BaksmaliOptions getOptions(DexFile dexFile) {
-        BaksmaliOptions options = super.getOptions(dexFile);
+    @Override protected BaksmaliOptions getOptions() {
+        BaksmaliOptions options = super.getOptions();
 
         options.deodex = true;
 

File: baksmali/src/main/java/org/jf/baksmali/DumpCommand.java
Patch:
@@ -77,7 +77,7 @@ public void run() {
         }
 
         String input = inputList.get(0);
-        DexBackedDexFile dexFile = loadDexFile(input, 15);
+        loadDexFile(input, 15);
 
         try {
             dump(dexFile, System.out, apiLevel);

File: baksmali/src/main/java/org/jf/baksmali/ListClassesCommand.java
Patch:
@@ -34,7 +34,6 @@
 import com.beust.jcommander.JCommander;
 import com.beust.jcommander.Parameter;
 import com.beust.jcommander.Parameters;
-import org.jf.dexlib2.dexbacked.DexBackedDexFile;
 import org.jf.dexlib2.iface.reference.Reference;
 import org.jf.dexlib2.util.ReferenceUtil;
 import org.jf.util.jcommander.ExtendedParameters;
@@ -69,7 +68,7 @@ public ListClassesCommand(@Nonnull List<JCommander> commandAncestors) {
         }
 
         String input = inputList.get(0);
-        DexBackedDexFile dexFile = loadDexFile(input, 15);
+        loadDexFile(input, 15);
 
         for (Reference reference: dexFile.getClasses()) {
             System.out.println(ReferenceUtil.getReferenceString(reference));

File: baksmali/src/main/java/org/jf/baksmali/ListReferencesCommand.java
Patch:
@@ -33,7 +33,6 @@
 
 import com.beust.jcommander.JCommander;
 import com.beust.jcommander.Parameter;
-import org.jf.dexlib2.dexbacked.DexBackedDexFile;
 import org.jf.dexlib2.iface.reference.Reference;
 import org.jf.dexlib2.util.ReferenceUtil;
 
@@ -66,7 +65,7 @@ public ListReferencesCommand(@Nonnull List<JCommander> commandAncestors, int ref
         }
 
         String input = inputList.get(0);
-        DexBackedDexFile dexFile = loadDexFile(input, 15);
+        loadDexFile(input, 15);
 
         for (Reference reference: dexFile.getReferences(referenceType)) {
             System.out.println(ReferenceUtil.getReferenceString(reference));

File: baksmali/src/main/java/org/jf/baksmali/DisassembleCommand.java
Patch:
@@ -172,7 +172,6 @@ public void run() {
          }
     }
 
-
     protected boolean needsClassPath() {
         return !registerInfoTypes.isEmpty() || normalizeVirtualMethods;
     }

File: baksmali/src/main/java/org/jf/baksmali/ListClassPathCommand.java
Patch:
@@ -103,6 +103,7 @@ public ListClassPathCommand(@Nonnull List<JCommander> commandAncestors) {
             for (String entry: odexFile.getDependencies()) {
                 System.out.println(entry);
             }
+            return;
         } catch (IOException ex) {
             throw new RuntimeException(ex);
         } catch (DexBackedOdexFile.NotAnOdexFile ex) {

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/RegisterType.java
Patch:
@@ -235,7 +235,7 @@ public static RegisterType getRegisterType(@Nonnull ClassPath classPath, @Nonnul
             case '[':
                 return getRegisterType(REFERENCE, classPath.getClass(type));
             default:
-                throw new ExceptionWithContext("Invalid type: " + type);
+                throw new AnalysisException("Invalid type: " + type);
         }
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/AnalyzedInstruction.java
Patch:
@@ -368,7 +368,8 @@ public boolean setsRegister(int registerNumber) {
             return false;
         }
 
-        if (instruction.getOpcode() == Opcode.IF_EQZ || instruction.getOpcode() == Opcode.IF_NEZ) {
+        if (getPredecessorCount() == 1 && (instruction.getOpcode() == Opcode.IF_EQZ ||
+                instruction.getOpcode() == Opcode.IF_NEZ)) {
             AnalyzedInstruction previousInstruction = getPreviousInstruction();
             if (previousInstruction != null &&
                     previousInstruction.instruction.getOpcode() == Opcode.INSTANCE_OF &&

File: dexlib2/src/main/java/org/jf/dexlib2/DexFileFactory.java
Patch:
@@ -501,7 +501,7 @@ private static DexBackedDexFile loadDexFromZip(@Nonnull ZipFile zipFile, @Nonnul
         InputStream stream;
         stream = zipFile.getInputStream(zipEntry);
         try {
-            return DexBackedDexFile.fromInputStream(opcodes, stream);
+            return DexBackedDexFile.fromInputStream(opcodes, new BufferedInputStream(stream));
         } finally {
             if (stream != null) {
                 stream.close();

File: baksmali/src/main/java/org/jf/baksmali/DumpCommand.java
Patch:
@@ -118,7 +118,7 @@ public static void dump(@Nonnull DexBackedDexFile dexFile, @Nonnull OutputStream
             consoleWidth = 120;
         }
 
-        RawDexFile rawDexFile = new RawDexFile(Opcodes.forApi(apiLevel), dexFile);
+        RawDexFile rawDexFile = new RawDexFile(dexFile.getOpcodes(), dexFile);
         DexAnnotator annotator = new DexAnnotator(rawDexFile, consoleWidth);
         annotator.writeAnnotations(writer);
     }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedDexFile.java
Patch:
@@ -93,7 +93,7 @@ private DexBackedDexFile(@Nonnull Opcodes opcodes, @Nonnull byte[] buf, int offs
     }
 
     public DexBackedDexFile(@Nonnull Opcodes opcodes, @Nonnull BaseDexBuffer buf) {
-        this(opcodes, buf.buf);
+        this(opcodes, buf.buf, buf.baseOffset);
     }
 
     public DexBackedDexFile(@Nonnull Opcodes opcodes, @Nonnull byte[] buf, int offset) {

File: dexlib2/src/main/java/org/jf/dexlib2/Format.java
Patch:
@@ -63,6 +63,8 @@ public enum Format {
     Format3rc(6),
     Format3rmi(6),
     Format3rms(6),
+    Format45cc(8),
+    Format4rcc(8),
     Format51l(10),
     ArrayPayload(-1, true),
     PackedSwitchPayload(-1, true),

File: dexlib2/src/main/java/org/jf/dexlib2/builder/instruction/BuilderInstruction35c.java
Patch:
@@ -60,7 +60,7 @@ public BuilderInstruction35c(@Nonnull Opcode opcode,
                                  int registerG,
                                  @Nonnull Reference reference) {
         super(opcode);
-        this.registerCount = Preconditions.check35cRegisterCount(registerCount);
+        this.registerCount = Preconditions.check35cAnd45ccRegisterCount(registerCount);
         this.registerC = (registerCount>0) ? Preconditions.checkNibbleRegister(registerC) : 0;
         this.registerD = (registerCount>1) ? Preconditions.checkNibbleRegister(registerD) : 0;
         this.registerE = (registerCount>2) ? Preconditions.checkNibbleRegister(registerE) : 0;

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/reference/DexBackedReference.java
Patch:
@@ -49,6 +49,8 @@ public static Reference makeReference(@Nonnull DexBackedDexFile dexFile, int ref
                 return new DexBackedMethodReference(dexFile, referenceIndex);
             case ReferenceType.FIELD:
                 return new DexBackedFieldReference(dexFile, referenceIndex);
+            case ReferenceType.METHOD_PROTO:
+                return new DexBackedMethodProtoReference(dexFile, referenceIndex);
             default:
                 throw new ExceptionWithContext("Invalid reference type: %d", referenceType);
         }

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction35c.java
Patch:
@@ -61,7 +61,7 @@ public ImmutableInstruction35c(@Nonnull Opcode opcode,
                                    int registerG,
                                    @Nonnull Reference reference) {
         super(opcode);
-        this.registerCount = Preconditions.check35cRegisterCount(registerCount);
+        this.registerCount = Preconditions.check35cAnd45ccRegisterCount(registerCount);
         this.registerC = (registerCount>0) ? Preconditions.checkNibbleRegister(registerC) : 0;
         this.registerD = (registerCount>1) ? Preconditions.checkNibbleRegister(registerD) : 0;
         this.registerE = (registerCount>2) ? Preconditions.checkNibbleRegister(registerE) : 0;

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction35mi.java
Patch:
@@ -58,7 +58,7 @@ public ImmutableInstruction35mi(@Nonnull Opcode opcode,
                                     int registerG,
                                     int inlineIndex) {
         super(opcode);
-        this.registerCount = Preconditions.check35cRegisterCount(registerCount);
+        this.registerCount = Preconditions.check35cAnd45ccRegisterCount(registerCount);
         this.registerC = (registerCount>0) ? Preconditions.checkNibbleRegister(registerC) : 0;
         this.registerD = (registerCount>1) ? Preconditions.checkNibbleRegister(registerD) : 0;
         this.registerE = (registerCount>2) ? Preconditions.checkNibbleRegister(registerE) : 0;

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction35ms.java
Patch:
@@ -58,7 +58,7 @@ public ImmutableInstruction35ms(@Nonnull Opcode opcode,
                                     int registerG,
                                     int vtableIndex) {
         super(opcode);
-        this.registerCount = Preconditions.check35cRegisterCount(registerCount);
+        this.registerCount = Preconditions.check35cAnd45ccRegisterCount(registerCount);
         this.registerC = (registerCount>0) ? Preconditions.checkNibbleRegister(registerC) : 0;
         this.registerD = (registerCount>1) ? Preconditions.checkNibbleRegister(registerD) : 0;
         this.registerE = (registerCount>2) ? Preconditions.checkNibbleRegister(registerE) : 0;

File: dexlib2/src/main/java/org/jf/dexlib2/util/Preconditions.java
Patch:
@@ -125,7 +125,7 @@ public static int checkShortCodeOffset(int offset) {
         return offset;
     }
 
-    public static int check35cRegisterCount(int registerCount) {
+    public static int check35cAnd45ccRegisterCount(int registerCount) {
         if (registerCount < 0 || registerCount > 5) {
             throw new IllegalArgumentException(
                     String.format("Invalid register count: %d. Must be between 0 and 5, inclusive.", registerCount));

File: dexlib2/src/main/java/org/jf/dexlib2/writer/builder/BuilderMethodReference.java
Patch:
@@ -39,12 +39,12 @@
 public class BuilderMethodReference extends BaseMethodReference implements BuilderReference {
     @Nonnull final BuilderTypeReference definingClass;
     @Nonnull final BuilderStringReference name;
-    @Nonnull final BuilderProtoReference proto;
+    @Nonnull final BuilderMethodProtoReference proto;
     int index = DexWriter.NO_INDEX;
 
     BuilderMethodReference(@Nonnull BuilderTypeReference definingClass,
                            @Nonnull BuilderStringReference name,
-                           @Nonnull BuilderProtoReference proto) {
+                           @Nonnull BuilderMethodProtoReference proto) {
         this.definingClass = definingClass;
         this.name = name;
         this.proto = proto;

File: dexlib2/src/main/java/org/jf/dexlib2/writer/pool/DexPool.java
Patch:
@@ -42,7 +42,6 @@
 import org.jf.dexlib2.writer.DexWriter;
 import org.jf.dexlib2.writer.io.DexDataStore;
 import org.jf.dexlib2.writer.io.FileDataStore;
-import org.jf.dexlib2.writer.pool.ProtoPool.Key;
 import org.jf.util.ExceptionWithContext;
 
 import javax.annotation.Nonnull;
@@ -51,8 +50,8 @@
 import java.util.Collection;
 import java.util.Set;
 
-public class DexPool extends DexWriter<CharSequence, StringReference, CharSequence, TypeReference, Key,
-        FieldReference, MethodReference, PoolClassDef,
+public class DexPool extends DexWriter<CharSequence, StringReference, CharSequence, TypeReference,
+        MethodProtoReference, FieldReference, MethodReference, PoolClassDef,
         Annotation, Set<? extends Annotation>,
         TypeListPool.Key<? extends Collection<? extends CharSequence>>, Field, PoolMethod,
         EncodedValue, AnnotationElement> {

File: baksmali/src/main/java/org/jf/baksmali/DisassembleCommand.java
Patch:
@@ -209,8 +209,9 @@ public void run() {
         try {
             dexFile = DexFileFactory.loadDexFile(dexFileFile, dexFileEntry, apiLevel, experimentalOpcodes);
         } catch (DexFileFactory.MultipleDexFilesException ex) {
-            System.err.println(String.format("%s contains multiple dex files. You must specify which one to " +
-                    "disassemble with the -e option", dexFileFile.getName()));
+            System.err.println(String.format("%s is an oat file that contains multiple dex files. You must specify " +
+                    "which one to load. E.g. To load the \"classes2.dex\" entry from blah.apk, you should use " +
+                    "\"blah.apk:classes2.dex\"", dexFileFile));
             System.err.println("Valid entries include:");
 
             for (OatFile.OatDexFile oatDexFile : ex.oatFile.getDexFiles()) {

File: baksmali/src/main/java/org/jf/baksmali/DumpCommand.java
Patch:
@@ -107,8 +107,9 @@ public void run() {
         try {
             dexFile = DexFileFactory.loadDexFile(dexFileFile, dexFileEntry, apiLevel, experimentalOpcodes);
         } catch (DexFileFactory.MultipleDexFilesException ex) {
-            System.err.println(String.format("%s contains multiple dex files. You must specify which one to " +
-                    "disassemble with the -e option", dexFileFile.getName()));
+            System.err.println(String.format("%s is an oat file that contains multiple dex files. You must specify " +
+                    "which one to load. E.g. To load the \"classes2.dex\" entry from blah.apk, you should use " +
+                    "\"blah.apk:classes2.dex\"", dexFileFile));
             System.err.println("Valid entries include:");
 
             for (OatFile.OatDexFile oatDexFile: ex.oatFile.getDexFiles()) {

File: dexlib2/src/main/java/org/jf/dexlib2/writer/DexWriter.java
Patch:
@@ -1221,8 +1221,8 @@ private void writeMapItem(@Nonnull DexDataWriter writer, int type, int size, int
     }
 
     private void writeHeader(@Nonnull DexDataWriter writer, int dataOffset, int fileSize) throws IOException {
-        // always write the 035 version, there's no reason to use the 036 version for now
-        writer.write(HeaderItem.MAGIC_VALUES[0]);
+        // Write the appropriate header.
+        writer.write(HeaderItem.getMagicForApi(opcodes.api));
 
         // checksum placeholder
         writer.writeInt(0);

File: baksmali/src/main/java/org/jf/baksmali/baksmaliOptions.java
Patch:
@@ -81,7 +81,7 @@ public class baksmaliOptions {
     public InlineMethodResolver inlineResolver = null;
     public int registerInfo = 0;
     public ClassPath classPath = null;
-    public int jobs = -1;
+    public int jobs = Runtime.getRuntime().availableProcessors();
 
     public SyntheticAccessorResolver syntheticAccessorResolver = null;
 

File: smalidea/src/main/java/org/jf/smalidea/debugging/SmaliPositionManager.java
Patch:
@@ -149,7 +149,7 @@ public ClassPrepareRequest createPrepareRequest(@NotNull final ClassPrepareReque
         Computable<Boolean> isSmaliFile = new Computable<Boolean>() {
             @Override
             public Boolean compute() {
-                return position.getElementAt().getContainingFile() instanceof SmaliFile;
+                return position.getFile() instanceof SmaliFile;
             }
         };
 

File: smalidea/src/test/java/org/jf/smalidea/SmaliPositionManagerTest.java
Patch:
@@ -60,7 +60,7 @@
 
 public class SmaliPositionManagerTest extends LightCodeInsightFixtureTestCase {
     private static final String testClass =
-            ".class public Lmy/pkg/blah; .super Ljava/lang/Object;\n" +
+            "\n\n.class public Lmy/pkg/blah; .super Ljava/lang/Object;\n" +
                     ".method public getRandomParentType(I)I\n" +
                     "    .registers 4\n" +
                     "    .param p1, \"edge\"    # I\n" +

File: smalidea/src/main/java/org/jf/smalidea/errorReporting/GithubFeedbackTask.java
Patch:
@@ -81,7 +81,7 @@ private static String getToken() {
     }
 
     public static String sendFeedback(Map<String, String> environmentDetails) throws IOException {
-        String url = "https://api.github.com/repos/JesusFreke/smali/issues";
+        String url = "https://api.github.com/repos/JesusFreke/smalidea-issues/issues";
         String userAgent = "smalidea plugin";
 
         IdeaPluginDescriptorImpl pluginDescriptor =

File: smalidea/src/main/java/org/jf/smalidea/debugging/SmaliCodeFragmentFactory.java
Patch:
@@ -246,7 +246,7 @@ private PsiElement wrapContext(final Project project, final PsiElement originalC
             @Override
             public void visitLocalVariable(final PsiLocalVariable variable) {
                 final String name = variable.getName();
-                if (registerMap.containsKey(name)) {
+                if (name != null && registerMap.containsKey(name)) {
                     int registerNumber = Integer.parseInt(name.substring(1));
                     if (name.charAt(0) == 'p') {
                         registerNumber += ApplicationManager.getApplication().runReadAction(new Computable<Integer>() {

File: smalidea/src/main/java/org/jf/smalidea/psi/impl/SmaliMethod.java
Patch:
@@ -53,6 +53,7 @@
 import org.jf.dexlib2.analysis.ClassPath;
 import org.jf.dexlib2.analysis.MethodAnalyzer;
 import org.jf.smalidea.dexlib.SmalideaMethod;
+import org.jf.smalidea.dexlib.analysis.SmalideaClassProvider;
 import org.jf.smalidea.psi.SmaliElementTypes;
 import org.jf.smalidea.psi.iface.SmaliModifierListOwner;
 import org.jf.smalidea.psi.stub.SmaliMethodStub;
@@ -316,7 +317,8 @@ public MethodAnalyzer getMethodAnalyzer() {
             if (!PsiTreeUtil.hasErrorElements(this)) {
                 ClassPath classPath;
                 try {
-                    classPath = new ClassPath();
+                    classPath = new ClassPath(
+                            new SmalideaClassProvider(getProject(), getContainingFile().getVirtualFile()));
                 } catch (IOException ex) {
                     throw new RuntimeException(ex);
                 }

File: smali/src/main/java/org/jf/smali/main.java
Patch:
@@ -327,7 +327,7 @@ private static boolean assembleSmaliFile(File smaliFile, DexBuilder dexBuilder,
 
         LexerErrorInterface lexer;
 
-        FileInputStream fis = new FileInputStream(smaliFile.getAbsolutePath());
+        FileInputStream fis = new FileInputStream(smaliFile);
         InputStreamReader reader = new InputStreamReader(fis, "UTF-8");
 
         lexer = new smaliFlexLexer(reader);

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/AnalyzedInstruction.java
Patch:
@@ -244,7 +244,7 @@ protected RegisterType getMergedPreRegisterTypeFromPredecessors(int registerNumb
      * Sets the "post-instruction" register type as indicated.
      * @param registerNumber Which register to set
      * @param registerType The "post-instruction" register type
-     * @returns true if the given register type is different than the existing post-instruction register type
+     * @return true if the given register type is different than the existing post-instruction register type
      */
     protected boolean setPostRegisterType(int registerNumber, RegisterType registerType) {
         assert registerNumber >= 0 && registerNumber < postRegisterMap.length;

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/Format/InstructionMethodItem.java
Patch:
@@ -76,8 +76,7 @@ private boolean isAllowedOdex(@Nonnull Opcode opcode) {
             return false;
         }
 
-        return opcode.isOdexedInstanceVolatile() || opcode.isOdexedStaticVolatile() ||
-            opcode == Opcode.THROW_VERIFICATION_ERROR;
+        return opcode.isVolatileFieldAccessor() || opcode == Opcode.THROW_VERIFICATION_ERROR;
     }
 
     @Override

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/MethodAnalyzer.java
Patch:
@@ -1841,7 +1841,7 @@ private boolean analyzePutGetVolatile(@Nonnull AnalyzedInstruction analyzedInstr
 
         Instruction deodexedInstruction;
 
-        if (originalOpcode.isOdexedStaticVolatile()) {
+        if (originalOpcode.isStaticFieldAccessor()) {
             OneRegisterInstruction instruction = (OneRegisterInstruction)analyzedInstruction.instruction;
             deodexedInstruction = new ImmutableInstruction21c(opcode, instruction.getRegisterA(), field);
         } else {

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/MethodDefinition.java
Patch:
@@ -320,7 +320,7 @@ private static void writeParameters(IndentingWriter writer, Method method,
             String parameterType = parameter.getType();
             String parameterName = parameter.getName();
             Collection<? extends Annotation> annotations = parameter.getAnnotations();
-            if (parameterName != null || annotations.size() != 0) {
+            if ((options.outputDebugInfo && parameterName != null) || annotations.size() != 0) {
                 writer.write(".param p");
                 writer.printSignedIntAsDec(registerNumber);
 

File: baksmali/src/test/java/org/jf/baksmali/DisassemblyTest.java
Patch:
@@ -79,7 +79,7 @@ protected void runTest(@Nonnull String testName, @Nonnull baksmaliOptions option
         try {
             // Load file from resources as a stream
             String inputFilename = getInputFilename(testName);
-            byte[] inputBytes = BaksmaliTestUtils.readResourceBytesFully(getInputFilename(testName));
+            byte[] inputBytes = BaksmaliTestUtils.readResourceBytesFully(inputFilename);
 
             DexBackedDexFile inputDex = new DexBackedDexFile(Opcodes.forApi(options.apiLevel), inputBytes);
             Assert.assertEquals(1, inputDex.getClassCount());

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/ClassDefinition.java
Patch:
@@ -146,8 +146,7 @@ private void writeSourceFile(IndentingWriter writer) throws IOException {
     }
 
     private void writeInterfaces(IndentingWriter writer) throws IOException {
-        List<String> interfaces = Lists.newArrayList(classDef.getInterfaces());
-        Collections.sort(interfaces);
+        List<String> interfaces = classDef.getInterfaces();
 
         if (interfaces.size() != 0) {
             writer.write('\n');

File: dexlib2/src/main/java/org/jf/dexlib2/rewriter/ClassDefRewriter.java
Patch:
@@ -41,6 +41,7 @@
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Set;
 
 public class ClassDefRewriter implements Rewriter<ClassDef> {
@@ -73,8 +74,8 @@ public RewrittenClassDef(@Nonnull ClassDef classdef) {
             return RewriterUtils.rewriteNullable(rewriters.getTypeRewriter(), classDef.getSuperclass());
         }
 
-        @Override @Nonnull public Set<String> getInterfaces() {
-            return RewriterUtils.rewriteSet(rewriters.getTypeRewriter(), classDef.getInterfaces());
+        @Override @Nonnull public List<String> getInterfaces() {
+            return RewriterUtils.rewriteList(rewriters.getTypeRewriter(), classDef.getInterfaces());
         }
 
         @Override @Nullable public String getSourceFile() {

File: dexlib2/src/main/java/org/jf/dexlib2/writer/ClassSection.java
Patch:
@@ -53,7 +53,7 @@ public interface ClassSection<StringKey extends CharSequence, TypeKey extends Ch
     @Nonnull TypeKey getType(@Nonnull ClassKey key);
     int getAccessFlags(@Nonnull ClassKey key);
     @Nullable TypeKey getSuperclass(@Nonnull ClassKey key);
-    @Nullable TypeListKey getSortedInterfaces(@Nonnull ClassKey key);
+    @Nullable TypeListKey getInterfaces(@Nonnull ClassKey key);
     @Nullable StringKey getSourceFile(@Nonnull ClassKey key);
     @Nullable Collection<? extends EncodedValue> getStaticInitializers(@Nonnull ClassKey key);
 

File: dexlib2/src/main/java/org/jf/dexlib2/writer/DexWriter.java
Patch:
@@ -433,7 +433,7 @@ private int writeClass(@Nonnull DexDataWriter indexWriter, @Nonnull DexDataWrite
         nextIndex = writeClass(indexWriter, offsetWriter, nextIndex, superEntry);
 
         // then, try to write interfaces
-        for (TypeKey interfaceTypeKey: typeListSection.getTypes(classSection.getSortedInterfaces(key))) {
+        for (TypeKey interfaceTypeKey: typeListSection.getTypes(classSection.getInterfaces(key))) {
             Map.Entry<? extends ClassKey, Integer> interfaceEntry = classSection.getClassEntryByType(interfaceTypeKey);
             nextIndex = writeClass(indexWriter, offsetWriter, nextIndex, interfaceEntry);
         }
@@ -446,7 +446,7 @@ private int writeClass(@Nonnull DexDataWriter indexWriter, @Nonnull DexDataWrite
         indexWriter.writeInt(typeSection.getItemIndex(classSection.getType(key)));
         indexWriter.writeInt(classSection.getAccessFlags(key));
         indexWriter.writeInt(typeSection.getNullableItemIndex(classSection.getSuperclass(key)));
-        indexWriter.writeInt(typeListSection.getNullableItemOffset(classSection.getSortedInterfaces(key)));
+        indexWriter.writeInt(typeListSection.getNullableItemOffset(classSection.getInterfaces(key)));
         indexWriter.writeInt(stringSection.getNullableItemIndex(classSection.getSourceFile(key)));
         indexWriter.writeInt(classSection.getAnnotationDirectoryOffset(key));
 

File: dexlib2/src/main/java/org/jf/dexlib2/writer/builder/BuilderClassPool.java
Patch:
@@ -122,7 +122,7 @@ public Entry<? extends BuilderClassDef, Integer> getClassEntryByType(@Nullable B
         return builderClassDef.superclass;
     }
 
-    @Nullable @Override public BuilderTypeList getSortedInterfaces(@Nonnull BuilderClassDef builderClassDef) {
+    @Nullable @Override public BuilderTypeList getInterfaces(@Nonnull BuilderClassDef builderClassDef) {
         return builderClassDef.interfaces;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/writer/pool/ClassPool.java
Patch:
@@ -250,7 +250,7 @@ public Map.Entry<? extends PoolClassDef, Integer> getClassEntryByType(@Nullable
         return classDef.getSuperclass();
     }
 
-    @Nullable @Override public TypeListPool.Key<SortedSet<String>> getSortedInterfaces(@Nonnull PoolClassDef classDef) {
+    @Nullable @Override public TypeListPool.Key<List<String>> getInterfaces(@Nonnull PoolClassDef classDef) {
         return classDef.interfaces;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/writer/pool/PoolClassDef.java
Patch:
@@ -43,7 +43,7 @@
 
 class PoolClassDef extends BaseTypeReference implements ClassDef {
     @Nonnull final ClassDef classDef;
-    @Nonnull final TypeListPool.Key<SortedSet<String>> interfaces;
+    @Nonnull final TypeListPool.Key<List<String>> interfaces;
     @Nonnull final ImmutableSortedSet<Field> staticFields;
     @Nonnull final ImmutableSortedSet<Field> instanceFields;
     @Nonnull final ImmutableSortedSet<PoolMethod> directMethods;
@@ -56,7 +56,7 @@ class PoolClassDef extends BaseTypeReference implements ClassDef {
     PoolClassDef(@Nonnull ClassDef classDef) {
         this.classDef = classDef;
 
-        interfaces = new TypeListPool.Key<SortedSet<String>>(ImmutableSortedSet.copyOf(classDef.getInterfaces()));
+        interfaces = new TypeListPool.Key<List<String>>(ImmutableList.copyOf(classDef.getInterfaces()));
         staticFields = ImmutableSortedSet.copyOf(classDef.getStaticFields());
         instanceFields = ImmutableSortedSet.copyOf(classDef.getInstanceFields());
         directMethods = ImmutableSortedSet.copyOf(
@@ -77,7 +77,7 @@ class PoolClassDef extends BaseTypeReference implements ClassDef {
         return classDef.getSuperclass();
     }
 
-    @Nonnull @Override public SortedSet<String> getInterfaces() {
+    @Nonnull @Override public List<String> getInterfaces() {
         return interfaces.types;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/raw/CodeItem.java
Patch:
@@ -100,10 +100,10 @@ public void annotateItem(@Nonnull AnnotatedBytes out, int itemIndex, @Nullable S
                     int triesCount = reader.readUshort();
                     out.annotate(2, "tries_size = %d", triesCount);
 
-                    int debugInfoOffset = reader.readSmallUint();
+                    int debugInfoOffset = reader.readInt();
                     out.annotate(4, "debug_info_off = 0x%x", debugInfoOffset);
 
-                    if (debugInfoOffset != 0) {
+                    if (debugInfoOffset > 0) {
                         addDebugInfoIdentity(debugInfoOffset, itemIdentity);
                     }
 

File: smalidea/src/main/java/org/jf/smalidea/SmaliLexer.java
Patch:
@@ -126,5 +126,6 @@ private void ensureToken() {
             token = (CommonToken)lexer.nextToken();
             state = lexer.yystate();
         }
+        assert token != null;
     }
 }

File: smalidea/src/main/java/org/jf/smalidea/debugging/SmaliCodeFragmentFactory.java
Patch:
@@ -69,6 +69,9 @@ public JavaCodeFragment createCodeFragment(TextWithImports item, PsiElement cont
 
     @Override
     public boolean isContextAccepted(PsiElement contextElement) {
+        if (contextElement == null) {
+            return false;
+        }
         return contextElement.getLanguage() == SmaliLanguage.INSTANCE;
     }
 

File: smalidea/src/main/java/org/jf/smalidea/psi/impl/SmaliField.java
Patch:
@@ -101,7 +101,7 @@ public SmaliField(@NotNull ASTNode node) {
         if (typeElement == null) {
             // If we don't have a type (i.e. syntax error), use Object as a safe-ish fallback
             PsiElementFactory factory = JavaPsiFacade.getInstance(getProject()).getElementFactory();
-            return factory.createTypeByFQClassName("java.lang.Object", getResolveScope());
+            return factory.createTypeFromText("java.lang.Object", this);
         }
         return getTypeElement().getType();
     }

File: smalidea/src/main/java/org/jf/smalidea/psi/impl/SmaliMethodPrototype.java
Patch:
@@ -59,7 +59,7 @@ public PsiType getReturnType() {
                 return null;
             }
             PsiElementFactory factory = JavaPsiFacade.getInstance(getProject()).getElementFactory();
-            return factory.createTypeByFQClassName(returnType, getResolveScope());
+            return factory.createTypeFromText(returnType, this);
         }
 
         PsiTypeElement returnTypeElement = getReturnTypeElement();

File: util/src/main/java/org/jf/util/IndentingWriter.java
Patch:
@@ -120,7 +120,7 @@ public void write(String str, int start, int len) throws IOException {
         int pos = start;
         while (pos < end) {
             pos = str.indexOf('\n', start);
-            if (pos == -1) {
+            if (pos == -1 || pos >= end) {
                 writeLine(str, start, end-start);
                 return;
             } else {

File: smalidea/src/test/java/org/jf/smalidea/ParserTest.java
Patch:
@@ -53,6 +53,7 @@ protected String getTestDataPath() {
     public void testInvalidField3() throws Exception { doTest(true); }
     public void testInvalidField4() throws Exception { doTest(true); }
     public void testInvalidInstruction() throws Exception { doTest(true); }
+    public void testInvalidLocal() throws Exception { doTest(true);}
     public void testParamListInvalidParameter() throws Exception { doTest(true); }
     public void testSuperClassInvalidSyntax() throws Exception { doTest(true); }
     public void testSuperClassInvalidSyntax2() throws Exception { doTest(true); }

File: smalidea/src/main/java/org/jf/smalidea/psi/impl/SmaliMethodParameter.java
Patch:
@@ -107,7 +107,7 @@ public SmaliMethodParameter(@NotNull ASTNode node) {
         return null;
     }
 
-    @Override public String getName() {
+    @Nullable @Override public String getName() {
         SmaliMethodParameterStub stub = getStub();
         if (stub != null) {
             return stub.getName();

File: smalidea/src/test/java/org/jf/smalidea/ParserTest.java
Patch:
@@ -57,6 +57,7 @@ protected String getTestDataPath() {
     public void testSuperClassInvalidSyntax() throws Exception { doTest(true); }
     public void testSuperClassInvalidSyntax2() throws Exception { doTest(true); }
     public void testInvalidMethodReference() throws Exception { doTest(true); }
+    public void testInvalidParameter() throws Exception { doTest(true); }
     public void testInvalidMethod() throws Exception { doTest(true); }
     public void testInvalidMethod2() throws Exception { doTest(true); }
     public void testInvalidMethod3() throws Exception { doTest(true); }

File: smalidea/src/test/java/org/jf/smalidea/ParserTest.java
Patch:
@@ -61,4 +61,5 @@ protected String getTestDataPath() {
     public void testInvalidMethod2() throws Exception { doTest(true); }
     public void testInvalidMethod3() throws Exception { doTest(true); }
     public void testInvalidMethod4() throws Exception { doTest(true); }
+    public void testMissingDotDot() throws Exception { doTest(true); }
 }

File: smalidea/src/test/java/org/jf/smalidea/ParserTest.java
Patch:
@@ -47,6 +47,7 @@ protected String getTestDataPath() {
     public void testInvalidClassDirective() throws Exception { doTest(true); }
     public void testInvalidClassDirective2() throws Exception { doTest(true); }
     public void testInvalidClassDirective3() throws Exception { doTest(true); }
+    public void testInvalidEnumLiteral() throws Exception { doTest(true); }
     public void testInvalidField() throws Exception { doTest(true); }
     public void testInvalidField2() throws Exception { doTest(true); }
     public void testInvalidField3() throws Exception { doTest(true); }

File: smalidea/src/test/java/org/jf/smalidea/ParserTest.java
Patch:
@@ -51,6 +51,7 @@ protected String getTestDataPath() {
     public void testInvalidField2() throws Exception { doTest(true); }
     public void testInvalidField3() throws Exception { doTest(true); }
     public void testInvalidField4() throws Exception { doTest(true); }
+    public void testInvalidInstruction() throws Exception { doTest(true); }
     public void testParamListInvalidParameter() throws Exception { doTest(true); }
     public void testSuperClassInvalidSyntax() throws Exception { doTest(true); }
     public void testSuperClassInvalidSyntax2() throws Exception { doTest(true); }

File: smalidea/src/test/java/org/jf/smalidea/ParserTest.java
Patch:
@@ -58,4 +58,5 @@ protected String getTestDataPath() {
     public void testInvalidMethod() throws Exception { doTest(true); }
     public void testInvalidMethod2() throws Exception { doTest(true); }
     public void testInvalidMethod3() throws Exception { doTest(true); }
+    public void testInvalidMethod4() throws Exception { doTest(true); }
 }

File: smalidea/src/main/java/org/jf/smalidea/psi/impl/SmaliMethodReference.java
Patch:
@@ -124,7 +124,9 @@ public List<PsiType> getParameterTypes() {
     @Nullable
     public SmaliTypeElement getReturnType() {
         SmaliTypeElement[] types = findChildrenByClass(SmaliTypeElement.class);
-        assert types.length == 2;
+        if (types.length < 2) {
+            return null;
+        }
         return types[1];
     }
 

File: smalidea/src/test/java/org/jf/smalidea/ParserTest.java
Patch:
@@ -54,6 +54,7 @@ protected String getTestDataPath() {
     public void testParamListInvalidParameter() throws Exception { doTest(true); }
     public void testSuperClassInvalidSyntax() throws Exception { doTest(true); }
     public void testSuperClassInvalidSyntax2() throws Exception { doTest(true); }
+    public void testInvalidMethodReference() throws Exception { doTest(true); }
     public void testInvalidMethod() throws Exception { doTest(true); }
     public void testInvalidMethod2() throws Exception { doTest(true); }
     public void testInvalidMethod3() throws Exception { doTest(true); }

File: smalidea/src/test/java/org/jf/smalidea/ParserTest.java
Patch:
@@ -56,4 +56,5 @@ protected String getTestDataPath() {
     public void testSuperClassInvalidSyntax2() throws Exception { doTest(true); }
     public void testInvalidMethod() throws Exception { doTest(true); }
     public void testInvalidMethod2() throws Exception { doTest(true); }
+    public void testInvalidMethod3() throws Exception { doTest(true); }
 }

File: smalidea/src/main/java/org/jf/smalidea/psi/impl/SmaliAnnotation.java
Patch:
@@ -52,7 +52,7 @@ public SmaliAnnotation(@NotNull ASTNode node) {
 
     @NotNull @Override public SmaliAnnotationParameterList getParameterList() {
         SmaliAnnotationParameterList paramList = findChildByClass(SmaliAnnotationParameterList.class);
-        // TODO: test that this is true even if there are syntax errors
+        // The structure of the parser should ensure the param list is always present, even if there are syntax errors
         assert paramList != null;
         return paramList;
     }
@@ -71,7 +71,6 @@ public SmaliAnnotation(@NotNull ASTNode node) {
     }
 
     @Nullable @Override public PsiJavaCodeReferenceElement getNameReferenceElement() {
-        // TODO: have SmaliClassTypeElement implement PsiJavaCodeReferenceElement?
         // TODO: we need to have a PsiAnnotationMethod implementation for methods in an annotation class (see PsiUtil.isAnnotationMethod and PsiImplUtil.findAttributeValue)
         // TODO: alternately, we should implement findAttributeValue and findAttributeValue ourselves, instead of relying on PsiImplUtil (don't forget about finding default values..)
         SmaliAnnotationStub stub = getStub();

File: smalidea/src/main/java/org/jf/smalidea/psi/stub/element/SmaliAnnotationElementType.java
Patch:
@@ -72,7 +72,7 @@ public void serialize(@NotNull SmaliAnnotationStub stub, @NotNull StubOutputStre
 
     @NotNull @Override
     public SmaliAnnotationStub deserialize(@NotNull StubInputStream dataStream, StubElement parentStub) throws IOException {
-        return new SmaliAnnotationStub(parentStub, dataStream.readName().getString());
+        return new SmaliAnnotationStub(parentStub, deserializeNullableString(dataStream));
     }
 
     @Override public void indexStub(@NotNull SmaliAnnotationStub stub, @NotNull IndexSink sink) {

File: smalidea/src/test/java/org/jf/smalidea/ParserTest.java
Patch:
@@ -43,6 +43,7 @@ protected String getTestDataPath() {
 
     public void testEmpty() throws Exception { doTest(true); }
     public void testFieldAnnotations() throws Exception { doTest(true); }
+    public void testInvalidAnnotation() throws Exception { doTest(true); }
     public void testInvalidClassDirective() throws Exception { doTest(true); }
     public void testInvalidClassDirective2() throws Exception { doTest(true); }
     public void testInvalidClassDirective3() throws Exception { doTest(true); }

File: smalidea/src/test/java/org/jf/smalidea/ParserTest.java
Patch:
@@ -49,6 +49,7 @@ protected String getTestDataPath() {
     public void testInvalidField() throws Exception { doTest(true); }
     public void testInvalidField2() throws Exception { doTest(true); }
     public void testInvalidField3() throws Exception { doTest(true); }
+    public void testInvalidField4() throws Exception { doTest(true); }
     public void testParamListInvalidParameter() throws Exception { doTest(true); }
     public void testSuperClassInvalidSyntax() throws Exception { doTest(true); }
     public void testSuperClassInvalidSyntax2() throws Exception { doTest(true); }

File: smalidea/src/main/java/org/jf/smalidea/debugging/SmaliCodeFragmentFactory.java
Patch:
@@ -85,6 +85,9 @@ private PsiElement wrapContext(final Project project, final PsiElement originalC
 
         final SmaliMethod containingMethod = currentInstruction.getParentMethod();
         AnalyzedInstruction analyzedInstruction = currentInstruction.getAnalyzedInstruction();
+        if (analyzedInstruction == null) {
+            return originalContext;
+        }
 
         final int firstParameterRegister = containingMethod.getRegisterCount() -
                 containingMethod.getParameterRegisterCount();

File: smalidea/src/main/java/org/jf/smalidea/psi/impl/SmaliMethodParameter.java
Patch:
@@ -89,8 +89,7 @@ public SmaliMethodParameter(@NotNull ASTNode node) {
         SmaliMethodParameterStub stub = getStub();
         if (stub != null) {
             String type = stub.getType();
-            PsiElementFactory factory = JavaPsiFacade.getInstance(getProject()).getElementFactory();
-            return factory.createTypeByFQClassName(type, getResolveScope());
+            return JavaPsiFacade.getInstance(getProject()).getParserFacade().createTypeFromText(type, null);
         }
         return getTypeElement().getType();
     }

File: smalidea/src/main/java/org/jf/smalidea/psi/impl/SmaliMethodPrototype.java
Patch:
@@ -52,8 +52,8 @@ public PsiTypeElement getReturnType() {
         return findChildByClass(PsiTypeElement.class);
     }
 
-    @Nullable
+    @NotNull
     public SmaliMethodParamList getParameterList() {
-        return findChildByClass(SmaliMethodParamList.class);
+        return getRequiredStubOrPsiChild(SmaliElementTypes.METHOD_PARAM_LIST);
     }
 }

File: smalidea/src/test/java/org/jf/smalidea/ParserTest.java
Patch:
@@ -102,4 +102,5 @@ protected String getTestDataPath() {
     public void testSuperClassInvalidSyntax() throws Exception { doTest(true); }
     public void testSuperClassInvalidSyntax2() throws Exception { doTest(true); }
     public void testInvalidMethod() throws Exception { doTest(true); }
+    public void testInvalidMethod2() throws Exception { doTest(true); }
 }

File: smalidea/src/test/java/org/jf/smalidea/ParserTest.java
Patch:
@@ -101,4 +101,5 @@ protected String getTestDataPath() {
     public void testParamListInvalidParameter() throws Exception { doTest(true); }
     public void testSuperClassInvalidSyntax() throws Exception { doTest(true); }
     public void testSuperClassInvalidSyntax2() throws Exception { doTest(true); }
+    public void testInvalidMethod() throws Exception { doTest(true); }
 }

File: smalidea/src/main/java/org/jf/smalidea/debugging/SmaliPositionManagerFactory.java
Patch:
@@ -34,10 +34,11 @@
 import com.intellij.debugger.PositionManager;
 import com.intellij.debugger.PositionManagerFactory;
 import com.intellij.debugger.engine.DebugProcess;
+import org.jetbrains.annotations.NotNull;
 
 public class SmaliPositionManagerFactory extends PositionManagerFactory {
     @Override
-    public PositionManager createPositionManager(DebugProcess process) {
+    public PositionManager createPositionManager(@NotNull DebugProcess process) {
         return new SmaliPositionManager(process);
     }
 }

File: smalidea/src/test/java/org/jf/smalidea/ParserTest.java
Patch:
@@ -98,6 +98,7 @@ protected String getTestDataPath() {
     public void testEmpty() throws Exception { doTest(true); }
     public void testInvalidClassDirective() throws Exception { doTest(true); }
     public void testInvalidClassDirective2() throws Exception { doTest(true); }
+    public void testParamListInvalidParameter() throws Exception { doTest(true); }
     public void testSuperClassInvalidSyntax() throws Exception { doTest(true); }
     public void testSuperClassInvalidSyntax2() throws Exception { doTest(true); }
 }

File: smalidea/src/test/java/org/jf/smalidea/ParserTest.java
Patch:
@@ -97,4 +97,7 @@ protected String getTestDataPath() {
 
     public void testEmpty() throws Exception { doTest(true); }
     public void testInvalidClassDirective() throws Exception { doTest(true); }
+    public void testInvalidClassDirective2() throws Exception { doTest(true); }
+    public void testSuperClassInvalidSyntax() throws Exception { doTest(true); }
+    public void testSuperClassInvalidSyntax2() throws Exception { doTest(true); }
 }

File: smalidea/src/test/java/org/jf/smalidea/dexlib/SmalideaMethodTest.java
Patch:
@@ -551,7 +551,8 @@ public void testArrayData() {
                 ":ArrayData\n" +
                 "    .array-data 4\n" +
                 "        1 2 128 -256 65536 0x7fffffff\n" +
-                "    .end array-data";
+                "    .end array-data\n" +
+                ".end method";
 
         SmaliFile file = (SmaliFile)myFixture.addFileToProject("my/pkg/blah.smali", text);
         SmaliClass smaliClass = file.getPsiClass();

File: smalidea/src/test/java/org/jf/smalidea/ParserTest.java
Patch:
@@ -96,4 +96,5 @@ protected String getTestDataPath() {
     }
 
     public void testEmpty() throws Exception { doTest(true); }
+    public void testInvalidClassDirective() throws Exception { doTest(true); }
 }

File: smalidea/src/main/java/org/jf/smalidea/psi/impl/SmaliBaseReferenceList.java
Patch:
@@ -32,7 +32,6 @@
 package org.jf.smalidea.psi.impl;
 
 import com.google.common.collect.Lists;
-import com.intellij.extapi.psi.StubBasedPsiElementBase;
 import com.intellij.lang.ASTNode;
 import com.intellij.psi.PsiReferenceList;
 import com.intellij.psi.StubBasedPsiElement;
@@ -43,7 +42,7 @@
 import java.util.List;
 
 public abstract class SmaliBaseReferenceList<StubT extends SmaliBaseReferenceListStub>
-        extends StubBasedPsiElementBase<StubT> implements StubBasedPsiElement<StubT>, PsiReferenceList {
+        extends SmaliStubBasedPsiElement<StubT> implements StubBasedPsiElement<StubT>, PsiReferenceList {
     protected SmaliBaseReferenceList(@NotNull StubT stub, @NotNull IStubElementType nodeType) {
         super(stub, nodeType);
     }

File: smalidea/src/main/java/org/jf/smalidea/SmaliTokens.java
Patch:
@@ -50,7 +50,7 @@ public static IElementType getElementType(int tokenType) {
     @SuppressWarnings({"UnusedDeclaration"}) public static IElementType ANNOTATION_DIRECTIVE;
     @SuppressWarnings({"UnusedDeclaration"}) public static IElementType ANNOTATION_VISIBILITY;
     @SuppressWarnings({"UnusedDeclaration"}) public static IElementType ARRAY_DATA_DIRECTIVE;
-    @SuppressWarnings({"UnusedDeclaration"}) public static IElementType ARRAY_DESCRIPTOR;
+    @SuppressWarnings({"UnusedDeclaration"}) public static IElementType ARRAY_TYPE_PREFIX;
     @SuppressWarnings({"UnusedDeclaration"}) public static IElementType ARROW;
     @SuppressWarnings({"UnusedDeclaration"}) public static IElementType BOOL_LITERAL;
     @SuppressWarnings({"UnusedDeclaration"}) public static IElementType BYTE_LITERAL;
@@ -169,7 +169,7 @@ public static IElementType getElementType(int tokenType) {
         tokenColors.put("ANNOTATION_DIRECTIVE", SmaliHighlightingColors.DIRECTIVE);
         tokenColors.put("ANNOTATION_VISIBILITY", SmaliHighlightingColors.ACCESS);
         tokenColors.put("ARRAY_DATA_DIRECTIVE", SmaliHighlightingColors.DIRECTIVE);
-        tokenColors.put("ARRAY_DESCRIPTOR", SmaliHighlightingColors.TYPE);
+        tokenColors.put("ARRAY_TYPE_PREFIX", SmaliHighlightingColors.TYPE);
         tokenColors.put("ARROW", SmaliHighlightingColors.ARROW);
         tokenColors.put("BOOL_LITERAL", SmaliHighlightingColors.LITERAL);
         tokenColors.put("BYTE_LITERAL", SmaliHighlightingColors.NUMBER);

File: smalidea/src/test/java/org/jf/smalidea/SmaliLexerTest.java
Patch:
@@ -72,7 +72,8 @@ public void testHelloWorld() {
                 "WHITE_SPACE (' ')\n" +
                 "SIMPLE_NAME ('main')\n" +
                 "OPEN_PAREN ('(')\n" +
-                "ARRAY_DESCRIPTOR ('[Ljava/lang/String;')\n" +
+                "ARRAY_TYPE_PREFIX ('[')\n" +
+                "CLASS_DESCRIPTOR ('Ljava/lang/String;')\n" +
                 "CLOSE_PAREN (')')\n" +
                 "VOID_TYPE ('V')\n" +
                 "WHITE_SPACE ('\\n    ')\n" +

File: smalidea/src/test/java/org/jf/smalidea/SmaliClassTest.java
Patch:
@@ -38,13 +38,14 @@
 import org.jf.smalidea.psi.impl.SmaliFile;
 
 public class SmaliClassTest extends LightCodeInsightFixtureTestCase {
-    public void testGetQualifiedName() {
+    public void testName() {
         SmaliFile file = (SmaliFile)myFixture.addFileToProject("my/pkg/blah.smali",
                 ".class public Lmy/pkg/blah; .super Ljava/lang/Object;");
 
         SmaliClass smaliClass = file.getPsiClass();
         Assert.assertEquals("my.pkg.blah", smaliClass.getQualifiedName());
         Assert.assertEquals("my.pkg", smaliClass.getPackageName());
+        Assert.assertEquals("blah", smaliClass.getName());
     }
 
     public void testEmptyPackageName() {

File: smalidea/src/main/java/org/jf/smalidea/psi/SmaliElementTypes.java
Patch:
@@ -95,4 +95,6 @@ public class SmaliElementTypes {
             new SmaliCompositeElementType("CLASS_TYPE", SmaliClassTypeElement.FACTORY);
     public static final SmaliCompositeElementType ARRAY_TYPE =
             new SmaliCompositeElementType("ARRAY_TYPE", SmaliArrayTypeElement.FACTORY);
+    public static final SmaliCompositeElementType VOID_TYPE =
+            new SmaliCompositeElementType("VOID_TYPE", SmaliVoidTypeElement.FACTORY);
 }

File: smalidea/src/main/java/org/jf/smalidea/psi/SmaliElementTypes.java
Patch:
@@ -93,4 +93,6 @@ public class SmaliElementTypes {
             new SmaliCompositeElementType("PRIMITIVE_TYPE", SmaliPrimitiveTypeElement.FACTORY);
     public static final SmaliCompositeElementType CLASS_TYPE =
             new SmaliCompositeElementType("CLASS_TYPE", SmaliClassTypeElement.FACTORY);
+    public static final SmaliCompositeElementType ARRAY_TYPE =
+            new SmaliCompositeElementType("ARRAY_TYPE", SmaliArrayTypeElement.FACTORY);
 }

File: smalidea/src/main/java/org/jf/smalidea/psi/SmaliElementTypes.java
Patch:
@@ -91,4 +91,6 @@ public class SmaliElementTypes {
             new SmaliCompositeElementType("SOURCE_DEBUG_STATEMENT", SmaliSourceDebugStatement.FACTORY);
     public static final SmaliCompositeElementType PRIMITIVE_TYPE =
             new SmaliCompositeElementType("PRIMITIVE_TYPE", SmaliPrimitiveTypeElement.FACTORY);
+    public static final SmaliCompositeElementType CLASS_TYPE =
+            new SmaliCompositeElementType("CLASS_TYPE", SmaliClassTypeElement.FACTORY);
 }

File: smalidea/src/main/java/org/jf/smalidea/psi/SmaliElementTypes.java
Patch:
@@ -51,4 +51,6 @@ public class SmaliElementTypes {
             new SmaliCompositeElementType("IMPLEMENTS_STATEMENT", SmaliImplementsStatement.FACTORY);
     public static final SmaliCompositeElementType SOURCE_STATEMENT =
             new SmaliCompositeElementType("SOURCE_STATEMENT", SmaliSourceStatement.FACTORY);
+    public static final SmaliCompositeElementType PRIMITIVE_TYPE =
+            new SmaliCompositeElementType("PRIMITIVE_TYPE", SmaliPrimitiveTypeElement.FACTORY);
 }

File: smalidea/src/main/java/org/jf/smalidea/SmaliParser.java
Patch:
@@ -47,6 +47,7 @@ public class SmaliParser implements PsiParser {
 
         PsiBuilderTokenStream tokenStream = new PsiBuilderTokenStream(builder);
         smalideaParser parser = new smalideaParser(tokenStream);
+        parser.setPsiBuilder(builder);
         try {
             parser.smali_file();
         } catch (RecognitionException ex) {

File: baksmali/src/main/java/org/jf/baksmali/baksmaliOptions.java
Patch:
@@ -73,7 +73,7 @@ public class baksmaliOptions {
     public boolean deodex = false;
     public boolean ignoreErrors = false;
     public boolean checkPackagePrivateAccess = false;
-    public boolean useImplicitReferences = true;
+    public boolean useImplicitReferences = false;
     public File customInlineDefinitions = null;
     public InlineMethodResolver inlineResolver = null;
     public int registerInfo = 0;

File: baksmali/src/main/java/org/jf/baksmali/main.java
Patch:
@@ -206,7 +206,7 @@ public static void main(String[] args) throws IOException {
                     options.setResourceIdFiles(rif);
                     break;
                 case 't':
-                    options.useImplicitReferences = false;
+                    options.useImplicitReferences = true;
                     break;
                 case 'e':
                     options.dexEntry = commandLine.getOptionValue("e");
@@ -425,8 +425,8 @@ private static void buildOptions() {
                 .withArgName("FILES")
                 .create("i");
 
-        Option noImplicitReferencesOption = OptionBuilder.withLongOpt("no-implicit-references")
-                .withDescription("Don't use implicit (type-less) method and field references")
+        Option noImplicitReferencesOption = OptionBuilder.withLongOpt("implicit-references")
+                .withDescription("Use implicit (type-less) method and field references")
                 .create("t");
 
         Option checkPackagePrivateAccessOption = OptionBuilder.withLongOpt("check-package-private-access")

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/BaseDexReader.java
Patch:
@@ -48,7 +48,6 @@ public BaseDexReader(@Nonnull T dexBuf, int offset) {
     public int getOffset() { return offset; }
     public void setOffset(int offset) { this.offset = offset; }
 
-    /** {@inheritDoc} */
     public int readSleb128() {
         int end = offset;
         int currentByteValue;

File: dexlib2/src/main/java/org/jf/dexlib2/iface/debug/DebugItem.java
Patch:
@@ -48,8 +48,7 @@ public interface DebugItem {
     int getDebugItemType();
 
     /**
-     * The code address
-     * @return
+     * @return The code address
      */
     int getCodeAddress();
 }

File: dexlib2/src/main/java/org/jf/dexlib2/util/AnnotatedBytes.java
Patch:
@@ -268,8 +268,7 @@ public AnnotationItem(int  indentLevel, String annotation) {
     }
 
     /**
-     * Gets the width of the right side containing the annotations
-     * @return
+     * @return The width of the right side containing the annotations
      */
     public int getAnnotationWidth() {
         int leftWidth = 8 + (hexCols * 2) + (hexCols / 2);

File: util/src/main/java/ds/tree/RadixTree.java
Patch:
@@ -57,7 +57,7 @@ public interface RadixTree<T> {
     /**
      * Delete a key and its associated value from the tree.
      * @param key The key of the node that need to be deleted
-     * @return
+     * @return True if the key was deleted, false if not found
      */
     public boolean delete(String key);
 

File: util/src/main/java/ds/tree/RadixTreeImpl.java
Patch:
@@ -373,7 +373,7 @@ public long getSize() {
      * Display the Trie on console.
      *
      * WARNING! Do not use this for a large Trie, it's for testing purpose only.
-     * @see formatTo
+     * @see #formatTo
      */
     @Deprecated
     public void display() {

File: util/src/main/java/ds/tree/Visitor.java
Patch:
@@ -33,7 +33,8 @@ of this software and associated documentation files (the "Software"), to deal
  * @author Tahseen Ur Rehman (tahseen.ur.rehman {at.spam.me.not} gmail.com)
  * @author Javid Jamae
  * @author Dennis Heidsiek
- * @param <T,R>
+ * @param <T>
+ * @param <R>
  */
 public interface Visitor<T, R> {
     /**

File: util/src/main/java/ds/tree/VisitorImpl.java
Patch:
@@ -2,10 +2,11 @@
 
 
 /**
- * A simple standard implementation for a {@link visitor}.
+ * A simple standard implementation for a {@link Visitor}.
  *
  * @author Dennis Heidsiek
- * @param <T,R>
+ * @param <T>
+ * @param <R>
  */
 public abstract class VisitorImpl<T, R> implements Visitor<T, R> {
 

File: util/src/main/java/org/jf/util/ConsoleUtil.java
Patch:
@@ -35,7 +35,7 @@
 public class ConsoleUtil {
     /**
      * Attempt to find the width of the console. If it can't get the width, return a default of 80
-     * @return
+     * @return The current console width
      */
     public static int getConsoleWidth() {
         if (System.getProperty("os.name").toLowerCase().contains("windows")) {

File: dexlib2/src/main/java/org/jf/dexlib2/builder/MutableMethodImplementation.java
Patch:
@@ -213,8 +213,10 @@ public void addInstruction(int index, BuilderInstruction instruction) {
             return;
         }
         int codeAddress = instructionList.get(index).getCodeAddress();
+        MethodLocation newLoc = new MethodLocation(instruction, codeAddress, index);
+        instructionList.add(index, newLoc);
+        instruction.location = newLoc;
 
-        instructionList.add(index, new MethodLocation(instruction, codeAddress, index));
         codeAddress += instruction.getCodeUnits();
 
         for (int i=index+1; i<instructionList.size(); i++) {

File: baksmali/src/main/java/org/jf/baksmali/baksmaliOptions.java
Patch:
@@ -36,6 +36,7 @@
 import org.jf.dexlib2.analysis.InlineMethodResolver;
 import org.jf.dexlib2.util.SyntheticAccessorResolver;
 
+import java.io.File;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
@@ -71,6 +72,7 @@ public class baksmaliOptions {
     public boolean deodex = false;
     public boolean ignoreErrors = false;
     public boolean checkPackagePrivateAccess = false;
+    public File customInlineDefinitions = null;
     public InlineMethodResolver inlineResolver = null;
     public int registerInfo = 0;
     public ClassPath classPath = null;

File: baksmali/src/main/java/org/jf/baksmali/main.java
Patch:
@@ -31,7 +31,6 @@
 import com.google.common.collect.Lists;
 import org.apache.commons.cli.*;
 import org.jf.dexlib2.DexFileFactory;
-import org.jf.dexlib2.analysis.CustomInlineMethodResolver;
 import org.jf.dexlib2.analysis.InlineMethodResolver;
 import org.jf.dexlib2.dexbacked.DexBackedDexFile;
 import org.jf.dexlib2.dexbacked.DexBackedOdexFile;
@@ -217,7 +216,7 @@ public static void main(String[] args) throws IOException {
                     options.ignoreErrors = true;
                     break;
                 case 'T':
-                    options.inlineResolver = new CustomInlineMethodResolver(options.classPath, new File(commandLine.getOptionValue("T")));
+                    options.customInlineDefinitions = new File(commandLine.getOptionValue("T"));
                     break;
                 default:
                     assert false;
@@ -270,7 +269,7 @@ public static void main(String[] args) throws IOException {
             }
         }
 
-        if (options.inlineResolver == null && dexFile instanceof DexBackedOdexFile) {
+        if (options.customInlineDefinitions == null && dexFile instanceof DexBackedOdexFile) {
             options.inlineResolver =
                     InlineMethodResolver.createInlineMethodResolver(((DexBackedOdexFile)dexFile).getOdexVersion());
         }

File: dexlib2/src/main/java/org/jf/dexlib2/builder/MutableMethodImplementation.java
Patch:
@@ -96,8 +96,8 @@ public MutableMethodImplementation(@Nonnull MethodImplementation methodImplement
             index++;
         }
 
-        // the switch instructions must be converted last, so that any switch statements that refer to them have
-        // created the referring labels that we look for
+        // the switch payload instructions must be converted last, so that any switch statements that refer to them
+        // have created the referring labels that we look for
         for (Task switchPayloadTask: switchPayloadTasks) {
             switchPayloadTask.perform();
         }

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/ReferenceFormatter.java
Patch:
@@ -57,6 +57,9 @@ public static void writeReference(IndentingWriter writer, int referenceType,
                 return;
             case ReferenceType.FIELD:
                 ReferenceUtil.writeFieldDescriptor(writer, (FieldReference)reference);
+                return;
+            default:
+                throw new IllegalStateException("Unknown reference type");
         }
     }
 }

File: baksmali/src/main/java/org/jf/baksmali/baksmaliOptions.java
Patch:
@@ -67,6 +67,7 @@ public class baksmaliOptions {
     public boolean outputDebugInfo = true;
     public boolean addCodeOffsets = false;
     public boolean noAccessorComments = false;
+    public boolean allowOdex = false;
     public boolean deodex = false;
     public boolean ignoreErrors = false;
     public boolean checkPackagePrivateAccess = false;

File: baksmali/src/main/java/org/jf/baksmali/main.java
Patch:
@@ -255,6 +255,7 @@ public static void main(String[] args) throws IOException {
                 System.err.println("Warning: You are disassembling an odex file without deodexing it. You");
                 System.err.println("won't be able to re-assemble the results unless you deodex it with the -x");
                 System.err.println("option");
+                options.allowOdex = true;
             }
         } else {
             options.deodex = false;

File: dexlib2/src/main/java/org/jf/dexlib2/VerificationError.java
Patch:
@@ -34,6 +34,7 @@
 import com.google.common.collect.Maps;
 import org.jf.util.ExceptionWithContext;
 
+import javax.annotation.Nullable;
 import java.util.HashMap;
 
 public class VerificationError {
@@ -61,6 +62,7 @@ public class VerificationError {
         verificationErrorNames.put("instantiation-error", INSTANTIATION_ERROR);
     }
 
+    @Nullable
     public static String getVerificationErrorName(int verificationError) {
         switch (verificationError) {
             case GENERIC:

File: dexlib2/src/main/java/org/jf/dexlib2/builder/instruction/BuilderInstruction20bc.java
Patch:
@@ -33,6 +33,7 @@
 
 import org.jf.dexlib2.Format;
 import org.jf.dexlib2.Opcode;
+import org.jf.dexlib2.ReferenceType;
 import org.jf.dexlib2.builder.BuilderInstruction;
 import org.jf.dexlib2.iface.instruction.formats.Instruction20bc;
 import org.jf.dexlib2.iface.reference.Reference;
@@ -56,6 +57,7 @@ public BuilderInstruction20bc(@Nonnull Opcode opcode,
 
     @Override public int getVerificationError() { return verificationError; }
     @Nonnull @Override public Reference getReference() { return reference; }
+    @Override public int getReferenceType() { return ReferenceType.getReferenceType(reference); }
 
     @Override public Format getFormat() { return FORMAT; }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/builder/instruction/BuilderInstruction21c.java
Patch:
@@ -56,6 +56,7 @@ public BuilderInstruction21c(@Nonnull Opcode opcode,
 
     @Override public int getRegisterA() { return registerA; }
     @Nonnull @Override public Reference getReference() { return reference; }
+    @Override public int getReferenceType() { return opcode.referenceType; }
 
     @Override public Format getFormat() { return FORMAT; }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/builder/instruction/BuilderInstruction22c.java
Patch:
@@ -60,6 +60,7 @@ public BuilderInstruction22c(@Nonnull Opcode opcode,
     @Override public int getRegisterA() { return registerA; }
     @Override public int getRegisterB() { return registerB; }
     @Nonnull @Override public Reference getReference() { return reference; }
+    @Override public int getReferenceType() { return opcode.referenceType; }
 
     @Override public Format getFormat() { return FORMAT; }
 }
\ No newline at end of file

File: dexlib2/src/main/java/org/jf/dexlib2/builder/instruction/BuilderInstruction31c.java
Patch:
@@ -56,6 +56,7 @@ public BuilderInstruction31c(@Nonnull Opcode opcode,
 
     @Override public int getRegisterA() { return registerA; }
     @Nonnull @Override public Reference getReference() { return reference; }
+    @Override public int getReferenceType() { return opcode.referenceType; }
 
     @Override public Format getFormat() { return FORMAT; }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/builder/instruction/BuilderInstruction35c.java
Patch:
@@ -76,6 +76,7 @@ public BuilderInstruction35c(@Nonnull Opcode opcode,
     @Override public int getRegisterF() { return registerF; }
     @Override public int getRegisterG() { return registerG; }
     @Nonnull @Override public Reference getReference() { return reference; }
+    @Override public int getReferenceType() { return opcode.referenceType; }
 
     @Override public Format getFormat() { return FORMAT; }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/builder/instruction/BuilderInstruction3rc.java
Patch:
@@ -61,6 +61,7 @@ public BuilderInstruction3rc(@Nonnull Opcode opcode,
     @Override public int getStartRegister() { return startRegister; }
     @Override public int getRegisterCount() { return registerCount; }
     @Nonnull @Override public Reference getReference() { return reference; }
+    @Override public int getReferenceType() { return opcode.referenceType; }
 
     @Override public Format getFormat() { return FORMAT; }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/iface/instruction/ReferenceInstruction.java
Patch:
@@ -37,4 +37,5 @@
 
 public interface ReferenceInstruction extends Instruction {
     @Nonnull Reference getReference();
+    int getReferenceType();
 }

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction20bc.java
Patch:
@@ -33,6 +33,7 @@
 
 import org.jf.dexlib2.Format;
 import org.jf.dexlib2.Opcode;
+import org.jf.dexlib2.ReferenceType;
 import org.jf.dexlib2.iface.instruction.formats.Instruction20bc;
 import org.jf.dexlib2.iface.reference.Reference;
 import org.jf.dexlib2.immutable.reference.ImmutableReference;
@@ -67,6 +68,7 @@ public static ImmutableInstruction20bc of(Instruction20bc instruction) {
 
     @Override public int getVerificationError() { return verificationError; }
     @Nonnull @Override public ImmutableReference getReference() { return reference; }
+    @Override public int getReferenceType() { return ReferenceType.getReferenceType(reference); }
 
     @Override public Format getFormat() { return FORMAT; }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction21c.java
Patch:
@@ -67,6 +67,7 @@ public static ImmutableInstruction21c of(Instruction21c instruction) {
 
     @Override public int getRegisterA() { return registerA; }
     @Nonnull @Override public ImmutableReference getReference() { return reference; }
+    @Override public int getReferenceType() { return opcode.referenceType; }
 
     @Override public Format getFormat() { return FORMAT; }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction22c.java
Patch:
@@ -72,6 +72,7 @@ public static ImmutableInstruction22c of(Instruction22c instruction) {
     @Override public int getRegisterA() { return registerA; }
     @Override public int getRegisterB() { return registerB; }
     @Nonnull @Override public ImmutableReference getReference() { return reference; }
+    @Override public int getReferenceType() { return opcode.referenceType; }
 
     @Override public Format getFormat() { return FORMAT; }
 }
\ No newline at end of file

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction31c.java
Patch:
@@ -67,6 +67,7 @@ public static ImmutableInstruction31c of(Instruction31c instruction) {
 
     @Override public int getRegisterA() { return registerA; }
     @Nonnull @Override public ImmutableReference getReference() { return reference; }
+    @Override public int getReferenceType() { return opcode.referenceType; }
 
     @Override public Format getFormat() { return FORMAT; }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction35c.java
Patch:
@@ -92,6 +92,7 @@ public static ImmutableInstruction35c of(Instruction35c instruction) {
     @Override public int getRegisterF() { return registerF; }
     @Override public int getRegisterG() { return registerG; }
     @Nonnull @Override public ImmutableReference getReference() { return reference; }
+    @Override public int getReferenceType() { return opcode.referenceType; }
 
     @Override public Format getFormat() { return FORMAT; }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction3rc.java
Patch:
@@ -73,6 +73,7 @@ public static ImmutableInstruction3rc of(Instruction3rc instruction) {
     @Override public int getStartRegister() { return startRegister; }
     @Override public int getRegisterCount() { return registerCount; }
     @Nonnull @Override public ImmutableReference getReference() { return reference; }
+    @Override public int getReferenceType() { return opcode.referenceType; }
 
     @Override public Format getFormat() { return FORMAT; }
 }

File: dexlib2/src/test/java/org/jf/dexlib2/writer/JumboStringConversionTest.java
Patch:
@@ -37,6 +37,7 @@
 import com.google.common.collect.Lists;
 import org.jf.dexlib2.Opcode;
 import org.jf.dexlib2.Opcodes;
+import org.jf.dexlib2.ReferenceType;
 import org.jf.dexlib2.builder.MethodImplementationBuilder;
 import org.jf.dexlib2.builder.instruction.BuilderInstruction10x;
 import org.jf.dexlib2.builder.instruction.BuilderInstruction21c;
@@ -136,6 +137,8 @@ public void testJumboStringConversion_NonMethodBuilder() throws IOException {
                     return ref;
                 }
 
+                @Override public int getReferenceType() { return ReferenceType.STRING; }
+
                 @Override public Opcode getOpcode() {
                     return Opcode.CONST_STRING;
                 }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedDexFile.java
Patch:
@@ -184,7 +184,7 @@ public int getFieldIdItemOffset(int fieldIndex) {
 
     public int getMethodIdItemOffset(int methodIndex) {
         if (methodIndex < 0 || methodIndex >= methodCount) {
-            throw new InvalidItemIndex(methodIndex, "Method findex out of bounds: %d", methodIndex);
+            throw new InvalidItemIndex(methodIndex, "Method index out of bounds: %d", methodIndex);
         }
         return methodStartOffset + methodIndex*MethodIdItem.ITEM_SIZE;
     }

File: dexlib2/src/main/java/org/jf/dexlib2/iface/instruction/formats/UnknownInstruction.java
Patch:
@@ -32,5 +32,5 @@
 package org.jf.dexlib2.iface.instruction.formats;
 
 public interface UnknownInstruction extends Instruction10x {
-    short getOriginalOpcode();
+    int getOriginalOpcode();
 }

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableUnknownInstruction.java
Patch:
@@ -38,9 +38,9 @@
 public class ImmutableUnknownInstruction extends ImmutableInstruction implements UnknownInstruction {
     public static final Format FORMAT = Format.Format10x;
 
-    protected final short originalOpcode;
+    protected final int originalOpcode;
 
-    public ImmutableUnknownInstruction(short originalOpcode) {
+    public ImmutableUnknownInstruction(int originalOpcode) {
         super(Opcode.NOP);
         this.originalOpcode = originalOpcode;
     }
@@ -53,5 +53,5 @@ public static ImmutableUnknownInstruction of(UnknownInstruction instruction) {
     }
 
     @Override public Format getFormat() { return FORMAT; }
-    @Override public short getOriginalOpcode() { return originalOpcode; }
+    @Override public int getOriginalOpcode() { return originalOpcode; }
 }

File: baksmali/src/test/java/org/jf/baksmali/AnalysisTest.java
Patch:
@@ -104,7 +104,8 @@ public void runTest(String test, boolean registerInfo) throws IOException, URISy
                     className.substring(1, className.length() - 1));
             String smaliContents = readResource(smaliPath);
 
-            Assert.assertEquals(smaliContents.replace("\r\n", "\n"), stringWriter.toString().replace("\r\n", "\n"));
+            Assert.assertEquals(smaliContents.replace("\r", "").replace("\n", System.lineSeparator()),
+                    stringWriter.toString().replace("\r", "").replace("\n", System.lineSeparator()));
         }
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/writer/DexWriter.java
Patch:
@@ -236,7 +236,7 @@ private void updateSignature(@Nonnull DexDataStore dataStore) throws IOException
         }
 
         byte[] buffer = new byte[4 * 1024];
-        InputStream input = dataStore.readAt(HeaderItem.HEADER_SIZE_OFFSET);
+        InputStream input = dataStore.readAt(HeaderItem.SIGNATURE_DATA_START_OFFSET);
         int bytesRead = input.read(buffer);
         while (bytesRead >= 0) {
             md.update(buffer, 0, bytesRead);
@@ -258,7 +258,7 @@ private void updateChecksum(@Nonnull DexDataStore dataStore) throws IOException
         Adler32 a32 = new Adler32();
 
         byte[] buffer = new byte[4 * 1024];
-        InputStream input = dataStore.readAt(HeaderItem.SIGNATURE_OFFSET);
+        InputStream input = dataStore.readAt(HeaderItem.CHECKSUM_DATA_START_OFFSET);
         int bytesRead = input.read(buffer);
         while (bytesRead >= 0) {
             a32.update(buffer, 0, bytesRead);

File: dexlib2/src/main/java/org/jf/dexlib2/writer/builder/BuilderTypeListPool.java
Patch:
@@ -55,7 +55,7 @@ class BuilderTypeListPool implements TypeListSection<BuilderTypeReference, Build
     }
 
     @Nonnull public BuilderTypeList internTypeList(@Nullable List<? extends CharSequence> types) {
-        if (types == null) {
+        if (types == null || types.size() == 0) {
             return BuilderTypeList.EMPTY;
         }
 
@@ -76,7 +76,7 @@ class BuilderTypeListPool implements TypeListSection<BuilderTypeReference, Build
     }
 
     @Override public int getNullableItemOffset(@Nullable BuilderTypeList key) {
-        return key==null?DexWriter.NO_OFFSET:key.offset;
+        return (key==null||key.size()==0)?DexWriter.NO_OFFSET:key.offset;
     }
 
     @Nonnull @Override

File: dexlib2/src/main/java/org/jf/dexlib2/builder/MutableMethodImplementation.java
Patch:
@@ -528,7 +528,7 @@ private void convertAndSetInstruction(@Nonnull MethodLocation location, int[] co
                 setInstruction(location, newBuilderInstruction21ih((Instruction21ih)instruction));
                 return;
             case Format21lh:
-                setInstruction(location, newBuilderInstruction10x((Instruction10x)instruction));
+                setInstruction(location, newBuilderInstruction21lh((Instruction21lh)instruction));
                 return;
             case Format21s:
                 setInstruction(location, newBuilderInstruction21s((Instruction21s)instruction));

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/debug/ImmutableStartLocal.java
Patch:
@@ -67,8 +67,8 @@ public static ImmutableStartLocal of(@Nonnull StartLocal startLocal) {
         return new ImmutableStartLocal(
                 startLocal.getCodeAddress(),
                 startLocal.getRegister(),
-                startLocal.getType(),
                 startLocal.getName(),
+                startLocal.getType(),
                 startLocal.getSignature());
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/builder/MutableMethodImplementation.java
Patch:
@@ -589,8 +589,10 @@ private void convertAndSetInstruction(@Nonnull MethodLocation location, int[] co
             case SparseSwitchPayload:
                 setInstruction(location,
                         newBuilderSparseSwitchPayload(location, codeAddressToIndex, (SparseSwitchPayload)instruction));
+                return;
             case ArrayPayload:
                 setInstruction(location, newBuilderArrayPayload((ArrayPayload)instruction));
+                return;
             default:
                 throw new ExceptionWithContext("Instruction format %s not supported", instruction.getOpcode().format);
         }

File: dexlib2/src/main/java/org/jf/dexlib2/builder/MutableMethodImplementation.java
Patch:
@@ -662,15 +662,15 @@ private BuilderInstruction21ih newBuilderInstruction21ih(@Nonnull Instruction21i
         return new BuilderInstruction21ih(
                 instruction.getOpcode(),
                 instruction.getRegisterA(),
-                instruction.getHatLiteral());
+                instruction.getNarrowLiteral());
     }
 
     @Nonnull
     private BuilderInstruction21lh newBuilderInstruction21lh(@Nonnull Instruction21lh instruction) {
         return new BuilderInstruction21lh(
                 instruction.getOpcode(),
                 instruction.getRegisterA(),
-                instruction.getHatLiteral());
+                instruction.getWideLiteral());
     }
 
     @Nonnull

File: baksmali/src/test/java/org/jf/baksmali/AnalysisTest.java
Patch:
@@ -104,7 +104,7 @@ public void runTest(String test, boolean registerInfo) throws IOException, URISy
                     className.substring(1, className.length() - 1));
             String smaliContents = readResource(smaliPath);
 
-            Assert.assertEquals(smaliContents, stringWriter.toString().replace("\r\n", "\n"));
+            Assert.assertEquals(smaliContents.replace("\r\n", "\n"), stringWriter.toString().replace("\r\n", "\n"));
         }
     }
 

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/ClassDefinition.java
Patch:
@@ -263,7 +263,7 @@ private Set<String> writeDirectMethods(IndentingWriter writer) throws IOExceptio
 
             MethodImplementation methodImpl = method.getImplementation();
             if (methodImpl == null) {
-                MethodDefinition.writeEmptyMethodTo(methodWriter, method);
+                MethodDefinition.writeEmptyMethodTo(methodWriter, method, options);
             } else {
                 MethodDefinition methodDefinition = new MethodDefinition(this, method, methodImpl);
                 methodDefinition.writeTo(methodWriter);
@@ -308,7 +308,7 @@ private void writeVirtualMethods(IndentingWriter writer, Set<String> directMetho
 
             MethodImplementation methodImpl = method.getImplementation();
             if (methodImpl == null) {
-                MethodDefinition.writeEmptyMethodTo(methodWriter, method);
+                MethodDefinition.writeEmptyMethodTo(methodWriter, method, options);
             } else {
                 MethodDefinition methodDefinition = new MethodDefinition(this, method, methodImpl);
                 methodDefinition.writeTo(methodWriter);

File: dexlib2/src/main/java/org/jf/dexlib2/builder/BuilderDebugItem.java
Patch:
@@ -33,14 +33,12 @@
 
 import org.jf.dexlib2.iface.debug.DebugItem;
 
-import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
 public abstract class BuilderDebugItem implements DebugItem {
     @Nullable MethodLocation location;
 
-    public BuilderDebugItem(@Nonnull MethodLocation location) {
-        this.location = location;
+    public BuilderDebugItem() {
     }
 
     @Override public int getCodeAddress() {

File: baksmali/src/test/java/org/jf/baksmali/AnalysisTest.java
Patch:
@@ -104,7 +104,7 @@ public void runTest(String test, boolean registerInfo) throws IOException, URISy
                     className.substring(1, className.length() - 1));
             String smaliContents = readResource(smaliPath);
 
-            Assert.assertEquals(smaliContents, stringWriter.toString());
+            Assert.assertEquals(smaliContents, stringWriter.toString().replace("\r\n", "\n"));
         }
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/builder/instruction/BuilderInstruction3rc.java
Patch:
@@ -36,7 +36,6 @@
 import org.jf.dexlib2.builder.BuilderInstruction;
 import org.jf.dexlib2.iface.instruction.formats.Instruction3rc;
 import org.jf.dexlib2.iface.reference.Reference;
-import org.jf.dexlib2.immutable.reference.ImmutableReferenceFactory;
 import org.jf.dexlib2.util.Preconditions;
 
 import javax.annotation.Nonnull;
@@ -56,7 +55,7 @@ public BuilderInstruction3rc(@Nonnull Opcode opcode,
         super(opcode);
         this.startRegister = Preconditions.checkShortRegister(startRegister);
         this.registerCount = Preconditions.checkRegisterRangeCount(registerCount);
-        this.reference = ImmutableReferenceFactory.of(opcode.referenceType, reference);
+        this.reference = reference;
     }
 
     @Override public int getStartRegister() { return startRegister; }

File: dexlib2/src/main/java/org/jf/dexlib2/builder/instruction/BuilderSwitchElement.java
Patch:
@@ -24,6 +24,6 @@ public BuilderSwitchElement(@Nonnull BuilderSwitchPayload parent,
     }
 
     @Override public int getOffset() {
-        return parent.getReferrer().getCodeAddress() - target.getCodeAddress();
+        return target.getCodeAddress() - parent.getReferrer().getCodeAddress();
     }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/raw/util/DexAnnotator.java
Patch:
@@ -53,6 +53,8 @@ public class DexAnnotator extends AnnotatedBytes {
 
     static {
         int[] sectionOrder = new int[] {
+                ItemType.MAP_LIST,
+
                 ItemType.HEADER_ITEM,
                 ItemType.STRING_ID_ITEM,
                 ItemType.TYPE_ID_ITEM,
@@ -66,7 +68,6 @@ public class DexAnnotator extends AnnotatedBytes {
                 ItemType.CODE_ITEM,
                 ItemType.DEBUG_INFO_ITEM,
 
-                ItemType.MAP_LIST,
                 ItemType.TYPE_LIST,
                 ItemType.ANNOTATION_SET_REF_LIST,
                 ItemType.ANNOTATION_SET_ITEM,

File: dexlib2/src/main/java/org/jf/dexlib2/writer/ClassSection.java
Patch:
@@ -31,6 +31,7 @@
 
 package org.jf.dexlib2.writer;
 
+import org.jf.dexlib2.builder.MutableMethodImplementation;
 import org.jf.dexlib2.iface.ExceptionHandler;
 import org.jf.dexlib2.iface.TryBlock;
 import org.jf.dexlib2.iface.debug.DebugItem;
@@ -78,6 +79,7 @@ public interface ClassSection<StringKey extends CharSequence, TypeKey extends Ch
     @Nullable Iterable<? extends Instruction> getInstructions(@Nonnull MethodKey key);
     @Nonnull List<? extends TryBlock<? extends ExceptionHandler>> getTryBlocks(@Nonnull MethodKey key);
     @Nullable TypeKey getExceptionType(@Nonnull ExceptionHandler handler);
+    @Nonnull MutableMethodImplementation makeMutableMethodImplementation(@Nonnull MethodKey key);
 
     void setEncodedArrayOffset(@Nonnull ClassKey key, int offset);
     int getEncodedArrayOffset(@Nonnull ClassKey key);

File: dexlib2/src/main/java/org/jf/dexlib2/writer/StringSection.java
Patch:
@@ -37,4 +37,5 @@
 
 public interface StringSection<StringKey, StringRef extends StringReference> extends NullableIndexSection<StringKey> {
     int getItemIndex(@Nonnull StringRef key);
+    boolean hasJumboIndexes();
 }

File: dexlib2/src/main/java/org/jf/dexlib2/writer/io/MemoryDeferredOutputStream.java
Patch:
@@ -53,7 +53,7 @@ public MemoryDeferredOutputStream(int bufferSize) {
         int remaining = remaining();
         int written = 0;
         while (length - written > 0) {
-            int toWrite = Math.min(remaining, length);
+            int toWrite = Math.min(remaining, (length - written));
             System.arraycopy(bytes, offset + written, currentBuffer, currentPosition, toWrite);
             written += toWrite;
             currentPosition += toWrite;

File: dexlib2/src/main/java/org/jf/dexlib2/writer/ClassSection.java
Patch:
@@ -91,8 +91,5 @@ public interface ClassSection<StringKey extends CharSequence, TypeKey extends Ch
     void setCodeItemOffset(@Nonnull MethodKey key, int offset);
     int getCodeItemOffset(@Nonnull MethodKey key);
 
-    void setDebugItemOffset(@Nonnull MethodKey key, int offset);
-    int getDebugItemOffset(@Nonnull MethodKey key);
-
     void writeDebugItem(@Nonnull DebugWriter<StringKey, TypeKey> writer, DebugItem debugItem) throws IOException;
 }

File: dexlib2/src/main/java/org/jf/dexlib2/writer/builder/BuilderMethod.java
Patch:
@@ -49,7 +49,6 @@ public class BuilderMethod extends BaseMethodReference implements Method {
 
     int annotationSetRefListOffset = DexWriter.NO_OFFSET;
     int codeItemOffset = DexWriter.NO_OFFSET;
-    int debugInfoOffset = DexWriter.NO_OFFSET;
 
     BuilderMethod(@Nonnull BuilderMethodReference methodReference,
                   @Nonnull List<? extends BuilderMethodParameter> parameters,

File: dexlib2/src/main/java/org/jf/dexlib2/writer/pool/DexPool.java
Patch:
@@ -40,10 +40,12 @@
 import org.jf.dexlib2.iface.value.*;
 import org.jf.dexlib2.immutable.instruction.ImmutableInstructionFactory;
 import org.jf.dexlib2.writer.DexWriter;
+import org.jf.dexlib2.writer.io.FileDataStore;
 import org.jf.dexlib2.writer.pool.ProtoPool.Key;
 import org.jf.util.ExceptionWithContext;
 
 import javax.annotation.Nonnull;
+import java.io.File;
 import java.io.IOException;
 import java.util.Collection;
 import java.util.Set;
@@ -86,7 +88,7 @@ public static void writeTo(@Nonnull String path, @Nonnull org.jf.dexlib2.iface.D
         for (ClassDef classDef: input.getClasses()) {
             ((ClassPool)dexPool.classSection).intern(classDef);
         }
-        dexPool.writeTo(path);
+        dexPool.writeTo(new FileDataStore(new File(path)));
     }
 
     @Override protected void writeEncodedValue(@Nonnull InternalEncodedValueWriter writer,

File: dexlib2/src/main/java/org/jf/dexlib2/writer/pool/PoolMethod.java
Patch:
@@ -48,7 +48,6 @@ class PoolMethod extends BaseMethodReference implements Method {
     @Nonnull private final Method method;
     protected int annotationSetRefListOffset = DexPool.NO_OFFSET;
     protected int codeItemOffset = DexPool.NO_OFFSET;
-    protected int debugInfoOffset = DexPool.NO_OFFSET;
 
     public static final Function<Method, PoolMethod> TRANSFORM = new Function<Method, PoolMethod>() {
         @Override public PoolMethod apply(Method method) {

File: dexlib2/src/main/java/org/jf/dexlib2/builder/MethodLocation.java
Patch:
@@ -22,8 +22,7 @@ public class MethodLocation {
     private List<Label> labels = Lists.newArrayList();
     List<BuilderDebugItem> debugItems = Lists.newArrayList();
 
-    MethodLocation(@Nullable BuilderInstruction instruction,
-    int codeAddress, int index) {
+    MethodLocation(@Nullable BuilderInstruction instruction, int codeAddress, int index) {
         this.instruction = instruction;
         this.codeAddress = codeAddress;
         this.index = index;

File: dexlib2/src/main/java/org/jf/dexlib2/builder/instruction/BuilderInstruction10t.java
Patch:
@@ -33,6 +33,7 @@
 
 import org.jf.dexlib2.Format;
 import org.jf.dexlib2.Opcode;
+import org.jf.dexlib2.builder.BuilderOffsetInstruction;
 import org.jf.dexlib2.builder.Label;
 import org.jf.dexlib2.iface.instruction.formats.Instruction10t;
 

File: dexlib2/src/main/java/org/jf/dexlib2/builder/instruction/BuilderInstruction20t.java
Patch:
@@ -33,6 +33,7 @@
 
 import org.jf.dexlib2.Format;
 import org.jf.dexlib2.Opcode;
+import org.jf.dexlib2.builder.BuilderOffsetInstruction;
 import org.jf.dexlib2.builder.Label;
 import org.jf.dexlib2.iface.instruction.formats.Instruction20t;
 

File: dexlib2/src/main/java/org/jf/dexlib2/builder/instruction/BuilderInstruction21t.java
Patch:
@@ -33,6 +33,7 @@
 
 import org.jf.dexlib2.Format;
 import org.jf.dexlib2.Opcode;
+import org.jf.dexlib2.builder.BuilderOffsetInstruction;
 import org.jf.dexlib2.builder.Label;
 import org.jf.dexlib2.iface.instruction.formats.Instruction21t;
 import org.jf.dexlib2.util.Preconditions;

File: dexlib2/src/main/java/org/jf/dexlib2/builder/instruction/BuilderInstruction22t.java
Patch:
@@ -33,6 +33,7 @@
 
 import org.jf.dexlib2.Format;
 import org.jf.dexlib2.Opcode;
+import org.jf.dexlib2.builder.BuilderOffsetInstruction;
 import org.jf.dexlib2.builder.Label;
 import org.jf.dexlib2.iface.instruction.formats.Instruction22t;
 import org.jf.dexlib2.util.Preconditions;

File: dexlib2/src/main/java/org/jf/dexlib2/builder/instruction/BuilderInstruction30t.java
Patch:
@@ -33,6 +33,7 @@
 
 import org.jf.dexlib2.Format;
 import org.jf.dexlib2.Opcode;
+import org.jf.dexlib2.builder.BuilderOffsetInstruction;
 import org.jf.dexlib2.builder.Label;
 import org.jf.dexlib2.iface.instruction.formats.Instruction30t;
 

File: dexlib2/src/main/java/org/jf/dexlib2/builder/instruction/BuilderInstruction31t.java
Patch:
@@ -33,6 +33,7 @@
 
 import org.jf.dexlib2.Format;
 import org.jf.dexlib2.Opcode;
+import org.jf.dexlib2.builder.BuilderOffsetInstruction;
 import org.jf.dexlib2.builder.Label;
 import org.jf.dexlib2.iface.instruction.formats.Instruction31t;
 import org.jf.dexlib2.util.Preconditions;

File: dexlib2/src/main/java/org/jf/dexlib2/writer/pool/ClassPool.java
Patch:
@@ -59,8 +59,7 @@
 
 public class ClassPool implements ClassSection<CharSequence, CharSequence,
         TypeListPool.Key<? extends Collection<? extends CharSequence>>, PoolClassDef, Field, PoolMethod,
-        Set<? extends Annotation>,
-        EncodedValue> {
+        Set<? extends Annotation>, EncodedValue> {
     @Nonnull private HashMap<String, PoolClassDef> internedItems = Maps.newHashMap();
 
     @Nonnull private final StringPool stringPool;

File: dexlib2/src/main/java/org/jf/dexlib2/writer/util/InstructionWriteUtil.java
Patch:
@@ -53,8 +53,7 @@
 import java.util.HashMap;
 import java.util.List;
 
-public class InstructionWriteUtil<StringRef extends StringReference,
-        BaseReference extends Reference> {
+public class InstructionWriteUtil<StringRef extends StringReference, BaseReference extends Reference> {
     private final StringIndexProvider<StringRef> stringIndexProvider;
     private final InstructionFactory<BaseReference> instructionFactory;
     private final Iterable<? extends Instruction> originalInstructions;

File: dexlib2/src/main/java/org/jf/dexlib2/writer/ClassSection.java
Patch:
@@ -31,6 +31,7 @@
 
 package org.jf.dexlib2.writer;
 
+import org.jf.dexlib2.iface.ExceptionHandler;
 import org.jf.dexlib2.iface.TryBlock;
 import org.jf.dexlib2.iface.debug.DebugItem;
 
@@ -42,8 +43,7 @@
 import java.util.Map;
 
 public interface ClassSection<StringKey extends CharSequence, TypeKey extends CharSequence, TypeListKey, ClassKey,
-        FieldKey, MethodKey, AnnotationSetKey, EncodedValue, Insn,
-        ExceptionHandler extends org.jf.dexlib2.iface.ExceptionHandler> extends IndexSection<ClassKey> {
+        FieldKey, MethodKey, AnnotationSetKey, EncodedValue, Insn> extends IndexSection<ClassKey> {
     @Nonnull Collection<? extends ClassKey> getSortedClasses();
 
     @Nullable Map.Entry<? extends ClassKey, Integer> getClassEntryByType(@Nullable TypeKey key);

File: dexlib2/src/main/java/org/jf/dexlib2/writer/builder/DexBuilder.java
Patch:
@@ -56,7 +56,7 @@
 public class DexBuilder extends DexWriter<BuilderStringReference, BuilderStringReference, BuilderTypeReference,
         BuilderTypeReference, BuilderProtoReference, BuilderFieldReference, BuilderMethodReference, BuilderReference,
         BuilderClassDef, BuilderAnnotation, BuilderAnnotationSet, BuilderTypeList, BuilderField, BuilderMethod,
-        BuilderEncodedValue, BuilderAnnotationElement, BuilderInstruction, BuilderExceptionHandler> {
+        BuilderEncodedValue, BuilderAnnotationElement, BuilderInstruction> {
 
     private final BuilderContext context;
 

File: dexlib2/src/main/java/org/jf/dexlib2/writer/pool/ClassPool.java
Patch:
@@ -60,7 +60,7 @@
 public class ClassPool implements ClassSection<CharSequence, CharSequence,
         TypeListPool.Key<? extends Collection<? extends CharSequence>>, PoolClassDef, Field, PoolMethod,
         Set<? extends Annotation>,
-        EncodedValue, Instruction, ExceptionHandler> {
+        EncodedValue, Instruction> {
     @Nonnull private HashMap<String, PoolClassDef> internedItems = Maps.newHashMap();
 
     @Nonnull private final StringPool stringPool;

File: dexlib2/src/main/java/org/jf/dexlib2/writer/pool/DexPool.java
Patch:
@@ -50,7 +50,7 @@ public class DexPool extends DexWriter<CharSequence, StringReference, CharSequen
         FieldReference, MethodReference, Reference, PoolClassDef,
         Annotation, Set<? extends Annotation>,
         TypeListPool.Key<? extends Collection<? extends CharSequence>>, Field, PoolMethod,
-        EncodedValue, AnnotationElement, Instruction, ExceptionHandler> {
+        EncodedValue, AnnotationElement, Instruction> {
 
     public static DexPool makeDexPool() {
         return makeDexPool(15);

File: dexlib2/src/main/java/org/jf/dexlib2/iface/debug/SetSourceFile.java
Patch:
@@ -31,8 +31,11 @@
 
 package org.jf.dexlib2.iface.debug;
 
+import org.jf.dexlib2.iface.reference.StringReference;
+
 import javax.annotation.Nullable;
 
 public interface SetSourceFile extends DebugItem {
     @Nullable String getSourceFile();
+    @Nullable StringReference getSourceFileReference();
 }

File: dexlib2/src/main/java/org/jf/dexlib2/writer/ClassSection.java
Patch:
@@ -32,6 +32,7 @@
 package org.jf.dexlib2.writer;
 
 import org.jf.dexlib2.iface.TryBlock;
+import org.jf.dexlib2.iface.debug.DebugItem;
 
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
@@ -41,7 +42,7 @@
 import java.util.Map;
 
 public interface ClassSection<StringKey extends CharSequence, TypeKey extends CharSequence, TypeListKey, ClassKey,
-        FieldKey, MethodKey, AnnotationSetKey, EncodedValue, DebugItem, Insn,
+        FieldKey, MethodKey, AnnotationSetKey, EncodedValue, Insn,
         ExceptionHandler extends org.jf.dexlib2.iface.ExceptionHandler> extends IndexSection<ClassKey> {
     @Nonnull Collection<? extends ClassKey> getSortedClasses();
 

File: dexlib2/src/main/java/org/jf/dexlib2/writer/DexWriter.java
Patch:
@@ -40,6 +40,7 @@
 import org.jf.dexlib2.dexbacked.raw.*;
 import org.jf.dexlib2.iface.Annotation;
 import org.jf.dexlib2.iface.TryBlock;
+import org.jf.dexlib2.iface.debug.DebugItem;
 import org.jf.dexlib2.iface.debug.LineNumber;
 import org.jf.dexlib2.iface.instruction.Instruction;
 import org.jf.dexlib2.iface.instruction.formats.*;
@@ -75,7 +76,6 @@ public abstract class DexWriter<
         TypeListKey,
         FieldKey, MethodKey,
         EncodedValue, AnnotationElement,
-        DebugItem extends org.jf.dexlib2.iface.debug.DebugItem,
         Insn extends Instruction, ExceptionHandler extends org.jf.dexlib2.iface.ExceptionHandler> {
     public static final int NO_INDEX = -1;
     public static final int NO_OFFSET = 0;
@@ -116,7 +116,7 @@ public abstract class DexWriter<
     protected final FieldSection<StringKey, TypeKey, FieldRefKey, FieldKey> fieldSection;
     protected final MethodSection<StringKey, TypeKey, ProtoKey, MethodRefKey, MethodKey> methodSection;
     protected final ClassSection<StringKey, TypeKey, TypeListKey, ClassKey, FieldKey, MethodKey, AnnotationSetKey,
-            EncodedValue, DebugItem, Insn, ExceptionHandler> classSection;
+            EncodedValue, Insn, ExceptionHandler> classSection;
     
     protected final TypeListSection<TypeKey, TypeListKey> typeListSection;
     protected final AnnotationSection<StringKey, TypeKey, AnnotationKey, AnnotationElement, EncodedValue> annotationSection;
@@ -130,7 +130,7 @@ protected DexWriter(int api,
                         FieldSection<StringKey, TypeKey, FieldRefKey, FieldKey> fieldSection,
                         MethodSection<StringKey, TypeKey, ProtoKey, MethodRefKey, MethodKey> methodSection,
                         ClassSection<StringKey, TypeKey, TypeListKey, ClassKey, FieldKey, MethodKey, AnnotationSetKey,
-                                EncodedValue, DebugItem, Insn, ExceptionHandler> classSection,
+                                EncodedValue, Insn, ExceptionHandler> classSection,
                         TypeListSection<TypeKey, TypeListKey> typeListSection,
                         AnnotationSection<StringKey, TypeKey, AnnotationKey, AnnotationElement,
                                 EncodedValue> annotationSection,

File: dexlib2/src/main/java/org/jf/dexlib2/writer/pool/ClassPool.java
Patch:
@@ -60,7 +60,7 @@
 public class ClassPool implements ClassSection<CharSequence, CharSequence,
         TypeListPool.Key<? extends Collection<? extends CharSequence>>, PoolClassDef, Field, PoolMethod,
         Set<? extends Annotation>,
-        EncodedValue, DebugItem, Instruction, ExceptionHandler> {
+        EncodedValue, Instruction, ExceptionHandler> {
     @Nonnull private HashMap<String, PoolClassDef> internedItems = Maps.newHashMap();
 
     @Nonnull private final StringPool stringPool;

File: dexlib2/src/main/java/org/jf/dexlib2/writer/pool/DexPool.java
Patch:
@@ -33,7 +33,6 @@
 
 import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.*;
-import org.jf.dexlib2.iface.debug.DebugItem;
 import org.jf.dexlib2.iface.instruction.Instruction;
 import org.jf.dexlib2.iface.reference.*;
 import org.jf.dexlib2.iface.value.*;
@@ -51,7 +50,7 @@ public class DexPool extends DexWriter<CharSequence, StringReference, CharSequen
         FieldReference, MethodReference, Reference, PoolClassDef,
         Annotation, Set<? extends Annotation>,
         TypeListPool.Key<? extends Collection<? extends CharSequence>>, Field, PoolMethod,
-        EncodedValue, AnnotationElement, DebugItem, Instruction, ExceptionHandler> {
+        EncodedValue, AnnotationElement, Instruction, ExceptionHandler> {
 
     public static DexPool makeDexPool() {
         return makeDexPool(15);

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction22cs.java
Patch:
@@ -43,7 +43,7 @@ public class ImmutableInstruction22cs extends ImmutableInstruction implements In
 
     protected final int registerA;
     protected final int registerB;
-    @Nonnull protected final int fieldOffset;
+    protected final int fieldOffset;
 
     public ImmutableInstruction22cs(@Nonnull Opcode opcode,
                                    int registerA,

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction35mi.java
Patch:
@@ -47,7 +47,7 @@ public class ImmutableInstruction35mi extends ImmutableInstruction implements In
     protected final int registerE;
     protected final int registerF;
     protected final int registerG;
-    @Nonnull protected final int inlineIndex;
+    protected final int inlineIndex;
 
     public ImmutableInstruction35mi(@Nonnull Opcode opcode,
                                     int registerCount,

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction35ms.java
Patch:
@@ -47,7 +47,7 @@ public class ImmutableInstruction35ms extends ImmutableInstruction implements In
     protected final int registerE;
     protected final int registerF;
     protected final int registerG;
-    @Nonnull protected final int vtableIndex;
+    protected final int vtableIndex;
 
     public ImmutableInstruction35ms(@Nonnull Opcode opcode,
                                     int registerCount,

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction3rmi.java
Patch:
@@ -43,7 +43,6 @@ public class ImmutableInstruction3rmi extends ImmutableInstruction implements In
 
     protected final int startRegister;
     protected final int registerCount;
-
     protected final int inlineIndex;
 
     public ImmutableInstruction3rmi(@Nonnull Opcode opcode,

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction3rms.java
Patch:
@@ -43,7 +43,6 @@ public class ImmutableInstruction3rms extends ImmutableInstruction implements In
 
     protected final int startRegister;
     protected final int registerCount;
-
     protected final int vtableIndex;
 
     public ImmutableInstruction3rms(@Nonnull Opcode opcode,

File: dexlib2/src/main/java/org/jf/dexlib2/util/Preconditions.java
Patch:
@@ -118,7 +118,7 @@ public static int checkByteCodeOffset(int offset) {
     }
 
     public static int checkShortCodeOffset(int offset) {
-        if (offset < -32768 || offset > 32768) {
+        if (offset < -32768 || offset > 32767) {
             throw new IllegalArgumentException(
                     String.format("Invalid code offset: %d. Must be between -32768 and 32767, inclusive.", offset));
         }

File: dexlib2/src/main/java/org/jf/dexlib2/Opcode.java
Patch:
@@ -317,7 +317,7 @@ private static int minApi(int api) {
     }
 
     private static int maxApi(int api) {
-        return 0xFFFF | (api << 16);
+        return api << 16;
     }
 
     public final short value;

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/MethodAnalyzer.java
Patch:
@@ -1454,8 +1454,8 @@ private void analyzeExecuteInlineRange(@Nonnull AnalyzedInstruction analyzedInst
             deodexedOpcode = Opcode.INVOKE_VIRTUAL_RANGE;
         }
 
-        Instruction3rc deodexedInstruction = new ImmutableInstruction3rc(deodexedOpcode, instruction.getRegisterCount(),
-                instruction.getStartRegister(), resolvedMethod);
+        Instruction3rc deodexedInstruction = new ImmutableInstruction3rc(deodexedOpcode, instruction.getStartRegister(),
+                instruction.getRegisterCount(), resolvedMethod);
 
         analyzedInstruction.setDeodexedInstruction(deodexedInstruction);
         analyzeInstruction(analyzedInstruction);

File: dexlib2/src/main/java/org/jf/dexlib2/writer/DexWriter.java
Patch:
@@ -666,7 +666,7 @@ private void writeAnnotationDirectories(@Nonnull DexDataWriter writer) throws IO
             for (MethodKey method: methods) {
                 int offset = classSection.getAnnotationSetRefListOffset(method);
                 if (offset != DexWriter.NO_OFFSET) {
-                    methodAnnotations++;
+                    parameterAnnotations++;
                     tempBuffer.putInt(methodSection.getMethodIndex(method));
                     tempBuffer.putInt(offset);
                 }

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/Debug/LineNumberMethodItem.java
Patch:
@@ -48,7 +48,7 @@ public LineNumberMethodItem(int codeAddress, int sortOrder, @Nonnull LineNumber
     @Override
     public boolean writeTo(IndentingWriter writer) throws IOException {
         writer.write(".line ");
-        writer.printSignedIntAsDec(lineNumber);
+        writer.printUnsignedIntAsDec(lineNumber);
         return true;
     }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/util/DebugInfo.java
Patch:
@@ -99,8 +99,7 @@ public DebugInfoImpl(@Nonnull DexBackedDexFile dexFile,
         @Override
         public Iterator<DebugItem> iterator() {
             DexReader reader = dexFile.readerAt(debugInfoOffset);
-            // TODO: this unsigned value could legitimally be > MAX_INT
-            final int lineNumberStart = reader.readSmallUleb128();
+            final int lineNumberStart = reader.readBigUleb128();
             int registerCount = methodImpl.getRegisterCount();
 
             //TODO: does dalvik allow references to invalid registers?

File: dexlib2/src/main/java/org/jf/dexlib2/DexFileFactory.java
Patch:
@@ -35,6 +35,7 @@
 import org.jf.dexlib2.dexbacked.DexBackedDexFile;
 import org.jf.dexlib2.dexbacked.DexBackedOdexFile;
 import org.jf.dexlib2.iface.DexFile;
+import org.jf.dexlib2.writer.pool.DexPool;
 import org.jf.util.ExceptionWithContext;
 
 import javax.annotation.Nonnull;
@@ -111,7 +112,7 @@ public static DexBackedDexFile loadDexFile(File dexFile, @Nonnull Opcodes opcode
     }
 
     public static void writeDexFile(String path, DexFile dexFile) throws IOException {
-        org.jf.dexlib2.writer.pool.DexPool.writeTo(path, dexFile);
+        DexPool.writeTo(path, dexFile);
     }
 
     private DexFileFactory() {}

File: dexlib2/src/main/java/org/jf/dexlib2/writer/pool/DexPool.java
Patch:
@@ -88,8 +88,6 @@ public static void writeTo(@Nonnull String path, @Nonnull org.jf.dexlib2.iface.D
         for (ClassDef classDef: input.getClasses()) {
             ((ClassPool)dexPool.classSection).intern(classDef);
         }
-        /*System.out.println("here");
-        while(true);*/
         dexPool.writeTo(path);
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/raw/DebugInfoItem.java
Patch:
@@ -63,7 +63,7 @@ public void annotateItem(@Nonnull AnnotatedBytes out, int itemIndex, @Nullable S
                     out.indent();
                     for (int i=0; i<parametersSize; i++) {
                         int paramaterIndex = reader.readSmallUleb128() - 1;
-                        out.annotateTo(reader.getOffset(),
+                        out.annotateTo(reader.getOffset(), "%s",
                                 StringIdItem.getOptionalReferenceAnnotation(dexFile, paramaterIndex, true));
                     }
                     out.deindent();

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/raw/CodeItem.java
Patch:
@@ -273,7 +273,7 @@ private void annotateDefaultInstruction(@Nonnull AnnotatedBytes out, @Nonnull In
                 } else if (instruction instanceof OffsetInstruction) {
                     int offset = ((OffsetInstruction)instruction).getCodeOffset();
                     String sign = offset>=0?"+":"-";
-                    args.add(String.format("%s0x%x", sign, offset));
+                    args.add(String.format("%s0x%x", sign, Math.abs(offset)));
                 } else if (instruction instanceof NarrowLiteralInstruction) {
                     int value = ((NarrowLiteralInstruction)instruction).getNarrowLiteral();
                     if (NumberUtils.isLikelyFloat(value)) {

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/MethodAnalyzer.java
Patch:
@@ -1590,8 +1590,8 @@ private boolean analyzeInvokeVirtualQuick(@Nonnull AnalyzedInstruction analyzedI
                 opcode = Opcode.INVOKE_VIRTUAL_RANGE;
             }
 
-            deodexedInstruction = new ImmutableInstruction3rc(opcode, instruction.getRegisterCount(),
-                    instruction.getStartRegister(), resolvedMethod);
+            deodexedInstruction = new ImmutableInstruction3rc(opcode, instruction.getStartRegister(),
+                    instruction.getRegisterCount(), resolvedMethod);
         } else {
             Instruction35ms instruction = (Instruction35ms)analyzedInstruction.instruction;
             Opcode opcode;

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedOdexFile.java
Patch:
@@ -123,7 +123,7 @@ private static void verifyMagic(byte[] buf) {
     }
 
     public int getVersion() {
-        return HeaderItem.getVersion(getBuf(), 0);
+        return OdexHeaderItem.getVersion(odexBuf);
     }
 
     public static class NotAnOdexFile extends RuntimeException {

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/raw/HeaderItem.java
Patch:
@@ -219,7 +219,7 @@ private static String getEndianText(int endianTag) {
         return "Invalid";
     }
 
-    public static int getVersion(byte[] buf, int offset) {
+    private static int getVersion(byte[] buf, int offset) {
         if (buf.length - offset < 8) {
             return 0;
         }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedClassDef.java
Patch:
@@ -417,7 +417,7 @@ private int getInstanceFieldsOffset() {
             return instanceFieldsOffset;
         }
         DexReader reader = new DexReader(dexFile, staticFieldsOffset);
-        DexBackedField.skipAllFields(reader, staticFieldCount);
+        DexBackedField.skipFields(reader, staticFieldCount);
         instanceFieldsOffset = reader.getOffset();
         return instanceFieldsOffset;
     }
@@ -427,7 +427,7 @@ private int getDirectMethodsOffset() {
             return directMethodsOffset;
         }
         DexReader reader = dexFile.readerAt(getInstanceFieldsOffset());
-        DexBackedField.skipAllFields(reader, instanceFieldCount);
+        DexBackedField.skipFields(reader, instanceFieldCount);
         directMethodsOffset = reader.getOffset();
         return directMethodsOffset;
     }
@@ -437,7 +437,7 @@ private int getVirtualMethodsOffset() {
             return virtualMethodsOffset;
         }
         DexReader reader = dexFile.readerAt(getDirectMethodsOffset());
-        DexBackedField.skipAllFields(reader, instanceFieldCount);
+        DexBackedMethod.skipMethods(reader, directMethodCount);
         virtualMethodsOffset = reader.getOffset();
         return virtualMethodsOffset;
     }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedField.java
Patch:
@@ -114,7 +114,7 @@ public Set<? extends DexBackedAnnotation> getAnnotations() {
      * @param reader The reader to skip
      * @param count The number of encoded_field structures to skip over
      */
-    public static void skipAllFields(@Nonnull DexReader reader, int count) {
+    public static void skipFields(@Nonnull DexReader reader, int count) {
         for (int i=0; i<count; i++) {
             reader.skipUleb128();
             reader.skipUleb128();

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/MethodDefinition.java
Patch:
@@ -230,10 +230,10 @@ private static void writeParameters(IndentingWriter writer, Method method,
             if (parameterName != null || annotations.size() != 0) {
                 writer.write(".param p");
                 writer.printSignedIntAsDec(registerNumber);
+
                 if (parameterName != null) {
                     writer.write(", ");
-                    // TODO: does dalvik allow non-identifier parameter and/or local names?
-                    writer.write(parameterName);
+                    ReferenceFormatter.writeStringReference(writer, parameterName);
                 }
                 writer.write("    # ");
                 writer.write(parameterType);

File: dexlib2/src/main/java/org/jf/dexlib2/base/reference/BaseMethodReference.java
Patch:
@@ -33,6 +33,7 @@
 
 import com.google.common.collect.Ordering;
 import org.jf.dexlib2.iface.reference.MethodReference;
+import org.jf.util.CharSequenceUtils;
 import org.jf.util.CollectionUtils;
 
 import javax.annotation.Nonnull;
@@ -54,7 +55,7 @@ public boolean equals(@Nullable Object o) {
             return getDefiningClass().equals(other.getDefiningClass()) &&
                    getName().equals(other.getName()) &&
                    getReturnType().equals(other.getReturnType()) &&
-                   getParameterTypes().equals(other.getParameterTypes());
+                   CharSequenceUtils.listEquals(getParameterTypes(), other.getParameterTypes());
         }
         return false;
     }

File: dexlib2/src/main/java/org/jf/dexlib2/iface/reference/TypeReference.java
Patch:
@@ -69,7 +69,7 @@ public interface TypeReference extends Reference, CharSequence, Comparable<CharS
     /**
      * Compares this TypeReference to another TypeReference, or more generally to another CharSequence for equality.
      *
-     * This TypeReference is equal to a CharSequence iff this.getType().equals(other.getString()).
+     * This TypeReference is equal to a CharSequence iff this.getType().equals(other.toString()).
      *
      * Equivalently, This TypeReference is equal to another TypeReference iff this.getType().equals(other.getType()).
      *

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/raw/ClassDefItem.java
Patch:
@@ -75,7 +75,7 @@ protected void annotateItem(@Nonnull AnnotatedBytes out, int itemIndex, @Nullabl
                 out.annotate(4, "access_flags = 0x%x: %s", accessFlags,
                         Joiner.on('|').join(AccessFlags.getAccessFlagsForClass(accessFlags)));
 
-                int superclassIndex = dexFile.readSmallUint(out.getCursor());
+                int superclassIndex = dexFile.readOptionalUint(out.getCursor());
                 out.annotate(4, "superclass_idx = %s",
                         TypeIdItem.getOptionalReferenceAnnotation(dexFile, superclassIndex));
 

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/MethodAnalyzer.java
Patch:
@@ -1486,7 +1486,7 @@ private void analyzeInvokeObjectInitRange(@Nonnull AnalyzedInstruction analyzedI
         Instruction3rc instruction = (Instruction3rc)analyzedInstruction.instruction;
 
         Instruction3rc deodexedInstruction = new ImmutableInstruction3rc(Opcode.INVOKE_DIRECT_RANGE,
-                instruction.getRegisterCount(), instruction.getStartRegister(), instruction.getReference());
+                instruction.getStartRegister(), instruction.getRegisterCount(), instruction.getReference());
 
         analyzedInstruction.setDeodexedInstruction(deodexedInstruction);
 

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/ClassPath.java
Patch:
@@ -178,7 +178,7 @@ private static DexFile loadClassPathEntry(Iterable<String> classPathDirs, String
             for (String ext: new String[]{"", ".odex", ".jar", ".apk", ".zip"}) {
                 File file = new File(classPathDir, baseEntryName + ext);
 
-                if (file.exists()) {
+                if (file.exists() && file.isFile()) {
                     if (!file.canRead()) {
                         System.err.println(String.format(
                                 "warning: cannot open %s for reading. Will continue looking.", file.getPath()));

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/PostInstructionRegisterInfoMethodItem.java
Patch:
@@ -75,8 +75,8 @@ public boolean writeTo(IndentingWriter writer) throws IOException {
 
     private void addDestRegs(BitSet printPostRegister, int registerCount) {
         for (int registerNum=0; registerNum<registerCount; registerNum++) {
-            if (analyzedInstruction.getPreInstructionRegisterType(registerNum) !=
-                    analyzedInstruction.getPostInstructionRegisterType(registerNum)) {
+            if (!analyzedInstruction.getPreInstructionRegisterType(registerNum).equals(
+                    analyzedInstruction.getPostInstructionRegisterType(registerNum))) {
                 printPostRegister.set(registerNum);
             }
         }

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/PreInstructionRegisterInfoMethodItem.java
Patch:
@@ -151,7 +151,7 @@ private void addMergeRegs(BitSet registers, int registerCount) {
             RegisterType mergedRegisterType = analyzedInstruction.getPreInstructionRegisterType(registerNum);
 
             for (AnalyzedInstruction predecessor: analyzedInstruction.getPredecessors()) {
-                if (predecessor.getPostInstructionRegisterType(registerNum) != mergedRegisterType) {
+                if (!predecessor.getPostInstructionRegisterType(registerNum).equals(mergedRegisterType)) {
                     registers.set(registerNum);
                 }
             }
@@ -178,7 +178,7 @@ private boolean writeFullMergeRegs(IndentingWriter writer, BitSet registers, int
             for (AnalyzedInstruction predecessor: analyzedInstruction.getPredecessors()) {
                 RegisterType predecessorRegisterType = predecessor.getPostInstructionRegisterType(registerNum);
                 if (predecessorRegisterType.category != RegisterType.UNKNOWN &&
-                        predecessorRegisterType != mergedRegisterType) {
+                        !predecessorRegisterType.equals(mergedRegisterType)) {
 
                     addRegister = true;
                     break;

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/AnalyzedInstruction.java
Patch:
@@ -176,7 +176,7 @@ protected boolean mergeRegister(int registerNumber, RegisterType registerType, B
         RegisterType oldRegisterType = preRegisterMap[registerNumber];
         RegisterType mergedRegisterType = oldRegisterType.merge(registerType);
 
-        if (mergedRegisterType == oldRegisterType) {
+        if (mergedRegisterType.equals(oldRegisterType)) {
             return false;
         }
 
@@ -218,7 +218,7 @@ protected boolean setPostRegisterType(int registerNumber, RegisterType registerT
          assert registerType != null;
 
          RegisterType oldRegisterType = postRegisterMap[registerNumber];
-         if (oldRegisterType == registerType) {
+         if (oldRegisterType.equals(registerType)) {
              return false;
          }
 
@@ -277,7 +277,7 @@ public boolean setsRegister(int registerNumber) {
                 return false;
             }
             //check if the uninit ref has been copied to another register
-            if (getPreInstructionRegisterType(registerNumber) == preInstructionDestRegisterType) {
+            if (getPreInstructionRegisterType(registerNumber).equals(preInstructionDestRegisterType)) {
                 return true;
             }
             return false;

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/MethodAnalyzer.java
Patch:
@@ -1253,7 +1253,7 @@ private void analyzeInvokeDirectCommon(@Nonnull AnalyzedInstruction analyzedInst
                 if (preInstructionRegisterType.category == RegisterType.UNINIT_REF ||
                         preInstructionRegisterType.category == RegisterType.UNINIT_THIS) {
                     RegisterType registerType;
-                    if (preInstructionRegisterType == objectRegisterType) {
+                    if (preInstructionRegisterType.equals(objectRegisterType)) {
                         registerType = analyzedInstruction.postRegisterMap[objectRegister];
                     } else {
                         registerType = preInstructionRegisterType;

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/RegisterType.java
Patch:
@@ -264,7 +264,7 @@ public static RegisterType getRegisterTypeForLiteral(int literalValue) {
 
     @Nonnull
     public RegisterType merge(@Nonnull RegisterType other) {
-        if (other == this) {
+        if (other.equals(this)) {
             return this;
         }
 

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/MethodAnalyzer.java
Patch:
@@ -144,7 +144,6 @@ private void analyze() {
         //if this isn't a static method, determine which register is the "this" register and set the type to the
         //current class
         if (!MethodUtil.isStatic(method)) {
-            nonParameterRegisters--;
             int thisRegister = totalRegisters - parameterRegisters;
 
             //if this is a constructor, then set the "this" register to an uninitialized reference of the current class

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/MethodAnalyzer.java
Patch:
@@ -142,7 +142,7 @@ private void analyze() {
         //current class
         if (!MethodUtil.isStatic(method)) {
             nonParameterRegisters--;
-            int thisRegister = totalRegisters - parameterRegisters - 1;
+            int thisRegister = totalRegisters - parameterRegisters;
 
             //if this is a constructor, then set the "this" register to an uninitialized reference of the current class
             if (MethodUtil.isConstructor(method)) {

File: dexlib2/src/main/java/org/jf/dexlib2/analysis/MethodAnalyzer.java
Patch:
@@ -1029,7 +1029,7 @@ private void analyzeMoveException(@Nonnull AnalyzedInstruction analyzedInstructi
             }
         }
 
-        if (exceptionType == null) {
+        if (exceptionType.category == RegisterType.UNKNOWN) {
             throw new AnalysisException("move-exception must be the first instruction in an exception handler block");
         }
 

File: dexlib2/src/main/java/org/jf/dexlib2/writer/util/InstructionWriteUtil.java
Patch:
@@ -205,7 +205,7 @@ private void findCodeOffsetShifts() {
                     int codeOffsetDelta = codeOffsetShift(currentCodeOffset);
                     if ((currentCodeOffset+codeOffsetDelta)%2 != 0) {
                         if (codeOffsetShifts.contains(currentCodeOffset)) {
-                            codeOffsetShifts.remove(codeOffsetDelta);
+                            codeOffsetShifts.remove(codeOffsetDelta-1);
                             offsetToNewInstructionMap.remove(currentCodeOffset);
                         } else {
                             codeOffsetShifts.add(codeOffsetDelta, currentCodeOffset);

File: dexlib2/src/main/java/org/jf/dexlib2/writer/util/InstructionWriteUtil.java
Patch:
@@ -193,7 +193,7 @@ private void findCodeOffsetShifts() {
                 } else if (instruction.getOpcode().format.equals(Format.Format20t) && !offsetToNewInstructionMap.containsKey(currentCodeOffset)) {
                     int targetOffset = ((Instruction20t)instruction).getCodeOffset();
                     int codeOffsetDelta = codeOffsetShift(currentCodeOffset);
-                    int newTargetOffset = targetOffsetShift(currentCodeOffset, targetOffset);
+                    int newTargetOffset = targetOffset + targetOffsetShift(currentCodeOffset, targetOffset);
                     if ((short)newTargetOffset != newTargetOffset) {
                         codeOffsetShifts.add(codeOffsetDelta, currentCodeOffset+instruction.getCodeUnits());
                         offsetToNewInstructionMap.put(currentCodeOffset, Format.Format30t);

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/raw/MapItem.java
Patch:
@@ -96,7 +96,7 @@ protected void annotateItem(@Nonnull AnnotatedBytes out, int itemIndex, @Nullabl
                 int mapItemCount = dexFile.readSmallUint(out.getCursor());
                 out.annotate(4, "size = %d", mapItemCount);
 
-                super.annotateSectionInner(out);
+                super.annotateSectionInner(out, mapItemCount);
             }
         };
     }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/raw/SectionAnnotator.java
Patch:
@@ -68,10 +68,10 @@ public SectionAnnotator(@Nonnull DexAnnotator annotator, @Nonnull MapItem mapIte
      */
     public void annotateSection(@Nonnull AnnotatedBytes out) {
         out.moveTo(sectionOffset);
-        annotateSectionInner(out);
+        annotateSectionInner(out, itemCount);
     }
 
-    protected void annotateSectionInner(@Nonnull AnnotatedBytes out) {
+    protected void annotateSectionInner(@Nonnull AnnotatedBytes out, int itemCount) {
         String itemName = getItemName();
         int itemAlignment = getItemAlignment();
         if (itemCount > 0) {

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/raw/util/DexAnnotator.java
Patch:
@@ -130,6 +130,9 @@ public DexAnnotator(@Nonnull RawDexFile dexFile, int width) {
                 case ItemType.STRING_DATA_ITEM:
                     annotators.put(mapItem.getType(), StringDataItem.makeAnnotator(this, mapItem));
                     break;
+                case ItemType.DEBUG_INFO_ITEM:
+                    annotators.put(mapItem.getType(), DebugInfoItem.makeAnnotator(this, mapItem));
+                    break;
                 case ItemType.ANNOTATION_ITEM:
                     annotators.put(mapItem.getType(), AnnotationItem.makeAnnotator(this, mapItem));
                     break;

File: baksmali/src/main/java/org/jf/baksmali/dump.java
Patch:
@@ -41,7 +41,6 @@ public static void dump(DexBackedDexFile dexFile, String dumpFileName)
         if (dumpFileName != null) {
             FileWriter writer = null;
 
-
             try {
                 writer = new FileWriter(dumpFileName);
 
@@ -50,7 +49,7 @@ public static void dump(DexBackedDexFile dexFile, String dumpFileName)
                     consoleWidth = 120;
                 }
 
-                dexFile.dumpTo(writer, consoleWidth);
+                dexFile.asRaw().dumpTo(writer, consoleWidth);
             } catch (IOException ex) {
                 System.err.println("There was an error while dumping the dex file to " + dumpFileName);
                 ex.printStackTrace(System.err);

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedMethod.java
Patch:
@@ -34,6 +34,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterators;
 import org.jf.dexlib2.base.reference.BaseMethodReference;
+import org.jf.dexlib2.dexbacked.raw.TypeListItem;
 import org.jf.dexlib2.dexbacked.util.AnnotationsDirectory;
 import org.jf.dexlib2.dexbacked.util.FixedSizeList;
 import org.jf.dexlib2.dexbacked.util.ParameterIterator;
@@ -161,9 +162,8 @@ public Iterator<String> getParameterNames() {
     public List<String> getParameterTypes() {
         final int parametersOffset = getParametersOffset();
         if (parametersOffset > 0) {
-            final int parameterCount = dexFile.readSmallUint(parametersOffset +
-                    DexBackedDexFile.Impl.TYPE_LIST_SIZE_OFFSET);
-            final int paramListStart = parametersOffset + DexBackedDexFile.Impl.TYPE_LIST_LIST_OFFSET;
+            final int parameterCount = dexFile.readSmallUint(parametersOffset + TypeListItem.SIZE_OFFSET);
+            final int paramListStart = parametersOffset + TypeListItem.LIST_OFFSET;
             return new FixedSizeList<String>() {
                 @Nonnull
                 @Override

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/reference/DexBackedMethodReference.java
Patch:
@@ -36,6 +36,7 @@
 import org.jf.dexlib2.dexbacked.DexBackedDexFile;
 import org.jf.dexlib2.dexbacked.raw.MethodIdItem;
 import org.jf.dexlib2.dexbacked.raw.ProtoIdItem;
+import org.jf.dexlib2.dexbacked.raw.TypeListItem;
 import org.jf.dexlib2.dexbacked.util.FixedSizeList;
 
 import javax.annotation.Nonnull;
@@ -69,9 +70,8 @@ public List<String> getParameterTypes() {
         int protoIdItemOffset = getProtoIdItemOffset();
         final int parametersOffset = dexFile.readSmallUint(protoIdItemOffset + ProtoIdItem.PARAMETERS_OFFSET);
         if (parametersOffset > 0) {
-            final int parameterCount = dexFile.readSmallUint(parametersOffset +
-                    DexBackedDexFile.Impl.TYPE_LIST_SIZE_OFFSET);
-            final int paramListStart = parametersOffset + DexBackedDexFile.Impl.TYPE_LIST_LIST_OFFSET;
+            final int parameterCount = dexFile.readSmallUint(parametersOffset + TypeListItem.SIZE_OFFSET);
+            final int paramListStart = parametersOffset + TypeListItem.LIST_OFFSET;
             return new FixedSizeList<String>() {
                 @Nonnull
                 @Override

File: dexlib2/src/main/java/org/jf/dexlib2/iface/Method.java
Patch:
@@ -60,7 +60,7 @@ public interface Method extends MethodReference {
     @Override @Nonnull String getName();
 
     /**
-     * Gets a list of the types of the parameters of this method.
+     * Gets a list of the parameters of this method.
      *
      * As per the MethodReference interface, the MethodParameter objects contained in the returned list also act
      * as a simple reference to the type of the parameter. However, the MethodParameter object can also contain
@@ -70,7 +70,7 @@ public interface Method extends MethodReference {
      *
      * @return A list of MethodParameter objects, representing the parameters of this method.
      */
-    @Override @Nonnull List<? extends MethodParameter> getParameters();
+    @Nonnull List<? extends MethodParameter> getParameters();
 
     /**
      * Gets the return type of this method.

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/ImmutableMethod.java
Patch:
@@ -105,6 +105,7 @@ public static ImmutableMethod of(Method method) {
 
     @Nonnull public String getDefiningClass() { return definingClass; }
     @Nonnull public String getName() { return name; }
+    @Nonnull public ImmutableList<? extends CharSequence> getParameterTypes() { return parameters; }
     @Nonnull public ImmutableList<? extends ImmutableMethodParameter> getParameters() { return parameters; }
     @Nonnull public String getReturnType() { return returnType; }
     public int getAccessFlags() { return accessFlags; }

File: dexlib2/src/main/java/org/jf/dexlib2/util/MethodUtil.java
Patch:
@@ -34,7 +34,6 @@
 import org.jf.dexlib2.AccessFlags;
 import org.jf.dexlib2.iface.Method;
 import org.jf.dexlib2.iface.reference.MethodReference;
-import org.jf.dexlib2.iface.reference.TypeReference;
 
 import javax.annotation.Nonnull;
 
@@ -52,8 +51,8 @@ public static boolean isStatic(@Nonnull Method method) {
 
     public static int getParameterRegisterCount(@Nonnull MethodReference methodRef, boolean isStatic) {
         int regCount = 0;
-        for (TypeReference param: methodRef.getParameters()) {
-            int firstChar = param.getType().charAt(0);
+        for (CharSequence paramType: methodRef.getParameterTypes()) {
+            int firstChar = paramType.charAt(0);
             if (firstChar == 'J' || firstChar == 'D') {
                 regCount += 2;
             } else {

File: dexlib2/src/main/java/org/jf/dexlib2/util/SyntheticAccessorResolver.java
Patch:
@@ -146,6 +146,6 @@ private static boolean methodReferenceEquals(@Nonnull MethodReference ref1, @Non
         // we already know the containing class matches
         return ref1.getName().equals(ref2.getName()) &&
                ref1.getReturnType().equals(ref2.getReturnType()) &&
-               ref1.getParameters().equals(ref2.getParameters());
+               ref1.getParameterTypes().equals(ref2.getParameterTypes());
     }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/util/DebugInfo.java
Patch:
@@ -56,7 +56,7 @@ public abstract class DebugInfo implements Iterable<DebugItem> {
     public static DebugInfo newOrEmpty(@Nonnull DexBuffer dexBuf, int debugInfoOffset,
                                        @Nonnull DexBackedMethodImplementation methodImpl) {
         if (debugInfoOffset == 0) {
-            new EmptyDebugInfo(methodImpl.method);
+            return new EmptyDebugInfo(methodImpl.method);
         }
         return new DebugInfoImpl(dexBuf, debugInfoOffset, methodImpl);
     }

File: dexlib2/src/main/java/org/jf/dexlib2/writer/AnnotationDirectoryPool.java
Patch:
@@ -266,7 +266,7 @@ public boolean equals(Object o) {
         public int compareTo(Key o) {
             // compareTo will only be called on keys of the same internability. An internable key will not be compared
             // with a non-internable one.
-            if (hasClassAnnotations()) {
+            if (hasNonClassAnnotations()) {
                 return classDef.getType().compareTo(o.classDef.getType());
             }
             return CollectionUtils.compareAsSet(classDef.getAnnotations(), o.classDef.getAnnotations());

File: dexlib2/src/main/java/org/jf/dexlib2/writer/ProtoPool.java
Patch:
@@ -168,7 +168,7 @@ public boolean equals(@Nullable Object o) {
         public int compareTo(@Nonnull Key o) {
             int res = getReturnType().compareTo(o.getReturnType());
             if (res != 0) return res;
-            return CollectionUtils.compareAsList(getParameters(), o.getParameters());
+            return CollectionUtils.compareAsIterable(getParameters(), o.getParameters());
         }
     }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/writer/DexFile.java
Patch:
@@ -207,9 +207,9 @@ private void writeTo(@Nonnull String path) throws IOException {
             try {
                 stringPool.write(indexWriter, offsetWriter);
                 typePool.write(indexWriter);
-                fieldPool.write(indexWriter);
                 typeListPool.write(offsetWriter);
                 protoPool.write(indexWriter);
+                fieldPool.write(indexWriter);
                 methodPool.write(indexWriter);
                 encodedArrayPool.write(offsetWriter);
                 annotationPool.write(offsetWriter);

File: dexlib2/src/main/java/org/jf/dexlib2/writer/AnnotationDirectoryPool.java
Patch:
@@ -152,7 +152,7 @@ public void write(@Nonnull DexWriter writer) throws IOException {
                 writer.writeInt(dexFile.annotationSetPool.getOffset(field.getAnnotations()));
             }
 
-            boolean sortMethods = CollectionUtils.isNaturalSortedSet(key.classDef.getMethods());
+            boolean sortMethods = !CollectionUtils.isNaturalSortedSet(key.classDef.getMethods());
             Iterable<? extends Method> methodsWithAnnotations = null;
             if (sortMethods) {
                 methodsWithAnnotations = Lists.newArrayList(key.getMethodsWithAnnotations());

File: dexlib2/src/main/java/org/jf/dexlib2/base/reference/BaseMethodReference.java
Patch:
@@ -66,6 +66,6 @@ public int compareTo(@Nonnull MethodReference o) {
         if (res != 0) return res;
         res = getReturnType().compareTo(o.getReturnType());
         if (res != 0) return res;
-        return CollectionUtils.compareAsList(getParameters(), o.getParameters());
+        return CollectionUtils.compareAsIterable(getParameters(), o.getParameters());
     }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/util/FixedSizeList.java
Patch:
@@ -41,7 +41,7 @@
 public abstract class FixedSizeList<T> extends AbstractList<T> {
     @Override
     public T get(int index) {
-        if (index < 0 || index > size()) {
+        if (index < 0 || index >= size()) {
             throw new IndexOutOfBoundsException();
         }
         return readItem(index);

File: dexlib2/src/main/java/org/jf/dexlib2/writer/AnnotationSetRefPool.java
Patch:
@@ -69,7 +69,7 @@ public void intern(@Nonnull Method method) {
 
     public int getOffset(@Nonnull Method method) {
         Key annotationSetRefKey = new Key(method);
-        Integer offset = internedAnnotationSetRefItems.put(annotationSetRefKey, 0);
+        Integer offset = internedAnnotationSetRefItems.get(annotationSetRefKey);
         if (offset == null) {
             throw new ExceptionWithContext("Annotation set ref not found.");
         }

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/MethodDefinition.java
Patch:
@@ -231,13 +231,12 @@ private static void writeParameters(IndentingWriter writer, Method method,
                 }
                 writer.write("    # ");
                 writer.write(parameterType);
+                writer.write("\n");
                 if (annotations.size() > 0) {
                     writer.indent(4);
                     AnnotationFormatter.writeTo(writer, annotations);
                     writer.deindent(4);
                     writer.write(".end param\n");
-                } else {
-                    writer.write("\n");
                 }
             }
 

File: dexlib2/src/main/java/org/jf/dexlib2/writer/CodeItemPool.java
Patch:
@@ -152,9 +152,8 @@ public void write(@Nonnull DexWriter writer) throws IOException {
                 int maxOutParamCount = 0;
                 int codeUnitCount = 0;
                 for (Instruction instruction: methodImpl.getInstructions()) {
+                    codeUnitCount += instruction.getCodeUnits();
                     if (instruction.getOpcode().referenceType == ReferenceType.METHOD) {
-                        codeUnitCount += instruction.getCodeUnits();
-
                         ReferenceInstruction refInsn = (ReferenceInstruction)instruction;
                         MethodReference methodRef = (MethodReference)refInsn.getReference();
                         int paramCount = MethodUtil.getParameterRegisterCount(methodRef,

File: dexlib2/src/main/java/org/jf/dexlib2/writer/DebugInfoPool.java
Patch:
@@ -135,7 +135,7 @@ public void write(@Nonnull DexWriter writer) throws IOException {
             List<? extends MethodParameter> parameters = method.getParameters();
             writer.writeUleb128(parameters.size());
             for (MethodParameter parameter: parameters) {
-                writer.writeUleb128(dexFile.stringPool.getIndexNullable(parameter.getName()));
+                writer.writeUleb128(dexFile.stringPool.getIndexNullable(parameter.getName())+1);
             }
 
             if (debugItems != null && debugItems.size() > 0) {

File: dexlib2/src/main/java/org/jf/dexlib2/writer/CodeItemPool.java
Patch:
@@ -479,15 +479,15 @@ public void writeFormat32x(@Nonnull DexWriter writer, @Nonnull Instruction32x in
     public void writeFormat35c(@Nonnull DexWriter writer, @Nonnull Instruction35c instruction) throws IOException {
         writer.write(instruction.getOpcode().value);
         writer.write(packNibbles(instruction.getRegisterG(), instruction.getRegisterCount()));
-        writer.write(getReferenceIndex(instruction));
+        writer.writeUshort(getReferenceIndex(instruction));
         writer.write(packNibbles(instruction.getRegisterC(), instruction.getRegisterD()));
         writer.write(packNibbles(instruction.getRegisterE(), instruction.getRegisterF()));
     }
 
     public void writeFormat3rc(@Nonnull DexWriter writer, @Nonnull Instruction3rc instruction) throws IOException {
         writer.write(instruction.getOpcode().value);
         writer.write(instruction.getRegisterCount());
-        writer.write(getReferenceIndex(instruction));
+        writer.writeUshort(getReferenceIndex(instruction));
         writer.writeUshort(instruction.getStartRegister());
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedDexFile.java
Patch:
@@ -81,7 +81,7 @@ public List<DexBackedMapItem> getMap() {
         return new FixedSizeList<DexBackedMapItem>() {
             @Override
             public DexBackedMapItem readItem(int index) {
-                int mapItemOffset = mapOffset + index * DexBuffer.MAP_ITEM_SIZE;
+                int mapItemOffset = mapOffset + 4 + index * DexBuffer.MAP_ITEM_SIZE;
                 return new DexBackedMapItem(dexBuf, mapItemOffset);
             }
 

File: dexlib2/src/main/java/org/jf/dexlib2/writer/MapItem.java
Patch:
@@ -78,7 +78,7 @@ public void write(@Nonnull DexWriter writer) throws IOException {
         writeItem(writer, DexItemType.DEBUG_INFO_ITEM, dexFile.debugInfoPool.getNumItems(), dexFile.debugInfoPool.getSectionOffset());
         writeItem(writer, DexItemType.CODE_ITEM, dexFile.codeItemPool.getNumItems(), dexFile.codeItemPool.getSectionOffset());
         writeItem(writer, DexItemType.CLASS_DATA_ITEM, dexFile.classDefPool.getNumClassDataItems(), dexFile.classDefPool.getDataSectionOffset());
-        writeItem(writer, DexItemType.MAP_LIST, numItems, sectionOffset);
+        writeItem(writer, DexItemType.MAP_LIST, 1, sectionOffset);
     }
 
     private int calcNumItems() {

File: dexlib2/src/main/java/org/jf/dexlib2/iface/MethodImplementation.java
Patch:
@@ -78,6 +78,8 @@ public interface MethodImplementation {
      * This generally matches the semantics of the debug_info_item in the dex specification, although in an easier to
      * digest form.
      *
+     * The addresses of the DebugItems in the returned list will be in non-descending order.
+     *
      * @return A list of DebugInfo items
      */
     @Nonnull Iterable<? extends DebugItem> getDebugItems();

File: dexlib2/src/main/java/org/jf/dexlib2/base/BaseAnnotation.java
Patch:
@@ -65,7 +65,7 @@ public int compareTo(Annotation o) {
         return CollectionUtils.compareAsSet(getElements(), o.getElements());
     }
 
-    public static final Comparator<Annotation> COMPARE_BY_TYPE = new Comparator<Annotation>() {
+    public static final Comparator<Annotation> BY_TYPE = new Comparator<Annotation>() {
         @Override
         public int compare(Annotation annotation1, Annotation annotation2) {
             return annotation1.getType().compareTo(annotation2.getType());

File: dexlib2/src/main/java/org/jf/dexlib2/base/BaseAnnotationElement.java
Patch:
@@ -60,7 +60,7 @@ public int compareTo(AnnotationElement o) {
         return getValue().compareTo(o.getValue());
     }
 
-    public static final Comparator<AnnotationElement> COMPARE_BY_NAME = new Comparator<AnnotationElement>() {
+    public static final Comparator<AnnotationElement> BY_NAME = new Comparator<AnnotationElement>() {
         @Override
         public int compare(@Nonnull AnnotationElement element1, @Nonnull AnnotationElement element2) {
             return element1.getName().compareTo(element2.getName());

File: dexlib2/src/main/java/org/jf/dexlib2/iface/reference/MethodReference.java
Patch:
@@ -31,12 +31,10 @@
 
 package org.jf.dexlib2.iface.reference;
 
-import org.jf.dexlib2.iface.MethodPrototype;
-
 import javax.annotation.Nonnull;
 import java.util.Collection;
 
-public interface MethodReference extends Reference, MethodPrototype {
+public interface MethodReference extends Reference {
     @Nonnull String getContainingClass();
     @Nonnull String getName();
     @Nonnull Collection<? extends TypeReference> getParameters();

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedMethod.java
Patch:
@@ -32,6 +32,7 @@
 package org.jf.dexlib2.dexbacked;
 
 import com.google.common.collect.ImmutableList;
+import org.jf.dexlib2.base.BaseMethodParameter;
 import org.jf.dexlib2.base.reference.BaseMethodReference;
 import org.jf.dexlib2.dexbacked.util.AnnotationsDirectory;
 import org.jf.dexlib2.dexbacked.util.FixedSizeList;
@@ -140,7 +141,7 @@ public List<? extends MethodParameter> getParametersWithoutNames() {
                 @Nonnull
                 @Override
                 public MethodParameter readItem(final int index) {
-                    return new MethodParameter() {
+                    return new BaseMethodParameter() {
                         @Nonnull
                         @Override
                         public String getType() {

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/reference/DexBackedMethodReference.java
Patch:
@@ -33,6 +33,7 @@
 
 import com.google.common.collect.ImmutableList;
 import org.jf.dexlib2.base.reference.BaseMethodReference;
+import org.jf.dexlib2.base.reference.BaseTypeReference;
 import org.jf.dexlib2.dexbacked.DexBuffer;
 import org.jf.dexlib2.dexbacked.util.FixedSizeList;
 import org.jf.dexlib2.iface.reference.TypeReference;
@@ -76,7 +77,7 @@ public List<? extends TypeReference> getParameters() {
                 public TypeReference readItem(final int index) {
                     // Can't use DexBackedTypeReference, because we don't want to read in the type index until it
                     // is asked for
-                    return new TypeReference() {
+                    return new BaseTypeReference() {
                         @Nonnull
                         @Override
                         public String getType() {

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/util/DebugInfo.java
Patch:
@@ -34,6 +34,7 @@
 import com.google.common.collect.Iterators;
 import org.jf.dexlib2.AccessFlags;
 import org.jf.dexlib2.DebugItemType;
+import org.jf.dexlib2.base.BaseMethodParameter;
 import org.jf.dexlib2.dexbacked.DexBackedMethod;
 import org.jf.dexlib2.dexbacked.DexBackedMethodImplementation;
 import org.jf.dexlib2.dexbacked.DexBuffer;
@@ -253,7 +254,7 @@ protected MethodParameter readNextItem(@Nonnull DexReader reader, int index) {
                     }
                     final String name = _name;
 
-                    return new MethodParameter() {
+                    return new BaseMethodParameter() {
                         @Nonnull @Override public String getType() { return methodParameter.getType(); }
                         @Nullable @Override public String getName() { return name; }
                         @Nullable @Override public String getSignature() { return methodParameter.getSignature();}

File: dexlib2/src/main/java/org/jf/dexlib2/iface/reference/StringReference.java
Patch:
@@ -33,6 +33,6 @@
 
 import javax.annotation.Nonnull;
 
-public interface StringReference extends Reference {
+public interface StringReference extends Reference, CharSequence {
     @Nonnull String getString();
 }

File: dexlib2/src/main/java/org/jf/dexlib2/iface/reference/TypeReference.java
Patch:
@@ -33,6 +33,6 @@
 
 import javax.annotation.Nonnull;
 
-public interface TypeReference extends Reference {
+public interface TypeReference extends Reference, CharSequence {
     @Nonnull String getType();
 }

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/ImmutableMethodParameter.java
Patch:
@@ -32,7 +32,7 @@
 package org.jf.dexlib2.immutable;
 
 import com.google.common.collect.ImmutableList;
-import org.jf.dexlib2.base.reference.BaseTypeReference;
+import org.jf.dexlib2.base.BaseMethodParameter;
 import org.jf.dexlib2.iface.Annotation;
 import org.jf.dexlib2.iface.MethodParameter;
 import org.jf.util.ImmutableListConverter;
@@ -43,7 +43,7 @@
 import java.util.Collection;
 import java.util.List;
 
-public class ImmutableMethodParameter extends BaseTypeReference implements MethodParameter {
+public class ImmutableMethodParameter extends BaseMethodParameter {
     @Nonnull public final String type;
     @Nonnull public final ImmutableList<? extends ImmutableAnnotation> annotations;
     @Nullable public final String name;

File: util/src/main/java/org/jf/util/ImmutableListConverter.java
Patch:
@@ -62,7 +62,7 @@ public ImmutableList<ImmutableItem> convert(@Nullable final Iterable<? extends I
         boolean needsCopy = false;
         if (iterable instanceof ImmutableList) {
             for (Item element: iterable) {
-                if (isImmutable(element)) {
+                if (!isImmutable(element)) {
                     needsCopy = true;
                     break;
                 }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedMethodImplementation.java
Patch:
@@ -35,7 +35,7 @@
 import org.jf.dexlib2.dexbacked.instruction.DexBackedInstruction;
 import org.jf.dexlib2.dexbacked.util.DebugInfo;
 import org.jf.dexlib2.dexbacked.util.FixedSizeList;
-import org.jf.dexlib2.dexbacked.util.VariableSizeIterator;
+import org.jf.dexlib2.dexbacked.util.VariableSizeLookaheadIterator;
 import org.jf.dexlib2.iface.MethodImplementation;
 import org.jf.dexlib2.iface.MethodParameter;
 import org.jf.dexlib2.iface.TryBlock;
@@ -79,9 +79,9 @@ public DexBackedMethodImplementation(@Nonnull DexBuffer dexBuf,
         return new Iterable<Instruction>() {
             @Override
             public Iterator<Instruction> iterator() {
-                return new VariableSizeIterator<Instruction>(dexBuf, instructionsStartOffset) {
+                return new VariableSizeLookaheadIterator<Instruction>(dexBuf, instructionsStartOffset) {
                     @Override
-                    protected Instruction readItem(@Nonnull DexReader reader, int index) {
+                    protected Instruction readNextItem(@Nonnull DexReader reader) {
                         if (reader.getOffset() >= endOffset) {
                             return null;
                         }

File: dexlib2/src/main/java/org/jf/dexlib2/iface/reference/MethodReference.java
Patch:
@@ -31,10 +31,12 @@
 
 package org.jf.dexlib2.iface.reference;
 
+import org.jf.dexlib2.iface.MethodPrototype;
+
 import javax.annotation.Nonnull;
 import java.util.List;
 
-public interface MethodReference extends Reference {
+public interface MethodReference extends Reference, MethodPrototype {
     @Nonnull String getContainingClass();
     @Nonnull String getName();
     @Nonnull List<? extends TypeReference> getParameters();

File: dexlib2/src/main/java/org/jf/dexlib2/base/reference/BaseMethodReference.java
Patch:
@@ -31,16 +31,16 @@
 
 package org.jf.dexlib2.base.reference;
 
-import org.jf.dexlib2.iface.reference.BasicMethodParameter;
 import org.jf.dexlib2.iface.reference.MethodReference;
+import org.jf.dexlib2.iface.reference.TypeReference;
 
 import javax.annotation.Nonnull;
 import java.util.List;
 
 public abstract class BaseMethodReference implements MethodReference {
     @Nonnull public abstract String getContainingClass();
     @Nonnull public abstract String getName();
-    @Nonnull public abstract List<? extends BasicMethodParameter> getParameters();
+    @Nonnull public abstract List<? extends TypeReference> getParameters();
     @Nonnull
     public abstract String getReturnType();
 
@@ -61,7 +61,7 @@ public static int hashCode(@Nonnull MethodReference methodRef) {
         int hashCode = methodRef.getContainingClass().hashCode();
         hashCode = hashCode*31 + methodRef.getName().hashCode();
         hashCode = hashCode*31 + methodRef.getReturnType().hashCode();
-        for (BasicMethodParameter param: methodRef.getParameters()) {
+        for (TypeReference param: methodRef.getParameters()) {
             hashCode = hashCode*31 + param.hashCode();
         }
         return hashCode;

File: dexlib2/src/main/java/org/jf/dexlib2/iface/MethodParameter.java
Patch:
@@ -32,13 +32,13 @@
 package org.jf.dexlib2.iface;
 
 import org.jf.dexlib2.iface.debug.LocalInfo;
-import org.jf.dexlib2.iface.reference.BasicMethodParameter;
+import org.jf.dexlib2.iface.reference.TypeReference;
 
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import java.util.List;
 
-public interface MethodParameter extends BasicMethodParameter, LocalInfo {
+public interface MethodParameter extends TypeReference, LocalInfo {
     @Nonnull String getType();
     @Nonnull List<? extends Annotation> getAnnotations();
     @Nullable String getName();

File: dexlib2/src/main/java/org/jf/dexlib2/iface/reference/MethodReference.java
Patch:
@@ -37,6 +37,6 @@
 public interface MethodReference extends Reference {
     @Nonnull String getContainingClass();
     @Nonnull String getName();
-    @Nonnull List<? extends BasicMethodParameter> getParameters();
+    @Nonnull List<? extends TypeReference> getParameters();
     @Nonnull String getReturnType();
 }

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/ImmutableMethodParameter.java
Patch:
@@ -32,7 +32,7 @@
 package org.jf.dexlib2.immutable;
 
 import com.google.common.collect.ImmutableList;
-import org.jf.dexlib2.base.reference.BaseBasicMethodParameter;
+import org.jf.dexlib2.base.reference.BaseTypeReference;
 import org.jf.dexlib2.iface.Annotation;
 import org.jf.dexlib2.iface.MethodParameter;
 import org.jf.util.ImmutableListConverter;
@@ -42,7 +42,7 @@
 import javax.annotation.Nullable;
 import java.util.List;
 
-public class ImmutableMethodParameter extends BaseBasicMethodParameter implements MethodParameter {
+public class ImmutableMethodParameter extends BaseTypeReference implements MethodParameter {
     @Nonnull public final String type;
     @Nonnull public final ImmutableList<? extends ImmutableAnnotation> annotations;
     @Nullable public final String name;

File: dexlib2/src/main/java/org/jf/dexlib2/util/ReferenceUtil.java
Patch:
@@ -31,9 +31,9 @@
 
 package org.jf.dexlib2.util;
 
-import org.jf.dexlib2.iface.reference.BasicMethodParameter;
 import org.jf.dexlib2.iface.reference.FieldReference;
 import org.jf.dexlib2.iface.reference.MethodReference;
+import org.jf.dexlib2.iface.reference.TypeReference;
 
 import java.io.IOException;
 import java.io.Writer;
@@ -46,7 +46,7 @@ public static String getMethodDescriptor(MethodReference methodReference) {
         sb.append("->");
         sb.append(methodReference.getName());
         sb.append('(');
-        for (BasicMethodParameter param: methodReference.getParameters()) {
+        for (TypeReference param: methodReference.getParameters()) {
             sb.append(param.getType());
         }
         sb.append(')');
@@ -59,7 +59,7 @@ public static void writeMethodDescriptor(Writer writer, MethodReference methodRe
         writer.write("->");
         writer.write(methodReference.getName());
         writer.write('(');
-        for (BasicMethodParameter param: methodReference.getParameters()) {
+        for (TypeReference param: methodReference.getParameters()) {
             writer.write(param.getType());
         }
         writer.write(')');

File: dexlib2/src/main/java/org/jf/dexlib2/util/TypeUtils.java
Patch:
@@ -31,6 +31,8 @@
 
 package org.jf.dexlib2.util;
 
+import org.jf.dexlib2.iface.value.EncodedValue;
+
 public class TypeUtils {
     public static boolean isWideType(String type) {
         char c = type.charAt(0);

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction20t.java
Patch:
@@ -56,7 +56,7 @@ public static ImmutableInstruction20t of(Instruction20t instruction) {
         }
         return new ImmutableInstruction20t(
                 instruction.getOpcode(),
-                (byte)instruction.getCodeOffset());
+                instruction.getCodeOffset());
     }
 
     @Override public int getCodeOffset() { return codeOffset; }

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/ClassDefinition.java
Patch:
@@ -100,7 +100,7 @@ public void writeTo(IndentingWriter writer) throws IOException {
     private void writeClass(IndentingWriter writer) throws IOException {
         writer.write(".class ");
         writeAccessFlags(writer);
-        writer.write(classDef.getName());
+        writer.write(classDef.getType());
         writer.write('\n');
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedClassDef.java
Patch:
@@ -68,7 +68,7 @@ public DexBackedClassDef(@Nonnull DexBuffer dexBuf,
 
     @Nonnull
     @Override
-    public String getName() {
+    public String getType() {
         return dexBuf.getType(dexBuf.readSmallUint(classDefOffset + CLASS_NAME_OFFSET));
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedField.java
Patch:
@@ -85,7 +85,7 @@ public String getType() {
         return dexBuf.getType(dexBuf.readUshort(getFieldIdItemOffset() + TYPE_OFFSET));
     }
 
-    @Nonnull @Override public String getContainingClass() { return classDef.getName(); }
+    @Nonnull @Override public String getContainingClass() { return classDef.getType(); }
     @Override public int getAccessFlags() { return accessFlags; }
     @Nullable @Override public EncodedValue getInitialValue() { return initialValue; }
 

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedMethod.java
Patch:
@@ -98,7 +98,7 @@ public DexBackedMethod(@Nonnull DexReader reader,
         this.parameterAnnotationSetListOffset = paramaterAnnotationIterator.seekTo(methodIndex);
     }
 
-    @Nonnull @Override public String getContainingClass() { return classDef.getName(); }
+    @Nonnull @Override public String getContainingClass() { return classDef.getType(); }
     @Override public int getAccessFlags() { return accessFlags; }
 
     @Nonnull

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/util/DebugInfo.java
Patch:
@@ -113,7 +113,7 @@ public Iterator<DebugItem> iterator() {
                 // add the local info for the "this" parameter
                 locals[parameterIndex++] = new LocalInfo() {
                     @Override public String getName() { return "this"; }
-                    @Override public String getType() { return methodImpl.method.classDef.getName(); }
+                    @Override public String getType() { return methodImpl.method.classDef.getType(); }
                     @Override public String getSignature() { return null; }
                 };
             }

File: dexlib2/src/main/java/org/jf/dexlib2/util/MethodUtil.java
Patch:
@@ -39,7 +39,7 @@ public class MethodUtil {
     public static String buildFullMethodString(ClassDef classDef, Method method) {
         //TODO: consider using a cached thread-local StringBuilder
         StringBuilder sb = new StringBuilder();
-        sb.append(classDef.getName());
+        sb.append(classDef.getType());
         sb.append("->");
         sb.append(method.getName());
         sb.append("(");

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/EncodedValue/EncodedValueAdaptor.java
Patch:
@@ -31,6 +31,7 @@
 import org.jf.baksmali.Adaptors.ReferenceFormatter;
 import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.*;
+import org.jf.dexlib2.util.ReferenceUtil;
 import org.jf.util.IndentingWriter;
 import org.jf.baksmali.Renderers.*;
 
@@ -62,7 +63,7 @@ public static void writeTo(IndentingWriter writer, EncodedValue encodedValue) th
                 writer.write(((EnumEncodedValue)encodedValue).getValue());
                 return;
             case ValueType.FIELD:
-                writer.write(((FieldEncodedValue)encodedValue).getValue());
+                ReferenceUtil.writeFieldDescriptor(writer, ((FieldEncodedValue)encodedValue).getValue());
                 return;
             case ValueType.FLOAT:
                 FloatRenderer.writeTo(writer, ((FloatEncodedValue)encodedValue).getValue());
@@ -74,7 +75,7 @@ public static void writeTo(IndentingWriter writer, EncodedValue encodedValue) th
                 LongRenderer.writeTo(writer, ((LongEncodedValue)encodedValue).getValue());
                 return;
             case ValueType.METHOD:
-                writer.write(((MethodEncodedValue)encodedValue).getValue());
+                ReferenceUtil.writeMethodDescriptor(writer, ((MethodEncodedValue)encodedValue).getValue());
                 return;
             case ValueType.NULL:
                 writer.write("null");

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedClassDef.java
Patch:
@@ -149,8 +149,8 @@ protected DexBackedField readItem(@Nonnull DexReader reader, int index) {
                                     previousFieldIndex = 0;
                                     annotationIterator.reset();
                                 }
-                                DexBackedField item = new DexBackedField(reader, previousFieldIndex,
-                                        staticInitialValueIterator, annotationIterator);
+                                DexBackedField item = new DexBackedField(reader, DexBackedClassDef.this,
+                                        previousFieldIndex, staticInitialValueIterator, annotationIterator);
                                 previousFieldIndex = item.fieldIndex;
                                 return item;
                             }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedMethod.java
Patch:
@@ -98,6 +98,7 @@ public DexBackedMethod(@Nonnull DexReader reader,
         this.parameterAnnotationSetListOffset = paramaterAnnotationIterator.seekTo(methodIndex);
     }
 
+    @Nonnull @Override public String getContainingClass() { return classDef.getName(); }
     @Override public int getAccessFlags() { return accessFlags; }
 
     @Nonnull

File: dexlib2/src/main/java/org/jf/dexlib2/iface/Field.java
Patch:
@@ -31,13 +31,15 @@
 
 package org.jf.dexlib2.iface;
 
+import org.jf.dexlib2.iface.reference.FieldReference;
 import org.jf.dexlib2.iface.value.EncodedValue;
 
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import java.util.List;
 
-public interface Field {
+public interface Field extends FieldReference {
+    @Nonnull String getContainingClass();
     @Nonnull String getName();
     @Nonnull String getType();
     int getAccessFlags();

File: dexlib2/src/main/java/org/jf/dexlib2/iface/MethodParameter.java
Patch:
@@ -32,12 +32,13 @@
 package org.jf.dexlib2.iface;
 
 import org.jf.dexlib2.iface.debug.LocalInfo;
+import org.jf.dexlib2.iface.reference.BasicMethodParameter;
 
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import java.util.List;
 
-public interface MethodParameter extends LocalInfo {
+public interface MethodParameter extends LocalInfo, BasicMethodParameter {
     @Nonnull String getType();
     @Nonnull List<? extends Annotation> getAnnotations();
     @Nullable String getName();

File: dexlib2/src/main/java/org/jf/dexlib2/iface/instruction/ReferenceInstruction.java
Patch:
@@ -31,8 +31,10 @@
 
 package org.jf.dexlib2.iface.instruction;
 
+import org.jf.dexlib2.iface.reference.Reference;
+
 import javax.annotation.Nonnull;
 
 public interface ReferenceInstruction extends Instruction {
-    @Nonnull String getReference();
+    @Nonnull Reference getReference();
 }

File: dexlib2/src/main/java/org/jf/dexlib2/iface/instruction/formats/Instruction22c.java
Patch:
@@ -34,5 +34,5 @@
 import org.jf.dexlib2.iface.instruction.ReferenceInstruction;
 import org.jf.dexlib2.iface.instruction.TwoRegisterInstruction;
 
-public interface Instruction22c extends TwoRegisterInstruction, ReferenceInstruction{
+public interface Instruction22c extends TwoRegisterInstruction, ReferenceInstruction {
 }

File: dexlib2/src/main/java/org/jf/dexlib2/iface/value/FieldEncodedValue.java
Patch:
@@ -31,8 +31,10 @@
 
 package org.jf.dexlib2.iface.value;
 
+import org.jf.dexlib2.iface.reference.FieldReference;
+
 import javax.annotation.Nonnull;
 
 public interface FieldEncodedValue extends EncodedValue {
-    @Nonnull String getValue();
+    @Nonnull FieldReference getValue();
 }

File: dexlib2/src/main/java/org/jf/dexlib2/iface/value/MethodEncodedValue.java
Patch:
@@ -31,8 +31,10 @@
 
 package org.jf.dexlib2.iface.value;
 
+import org.jf.dexlib2.iface.reference.MethodReference;
+
 import javax.annotation.Nonnull;
 
 public interface MethodEncodedValue extends EncodedValue {
-    @Nonnull String getValue();
+    @Nonnull MethodReference getValue();
 }

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction.java
Patch:
@@ -34,13 +34,14 @@
 import com.google.common.collect.ImmutableList;
 import org.jf.dexlib2.Format;
 import org.jf.dexlib2.Opcode;
+import org.jf.dexlib2.ReferenceType;
 import org.jf.dexlib2.iface.instruction.Instruction;
 import org.jf.dexlib2.iface.instruction.formats.*;
+import org.jf.dexlib2.iface.reference.FieldReference;
 import org.jf.dexlib2.util.Preconditions;
 import org.jf.util.ImmutableListConverter;
 
 import javax.annotation.Nonnull;
-import java.util.List;
 
 public abstract class ImmutableInstruction implements Instruction {
     @Nonnull public final Opcode opcode;

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/util/AnnotationsDirectory.java
Patch:
@@ -181,7 +181,7 @@ public AnnotationIterator getParameterAnnotationIterator() {
             int methodCount = getMethodAnnotationCount();
             int parameterAnnotationsOffset = directoryOffset + ANNOTATIONS_START_OFFSET +
                     fieldCount * FIELD_ANNOTATION_SIZE +
-                    methodCount + METHOD_ANNOTATION_SIZE;
+                    methodCount * METHOD_ANNOTATION_SIZE;
             return new AnnotationIteratorImpl(parameterAnnotationsOffset, parameterAnnotationCount);
         }
 

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedClassDef.java
Patch:
@@ -206,8 +206,8 @@ protected DexBackedMethod readItem(@Nonnull DexReader reader, int index) {
                                     methodAnnotationIterator.reset();
                                     parameterAnnotationIterator.reset();
                                 }
-                                DexBackedMethod item = new DexBackedMethod(reader, previousMethodIndex,
-                                        methodAnnotationIterator, parameterAnnotationIterator);
+                                DexBackedMethod item = new DexBackedMethod(reader, DexBackedClassDef.this,
+                                        previousMethodIndex, methodAnnotationIterator, parameterAnnotationIterator);
                                 previousMethodIndex = item.methodIndex;
                                 return item;
                             }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/value/DexBackedAnnotationEncodedValue.java
Patch:
@@ -49,7 +49,7 @@ public class DexBackedAnnotationEncodedValue implements AnnotationEncodedValue {
 
     public DexBackedAnnotationEncodedValue(@Nonnull DexReader reader) {
         this.dexBuf = reader.getDexBuffer();
-        this.type = reader.getString(reader.readSmallUleb128());
+        this.type = reader.getType(reader.readSmallUleb128());
         this.elementsOffset = reader.getOffset();
         skipElements(reader);
     }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedClassDef.java
Patch:
@@ -94,7 +94,7 @@ public List<String> getInterfaces() {
                 @Nonnull
                 @Override
                 public String readItem(int index) {
-                    return dexBuf.getType(dexBuf.readSmallUint(interfacesOffset + 4 + (2*index)));
+                    return dexBuf.getType(dexBuf.readUshort(interfacesOffset + 4 + (2*index)));
                 }
 
                 @Override public int size() { return size; }

File: dexlib2/src/main/java/org/jf/dexlib2/Opcode.java
Patch:
@@ -337,9 +337,9 @@ public static Opcode getOpcodeByName(String opcodeName) {
     public static Opcode getOpcodeByValue(int opcodeValue) {
         switch (opcodeValue) {
             case 0x100:
-                return SPARSE_SWITCH_PAYLOAD;
-            case 0x200:
                 return PACKED_SWITCH_PAYLOAD;
+            case 0x200:
+                return SPARSE_SWITCH_PAYLOAD;
             case 0x300:
                 return ARRAY_PAYLOAD;
             default:

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/util/DebugInfo.java
Patch:
@@ -215,9 +215,9 @@ protected DebugItem readItem() {
                                 return new ImmutableSetSourceFile(codeAddress, sourceFile);
                             }
                             default: {
-                                int base = ((next & 0xFF) - 0x0A);
-                                codeAddress += base / 15;
-                                lineNumber += (base % 15) - 4;
+                                int adjusted = next - 0x0A;
+                                codeAddress += adjusted / 15;
+                                lineNumber += (adjusted % 15) - 4;
                                 return new ImmutableLineNumber(codeAddress, lineNumber);
                             }
                         }

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/CatchMethodItem.java
Patch:
@@ -34,13 +34,13 @@
 import java.io.IOException;
 
 public class CatchMethodItem extends MethodItem {
-    private final TypeIdItem exceptionType;
+    private final String exceptionType;
 
     private final LabelMethodItem tryStartLabel;
     private final LabelMethodItem tryEndLabel;
     private final LabelMethodItem handlerLabel;
 
-    public CatchMethodItem(MethodDefinition.LabelCache labelCache, int codeAddress, TypeIdItem exceptionType,
+    public CatchMethodItem(MethodDefinition.LabelCache labelCache, int codeAddress, String exceptionType,
                            int startAddress, int endAddress, int handlerAddress) {
         super(codeAddress);
         this.exceptionType = exceptionType;
@@ -81,7 +81,7 @@ public boolean writeTo(IndentingWriter writer) throws IOException {
             writer.write(".catchall");
         } else {
             writer.write(".catch ");
-            ReferenceFormatter.writeTypeReference(writer, exceptionType);
+            writer.write(exceptionType);
         }
         writer.write(" {");
         tryStartLabel.writeTo(writer);

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/Format/UnresolvedOdexInstructionMethodItem.java
Patch:
@@ -34,7 +34,8 @@
 
 import java.io.IOException;
 
-public class UnresolvedOdexInstructionMethodItem extends InstructionMethodItem<UnresolvedOdexInstruction> {
+//TODO: uncomment
+/*public class UnresolvedOdexInstructionMethodItem extends InstructionMethodItem<UnresolvedOdexInstruction> {
     public UnresolvedOdexInstructionMethodItem(CodeItem codeItem, int codeAddress, UnresolvedOdexInstruction instruction) {
         super(codeItem, codeAddress, instruction);
     }
@@ -49,4 +50,4 @@ private void writeThrowTo(IndentingWriter writer) throws IOException {
         writer.write("throw ");
         writeRegister(writer, instruction.ObjectRegisterNum);
     }
-}
+}*/

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/PostInstructionRegisterInfoMethodItem.java
Patch:
@@ -39,7 +39,8 @@
 import java.io.IOException;
 import java.util.BitSet;
 
-public class PostInstructionRegisterInfoMethodItem extends MethodItem {
+//TODO: uncomment
+/*public class PostInstructionRegisterInfoMethodItem extends MethodItem {
     private final AnalyzedInstruction analyzedInstruction;
     private final MethodAnalyzer methodAnalyzer;
 
@@ -108,4 +109,4 @@ private boolean writeRegisterInfo(IndentingWriter writer, BitSet registers) thro
         }
         return true;
     }
-}
+}*/

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/PreInstructionRegisterInfoMethodItem.java
Patch:
@@ -41,7 +41,8 @@
 import java.io.IOException;
 import java.util.BitSet;
 
-public class PreInstructionRegisterInfoMethodItem extends MethodItem {
+//TODO: uncomment
+/*public class PreInstructionRegisterInfoMethodItem extends MethodItem {
     private final AnalyzedInstruction analyzedInstruction;
     private final MethodAnalyzer methodAnalyzer;
 
@@ -262,4 +263,4 @@ private boolean writeRegisterInfo(IndentingWriter writer, BitSet registers,
         }
         return true;
     }
-}
+}*/

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/SyntheticAccessCommentMethodItem.java
Patch:
@@ -34,7 +34,8 @@
 
 import java.io.IOException;
 
-public class SyntheticAccessCommentMethodItem extends MethodItem {
+//TODO: uncomment
+/*public class SyntheticAccessCommentMethodItem extends MethodItem {
     private final AccessedMember accessedMember;
 
     public SyntheticAccessCommentMethodItem(AccessedMember accessedMember, int codeAddress) {
@@ -59,4 +60,4 @@ public boolean writeTo(IndentingWriter writer) throws IOException {
         ReferenceFormatter.writeReference(writer, accessedMember.accessedMember);
         return true;
     }
-}
+}*/

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedMethod.java
Patch:
@@ -86,7 +86,7 @@ public DexBackedMethod(@Nonnull DexReader reader,
 
         this.name = reader.getString(reader.readSmallUint(methodIdItemOffset + NAME_OFFSET));
 
-        this.returnType = reader.getString(reader.readSmallUint(protoIdItemOffset + RETURN_TYPE_OFFSET));
+        this.returnType = reader.getType(reader.readSmallUint(protoIdItemOffset + RETURN_TYPE_OFFSET));
         this.parametersOffset = reader.readSmallUint(protoIdItemOffset + PARAMETERS_OFFSET);
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedMethodImplementation.java
Patch:
@@ -109,7 +109,7 @@ public int size() {
 
     @Nonnull
     @Override
-    public List<? extends DebugItem> getDebugItems() {
+    public Iterable<? extends DebugItem> getDebugItems() {
         final int debugInfoOffset = dexBuf.readSmallUint(codeOffset + DEBUG_OFFSET_OFFSET);
         if (debugInfoOffset > 0) {
             return new DebugItemList(dexBuf, debugInfoOffset, method);

File: dexlib2/src/main/java/org/jf/dexlib2/iface/MethodImplementation.java
Patch:
@@ -41,5 +41,5 @@ public interface MethodImplementation {
     int getRegisterCount();
     @Nonnull List<? extends Instruction> getInstructions();
     @Nonnull List<? extends TryBlock> getTryBlocks();
-    @Nonnull List<? extends DebugItem> getDebugItems();
+    @Nonnull Iterable<? extends DebugItem> getDebugItems();
 }

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/ImmutableMethodImplementation.java
Patch:
@@ -53,7 +53,7 @@ public class ImmutableMethodImplementation implements MethodImplementation {
     public ImmutableMethodImplementation(int registerCount,
                                          @Nullable List<? extends Instruction> instructions,
                                          @Nullable List<? extends TryBlock> tryBlocks,
-                                         @Nullable List<? extends DebugItem> debugItems) {
+                                         @Nullable Iterable<? extends DebugItem> debugItems) {
         this.registerCount = registerCount;
         this.instructions = ImmutableInstruction.immutableListOf(instructions);
         this.tryBlocks = ImmutableTryBlock.immutableListOf(tryBlocks);

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/debug/ImmutableDebugItem.java
Patch:
@@ -77,7 +77,7 @@ public static ImmutableDebugItem of(DebugItem debugItem) {
     @Override public int getCodeAddress() { return codeAddress; }
 
     @Nonnull
-    public static ImmutableList<ImmutableDebugItem> immutableListOf(@Nullable List<? extends DebugItem> list) {
+    public static ImmutableList<ImmutableDebugItem> immutableListOf(@Nullable Iterable<? extends DebugItem> list) {
         return CONVERTER.convert(list);
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedTryBlock.java
Patch:
@@ -74,7 +74,7 @@ public List<? extends ExceptionHandler> getExceptionHandlers() {
                 @Nonnull
                 @Override
                 protected ExceptionHandler readItem(@Nonnull DexReader reader, int index) {
-                    return new DexBackedExceptionHandler(reader);
+                    return DexBackedExceptionHandler.createNew(reader);
                 }
 
                 @Override
@@ -94,7 +94,7 @@ protected ExceptionHandler readItem(@Nonnull DexReader dexReader, int index) {
                     if (index == sizeWithCatchAll-1) {
                         return new DexBackedCatchAllExceptionHandler(dexReader);
                     } else {
-                        return new DexBackedExceptionHandler(dexReader);
+                        return DexBackedExceptionHandler.createNew(dexReader);
                     }
                 }
 

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedMethod.java
Patch:
@@ -142,7 +142,7 @@ public List<? extends Annotation> getAnnotations() {
     @Override
     public MethodImplementation getImplementation() {
         if (codeOffset > 0) {
-            return new DexBackedMethodImplementation(dexBuf, codeOffset);
+            return new DexBackedMethodImplementation(dexBuf, this, codeOffset);
         }
         return null;
     }

File: dexlib2/src/main/java/org/jf/dexlib2/iface/MethodImplementation.java
Patch:
@@ -31,6 +31,7 @@
 
 package org.jf.dexlib2.iface;
 
+import org.jf.dexlib2.iface.debug.DebugItem;
 import org.jf.dexlib2.iface.instruction.Instruction;
 
 import javax.annotation.Nonnull;
@@ -40,4 +41,5 @@ public interface MethodImplementation {
     int getRegisterCount();
     @Nonnull List<? extends Instruction> getInstructions();
     @Nonnull List<? extends TryBlock> getTryBlocks();
+    @Nonnull List<? extends DebugItem> getDebugItems();
 }

File: dexlib2/src/test/java/org/jf/dexlib2/util/InstructionOffsetMapTest.java
Patch:
@@ -70,7 +70,7 @@ public void testInstructionOffsetMap() {
                 /*24: 0x32*/ new ImmutableInstruction51l(Opcode.CONST_WIDE, 32, 33),
                 /*25: 0x37*/ new ImmutableInstruction10t(Opcode.GOTO, 1)
         );
-        ImmutableMethodImplementation impl = new ImmutableMethodImplementation(33, instructions, null);
+        ImmutableMethodImplementation impl = new ImmutableMethodImplementation(33, instructions, null, null);
         InstructionOffsetMap instructionOffsetMap = new InstructionOffsetMap(impl);
 
         int[] expectedOffsets = new int[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x07, 0x09, 0x0b, 0x0d, 0x0f, 0x11,

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedClassDef.java
Patch:
@@ -68,7 +68,7 @@ public DexBackedClassDef(@Nonnull DexBuffer dexBuf,
 
         this.name = dexBuf.getType(dexBuf.readSmallUint(classDefOffset));
         this.accessFlags = dexBuf.readSmallUint(classDefOffset + ACCESS_FLAGS_OFFSET);
-        this.superclass = dexBuf.getOptionalString(dexBuf.readOptionalUint(classDefOffset + SUPERCLASS_OFFSET));
+        this.superclass = dexBuf.getOptionalType(dexBuf.readOptionalUint(classDefOffset + SUPERCLASS_OFFSET));
         this.interfacesOffset = dexBuf.readSmallUint(classDefOffset + INTERFACES_OFFSET);
         this.sourceFile = dexBuf.getOptionalString(dexBuf.readOptionalUint(classDefOffset + SOURCE_FILE_OFFSET));
 
@@ -94,7 +94,7 @@ public List<String> getInterfaces() {
                 @Nonnull
                 @Override
                 public String readItem(int index) {
-                    return dexBuf.getString(dexBuf.readSmallUint(interfacesOffset + 4 + (2*index)));
+                    return dexBuf.getType(dexBuf.readSmallUint(interfacesOffset + 4 + (2*index)));
                 }
 
                 @Override public int size() { return size; }

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexReader.java
Patch:
@@ -56,6 +56,7 @@ public DexReader(@Nonnull DexBuffer dexBuf, int offset) {
     public String getString(int stringIndex) { return dexBuf.getString(stringIndex); }
     public String getOptionalString(int stringIndex) { return dexBuf.getOptionalString(stringIndex); }
     public String getType(int typeIndex) { return dexBuf.getType(typeIndex); }
+    public String getOptionalType(int typeIndex) { return dexBuf.getOptionalType(typeIndex); }
     public String getField(int fieldIndex) { return dexBuf.getField(fieldIndex); }
     public String getMethod(int methodIndex) { return dexBuf.getMethod(methodIndex); }
     public String getReference(int type, int index) { return dexBuf.getReference(type, index); }

File: dexlib2/src/main/java/org/jf/dexlib2/util/Preconditions.java
Patch:
@@ -136,7 +136,7 @@ public static int check35cRegisterCount(int registerCount) {
     }
 
     public static int check3rcRegisterCount(int registerCount) {
-        if ((registerCount & 0xFFFFFF00) == 0) {
+        if ((registerCount & 0xFFFFFF00) != 0) {
             throw new IllegalArgumentException(
                     String.format("Invalid register count: %d. Must be between 0 and 255, inclusive.", registerCount));
         }

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction10t.java
Patch:
@@ -39,7 +39,7 @@
 import javax.annotation.Nonnull;
 
 public class ImmutableInstruction10t extends ImmutableInstruction implements Instruction10t {
-    public static final Format FORMAT = Format.Format12x;
+    public static final Format FORMAT = Format.Format10t;
 
     public final int codeOffset;
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction20t.java
Patch:
@@ -39,7 +39,7 @@
 import javax.annotation.Nonnull;
 
 public class ImmutableInstruction20t extends ImmutableInstruction implements Instruction20t {
-    public static final Format FORMAT = Format.Format12x;
+    public static final Format FORMAT = Format.Format20t;
 
     public final int codeOffset;
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction22b.java
Patch:
@@ -50,7 +50,7 @@ public ImmutableInstruction22b(@Nonnull Opcode opcode,
                                    int registerB,
                                    int literal) {
         super(opcode);
-        Preconditions.checkFormat(opcode, Format.Format35c);
+        Preconditions.checkFormat(opcode, FORMAT);
         this.registerA = Preconditions.checkByteRegister(registerA);
         this.registerB = Preconditions.checkByteRegister(registerB);
         this.literal = Preconditions.checkByteLiteral(literal);

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction22s.java
Patch:
@@ -50,7 +50,7 @@ public ImmutableInstruction22s(@Nonnull Opcode opcode,
                                    int registerB,
                                    int literal) {
         super(opcode);
-        Preconditions.checkFormat(opcode, Format.Format35c);
+        Preconditions.checkFormat(opcode, FORMAT);
         this.registerA = Preconditions.checkNibbleRegister(registerA);
         this.registerB = Preconditions.checkNibbleRegister(registerB);
         this.literal = Preconditions.checkShortLiteral(literal);

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction22t.java
Patch:
@@ -50,7 +50,7 @@ public ImmutableInstruction22t(@Nonnull Opcode opcode,
                                    int registerB,
                                    int codeOffset) {
         super(opcode);
-        Preconditions.checkFormat(opcode, Format.Format35c);
+        Preconditions.checkFormat(opcode, FORMAT);
         this.registerA = Preconditions.checkNibbleRegister(registerA);
         this.registerB = Preconditions.checkNibbleRegister(registerB);
         this.codeOffset = Preconditions.checkShortCodeOffset(codeOffset);

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction22x.java
Patch:
@@ -48,7 +48,7 @@ public ImmutableInstruction22x(@Nonnull Opcode opcode,
                                    int registerA,
                                    int registerB) {
         super(opcode);
-        Preconditions.checkFormat(opcode, Format.Format35c);
+        Preconditions.checkFormat(opcode, FORMAT);
         this.registerA = Preconditions.checkByteRegister(registerA);
         this.registerB = Preconditions.checkShortRegister(registerB);
     }

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction23x.java
Patch:
@@ -50,7 +50,7 @@ public ImmutableInstruction23x(@Nonnull Opcode opcode,
                                    int registerB,
                                    int registerC) {
         super(opcode);
-        Preconditions.checkFormat(opcode, Format.Format35c);
+        Preconditions.checkFormat(opcode, FORMAT);
         this.registerA = Preconditions.checkByteRegister(registerA);
         this.registerB = Preconditions.checkByteRegister(registerB);
         this.registerC = Preconditions.checkByteRegister(registerC);

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction30t.java
Patch:
@@ -39,7 +39,7 @@
 import javax.annotation.Nonnull;
 
 public class ImmutableInstruction30t extends ImmutableInstruction implements Instruction30t {
-    public static final Format FORMAT = Format.Format12x;
+    public static final Format FORMAT = Format.Format30t;
 
     public final int codeOffset;
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction32x.java
Patch:
@@ -48,7 +48,7 @@ public ImmutableInstruction32x(@Nonnull Opcode opcode,
                                    int registerA,
                                    int registerB) {
         super(opcode);
-        Preconditions.checkFormat(opcode, Format.Format35c);
+        Preconditions.checkFormat(opcode, FORMAT);
         this.registerA = Preconditions.checkShortRegister(registerA);
         this.registerB = Preconditions.checkShortRegister(registerB);
     }

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction35c.java
Patch:
@@ -58,7 +58,7 @@ public ImmutableInstruction35c(@Nonnull Opcode opcode,
                                    int registerG,
                                    @Nonnull String reference) {
         super(opcode);
-        Preconditions.checkFormat(opcode, Format.Format35c);
+        Preconditions.checkFormat(opcode, FORMAT);
         this.registerCount = Preconditions.check35cRegisterCount(registerCount);
         this.registerC = (registerCount>0) ? Preconditions.checkNibbleRegister(registerC) : 0;
         this.registerD = (registerCount>1) ? Preconditions.checkNibbleRegister(registerD) : 0;

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBuffer.java
Patch:
@@ -279,6 +279,7 @@ public String getMethod(int methodIndex) {
         }
 
         sb.append(")");
+        sb.append(returnType);
         return sb.toString();
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/instruction/ImmutableInstruction10x.java
Patch:
@@ -39,7 +39,7 @@
 import javax.annotation.Nonnull;
 
 public class ImmutableInstruction10x extends ImmutableInstruction implements Instruction10x {
-    public static final Format FORMAT = Format.Format12x;
+    public static final Format FORMAT = Format.Format10x;
 
     public ImmutableInstruction10x(@Nonnull Opcode opcode) {
         super(opcode);

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexBackedClassDef.java
Patch:
@@ -76,7 +76,7 @@ public DexBackedClassDef(@Nonnull DexBuffer dexBuf,
         int annotationsDirectoryOffset = dexBuf.readSmallUint(classDefOffset + ANNOTATIONS_OFFSET);
         this.annotationsDirectory = AnnotationsDirectory.newOrEmpty(dexBuf, annotationsDirectoryOffset);
 
-        this.classDataOffset = dexBuf.readSmallUint(CLASS_DATA_OFFSET);
+        this.classDataOffset = dexBuf.readSmallUint(classDefOffset + CLASS_DATA_OFFSET);
         this.staticInitialValuesOffset = dexBuf.readSmallUint(classDefOffset + STATIC_INITIAL_VALUES_OFFSET);
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/util/Preconditions.java
Patch:
@@ -145,7 +145,7 @@ public static int check3rcRegisterCount(int registerCount) {
     }
 
     public static void checkValueArg(int valueArg, int maxValue) {
-        if (valueArg > 0) {
+        if (valueArg > maxValue) {
             throw new IllegalArgumentException(
                     String.format("Invalid value_arg value %d for an encoded_value. Expecting 0..%d, inclusive",
                             valueArg, maxValue));

File: dexlib2/src/main/java/org/jf/dexlib2/dexbacked/DexFileBuffer.java
Patch:
@@ -93,7 +93,7 @@ public int readSmallUint(int offset) {
         int result = (buf[offset] & 0xff) |
                      ((buf[offset+1] & 0xff) << 8) |
                      ((buf[offset+2] & 0xff) << 16) |
-                     ((buf[offset+3] & 0xff) << 24);  // TODO: can get rid of last & 0xff?
+                     ((buf[offset+3]) << 24);
         if (result < 0) {
             throw new ExceptionWithContext("Encountered uint that is out of range at offset 0x%x", offset);
         }
@@ -113,10 +113,10 @@ public int readUbyte(int offset) {
     public long readLong(int offset) {
         // TODO: use | or +?
         byte[] buf = this.buf;
-        return (buf[offset] & 0xffL) |
+        return (buf[offset] & 0xff) |
                ((buf[offset+1] & 0xff) << 8) |
                ((buf[offset+2] & 0xff) << 16) |
-               ((buf[offset+3] & 0xff) << 24) |
+               ((buf[offset+3] & 0xffL) << 24) |
                ((buf[offset+4] & 0xffL) << 32) |
                ((buf[offset+5] & 0xffL) << 40) |
                ((buf[offset+6] & 0xffL) << 48) |

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableAnnotationEncodedValue.java
Patch:
@@ -31,6 +31,7 @@
 
 package org.jf.dexlib2.immutable.value;
 
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.EncodedValue;
 import org.jf.dexlib2.immutable.ImmutableBaseAnnotation;
 import org.jf.dexlib2.iface.BaseAnnotation;
@@ -43,12 +44,12 @@ public class ImmutableAnnotationEncodedValue extends ImmutableEncodedValue imple
     public final ImmutableBaseAnnotation value;
 
     public ImmutableAnnotationEncodedValue(@Nonnull BaseAnnotation value) {
-        super(EncodedValue.ANNOTATION);
+        super(ValueType.ANNOTATION);
         this.value = ImmutableBaseAnnotation.of(value);
     }
 
     public ImmutableAnnotationEncodedValue(@Nonnull ImmutableBaseAnnotation value) {
-        super(EncodedValue.ANNOTATION);
+        super(ValueType.ANNOTATION);
         this.value = value;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableArrayEncodedValue.java
Patch:
@@ -32,6 +32,7 @@
 package org.jf.dexlib2.immutable.value;
 
 import com.google.common.collect.ImmutableList;
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.ArrayEncodedValue;
 import org.jf.dexlib2.iface.value.EncodedValue;
 
@@ -43,12 +44,12 @@ public class ImmutableArrayEncodedValue extends ImmutableEncodedValue implements
     public final ImmutableList<? extends ImmutableEncodedValue> value;
 
     public ImmutableArrayEncodedValue(@Nonnull List<? extends EncodedValue> value) {
-        super(EncodedValue.ARRAY);
+        super(ValueType.ARRAY);
         this.value = ImmutableEncodedValue.immutableListOf(value);
     }
 
     public ImmutableArrayEncodedValue(@Nonnull ImmutableList<ImmutableEncodedValue> value) {
-        super(EncodedValue.ARRAY);
+        super(ValueType.ARRAY);
         this.value = value;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableBooleanEncodedValue.java
Patch:
@@ -31,14 +31,14 @@
 
 package org.jf.dexlib2.immutable.value;
 
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.BooleanEncodedValue;
-import org.jf.dexlib2.iface.value.EncodedValue;
 
 public class ImmutableBooleanEncodedValue extends ImmutableEncodedValue implements BooleanEncodedValue {
     public final boolean value;
 
     public ImmutableBooleanEncodedValue(boolean value) {
-        super(EncodedValue.BOOLEAN);
+        super(ValueType.BOOLEAN);
         this.value = value;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableByteEncodedValue.java
Patch:
@@ -31,14 +31,14 @@
 
 package org.jf.dexlib2.immutable.value;
 
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.ByteEncodedValue;
-import org.jf.dexlib2.iface.value.EncodedValue;
 
 public class ImmutableByteEncodedValue extends ImmutableEncodedValue implements ByteEncodedValue {
     public final byte value;
 
     public ImmutableByteEncodedValue(byte value) {
-        super(EncodedValue.BYTE);
+        super(ValueType.BYTE);
         this.value = value;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableCharEncodedValue.java
Patch:
@@ -31,14 +31,14 @@
 
 package org.jf.dexlib2.immutable.value;
 
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.CharEncodedValue;
-import org.jf.dexlib2.iface.value.EncodedValue;
 
 public class ImmutableCharEncodedValue extends ImmutableEncodedValue implements CharEncodedValue {
     public final char value;
 
     public ImmutableCharEncodedValue(char value) {
-        super(EncodedValue.CHAR);
+        super(ValueType.CHAR);
         this.value = value;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableDoubleEncodedValue.java
Patch:
@@ -31,14 +31,14 @@
 
 package org.jf.dexlib2.immutable.value;
 
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.DoubleEncodedValue;
-import org.jf.dexlib2.iface.value.EncodedValue;
 
 public class ImmutableDoubleEncodedValue extends ImmutableEncodedValue implements DoubleEncodedValue {
     public final double value;
 
     public ImmutableDoubleEncodedValue(double value) {
-        super(EncodedValue.DOUBLE);
+        super(ValueType.DOUBLE);
         this.value = value;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableEnumEncodedValue.java
Patch:
@@ -31,7 +31,7 @@
 
 package org.jf.dexlib2.immutable.value;
 
-import org.jf.dexlib2.iface.value.EncodedValue;
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.EnumEncodedValue;
 
 import javax.annotation.Nonnull;
@@ -40,7 +40,7 @@ public class ImmutableEnumEncodedValue extends ImmutableEncodedValue implements
     @Nonnull public final String value;
 
     public ImmutableEnumEncodedValue(@Nonnull String value) {
-        super(EncodedValue.ENUM);
+        super(ValueType.ENUM);
         this.value = value;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableFieldEncodedValue.java
Patch:
@@ -31,7 +31,7 @@
 
 package org.jf.dexlib2.immutable.value;
 
-import org.jf.dexlib2.iface.value.EncodedValue;
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.FieldEncodedValue;
 
 import javax.annotation.Nonnull;
@@ -40,7 +40,7 @@ public class ImmutableFieldEncodedValue extends ImmutableEncodedValue implements
     @Nonnull public final String value;
 
     public ImmutableFieldEncodedValue(@Nonnull String value) {
-        super(EncodedValue.FIELD);
+        super(ValueType.FIELD);
         this.value = value;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableFloatEncodedValue.java
Patch:
@@ -31,14 +31,14 @@
 
 package org.jf.dexlib2.immutable.value;
 
-import org.jf.dexlib2.iface.value.EncodedValue;
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.FloatEncodedValue;
 
 public class ImmutableFloatEncodedValue extends ImmutableEncodedValue implements FloatEncodedValue {
     public final float value;
 
     public ImmutableFloatEncodedValue(float value) {
-        super(EncodedValue.FLOAT);
+        super(ValueType.FLOAT);
         this.value = value;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableIntEncodedValue.java
Patch:
@@ -31,14 +31,14 @@
 
 package org.jf.dexlib2.immutable.value;
 
-import org.jf.dexlib2.iface.value.EncodedValue;
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.IntEncodedValue;
 
 public class ImmutableIntEncodedValue extends ImmutableEncodedValue implements IntEncodedValue {
     public final int value;
 
     public ImmutableIntEncodedValue(int value) {
-        super(EncodedValue.INT);
+        super(ValueType.INT);
         this.value = value;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableLongEncodedValue.java
Patch:
@@ -31,14 +31,14 @@
 
 package org.jf.dexlib2.immutable.value;
 
-import org.jf.dexlib2.iface.value.EncodedValue;
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.LongEncodedValue;
 
 public class ImmutableLongEncodedValue extends ImmutableEncodedValue implements LongEncodedValue {
     public final long value;
 
     public ImmutableLongEncodedValue(long value) {
-        super(EncodedValue.LONG);
+        super(ValueType.LONG);
         this.value = value;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableMethodEncodedValue.java
Patch:
@@ -31,7 +31,7 @@
 
 package org.jf.dexlib2.immutable.value;
 
-import org.jf.dexlib2.iface.value.EncodedValue;
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.MethodEncodedValue;
 
 import javax.annotation.Nonnull;
@@ -41,7 +41,7 @@ public class ImmutableMethodEncodedValue extends ImmutableEncodedValue implement
     public final String value;
 
     public ImmutableMethodEncodedValue(@Nonnull String value) {
-        super(EncodedValue.METHOD);
+        super(ValueType.METHOD);
         this.value = value;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableNullEncodedValue.java
Patch:
@@ -31,13 +31,13 @@
 
 package org.jf.dexlib2.immutable.value;
 
-import org.jf.dexlib2.iface.value.EncodedValue;
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.NullEncodedValue;
 
 public class ImmutableNullEncodedValue extends ImmutableEncodedValue implements NullEncodedValue {
     public static final ImmutableNullEncodedValue INSTANCE = new ImmutableNullEncodedValue();
 
     public ImmutableNullEncodedValue() {
-        super(EncodedValue.NULL);
+        super(ValueType.NULL);
     }
 }

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableShortEncodedValue.java
Patch:
@@ -31,14 +31,14 @@
 
 package org.jf.dexlib2.immutable.value;
 
-import org.jf.dexlib2.iface.value.EncodedValue;
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.ShortEncodedValue;
 
 public class ImmutableShortEncodedValue extends ImmutableEncodedValue implements ShortEncodedValue {
     public final short value;
 
     public ImmutableShortEncodedValue(short value) {
-        super(EncodedValue.SHORT);
+        super(ValueType.SHORT);
         this.value = value;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableStringEncodedValue.java
Patch:
@@ -31,7 +31,7 @@
 
 package org.jf.dexlib2.immutable.value;
 
-import org.jf.dexlib2.iface.value.EncodedValue;
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.StringEncodedValue;
 
 import javax.annotation.Nonnull;
@@ -41,7 +41,7 @@ public class ImmutableStringEncodedValue extends ImmutableEncodedValue implement
     public final String value;
 
     public ImmutableStringEncodedValue(@Nonnull String value) {
-        super(EncodedValue.STRING);
+        super(ValueType.STRING);
         this.value = value;
     }
 

File: dexlib2/src/main/java/org/jf/dexlib2/immutable/value/ImmutableTypeEncodedValue.java
Patch:
@@ -31,7 +31,7 @@
 
 package org.jf.dexlib2.immutable.value;
 
-import org.jf.dexlib2.iface.value.EncodedValue;
+import org.jf.dexlib2.ValueType;
 import org.jf.dexlib2.iface.value.TypeEncodedValue;
 
 import javax.annotation.Nonnull;
@@ -41,7 +41,7 @@ public class ImmutableTypeEncodedValue extends ImmutableEncodedValue implements
     public final String value;
 
     public ImmutableTypeEncodedValue(@Nonnull String value) {
-        super(EncodedValue.TYPE);
+        super(ValueType.TYPE);
         this.value = value;
     }
 

File: dexlib/src/main/java/org/jf/dexlib/ClassDataItem.java
Patch:
@@ -431,10 +431,9 @@ public int hashCode() {
      * Returns the parent type for a non-empty ClassDataItem, or null for an empty one (which could be referenced by
      * multiple ClassDefItem parents)
      *
-     * Specifically, the AnnotationDirectoryItem may be referenced by multiple classes if it has only class annotations,
-     * but not field/method/parameter annotations.
+     * Only an empty ClassDataItem may have multiple parents.
      *
-     * @return The parent type for this AnnotationDirectoryItem, or null if it may have multiple parents
+     * @return The parent type for this ClassDefItem, or null if it may have multiple parents
      */
     @Nullable
     public TypeIdItem getParentType() {

File: smali/src/main/java/org/jf/smali/main.java
Patch:
@@ -318,7 +318,7 @@ private static boolean assembleSmaliFile(File smaliFile, DexFile dexFile, boolea
         treeStream.setTokenStream(tokens);
 
         smaliTreeWalker dexGen = new smaliTreeWalker(treeStream);
-
+        dexGen.setVerboseErrors(verboseErrors);
         dexGen.dexFile = dexFile;
         dexGen.smali_file();
 

File: dexlib/src/main/java/org/jf/dexlib/HeaderItem.java
Patch:
@@ -48,7 +48,7 @@ public class HeaderItem extends Item<HeaderItem> {
 
     /** the endianness constants */
     private static final int LITTLE_ENDIAN = 0x12345678;
-    private static final int BIG_ENDIAN = 0x78562312;
+    private static final int BIG_ENDIAN = 0x78563412;
 
     /* Which magic value to use when writing out the header item */
     private int magic_index = 0;

File: dexlib/src/main/java/org/jf/dexlib/Util/Utf8Utils.java
Patch:
@@ -136,7 +136,7 @@ public static String utf8BytesToString(byte[] bytes, int start, int length) {
                         return throwBadUtf8(v1, at + 1);
                     }
                     int v2 = bytes[at + 2] & 0xFF;
-                    if ((v1 & 0xc0) != 0x80) {
+                    if ((v2 & 0xc0) != 0x80) {
                         return throwBadUtf8(v2, at + 2);
                     }
                     int value = ((v0 & 0x0f) << 12) | ((v1 & 0x3f) << 6) |

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/ClassDefinition.java
Patch:
@@ -39,11 +39,13 @@
 import org.jf.dexlib.Util.AccessFlags;
 import org.jf.dexlib.Util.SparseArray;
 
+import javax.annotation.Nullable;
 import java.io.IOException;
 import java.util.List;
 
 public class ClassDefinition {
     private ClassDefItem classDefItem;
+    @Nullable
     private ClassDataItem classDataItem;
 
     private SparseArray<FieldIdItem> fieldsSetInStaticConstructor;

File: dexlib/src/main/java/org/jf/dexlib/HeaderItem.java
Patch:
@@ -68,7 +68,7 @@ protected void readItem(Input in, ReadContext readContext) {
         for (int i=0; i<MAGIC_VALUES.length; i++) {
             byte[] magic_value = MAGIC_VALUES[i];
             boolean matched = true;
-            for (int j=0; j<8; i++) {
+            for (int j=0; j<8; j++) {
                 if (magic_value[j] != readMagic[j]) {
                     matched = false;
                     break;

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/MethodDefinition.java
Patch:
@@ -135,6 +135,7 @@ public void writeTo(IndentingWriter writer, AnnotationSetItem annotationSet,
                 }
             }
         } else {
+            writeParameters(writer, codeItem, parameterAnnotations);
             if (annotationSet != null) {
                 AnnotationFormatter.writeTo(writer, annotationSet);
             }

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/Format/InstructionMethodItem.java
Patch:
@@ -193,6 +193,7 @@ public boolean writeTo(IndentingWriter writer) throws IOException {
                 writeInvokeRegisters(writer);
                 writer.write(", ");
                 writeInlineIndex(writer);
+                return true;
             case Format35ms:
                 writeOpcode(writer);
                 writer.write(' ');

File: dexlib/src/main/java/org/jf/dexlib/Code/Format/Instruction35mi.java
Patch:
@@ -96,7 +96,7 @@ protected void writeInstruction(AnnotatedOutput out, int currentCodeAddress) {
     }
 
     public Format getFormat() {
-        return Format.Format35ms;
+        return Format.Format35mi;
     }
 
     public int getRegCount() {

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/Format/SparseSwitchMethodItem.java
Patch:
@@ -51,7 +51,7 @@ public SparseSwitchMethodItem(MethodDefinition methodDefinition, CodeItem codeIt
 
         targets = new ArrayList<SparseSwitchTarget>();
         Iterator<SparseSwitchDataPseudoInstruction.SparseSwitchTarget> iterator = instruction.iterateKeysAndTargets();
-        if (baseCodeAddress != 0) {
+        if (baseCodeAddress >= 0) {
             while (iterator.hasNext()) {
                 SparseSwitchDataPseudoInstruction.SparseSwitchTarget target = iterator.next();
                 SparseSwitchLabelTarget sparseSwitchLabelTarget = new SparseSwitchLabelTarget();

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/Format/InstructionMethodItem.java
Patch:
@@ -136,6 +136,7 @@ public boolean writeTo(IndentingWriter writer) throws IOException {
                 writeLiteral(writer);
                 return true;
             case Format22c:
+            case Format52c:
                 writeOpcode(writer);
                 writer.write(' ');
                 writeFirstRegister(writer);

File: dexlib/src/main/java/org/jf/dexlib/Code/Format/Format.java
Patch:
@@ -63,6 +63,7 @@ public enum Format {
     Format3rms(Instruction3rms.Factory, 6),
     Format41c(Instruction41c.Factory, 8),
     Format51l(Instruction51l.Factory, 10),
+    Format52c(Instruction52c.Factory, 10),
     ArrayData(null, -1, true),
     PackedSwitchData(null, -1, true),
     SparseSwitchData(null, -1, true),

File: dexlib/src/main/java/org/jf/dexlib/Code/Opcode.java
Patch:
@@ -284,7 +284,9 @@ public enum Opcode
 
     CONST_CLASS_JUMBO((short)0xff00, "const-class/jumbo", ReferenceType.type, Format.Format41c, Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_REGISTER),
     CHECK_CAST_JUMBO((short)0xff01, "check-cast/jumbo", ReferenceType.type, Format.Format41c, Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_REGISTER),
+    INSTANCE_OF_JUMBO((short)0xff02, "instance-of/jumbo", ReferenceType.type, Format.Format52c, Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_REGISTER),
     NEW_INSTANCE_JUMBO((short)0xff03, "new-instance/jumbo", ReferenceType.type, Format.Format41c, Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_REGISTER),
+    NEW_ARRAY_JUMBO((short)0xff04, "new-array/jumbo", ReferenceType.type, Format.Format52c, Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_REGISTER),
 
     SGET_JUMBO((short)0xff14, "sget/jumbo", ReferenceType.field, Format.Format41c, Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_REGISTER),
     SGET_WIDE_JUMBO((short)0xff15, "sget-wide/jumbo", ReferenceType.field, Format.Format41c, Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_REGISTER | Opcode.SETS_WIDE_REGISTER),

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/Format/InstructionMethodItem.java
Patch:
@@ -100,6 +100,7 @@ public boolean writeTo(IndentingWriter writer) throws IOException {
                 return true;
             case Format21c:
             case Format31c:
+            case Format41c:
                 writeOpcode(writer);
                 writer.write(' ');
                 writeFirstRegister(writer);

File: dexlib/src/main/java/org/jf/dexlib/Code/Format/Format.java
Patch:
@@ -61,6 +61,7 @@ public enum Format {
     Format3rc(Instruction3rc.Factory, 6),
     Format3rmi(Instruction3rmi.Factory, 6),
     Format3rms(Instruction3rms.Factory, 6),
+    Format41c(Instruction41c.Factory, 8),
     Format51l(Instruction51l.Factory, 10),
     ArrayData(null, -1, true),
     PackedSwitchData(null, -1, true),

File: dexlib/src/main/java/org/jf/dexlib/Code/Format/Instruction21c.java
Patch:
@@ -71,8 +71,8 @@ private Instruction21c(DexFile dexFile, Opcode opcode, byte[] buffer, int buffer
     }
 
     protected void writeInstruction(AnnotatedOutput out, int currentCodeAddress) {
-        if(opcode == Opcode.CONST_STRING && getReferencedItem().getIndex() > 0xFFFF) {
-            throw new RuntimeException("String offset is too large for const-string. Use string-const/jumbo instead.");
+        if(getReferencedItem().getIndex() > 0xFFFF) {
+            throw new RuntimeException(String.format("%s index is too large. Use the %s/jumbo instruction instead.", opcode.referenceType.name(), opcode.name));
         }
 
         out.writeByte(opcode.value);

File: dexlib/src/main/java/org/jf/dexlib/Code/Analysis/MethodAnalyzer.java
Patch:
@@ -1012,6 +1012,8 @@ private boolean analyzeInstruction(AnalyzedInstruction analyzedInstruction) {
             case SPUT_WIDE_VOLATILE:
                 analyzePutGetVolatile(analyzedInstruction);
                 return true;
+            case THROW_VERIFICATION_ERROR:
+                return true;
             case EXECUTE_INLINE:
                 analyzeExecuteInline(analyzedInstruction);
                 return true;
@@ -1512,6 +1514,7 @@ private void verifyInstruction(AnalyzedInstruction analyzedInstruction) {
             case IPUT_WIDE_VOLATILE:
             case SGET_WIDE_VOLATILE:
             case SPUT_WIDE_VOLATILE:
+            case THROW_VERIFICATION_ERROR:
             case EXECUTE_INLINE:
             case EXECUTE_INLINE_RANGE:
             case INVOKE_DIRECT_EMPTY:

File: smali/src/test/java/LexerTest.java
Patch:
@@ -185,8 +185,8 @@ public void runTest(String test, boolean discardHiddenTokens) {
             int expectedTokenType = tokenTypesByName.get(expectedToken.tokenName);
 
             if (token.getType() != expectedTokenType) {
-                Assert.fail(String.format("Invalid token at index %d. Expecting %s, got %s",
-                        expectedTokenIndex-1, expectedToken.tokenName, getTokenName(token.getType())));
+                Assert.fail(String.format("Invalid token at index %d. Expecting %s, got %s(%s)",
+                        expectedTokenIndex-1, expectedToken.tokenName, getTokenName(token.getType()), token.getText()));
             }
 
             if (expectedToken.tokenText != null) {

File: dexlib/src/main/java/org/jf/dexlib/Code/Format/Format.java
Patch:
@@ -36,6 +36,7 @@ public enum Format {
     Format11n(Instruction11n.Factory, 2),
     Format11x(Instruction11x.Factory, 2),
     Format12x(Instruction12x.Factory, 2),
+    Format20bc(Instruction20bc.Factory, 4),
     Format20t(Instruction20t.Factory, 4),
     Format21c(Instruction21c.Factory, 4),
     Format21h(Instruction21h.Factory, 4),

File: dexlib/src/main/java/org/jf/dexlib/Code/Opcode.java
Patch:
@@ -263,6 +263,7 @@ public enum Opcode
     SGET_WIDE_VOLATILE((byte)0xea, "sget-wide-volatile", ReferenceType.field, Format.Format21c, Opcode.ODEX_ONLY | Opcode.ODEXED_STATIC_VOLATILE | Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_REGISTER | Opcode.SETS_WIDE_REGISTER),
     SPUT_WIDE_VOLATILE((byte)0xeb, "sput-wide-volatile", ReferenceType.field, Format.Format21c, Opcode.ODEX_ONLY | Opcode.ODEXED_STATIC_VOLATILE | Opcode.CAN_THROW | Opcode.CAN_CONTINUE),
 
+    THROW_VERIFICATION_ERROR((byte)0xed, "throw-verification-error", ReferenceType.none, Format.Format20bc, Opcode.ODEX_ONLY | Opcode.CAN_THROW),
     EXECUTE_INLINE((byte)0xee, "execute-inline", ReferenceType.none,  Format.Format35ms, Opcode.ODEX_ONLY | Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_RESULT),
     EXECUTE_INLINE_RANGE((byte)0xef, "execute-inline/range", ReferenceType.none,  Format.Format3rms,  Opcode.ODEX_ONLY | Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_RESULT),
     INVOKE_DIRECT_EMPTY((byte)0xf0, "invoke-direct-empty", ReferenceType.method,  Format.Format35s, Opcode.ODEX_ONLY | Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_RESULT),

File: dexlib/src/main/java/org/jf/dexlib/CodeItem.java
Patch:
@@ -234,7 +234,7 @@ protected void writeItem(final AnnotatedOutput out) {
             if (debugInfo == null) {
                 out.annotate(4, "debug_info_off:");
             } else {
-                out.annotate(4, "debug_info_off: 0x" + debugInfo.getOffset());
+                out.annotate(4, "debug_info_off: 0x" + Integer.toHexString(debugInfo.getOffset()));
             }
             out.annotate(4, "insns_size: 0x" + Integer.toHexString(instructionsLength) + " (" +
                     (instructionsLength) + ")");

File: baksmali/src/main/java/org/jf/baksmali/Renderers/IntegerRenderer.java
Patch:
@@ -45,6 +45,6 @@ public static void writeTo(IndentingWriter writer, int val) throws IOException {
 
     public static void writeUnsignedTo(IndentingWriter writer, int val) throws IOException {
         writer.write("0x");
-        writer.printUnsignedLongAsHex(val & 0xFFFFFFFF);
+        writer.printUnsignedLongAsHex(val & 0xFFFFFFFFL);
     }
 }

File: dexlib/src/main/java/org/jf/dexlib/Util/ByteArrayInput.java
Patch:
@@ -120,7 +120,7 @@ public long readLong() {
                       ((data[readAt++] & 0xffL) << 32) |
                       ((data[readAt++] & 0xffL) << 40) |
                       ((data[readAt++] & 0xffL) << 48) |
-                      ((data[readAt++] & 0xffL) << 58);
+                      ((data[readAt++] & 0xffL) << 56);
         cursor = readAt;
         return result;
     }

File: dexlib/src/main/java/org/jf/dexlib/Code/Analysis/InlineMethodResolver.java
Patch:
@@ -80,7 +80,7 @@ public InlineMethodResolver_version35(DeodexUtil deodexUtil) {
         public DeodexUtil.InlineMethod resolveExecuteInline(AnalyzedInstruction analyzedInstruction) {
             assert analyzedInstruction.instruction instanceof OdexedInvokeVirtual;
 
-            OdexedInvokeVirtual instruction = (OdexedInvokeVirtual)analyzedInstruction;
+            OdexedInvokeVirtual instruction = (OdexedInvokeVirtual)analyzedInstruction.instruction;
             int methodIndex = instruction.getMethodIndex();
 
             if (methodIndex < 0 || methodIndex >= inlineMethods.length) {

File: util/src/main/java/ds/tree/RadixTreeImpl.java
Patch:
@@ -414,7 +414,6 @@ private void formatNodeTo(Formatter f, int level, RadixTreeNode<T> node) {
 	 *
      * WARNING! Do not use this for a large Trie, it's for testing purpose only.
 	 */
-	@Override
 	public void formatTo(Formatter formatter, int flags, int width, int precision) {
 		formatNodeTo(formatter, 0, root);
 	}

File: util/src/main/java/ds/tree/VisitorImpl.java
Patch:
@@ -19,12 +19,9 @@ public VisitorImpl(R initialValue) {
 		this.result = initialValue;
 	}
 
-	@Override
 	public R getResult() {
 		return result;
 	}
 
-	@Override
 	abstract public void visit(String key, RadixTreeNode<T> parent, RadixTreeNode<T> node);
-
 }
\ No newline at end of file

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/MethodDefinition.java
Patch:
@@ -293,7 +293,9 @@ private List<MethodItem> getMethodItems() {
         }
 
         addTries(methodItems);
-        addDebugInfo(methodItems);
+        if (baksmali.outputDebugInfo) {
+            addDebugInfo(methodItems);
+        }
 
         if (baksmali.useSequentialLabels) {
             setLabelSequentialNumbers();

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/ClassDefinition.java
Patch:
@@ -105,6 +105,9 @@ private void findFieldsSetInStaticConstructor() {
 
         for (ClassDataItem.EncodedMethod directMethod: classDataItem.getDirectMethods()) {
             if (directMethod.method.getMethodName().getStringValue().equals("<clinit>")) {
+                if (directMethod.codeItem == null) {
+                    break;
+                }
 
                 for (Instruction instruction: directMethod.codeItem.getInstructions()) {
                     switch (instruction.opcode) {

File: smali/src/test/java/LexerTest.java
Patch:
@@ -154,6 +154,8 @@ public void runTest(String test, boolean discardHiddenTokens) {
             Assert.fail("Could not load " + smaliFile);
         }
         smaliFlexLexer lexer = new smaliFlexLexer(smaliStream);
+        lexer.setSourceFile(new File(test + ".smali"));
+        lexer.setSuppressErrors(true);
 
         CommonTokenStream tokenStream = new CommonTokenStream(lexer);
         List tokens = tokenStream.getTokens();

File: smali/src/main/java/org/jf/smali/main.java
Patch:
@@ -276,6 +276,7 @@ private static boolean assembleSmaliFile(File smaliFile, DexFile dexFile, boolea
             InputStreamReader reader = new InputStreamReader(fis, "UTF-8");
 
             lexer = new smaliFlexLexer(reader);
+            ((smaliFlexLexer)lexer).setSourceFile(smaliFile);
             tokens = new CommonTokenStream((TokenSource)lexer);
         }
 

File: smali/src/test/java/LongLiteralTest.java
Patch:
@@ -35,7 +35,7 @@ public class LongLiteralTest
     @Test
     public void SuccessHexTests() {
         Assert.assertTrue(literalTools.parseLong("0x0L") == 0x0);
-        Assert.assertTrue(literalTools.parseLong("0x00") == 0x0);
+        Assert.assertTrue(literalTools.parseLong("0x00L") == 0x0);
         Assert.assertTrue(literalTools.parseLong("0x1L") == 0x1);
         Assert.assertTrue(literalTools.parseLong("0x1234567890123456L") == 0x1234567890123456L);
         Assert.assertTrue(literalTools.parseLong("0x7fffffffffffffffL") == 0x7fffffffffffffffL);
@@ -45,7 +45,7 @@ public void SuccessHexTests() {
         Assert.assertTrue(literalTools.parseLong("-0x00L") == 0);
         Assert.assertTrue(literalTools.parseLong("-0x01L") == -1);
         Assert.assertTrue(literalTools.parseLong("-0x1234567890123456L") == -0x1234567890123456L);
-        Assert.assertTrue(literalTools.parseLong("-0x8000000000000000") == Long.MIN_VALUE);
+        Assert.assertTrue(literalTools.parseLong("-0x8000000000000000L") == Long.MIN_VALUE);
         Assert.assertTrue(literalTools.parseLong("-0x1fffffffffffffffL") == -0x1fffffffffffffffL);
     }
 

File: dexlib/src/main/java/org/jf/dexlib/Code/Analysis/DeodexUtil.java
Patch:
@@ -116,6 +116,9 @@ public FieldIdItem lookupField(ClassPath.ClassDef classDef, int fieldOffset) {
 
     public MethodIdItem lookupVirtualMethod(ClassPath.ClassDef classDef, int methodIndex) {
         String method = classDef.getVirtualMethod(methodIndex);
+        if (method == null) {
+            return null;
+        }
 
         Matcher m = shortMethodPattern.matcher(method);
         if (!m.matches()) {

File: smali/src/main/java/org/jf/smali/main.java
Patch:
@@ -262,7 +262,7 @@ private static boolean assembleSmaliFile(File smaliFile, DexFile dexFile, boolea
 
         smaliParser.smali_file_return result = parser.smali_file();
 
-        if (parser.getNumberOfSyntaxErrors() > 0 || lexer.getNumberOfLexerErrors() > 0) {
+        if (parser.getNumberOfSyntaxErrors() > 0 || lexer.getNumberOfSyntaxErrors() > 0) {
             return false;
         }
 

File: baksmali/src/main/java/org/jf/baksmali/deodexCheck.java
Patch:
@@ -121,7 +121,7 @@ public static void main(String[] args) {
         }
 
         ClassPath.InitializeClassPath(bootClassPathDirsArray, bootClassPath==null?null:bootClassPath.split(":"), null,
-                null, null);
+                null, null, null);
 
         ClassPath.validateAgainstDeodexerant(deodexerantHost, deodexerantPort, classStartIndex);
     }

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/Format/PackedSwitchMethodItem.java
Patch:
@@ -67,7 +67,7 @@ public PackedSwitchMethodItem(MethodDefinition methodDefinition, CodeItem codeIt
     @Override
     public boolean writeTo(IndentingWriter writer) throws IOException {
         if (dead) {
-            writer.write("'#.packed-switch ");
+            writer.write("#.packed-switch ");
             IntegerRenderer.writeTo(writer, instruction.getFirstKey());
             writer.write('\n');
             for (LabelMethodItem label: labels) {

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/MethodDefinition.java
Patch:
@@ -205,7 +205,7 @@ private static void writeParameters(IndentingWriter writer, CodeItem codeItem,
             writer.write(".parameter");
 
             if (parameterName != null) {
-                writer.write('"');
+                writer.write(" \"");
                 writer.write(parameterName.getStringValue());
                 writer.write('"');
             }

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/MethodDefinition.java
Patch:
@@ -369,7 +369,7 @@ public double getSortOrder() {
                     @Override
                     public boolean writeTo(IndentingWriter writer) throws IOException {
                         writer.write("#@");
-                        IntegerRenderer.writeUnsignedTo(writer, codeAddress);
+                        writer.printLongAsHex(codeAddress & 0xFFFFFFFF);
                         return true;
                     }
                 });

File: dexlib/src/main/java/org/jf/dexlib/TypeIdItem.java
Patch:
@@ -168,7 +168,7 @@ public int getRegisterCount() {
         /** Only the long and double primitive types are 2 words,
          * everything else is a single word
          */
-        if (type.equals("J") || type.equals("D")) {
+        if (type.charAt(0) == 'J' || type.charAt(0) == 'D') {
             return 2;
         } else {
             return 1;

File: baksmali/src/main/java/org/jf/baksmali/deodexCheck.java
Patch:
@@ -120,7 +120,7 @@ public static void main(String[] args) {
             bootClassPathDirsArray[i] = bootClassPathDirs.get(i);
         }
 
-        ClassPath.InitializeClassPath(bootClassPathDirsArray, bootClassPath==null?null:bootClassPath.split(":"),
+        ClassPath.InitializeClassPath(bootClassPathDirsArray, bootClassPath==null?null:bootClassPath.split(":"), null,
                 null, null);
 
         ClassPath.validateAgainstDeodexerant(deodexerantHost, deodexerantPort, classStartIndex);

File: baksmali/src/main/java/org/jf/baksmali/baksmali.java
Patch:
@@ -50,7 +50,7 @@ public class baksmali {
     public static int registerInfo = 0;
     public static String bootClassPath;
 
-    public static void disassembleDexFile(DexFile dexFile, boolean deodex, String outputDirectory,
+    public static void disassembleDexFile(String dexFilePath, DexFile dexFile, boolean deodex, String outputDirectory,
                                           String[] classPathDirs, String bootClassPath, boolean noParameterRegisters,
                                           boolean useLocalsDirective, boolean useSequentialLabels,
                                           boolean outputDebugInfo, boolean addCodeOffsets, int registerInfo,
@@ -68,7 +68,8 @@ public static void disassembleDexFile(DexFile dexFile, boolean deodex, String ou
 
         if (registerInfo != 0 || deodex || verify) {
             try {
-                ClassPath.InitializeClassPath(classPathDirs, bootClassPath==null?null:bootClassPath.split(":"), dexFile);
+                ClassPath.InitializeClassPath(classPathDirs, bootClassPath==null?null:bootClassPath.split(":"),
+                        dexFilePath, dexFile);
             } catch (Exception ex) {
                 System.err.println("\n\nError occured while loading boot class path files. Aborting.");
                 ex.printStackTrace(System.err);

File: baksmali/src/main/java/org/jf/baksmali/deodexCheck.java
Patch:
@@ -120,7 +120,8 @@ public static void main(String[] args) {
             bootClassPathDirsArray[i] = bootClassPathDirs.get(i);
         }
 
-        ClassPath.InitializeClassPath(bootClassPathDirsArray, bootClassPath==null?null:bootClassPath.split(":"), null);
+        ClassPath.InitializeClassPath(bootClassPathDirsArray, bootClassPath==null?null:bootClassPath.split(":"),
+                null, null);
 
         ClassPath.validateAgainstDeodexerant(deodexerantHost, deodexerantPort, classStartIndex);
     }

File: baksmali/src/main/java/org/jf/baksmali/main.java
Patch:
@@ -265,9 +265,9 @@ public static void main(String[] args) {
                     bootClassPathDirsArray[i] = bootClassPathDirs.get(i);
                 }
 
-                baksmali.disassembleDexFile(dexFile, deodex, outputDirectory, bootClassPathDirsArray, bootClassPath,
-                        noParameterRegisters, useLocalsDirective, useSequentialLabels, outputDebugInfo, addCodeOffsets,
-                        registerInfo, verify);
+                baksmali.disassembleDexFile(dexFileFile.getPath(), dexFile, deodex, outputDirectory,
+                        bootClassPathDirsArray, bootClassPath, noParameterRegisters, useLocalsDirective,
+                        useSequentialLabels, outputDebugInfo, addCodeOffsets, registerInfo, verify);
             }
 
             if ((doDump || write) && !dexFile.isOdex()) {

File: baksmali/src/main/java/org/jf/baksmali/main.java
Patch:
@@ -148,7 +148,7 @@ public static void main(String[] args) {
                     String[] values = commandLine.getOptionValues('r');
 
                     if (values == null || values.length == 0) {
-                        registerInfo = ARGS | DEST | MERGE;
+                        registerInfo = ARGS | DEST;
                     } else {
                         for (String value: values) {
                             if (value.equalsIgnoreCase("ALL")) {
@@ -377,7 +377,7 @@ private static void buildOptions() {
                 .withArgName("REGISTER_INFO_TYPES")
                 .withValueSeparator(',')
                 .withDescription("print the specificed type(s) of register information for each instruction. " +
-                        "\"ARGS,DEST,MERGE\" is the default if no types are specified.\nValid values are:\nALL: all " +
+                        "\"ARGS,DEST\" is the default if no types are specified.\nValid values are:\nALL: all " +
                         "pre- and post-instruction registers.\nALLPRE: all pre-instruction registers\nALLPOST: all " +
                         "post-instruction registers\nARGS: any pre-instruction registers used as arguments to the " +
                         "instruction\nDEST: the post-instruction destination register, if any\nMERGE: Any " +

File: baksmali/src/main/java/org/jf/baksmali/Deodex/DeodexUtil.java
Patch:
@@ -41,7 +41,6 @@ public class DeodexUtil {
 
     public DeodexUtil(Deodexerant deodexerant) {
         this.deodexerant = deodexerant;
-        deodexerant.dexFile.disableInterning();
     }
 
     private List<insn> makeInsnList(final CodeItem codeItem) {

File: dexlib/src/main/java/org/jf/dexlib/AnnotationDirectoryItem.java
Patch:
@@ -108,7 +108,7 @@ private AnnotationDirectoryItem(DexFile dexFile, AnnotationSetItem classAnnotati
      * @return an <code>AnnotationItem</code> for the given values, and that has been interned into the given
      * <code>DexFile</code>
      */
-    public static AnnotationDirectoryItem getInternedAnnotationDirectoryItem(DexFile dexFile,
+    public static AnnotationDirectoryItem internAnnotationDirectoryItem(DexFile dexFile,
                                     AnnotationSetItem classAnnotations,
                                     List<FieldAnnotation> fieldAnnotations,
                                     List<MethodAnnotation> methodAnnotations,

File: dexlib/src/main/java/org/jf/dexlib/AnnotationItem.java
Patch:
@@ -68,7 +68,7 @@ private AnnotationItem(DexFile dexFile, AnnotationVisibility visibility,
      * @return an <code>AnnotationItem</code> for the given values, and that has been interned into the given
      * <code>DexFile</code>
      */
-    public static AnnotationItem getInternedAnnotationItem(DexFile dexFile, AnnotationVisibility visibility,
+    public static AnnotationItem internAnnotationItem(DexFile dexFile, AnnotationVisibility visibility,
                            AnnotationEncodedSubValue annotationValue) {
         AnnotationItem annotationItem = new AnnotationItem(dexFile, visibility, annotationValue);
         return dexFile.AnnotationsSection.intern(annotationItem);

File: dexlib/src/main/java/org/jf/dexlib/AnnotationSetItem.java
Patch:
@@ -63,7 +63,7 @@ private AnnotationSetItem(DexFile dexFile, AnnotationItem[] annotations) {
      * @param annotations The annotations for this <code>AnnotationSetItem</code>
      * @return an <code>AnnotationSetItem</code> for the given annotations
      */
-    public static AnnotationSetItem getInternedAnnotationSetItem(DexFile dexFile, List<AnnotationItem> annotations) {
+    public static AnnotationSetItem internAnnotationSetItem(DexFile dexFile, List<AnnotationItem> annotations) {
         AnnotationItem[] annotationsArray = new AnnotationItem[annotations.size()];
         annotations.toArray(annotationsArray);
         AnnotationSetItem annotationSetItem = new AnnotationSetItem(dexFile, annotationsArray);

File: dexlib/src/main/java/org/jf/dexlib/AnnotationSetRefList.java
Patch:
@@ -63,7 +63,7 @@ private AnnotationSetRefList(DexFile dexFile, AnnotationSetItem[] annotationSets
      * @param annotationSets The annotation sets for this <code>AnnotationSetRefList</code>
      * @return an <code>AnnotationSetItem</code> for the given annotations
      */
-    public static AnnotationSetRefList getInternedAnnotationSetRefList(DexFile dexFile,
+    public static AnnotationSetRefList internAnnotationSetRefList(DexFile dexFile,
                                                                        List<AnnotationSetItem> annotationSets) {
         AnnotationSetItem[] annotationSetsArray = new AnnotationSetItem[annotationSets.size()];
         annotationSets.toArray(annotationSetsArray);

File: dexlib/src/main/java/org/jf/dexlib/ClassDataItem.java
Patch:
@@ -75,7 +75,7 @@ private ClassDataItem(DexFile dexFile, EncodedField[] staticFields, EncodedField
      * @param virtualMethods The virtual methods for this class
      * @return a new <code>ClassDataItem</code> with the given values
      */
-    public static ClassDataItem getInternedClassDataItem(DexFile dexFile, List<EncodedField> staticFields,
+    public static ClassDataItem internClassDataItem(DexFile dexFile, List<EncodedField> staticFields,
                                                          List<EncodedField> instanceFields,
                                                          List<EncodedMethod> directMethods,
                                                          List<EncodedMethod> virtualMethods) {

File: dexlib/src/main/java/org/jf/dexlib/CodeItem.java
Patch:
@@ -105,7 +105,7 @@ private CodeItem(DexFile dexFile,
      * @param encodedCatchHandlers a list of the exception handlers defined for this code/method or null if none
      * @return a new <code>CodeItem</code> with the given values.
      */
-    public static CodeItem getInternedCodeItem(DexFile dexFile,
+    public static CodeItem internCodeItem(DexFile dexFile,
                     int registerCount,
                     int inWords,
                     int outWords,

File: dexlib/src/main/java/org/jf/dexlib/DebugInfoItem.java
Patch:
@@ -87,7 +87,7 @@ private DebugInfoItem(DexFile dexFile,
      * debug info
      * @return a new <code>DebugInfoItem</code> with the given values
      */
-    public static DebugInfoItem getInternedDebugInfoItem(DexFile dexFile,
+    public static DebugInfoItem internDebugInfoItem(DexFile dexFile,
                          int lineStart,
                          StringIdItem[] parameterNames,
                          byte[] encodedDebugInfo,

File: dexlib/src/main/java/org/jf/dexlib/EncodedArrayItem.java
Patch:
@@ -62,7 +62,7 @@ private EncodedArrayItem(DexFile dexFile, ArrayEncodedSubValue encodedArray) {
      * @param encodedArray The encoded array value
      * @return an <code>EncodedArrayItem</code> for the given values, and that has been interned into the given
      */
-    public static EncodedArrayItem getInternedEncodedArrayItem(DexFile dexFile, ArrayEncodedSubValue encodedArray) {
+    public static EncodedArrayItem internEncodedArrayItem(DexFile dexFile, ArrayEncodedSubValue encodedArray) {
         EncodedArrayItem encodedArrayItem = new EncodedArrayItem(dexFile, encodedArray);
         return dexFile.EncodedArraysSection.intern(encodedArrayItem);
     }

File: dexlib/src/main/java/org/jf/dexlib/Section.java
Patch:
@@ -178,7 +178,7 @@ protected T intern(T item) {
             return null;
         }
         T internedItem = getInternedItem(item);
-        if (internedItem == null && !item.dexFile.getInterningDisabled()) {
+        if (internedItem == null) {
             uniqueItems.put(item, item);
             items.add(item);
             return item;

File: baksmali/src/main/java/org/jf/baksmali/main.java
Patch:
@@ -325,7 +325,7 @@ private static void buildOptions() {
 
         Option classPathOption = OptionBuilder.withLongOpt("bootclasspath")
                 .withDescription("the bootclasspath jars to use, for analysis")
-                .hasArg()
+                .hasOptionalArg()
                 .withArgName("BOOTCLASSPATH")
                 .create("c");
 

File: dexlib/src/main/java/org/jf/dexlib/Code/Analysis/MethodAnalyzer.java
Patch:
@@ -1717,6 +1717,7 @@ private boolean handleAputObject(AnalyzedInstruction analyzedInstruction) {
         if (sourceRegisterType.category == RegisterType.Category.Unknown) {
             return false;
         }
+        //TODO: ensure sourceRegisterType is a Reference type?
 
         RegisterType arrayRegisterType = analyzedInstruction.getPreInstructionRegisterType(instruction.getRegisterB());
         assert arrayRegisterType != null;
@@ -1972,7 +1973,7 @@ private boolean handleIputObject(AnalyzedInstruction analyzedInstruction) {
         if (sourceRegisterType.category == RegisterType.Category.Unknown) {
             return false;
         }
-        checkRegister(objectRegisterType, ReferenceCategories);
+        checkRegister(sourceRegisterType, ReferenceCategories);
 
         //TODO: check access
         //TODO: allow an uninitialized "this" reference, if the current method is an <init> method

File: smali/src/main/java/org/jf/smali/OdexedInstructionException.java
Patch:
@@ -40,7 +40,7 @@ public class OdexedInstructionException extends RecognitionException {
     }
 
     public String getMessage() {
-        return odexedInstruction + " is an odexed instruction. You cannot recompile a disassembled odex file " +
+        return odexedInstruction + " is an odexed instruction. You cannot reassemble a disassembled odex file " +
                 "unless it has been deodexed.";
     }
 }

File: baksmali/src/main/java/org/jf/baksmali/baksmali.java
Patch:
@@ -44,15 +44,17 @@ public class baksmali {
     public static boolean noParameterRegisters = false;
     public static boolean useLocalsDirective = false;
     public static boolean useIndexedLabels = false;
+    public static boolean outputDebugInfo = true;
     public static DeodexUtil deodexUtil = null;
 
     public static void disassembleDexFile(DexFile dexFile, Deodexerant deodexerant, String outputDirectory,
                                           boolean noParameterRegisters, boolean useLocalsDirective,
-                                          boolean useIndexedLabels)
+                                          boolean useIndexedLabels, boolean outputDebugInfo)
     {
         baksmali.noParameterRegisters = noParameterRegisters;
         baksmali.useLocalsDirective = useLocalsDirective;
         baksmali.useIndexedLabels = useIndexedLabels;
+        baksmali.outputDebugInfo = outputDebugInfo;
 
         if (deodexerant != null) {
             baksmali.deodexUtil = new DeodexUtil(deodexerant);

File: dexlib/src/main/java/org/jf/dexlib/CodeItem.java
Patch:
@@ -547,8 +547,8 @@ private void replaceInstructionAtOffset(int offset, Instruction replacementInstr
                 assert originalOffsetsByNewOffset.indexOfKey(currentCodeOffset) >= 0;
                 int originalDataOffset = originalOffsetsByNewOffset.get(currentCodeOffset);
 
-                int originalSwitchOffset = originalSwitchOffsetByOriginalSwitchDataOffset.get(originalDataOffset);
-                if (originalSwitchOffset == 0) {
+                int originalSwitchOffset = originalSwitchOffsetByOriginalSwitchDataOffset.get(originalDataOffset, -1);
+                if (originalSwitchOffset == -1) {
                     throw new RuntimeException("This method contains an unreferenced switch data block, and can't be automatically fixed.");
                 }
 

File: dexlib/src/main/java/org/jf/dexlib/CodeItem.java
Patch:
@@ -549,8 +549,7 @@ private void replaceInstructionAtOffset(int offset, Instruction replacementInstr
 
                 int originalSwitchOffset = originalSwitchOffsetByOriginalSwitchDataOffset.get(originalDataOffset);
                 if (originalSwitchOffset == 0) {
-                    //TODO: is it safe to skip an unreferenced switch data instruction? Or should it throw an exception?
-                    continue;
+                    throw new RuntimeException("This method contains an unreferenced switch data block, and can't be automatically fixed.");
                 }
 
                 assert newOffsetsByOriginalOffset.indexOfKey(originalSwitchOffset) >= 0;

File: dexlib/src/main/java/org/jf/dexlib/CodeItem.java
Patch:
@@ -581,7 +581,9 @@ private void replaceInstructionAtOffset(int offset, Instruction replacementInstr
 
             assert debugInstructionFixer.result != null;
 
-            debugInfo.setEncodedDebugInfo(debugInstructionFixer.result);
+            if (debugInstructionFixer.result != null) {
+                debugInfo.setEncodedDebugInfo(debugInstructionFixer.result);
+            }
         }
 
         if (encodedCatchHandlers != null) {

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/MethodDefinition.java
Patch:
@@ -526,8 +526,8 @@ private void addTries() {
                 return;
             }
             for (CodeItem.TryItem tryItem: codeItem.getTries()) {
-                int startAddress = tryItem.startAddress;
-                int endAddress = tryItem.startAddress + tryItem.instructionCount;
+                int startAddress = tryItem.getStartAddress();
+                int endAddress = tryItem.getStartAddress() + tryItem.getInstructionCount();
 
                 /**
                  * The end address points to the address immediately after the end of the last

File: dexlib/src/main/java/org/jf/dexlib/Util/DeodexUtil.java
Patch:
@@ -166,8 +166,8 @@ private List<insn> makeInsnList(final CodeItem codeItem) {
                     handlers[i] = insnsMap.get(tryItem.encodedCatchHandler.handlers[i].getHandlerAddress());
                 }
 
-                int insnoffset = tryItem.startAddress;
-                while (insnoffset < tryItem.startAddress + tryItem.instructionCount) {
+                int insnoffset = tryItem.getStartAddress();
+                while (insnoffset < tryItem.getStartAddress() + tryItem.getInstructionCount()) {
                     insn i = insnsMap.get(insnoffset);
 
                     i.exceptionHandlers = handlers;

File: dexlib/src/main/java/org/jf/dexlib/Debug/DebugInstructionIterator.java
Patch:
@@ -140,7 +140,7 @@ public static void IterateInstructions(Input in, ProcessRawDebugInstructionDeleg
                 }
                 default:
                 {
-                    byte base = (byte)((debugOpcode & 0xFF) - 0x0A);
+                    int base = ((debugOpcode & 0xFF) - 0x0A);
                     processDebugInstruction.ProcessSpecialOpcode(startOffset, debugOpcode, (base % 15) - 4, base / 15);
                 }
             }

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/Format/Instruction31tMethodItem.java
Patch:
@@ -43,7 +43,7 @@ public Instruction31tMethodItem(MethodDefinition.LabelCache labelCache, CodeItem
 
     protected void setAttributes(StringTemplate template) {
         super.setAttributes(template);
-        template.setAttribute("Register", formatRegister(instruction.getRegister()));
+        template.setAttribute("Register", formatRegister(instruction.getRegisterA()));
     }
 
     protected String getLabelPrefix() {

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/Format/PackedSwitchMethodItem.java
Patch:
@@ -48,7 +48,7 @@ public PackedSwitchMethodItem(MethodDefinition.LabelCache labelCache, CodeItem c
                                   int baseAddress) {
         super(codeItem, offset, stg, instruction);
 
-        Iterator<PackedSwitchDataPseudoInstruction.PackedSwitchTarget> iterator = instruction.getTargets();
+        Iterator<PackedSwitchDataPseudoInstruction.PackedSwitchTarget> iterator = instruction.iterateKeysAndTargets();
         while (iterator.hasNext()) {
             PackedSwitchDataPseudoInstruction.PackedSwitchTarget target = iterator.next();
             LabelMethodItem label = new LabelMethodItem(baseAddress + target.target, stg, "pswitch_");

File: dexlib/src/main/java/org/jf/dexlib/Code/OffsetInstruction.java
Patch:
@@ -30,4 +30,5 @@
 
 public interface OffsetInstruction {
     public int getOffset();
+    public void updateOffset(int offset);
 }

File: dexlib/src/main/java/org/jf/dexlib/HeaderItem.java
Patch:
@@ -32,8 +32,6 @@
 import org.jf.dexlib.Util.Input;
 import org.jf.dexlib.Util.Utf8Utils;
 
-import java.io.UnsupportedEncodingException;
-
 public class HeaderItem extends Item<HeaderItem> {
     /**
      * the file format magic number, represented as the

File: dexlib/src/main/java/org/jf/dexlib/OdexHeaderItem.java
Patch:
@@ -30,8 +30,6 @@
 
 import org.jf.dexlib.Util.Input;
 
-import java.io.UnsupportedEncodingException;
-
 public class OdexHeaderItem {
 
     /**

File: dexlib/src/main/java/org/jf/dexlib/Util/ByteArrayInput.java
Patch:
@@ -111,7 +111,7 @@ public int readShort() {
         }
 
         cursor = end;
-        return (int)((data[readAt] & 0xff) +
+        return ((data[readAt] & 0xff) +
                 ((data[readAt + 1] & 0xff) << 8));
     }
 

File: dexlib/src/main/java/org/jf/dexlib/AnnotationDirectoryItem.java
Patch:
@@ -322,7 +322,7 @@ public AnnotationSetItem getClassAnnotations() {
     }
 
     /**
-     * Iterates over the field annotations, calling delegate.processFieldAnnotations for each 
+     * Iterates over the field annotations, calling delegate.processFieldAnnotations for each
      * @param delegate the delegate to call
      */
     public void iterateFieldAnnotations(FieldAnnotationIteratorDelegate delegate) {
@@ -364,7 +364,7 @@ public int getMethodAnnotationCount() {
     }
 
     /**
-     * Iterates over the parameter annotations, calling delegate.processParameterAnnotations for each 
+     * Iterates over the parameter annotations, calling delegate.processParameterAnnotations for each
      * @param delegate the delegate to call
      */
     public void iterateParameterAnnotations(ParameterAnnotationIteratorDelegate delegate) {

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/AnnotationEncodedValue.java
Patch:
@@ -47,7 +47,7 @@ protected AnnotationEncodedValue(DexFile dexFile, Input in) {
 
     /**
      * Constructs a new <code>AnnotationEncodedValue</code> with the given values. names and values must be the same
-     * length, and must be sorted according to the name  
+     * length, and must be sorted according to the name
      * @param annotationType The type of the annotation
      * @param names An array of the names of the elements of the annotation
      * @param values An array of the values of the elements on the annotation

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/BooleanEncodedValue.java
Patch:
@@ -32,7 +32,7 @@
 
 public class BooleanEncodedValue extends EncodedValue {
     /**
-     * The dupliton values 
+     * The dupliton values
      */
     public static final BooleanEncodedValue TrueValue = new BooleanEncodedValue(true);
     public static final BooleanEncodedValue FalseValue = new BooleanEncodedValue(false);
@@ -51,15 +51,15 @@ private BooleanEncodedValue(boolean value) {
      * Gets the <code>BooleanEncodedValue</code> for the given valueArg value. The high 3 bits of the first byte should
      * be passed as the valueArg parameter
      * @param valueArg The high 3 bits of the first byte of this encoded value
-     * @return the <code>BooleanEncodedValue</code> for the given valueArg value 
+     * @return the <code>BooleanEncodedValue</code> for the given valueArg value
      */
     protected static BooleanEncodedValue getBooleanEncodedValue(byte valueArg) {
         if (valueArg == 0) {
             return FalseValue;
         } else if (valueArg == 1) {
             return TrueValue;
         }
-        throw new RuntimeException("valueArg must be either 0 or 1");        
+        throw new RuntimeException("valueArg must be either 0 or 1");
     }
 
     /**

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/ByteEncodedValue.java
Patch:
@@ -41,7 +41,7 @@ public class ByteEncodedValue extends EncodedValue {
      * @param in The <code>Input</code> object to read from
      */
     protected ByteEncodedValue(Input in) {
-        value = (byte)EncodedValueUtils.decodeSignedIntegralValue(in.readBytes(1)); 
+        value = (byte)EncodedValueUtils.decodeSignedIntegralValue(in.readBytes(1));
     }
 
     /**
@@ -59,7 +59,7 @@ public void writeValue(AnnotatedOutput out) {
             out.annotate(1, "value: 0x" + Integer.toHexString(value) + " (" + value + ")");
         }
         out.writeByte(ValueType.VALUE_BYTE.value);
-        out.writeByte(value);        
+        out.writeByte(value);
     }
 
     /** {@inheritDoc} */

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/DoubleEncodedValue.java
Patch:
@@ -44,7 +44,7 @@ public class DoubleEncodedValue extends EncodedValue {
      */
     protected DoubleEncodedValue(Input in, byte valueArg) {
         long longValue = EncodedValueUtils.decodeRightZeroExtendedValue(in.readBytes(valueArg + 1));
-        value = Double.longBitsToDouble(longValue); 
+        value = Double.longBitsToDouble(longValue);
     }
 
     /**

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/EncodedValue.java
Patch:
@@ -100,9 +100,9 @@ public int compareTo(EncodedValue o) {
 
     /**
      * Compare the value of this <code>EncodedValue</code> against the value of the given <EncodedValue>, which
-     * is guaranteed to be of the same type as this <code>EncodedValue</code> 
+     * is guaranteed to be of the same type as this <code>EncodedValue</code>
      * @param o The <code>EncodedValue</code> to compare against
-     * @return A standard comparison integer value 
+     * @return A standard comparison integer value
      */
     protected abstract int compareValue(EncodedValue o);
 

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/FloatEncodedValue.java
Patch:
@@ -44,7 +44,7 @@ public class FloatEncodedValue extends EncodedValue {
      */
     protected FloatEncodedValue(Input in, byte valueArg) {
         long longValue = EncodedValueUtils.decodeRightZeroExtendedValue(in.readBytes(valueArg + 1));
-        value = Float.intBitsToFloat((int)((longValue >> 32) & 0xFFFFFFFFL)); 
+        value = Float.intBitsToFloat((int)((longValue >> 32) & 0xFFFFFFFFL));
     }
 
     /**

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/IntEncodedValue.java
Patch:
@@ -43,7 +43,7 @@ public class IntEncodedValue extends EncodedValue {
      * @param valueArg The high 3 bits of the first byte of this encoded value
      */
     protected IntEncodedValue(Input in, byte valueArg) {
-        value = (int)EncodedValueUtils.decodeSignedIntegralValue(in.readBytes(valueArg+1)); 
+        value = (int)EncodedValueUtils.decodeSignedIntegralValue(in.readBytes(valueArg+1));
     }
 
     /**

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/NullEncodedValue.java
Patch:
@@ -46,7 +46,7 @@ private NullEncodedValue() {
     public void writeValue(AnnotatedOutput out) {
         if (out.annotates()) {
             out.annotate("value_type=" + ValueType.VALUE_NULL.name() + ",value_arg=0");
-        }        
+        }
         out.writeByte(ValueType.VALUE_NULL.value);
     }
 

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/ShortEncodedValue.java
Patch:
@@ -43,7 +43,7 @@ public class ShortEncodedValue extends EncodedValue {
      * @param valueArg The high 3 bits of the first byte of this encoded value
      */
     protected ShortEncodedValue(Input in, byte valueArg) {
-        value = (short) EncodedValueUtils.decodeSignedIntegralValue(in.readBytes(valueArg+1)); 
+        value = (short) EncodedValueUtils.decodeSignedIntegralValue(in.readBytes(valueArg+1));
     }
 
     /**

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/EndTryLabelMethodItem.java
Patch:
@@ -34,7 +34,7 @@ public class EndTryLabelMethodItem extends LabelMethodItem {
     private int labelOffset;
 
     public EndTryLabelMethodItem(int offset, StringTemplateGroup stg, int labelOffset) {
-        super(offset, stg, "try_end_", false);
+        super(offset, stg, "try_end_");
         this.labelOffset = labelOffset;
     }
 

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/BlankMethodItem.java
Patch:
@@ -42,7 +42,6 @@ public BlankMethodItem(StringTemplateGroup stg, int offset) {
         }
     }
 
-
     public int getSortOrder() {
         return Integer.MAX_VALUE;
     }

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/EndTryLabelMethodItem.java
Patch:
@@ -34,7 +34,7 @@ public class EndTryLabelMethodItem extends LabelMethodItem {
     private int labelOffset;
 
     public EndTryLabelMethodItem(int offset, StringTemplateGroup stg, int labelOffset) {
-        super(offset, stg, "try_end_");
+        super(offset, stg, "try_end_", false);
         this.labelOffset = labelOffset;
     }
 

File: dexlib/src/main/java/org/jf/dexlib/Util/DeodexUtil.java
Patch:
@@ -1369,7 +1369,7 @@ public void propogateRegisters() {
                         if (regType == RegisterType.Reference) {
                             String regReferenceType = findCommonSuperclass(registerTypes[i],
                                     nextInsn.registerTypes[i]);
-                            if (!regReferenceType.equals(nextInsn.registerTypes[i])) {
+                            if (regReferenceType != null && !regReferenceType.equals(nextInsn.registerTypes[i])) {
                                 //see comment above for loop
                                 if (i == nextInsn.objectRegisterNum) {
                                     nextInsn.fixedInstruction = null;
@@ -1401,8 +1401,7 @@ public void propogateRegisters() {
                             String type = destRegisterType();
                             String nextType = nextInsn.registerTypes[registerNum];
 
-                            if ((type == null && nextType == null) ||
-                                    !type.equals(nextInsn.registerTypes[registerNum])) {
+                            if (type != null && !type.equals(nextInsn.registerTypes[registerNum])) {
                                 //see comment above for loop
                                 if (registerNum == nextInsn.objectRegisterNum) {
                                     nextInsn.fixedInstruction = null;

File: dexlib/src/main/java/org/jf/dexlib/DexFile.java
Patch:
@@ -497,15 +497,15 @@ protected Section[] getOrderedSections() {
         int sectionCount = 0;
 
         for (Section section: sectionsByType) {
-            if (section != null && (section.ItemType.isIndexedItem() || section.getItems().size() > 0)) {
+            if (section != null && section.getItems().size() > 0) {
                 sectionCount++;
             }
         }
 
         Section[] sections = new Section[sectionCount];
         sectionCount = 0;
         for (Section section: sectionsByType) {
-            if (section != null && (section.ItemType.isIndexedItem() || section.getItems().size() > 0)) {
+            if (section != null && section.getItems().size() > 0) {
                 sections[sectionCount++] = section;
             }
         }

File: dexlib/src/main/java/org/jf/dexlib/Section.java
Patch:
@@ -52,7 +52,7 @@ public abstract class Section<T extends Item> {
     /**
      * The offset of this section within the <code>DexFile</code>
      */
-    protected int offset = -1;
+    protected int offset = 0;
 
     /**
      * The type of item that this section holds
@@ -93,7 +93,7 @@ protected int placeAt(int offset) {
                 offset = item.placeAt(offset, i);
             }
         } else {
-            this.offset = -1;
+            this.offset = 0;
         }
 
         return offset;

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/Format/Instruction22csnMethodItem.java
Patch:
@@ -40,6 +40,6 @@ public Instruction22csnMethodItem(CodeItem codeItem, int offset, StringTemplateG
     }
 
     protected void setAttributes(StringTemplate template) {
-        template.setAttribute("Register", instruction.RegisterNum);
+        template.setAttribute("Register", formatRegister(instruction.RegisterNum));
     }
 }

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/Format/Instruction35msnMethodItem.java
Patch:
@@ -40,6 +40,6 @@ public Instruction35msnMethodItem(CodeItem codeItem, int offset, StringTemplateG
     }
 
     protected void setAttributes(StringTemplate template) {
-        template.setAttribute("Register", instruction.RegisterNum);
+        template.setAttribute("Register", formatRegister(instruction.RegisterNum));
     }
 }

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/ByteEncodedValue.java
Patch:
@@ -71,7 +71,7 @@ public int placeValue(int offset) {
     protected int compareValue(EncodedValue o) {
         ByteEncodedValue other = (ByteEncodedValue)o;
 
-        return value - other.value;
+         return (value<other.value?-1:(value>other.value?1:0));
     }
 
     /** {@inheritDoc} */

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/CharEncodedValue.java
Patch:
@@ -78,7 +78,7 @@ public int placeValue(int offset) {
     protected int compareValue(EncodedValue o) {
         CharEncodedValue other = (CharEncodedValue)o;
 
-        return value - other.value;
+         return (value<other.value?-1:(value>other.value?1:0));
     }
 
     /** {@inheritDoc} */

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/IntEncodedValue.java
Patch:
@@ -76,7 +76,7 @@ public int placeValue(int offset) {
     protected int compareValue(EncodedValue o) {
         IntEncodedValue other = (IntEncodedValue)o;
 
-        return value - other.value;
+        return (value<other.value?-1:(value>other.value?1:0));
     }
 
     /** {@inheritDoc} */

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/LongEncodedValue.java
Patch:
@@ -76,7 +76,7 @@ public int placeValue(int offset) {
     protected int compareValue(EncodedValue o) {
         LongEncodedValue other = (LongEncodedValue)o;
 
-        return Long.signum(value - other.value);
+        return (value<other.value?-1:(value>other.value?1:0));
     }
 
     /** {@inheritDoc} */

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/ShortEncodedValue.java
Patch:
@@ -76,7 +76,7 @@ public int placeValue(int offset) {
     protected int compareValue(EncodedValue o) {
         ShortEncodedValue other = (ShortEncodedValue)o;
 
-        return value - other.value;
+         return (value<other.value?-1:(value>other.value?1:0));
     }
 
     /** {@inheritDoc} */

File: dexlib/src/main/java/org/jf/dexlib/Code/Format/Instruction10x.java
Patch:
@@ -38,6 +38,7 @@ public class Instruction10x extends Instruction {
 
     public static void emit(Output out, Opcode opcode) {
         out.writeByte(opcode.value);
+        out.writeByte(0);
     }
 
     public Instruction10x(Opcode opcode, byte[] buffer, int bufferIndex) {

File: dexlib/src/main/java/org/jf/dexlib/Code/Format/Instruction20t.java
Patch:
@@ -43,6 +43,7 @@ public static void emit(Output out, Opcode opcode, short offA) {
         }
 
         out.writeByte(opcode.value);
+        out.writeByte(0);
         out.writeShort(offA);
     }
 

File: dexlib/src/main/java/org/jf/dexlib/Code/Format/Instruction30t.java
Patch:
@@ -40,6 +40,7 @@ public class Instruction30t extends Instruction
 
     public static void emit(Output out, Opcode opcode, int offA) {
         out.writeByte(opcode.value);
+        out.writeByte(0);
         out.writeInt(offA);
     }
 

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/BooleanEncodedValue.java
Patch:
@@ -79,7 +79,7 @@ public void writeValue(AnnotatedOutput out) {
         if (out.annotates()) {
             out.annotate("value_type=" + ValueType.VALUE_BOOLEAN.name() + ",value=" + Boolean.toString(value));
         }
-        out.writeByte(ValueType.VALUE_BOOLEAN.value | (value?1:0 << 5));
+        out.writeByte(ValueType.VALUE_BOOLEAN.value | ((value?1:0) << 5));
     }
 
     /** {@inheritDoc} */

File: dexlib/src/main/java/org/jf/dexlib/CodeItem.java
Patch:
@@ -244,7 +244,7 @@ public void ProcessFillArrayDataInstruction(int index, int elementWidth, int ele
         if (debugInfo == null) {
             out.writeInt(0);
         } else {
-            out.writeInt(debugInfo.getIndex());
+            out.writeInt(debugInfo.getOffset());
         }
         out.writeInt(encodedInstructions.length / 2);
         InstructionWriter.writeInstructions(encodedInstructions, referencedItems, out);

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/ArrayEncodedSubValue.java
Patch:
@@ -66,7 +66,6 @@ public ArrayEncodedSubValue(EncodedValue[] values) {
 
     /** {@inheritDoc} */
     public void writeValue(AnnotatedOutput out) {
-        out.writeByte(ValueType.VALUE_ARRAY.value);
         out.writeUnsignedLeb128(values.length);
         for (EncodedValue encodedValue: values) {
             encodedValue.writeValue(out);

File: dexlib/src/main/java/org/jf/dexlib/CodeItem.java
Patch:
@@ -237,7 +237,7 @@ public void ProcessFillArrayDataInstruction(int index, int elementWidth, int ele
         InstructionWriter.writeInstructions(encodedInstructions, referencedItems, out);
 
         if (tries != null && tries.length > 0) {
-            if ((tries.length % 2) == 1) {
+            if ((encodedInstructions.length % 4) != 0) {
                 out.writeShort(0);
             }
 

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/ArrayEncodedSubValue.java
Patch:
@@ -75,7 +75,7 @@ public void writeValue(AnnotatedOutput out) {
 
     /** {@inheritDoc} */
     public int placeValue(int offset) {
-        offset = offset + 1 + Leb128Utils.unsignedLeb128Size(values.length);
+        offset = offset + Leb128Utils.unsignedLeb128Size(values.length);
         for (EncodedValue encodedValue: values) {
             offset = encodedValue.placeValue(offset);
         }

File: dexlib/src/main/java/org/jf/dexlib/StringDataItem.java
Patch:
@@ -75,7 +75,8 @@ protected void readItem(Input in, ReadContext readContext) {
 
     /** {@inheritDoc} */
     protected int placeItem(int offset) {
-        return offset + 4 + Utf8Utils.stringToUtf8Bytes(stringValue).length + 1;
+        return offset + Leb128Utils.unsignedLeb128Size(stringValue.length()) +
+                Utf8Utils.stringToUtf8Bytes(stringValue).length + 1;
     }
 
     /** {@inheritDoc} */

File: dexlib/src/main/java/org/jf/dexlib/Item.java
Patch:
@@ -95,7 +95,7 @@ protected void writeTo(AnnotatedOutput out) {
 
         if (out.getCursor() != offset) {
             throw new RuntimeException("Item was placed at offset 0x" + Integer.toHexString(offset) +
-                    "but is being written to offset 0x" + Integer.toHexString(out.getCursor()));
+                    " but is being written to offset 0x" + Integer.toHexString(out.getCursor()));
         }
 
         if (out.annotates()) {

File: dexlib/src/main/java/org/jf/dexlib/Debug/DebugInstructionIterator.java
Patch:
@@ -231,7 +231,7 @@ public static void DecodeInstructions(DebugInfoItem debugInfoItem, int registerC
                 }
                 default:
                 {
-                    byte base = (byte)((debugOpcode & 0xFF) - 0x0A);
+                    int base = ((debugOpcode & 0xFF) - 0x0A);
                     address += base / 15;
                     line += (base % 15) - 4;
                     processDecodedDebugInstruction.ProcessLineEmit(address, line);

File: smali/src/main/java/org/jf/smali/main.java
Patch:
@@ -270,7 +270,7 @@ private static void buildOptions() {
                 .create("d");
 
         Option outputOption = OptionBuilder.withLongOpt("output")
-                .withDescription("the directory where the disassembled files will be placed. The default is out.dex")
+                .withDescription("the name of the dex file that will be written. The default is out.dex")
                 .hasArg()
                 .withArgName("FILE")
                 .create("o");

File: dexlib/src/main/java/org/jf/dexlib/ClassDataItem.java
Patch:
@@ -287,7 +287,7 @@ public static class EncodedMethod extends EncodedMember<EncodedMethod> {
         private final OffsettedItemReference<CodeItem> codeItemReferenceField;
 
         public EncodedMethod(DexFile dexFile, final EncodedMethod previousMethod) {
-            super("encedod_method");
+            super("encoded_method");
             Leb128DeltaField previousIndexField = null;
             if (previousMethod != null) {
                 previousIndexField = previousMethod.methodIndexField;

File: dexlib/src/main/java/org/jf/dexlib/Util/DebugInfoBuilder.java
Patch:
@@ -221,6 +221,7 @@ public void emit(DexFile dexFile, List<DebugInstruction> debugInstructions) {
                 addressDelta = 0;
             }
 
+            //TODO: need to handle the case when the line delta is larger than a signed int
             debugInstructions.add(new SpecialOpcode(calculateSpecialOpcode(lineDelta, addressDelta)));
 
 

File: baksmali/src/main/java/org/jf/baksmali/main.java
Patch:
@@ -95,7 +95,7 @@ public static void main(String[] args) {
         if (commandLine.hasOption("D")) {
             doDump = true;
             disassemble = false;
-            dumpFileName = commandLine.getOptionValue("d", inputDexFileName + ".dump");
+            dumpFileName = commandLine.getOptionValue("D", inputDexFileName + ".dump");
         }
 
         if (commandLine.hasOption("w")) {

File: dexlib/src/main/java/org/jf/dexlib/CodeItem.java
Patch:
@@ -152,7 +152,7 @@ public void copyTo(DexFile dexFile, CodeItem copy)
         triesListField.copyTo(dexFile, copy.triesListField);
 
         DebugInfoItem copyDebugInfo = copy.getDebugInfo();
-        if (copy != null) {
+        if (copyDebugInfo != null) {
             copyDebugInfo.setParent(copy);
         }
     }

File: dexlib/src/main/java/org/jf/dexlib/DexFile.java
Patch:
@@ -588,7 +588,7 @@ protected MapItem make(int index) {
             return new MapItem(dexFile, index);
         }
 
-        public MapItem intern(DexFile dexFile, MapItem item) {
+        public MapItem intern(MapItem item) {
             this.items.add(item);
             return item;
         }

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/EncodedValueSubField.java
Patch:
@@ -35,4 +35,5 @@ public interface EncodedValueSubField<T extends EncodedValueSubField> extends Fi
     public void setInitialValueArg(byte valueArg);
     public byte getValueArg();
     public ValueType getValueType();
+    public int compareTo(EncodedValueSubField encodedValueSubField);
 }

File: dexlib/src/main/java/org/jf/dexlib/IndexedItem.java
Patch:
@@ -28,7 +28,7 @@
 
 package org.jf.dexlib;
 
-public abstract class IndexedItem<T extends IndexedItem> extends Item<T> implements Comparable<T> {
+public abstract class IndexedItem<T extends IndexedItem> extends Item<T> {
     protected IndexedItem(int index) {
         this.index = index;
     }

File: dexlib/src/main/java/org/jf/dexlib/Item.java
Patch:
@@ -31,7 +31,7 @@
 import org.jf.dexlib.Util.AnnotatedOutput;
 import org.jf.dexlib.Util.Input;
 
-public abstract class Item<T extends Item> {
+public abstract class Item<T extends Item> implements Comparable<T> {
     protected int offset = -1;
     protected int index = -1;
     

File: dexlib/src/main/java/org/jf/dexlib/TypeListItem.java
Patch:
@@ -31,7 +31,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-public class TypeListItem extends OffsettedItem<TypeListItem> implements Comparable<TypeListItem> {
+public class TypeListItem extends OffsettedItem<TypeListItem> {
     private final ArrayList<IndexedItemReference<TypeIdItem>> typeList = new ArrayList<IndexedItemReference<TypeIdItem>>();
 
     private final ListSizeField sizeField;

File: smali/src/main/java/org/jf/smali/smali.java
Patch:
@@ -33,11 +33,13 @@
 import org.antlr.runtime.tree.CommonTree;
 import org.antlr.runtime.tree.CommonTreeNodeStream;
 import org.jf.dexlib.DexFile;
+import org.jf.dexlib.AnnotationItem;
 import org.jf.dexlib.Util.ByteArrayAnnotatedOutput;
 
 import java.io.*;
 import java.util.LinkedHashSet;
 import java.util.Set;
+import java.util.List;
 
 public class smali
 {
@@ -125,7 +127,7 @@ public static void main(String[] args) throws Exception
             System.exit(1);
         }
 
-        dexFile.place();
+        dexFile.place(false);
         try
         {
             ByteArrayAnnotatedOutput out = new ByteArrayAnnotatedOutput();

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/LocalDebugMethodItem.java
Patch:
@@ -29,6 +29,7 @@
 package org.jf.baksmali.Adaptors;
 
 import org.jf.dexlib.Util.DebugInfoDecoder;
+import org.jf.dexlib.Util.Utf8Utils;
 
 public class LocalDebugMethodItem extends DebugMethodItem {
     private DebugInfoDecoder.Local local;
@@ -61,6 +62,6 @@ public String getSignature() {
         if (local.signature == null) {
             return null;
         }
-        return local.signature.getStringValue();
+        return Utf8Utils.escapeString(local.signature.getStringValue());
     }
 }

File: dexlib/src/main/java/org/jf/dexlib/code/Format/Instruction35c.java
Patch:
@@ -116,7 +116,7 @@ public byte getRegisterF() {
     }
 
     public byte getRegisterG() {
-        return NumberUtils.decodeLowUnsignedNibble(encodedInstruction[5]);
+        return NumberUtils.decodeHighUnsignedNibble(encodedInstruction[5]);
     }
 
     private void checkItem() {

File: baksmali/src/main/java/org/jf/baksmali/Renderers/ByteRenderer.java
Patch:
@@ -42,7 +42,7 @@ public String toString(Object o) {
     public String toString(Object o, String s) {
         if (s.equals("unsigned")) {
             Byte b = (Byte)o;
-            return "0x" + Integer.toHexString(b & 0xFF);   
+            return "0x" + Integer.toHexString(b & 0xFF) + "t";   
         }
         return toString(o);
     }

File: smali/src/main/java/org/jf/smali/smali.java
Patch:
@@ -144,7 +144,7 @@ public static void main(String[] args) throws Exception
             if (dumpFilename != null) {
                 out.finishAnnotating();
 
-                FileWriter fileWriter = new FileWriter("classes.dump");
+                FileWriter fileWriter = new FileWriter(dumpFilename);
                 out.writeAnnotationsTo(fileWriter);
                 fileWriter.close();
             }

File: baksmali/src/main/java/org/jf/baksmali/Renderers/LongRenderer.java
Patch:
@@ -34,9 +34,9 @@ public class LongRenderer implements AttributeRenderer {
     public String toString(Object o) {
         Long l = (Long)o;
         if (l < 0) {
-            return "-0x" + Long.toHexString(-1 * l);
+            return "-0x" + Long.toHexString(-1 * l) + "L";
         }
-        return "0x" + Long.toHexString((Long)o);
+        return "0x" + Long.toHexString((Long)o) + "L";
     }
 
     public String toString(Object o, String s) {

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/Format/Instruction21tMethodItem.java
Patch:
@@ -36,7 +36,7 @@ public Instruction21tMethodItem(int offset, Instruction21t instruction) {
     }
 
     public int getRegister() {
-        return instruction.getOffset();
+        return instruction.getRegister();
     }
 
     public String getTarget() {

File: dexlib/src/main/java/org/jf/dexlib/debug/DebugInstructionFactory.java
Patch:
@@ -57,7 +57,7 @@ public static DebugInstruction makeDebugInstruction(DexFile dexFile, byte opcode
             case 0x05:
                 return new EndLocal();
             case 0x06:
-                return new RestartLocal();
+                return new RestartLocal(dexFile.isForDumping());
             case 0x07:
                 return new SetPrologueEnd();
             case 0x08:

File: dexlib/src/main/java/org/jf/dexlib/debug/StartLocal.java
Patch:
@@ -40,7 +40,8 @@ public StartLocal(DexFile dexFile) {
         super("DBG_START_LOCAL");
         fields = new Field[] {
                 opcodeField = new ByteField((byte)0x03, "opcode"),
-                registerNumber = new Leb128Field("register_num"),
+                registerNumber = dexFile.isForDumping()?new Leb128Field.PossiblySignedLeb128Field("register_num"):
+                        new Leb128Field("register_num"),
                 localName = new IndexedItemReference<StringIdItem>(dexFile.StringIdsSection,
                         new Leb128p1Field(null), "name_idx"),
                 localType = new IndexedItemReference<TypeIdItem>(dexFile.TypeIdsSection,

File: dexlib/src/main/java/org/jf/dexlib/debug/StartLocalExtended.java
Patch:
@@ -41,7 +41,8 @@ public StartLocalExtended(DexFile dexFile) {
         super("DBG_START_LOCAL_EXTENDED");
         fields = new Field[] {
                 opcodeField = new ByteField((byte)0x04, "opcode"),
-                registerNumber = new Leb128Field("register_num"),
+                registerNumber = dexFile.isForDumping()?new Leb128Field.PossiblySignedLeb128Field("register_num"):
+                        new Leb128Field("register_num"),
                 localName = new IndexedItemReference<StringIdItem>(dexFile.StringIdsSection,
                         new Leb128p1Field(null), "name_idx"),
                 localType = new IndexedItemReference<TypeIdItem>(dexFile.TypeIdsSection,

File: dexlib/src/main/java/org/jf/dexlib/code/Instruction.java
Patch:
@@ -29,6 +29,7 @@
 package org.jf.dexlib.code;
 
 import org.jf.dexlib.*;
+import org.jf.dexlib.util.NumberUtils;
 import org.jf.dexlib.code.Format.Format;
 
 public abstract class Instruction {
@@ -84,7 +85,7 @@ protected Instruction(DexFile dexFile, Opcode opcode, byte[] rest) {
         System.arraycopy(rest, 0, encodedInstruction, 1, rest.length);
 
         if (opcode.referenceType != ReferenceType.none) {
-            int itemIndex = (encodedInstruction[3] << 8) | encodedInstruction[2];
+            int itemIndex = NumberUtils.decodeUnsignedShort(encodedInstruction[2], encodedInstruction[3]);
             getReferencedItem(dexFile, opcode, itemIndex);
         }
     }

File: baksmali/src/main/java/org/jf/baksmali/Adaptors/Format/InstructionFormatMethodItem.java
Patch:
@@ -41,7 +41,7 @@ public InstructionFormatMethodItem(int offset, T instruction) {
     }
 
     public int getSortOrder() {
-        //instructions should appear after everything except an "end try" label
+        //instructions should appear after everything except an "end try" label and .catch directive
         return 100;
     }
 

File: baksmali/src/main/java/org/jf/baksmali/Renderers/IntegerRenderer.java
Patch:
@@ -42,6 +42,8 @@ public String toString(Object o) {
     public String toString(Object o, String s) {
         if (s.equals("decimal")) {
             return Integer.toString((Integer)o);
+        } else if (s.equals("barehex")) {
+            return Integer.toHexString((Integer)o);
         }
         return toString(o);
     }

File: dexlib/src/main/java/org/jf/dexlib/EncodedValue/IntEncodedValueSubField.java
Patch:
@@ -36,6 +36,7 @@ public class IntEncodedValueSubField
         extends SimpleEncodedValueSubField<Integer, IntEncodedValueSubField>
 {
     public IntEncodedValueSubField() {
+        return;
     }
 
     public IntEncodedValueSubField(int value) {

File: dexlib/src/main/java/org/jf/dexlib/code/InstructionField.java
Patch:
@@ -88,7 +88,7 @@ public void readFrom(Input in) {
             switch (secondByte) {
                 case 0x00:
                     //nop
-                    instruction = Opcode.NOP.format.Factory.makeInstruction(dexFile, Opcode.NOP, new byte[]{0x00, 0x00});
+                    instruction = Opcode.NOP.format.Factory.makeInstruction(dexFile, Opcode.NOP, new byte[]{0x00});
                     return;
                 case 0x01:
                     //packed switch

File: src/main/java/org/JesusFreke/dexlib/code/Opcode.java
Patch:
@@ -233,7 +233,7 @@ public enum Opcode
     DIV_DOUBLE_2ADDR((byte)0xce, "DIV-DOUBLE/2ADDR", (byte)2, ReferenceType.none, "12x"),
     REM_DOUBLE_2ADDR((byte)0xcf, "REM-DOUBLE/2ADDR", (byte)2, ReferenceType.none, "12x"),
     ADD_INT_LIT16((byte)0xd0, "ADD-INT/LIT16", (byte)4, ReferenceType.none, "22s"),
-    RSUB_INT_LIT16((byte)0xd1, "RSUB-INT/LIT16", (byte)4, ReferenceType.none, "22s"),
+    RSUB_INT((byte)0xd1, "RSUB-INT", (byte)4, ReferenceType.none, "22s"),
     MUL_INT_LIT16((byte)0xd2, "MUL-INT/LIT16", (byte)4, ReferenceType.none, "22s"),
     DIV_INT_LIT16((byte)0xd3, "DIV-INT/LIT16", (byte)4, ReferenceType.none, "22s"),
     REM_INT_LIT16((byte)0xd4, "REM-INT/LIT16", (byte)4, ReferenceType.none, "22s"),

File: src/main/java/org/JesusFreke/dexlib/code/Opcode.java
Patch:
@@ -70,7 +70,7 @@ public enum Opcode
     NEW_INSTANCE((byte)0x22, "NEW-INSTANCE", (byte)4, ReferenceType.type, "21c"),
     NEW_ARRAY((byte)0x23, "NEW-ARRAY", (byte)4, ReferenceType.type, "22c"),
     FILLED_NEW_ARRAY((byte)0x24, "FILLED-NEW-ARRAY", (byte)6, ReferenceType.type, "35c"),
-    FILLED_NEW_ARRAY_RANGE((byte)0x25, "FILLED-NEW-ARRAY-RANGE", (byte)6, ReferenceType.type, "3rc"),
+    FILLED_NEW_ARRAY_RANGE((byte)0x25, "FILLED-NEW-ARRAY/RANGE", (byte)6, ReferenceType.type, "3rc"),
     FILL_ARRAY_DATA((byte)0x26, "FILL-ARRAY-DATA", (byte)6, ReferenceType.none, "31t"),
     THROW((byte)0x27, "THROW", (byte)2, ReferenceType.none, "11x"),
     GOTO((byte)0x28, "GOTO", (byte)2, ReferenceType.none, "10t"),

File: src/main/java/org/JesusFreke/dexlib/code/Format/Format3rc.java
Patch:
@@ -82,7 +82,7 @@ public Instruction make(DexFile dexFile, byte opcode, short regCount, int startR
         } else if (opcode >= INVOKE_VIRTUAL_RANGE.value && opcode <= INVOKE_INTERFACE_RANGE.value) {
             //check data for invoke-*/range opcodes
             MethodIdItem methodIdItem = (MethodIdItem)item;
-            if (methodIdItem.getParameterRegisterCount(opcode == INVOKE_STATIC.value) != regCount) {
+            if (methodIdItem.getParameterRegisterCount(opcode == INVOKE_STATIC_RANGE.value) != regCount) {
                 throw new RuntimeException("regCount does not match the number of arguments of the method");
             }
         } else {

File: src/main/java/org/JesusFreke/smali/smali.java
Patch:
@@ -168,6 +168,8 @@ private static void getSmaliFilesInDir(File dir, Set<File> smaliFiles) {
     private static void assembleSmaliFile(File smaliFile, DexFile dexFile)
             throws Exception {
         ANTLRInputStream input = new ANTLRInputStream(new FileInputStream(smaliFile));
+        input.name = smaliFile.getAbsolutePath();
+
         smaliLexer lexer = new smaliLexer(input);
 
         CommonTokenStream tokens = new CommonTokenStream(lexer);

File: src/main/java/org/JesusFreke/dexlib/CodeItem.java
Patch:
@@ -491,9 +491,8 @@ private ArrayList<Instruction> getInstructionList() {
         //return the word size of the instruction list
         public int getInstructionWordCount() {
             int bytes = 0;
-            //TODO: what about option padding before the special opcodes?
             for (Instruction instruction: instructionList) {
-                bytes += instruction.getBytes().length;
+                bytes += instruction.getSize(bytes);
             }
             return bytes/2;
         }

File: src/main/java/org/JesusFreke/dexlib/FieldIdItem.java
Patch:
@@ -41,7 +41,7 @@ public FieldIdItem(DexFile dexFile, int index) {
                 fieldTypeReferenceField = new IndexedItemReference<TypeIdItem>(dexFile.TypeIdsSection,
                         new ShortIntegerField(null), "type_idx"),
                 fieldNameReferenceField = new IndexedItemReference<StringIdItem>(dexFile.StringIdsSection,
-                        new IntegerField(null), "parameters_off")
+                        new IntegerField(null), "name_idx")
         };
     }
 

File: src/main/java/org/JesusFreke/dexlib/EncodedValue/CharEncodedValueSubField.java
Patch:
@@ -58,7 +58,7 @@ public int place(int offset) {
     }
 
     public byte getValueArg() {
-        return EncodedValueUtils.getRequiredBytesForUnsignedIntegralValue(value);
+        return (byte)(EncodedValueUtils.getRequiredBytesForUnsignedIntegralValue(value) - 1);
     }
 
     public ValueType getValueType() {

File: src/main/java/org/JesusFreke/dexlib/EncodedValue/EncodedIndexedItemReference.java
Patch:
@@ -107,7 +107,7 @@ public void setInitialValueArg(byte valueArg)
     }
 
     public byte getValueArg() {
-        return EncodedValueUtils.getRequiredBytesForUnsignedIntegralValue(item.getIndex());
+        return (byte)(EncodedValueUtils.getRequiredBytesForUnsignedIntegralValue(item.getIndex()) - 1);
     }
 
     public ValueType getValueType() {

File: src/main/java/org/JesusFreke/dexlib/EncodedValue/FloatEncodedValueSubField.java
Patch:
@@ -59,10 +59,10 @@ public int place(int offset) {
 
     public byte getValueArg() {
         return (byte)(EncodedValueUtils.getRequiredBytesForRightZeroExtendedValue(
-                Float.floatToIntBits(value)) - 1);
+                ((long)Float.floatToRawIntBits(value)) << 32) - 1);
     }
 
     public ValueType getValueType() {
-        return ValueType.VALUE_LONG;
+        return ValueType.VALUE_FLOAT;
     }
 }

File: src/test/java/TryListBuilderTest.java
Patch:
@@ -70,7 +70,7 @@ public static void checkTry(CodeItem.TryItem tryItem,
             CodeItem.EncodedTypeAddrPair typeAddrPair = encodedCatchHandler.getHandler(i);
             Handler handler = handlers[i];
 
-            Assert.assertTrue(typeAddrPair.getTypeReferenceField().toString().compareTo(handler.type) == 0);
+            Assert.assertTrue(typeAddrPair.getTypeReferenceField().getTypeDescriptor().compareTo(handler.type) == 0);
             Assert.assertTrue(typeAddrPair.getHandlerAddress() == handler.handlerAddress);
         }
     }

File: src/main/java/org/JesusFreke/dexlib/DexFile.java
Patch:
@@ -82,6 +82,7 @@ private DexFile() {
         };
 
         offsettedSections = new OffsettedSection[] {
+                AnnotationSetRefListsSection,
                 AnnotationSetsSection,
                 CodeItemsSection,
                 AnnotationDirectoriesSection,
@@ -90,9 +91,7 @@ private DexFile() {
                 DebugInfoItemsSection,
                 AnnotationsSection,
                 EncodedArraysSection,
-                ClassDataSection,
-
-                AnnotationSetRefListsSection
+                ClassDataSection
         };
     }
 

File: src/main/java/org/JesusFreke/dexlib/MapItem.java
Patch:
@@ -84,6 +84,7 @@ public static MapItem makeBlankMapItem(DexFile dexFile) {
         mapItem.mapEntries.add(new MapField(dexFile, (short)0x0004));
         mapItem.mapEntries.add(new MapField(dexFile, (short)0x0005));
         mapItem.mapEntries.add(new MapField(dexFile, (short)0x0006));
+        mapItem.mapEntries.add(new MapField(dexFile, (short)0x1002));
         mapItem.mapEntries.add(new MapField(dexFile, (short)0x1003));
         mapItem.mapEntries.add(new MapField(dexFile, (short)0x2001));
         mapItem.mapEntries.add(new MapField(dexFile, (short)0x2006));

File: src/main/java/org/JesusFreke/dexlib/AnnotationDirectoryItem.java
Patch:
@@ -89,11 +89,11 @@ public AnnotationDirectoryItem(final DexFile dexFile,
 
         classAnnotationsReferenceField.setReference(classAnnotations);
 
-        if (fieldAnnotationListField != null) {
+        if (fieldAnnotations != null) {
             fieldAnnotationList.addAll(fieldAnnotations);
         }
 
-        if (methodAnnotationListField != null) {
+        if (methodAnnotations != null) {
             methodAnnotationList.addAll(methodAnnotations);
         }
 

File: src/main/java/org/JesusFreke/dexlib/ItemReference.java
Patch:
@@ -47,7 +47,7 @@ public T getReference() {
         return item;
     }
 
-    protected void setReference(T item) {
+    public void setReference(T item) {
         this.item = item;
     }
 

File: src/main/java/org/JesusFreke/dexlib/EncodedValue/EncodedIndexedItemReference.java
Patch:
@@ -69,7 +69,7 @@ public void writeTo(Output out) {
 
     public void readFrom(Input in) {
         setReference(((IndexedSection<T>)getSection()).getByIndex(
-                (int)EncodedValueUtils.decodeUnsignedIntegralValue(in.readBytes(initialValueArg))));
+                (int)EncodedValueUtils.decodeUnsignedIntegralValue(in.readBytes(initialValueArg + 1))));
     }
 
     public int place(int offset) {

File: src/main/java/org/JesusFreke/dexlib/EncodedValue/EncodedValue.java
Patch:
@@ -108,6 +108,7 @@ public void writeTo(Output out) {
 
         public void readFrom(Input in) {
             subField = EncodedValueSubFieldFactory.makeEncodedValueField(dexFile, getValueType());
+            subField.setInitialValueArg(getValueArg());
             subField.readFrom(in);
         }
 

File: src/main/java/org/JesusFreke/dexlib/ClassDefItem.java
Patch:
@@ -69,7 +69,7 @@ public ClassDefItem(DexFile dexFile, int index) {
         };
     }
 
-    public ClassDefItem(DexFile dexFile, TypeIdItem classType, int accessFlags, TypeIdItem superType, ClassDataItem classDataItem) {
+    public ClassDefItem(DexFile dexFile, TypeIdItem classType, int accessFlags, TypeIdItem superType, TypeListItem implementsList, StringIdItem source, ClassDataItem classDataItem) {
         super(-1);
 
         this.dexFile = dexFile;
@@ -78,8 +78,8 @@ public ClassDefItem(DexFile dexFile, TypeIdItem classType, int accessFlags, Type
                 this.classType = new IndexedItemReference<TypeIdItem>(dexFile, classType, new IntegerField()),
                 this.accessFlags = new IntegerField(accessFlags),
                 superclassType = new IndexedItemReference<TypeIdItem>(dexFile, superType, new IntegerField()),
-                classInterfacesList = new OffsettedItemReference<TypeListItem>(dexFile.TypeListsSection, new IntegerField()),
-                sourceFile = new IndexedItemReference<StringIdItem>(dexFile.StringIdsSection, new IntegerField()),
+                classInterfacesList = new OffsettedItemReference<TypeListItem>(dexFile, implementsList, new IntegerField()),
+                sourceFile = new IndexedItemReference<StringIdItem>(dexFile, source, new IntegerField()),
                 classAnnotations = new OffsettedItemReference<AnnotationDirectoryItem>(dexFile.AnnotationDirectoriesSection, new IntegerField()),
                 classData = new OffsettedItemReference<ClassDataItem>(dexFile, classDataItem, new IntegerField()),
                 staticFieldInitialValues = new OffsettedItemReference<EncodedArrayItem>(dexFile.EncodedArraysSection, new IntegerField())

File: src/main/java/org/JesusFreke/dexlib/FieldListField.java
Patch:
@@ -34,7 +34,7 @@
 import java.util.ArrayList;
 
 public abstract class FieldListField<T extends Field> implements Field<FieldListField<T>> {
-    private final ArrayList<T> list;
+    final ArrayList<T> list;
 
     public FieldListField(ArrayList<T> list) {
         this.list = list;

File: src/main/java/org/JesusFreke/dexlib/code/Format/Format11x.java
Patch:
@@ -44,7 +44,7 @@ public Instruction make(DexFile dexFile, byte opcode, short regA) {
 
         checkOpcodeFormat(op);
 
-        if (regA >= 2<<8) {
+        if (regA >= 1<<8) {
             throw new RuntimeException("The register number must be less than v256");
         }
 

File: src/main/java/org/JesusFreke/dexlib/code/Format/Format21c.java
Patch:
@@ -49,7 +49,7 @@ public Instruction make(DexFile dexFile, byte opcode, short regA, IndexedItem it
 
         checkOpcodeFormat(op);
 
-        if (regA >= 2<<8) {
+        if (regA >= 1<<8) {
             throw new RuntimeException("The register number must be less than v256");
         }
 

File: src/main/java/org/JesusFreke/dexlib/code/Format/Format22c.java
Patch:
@@ -47,8 +47,8 @@ public Instruction make(DexFile dexFile, byte opcode, byte regA, byte regB, Inde
 
         checkOpcodeFormat(op);
 
-        if (regA >= 16 ||
-            regB >= 16) {
+        if (regA >= 1<<4 ||
+            regB >= 1<<4) {
             throw new RuntimeException("The register number must be less than v16");
         }
 

File: src/main/java/org/JesusFreke/dexlib/code/Format/Format3rc.java
Patch:
@@ -47,14 +47,14 @@ public Instruction make(DexFile dexFile, byte opcode, short regCount, int startR
 
         checkOpcodeFormat(op);
 
-        if (regCount >= 2<<8) {
+        if (regCount >= 1<<8) {
             throw new RuntimeException("regCount must be less than 256");
         }
         if (regCount < 0) {
             throw new RuntimeException("regCount cannot be negative");
         }
 
-        if (startReg >= 2<<16) {
+        if (startReg >= 1<<16) {
             throw new RuntimeException("The beginning register of the range must be less than 65536");
         }
         if (startReg < 0) {

