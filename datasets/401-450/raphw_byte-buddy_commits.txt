File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/AsmClassWriter.java
Patch:
@@ -200,7 +200,9 @@ public AsmClassWriter make(int flags, AsmClassReader classReader, TypePool typeP
                 FACTORY = processor == null ? Default.ASM_FIRST : Default.valueOf(processor);
                 Class<?> type;
                 try {
-                    type = Class.forName("codes.rafael.asmjdkbridge.JdkClassReader");
+                    type = ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V24)
+                        ? Class.forName("codes.rafael.asmjdkbridge.JdkClassReader")
+                        : null;
                 } catch (ClassNotFoundException ignored) {
                     type = null;
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodReturn.java
Patch:
@@ -114,6 +114,6 @@ public boolean isValid() {
      */
     public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
         methodVisitor.visitInsn(returnOpcode);
-        return stackSize.toIncreasingSize();
+        return stackSize.toDecreasingSize();
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -335,8 +335,8 @@ public ByteBuddy(ClassFileVersion classFileVersion) {
                 InstrumentedType.Factory.Default.MODIFIABLE,
                 DEFAULT_TYPE_VALIDATION,
                 VisibilityBridgeStrategy.Default.ALWAYS,
-                AsmClassReader.Factory.Default.INSTANCE,
-                AsmClassWriter.Factory.Default.INSTANCE,
+                AsmClassReader.Factory.Default.IMPLICIT,
+                AsmClassWriter.Factory.Default.IMPLICIT,
                 new LatentMatcher.Resolved<MethodDescription>(isSynthetic().or(isDefaultFinalizer())));
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -342,7 +342,7 @@ public static Advice to(TypeDescription advice, ClassFileLocator classFileLocato
                 classFileLocator,
                 Collections.<OffsetMapping.Factory<?>>emptyList(),
                 Delegator.ForRegularInvocation.Factory.INSTANCE,
-                AsmClassReader.Factory.Default.INSTANCE);
+                AsmClassReader.Factory.Default.IMPLICIT);
     }
 
     /**
@@ -436,7 +436,7 @@ public static Advice to(TypeDescription enterAdvice, TypeDescription exitAdvice,
                 classFileLocator,
                 Collections.<OffsetMapping.Factory<?>>emptyList(),
                 Delegator.ForRegularInvocation.Factory.INSTANCE,
-                AsmClassReader.Factory.Default.INSTANCE);
+                AsmClassReader.Factory.Default.IMPLICIT);
     }
 
     /**
@@ -14876,7 +14876,7 @@ protected WithCustomMapping() {
             this(PostProcessor.NoOp.INSTANCE,
                     Collections.<Class<? extends Annotation>, OffsetMapping.Factory<?>>emptyMap(),
                     Delegator.ForRegularInvocation.Factory.INSTANCE,
-                    AsmClassReader.Factory.Default.INSTANCE);
+                    AsmClassReader.Factory.Default.IMPLICIT);
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/ClassWriterStrategy.java
Patch:
@@ -123,15 +123,15 @@ public AsmClassWriter make(int flags, AsmClassReader classReader) {
          * {@inheritDoc}
          */
         public AsmClassWriter make(int flags, TypePool typePool) {
-            return new AsmClassWriter.Default(classWriterStrategy.resolve(flags, typePool));
+            return new AsmClassWriter.ForAsm(classWriterStrategy.resolve(flags, typePool));
         }
 
         /**
          * {@inheritDoc}
          */
         public AsmClassWriter make(int flags, AsmClassReader classReader, TypePool typePool) {
             ClassReader unwrapped = classReader.unwrap(ClassReader.class);
-            return new AsmClassWriter.Default(unwrapped == null
+            return new AsmClassWriter.ForAsm(unwrapped == null
                     ? classWriterStrategy.resolve(flags, typePool)
                     : classWriterStrategy.resolve(flags, typePool, unwrapped));
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -6126,12 +6126,14 @@ protected void onVisitInnerClass(String internalName, @MaybeNull String outerNam
                 }
 
                 @Override
+                @MaybeNull
                 protected FieldVisitor onVisitField(int modifiers, String name, String descriptor, @MaybeNull String signature, @MaybeNull Object value) {
                     visitedFields.add(new SignatureKey(name, descriptor));
                     return super.onVisitField(modifiers, name, descriptor, signature, value);
                 }
 
                 @Override
+                @MaybeNull
                 protected MethodVisitor onVisitMethod(int modifiers, String internalName, String descriptor, @MaybeNull String signature, @MaybeNull String[] exception) {
                     visitedMethods.add(new SignatureKey(internalName, descriptor));
                     return super.onVisitMethod(modifiers, internalName, descriptor, signature, exception);

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -806,7 +806,7 @@ public Default(CacheProvider cacheProvider, ClassFileLocator classFileLocator, R
          * @param parentPool       The parent type pool.
          */
         public Default(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode, TypePool parentPool) {
-            this(cacheProvider, classFileLocator, readerMode, AsmClassReader.Factory.Default.INSTANCE, parentPool);
+            this(cacheProvider, classFileLocator, readerMode, AsmClassReader.Factory.Default.IMPLICIT, parentPool);
         }
 
         /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionGenericTest.java
Patch:
@@ -1995,8 +1995,8 @@ public abstract static class InconsistentGenerics<T extends Exception> implement
     public static class GenericDisintegrator extends ClassVisitor {
 
         public static Field make() throws IOException, ClassNotFoundException, NoSuchFieldException {
-            AsmClassReader classReader = AsmClassReader.Factory.Default.INSTANCE.make(ClassFileLocator.ForClassLoader.read(InconsistentGenerics.class));
-            AsmClassWriter classWriter = AsmClassWriter.Factory.Default.INSTANCE.make(ClassWriter.COMPUTE_MAXS, classReader);
+            AsmClassReader classReader = AsmClassReader.Factory.Default.IMPLICIT.make(ClassFileLocator.ForClassLoader.read(InconsistentGenerics.class));
+            AsmClassWriter classWriter = AsmClassWriter.Factory.Default.IMPLICIT.make(ClassWriter.COMPUTE_MAXS, classReader);
             classReader.accept(new GenericDisintegrator(classWriter.getVisitor()), AsmVisitorWrapper.NO_FLAGS);
             return new ByteArrayClassLoader(ClassLoadingStrategy.BOOTSTRAP_LOADER,
                     Collections.singletonMap(InconsistentGenerics.class.getName(), classWriter.getBinaryRepresentation()),

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -1521,7 +1521,7 @@ public void testWrapClassVisitor() throws Exception {
         TypeDescription typeDescription = createPlain()
                 .make()
                 .getTypeDescription();
-        AsmClassWriter classWriter = AsmClassWriter.Factory.Default.INSTANCE.make(AsmVisitorWrapper.NO_FLAGS);
+        AsmClassWriter classWriter = AsmClassWriter.Factory.Default.IMPLICIT.make(AsmVisitorWrapper.NO_FLAGS);
         ContextClassVisitor classVisitor = createPlain()
                 .defineMethod(FOO, Object.class, Visibility.PUBLIC, Ownership.STATIC)
                 .throwing(Exception.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassInjectorUsingReflectionTest.java
Patch:
@@ -240,7 +240,7 @@ public void testMultipleClassLoaderUsingDispatch() throws Exception {
         ClassLoader classLoader = new ClassLoader(ClassLoadingStrategy.BOOTSTRAP_LOADER) {
             @Override
             protected Class<?> findClass(String name) throws ClassNotFoundException {
-                if (name.startsWith("net.bytebuddy.") || name.startsWith("org.objectweb.")) {
+                if (name.startsWith("net.bytebuddy.") || name.startsWith("org.objectweb.") || name.startsWith("codes.rafael.asmjdkbridge.")) {
                     InputStream inputStream = ClassInjectorUsingReflectionTest.class.getResourceAsStream("/"
                         + name.replace('.', '/')
                         + ClassFileLocator.CLASS_FILE_EXTENSION);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDeclarationPreservationTest.java
Patch:
@@ -61,7 +61,7 @@ public TypeWriterDeclarationPreservationTest(Class<?> type) {
     @Test
     public void testRedefinition() throws Exception {
         TypeModifierExtractor typeModifierExtractor = new TypeModifierExtractor();
-        AsmClassReader.Factory.Default.INSTANCE.make(ClassFileLocator.ForClassLoader.read(type)).accept(typeModifierExtractor, AsmVisitorWrapper.NO_FLAGS);
+        AsmClassReader.Factory.Default.IMPLICIT.make(ClassFileLocator.ForClassLoader.read(type)).accept(typeModifierExtractor, AsmVisitorWrapper.NO_FLAGS);
         new ByteBuddy()
                 .redefine(type)
                 .visit(new TypeValidator.Wrapper(typeModifierExtractor))
@@ -71,7 +71,7 @@ public void testRedefinition() throws Exception {
     @Test
     public void testRebasing() throws Exception {
         TypeModifierExtractor typeModifierExtractor = new TypeModifierExtractor();
-        AsmClassReader.Factory.Default.INSTANCE.make(ClassFileLocator.ForClassLoader.read(type)).accept(typeModifierExtractor, AsmVisitorWrapper.NO_FLAGS);
+        AsmClassReader.Factory.Default.IMPLICIT.make(ClassFileLocator.ForClassLoader.read(type)).accept(typeModifierExtractor, AsmVisitorWrapper.NO_FLAGS);
         new ByteBuddy()
                 .rebase(type)
                 .visit(new TypeValidator.Wrapper(typeModifierExtractor))
@@ -81,7 +81,7 @@ public void testRebasing() throws Exception {
     @Test
     public void testDecoration() throws Exception {
         TypeModifierExtractor typeModifierExtractor = new TypeModifierExtractor();
-        AsmClassReader.Factory.Default.INSTANCE.make(ClassFileLocator.ForClassLoader.read(type)).accept(typeModifierExtractor, AsmVisitorWrapper.NO_FLAGS);
+        AsmClassReader.Factory.Default.IMPLICIT.make(ClassFileLocator.ForClassLoader.read(type)).accept(typeModifierExtractor, AsmVisitorWrapper.NO_FLAGS);
         new ByteBuddy()
                 .decorate(type)
                 .visit(new TypeValidator.Wrapper(typeModifierExtractor))

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultTest.java
Patch:
@@ -678,7 +678,7 @@ public void testPropertyDefinitionEmptyName() throws Exception {
 
     @Test
     public void testOldJavaClassFileDeprecation() {
-        AsmClassWriter classWriter = AsmClassWriter.Factory.Default.INSTANCE.make(AsmVisitorWrapper.NO_FLAGS);
+        AsmClassWriter classWriter = AsmClassWriter.Factory.Default.IMPLICIT.make(AsmVisitorWrapper.NO_FLAGS);
         classWriter.getVisitor().visit(Opcodes.V1_4, Opcodes.ACC_DEPRECATED | Opcodes.ACC_ABSTRACT, "foo/Bar", null, "java/lang/Object", null);
         classWriter.getVisitor().visitField(Opcodes.ACC_DEPRECATED, "qux", "Ljava/lang/Object;", null, null).visitEnd();
         classWriter.getVisitor().visitMethod(Opcodes.ACC_DEPRECATED | Opcodes.ACC_ABSTRACT, "baz", "()V", null, null).visitEnd();
@@ -700,7 +700,7 @@ public void testOldJavaClassFileDeprecation() {
                 .make()
                 .getBytes();
 
-        AsmClassReader classReader = AsmClassReader.Factory.Default.INSTANCE.make(binaryRepresentation);
+        AsmClassReader classReader = AsmClassReader.Factory.Default.IMPLICIT.make(binaryRepresentation);
         classReader.accept(new ClassVisitor(OpenedClassReader.ASM_API) {
             @Override
             public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/AnnotationAppenderDefaultTest.java
Patch:
@@ -157,7 +157,7 @@ public void testMultipleTypeArgumentAnnotation() throws Exception {
 
     private Class<?> makeTypeWithAnnotation(Annotation annotation) throws Exception {
         when(valueFilter.isRelevant(any(AnnotationDescription.class), any(MethodDescription.InDefinedShape.class))).thenReturn(true);
-        AsmClassWriter classWriter = AsmClassWriter.Factory.Default.INSTANCE.make(AsmVisitorWrapper.NO_FLAGS);
+        AsmClassWriter classWriter = AsmClassWriter.Factory.Default.IMPLICIT.make(AsmVisitorWrapper.NO_FLAGS);
         classWriter.getVisitor().visit(ClassFileVersion.ofThisVm().getMinorMajorVersion(),
                 Opcodes.ACC_PUBLIC,
                 BAR.replace('.', '/'),
@@ -177,7 +177,7 @@ private Class<?> makeTypeWithAnnotation(Annotation annotation) throws Exception
 
     private Class<?> makeTypeWithSuperClassAnnotation(Annotation annotation) throws Exception {
         when(valueFilter.isRelevant(any(AnnotationDescription.class), any(MethodDescription.InDefinedShape.class))).thenReturn(true);
-        AsmClassWriter classWriter = AsmClassWriter.Factory.Default.INSTANCE.make(AsmVisitorWrapper.NO_FLAGS);
+        AsmClassWriter classWriter = AsmClassWriter.Factory.Default.IMPLICIT.make(AsmVisitorWrapper.NO_FLAGS);
         classWriter.getVisitor().visit(ClassFileVersion.ofThisVm().getMinorMajorVersion(),
                 Opcodes.ACC_PUBLIC,
                 BAR.replace('.', '/'),

File: byte-buddy-android/src/main/java/net/bytebuddy/android/AndroidClassLoadingStrategy.java
Patch:
@@ -33,7 +33,6 @@
 import net.bytebuddy.utility.nullability.AlwaysNull;
 import net.bytebuddy.utility.nullability.MaybeNull;
 
-import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -6280,6 +6280,7 @@ public File toJar(File file) throws IOException {
         /**
          * {@inheritDoc}
          */
+        @SuppressFBWarnings(value = "OS_OPEN_STREAM_EXCEPTION_PATH", justification = "Outer stream holds file handle and is closed")
         public File toJar(File file, Manifest manifest) throws IOException {
             if (!file.isFile() && !file.createNewFile()) {
                 throw new IllegalArgumentException("Could not create file: " + file);

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -618,6 +618,7 @@ private static void install(AttachmentProvider attachmentProvider, String proces
      * @param argument           The argument to provide to the agent or {@code null} if no argument should be supplied.
      * @throws Exception If an exception occurs during the attachment or the external process fails the attachment.
      */
+    @SuppressFBWarnings(value = "OS_OPEN_STREAM_EXCEPTION_PATH", justification = "Outer stream holds file handle and is closed")
     private static void installExternal(AttachmentProvider.Accessor.ExternalAttachment externalAttachment,
                                         String processId,
                                         File agent,
@@ -1493,6 +1494,7 @@ private static File trySelfResolve(Class<?> installer) throws IOException {
              * @return The agent jar file.
              * @throws IOException If an I/O exception occurs.
              */
+            @SuppressFBWarnings(value = "OS_OPEN_STREAM_EXCEPTION_PATH", justification = "Outer stream holds file handle and is closed")
             private static File createJarFile() throws IOException {
                 InputStream inputStream = Installer.class.getResourceAsStream('/' + Installer.class.getName().replace('.', '/') + CLASS_FILE_EXTENSION);
                 if (inputStream == null) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -6215,6 +6215,7 @@ public File inject(File jar) throws IOException {
          * @return The jar file that was written to.
          * @throws IOException If an I/O error occurs.
          */
+        @SuppressFBWarnings(value = "OS_OPEN_STREAM_EXCEPTION_PATH", justification = "Outer stream holds file handle and is closed")
         private File doInject(File sourceJar, File targetJar) throws IOException {
             InputStream inputStream = new FileInputStream(sourceJar);
             try {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -2512,6 +2512,7 @@ public boolean isAlive() {
         /**
          * {@inheritDoc}
          */
+        @SuppressFBWarnings(value = "OS_OPEN_STREAM_EXCEPTION_PATH", justification = "Outer stream holds file handle and is closed")
         public Map<String, Class<?>> injectRaw(Set<String> names, ClassFileLocator classFileLocator) {
             File file = new File(folder, JAR + randomString.nextString() + "." + JAR);
             try {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -2526,6 +2526,7 @@ public Map<String, Class<?>> injectRaw(Set<String> names, ClassFileLocator class
                             jarOutputStream.putNextEntry(new JarEntry(name.replace('.', '/') + CLASS_FILE_EXTENSION));
                             jarOutputStream.write(classFileLocator.locate(name).resolve());
                         }
+                        jarOutputStream.close();
                     } finally {
                         outputStream.close();
                     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginEngineTargetForJarFileTest.java
Patch:
@@ -80,7 +80,7 @@ public void testWriteResource() throws Exception {
             assertThat(jarInputStream.getManifest(), nullValue(Manifest.class));
             JarEntry entry = jarInputStream.getNextJarEntry();
             assertThat(entry.getName(), is(FOO + "/" + BAR));
-            assertThat(StreamDrainer.DEFAULT.drain(inputStream), is(new byte[]{1, 2, 3}));
+            assertThat(StreamDrainer.DEFAULT.drain(jarInputStream), is(new byte[]{1, 2, 3}));
             assertThat(jarInputStream.getNextJarEntry(), nullValue(JarEntry.class));
             jarInputStream.close();
         } finally {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -6256,9 +6256,11 @@ private File doInject(File sourceJar, File targetJar) throws IOException {
                         jarOutputStream.write(entry.getValue());
                         jarOutputStream.closeEntry();
                     }
+                    jarOutputStream.close();
                 } finally {
                     outputStream.close();
                 }
+                jarInputStream.close();
             } finally {
                 inputStream.close();
             }
@@ -6292,6 +6294,7 @@ public File toJar(File file, Manifest manifest) throws IOException {
                 jarOutputStream.putNextEntry(new JarEntry(getTypeDescription().getInternalName() + CLASS_FILE_EXTENSION));
                 jarOutputStream.write(getBytes());
                 jarOutputStream.closeEntry();
+                jarOutputStream.close();
             } finally {
                 outputStream.close();
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -1308,7 +1308,7 @@ public ByteBuddy with(Implementation.Context.Factory implementationContextFactor
      * Creates a new configuration where the {@link MethodGraph.Compiler} is used for creating a {@link MethodGraph}
      * of the instrumented type. A method graph is a representation of a type's virtual methods, including all information
      * on bridge methods that are inserted by the Java compiler. Creating a method graph is a rather expensive operation
-     * and more efficient strategies might exist for certain types or ava types that are created by alternative JVM
+     * and more efficient strategies might exist for certain types or Java types that are created by alternative JVM
      * languages. By default, a general purpose method graph compiler is used that uses the information that is exposed
      * by the generic type information that is embedded in any class file.
      *

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/Plugin.java
Patch:
@@ -3398,7 +3398,7 @@ protected enum NoFolderMatcher implements ElementMatcher<Element> {
                      * {@inheritDoc}
                      */
                     public boolean matches(@MaybeNull Element target) {
-                        return target == null || target.getName().endsWith("/");
+                        return target == null || !target.getName().endsWith("/");
                     }
                 }
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -2507,7 +2507,7 @@ public FieldVisitor visitField(int modifiers, String name, String descriptor, @M
                             type = String.class;
                     }
                     if (!type.isInstance(value)) {
-                        throw new IllegalStateException("Field " + name + " defines an incompatible default value " + value);
+                        throw new IllegalStateException("Field " + name + " defines an incompatible default value " + value + " (" + value.getClass().getName() + ")");
                     } else if (type == Integer.class) {
                         int minimum, maximum;
                         switch (descriptor.charAt(0)) {
@@ -2532,7 +2532,7 @@ public FieldVisitor visitField(int modifiers, String name, String descriptor, @M
                                 maximum = Integer.MAX_VALUE;
                         }
                         if ((Integer) value < minimum || (Integer) value > maximum) {
-                            throw new IllegalStateException("Field " + name + " defines an incompatible default value " + value);
+                            throw new IllegalStateException("Field " + name + " defines an incompatible default value " + value + " (" + minimum + "-" + maximum + ")");
                         }
                     }
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/AsmClassWriter.java
Patch:
@@ -118,8 +118,8 @@ public AsmClassWriter make(int flags, AsmClassReader classReader, TypePool typeP
                  */
                 public AsmClassWriter make(int flags, AsmClassReader classReader, TypePool typePool) {
                     return ClassFileVersion.ofThisVm().isGreaterThan(ClassFileVersion.latest())
-                            ? ASM_ONLY.make(flags, classReader, typePool)
-                            : CLASS_FILE_API_ONLY.make(flags, classReader, typePool);
+                            ? CLASS_FILE_API_ONLY.make(flags, classReader, typePool)
+                            : ASM_ONLY.make(flags, classReader, typePool);
                 }
             },
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/AsmClassWriter.java
Patch:
@@ -302,7 +302,7 @@ public SuperClassResolvingJdkClassWriter(int flags, TypePool typePool) {
         }
 
         public SuperClassResolvingJdkClassWriter(int flags, JdkClassReader classReader, TypePool typePool) {
-            super(flags, classReader);
+            super(classReader, flags);
             this.typePool = typePool;
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/DynamicTypeDefaultTest.java
Patch:
@@ -144,7 +144,7 @@ public void testTypeInitializersAliveMain() throws Exception {
 
     @Test
     public void testTypeInitializersAliveAuxiliary() throws Exception {
-        when(auxiliaryLoadedTypeInitializer.isAlive()).thenReturn(true);
+        when(auxiliaryType.hasAliveLoadedTypeInitializers()).thenReturn(true);
         assertThat(dynamicType.hasAliveLoadedTypeInitializers(), is(true));
     }
 
@@ -337,6 +337,7 @@ public void testIterationOrderAuxiliary() throws Exception {
 
     @Test
     public void testIterationOrderAllDescriptions() throws Exception {
+        when(auxiliaryType.getAllTypeDescriptions()).thenReturn(Collections.singleton(auxiliaryTypeDescription));
         Iterator<TypeDescription> types = dynamicType.getAllTypeDescriptions().iterator();
         assertThat(types.hasNext(), is(true));
         assertThat(types.next(), is(typeDescription));
@@ -347,6 +348,7 @@ public void testIterationOrderAllDescriptions() throws Exception {
 
     @Test
     public void testIterationOrderAuxiliaryDescriptions() throws Exception {
+        when(auxiliaryType.getAllTypeDescriptions()).thenReturn(Collections.singleton(auxiliaryTypeDescription));
         Iterator<TypeDescription> types = dynamicType.getAuxiliaryTypeDescriptions().iterator();
         assertThat(types.hasNext(), is(true));
         assertThat(types.next(), is(auxiliaryTypeDescription));

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/Plugin.java
Patch:
@@ -4886,7 +4886,7 @@ public Summary apply(Source source, Target target, List<? extends Plugin.Factory
                                         name = name.substring(1);
                                     }
                                     if (name.endsWith(ClassFileLocator.CLASS_FILE_EXTENSION)
-                                            && (!name.startsWith("META-INF") && name.startsWith(ClassFileLocator.META_INF_VERSIONS))
+                                            && (!name.startsWith("META-INF") || name.startsWith(ClassFileLocator.META_INF_VERSIONS))
                                             && !name.endsWith(PACKAGE_INFO)
                                             && !name.endsWith(MODULE_INFO)) {
                                         try {

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginEngineDefaultTest.java
Patch:
@@ -223,7 +223,7 @@ public void testSimpleTransformationMultiRelease() throws Exception {
         Plugin plugin = eager
                 ? new SimplePlugin()
                 : new PreprocessingPlugin(new SimplePlugin());
-        Plugin.Engine.Source source = Plugin.Engine.Source.InMemory.ofTypes(Collections.emptyList(), Collections.singletonMap(
+        Plugin.Engine.Source source = Plugin.Engine.Source.InMemory.ofTypes(Collections.<Class<?>>emptyList(), Collections.<ClassFileVersion, Collection<Class<?>>>singletonMap(
             ClassFileVersion.JAVA_V11,
             Collections.singletonList(Sample.class)));
         Plugin.Engine.Target.InMemory target = new Plugin.Engine.Target.InMemory();

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/AbstractByteBuddyTask.java
Patch:
@@ -481,8 +481,8 @@ public static void apply(Logger logger,
             classFileLocators.add(rootLocator);
             for (File artifact : artifacts) {
                 classFileLocators.add(artifact.isFile()
-                        ? ClassFileLocator.ForJarFile.of(artifact)
-                        : new ClassFileLocator.ForFolder(artifact));
+                        ? ClassFileLocator.ForJarFile.of(artifact, classFileVersion)
+                        : ClassFileLocator.ForFolder.of(artifact, classFileVersion));
             }
             ClassFileLocator classFileLocator = new ClassFileLocator.Compound(classFileLocators);
             try {
@@ -493,6 +493,7 @@ public static void apply(Logger logger,
                                 ? Plugin.Engine.PoolStrategy.Default.EXTENDED
                                 : Plugin.Engine.PoolStrategy.Default.FAST)
                         .with(classFileLocator)
+                        .with(classFileVersion)
                         .with(new TransformationLogger(logger))
                         .withErrorHandlers(Plugin.Engine.ErrorHandler.Enforcing.ALL_TYPES_RESOLVED, failOnLiveInitializer
                                 ? Plugin.Engine.ErrorHandler.Enforcing.NO_LIVE_INITIALIZERS

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/ByteBuddyJarsTask.java
Patch:
@@ -25,7 +25,6 @@
 import javax.inject.Inject;
 import java.io.File;
 import java.io.IOException;
-import java.nio.file.Path;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Queue;

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/ByteBuddyJarsTask.java
Patch:
@@ -28,7 +28,6 @@
 import java.nio.file.Path;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.Optional;
 import java.util.Queue;
 
 /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -13,7 +13,6 @@
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.dynamic.loading.PackageDefinitionStrategy;
 import net.bytebuddy.implementation.bytecode.StackSize;
-import net.bytebuddy.pool.TypePool;
 import net.bytebuddy.test.packaging.SimpleType;
 import net.bytebuddy.test.scope.EnclosingType;
 import net.bytebuddy.test.utility.JavaVersionRule;
@@ -27,7 +26,6 @@
 import org.junit.Test;
 import org.junit.rules.MethodRule;
 import org.objectweb.asm.*;
-import org.objectweb.asm.signature.SignatureWriter;
 
 import java.io.Serializable;
 import java.lang.annotation.Annotation;

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -8852,6 +8852,7 @@ public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, TypePath type
                                     typePath,
                                     receiverTypeAnnotationTokens);
                             break;
+                        case TypeReference.CLASS_EXTENDS: // Emitted by mistake by javac for type variables in Java 9-11.
                         case TypeReference.FIELD: // Emitted by mistake by javac for records in Java 14.
                             return null;
                         default:

File: byte-buddy-gradle-plugin/android-plugin/src/main/java/net/bytebuddy/build/gradle/android/ByteBuddyAndroidTaskExtension.java
Patch:
@@ -97,7 +97,7 @@ public class ByteBuddyAndroidTaskExtension {
     public ByteBuddyAndroidTaskExtension(Project project) {
         this.project = project;
         transformations = new ArrayList<Transformation>();
-        entryPoint = EntryPoint.Default.REBASE;
+        entryPoint = new EntryPoint.Unvalidated(EntryPoint.Default.DECORATE);
         suffix = "";
         failOnLiveInitializer = true;
         warnOnEmptyTypeSet = true;

File: byte-buddy-gradle-plugin/android-plugin/src/main/java/net/bytebuddy/build/gradle/android/ByteBuddyAndroidPlugin.java
Patch:
@@ -92,6 +92,8 @@ public class ByteBuddyAndroidPlugin implements Plugin<Project> {
             Class<?> scopedArtifact = Class.forName("com.android.build.api.artifact.ScopedArtifact");
             @SuppressWarnings("unchecked")
             Object project = Enum.valueOf((Class) scope, "ALL");
+            @SuppressWarnings("unchecked")
+            Artifact<FileSystemLocation> location = (Artifact<FileSystemLocation>) Class.forName("com.android.build.api.artifact.ScopedArtifact$CLASSES").getField("INSTANCE").get(null);
             dispatcher = new TransformationDispatcher.ForApk74CompatibleAndroid(
                 Artifacts.class.getMethod("forScope", scope),
                 scopedArtifacts.getMethod("use", TaskProvider.class),
@@ -101,7 +103,7 @@ public class ByteBuddyAndroidPlugin implements Plugin<Project> {
                     Function1.class,
                     Function1.class),
                 project,
-                (Artifact<FileSystemLocation>) Class.forName("com.android.build.api.artifact.ScopedArtifact$CLASSES").getField("INSTANCE").get(null));
+                location);
         } catch (Throwable ignored) {
             dispatcher = TransformationDispatcher.ForLegacyAndroid.INSTANCE;
         }

File: byte-buddy-gradle-plugin/android-plugin/src/main/java/net/bytebuddy/build/gradle/android/ByteBuddyAndroidTaskExtension.java
Patch:
@@ -15,9 +15,9 @@
  */
 package net.bytebuddy.build.gradle.android;
 
+import groovy.lang.Closure;
 import net.bytebuddy.build.EntryPoint;
 import org.gradle.api.Action;
-import org.gradle.api.Closure;
 import org.gradle.api.Project;
 
 import java.util.ArrayList;

File: byte-buddy-gradle-plugin/android-plugin/src/main/java/net/bytebuddy/build/gradle/android/LegacyByteBuddyLocalClassesEnhancerTask.java
Patch:
@@ -206,15 +206,15 @@ public static class ConfigurationAction implements Action<LegacyByteBuddyLocalCl
          * The current variant's Byte Buddy configuration.
          */
         private final FileCollection byteBuddyConfiguration;
+
         /**
          * The android gradle extension.
          */
-
         private final BaseExtension androidExtension;
+
         /**
          * The current variant's runtime classpath.
          */
-
         private final FileCollection runtimeClasspath;
 
         /**

File: byte-buddy-gradle-plugin/android-plugin/src/main/java/net/bytebuddy/build/gradle/android/Transformation.java
Patch:
@@ -17,7 +17,6 @@
 
 import groovy.lang.Closure;
 import net.bytebuddy.build.Plugin;
-import net.bytebuddy.build.gradle.PluginArgument;
 import net.bytebuddy.utility.nullability.MaybeNull;
 import net.bytebuddy.utility.nullability.UnknownNull;
 import org.gradle.api.Action;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDefinition.java
Patch:
@@ -292,7 +292,7 @@ protected static TypeDescription.Generic describe(Type type, TypeDescription.Gen
          */
         protected static TypeDescription.Generic describeOrNull(@MaybeNull Type type, TypeDescription.Generic.AnnotationReader annotationReader) {
             if (type == null) {
-                throw new IllegalStateException("A generic type is represented as null what indicates that a type variable was used without declaration");
+                throw new TypeNotPresentException("<unknown>", null);
             }
             return describe(type, annotationReader);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -4628,7 +4628,7 @@ protected UnresolvedTypeVariable(TypeVariableSource typeVariableSource,
                          * {@inheritDoc}
                          */
                         public TypeList.Generic getUpperBounds() {
-                            throw new IllegalStateException("Cannot resolve bounds of unresolved type variable " + this + " by " + typeVariableSource);
+                            throw new TypeNotPresentException(symbol, null);
                         }
 
                         /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -613,14 +613,14 @@ public void testMalformedMethodSignature() throws Exception {
         typeDescription.getDeclaredMethods().filter(isMethod()).getOnly().getReturnType().getSort();
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test(expected = TypeNotPresentException.class)
     public void testMalformedTypeVariableDefinition() throws Exception {
         TypeDescription typeDescription = describe(TypeVariableMalformer.malform(MalformedTypeVariable.class));
         assertThat(typeDescription.getDeclaredFields().size(), is(1));
         typeDescription.getDeclaredFields().getOnly().getType().getUpperBounds();
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test(expected = TypeNotPresentException.class)
     public void testMalformedParameterizedTypeVariableDefinition() throws Exception {
         TypeDescription typeDescription = describe(TypeVariableMalformer.malform(MalformedParameterizedTypeVariable.class));
         assertThat(typeDescription.getDeclaredFields().getOnly().getType().getTypeArguments().size(), is(1));

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationValue.java
Patch:
@@ -2452,6 +2452,9 @@ public Sort getSort() {
         public AnnotationValue<U, V> filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
             if (typeDefinition.isArray() && typeDefinition.getComponentType().asErasure().equals(componentType)) {
                 for (AnnotationValue<?, ?> value : values) {
+                    if (value.getSort() != Sort.of(componentType)) {
+                        return new ForMismatchedType<U, V>(property, RenderingDispatcher.CURRENT.toArrayErrorString(value.getSort()));
+                    }
                     value = value.filter(property, typeDefinition.getComponentType());
                     if (value.getState() != State.RESOLVED) {
                         return (AnnotationValue<U, V>) value;

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/MemberSubstitutionTest.java
Patch:
@@ -846,7 +846,7 @@ public void testSubstitutionChainArgumentLoaded() throws Exception {
         Object instance = type.getDeclaredConstructor().newInstance();
         assertThat(type.getDeclaredField(FOO).get(instance), is((Object) FOO));
         assertThat(type.getDeclaredMethod(RUN, Object.class).invoke(instance, QUX), nullValue(Object.class));
-        assertThat(type.getDeclaredField(FOO).get(instance), is((Object) QUX + BAZ));
+        assertThat(type.getDeclaredField(FOO).get(instance), is((Object) (QUX + BAZ)));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -822,7 +822,7 @@ private TypeProjection(Class<?> type, int index, Class<?>[] erasure) {
                 protected TypeDescription.Generic resolve() {
                     java.lang.reflect.Type[] type = this.type.getGenericInterfaces();
                     return erasure.length == type.length
-                            ? Sort.describe(type[index], getAnnotationReader())
+                            ? Sort.describeOrNull(type[index], getAnnotationReader())
                             : asRawType();
                 }
 
@@ -918,7 +918,7 @@ private TypeProjection(Constructor<?> constructor, int index, Class<?>[] erasure
                 protected TypeDescription.Generic resolve() {
                     java.lang.reflect.Type[] type = constructor.getGenericExceptionTypes();
                     return erasure.length == type.length
-                            ? Sort.describe(type[index], getAnnotationReader())
+                            ? Sort.describeOrNull(type[index], getAnnotationReader())
                             : asRawType();
                 }
 
@@ -1014,7 +1014,7 @@ public TypeProjection(Method method, int index, Class<?>[] erasure) {
                 protected TypeDescription.Generic resolve() {
                     java.lang.reflect.Type[] type = method.getGenericExceptionTypes();
                     return erasure.length == type.length
-                            ? Sort.describe(type[index], getAnnotationReader())
+                            ? Sort.describeOrNull(type[index], getAnnotationReader())
                             : asRawType();
                 }
 

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/ByteBuddyMojo.java
Patch:
@@ -743,7 +743,7 @@ public static class ForExplicitLocations extends ByteBuddyMojo {
 
         @Override
         protected List<String> resolveClassPathElements() throws MojoExecutionException, MojoFailureException {
-            List<String> classPath = new ArrayList<>();
+            List<String> classPath = new ArrayList<String>();
             classPath.add(source);
             if (dependencies != null && !dependencies.isEmpty()) {
                 RepositorySystemSession repositorySystemSession = this.repositorySystemSession == null ? MavenRepositorySystemUtils.newSession() : this.repositorySystemSession;

File: byte-buddy-maven-plugin/src/test/java/net/bytebuddy/build/maven/ClassLoaderResolverTest.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.build.maven;
 
 import org.apache.maven.plugin.MojoExecutionException;
+import org.apache.maven.plugin.MojoFailureException;
 import org.apache.maven.plugin.logging.Log;
 import org.eclipse.aether.RepositorySystem;
 import org.eclipse.aether.RepositorySystemSession;
@@ -87,7 +88,7 @@ public void testCollectionFailure() throws Exception {
         classLoaderResolver.resolve(new MavenCoordinate(FOO, BAR, QUX, JAR));
     }
 
-    @Test(expected = MojoExecutionException.class)
+    @Test(expected = MojoFailureException.class)
     public void testResolutionFailure() throws Exception {
         when(repositorySystem.resolveDependencies(eq(repositorySystemSession), any(DependencyRequest.class)))
                 .thenThrow(new DependencyResolutionException(new DependencyResult(new DependencyRequest(root, mock(DependencyFilter.class))), new Throwable()));

File: byte-buddy-android/src/main/java/net/bytebuddy/android/AndroidClassLoadingStrategy.java
Patch:
@@ -891,7 +891,7 @@ public dalvik.system.DexFile loadDex(File privateDirectory,
                         throw new IllegalArgumentException("On Android P, a class injection can only be applied to BaseDexClassLoader: " + classLoader);
                     }
                     try {
-                        addDexPath.invoke(classLoader, jar.getAbsolutePath(), true);
+                        addDexPath.invoke(classLoader, jar.getAbsolutePath(), false);
                         return NO_RETURN_VALUE;
                     } catch (IllegalAccessException exception) {
                         throw new IllegalStateException("Cannot access BaseDexClassLoader#addDexPath(String, boolean)", exception);

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -1528,6 +1528,7 @@ private static File createJarFile() throws IOException {
             /**
              * {@inheritDoc}
              */
+            @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but trigger a fallback.")
             public File resolve() throws IOException {
                 try {
                     if (!Installer.class.getName().equals(Installer.NAME)) {
@@ -1547,6 +1548,7 @@ public File resolve() throws IOException {
                         return resolved;
                     }
                 } catch (Exception ignored) {
+                    /* do nothing */
                 }
                 return createJarFile();
             }

File: byte-buddy-agent/src/test/java/net/bytebuddy/agent/InstallerTest.java
Patch:
@@ -1,6 +1,5 @@
 package net.bytebuddy.agent;
 
-import org.hamcrest.CoreMatchers;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/Installer.java
Patch:
@@ -15,6 +15,7 @@
  */
 package net.bytebuddy.agent;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.agent.utility.nullability.MaybeNull;
 
 import java.lang.instrument.Instrumentation;
@@ -114,6 +115,7 @@ public static void agentmain(String arguments, Instrumentation instrumentation)
      *
      * @param instrumentation The instrumentation instance.
      */
+    @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not interrupt agent attachment.")
     private static void doMain(Instrumentation instrumentation) {
         Installer.instrumentation = instrumentation;
         try {

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -158,7 +158,7 @@ public class ClassFileVersion implements Comparable<ClassFileVersion>, Serializa
     /**
      * The class file version of Java 23.
      */
-    public static final ClassFileVersion JAVA_V23 = new ClassFileVersion(Opcodes.V22 + 1);
+    public static final ClassFileVersion JAVA_V23 = new ClassFileVersion(Opcodes.V23);
 
     /**
      * A version locator for the executing JVM.
@@ -344,7 +344,7 @@ public static ClassFileVersion ofJavaVersion(int javaVersion) {
      * @return The latest officially supported Java version.
      */
     public static ClassFileVersion latest() {
-        return ClassFileVersion.JAVA_V22;
+        return ClassFileVersion.JAVA_V23;
     }
 
     /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/ClassFileVersionTest.java
Patch:
@@ -80,7 +80,7 @@ public static Collection<Object[]> data() {
                 {20, 20, Arrays.asList("1.20", "20"), Opcodes.V20, (short) 64, (short) 0, true, true, true},
                 {21, 21, Arrays.asList("1.21", "21"), Opcodes.V21, (short) 65, (short) 0, true, true, true},
                 {22, 22, Arrays.asList("1.22", "22"), Opcodes.V22, (short) 66, (short) 0, true, true, true},
-                {23, 23, Arrays.asList("1.23", "23"), Opcodes.V22 + 1, (short) 67, (short) 0, true, true, true}
+                {23, 23, Arrays.asList("1.23", "23"), Opcodes.V23, (short) 67, (short) 0, true, true, true}
         });
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -1049,7 +1049,7 @@ protected String toSafeString() {
                 stringBuilder.append(Modifier.toString(modifiers)).append(' ');
             }
             if (isMethod()) {
-                stringBuilder.append(getReturnType().asErasure().getActualName()).append(' ');
+                stringBuilder.append('?').append(' ');
                 stringBuilder.append(getDeclaringType().asErasure().getActualName()).append('.');
             }
             return stringBuilder.append(getName()).append("(?)").toString();

File: byte-buddy-android/src/main/java/net/bytebuddy/android/AndroidClassLoadingStrategy.java
Patch:
@@ -33,6 +33,7 @@
 import net.bytebuddy.utility.nullability.AlwaysNull;
 import net.bytebuddy.utility.nullability.MaybeNull;
 
+import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -167,7 +168,7 @@ public Map<TypeDescription, Class<?>> load(@MaybeNull ClassLoader classLoader, M
             if (!jar.createNewFile()) {
                 throw new IllegalStateException("Cannot create " + jar);
             }
-            JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(jar));
+            JarOutputStream outputStream = new JarOutputStream(new BufferedOutputStream(new FileOutputStream(jar)));
             try {
                 outputStream.putNextEntry(new JarEntry(DEX_CLASS_FILE));
                 conversion.drainTo(outputStream);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -1842,13 +1842,13 @@ private static boolean isValidIdentifier(String[] identifier) {
          * @return {@code true} if the given identifier is valid.
          */
         private static boolean isValidIdentifier(String identifier) {
-            if (KEYWORDS.contains(identifier) || identifier.length() == 0 || !Character.isJavaIdentifierStart(identifier.charAt(0))) {
+            if (KEYWORDS.contains(identifier) || identifier.length() == 0 || !Character.isUnicodeIdentifierStart(identifier.charAt(0))) {
                 return false;
             } else if (identifier.equals(PackageDescription.PACKAGE_CLASS_NAME)) {
                 return true;
             }
             for (int index = 1; index < identifier.length(); index++) {
-                if (!Character.isJavaIdentifierPart(identifier.charAt(index))) {
+                if (!Character.isUnicodeIdentifierPart(identifier.charAt(index))) {
                     return false;
                 }
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -371,8 +371,8 @@ public Latent(TypeDescription declaringType, FieldDescription.Token token) {
          *
          * @param declaringType       The declaring type of the field.
          * @param name                The name of the field.
-         * @param fieldType           The field's modifiers.
-         * @param modifiers           The type of the field.
+         * @param fieldType           The type of the field.
+         * @param modifiers           The field's modifiers.
          * @param declaredAnnotations The annotations of this field.
          */
         public Latent(TypeDescription declaringType,

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -1907,7 +1907,7 @@ public Generic onParameterizedType(Generic parameterizedType) {
                     if (TypeDescription.AbstractBase.RAW_TYPES) {
                         typeArguments = Collections.emptyList();
                     } else {
-                        typeArguments = new ArrayList<>(parameterizedType.getTypeArguments().size());
+                        typeArguments = new ArrayList<Generic>(parameterizedType.getTypeArguments().size());
                         for (Generic typeArgument : parameterizedType.getTypeArguments()) {
                             typeArguments.add(typeArgument.accept(this));
                         }

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -703,7 +703,9 @@ private static void installExternal(AttachmentProvider.Accessor.ExternalAttachme
                     agent.getAbsolutePath(),
                     Boolean.toString(isNative),
                     argument == null ? "" : (AGENT_ARGUMENT_SEPARATOR + argument)).start().waitFor() != SUCCESSFUL_ATTACH) {
-                throw new IllegalStateException("Could not self-attach to current VM using external process");
+                throw new IllegalStateException("Could not self-attach to current VM using external process - set a property "
+                        + Attacher.DUMP_PROPERTY
+                        + " to dump the process output to a file at the specified location");
             }
         } finally {
             if (attachmentJar != null) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -8408,7 +8408,7 @@ public String getSimpleName() {
                         return internalName;
                     }
                 }
-                while (simpleNameIndex < internalName.length() && !Character.isLetter(internalName.charAt(simpleNameIndex))) {
+                while (simpleNameIndex < internalName.length() && !Character.isJavaIdentifierStart(internalName.charAt(simpleNameIndex))) {
                     simpleNameIndex += 1;
                 }
                 return internalName.substring(simpleNameIndex);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -75,7 +75,7 @@
  * <li>{@link net.bytebuddy.implementation.bind.annotation.Default}: A parameter that is annotated with
  * this annotation is assigned a proxy that allows calling an instrumented type's directly implemented interfaces'
  * default methods.</li>
- * <li>{@link net.bytebuddy.implementation.bind.annotation.DefaultCall}: A parameter
+ * <li>{@link net.bytebuddy.implementation.bind.annotation.SuperCall}: A parameter
  * of {@code Qux#baz} that is annotated with {@code SuperCall} will be assigned an instance of a type implementing both
  * {@link java.lang.Runnable} and {@link java.util.concurrent.Callable} which will invoke the instrumented method on the
  * invocation of either interface's method. The call is made using the original arguments of the method invocation.
@@ -84,8 +84,8 @@
  * source method is abstract, using this annotation excludes the method with this parameter annotation from being bound
  * to this source method.
  * </li>
- * <li>{@link net.bytebuddy.implementation.bind.annotation.SuperCall}:
- * This annotation is similar to the {@link net.bytebuddy.implementation.bind.annotation.DefaultCall}
+ * <li>{@link net.bytebuddy.implementation.bind.annotation.DefaultCall}:
+ * This annotation is similar to the {@link net.bytebuddy.implementation.bind.annotation.SuperCall}
  * annotation but it invokes a default method that is compatible to this method. If a source method does not represent
  * a default method, using this annotation excludes the method with this parameter annotation from being bound to this
  * source method. For using method handles, the {@link net.bytebuddy.implementation.bind.annotation.SuperCallHandle}

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -75,7 +75,7 @@
  * <li>{@link net.bytebuddy.implementation.bind.annotation.Default}: A parameter that is annotated with
  * this annotation is assigned a proxy that allows calling an instrumented type's directly implemented interfaces'
  * default methods.</li>
- * <li>{@link net.bytebuddy.implementation.bind.annotation.SuperCall}: A parameter
+ * <li>{@link net.bytebuddy.implementation.bind.annotation.DefaultCall}: A parameter
  * of {@code Qux#baz} that is annotated with {@code SuperCall} will be assigned an instance of a type implementing both
  * {@link java.lang.Runnable} and {@link java.util.concurrent.Callable} which will invoke the instrumented method on the
  * invocation of either interface's method. The call is made using the original arguments of the method invocation.

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/ByteBuddyPlugin.java
Patch:
@@ -306,7 +306,7 @@ protected static class JavaConventionConfiguration {
             try {
                 javaPluginConvention = Class.forName("org.gradle.api.plugins.JavaPluginConvention");
                 getConvention = Project.class.getMethod("getConvention");
-                findPlugin = Class.forName("org.gradle.api.plugins.Convention").getMethod("findClass", Class.class);
+                findPlugin = Class.forName("org.gradle.api.plugins.Convention").getMethod("findPlugin", Class.class);
                 getSourceSetsConvention = javaPluginConvention.getMethod("getSourceSets");
                 getTargetCompatibilityConvention = javaPluginConvention.getMethod("getTargetCompatibility");
             } catch (Throwable ignored) {

File: byte-buddy-gradle-plugin/android-plugin/src/main/java/net/bytebuddy/build/gradle/android/ByteBuddyLocalClassesEnhancerTask.java
Patch:
@@ -377,7 +377,8 @@ public void retain(Plugin.Engine.Source.Element element) throws IOException {
                     }
                     outputStream.closeEntry();
                 } catch (ZipException exception) {
-                    if (!element.getName().startsWith("META-INF")) {
+                    String name = element.getName();
+                    if (!name.startsWith("META-INF") && !name.endsWith("-info.class")) {
                         throw exception;
                     }
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -3370,7 +3370,9 @@ enum Default implements PoolStrategy {
              * {@inheritDoc}
              */
             public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader) {
-                return new TypePool.Default.WithLazyResolution(TypePool.CacheProvider.Simple.withObjectType(), classFileLocator, readerMode);
+                return new TypePool.LazyFacade(new TypePool.Default.WithLazyResolution(TypePool.CacheProvider.Simple.withObjectType(),
+                        classFileLocator,
+                        readerMode));
             }
 
             /**

File: byte-buddy-gradle-plugin/android-plugin-test/aar-bytebuddy-plugin/src/main/java/net/bytebuddy/plugin/gradle/test/aar/AarAdvice.java
Patch:
@@ -29,6 +29,6 @@ public class AarAdvice {
      */
     @Advice.OnMethodExit
     public static void onExit(@Advice.Return(readOnly = false) String returned) {
-        returned = "bar";
+        returned = "instrumented local class from aar plugin";
     }
 }

File: byte-buddy-gradle-plugin/android-plugin-test/jar-bytebuddy-plugin/src/main/java/net/bytebuddy/plugin/gradle/test/jar/AdviceForLocalClass.java
Patch:
@@ -20,7 +20,7 @@
 /**
  * A sample advice class.
  */
-public class JarAdvice {
+public class AdviceForLocalClass {
 
     /**
      * Applies an exit advice.
@@ -29,6 +29,6 @@ public class JarAdvice {
      */
     @Advice.OnMethodExit
     public static void enter(@Advice.Return(readOnly = false) String returned) {
-        returned = "bar";
+        returned = "instrumented local class from jar plugin";
     }
 }

File: byte-buddy-gradle-plugin/android-plugin/src/main/java/net/bytebuddy/build/gradle/android/LegacyByteBuddyLocalClassesEnhancerTask.java
Patch:
@@ -28,7 +28,6 @@
 import org.gradle.api.DefaultTask;
 import org.gradle.api.GradleException;
 import org.gradle.api.JavaVersion;
-import org.gradle.api.artifacts.Configuration;
 import org.gradle.api.file.ConfigurableFileCollection;
 import org.gradle.api.file.Directory;
 import org.gradle.api.file.DirectoryProperty;
@@ -206,7 +205,7 @@ public static class ConfigurationAction implements Action<LegacyByteBuddyLocalCl
         /**
          * The current variant's Byte Buddy configuration.
          */
-        private final Configuration byteBuddyConfiguration;
+        private final FileCollection byteBuddyConfiguration;
         /**
          * The android gradle extension.
          */
@@ -223,7 +222,7 @@ public static class ConfigurationAction implements Action<LegacyByteBuddyLocalCl
          * @param androidExtension       The android gradle extension.
          * @param runtimeClasspath       The current variant's runtime classpath.
          */
-        public ConfigurationAction(Configuration byteBuddyConfiguration, BaseExtension androidExtension, FileCollection runtimeClasspath) {
+        public ConfigurationAction(FileCollection byteBuddyConfiguration, BaseExtension androidExtension, FileCollection runtimeClasspath) {
             this.byteBuddyConfiguration = byteBuddyConfiguration;
             this.androidExtension = androidExtension;
             this.runtimeClasspath = runtimeClasspath;

File: byte-buddy-gradle-plugin/android-plugin/src/main/java/net/bytebuddy/build/gradle/android/ByteBuddyAndroidPlugin.java
Patch:
@@ -82,13 +82,14 @@ public class ByteBuddyAndroidPlugin implements Plugin<Project> {
         try {
             Class<?> scope = Class.forName("com.android.build.api.variant.ScopedArtifacts$Scope");
             Class<?> scopedArtifacts = Class.forName("com.android.build.api.variant.ScopedArtifacts");
+            Class<?> scopedArtifact = Class.forName("com.android.build.api.artifact.ScopedArtifact");
             @SuppressWarnings("unchecked")
             Object project = Enum.valueOf((Class) scope, "PROJECT");
             dispatcher = new TransformationDispatcher.ForApk74CompatibleAndroid(
                 Artifacts.class.getMethod("forScope", scope),
                 scopedArtifacts.getMethod("use", TaskProvider.class),
                 Class.forName("com.android.build.api.variant.ScopedArtifactsOperation").getMethod("toTransform",
-                    scopedArtifacts,
+                    scopedArtifact,
                     Function1.class,
                     Function1.class,
                     Function1.class),

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -402,7 +402,7 @@ public static ClassFileVersion ofClassFile(byte[] binaryRepresentation) {
         if (binaryRepresentation.length < 7) {
             throw new IllegalArgumentException("Supplied byte array is too short to be a class file with " + binaryRepresentation.length + " byte");
         }
-        return ofMinorMajor(binaryRepresentation[6] << 8 | binaryRepresentation[7] & 0xFF);
+        return ofMinorMajor(binaryRepresentation[5] << 16 | binaryRepresentation[7] & 0xFF);
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -402,7 +402,7 @@ public static ClassFileVersion ofClassFile(byte[] binaryRepresentation) {
         if (binaryRepresentation.length < 7) {
             throw new IllegalArgumentException("Supplied byte array is too short to be a class file with " + binaryRepresentation.length + " byte");
         }
-        return ofMinorMajor(binaryRepresentation[6] << 8 | binaryRepresentation[7] & 0xFF);
+        return ofMinorMajor(binaryRepresentation[5] << 16 | binaryRepresentation[7] & 0xFF);
     }
 
     /**

File: byte-buddy-android/src/main/java/net/bytebuddy/android/AndroidClassLoadingStrategy.java
Patch:
@@ -269,7 +269,9 @@ public void accept(File file) {
                 } catch (IllegalAccessException exception) {
                     throw new IllegalStateException("Cannot access file system permissions", exception);
                 } catch (InvocationTargetException exception) {
-                    throw new IllegalStateException("Cannot invoke file system permissions method", exception.getTargetException());
+                    if (!(exception.getTargetException() instanceof UnsupportedOperationException)) {
+                        throw new IllegalStateException("Cannot invoke file system permissions method", exception.getTargetException());
+                    }
                 }
             }
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/ResettableClassFileTransformerSubstitutableTest.java
Patch:
@@ -31,6 +31,7 @@ public class ResettableClassFileTransformerSubstitutableTest {
     private ResettableClassFileTransformer classFileTransformer, other;
 
     @Test
+    @JavaVersionRule.Enforce(7) // avoids bug in legacy Mockito
     public void testTransformLegacy() throws Exception {
         when(classFileTransformer.transform(Foo.class.getClassLoader(),
             FOO,
@@ -72,6 +73,7 @@ public void testTransformModern() throws Exception {
     }
 
     @Test
+    @JavaVersionRule.Enforce(7) // avoids bug in legacy Mockito
     public void testReplace() throws Exception {
         when(classFileTransformer.transform(Foo.class.getClassLoader(),
                 FOO,
@@ -92,7 +94,7 @@ private static class Foo {
         /* empty */
     }
 
-    private static class Holder {
+    private static class Holder { // avoids bug in legacy Mockito
 
         private static final byte[] FIRST = new byte[]{0}, SECOND = new byte[]{1};
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/ResettableClassFileTransformer.java
Patch:
@@ -15,6 +15,7 @@
  */
 package net.bytebuddy.agent.builder;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.build.AccessControllerPlugin;
 import net.bytebuddy.build.HashCodeAndEqualsPlugin;
@@ -560,6 +561,7 @@ enum CreationAction implements PrivilegedAction<Factory> {
                     /**
                      * {@inheritDoc}
                      */
+                    @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but trigger a fallback.")
                     public Factory run() {
                         try {
                             return new ForJava9CapableVm(new ByteBuddy()

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -5520,7 +5520,7 @@ enum ForSubstitution implements TransformerDecorator {
              * {@inheritDoc}
              */
             public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {
-                return new ResettableClassFileTransformer.WithDelegation.Substitutable(classFileTransformer);
+                return ResettableClassFileTransformer.WithDelegation.Substitutable.of(classFileTransformer);
             }
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -1822,7 +1822,7 @@ public Map<String, Class<?>> injectRaw(Map<? extends String, byte[]> types) {
                     } catch (ClassNotFoundException ignored) {
                         try {
                             result.put(entry.getKey(), dispatcher.defineClass(classLoader, entry.getKey(), entry.getValue(), protectionDomain));
-                        } catch (Exception exception) { // The bootstrap loader lock might be replicated throughout multiple class loaders.
+                        } catch (RuntimeException exception) { // The bootstrap loader lock might be replicated throughout multiple class loaders.
                             try {
                                 result.put(entry.getKey(), Class.forName(entry.getKey(), false, classLoader));
                             } catch (ClassNotFoundException ignored2) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/DecoratingDynamicTypeBuilder.java
Patch:
@@ -505,7 +505,7 @@ protected TypeWriter<T> toTypeWriter(TypePool typePool) {
                 implementationContextFactory,
                 typeValidation,
                 classWriterStrategy,
-                typePool,
+                TypePool.Explicit.wrap(instrumentedType, auxiliaryTypes, typePool),
                 classFileLocator);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -243,7 +243,7 @@ protected TypeWriter<T> toTypeWriter(TypePool typePool) {
                 implementationContextFactory,
                 typeValidation,
                 classWriterStrategy,
-                typePool,
+                TypePool.Explicit.wrap(instrumentedType, auxiliaryTypes, typePool),
                 originalType,
                 classFileLocator,
                 methodRebaseResolver);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -218,7 +218,7 @@ protected TypeWriter<T> toTypeWriter(TypePool typePool) {
                 implementationContextFactory,
                 typeValidation,
                 classWriterStrategy,
-                typePool,
+                TypePool.Explicit.wrap(instrumentedType, auxiliaryTypes, typePool),
                 originalType,
                 classFileLocator);
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -228,7 +228,7 @@ protected TypeWriter<T> toTypeWriter(TypePool typePool) {
                 implementationContextFactory,
                 typeValidation,
                 classWriterStrategy,
-                typePool);
+                TypePool.Explicit.wrap(instrumentedType, auxiliaryTypes, typePool));
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -8354,7 +8354,7 @@ public OfDefault(int index) {
                      * {@inheritDoc}
                      */
                     public Bound bind(MethodDescription instrumentedMethod, Relocation relocation) {
-                        return new ForValue.Bound(instrumentedMethod, relocation, index, true);
+                        return new ForValue.Bound(instrumentedMethod, relocation, index, false);
                     }
                 }
 
@@ -8437,6 +8437,7 @@ public int apply(MethodVisitor methodVisitor, Implementation.Context implementat
                         Label noSkip = new Label();
                         int size;
                         if (index < 0) {
+                            size = requiredSize;
                             methodVisitor.visitVarInsn(load, offset);
                         } else {
                             methodVisitor.visitVarInsn(Opcodes.ALOAD, offset);
@@ -8453,7 +8454,7 @@ public int apply(MethodVisitor methodVisitor, Implementation.Context implementat
                                 : defaultJump, noSkip);
                         relocation.apply(methodVisitor);
                         methodVisitor.visitLabel(noSkip);
-                        return requiredSize;
+                        return size;
                     }
                 }
             }

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceLocalVariableArrayTest.java
Patch:
@@ -48,10 +48,12 @@ public void method(long a, Void b, Void c) {
 
     public static class ShiftVariablesAdvice {
 
+        @Advice.OnMethodEnter
         static void enter(@Advice.Argument(1) Void ignored) {
             /* empty */
         }
 
+        @Advice.OnMethodExit
         static void exit(@Advice.Argument(1) Void ignored) {
             /* empty */
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -15,6 +15,7 @@
  */
 package net.bytebuddy.utility;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.build.AccessControllerPlugin;
 import net.bytebuddy.description.enumeration.EnumerationDescription;
@@ -1000,6 +1001,7 @@ public static MethodType ofSetter(Field field) {
          * @param fieldDescription The field to extract a setter type for.
          * @return The type of a setter for the given field.
          */
+        @SuppressFBWarnings(value = "NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE", justification = "Assuming declaring type for type member.")
         public static MethodType ofSetter(FieldDescription fieldDescription) {
             return new MethodType(TypeDescription.ForLoadedType.of(void.class), fieldDescription.isStatic()
                     ? Collections.singletonList(fieldDescription.getType().asErasure())
@@ -1022,6 +1024,7 @@ public static MethodType ofGetter(Field field) {
          * @param fieldDescription The field to extract a getter type for.
          * @return The type of a getter for the given field.
          */
+        @SuppressFBWarnings(value = "NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE", justification = "Assuming declaring type for type member.")
         public static MethodType ofGetter(FieldDescription fieldDescription) {
             return new MethodType(fieldDescription.getType().asErasure(), fieldDescription.isStatic()
                     ? Collections.<TypeDescription>emptyList()

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -15016,9 +15016,9 @@ public <T extends Annotation> WithCustomMapping bindLambda(Class<T> type,
                     Collections.<AnnotationDescription>emptyList(),
                     AnnotationValue.UNDEFINED,
                     TypeDescription.Generic.UNDEFINED),
-                JavaConstant.MethodType.of(methods.asDefined().getOnly()),
+                JavaConstant.MethodType.ofSignature(methods.asDefined().getOnly()),
                 JavaConstant.MethodHandle.of(methodDescription),
-                JavaConstant.MethodType.of(methods.asDefined().getOnly()));
+                JavaConstant.MethodType.ofSignature(methods.asDefined().getOnly()));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberSubstitution.java
Patch:
@@ -6098,9 +6098,9 @@ public <T extends Annotation> WithCustomMapping bindLambda(Class<T> type,
                                             Collections.<AnnotationDescription>emptyList(),
                                             AnnotationValue.UNDEFINED,
                                             TypeDescription.Generic.UNDEFINED),
-                                    JavaConstant.MethodType.of(methods.asDefined().getOnly()),
+                                    JavaConstant.MethodType.ofSignature(methods.asDefined().getOnly()),
                                     JavaConstant.MethodHandle.of(methodDescription),
-                                    JavaConstant.MethodType.of(methods.asDefined().getOnly()));
+                                    JavaConstant.MethodType.ofSignature(methods.asDefined().getOnly()));
                         }
 
                         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -324,9 +324,9 @@ public static WithImplicitArguments lambda(MethodDescription.InDefinedShape meth
                         Collections.<AnnotationDescription>emptyList(),
                         AnnotationValue.UNDEFINED,
                         TypeDescription.Generic.UNDEFINED),
-                JavaConstant.MethodType.of(methods.asDefined().getOnly()),
+                JavaConstant.MethodType.ofSignature(methods.asDefined().getOnly()),
                 JavaConstant.MethodHandle.of(methodDescription),
-                JavaConstant.MethodType.of(methods.getOnly())).invoke(methods.asDefined().getOnly().getInternalName());
+                JavaConstant.MethodType.ofSignature(methods.getOnly())).invoke(methods.asDefined().getOnly().getInternalName());
     }
 
     /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/OriginBinderTest.java
Patch:
@@ -143,6 +143,7 @@ public void testMethodHandleBinding() throws Exception {
     public void testMethodTypeBinding() throws Exception {
         when(genericTargetType.asErasure()).thenReturn(TypeDescription.ForLoadedType.of(JavaType.METHOD_TYPE.load()));
         when(methodDescription.getReturnType()).thenReturn(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(void.class));
+        when(methodDescription.getDeclaringType()).thenReturn(TypeDescription.ForLoadedType.of(Void.class));
         when(methodDescription.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = Origin.Binder.INSTANCE
                 .bind(annotationDescription, source, target, implementationTarget, assigner, Assigner.Typing.STATIC);

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberSubstitution.java
Patch:
@@ -3666,6 +3666,7 @@ class ForAllArguments implements OffsetMapping {
                              * The typing to use or {@code null} if implicit typing.
                              */
                             @MaybeNull
+                            @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
                             private final Assigner.Typing typing;
 
                             /**
@@ -4112,6 +4113,7 @@ abstract class ForField implements OffsetMapping {
                              * The typing to use or {@code null} if implicit typing.
                              */
                             @MaybeNull
+                            @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
                             private final Assigner.Typing typing;
 
                             /**
@@ -5257,6 +5259,7 @@ class ForCurrent implements OffsetMapping {
                              * The typing to use or {@code null} if implicit typing.
                              */
                             @MaybeNull
+                            @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
                             private final Assigner.Typing typing;
 
                             /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -42,8 +42,8 @@
  */
 public interface FieldDescription extends ByteCodeElement,
         ModifierReviewable.ForFieldDescription,
-        ByteCodeElement.Member,
         DeclaredByType.WithMandatoryDeclaration,
+        ByteCodeElement.Member,
         ByteCodeElement.TypeDependant<FieldDescription.InDefinedShape, FieldDescription.Token> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -57,8 +57,8 @@
  */
 public interface MethodDescription extends TypeVariableSource,
         ModifierReviewable.ForMethodDescription,
-        ByteCodeElement.Member,
         DeclaredByType.WithMandatoryDeclaration,
+        ByteCodeElement.Member,
         ByteCodeElement.TypeDependant<MethodDescription.InDefinedShape, MethodDescription.Token> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -59,7 +59,7 @@ public interface MethodDescription extends TypeVariableSource,
         ModifierReviewable.ForMethodDescription,
         ByteCodeElement.Member,
         DeclaredByType.WithMandatoryDeclaration,
-        ByteCodeElement.TypeDependant<MethodDescription.InDefinedShape, MethodDescription.Token>{
+        ByteCodeElement.TypeDependant<MethodDescription.InDefinedShape, MethodDescription.Token> {
 
     /**
      * The internal name of a Java constructor.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -41,8 +41,8 @@
  */
 public interface FieldDescription extends ByteCodeElement,
         ModifierReviewable.ForFieldDescription,
-        ByteCodeElement.Member,
-        ByteCodeElement.TypeDependant<FieldDescription.InDefinedShape, FieldDescription.Token> {
+        ByteCodeElement.TypeDependant<FieldDescription.InDefinedShape, FieldDescription.Token>,
+        ByteCodeElement.Member {
 
     /**
      * A representative of a field's non-set default value.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -56,8 +56,8 @@
  */
 public interface MethodDescription extends TypeVariableSource,
         ModifierReviewable.ForMethodDescription,
-        ByteCodeElement.Member,
-        ByteCodeElement.TypeDependant<MethodDescription.InDefinedShape, MethodDescription.Token> {
+        ByteCodeElement.TypeDependant<MethodDescription.InDefinedShape, MethodDescription.Token>,
+        ByteCodeElement.Member {
 
     /**
      * The internal name of a Java constructor.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberSubstitution.java
Patch:
@@ -2667,7 +2667,7 @@ public StackManipulation apply(TypeDescription receiver,
                         /**
                          * A factory for creating an offset mapping based on an annotation on a parameter, method or constructor.
                          *
-                         * @param <T>
+                         * @param <T> The type of the annotation.
                          */
                         interface Factory<T extends Annotation> {
 
@@ -3027,7 +3027,7 @@ public OffsetMapping make(ParameterDescription.InDefinedShape target, Annotation
                             /**
                              * Assigns a value to the annotated parameter that is deserialized from a given input.
                              *
-                             * @param <T>
+                             * @param <T> The type of the annotation.
                              */
                             @HashCodeAndEqualsPlugin.Enhance
                             public static class OfSerializedConstant<T extends Annotation> extends OffsetMapping.Factory.AbstractBase<T> {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/AllArguments.java
Patch:
@@ -50,8 +50,8 @@
  * </p>
  * <p>
  * <b>Important</b>: Don't confuse this annotation with {@link net.bytebuddy.asm.Advice.AllArguments} or
- * {@link net.bytebuddy.asm.MemberSubstitution.Substitution.Chain.Step.ForDelegation.AllArguments}. This
- * annotation should be used with {@link net.bytebuddy.implementation.MethodDelegation} only.
+ * {@link net.bytebuddy.asm.MemberSubstitution.AllArguments}. This annotation should be used with
+ * {@link net.bytebuddy.implementation.MethodDelegation} only.
  * </p>
  *
  * @see net.bytebuddy.implementation.MethodDelegation

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Argument.java
Patch:
@@ -45,8 +45,8 @@
  * </p>
  * <p>
  * <b>Important</b>: Don't confuse this annotation with {@link net.bytebuddy.asm.Advice.Argument} or
- * {@link net.bytebuddy.asm.MemberSubstitution.Substitution.Chain.Step.ForDelegation.Argument}. This
- * annotation should be used with {@link net.bytebuddy.implementation.MethodDelegation} only.
+ * {@link net.bytebuddy.asm.MemberSubstitution.Argument}. This annotation should be used with
+ * {@link net.bytebuddy.implementation.MethodDelegation} only.
  * </p>
  *
  * @see net.bytebuddy.implementation.MethodDelegation

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Empty.java
Patch:
@@ -32,8 +32,8 @@
  * </p>
  * <p>
  * <b>Important</b>: Don't confuse this annotation with {@link net.bytebuddy.asm.Advice.Unused} or
- * {@link net.bytebuddy.asm.MemberSubstitution.Substitution.Chain.Step.ForDelegation.Unused}. This
- * annotation should be used with {@link net.bytebuddy.implementation.MethodDelegation} only.
+ * {@link net.bytebuddy.asm.MemberSubstitution.Unused}. This annotation should be used with
+ * {@link net.bytebuddy.implementation.MethodDelegation} only.
  * </p>
  *
  * @see net.bytebuddy.implementation.MethodDelegation

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldGetterHandle.java
Patch:
@@ -49,8 +49,8 @@
  * </p>
  * <p>
  * <b>Important</b>: Don't confuse this annotation with {@link net.bytebuddy.asm.Advice.FieldGetterHandle} or
- * {@link net.bytebuddy.asm.MemberSubstitution.Substitution.Chain.Step.ForDelegation.FieldSetterHandle}. This
- * annotation should be used with {@link net.bytebuddy.implementation.MethodDelegation} only.
+ * {@link net.bytebuddy.asm.MemberSubstitution.FieldSetterHandle}. This annotation should be used with
+ * {@link net.bytebuddy.implementation.MethodDelegation} only.
  * </p>
  *
  * @see net.bytebuddy.implementation.MethodDelegation

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldSetterHandle.java
Patch:
@@ -49,8 +49,8 @@
  * </p>
  * <p>
  * <b>Important</b>: Don't confuse this annotation with {@link net.bytebuddy.asm.Advice.FieldSetterHandle} or
- * {@link net.bytebuddy.asm.MemberSubstitution.Substitution.Chain.Step.ForDelegation.FieldSetterHandle}. This
- * annotation should be used with {@link net.bytebuddy.implementation.MethodDelegation} only.
+ * {@link net.bytebuddy.asm.MemberSubstitution.FieldSetterHandle}. This annotation should be used with
+ * {@link net.bytebuddy.implementation.MethodDelegation} only.
  * </p>
  *
  * @see net.bytebuddy.implementation.MethodDelegation

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Origin.java
Patch:
@@ -69,8 +69,8 @@
  * </p>
  * <p>
  * <b>Important</b>: Don't confuse this annotation with {@link net.bytebuddy.asm.Advice.Origin} or
- * {@link net.bytebuddy.asm.MemberSubstitution.Substitution.Chain.Step.ForDelegation.Origin}. This
- * annotation should be used with {@link net.bytebuddy.implementation.MethodDelegation} only.
+ * {@link net.bytebuddy.asm.MemberSubstitution.Origin}. This annotation should be used with
+ * {@link net.bytebuddy.implementation.MethodDelegation} only.
  * </p>
  *
  * @see net.bytebuddy.implementation.MethodDelegation

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/StubValue.java
Patch:
@@ -39,8 +39,8 @@
  * </p>
  * <p>
  * <b>Important</b>: Don't confuse this annotation with {@link net.bytebuddy.asm.Advice.StubValue} or
- * {@link net.bytebuddy.asm.MemberSubstitution.Substitution.Chain.Step.ForDelegation.StubValue}. This
- * annotation should be used with {@link net.bytebuddy.implementation.MethodDelegation} only.
+ * {@link net.bytebuddy.asm.MemberSubstitution.StubValue}. This annotation should be used with
+ * {@link net.bytebuddy.implementation.MethodDelegation} only.
  * </p>
  *
  * @see net.bytebuddy.implementation.MethodDelegation

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/This.java
Patch:
@@ -38,8 +38,8 @@
  * </p>
  * <p>
  * <b>Important</b>: Don't confuse this annotation with {@link net.bytebuddy.asm.Advice.This} or
- * {@link net.bytebuddy.asm.MemberSubstitution.Substitution.Chain.Step.ForDelegation.This}. This
- * annotation should be used with {@link net.bytebuddy.implementation.MethodDelegation} only.
+ * {@link net.bytebuddy.asm.MemberSubstitution.This}. This annotation should be used with
+ * {@link net.bytebuddy.implementation.MethodDelegation} only.
  * </p>
  *
  * @see net.bytebuddy.implementation.MethodDelegation

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/MemberSubstitutionChainWithAnnotationTest.java
Patch:
@@ -30,7 +30,7 @@ public void testMemberSubstitutionArgumentToElement() throws Exception {
         assertThat(type.getDeclaredMethod(RUN, String.class).invoke(instance, BAZ), nullValue(Object.class));
         assertThat(type.getDeclaredField(FOO).get(instance), is((Object) FOO));
         assertThat(type.getDeclaredField(BAR).get(instance), is((Object) BAR));
-        assertThat(type.getDeclaredField(QUX).get(null), is((Object) BAR));
+        assertThat(type.getDeclaredField(QUX).get(null), is((Object) BAZ));
     }
 
     @Test
@@ -157,7 +157,7 @@ public void testMemberSubstitutionThisReferenceNone() throws Exception {
             .redefine(ThisReferenceSample.class)
             .visit(MemberSubstitution.strict()
                 .field(named(BAZ))
-                .replaceWithChain(MemberSubstitution.Substitution.Chain.Step.ForDelegation.of(ThisReferenceSample.class.getMethod("optional", Object.class)))
+                .replaceWithChain(MemberSubstitution.Substitution.Chain.Step.ForDelegation.of(ThisReferenceSample.class.getMethod("none", Object.class)))
                 .on(named(RUN)))
             .make();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationGenericTest.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.implementation.bytecode.member;
 
 import net.bytebuddy.description.method.MethodDescription;
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.assign.TypeCasting;
@@ -114,7 +115,7 @@ public void testGenericMethodSpecialErasureEqual() throws Exception {
     public void testGenericMethodDynamic() throws Exception {
         TypeDescription genericErasure = mock(TypeDescription.class);
         when(methodReturnType.asErasure()).thenReturn(genericErasure);
-        when(declaredMethod.isInvokeBootstrap()).thenReturn(true);
+        when(declaredMethod.isInvokeBootstrap(Collections.<TypeDefinition>emptyList())).thenReturn(true);
         StackManipulation stackManipulation = MethodInvocation.invoke(methodDescription).dynamic(FOO,
                 otherType,
                 Collections.<TypeDescription>emptyList(),
@@ -129,7 +130,7 @@ public void testGenericMethodDynamic() throws Exception {
     @Test
     public void testGenericMethodDynamicErasureEqual() throws Exception {
         when(methodReturnType.asErasure()).thenReturn(declaredErasure);
-        when(declaredMethod.isInvokeBootstrap()).thenReturn(true);
+        when(declaredMethod.isInvokeBootstrap(Collections.<TypeDefinition>emptyList())).thenReturn(true);
         StackManipulation stackManipulation = MethodInvocation.invoke(methodDescription).dynamic(FOO,
                 otherType,
                 Collections.<TypeDescription>emptyList(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/MemberSubstitutionChainWithAnnotationTest.java
Patch:
@@ -177,7 +177,7 @@ public static void element(@MemberSubstitution.Substitution.Chain.Step.ForDelega
             qux = value;
         }
 
-        public static void method(@MemberSubstitution.Substitution.Chain.Step.ForDelegation.Argument(value = 0, target = MemberSubstitution.Substitution.Chain.Step.ForDelegation.Source.ENCLOSING_METHOD) String value) {
+        public static void method(@MemberSubstitution.Substitution.Chain.Step.ForDelegation.Argument(value = 0, source = MemberSubstitution.Substitution.Chain.Step.ForDelegation.Source.ENCLOSING_METHOD) String value) {
             qux = value;
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationSuperMethodHandleTest.java
Patch:
@@ -38,6 +38,7 @@ public class MethodDelegationSuperMethodHandleTest {
     public MethodRule accessControllerRule = new AccessControllerRule();
 
     @Test
+    @JavaVersionRule.Enforce(value = 7, target = Foo.class)
     public void testRunnableSuperCall() throws Exception {
         DynamicType.Loaded<Foo> loaded = new ByteBuddy()
                 .subclass(Foo.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationSuperCallTest.java
Patch:
@@ -67,7 +67,7 @@ public void testWithArgument() throws Exception {
                 .make()
                 .load(Baz.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER);
         Baz instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
-        assertThat(instance.foo(FOO), is(FOO));
+        assertThat(instance.foo(FOO), is((Object) FOO));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberSubstitution.java
Patch:
@@ -56,7 +56,7 @@
  * <p>
  * Substitutes field access, method invocations or constructor calls within a method's body.
  * </p>
- * <p>Note</p>: This substitution must not used to to match constructor calls to an instrumented class's super constructor invocation from
+ * <p>Note</p>: This substitution must not be used to match constructor calls to an instrumented class's super constructor invocation from
  * within a constructor. Matching such constructors will result in an invalid stack and a verification error.
  * <p>
  * <b>Important</b>: This component relies on using a {@link TypePool} for locating types within method bodies. Within a redefinition

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberSubstitution.java
Patch:
@@ -56,7 +56,7 @@
  * <p>
  * Substitutes field access, method invocations or constructor calls within a method's body.
  * </p>
- * <p>Note</p>: This substitution must not used to to match constructor calls to an instrumented class's super constructor invocation from
+ * <p>Note</p>: This substitution must not be used to match constructor calls to an instrumented class's super constructor invocation from
  * within a constructor. Matching such constructors will result in an invalid stack and a verification error.
  * <p>
  * <b>Important</b>: This component relies on using a {@link TypePool} for locating types within method bodies. Within a redefinition

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -2917,9 +2917,8 @@ public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder,
 
             /**
              * Allows for decoration of advice for subclass implementations of this transformer. Note that a subclass is not retained when
-             * using the builder methods of this class. Subclasses are expected to create their final state by invoking the
-             * {@link AgentBuilder.Transformer.ForAdvice#ForAdvice(Advice.WithCustomMapping, Advice.ExceptionHandler, Assigner, ClassFileLocator, PoolStrategy, LocationStrategy, List)}
-             * constructor with the final state already during construction.
+             * using the builder methods of this class. Subclasses are expected to create their final state by invoking the protected constructor
+             * with the final state already during construction.
              *
              * @param typeDescription  The description of the type currently being instrumented.
              * @param classLoader      The class loader of the instrumented class. Might be {@code null} to represent the bootstrap class loader.

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -2918,7 +2918,7 @@ public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder,
             /**
              * Allows for decoration of advice for subclass implementations of this transformer. Note that a subclass is not retained when
              * using the builder methods of this class. Subclasses are expected to create their final state by invoking the
-             * {@link ForAdvice#ForAdvice(Advice.WithCustomMapping, Advice.ExceptionHandler, Assigner, ClassFileLocator, PoolStrategy, LocationStrategy, List)}
+             * {@link AgentBuilder.Transformer.ForAdvice#ForAdvice(Advice.WithCustomMapping, Advice.ExceptionHandler, Assigner, ClassFileLocator, PoolStrategy, LocationStrategy, List)}
              * constructor with the final state already during construction.
              *
              * @param typeDescription  The description of the type currently being instrumented.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberSubstitution.java
Patch:
@@ -2018,6 +2018,7 @@ protected ForField(FieldDescription fieldDescription, Assigner assigner, Assigne
                     /**
                      * {@inheritDoc}
                      */
+                    @SuppressFBWarnings(value = "NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE", justification = "Field description always has declaring type.")
                     public Resolution resolve(TypeDescription targetType,
                                               ByteCodeElement target,
                                               TypeList.Generic parameters,

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/RenamingPlugin.java
Patch:
@@ -48,7 +48,7 @@ public class RenamingPlugin extends AsmVisitorWrapper.AbstractBase implements Pl
     private final Renaming renaming;
 
     /**
-     * A matcher that determines what types to consider for renaming
+     * A matcher that determines what types to consider for renaming.
      */
     private final ElementMatcher<? super TypeDescription> matcher;
 
@@ -83,10 +83,10 @@ public RenamingPlugin(Renaming renaming) {
     }
 
     /**
-     * Creates a ewnaming plugin for the given renaming and type matcher.
+     * Creates a renaming plugin for the given renaming and type matcher.
      *
      * @param renaming The renaming to apply.
-     * @param matcher  A matcher that determines what types to consider.
+     * @param matcher  A matcher that determines what types to consider for renaming.
      */
     public RenamingPlugin(Renaming renaming, ElementMatcher<? super TypeDescription> matcher) {
         this.renaming = renaming;

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -2344,6 +2344,7 @@ public void testInactiveExecutingTransformerReturnsNullValue() throws Exception
                 poolStrategy,
                 typeStrategy,
                 locationStrategy,
+                mock(ClassFileLocator.class),
                 mock(AgentBuilder.Default.NativeMethodStrategy.class),
                 initializationStrategy,
                 mock(AgentBuilder.InjectionStrategy.class),
@@ -2377,6 +2378,7 @@ public void testExecutingTransformerDoesNotRecurse() throws Exception {
                 poolStrategy,
                 typeStrategy,
                 locationStrategy,
+                mock(ClassFileLocator.class),
                 mock(AgentBuilder.Default.NativeMethodStrategy.class),
                 initializationStrategy,
                 mock(AgentBuilder.InjectionStrategy.class),
@@ -2417,6 +2419,7 @@ public void testExecutingTransformerDoesNotRecurseWithModules() throws Exception
                 poolStrategy,
                 typeStrategy,
                 locationStrategy,
+                mock(ClassFileLocator.class),
                 mock(AgentBuilder.Default.NativeMethodStrategy.class),
                 initializationStrategy,
                 mock(AgentBuilder.InjectionStrategy.class),

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/ByteBuddyPlugin.java
Patch:
@@ -48,7 +48,7 @@ public class ByteBuddyPlugin implements Plugin<Project> {
             Class.forName("org.gradle.work.InputChanges"); // Make sure that at least Gradle 6 is available.
             dispatcher = new Dispatcher.ForApi6CapableGradle(SourceDirectorySet.class.getMethod("getDestinationDirectory"),
                     AbstractCompile.class.getMethod("setDestinationDir", Class.forName("org.gradle.api.provider.Provider")));
-        } catch (Exception ignored) {
+        } catch (Throwable ignored) {
             dispatcher = Dispatcher.ForLegacyGradle.INSTANCE;
         }
         DISPATCHER = dispatcher;

File: byte-buddy-gradle-plugin/android-plugin/src/main/java/net/bytebuddy/build/gradle/android/classpath/DependenciesClasspathProvider.java
Patch:
@@ -40,10 +40,10 @@ static DependenciesClasspathProvider getInstance(AndroidPluginVersion currentVer
         Logger logger = Logging.getLogger(DependenciesClasspathProvider.class);
         try {
             if (isLowerThan73) {
-                logger.lifecycle("Using legacy classpath provider implementation");
+                logger.debug("Using legacy classpath provider implementation");
                 return (DependenciesClasspathProvider) Class.forName("net.bytebuddy.build.gradle.android.classpath.impl.LegacyDependenciesClasspathProvider").getDeclaredConstructor().newInstance();
             } else {
-                logger.lifecycle("Using default classpath provider implementation");
+                logger.debug("Using default classpath provider implementation");
                 return (DependenciesClasspathProvider) Class.forName("net.bytebuddy.build.gradle.android.classpath.impl.DefaultDependenciesClasspathProvider").getDeclaredConstructor().newInstance();
             }
         } catch (InstantiationException | IllegalAccessException | InvocationTargetException |

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/Attacher.java
Patch:
@@ -66,7 +66,7 @@ public static void main(String[] args) {
             try {
                 String property = System.getProperty(DUMP_PROPERTY);
                 if (property != null && property.length() > 0) {
-                    PrintStream outputStream = new PrintStream(new FileOutputStream(property));
+                    PrintStream outputStream = new PrintStream(new FileOutputStream(property, true), false, "UTF-8");
                     try {
                         throwable.printStackTrace(outputStream);
                     } finally {

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -93,7 +93,7 @@ public class ByteBuddyAgent {
     /**
      * The size of the buffer for copying the agent installer file into another jar.
      */
-    private static final int BUFFER_SIZE = 1024;
+    private static final int BUFFER_SIZE = 1024 * 8;
 
     /**
      * Convenience indices for reading and writing to the buffer to make the code more readable.
@@ -689,6 +689,7 @@ private static void installExternal(AttachmentProvider.Accessor.ExternalAttachme
             if (new ProcessBuilder(System.getProperty(JAVA_HOME)
                     + File.separatorChar + "bin"
                     + File.separatorChar + (System.getProperty(OS_NAME, "").toLowerCase(Locale.US).contains("windows") ? "java.exe" : "java"),
+                    "-D" + Attacher.DUMP_PROPERTY + "=" + System.getProperty(Attacher.DUMP_PROPERTY, ""),
                     CLASS_PATH_ARGUMENT,
                     classPath.toString(),
                     Attacher.class.getName(),

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/Installer.java
Patch:
@@ -95,7 +95,7 @@ public static void premain(String arguments, Instrumentation instrumentation) {
     }
 
     /**
-     * Allows the installation of this agent via the Attach API.
+     * Allows the installation of this agent via the attach API.
      *
      * @param arguments       The unused agent arguments.
      * @param instrumentation The instrumentation instance.

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/AbstractByteBuddyTask.java
Patch:
@@ -372,6 +372,7 @@ protected void doApply(Plugin.Engine.Source source, Plugin.Engine.Target target)
         }
         List<Transformation> transformations = new ArrayList<Transformation>(getTransformations());
         ClassLoader classLoader = ByteBuddySkippingUrlClassLoader.of(getClass().getClassLoader(), discoverySet(), classPath());
+        Plugin.Engine.Summary summary;
         try {
             if (discovery.isDiscover(transformations)) {
                 Set<String> undiscoverable = new HashSet<String>();
@@ -423,7 +424,6 @@ protected void doApply(Plugin.Engine.Source source, Plugin.Engine.Target target)
                         : new ClassFileLocator.ForFolder(artifact));
             }
             ClassFileLocator classFileLocator = new ClassFileLocator.Compound(classFileLocators);
-            Plugin.Engine.Summary summary;
             try {
                 getLogger().info("Processing class files located in in: {}", source());
                 Plugin.Engine pluginEngine;

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginEngineSourceCompoundTest.java
Patch:
@@ -76,7 +76,7 @@ public Iterator<Plugin.Engine.Source.Element> answer(InvocationOnMock invocation
 
     @Test
     public void testEmptyCompound() throws Exception {
-        assertThat(new Plugin.Engine.Source.Compound(Collections.emptyList()).read(), sameInstance((Plugin.Engine.Source.Origin) Plugin.Engine.Source.Empty.INSTANCE));
+        assertThat(new Plugin.Engine.Source.Compound(Collections.<Plugin.Engine.Source>emptyList()).read(), sameInstance((Plugin.Engine.Source.Origin) Plugin.Engine.Source.Empty.INSTANCE));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -4125,7 +4125,7 @@ public OffsetMapping make(ParameterDescription.InDefinedShape target, Annotation
                     }
                     return new ForStackManipulation(MethodInvocation.invoke(bootstrapMethod).dynamic(methodCandidates.getOnly().getInternalName(),
                             target.getType().asErasure(),
-                            Collections.emptyList(),
+                            Collections.<TypeDescription>emptyList(),
                             arguments), target.getType(), target.getType(), Assigner.Typing.STATIC);
                 }
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -4125,7 +4125,7 @@ public OffsetMapping make(ParameterDescription.InDefinedShape target, Annotation
                     }
                     return new ForStackManipulation(MethodInvocation.invoke(bootstrapMethod).dynamic(methodCandidates.getOnly().getInternalName(),
                             target.getType().asErasure(),
-                            methodCandidates.getOnly().getParameters().asTypeList().asErasures(),
+                            Collections.emptyList(),
                             arguments), target.getType(), target.getType(), Assigner.Typing.STATIC);
                 }
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -4125,7 +4125,7 @@ public OffsetMapping make(ParameterDescription.InDefinedShape target, Annotation
                     }
                     return new ForStackManipulation(MethodInvocation.invoke(bootstrapMethod).dynamic(methodCandidates.getOnly().getInternalName(),
                             target.getType().asErasure(),
-                            methodCandidates.getOnly().getParameters().asTypeList().asErasures(),
+                            Collections.emptyList(),
                             arguments), target.getType(), target.getType(), Assigner.Typing.STATIC);
                 }
             }

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/AbstractByteBuddyTask.java
Patch:
@@ -20,7 +20,6 @@
 import net.bytebuddy.build.BuildLogger;
 import net.bytebuddy.build.EntryPoint;
 import net.bytebuddy.build.Plugin;
-import net.bytebuddy.build.gradle.common.GradleBuildLogger;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.scaffold.inline.MethodNameTransformer;

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/GradleBuildLogger.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.bytebuddy.build.gradle.common;
+package net.bytebuddy.build.gradle;
 
 import net.bytebuddy.build.BuildLogger;
 import org.gradle.api.logging.Logger;

File: byte-buddy-gradle-plugin/android-plugin/src/main/java/net/bytebuddy/build/gradle/android/ByteBuddyAndroidService.java
Patch:
@@ -96,6 +96,7 @@ public void initialize(ByteBuddyInstrumentationParameters parameters) {
                 ClassLoader classLoader = new URLClassLoader(
                         toUrls(parameters.getByteBuddyClasspath().getFiles()),
                         new URLClassLoader(toUrls(parameters.getAndroidBootClasspath().getFiles()), ByteBuddy.class.getClassLoader()));
+                AndroidDescriptor androidDescriptor = DefaultAndroidDescriptor.ofClassPath(parameters.getLocalClassesDirectories().getFiles());
                 ArrayList<Plugin.Factory> factories = new ArrayList<Plugin.Factory>();
                 for (String name : Plugin.Engine.Default.scan(classLoader)) {
                     try {
@@ -127,7 +128,7 @@ public void initialize(ByteBuddyInstrumentationParameters parameters) {
                         typePool,
                         classFileLocator,
                         classLoader,
-                        DefaultAndroidDescriptor.ofClassPath(parameters.getLocalClassesDirectories().getFiles()));
+                        androidDescriptor);
             } catch (IOException exception) {
                 throw new IllegalStateException(exception);
             }

File: byte-buddy-gradle-plugin/android-plugin/src/main/java/net/bytebuddy/build/gradle/android/ByteBuddyAndroidService.java
Patch:
@@ -96,6 +96,7 @@ public void initialize(ByteBuddyInstrumentationParameters parameters) {
                 ClassLoader classLoader = new URLClassLoader(
                         toUrls(parameters.getByteBuddyClasspath().getFiles()),
                         new URLClassLoader(toUrls(parameters.getAndroidBootClasspath().getFiles()), ByteBuddy.class.getClassLoader()));
+                AndroidDescriptor androidDescriptor = DefaultAndroidDescriptor.ofClassPath(parameters.getLocalClassesDirectories().getFiles());
                 ArrayList<Plugin.Factory> factories = new ArrayList<Plugin.Factory>();
                 for (String name : Plugin.Engine.Default.scan(classLoader)) {
                     try {
@@ -127,7 +128,7 @@ public void initialize(ByteBuddyInstrumentationParameters parameters) {
                         typePool,
                         classFileLocator,
                         classLoader,
-                        DefaultAndroidDescriptor.ofClassPath(parameters.getLocalClassesDirectories().getFiles()));
+                        androidDescriptor);
             } catch (IOException exception) {
                 throw new IllegalStateException(exception);
             }

File: byte-buddy-gradle-plugin/android-plugin/src/main/java/net/bytebuddy/build/gradle/android/ByteBuddyAndroidService.java
Patch:
@@ -117,7 +117,7 @@ public void initialize(ByteBuddyInstrumentationParameters parameters) {
                     }
                     plugins.add(plugin);
                 }
-                EntryPoint entryPoint = new EntryPoint.Unvalidated(EntryPoint.Default.REBASE);
+                EntryPoint entryPoint = new EntryPoint.Unvalidated(EntryPoint.Default.DECORATE);
                 ByteBuddy byteBuddy = entryPoint.byteBuddy(classFileVersion);
                 state = new State(plugins,
                         new Plugin.Engine.TypeStrategy.ForEntryPoint(entryPoint, MethodNameTransformer.Suffixing.withRandomSuffix()),

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/ClassVisitorFactory.java
Patch:
@@ -1354,8 +1354,8 @@ public ClassVisitorFactory<S> run() {
                             } else if (parameter[index] == Attribute.class) {
                                 match[index] = utilities.get(Attribute.class);
                                 if (sourceAttribute != null && targetAttribute != null) {
-                                    left.add(toConvertedParameter(sourceAttribute.getTypeDescription(), utilities.get(Attribute.class), AttributeTranslator.NAME, offset, false));
-                                    right.add(toConvertedParameter(targetAttribute.getTypeDescription(), Attribute.class, AttributeTranslator.NAME, offset, false));
+                                    left.add(toConvertedParameter(targetAttribute.getTypeDescription(), utilities.get(Attribute.class), AttributeTranslator.NAME, offset, false));
+                                    right.add(toConvertedParameter(sourceAttribute.getTypeDescription(), Attribute.class, AttributeTranslator.NAME, offset, false));
                                 } else {
                                     unsupported = true;
                                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -881,7 +881,7 @@ interface Factory {
              * @param classFileVersion            The class file version of the created class.
              * @param auxiliaryClassFileVersion   The class file version of any auxiliary classes.
              * @return An implementation context in its extractable view.
-             * @deprecated Use {@link Implementation.Context.Factory#make(TypeDescription, AuxiliaryType.NamingStrategy, TypeInitializer, ClassFileVersion, ClassFileVersion, FrameGeneration)}.
+             * @deprecated Use {@link Implementation.Context.Factory#make(TypeDescription, AuxiliaryType.NamingStrategy, TypeInitializer, ClassFileVersion, ClassFileVersion, Implementation.Context.FrameGeneration)}.
              */
             @Deprecated
             ExtractableView make(TypeDescription instrumentedType,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -734,10 +734,10 @@ public void full(MethodVisitor methodVisitor,
              * @param methodVisitor             The method visitor to use
              * @param type                      The frame type.
              * @param stackCount                The number of values on the operand stack.
-             * @param stack                     The values on the operand stack up to {@code stackCount}, or {@link null}, if none.
+             * @param stack                     The values on the operand stack up to {@code stackCount}, or {@code null}, if none.
              * @param changedLocalVariableCount The number of local variables that were changed.
              * @param changedLocalVariable      The values added to the local variable array up to {@code changedLocalVariableCount}
-             *                                  or {@link null}, if none or not applicable.
+             *                                  or {@code null}, if none or not applicable.
              * @param fullLocalVariableCount    The number of local variables.
              * @param fullLocalVariable         The total number of local variables up to {@code fullLocalVariableCount} or
              *                                  {@code null}, if none.
@@ -881,7 +881,7 @@ interface Factory {
              * @param classFileVersion            The class file version of the created class.
              * @param auxiliaryClassFileVersion   The class file version of any auxiliary classes.
              * @return An implementation context in its extractable view.
-             * @deprecated Use {@link Factory#make(TypeDescription, AuxiliaryType.NamingStrategy, TypeInitializer, ClassFileVersion, ClassFileVersion, FrameGeneration)}.
+             * @deprecated Use {@link Implementation.Context.Factory#make(TypeDescription, AuxiliaryType.NamingStrategy, TypeInitializer, ClassFileVersion, ClassFileVersion, FrameGeneration)}.
              */
             @Deprecated
             ExtractableView make(TypeDescription instrumentedType,

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/ClassVisitorFactory.java
Patch:
@@ -231,7 +231,7 @@ public static <S> ClassVisitorFactory<S> of(Class<S> classVisitor, ByteBuddy byt
                             left.add(new MethodCall.ArgumentLoader.ForMethodParameter.Factory(index));
                             right.add(new MethodCall.ArgumentLoader.ForMethodParameter.Factory(index));
                         }
-                        offset = parameter[index] == long.class || parameter[index] == double.class ? 2 : 1;
+                        offset += parameter[index] == long.class || parameter[index] == double.class ? 2 : 1;
                     }
                     Method target;
                     try {

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/ClassVisitorFactoryTest.java
Patch:
@@ -63,4 +63,4 @@ public void visitEnd() {
 
         // method.invoke(factory.wrap(classVisitor));
     }
-}
\ No newline at end of file
+}

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -2282,7 +2282,7 @@ public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLo
                                     module,
                                     Collections.singleton(target),
                                     Collections.<String, Set<JavaModule>>emptyMap(),
-                                    !addTargetEdge || location == null
+                                    !addTargetEdge || location == null || location.isDefault()
                                             ? Collections.<String, Set<JavaModule>>emptyMap()
                                             : Collections.singletonMap(location.getName(), Collections.singleton(target)),
                                     Collections.<Class<?>>emptySet(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -1626,7 +1626,7 @@ public boolean isAlive() {
         public Map<String, Class<?>> injectRaw(Map<? extends String, byte[]> types) {
             PackageDescription target = TypeDescription.ForLoadedType.of(lookupType()).getPackage();
             if (target == null) {
-                throw new IllegalStateException("Cannot inject into default package");
+                throw new IllegalArgumentException("Cannot inject array or primitive type");
             }
             Map<String, Class<?>> result = new HashMap<String, Class<?>>();
             for (Map.Entry<? extends String, byte[]> entry : types.entrySet()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -1425,7 +1425,7 @@ public boolean isLocalType() {
         public PackageDescription getPackage() {
             int packageIndex = name.lastIndexOf('.');
             return packageIndex == -1
-                    ? PackageDescription.UNDEFINED
+                    ? PackageDescription.DEFAULT
                     : new PackageDescription.Simple(name.substring(0, packageIndex));
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -22,7 +22,6 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.DynamicType;
-import net.bytebuddy.dynamic.TypeResolutionStrategy;
 import net.bytebuddy.dynamic.VisibilityBridgeStrategy;
 import net.bytebuddy.dynamic.scaffold.*;
 import net.bytebuddy.implementation.Implementation;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -21,7 +21,6 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.DynamicType;
-import net.bytebuddy.dynamic.TypeResolutionStrategy;
 import net.bytebuddy.dynamic.VisibilityBridgeStrategy;
 import net.bytebuddy.dynamic.scaffold.*;
 import net.bytebuddy.implementation.Implementation;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/HashCodeMethod.java
Patch:
@@ -463,7 +463,7 @@ protected class AfterInstruction extends StackManipulation.AbstractBase {
                  */
                 public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
                     methodVisitor.visitLabel(label);
-                    if (implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V6)) {
+                    if (implementationContext.getFrameGeneration().isActive()) { // TODO
                         methodVisitor.visitFrame(Opcodes.F_SAME1, EMPTY.length, EMPTY, INTEGER.length, INTEGER);
                     }
                     return Size.ZERO;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -1166,7 +1166,7 @@ public List<ArgumentLoader> resolve(MethodDescription instrumentedMethod, Method
              * A factory for an argument loader that supplies a method parameter as an argument.
              */
             @HashCodeAndEqualsPlugin.Enhance
-            protected static class Factory implements ArgumentLoader.Factory, ArgumentProvider {
+            public static class Factory implements ArgumentLoader.Factory, ArgumentProvider {
 
                 /**
                  * The index of the parameter to be loaded onto the operand stack.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/MetadataAwareClassVisitor.java
Patch:
@@ -260,13 +260,13 @@ public final void visitInnerClass(String name, @MaybeNull String outerName, @May
     /**
      * An order-sensitive invocation of {@link ClassVisitor#visitInnerClass(String, String, String, int)}.
      *
-     * @param name      The internal name of the inner class.
+     * @param internalName      The internal name of the inner class.
      * @param outerName The internal name of the outer class or {@code null} for a member class.
      * @param innerName The inner class's simple name or {@code null} for an anonymous class.
      * @param modifiers The inner class's source code modifiers.
      */
-    protected void onVisitInnerClass(String name, @MaybeNull String outerName, @MaybeNull String innerName, int modifiers) {
-        super.visitInnerClass(name, outerName, innerName, modifiers);
+    protected void onVisitInnerClass(String internalName, @MaybeNull String outerName, @MaybeNull String innerName, int modifiers) {
+        super.visitInnerClass(internalName, outerName, innerName, modifiers);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/PackageDescriptionForLoadedPackageTest.java
Patch:
@@ -3,6 +3,6 @@
 public class PackageDescriptionForLoadedPackageTest extends AbstractPackageDescriptionTest {
 
     protected PackageDescription describe(Class<?> type) {
-        return new PackageDescription.ForLoadedPackage(type.getPackage());
+        return TypeDescription.ForLoadedType.of(type).getPackage();
     }
 }

File: byte-buddy-gradle-plugin/android-plugin-test/src/test/java/net/bytebuddy/build/gradle/android/ByteBuddyAndroidPluginTest.java
Patch:
@@ -4,7 +4,6 @@
 import net.bytebuddy.test.utility.ProjectInfo;
 import org.junit.Test;
 
-import java.io.File;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 

File: byte-buddy-gradle-plugin/android-plugin-test/src/test/assets/dummyProjects/dummy_target_jar/java/com/sompackage/SomeLibClass.java
Patch:
@@ -1,3 +1,5 @@
+package com.somepackage;
+
 public class SomeLibClass {
 
     public String getMessage() {

File: byte-buddy-gradle-plugin/android-plugin-test/src/test/java/net/bytebuddy/build/gradle/android/ByteBuddyAndroidPluginTest.java
Patch:
@@ -77,7 +77,7 @@ public void transformAndroidProjectClassesFromItselfAndItsLibraries() {
 
         ClassLoader classLoader = getAppClassloader(appProject);
         verifyClassIsInstrumented(classLoader, "com.somepackage.SomeClass");
-        verifyClassIsInstrumented(classLoader, "SomeLibClass");
+        verifyClassIsInstrumented(classLoader, "com.somepackage.SomeLibClass");
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/visitor/ContextClassVisitorTest.java
Patch:
@@ -26,13 +26,13 @@ public class ContextClassVisitorTest {
 
     @Test
     public void testPassive() {
-        new TestContextClassVisitor(Collections.emptyList(), loadedTypeInitializer).visitEnd();
+        new TestContextClassVisitor(Collections.<DynamicType>emptyList(), loadedTypeInitializer).visitEnd();
     }
 
     @Test(expected = IllegalStateException.class)
     public void testPassiveLoadedTypeInitializer() {
         when(loadedTypeInitializer.isAlive()).thenReturn(true);
-        new TestContextClassVisitor(Collections.emptyList(), loadedTypeInitializer).visitEnd();
+        new TestContextClassVisitor(Collections.<DynamicType>emptyList(), loadedTypeInitializer).visitEnd();
     }
 
     @Test(expected = IllegalStateException.class)

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/PackageDescription.java
Patch:
@@ -93,7 +93,7 @@ public boolean contains(TypeDescription typeDescription) {
          * {@inheritDoc}
          */
         public boolean isDefault() {
-            return getName().isEmpty();
+            return getName().length() == 0;
         }
 
         @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/PackageDescriptionForLoadedPackageTest.java
Patch:
@@ -3,6 +3,6 @@
 public class PackageDescriptionForLoadedPackageTest extends AbstractPackageDescriptionTest {
 
     protected PackageDescription describe(Class<?> type) {
-        return new PackageDescription.ForLoadedPackage(type.getPackage());
+        return TypeDescription.ForLoadedType.of(type).getPackage();
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -2282,7 +2282,7 @@ public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLo
                                     module,
                                     Collections.singleton(target),
                                     Collections.<String, Set<JavaModule>>emptyMap(),
-                                    !addTargetEdge || location == null
+                                    !addTargetEdge || location == null || location.isDefault()
                                             ? Collections.<String, Set<JavaModule>>emptyMap()
                                             : Collections.singletonMap(location.getName(), Collections.singleton(target)),
                                     Collections.<Class<?>>emptySet(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -1626,7 +1626,7 @@ public boolean isAlive() {
         public Map<String, Class<?>> injectRaw(Map<? extends String, byte[]> types) {
             PackageDescription target = TypeDescription.ForLoadedType.of(lookupType()).getPackage();
             if (target == null) {
-                throw new IllegalStateException("Cannot inject into default package");
+                throw new IllegalArgumentException("Cannot inject array or primitive type");
             }
             Map<String, Class<?>> result = new HashMap<String, Class<?>>();
             for (Map.Entry<? extends String, byte[]> entry : types.entrySet()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -1425,7 +1425,7 @@ public boolean isLocalType() {
         public PackageDescription getPackage() {
             int packageIndex = name.lastIndexOf('.');
             return packageIndex == -1
-                    ? PackageDescription.UNDEFINED
+                    ? PackageDescription.DEFAULT
                     : new PackageDescription.Simple(name.substring(0, packageIndex));
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -1524,8 +1524,8 @@ public void testWrapper() throws Exception {
                 .throwing(Exception.class)
                 .intercept(new Implementation.Simple(new TextConstant(FOO), MethodReturn.REFERENCE))
                 .wrap(classWriter);
-        classVisitor.visit(Opcodes.V1_6,
-                Opcodes.ACC_PUBLIC,
+        classVisitor.visit(ClassFileVersion.ofThisVm().getMinorMajorVersion(),
+                typeDescription.getActualModifiers(true),
                 typeDescription.getInternalName(),
                 typeDescription.getGenericSignature(),
                 typeDescription.getSuperClass().asErasure().getInternalName(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -217,7 +217,7 @@ protected DynamicType.Builder<T> materialize(InstrumentedType.WithFlexibleName i
     /**
      * {@inheritDoc}
      */
-    public DynamicType.Unloaded<T> make(TypeResolutionStrategy typeResolutionStrategy, TypePool typePool) {
+    protected TypeWriter<T> toTypeWriter(TypePool typePool) {
         MethodRegistry.Prepared methodRegistry = this.methodRegistry.prepare(instrumentedType,
                 methodGraphCompiler,
                 typeValidation,
@@ -247,6 +247,6 @@ public DynamicType.Unloaded<T> make(TypeResolutionStrategy typeResolutionStrateg
                 typePool,
                 originalType,
                 classFileLocator,
-                methodRebaseResolver).make(typeResolutionStrategy.resolve());
+                methodRebaseResolver);
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -217,7 +217,7 @@ protected DynamicType.Builder<T> materialize(InstrumentedType.WithFlexibleName i
     /**
      * {@inheritDoc}
      */
-    public DynamicType.Unloaded<T> make(TypeResolutionStrategy typeResolutionStrategy, TypePool typePool) {
+    protected TypeWriter<T> toTypeWriter(TypePool typePool) {
         MethodRegistry.Prepared methodRegistry = this.methodRegistry.prepare(instrumentedType,
                 methodGraphCompiler,
                 typeValidation,
@@ -247,6 +247,6 @@ public DynamicType.Unloaded<T> make(TypeResolutionStrategy typeResolutionStrateg
                 typePool,
                 originalType,
                 classFileLocator,
-                methodRebaseResolver).make(typeResolutionStrategy.resolve());
+                methodRebaseResolver);
     }
 }

File: byte-buddy-gradle-plugin/android-plugin/src/main/java/net/bytebuddy/build/gradle/android/transformation/impl/DefaultAndroidTransformation.java
Patch:
@@ -20,7 +20,6 @@
 import net.bytebuddy.build.Plugin;
 import net.bytebuddy.build.gradle.android.transformation.AndroidTransformation;
 import net.bytebuddy.build.gradle.android.transformation.impl.source.CompoundSourceOrigin;
-import net.bytebuddy.build.gradle.common.PluginNamesFinder;
 import net.bytebuddy.build.gradle.common.TransformationLogger;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.scaffold.inline.MethodNameTransformer;
@@ -79,10 +78,10 @@ private List<Plugin.Factory> createPluginFactories(AndroidTransformation.Input i
         URLClassLoader pluginLoader = new URLClassLoader(toUrlArray(input.bytebuddyDiscoveryClasspath), androidLoader);
         ArrayList<Plugin.Factory> factories = new ArrayList<>();
 
-        new PluginNamesFinder().find(pluginLoader, className -> {
+        for (String className : Plugin.Engine.Default.scan(pluginLoader)) {
             factories.add(createFactoryFromClassName(className, pluginLoader));
             logger.info("Resolved plugin: {}", className);
-        });
+        }
 
         return factories;
     }

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/ByteBuddyMojo.java
Patch:
@@ -259,7 +259,7 @@ public void execute() throws MojoExecutionException, MojoFailureException {
         }
         if (discovery.isDiscover(transformers)) {
             try {
-                Enumeration<URL> plugins = ByteBuddyMojo.class.getClassLoader().getResources("META-INF/net.bytebuddy/build.plugins");
+                Enumeration<URL> plugins = ByteBuddyMojo.class.getClassLoader().getResources(Plugin.Engine.Default.PLUGIN_FILE);
                 while (plugins.hasMoreElements()) {
                     discover(plugins.nextElement().openStream(), undiscoverable, transformers, null);
                 }
@@ -270,15 +270,15 @@ public void execute() throws MojoExecutionException, MojoFailureException {
                         if (artifact.isFile()) {
                             JarFile file = new JarFile(artifact);
                             try {
-                                JarEntry entry = file.getJarEntry("META-INF/net.bytebuddy/build.plugins");
+                                JarEntry entry = file.getJarEntry(Plugin.Engine.Default.PLUGIN_FILE);
                                 if (entry != null) {
                                     discover(file.getInputStream(entry), undiscoverable, transformers, elements);
                                 }
                             } finally {
                                 file.close();
                             }
                         } else {
-                            File file = new File(artifact, "META-INF/net.bytebuddy/build.plugins");
+                            File file = new File(artifact, Plugin.Engine.Default.PLUGIN_FILE);
                             if (file.exists()) {
                                 discover(new FileInputStream(file), undiscoverable, transformers, elements);
                             }

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/IncrementalResolver.java
Patch:
@@ -18,7 +18,6 @@
 import org.gradle.api.logging.Logger;
 import org.gradle.work.ChangeType;
 import org.gradle.work.FileChange;
-import org.gradle.api.Project;
 
 import java.io.File;
 import java.util.ArrayList;

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/dispatcher/JavaDispatcher.java
Patch:
@@ -1168,6 +1168,8 @@ public Object invoke(Object proxy, Method method, @MaybeNull Object[] argument)
                 }
             } catch (RuntimeException exception) {
                 throw exception;
+            } catch (Error error) {
+                throw error;
             } catch (Throwable throwable) {
                 for (Class<?> type : method.getExceptionTypes()) {
                     if (type.isInstance(throwable)) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/AbstractMethodDescriptionTest.java
Patch:
@@ -333,7 +333,7 @@ public void testToStringParameter() throws Exception {
     @Test
     @JavaVersionRule.Enforce(8)
     public void testParameterNameAndModifiers() throws Exception {
-        Class<?> type = Class.forName("net.bytebuddy.test.precompiled.v8.ParameterNames");
+        Class<?> type = Class.forName("net.bytebuddy.test.precompiled.v8parameters.ParameterNames");
         assertThat(describe(type.getDeclaredMethod("foo", String.class, long.class, int.class)).getParameters().get(0).isNamed(), is(true));
         assertThat(describe(type.getDeclaredMethod("foo", String.class, long.class, int.class)).getParameters().get(1).isNamed(), is(true));
         assertThat(describe(type.getDeclaredMethod("foo", String.class, long.class, int.class)).getParameters().get(2).isNamed(), is(true));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/AbstractDynamicTypeBuilderForInliningTest.java
Patch:
@@ -62,7 +62,7 @@ public abstract class AbstractDynamicTypeBuilderForInliningTest extends Abstract
 
     private static final int QUX = 42;
 
-    private static final String PARAMETER_NAME_CLASS = "net.bytebuddy.test.precompiled.v8.ParameterNames";
+    private static final String PARAMETER_NAME_CLASS = "net.bytebuddy.test.precompiled.v8parameters.ParameterNames";
 
     private static final String SIMPLE_TYPE_ANNOTATED = "net.bytebuddy.test.precompiled.v8.SimpleTypeAnnotatedType";
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderTest.java
Patch:
@@ -50,7 +50,7 @@ public class SubclassDynamicTypeBuilderTest extends AbstractDynamicTypeBuilderTe
 
     private static final String DEFAULT_METHOD_INTERFACE = "net.bytebuddy.test.precompiled.v8.SingleDefaultMethodInterface";
 
-    private static final String PARAMETER_NAME_CLASS = "net.bytebuddy.test.precompiled.v8.ParameterNames";
+    private static final String PARAMETER_NAME_CLASS = "net.bytebuddy.test.precompiled.v8parameters.ParameterNames";
 
     private static final Object STATIC_FIELD = null;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultApplicationSuperTypeLoadingTest.java
Patch:
@@ -19,6 +19,7 @@
 
 import java.lang.instrument.ClassFileTransformer;
 import java.lang.instrument.Instrumentation;
+import java.security.ProtectionDomain;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
@@ -113,7 +114,8 @@ private static class ConstantTransformer implements AgentBuilder.Transformer {
         public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder,
                                                 TypeDescription typeDescription,
                                                 ClassLoader classLoader,
-                                                JavaModule module) {
+                                                JavaModule module,
+                                                ProtectionDomain protectionDomain) {
             return builder
                     .method(isDeclaredBy(typeDescription).and(named(FOO))).intercept(FixedValue.value(FOO))
                     .method(isDeclaredBy(typeDescription).and(named(BAR))).intercept(FixedValue.value(BAR));

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultNativeApplicationTest.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.lang.instrument.ClassFileTransformer;
 import java.lang.instrument.Instrumentation;
+import java.security.ProtectionDomain;
 
 import static net.bytebuddy.matcher.ElementMatchers.named;
 import static net.bytebuddy.matcher.ElementMatchers.none;
@@ -100,7 +101,8 @@ private static class FooTransformer implements AgentBuilder.Transformer {
         public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder,
                                                 TypeDescription typeDescription,
                                                 ClassLoader classLoader,
-                                                JavaModule module) {
+                                                JavaModule module,
+                                                ProtectionDomain protectionDomain) {
             return builder.method(named(FOO)).intercept(MethodCall.invokeSuper().withArgument(0).with(2));
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/TypeVariableSource.java
Patch:
@@ -88,6 +88,7 @@ public interface TypeVariableSource extends ModifierReviewable.OfAbstraction {
      * <ul>
      * <li>A type declares type variables or is an inner class of a type with a generic declaration.</li>
      * <li>A method declares at least one type variable.</li>
+     * <li>A type is an inner anonymous class of a method with a generic declaration</li>
      * </ul>
      *
      * @return {@code true} if this type code element has a generic declaration.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/TypeVariableSource.java
Patch:
@@ -88,6 +88,7 @@ public interface TypeVariableSource extends ModifierReviewable.OfAbstraction {
      * <ul>
      * <li>A type declares type variables or is an inner class of a type with a generic declaration.</li>
      * <li>A method declares at least one type variable.</li>
+     * <li>A type is an inner anonymous class of a method with a generic declaration</li>
      * </ul>
      *
      * @return {@code true} if this type code element has a generic declaration.

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/ObjectFactory.java
Patch:
@@ -136,7 +136,7 @@ protected ForApi4CapableGradle(Method getObjects, Method newInstance) {
              */
             public Object newInstance(Project project, Class<?> type, Object... argument) {
                 try {
-                    return newInstance.invoke(getObjects.invoke(project), argument);
+                    return newInstance.invoke(getObjects.invoke(project), type, argument);
                 } catch (IllegalAccessException e) {
                     throw new IllegalStateException(e);
                 } catch (InvocationTargetException e) {

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/AbstractByteBuddyTaskConfiguration.java
Patch:
@@ -72,7 +72,7 @@ public void execute(final Project project) {
         } else {
             project.getLogger().debug("Configuring Byte Buddy task for source set '{}' as '{}'", sourceSet.getName(), name);
             final JavaCompile compileTask = (JavaCompile) project.getTasks().getByName(sourceSet.getCompileJavaTaskName());
-            final T byteBuddyTask = project.getTasks().create(name, extension.toType());
+            final T byteBuddyTask = project.getTasks().create(name, extension.toType(), project);
             byteBuddyTask.setGroup("Byte Buddy");
             byteBuddyTask.setDescription("Transforms the classes compiled by " + compileTask.getName());
             byteBuddyTask.dependsOn(compileTask);

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/ByteBuddySimpleTaskConfiguration.java
Patch:
@@ -39,6 +39,7 @@ public ByteBuddySimpleTaskConfiguration(String name, SourceSet sourceSet) {
     }
 
     @Override
+    @SuppressWarnings("deprecation")
     protected void configureDirectories(SourceDirectorySet source, JavaCompile compileTask, ByteBuddySimpleTask byteBuddyTask) {
         try {
             File raw = new File(compileTask.getDestinationDir(), RAW_FOLDER).getCanonicalFile(), processed = compileTask.getDestinationDir();

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/Transformation.java
Patch:
@@ -156,7 +156,7 @@ protected Class<? extends Plugin> toPlugin(ClassLoader classLoader) {
                 }
                 return type;
             } catch (ClassNotFoundException e) {
-                throw new GradleException("Cannot find plugin class " + pluginName + " by its name", e);
+                throw new GradleException("Cannot locate plugin class " + pluginName + " by its name", e);
             }
         } else {
             throw new GradleException("No plugin or plugin name defined for transformation");

File: byte-buddy-gradle-plugin/src/test/java/net/bytebuddy/build/gradle/ByteBuddyPluginTest.java
Patch:
@@ -16,9 +16,7 @@
 import org.junit.rules.MethodRule;
 
 import java.io.*;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import java.util.jar.JarEntry;
 import java.util.jar.JarInputStream;

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/ByteBuddyMojo.java
Patch:
@@ -367,7 +367,7 @@ private Plugin.Engine.Summary apply(File root,
                     throw new MojoExecutionException("Cannot resolve plugin: " + plugin, throwable);
                 }
             }
-            EntryPoint entryPoint = (initialization == null ? Initialization.makeDefault() : initialization).getEntryPoint(classLoaderResolver,
+            EntryPoint entryPoint = (initialization == null ? new Initialization() : initialization).getEntryPoint(classLoaderResolver,
                     project.getGroupId(),
                     project.getArtifactId(),
                     project.getVersion(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberSubstitution.java
Patch:
@@ -1399,14 +1399,14 @@ public StackManipulation resolve(TypeDescription targetType,
                 stackManipulations.add(DefaultValue.of(result));
                 TypeDescription.Generic current = result;
                 for (Step step : steps) {
-                    Step.Resolution resulution = step.resolve(targetType,
+                    Step.Resolution resolution = step.resolve(targetType,
                             target,
                             parameters,
                             current,
                             offsets,
                             freeOffset);
-                    stackManipulations.add(resulution.getStackManipulation());
-                    current = resulution.getResultType();
+                    stackManipulations.add(resolution.getStackManipulation());
+                    current = resolution.getResultType();
                 }
                 stackManipulations.add(assigner.assign(current, result, typing));
                 return new StackManipulation.Compound(stackManipulations);

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -1324,7 +1324,9 @@ public String resolve() {
             }
 
             /**
-             * A process provider for a legacy VM that reads the process id from its JMX properties.
+             * A process provider for a legacy VM that reads the process id from its JMX properties. This strategy
+             * is only used prior to Java 9 such that the <i>java.management</i> module never is resolved, even if
+             * the module system is used, as the module system was not available in any relevant JVM version.
              */
             protected enum ForLegacyVm implements ProcessProvider {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/GraalImageCode.java
Patch:
@@ -161,7 +161,7 @@ public boolean isNativeImageExecution() {
     }
 
     /**
-     * A privileged action to resolve the image code via
+     * A privileged action to resolve the image code via the current JVM processes input arguments, if available.
      */
     protected enum ImageCodeContextAction implements PrivilegedAction<GraalImageCode> {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/GraalImageCode.java
Patch:
@@ -25,6 +25,7 @@
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.List;
+import java.util.Locale;
 
 /**
  * A utility that resolves Graal VM native image properties.
@@ -68,14 +69,14 @@ public enum GraalImageCode {
      *
      * @return The status of the Graal image code.
      */
-    @SuppressFBWarnings(value = "LI_LAZY_INIT_STATIC", justification = "This behaviour is intended to avoid early binding in native images.")
+    @SuppressFBWarnings(value = {"LI_LAZY_INIT_STATIC", "NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE"}, justification = "This behaviour is intended to avoid early binding in native images.")
     public static GraalImageCode getCurrent() {
         GraalImageCode current = GraalImageCode.current;
         if (current == null) {
             String value = doPrivileged(new GetSystemPropertyAction("org.graalvm.nativeimage.imagecode"));
             if (value == null) {
                 String vendor = doPrivileged(new GetSystemPropertyAction("java.vm.vendor"));
-                current = vendor != null && vendor.toLowerCase().contains("graalvm")
+                current = vendor != null && vendor.toLowerCase(Locale.US).contains("graalvm")
                         ? doPrivileged(ImageCodeContextAction.INSTANCE)
                         : GraalImageCode.NONE;
             } else if (value.equalsIgnoreCase("agent")) {

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -1336,6 +1336,7 @@ protected enum ForLegacyVm implements ProcessProvider {
                 /**
                  * {@inheritDoc}
                  */
+                @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but trigger a fallback.")
                 public String resolve() {
                     String runtimeName;
                     try {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AbstractAnnotationDescriptionTest.java
Patch:
@@ -223,7 +223,9 @@ public void assertToString() throws Exception {
     }
 
     private void assertToString(String toString, Annotation actual) throws Exception {
-        String prefix = "@" + actual.annotationType().getName() + "(";
+        String prefix = "@" + (ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V19)
+                ? actual.annotationType().getCanonicalName()
+                : actual.annotationType().getName()) + "(";
         assertThat(toString, startsWith(prefix));
         assertThat(toString, endsWith(")"));
         String actualString = actual.toString();

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -6141,9 +6141,7 @@ public Unloaded(TypeDescription typeDescription,
              * {@inheritDoc}
              */
             public DynamicType.Loaded<T> load(@MaybeNull ClassLoader classLoader) {
-                if (GraalImageCode.getCurrent().isNativeImageExecution()) {
-                    return load(classLoader, ClassLoadingStrategy.ForPreloadedTypes.INSTANCE);
-                } else if (classLoader instanceof InjectionClassLoader && !((InjectionClassLoader) classLoader).isSealed()) {
+                if (classLoader instanceof InjectionClassLoader && !((InjectionClassLoader) classLoader).isSealed()) {
                     return load((InjectionClassLoader) classLoader, InjectionClassLoader.Strategy.INSTANCE);
                 } else {
                     return load(classLoader, ClassLoadingStrategy.Default.WRAPPER);

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberSubstitution.java
Patch:
@@ -1415,7 +1415,7 @@ public StackManipulation resolve(TypeDescription targetType,
             /**
              * Represents a step of a substitution chain.
              */
-            protected interface Step {
+            public interface Step {
 
                 /**
                  * Resolves this step of a substitution chain.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/HasSuperTypeMatcher.java
Patch:
@@ -21,7 +21,6 @@
 import net.bytebuddy.utility.QueueFactory;
 
 import java.util.HashSet;
-import java.util.LinkedList;
 import java.util.Queue;
 import java.util.Set;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -6368,7 +6368,7 @@ protected WithPreservedArguments(TypeDescription instrumentedType,
                 }
 
                 @Override
-                @SuppressFBWarnings(value = "RC_REF_COMPARISON_BAD_PRACTICE", justification = "ASM models frames by reference comparison.")
+                @SuppressFBWarnings(value = "RC_REF_COMPARISON_BAD_PRACTICE", justification = "ASM models frames by reference identity.")
                 protected void translateFrame(MethodVisitor methodVisitor,
                                               TranslationMode translationMode,
                                               MethodDescription methodDescription,
@@ -6628,7 +6628,7 @@ public void injectStartFrame(MethodVisitor methodVisitor) {
                     /**
                      * {@inheritDoc}
                      */
-                    @SuppressFBWarnings(value = "RC_REF_COMPARISON_BAD_PRACTICE", justification = "Reference equality is required by ASM.")
+                    @SuppressFBWarnings(value = "RC_REF_COMPARISON_BAD_PRACTICE", justification = "ASM models frames by reference identity.")
                     public void translateFrame(MethodVisitor methodVisitor,
                                                int type,
                                                int localVariableLength,

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/StackAwareMethodVisitor.java
Patch:
@@ -445,6 +445,7 @@ public void visitTryCatchBlock(Label start, Label end, Label handler, @MaybeNull
     }
 
     @Override
+    @SuppressFBWarnings(value = "RC_REF_COMPARISON_BAD_PRACTICE", justification = "ASM models frames by reference identity.")
     public void visitFrame(int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
         switch (type) {
             case Opcodes.F_SAME:

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AbstractAnnotationDescriptionTest.java
Patch:
@@ -785,7 +785,6 @@ public void testIsSupportedOn() throws Exception {
         for (ElementType elementType : ElementType.values()) {
             assertThat(describe(first).isSupportedOn(elementType), is(!elementType.name().equals("TYPE_PARAMETER")));
         }
-        assertThat(describe(explicitTarget).isSupportedOn((ElementType) null), is(true));
         assertThat(describe(explicitTarget).isSupportedOn(ElementType.TYPE), is(true));
         assertThat(describe(explicitTarget).isSupportedOn(ElementType.ANNOTATION_TYPE), is(false));
         assertThat(describe(explicitTarget).isSupportedOn(ElementType.TYPE.name()), is(true));

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -8870,6 +8870,7 @@ protected static class LambdaInstanceFactory {
             /**
              * A type-safe constant to express that a class is not already loaded when applying a class file transformer.
              */
+            @Nullable
             private static final Class<?> NOT_PREVIOUSLY_DEFINED = null;
 
             /**

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/ClassByImplementationBenchmark.java
Patch:
@@ -474,7 +474,8 @@ public ExampleInterface benchmarkJdkProxy() throws Exception {
         return (ExampleInterface) Proxy.newProxyInstance(newClassLoader(),
                 new Class<?>[]{baseClass},
                 new InvocationHandler() {
-                    public Object invoke(Object proxy, Method method, Object[] args) {
+                    @Nullable
+                    public Object invoke(Object proxy, Method method, @Nullable Object[] argument) {
                         Class<?> returnType = method.getReturnType();
                         if (returnType.isPrimitive()) {
                             if (returnType == boolean.class) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -276,7 +276,7 @@ public static <S extends Annotation> S of(@Nullable ClassLoader classLoader,
         /**
          * {@inheritDoc}
          */
-        public Object invoke(Object proxy, Method method, Object[] argument) {
+        public Object invoke(Object proxy, Method method, @Nullable Object[] argument) {
             if (method.getDeclaringClass() != annotationType) {
                 if (method.getName().equals(HASH_CODE)) {
                     return hashCodeRepresentation();

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationValue.java
Patch:
@@ -2443,7 +2443,7 @@ public boolean equals(Object other) {
             }
             AnnotationValue<?, ?> annotationValue = (AnnotationValue<?, ?>) other;
             Object value = annotationValue.resolve();
-            if (value == null || !value.getClass().isArray()) {
+            if (!value.getClass().isArray()) {
                 return false;
             }
             if (values.size() != Array.getLength(value)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -430,6 +430,7 @@ protected interface Executable {
                  * @param value The {@code java.lang.reflect.Executable} to resolve.
                  * @return An instance of {@code java.lang.reflect.AnnotatedType} that represents the receiver of the supplied executable.
                  */
+                @Nullable
                 @JavaDispatcher.Defaults
                 AnnotatedElement getAnnotatedReceiverType(Object value);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -4866,7 +4866,7 @@ protected FieldDefinitionAdapter(FieldDescription.Token token) {
                      */
                     protected FieldDefinitionAdapter(FieldAttributeAppender.Factory fieldAttributeAppenderFactory,
                                                      Transformer<FieldDescription> transformer,
-                                                     Object defaultValue,
+                                                     @Nullable Object defaultValue,
                                                      FieldDescription.Token token) {
                         super(fieldAttributeAppenderFactory, transformer, defaultValue);
                         this.token = token;
@@ -4944,7 +4944,7 @@ protected FieldMatchAdapter(LatentMatcher<? super FieldDescription> matcher) {
                      */
                     protected FieldMatchAdapter(FieldAttributeAppender.Factory fieldAttributeAppenderFactory,
                                                 Transformer<FieldDescription> transformer,
-                                                Object defaultValue,
+                                                @Nullable Object defaultValue,
                                                 LatentMatcher<? super FieldDescription> matcher) {
                         super(fieldAttributeAppenderFactory, transformer, defaultValue);
                         this.matcher = matcher;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategy.java
Patch:
@@ -233,6 +233,9 @@ private InjectionDispatcher(@Nullable ProtectionDomain protectionDomain,
              * {@inheritDoc}
              */
             public Map<TypeDescription, Class<?>> load(@Nullable ClassLoader classLoader, Map<TypeDescription, byte[]> types) {
+                if (classLoader == null) {
+                    throw new IllegalArgumentException("Cannot inject classes into the bootstrap class loader");
+                }
                 return new ClassInjector.UsingReflection(classLoader,
                         protectionDomain,
                         packageDefinitionStrategy,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1751,6 +1751,7 @@ abstract class Default<S> implements TypeWriter<S> {
         /**
          * A folder for dumping class files or {@code null} if no dump should be generated.
          */
+        @Nullable
         protected static final String DUMP_FOLDER;
 
         /*
@@ -4800,6 +4801,7 @@ protected class RedefinitionClassVisitor extends MetadataAwareClassVisitor {
                     /**
                      * A list of internal names of permitted subclasses to include.
                      */
+                    @Nullable
                     private final Set<String> permittedSubclasses;
 
                     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/MethodDelegationBinder.java
Patch:
@@ -29,6 +29,7 @@
 import net.bytebuddy.utility.CompoundList;
 import org.objectweb.asm.MethodVisitor;
 
+import javax.annotation.Nullable;
 import java.io.PrintStream;
 import java.util.*;
 
@@ -346,6 +347,7 @@ interface MethodBinding extends StackManipulation {
          * @return The target method's parameter index of this binding or {@code null} if no such argument binding
          * was applied for this binding.
          */
+        @Nullable
         Integer getTargetParameterIndex(Object parameterBindingToken);
 
         /**
@@ -541,6 +543,7 @@ public boolean isValid() {
                 /**
                  * {@inheritDoc}
                  */
+                @Nullable
                 public Integer getTargetParameterIndex(Object parameterBindingToken) {
                     return registeredTargetIndices.get(parameterBindingToken);
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/GraalImageCode.java
Patch:
@@ -92,6 +92,7 @@ public static GraalImageCode getCurrent() {
      * @param <T>    The type of the action's resolved value.
      * @return The action's resolved value.
      */
+    @Nullable
     @AccessControllerPlugin.Enhance
     private static <T> T doPrivileged(PrivilegedAction<T> action) {
         return action.run();

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaModule.java
Patch:
@@ -230,6 +230,7 @@ protected interface Resolver {
          * @param type The type for which to resolve the module.
          * @return The type's module or {@code null} if the module system is not supported.
          */
+        @Nullable
         @JavaDispatcher.Defaults
         Object getModule(Class<?> type);
     }

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/ByteBuddySimpleTask.java
Patch:
@@ -17,6 +17,8 @@
 
 import net.bytebuddy.build.Plugin;
 import net.bytebuddy.build.gradle.api.CompileClasspath;
+import net.bytebuddy.build.gradle.api.PathSensitive;
+import net.bytebuddy.build.gradle.api.PathSensitivity;
 import org.gradle.api.tasks.*;
 
 import javax.inject.Inject;
@@ -57,6 +59,7 @@ public ByteBuddySimpleTask() {
      * @return The task's source folder.
      */
     @InputDirectory
+    @PathSensitive(PathSensitivity.RELATIVE)
     public File getSource() {
         return source;
     }

File: byte-buddy-android/src/main/java/net/bytebuddy/android/AndroidClassLoadingStrategy.java
Patch:
@@ -695,7 +695,7 @@ protected interface Dispatcher {
              * @return The loaded class.
              */
             @Nullable
-            Class<?> loadClass(@Nullable dalvik.system.DexFile dexFile, @Nullable ClassLoader classLoader, TypeDescription typeDescription);
+            Class<?> loadClass(dalvik.system.DexFile dexFile, @Nullable ClassLoader classLoader, TypeDescription typeDescription);
 
             /**
              * A dispatcher for legacy VMs that allow {@link dalvik.system.DexFile#loadDex(String, String, int)}.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1794,6 +1794,9 @@ public FieldDefinition.Optional<U> value(double value) {
                          * {@inheritDoc}
                          */
                         public FieldDefinition.Optional<U> value(String value) {
+                            if (value == null) {
+                                throw new IllegalArgumentException("Cannot define 'null' as constant value");
+                            }
                             return defaultValue(value);
                         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -198,7 +198,7 @@ public UsingReflection(ClassLoader classLoader, @Nullable ProtectionDomain prote
          * @param packageDefinitionStrategy The package definer to be queried for package definitions.
          * @param forbidExisting            Determines if an exception should be thrown when attempting to load a type that already exists.
          */
-        public UsingReflection(@Nullable ClassLoader classLoader,
+        public UsingReflection(ClassLoader classLoader,
                                @Nullable ProtectionDomain protectionDomain,
                                PackageDefinitionStrategy packageDefinitionStrategy,
                                boolean forbidExisting) {

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/AbstractByteBuddyTask.java
Patch:
@@ -31,6 +31,7 @@
 import org.gradle.api.tasks.Optional;
 import org.gradle.util.ConfigureUtil;
 
+import javax.annotation.Nullable;
 import java.io.*;
 import java.net.URL;
 import java.util.*;
@@ -279,6 +280,7 @@ public void setThreads(int threads) {
      *
      * @return The class file version to use for creating auxiliary types.
      */
+    @Nullable
     @Input
     @Optional
     public ClassFileVersion getClassFileVersion() {
@@ -291,7 +293,7 @@ public ClassFileVersion getClassFileVersion() {
      *
      * @param classFileVersion The class file version to use for creating auxiliary types.
      */
-    public void setClassFileVersion(ClassFileVersion classFileVersion) {
+    public void setClassFileVersion(@Nullable ClassFileVersion classFileVersion) {
         this.classFileVersion = classFileVersion;
     }
 

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/AbstractByteBuddyTaskConfiguration.java
Patch:
@@ -24,6 +24,8 @@
 import org.gradle.api.tasks.SourceSet;
 import org.gradle.api.tasks.compile.JavaCompile;
 
+import javax.annotation.Nullable;
+
 /**
  * An abstract configuration for a Byte Buddy task and extension.
  *
@@ -228,6 +230,7 @@ protected TaskExecutionGraphClosure(Action<TaskExecutionGraph> action, TaskExecu
         /**
          * {@inheritDoc}
          */
+        @Nullable
         public Void call(Object... argument) {
             action.execute(taskExecutionGraph);
             return null;

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/Adjustment.java
Patch:
@@ -20,6 +20,7 @@
 import org.gradle.api.Task;
 import org.gradle.api.execution.TaskExecutionGraph;
 
+import javax.annotation.Nullable;
 import java.util.*;
 
 /**
@@ -173,6 +174,7 @@ protected static class CompoundIterator implements Iterator<Task> {
             /**
              * The current iterator or {@code null} if no such iterator is defined.
              */
+            @Nullable
             private Iterator<? extends Task> current;
 
             /**

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/package-info.java
Patch:
@@ -16,4 +16,7 @@
 /**
  * A package containing classes for applying Byte Buddy transformers within a Gradle build.
  */
+@NonnullByDefault
 package net.bytebuddy.build.gradle;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -11570,6 +11570,7 @@ public ExecutingTransformer(ByteBuddy byteBuddy,
              *
              * @return The current access control context or {@code null} if the current VM does not support it.
              */
+            @Nullable
             @AccessControllerPlugin.Enhance
             private static Object getContext() {
                 return null;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -22,7 +22,6 @@
 import net.bytebuddy.description.NamedElement;
 import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.annotation.AnnotationList;
-import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.matcher.ElementMatcher;
 import org.objectweb.asm.Opcodes;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoader.java
Patch:
@@ -142,6 +142,7 @@ private static <T> T doPrivileged(PrivilegedAction<T> action) {
     /**
      * The access control context to use for loading classes or {@code null} if this is not supported on the current VM.
      */
+    @Nullable
     protected final Object accessControlContext;
 
     /**
@@ -410,6 +411,7 @@ protected Class<?> findClass(String name) throws ClassNotFoundException {
     /**
      * {@inheritDoc}
      */
+    @Nullable
     protected URL findResource(String name) {
         return persistenceHandler.url(name, typeDefinitions);
     }
@@ -430,6 +432,7 @@ protected Enumeration<URL> findResources(String name) {
      * @param name The name of the package.
      * @return A suitable package or {@code null} if no such package exists.
      */
+    @Nullable
     @SuppressWarnings("deprecation")
     private Package doGetPackage(String name) {
         return getPackage(name);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -527,8 +527,8 @@ protected ClassRedefinitionTransformer(Map<Class<?>, ClassDefinition> redefinedC
             /**
              * {@inheritDoc}
              */
-            @SuppressFBWarnings(value = "EI_EXPOSE_REP", justification = "Value is always null")
             @Nullable
+            @SuppressFBWarnings(value = "EI_EXPOSE_REP", justification = "Value is always null")
             public byte[] transform(@Nullable ClassLoader classLoader,
                                     @Nullable String internalTypeName,
                                     @Nullable Class<?> classBeingRedefined,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/LoadedTypeInitializer.java
Patch:
@@ -130,6 +130,7 @@ public ForStaticField(String fieldName, Object value) {
          *
          * @return The current access control context or {@code null} if the current VM does not support it.
          */
+        @Nullable
         @AccessControllerPlugin.Enhance
         private static Object getContext() {
             return null;

File: byte-buddy-dep/src/main/java/net/bytebuddy/package-info.java
Patch:
@@ -28,4 +28,7 @@
  * creates a subclass of the {@link java.lang.Object} class which implements the {@link java.io.Serializable}
  * interface. The {@link java.lang.Object#toString()} method is overridden to return {@code Hello World!}.
  */
+@NonnullByDefault
 package net.bytebuddy;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/StreamDrainer.java
Patch:
@@ -83,7 +83,7 @@ public byte[] drain(InputStream inputStream) throws IOException {
         int currentRead;
         do {
             currentRead = inputStream.read(currentArray, currentIndex, bufferSize - currentIndex);
-            currentIndex += currentRead > 0 ? currentRead : 0;
+            currentIndex += Math.max(currentRead, 0);
             if (currentIndex == bufferSize) {
                 previousBytes.add(currentArray);
                 currentArray = new byte[bufferSize];

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/Initialization.java
Patch:
@@ -19,6 +19,8 @@
 import net.bytebuddy.build.EntryPoint;
 import org.apache.maven.plugin.MojoExecutionException;
 
+import javax.annotation.Nullable;
+
 /**
  * Defines a configuration for a Maven build's type transformation.
  */
@@ -28,6 +30,7 @@ public class Initialization extends CoordinateConfiguration {
     /**
      * The fully-qualified name of the entry point or any constant name of {@link EntryPoint.Default}.
      */
+    @Nullable
     public String entryPoint;
 
     /**

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/Transformation.java
Patch:
@@ -19,6 +19,7 @@
 import net.bytebuddy.build.Plugin;
 import org.apache.maven.plugin.MojoExecutionException;
 
+import javax.annotation.Nullable;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -32,11 +33,13 @@ public class Transformation extends CoordinateConfiguration {
     /**
      * The fully-qualified name of the plugin type.
      */
+    @Nullable
     public String plugin;
 
     /**
      * A list of arguments that are provided to the plugin for construction.
      */
+    @Nullable
     public List<PluginArgument> arguments;
 
     /**

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/package-info.java
Patch:
@@ -16,4 +16,7 @@
 /**
  * A package containing classes for applying Byte Buddy transformers within a Maven build.
  */
+@NonnullByDefault
 package net.bytebuddy.build.maven;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassFilePostProcessor.java
Patch:
@@ -70,7 +70,7 @@ class ForClassFileTransformer implements ClassFilePostProcessor {
         /**
          * A protection domain that represents all permissions.
          */
-        private static final ProtectionDomain ALL_PRIVILEGES = new ProtectionDomain(null, new AllPermissionsCollection());
+        protected static final ProtectionDomain ALL_PRIVILEGES = new ProtectionDomain(null, new AllPermissionsCollection());
 
         /**
          * Indicates that a class is not currently loaded.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -1987,7 +1987,6 @@ public MethodDescription.InDefinedShape getEnclosingMethod() {
          * {@inheritDoc}
          */
         @Nullable
-        @Nullable
         public String getGenericSignature() {
             // Embrace use of native generic signature by direct delegation.
             return typeDescription.getGenericSignature();

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassFilePostProcessorTest.java
Patch:
@@ -30,14 +30,14 @@ public void testNoOpPostProcessor() throws Exception {
 
     @Test
     public void testClassFileTransformerPostProcessor() throws Exception {
-        when(classFileTransformer.transform(null, "foo/Bar", null, null, new byte[]{1, 2, 3})).thenReturn(new byte[]{4, 5, 6});
+        when(classFileTransformer.transform(null, "foo/Bar", null, ClassFilePostProcessor.ForClassFileTransformer.ALL_PRIVILEGES, new byte[]{1, 2, 3})).thenReturn(new byte[]{4, 5, 6});
         byte[] transformed = new ClassFilePostProcessor.ForClassFileTransformer(classFileTransformer).transform(null, "foo.Bar", null, new byte[]{1, 2, 3});
         assertThat(Arrays.equals(transformed, new byte[]{4, 5, 6}), is(true));
     }
 
     @Test(expected = IllegalStateException.class)
     public void testClassFileTransformerPostProcessorWithException() throws Exception {
-        when(classFileTransformer.transform(null, "foo/Bar", null, null, new byte[]{1, 2, 3})).thenThrow(new IllegalClassFormatException());
+        when(classFileTransformer.transform(null, "foo/Bar", null, ClassFilePostProcessor.ForClassFileTransformer.ALL_PRIVILEGES, new byte[]{1, 2, 3})).thenThrow(new IllegalClassFormatException());
         new ClassFilePostProcessor.ForClassFileTransformer(classFileTransformer).transform(null, "foo.Bar", null, new byte[]{1, 2, 3});
     }
-}
\ No newline at end of file
+}

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/package-info.java
Patch:
@@ -19,4 +19,7 @@
  * but offers higher-level APIs in order to allow for the implementation of very readable transformations using
  * {@link net.bytebuddy.ByteBuddy}.
  */
+@NonnullByDefault
 package net.bytebuddy.agent.builder;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/package-info.java
Patch:
@@ -16,4 +16,7 @@
 /**
  * The ASM package contains classes that are meant for direct interaction with the ASM API.
  */
+@NonnullByDefault
 package net.bytebuddy.asm;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/AccessControllerPlugin.java
Patch:
@@ -33,6 +33,7 @@
 import net.bytebuddy.utility.OpenedClassReader;
 import org.objectweb.asm.*;
 
+import javax.annotation.Nullable;
 import java.lang.annotation.*;
 import java.security.Permission;
 import java.security.PrivilegedAction;
@@ -162,6 +163,7 @@ public class AccessControllerPlugin extends Plugin.ForElementMatcher implements
      * The property to control if the access controller should be used even
      * if available or {@code null} if such a property should not be available.
      */
+    @Nullable
     @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
     private final String property;
 
@@ -180,7 +182,7 @@ public AccessControllerPlugin() {
      *                 if available or {@code null} if such a property should not be available.
      */
     @UsingReflection.Priority(Integer.MAX_VALUE)
-    public AccessControllerPlugin(String property) {
+    public AccessControllerPlugin(@Nullable String property) {
         super(declaresMethod(isAnnotatedWith(Enhance.class)));
         this.property = property;
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/Plugin.java
Patch:
@@ -504,6 +504,7 @@ class Resolved implements Resolution {
                         /**
                          * The resolved argument which might be {@code null}.
                          */
+                        @Nullable
                         @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
                         private final Object argument;
 
@@ -512,7 +513,7 @@ class Resolved implements Resolution {
                          *
                          * @param argument The resolved argument which might be {@code null}.
                          */
-                        public Resolved(Object argument) {
+                        public Resolved(@Nullable Object argument) {
                             this.argument = argument;
                         }
 
@@ -526,6 +527,7 @@ public boolean isResolved() {
                         /**
                          * {@inheritDoc}
                          */
+                        @Nullable
                         public Object getArgument() {
                             return argument;
                         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/package-info.java
Patch:
@@ -16,4 +16,7 @@
 /**
  * A package for types that allow for applying Byte Buddy transformation during a build process.
  */
+@NonnullByDefault
 package net.bytebuddy.build;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/package-info.java
Patch:
@@ -16,4 +16,7 @@
 /**
  * Contains descriptions of annotations and annotation values.
  */
+@NonnullByDefault
 package net.bytebuddy.description.annotation;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/enumeration/package-info.java
Patch:
@@ -16,4 +16,7 @@
 /**
  * A package that contains classes for describing enumeration values.
  */
+@NonnullByDefault
 package net.bytebuddy.description.enumeration;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/package-info.java
Patch:
@@ -16,4 +16,7 @@
 /**
  * Contains descriptions of Java fields.
  */
+@NonnullByDefault
 package net.bytebuddy.description.field;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/package-info.java
Patch:
@@ -16,4 +16,7 @@
 /**
  * Contains descriptions of Java methods and constructors as well as their parameters.
  */
+@NonnullByDefault
 package net.bytebuddy.description.method;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/package-info.java
Patch:
@@ -16,4 +16,7 @@
 /**
  * The modifier package contains high-level and type-safe descriptions of Java modifiers.
  */
+@NonnullByDefault
 package net.bytebuddy.description.modifier;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/package-info.java
Patch:
@@ -18,4 +18,7 @@
  * reflection API, it would be required to load classes but by using these descriptions, it is possible to
  * represent byte code elements without prior loading.
  */
+@NonnullByDefault
 package net.bytebuddy.description;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/package-info.java
Patch:
@@ -16,4 +16,7 @@
 /**
  * Contains descriptions of Java types and packages.
  */
+@NonnullByDefault
 package net.bytebuddy.description.type;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1830,6 +1830,7 @@ private abstract static class Adapter<V> extends Optional.Valuable.AbstractBase<
                             /**
                              * The field's default value or {@code null} if no value is to be defined.
                              */
+                            @Nullable
                             @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
                             protected final Object defaultValue;
 
@@ -1842,7 +1843,7 @@ private abstract static class Adapter<V> extends Optional.Valuable.AbstractBase<
                              */
                             protected Adapter(FieldAttributeAppender.Factory fieldAttributeAppenderFactory,
                                               Transformer<FieldDescription> transformer,
-                                              Object defaultValue) {
+                                              @Nullable Object defaultValue) {
                                 this.fieldAttributeAppenderFactory = fieldAttributeAppenderFactory;
                                 this.transformer = transformer;
                                 this.defaultValue = defaultValue;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -22,6 +22,7 @@
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.utility.dispatcher.JavaDispatcher;
 
+import javax.annotation.Nullable;
 import java.io.File;
 import java.io.IOException;
 import java.lang.instrument.ClassDefinition;
@@ -215,7 +216,7 @@ public static ClassReloadingStrategy fromInstalledAgent(Strategy strategy) {
     /**
      * {@inheritDoc}
      */
-    public Map<TypeDescription, Class<?>> load(ClassLoader classLoader, Map<TypeDescription, byte[]> types) {
+    public Map<TypeDescription, Class<?>> load(@Nullable ClassLoader classLoader, Map<TypeDescription, byte[]> types) {
         Map<String, Class<?>> availableTypes = new HashMap<String, Class<?>>(preregisteredTypes);
         for (Class<?> type : instrumentation.getInitiatedClasses(classLoader)) {
             availableTypes.put(TypeDescription.ForLoadedType.getName(type), type);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/InjectionClassLoader.java
Patch:
@@ -18,6 +18,7 @@
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.description.type.TypeDescription;
 
+import javax.annotation.Nullable;
 import java.lang.reflect.Method;
 import java.util.Collections;
 import java.util.HashMap;
@@ -67,7 +68,7 @@ private static void doRegisterAsParallelCapable() {
      * @param parent The class loader's parent.
      * @param sealed Indicates if this class loader is sealed, i.e. forbids runtime injection.
      */
-    protected InjectionClassLoader(ClassLoader parent, boolean sealed) {
+    protected InjectionClassLoader(@Nullable ClassLoader parent, boolean sealed) {
         super(parent);
         this.sealed = new AtomicBoolean(sealed);
     }
@@ -138,7 +139,7 @@ public enum Strategy implements ClassLoadingStrategy<InjectionClassLoader> {
         /**
          * {@inheritDoc}
          */
-        public Map<TypeDescription, Class<?>> load(InjectionClassLoader classLoader, Map<TypeDescription, byte[]> types) {
+        public Map<TypeDescription, Class<?>> load(@Nullable InjectionClassLoader classLoader, Map<TypeDescription, byte[]> types) {
             if (classLoader == null) {
                 throw new IllegalArgumentException("Cannot add types to bootstrap class loader: " + types);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/package-info.java
Patch:
@@ -17,4 +17,7 @@
  * This package contains classes that are responsible for class loading of classes that are represented by
  * {@code byte} arrays.
  */
+@NonnullByDefault
 package net.bytebuddy.dynamic.loading;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/package-info.java
Patch:
@@ -17,4 +17,7 @@
  * This package contains classes and interfaces that are connected to writing the byte stream that represents a Java
  * type that is dynamically created and for loading this type into a running JVM process.
  */
+@NonnullByDefault
 package net.bytebuddy.dynamic;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/package-info.java
Patch:
@@ -17,4 +17,7 @@
  * All classes and types in this package are related to creating a {@link net.bytebuddy.dynamic.DynamicType} by
  * enhancing a given type.
  */
+@NonnullByDefault
 package net.bytebuddy.dynamic.scaffold.inline;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/package-info.java
Patch:
@@ -18,4 +18,7 @@
  * representing a Java class. These utilities allow to write a Java type in a more modular manner and take away
  * complexity from the actual implementations of {@link net.bytebuddy.dynamic.DynamicType.Builder}.
  */
+@NonnullByDefault
 package net.bytebuddy.dynamic.scaffold;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/package-info.java
Patch:
@@ -17,4 +17,7 @@
  * All classes and types in this package are related to creating a {@link net.bytebuddy.dynamic.DynamicType} by
  * creating a subclass of a given type.
  */
+@NonnullByDefault
 package net.bytebuddy.dynamic.scaffold.subclass;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/package-info.java
Patch:
@@ -18,4 +18,7 @@
  * i.e. fields, types and byte code methods. A common Java attribute is a Java annotation which are represented by
  * the {@link java.lang.annotation.Annotation} interface.
  */
+@NonnullByDefault
 package net.bytebuddy.implementation.attribute;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/package-info.java
Patch:
@@ -18,4 +18,7 @@
  * {@link net.bytebuddy.dynamic.scaffold.InstrumentedType}. A typical use case for auxiliary types is granting
  * access to {@code super} invocations of method calls.
  */
+@NonnullByDefault
 package net.bytebuddy.implementation.auxiliary;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/package-info.java
Patch:
@@ -17,4 +17,7 @@
  * This package contains annotations, types and classes that are responsible for binding a method to calling another
  * method by interpreting annotations that indicate how a method should be bound to another method.
  */
+@NonnullByDefault
 package net.bytebuddy.implementation.bind.annotation;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/package-info.java
Patch:
@@ -16,4 +16,7 @@
 /**
  * The types and classes of this package are responsible for binding a method call to calling another method.
  */
+@NonnullByDefault
 package net.bytebuddy.implementation.bind;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/package-info.java
Patch:
@@ -18,4 +18,7 @@
  * a given {@link net.bytebuddy.description.type.TypeDescription} into another one. In doing so, an assigner is also
  * able to determine that some assignment is illegal.
  */
+@NonnullByDefault
 package net.bytebuddy.implementation.bytecode.assign;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/package-info.java
Patch:
@@ -18,4 +18,7 @@
  * are capable of handling primitive types or the {@code void} type. On assignments from or to reference types,
  * these assigners usually delegate a boxed assignment to a reference aware assigner.
  */
+@NonnullByDefault
 package net.bytebuddy.implementation.bytecode.assign.primitive;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/reference/package-info.java
Patch:
@@ -17,4 +17,7 @@
  * {@link net.bytebuddy.implementation.bytecode.assign.Assigner} implementations of this package
  * are capable of assigning non-primitive types to each other.
  */
+@NonnullByDefault
 package net.bytebuddy.implementation.bytecode.assign.reference;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/collection/package-info.java
Patch:
@@ -17,4 +17,7 @@
  * This package is dedicated to creating {@link net.bytebuddy.implementation.bytecode.StackManipulation}s
  * that create collections or arrays from a given number of values.
  */
+@NonnullByDefault
 package net.bytebuddy.implementation.bytecode.collection;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/package-info.java
Patch:
@@ -17,4 +17,7 @@
  * {@link net.bytebuddy.implementation.bytecode.StackManipulation}s in this package are responsible for
  * creating compile-time constants and pushing them onto the operand stack.
  */
+@NonnullByDefault
 package net.bytebuddy.implementation.bytecode.constant;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/package-info.java
Patch:
@@ -18,4 +18,7 @@
  * accessing type or method members, i.e. reading and writing of fields, invoking of methods, access of local variables
  * within a method invocation or returning values from method invocations.
  */
+@NonnullByDefault
 package net.bytebuddy.implementation.bytecode.member;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/package-info.java
Patch:
@@ -17,4 +17,7 @@
  * Types and classes in this package are responsible for creating Java byte code for a given byte code target
  * which is represented by a {@link net.bytebuddy.description.method.MethodDescription}.
  */
+@NonnullByDefault
 package net.bytebuddy.implementation.bytecode;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/package-info.java
Patch:
@@ -16,4 +16,7 @@
 /**
  * The implementation package contains any logic for intercepting method calls.
  */
+@NonnullByDefault
 package net.bytebuddy.implementation;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/package-info.java
Patch:
@@ -16,4 +16,7 @@
 /**
  * Contains an API for matching Java byte code entities.
  */
+@NonnullByDefault
 package net.bytebuddy.matcher;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/package-info.java
Patch:
@@ -17,4 +17,7 @@
  * Classes of this package allow for the creating {@link net.bytebuddy.description.type.TypeDescription}s without
  * loading any classes.
  */
+@NonnullByDefault
 package net.bytebuddy.pool;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/Invoker.java
Patch:
@@ -15,6 +15,7 @@
  */
 package net.bytebuddy.utility;
 
+import javax.annotation.Nullable;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -50,5 +51,6 @@ public interface Invoker {
      * @throws IllegalAccessException    If the method is accessed illegally.
      * @throws InvocationTargetException If the invocation causes an error.
      */
-    Object invoke(Method method, Object instance, Object[] argument) throws IllegalAccessException, InvocationTargetException;
+    @Nullable
+    Object invoke(Method method, @Nullable Object instance, Object[] argument) throws IllegalAccessException, InvocationTargetException;
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/dispatcher/package-info.java
Patch:
@@ -19,4 +19,7 @@
  * This way, external users cannot emulate Byte Buddy's privilege when caller sensitive code
  * would be proxied.
  */
+@NonnullByDefault
 package net.bytebuddy.utility.dispatcher;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/package-info.java
Patch:
@@ -16,4 +16,5 @@
 /**
  * This package contains utility classes for common use within any Byte Buddy logic.
  */
+@NonnullByDefault
 package net.bytebuddy.utility;

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/privilege/package-info.java
Patch:
@@ -16,4 +16,7 @@
 /**
  * A package containing {@link java.security.PrivilegedAction}s that are used for invoking sensitive methods.
  */
+@NonnullByDefault
 package net.bytebuddy.utility.privilege;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/package-info.java
Patch:
@@ -16,4 +16,7 @@
 /**
  * A package containing visitor classes for ASM.
  */
+@NonnullByDefault
 package net.bytebuddy.utility.visitor;
+
+import net.bytebuddy.utility.NonnullByDefault;

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -4267,7 +4267,7 @@ public Generic resolveRecordType(String recordTypeDescriptor,
                                                              TypePool typePool,
                                                              Map<String, List<AnnotationToken>> annotationTokens,
                                                              RecordComponentDescription definingRecordComponent) {
-                                return TokenizedGenericType.of(typePool, recordComponentTypeToken, recordTypeDescriptor, annotationTokens, TypeVariableSource.UNDEFINED);
+                                return TokenizedGenericType.of(typePool, recordComponentTypeToken, recordTypeDescriptor, annotationTokens, definingRecordComponent.getDeclaringType().asErasure());
                             }
                         }
                     }

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/api/PathSensitivity.java
Patch:
@@ -15,8 +15,6 @@
  */
 package net.bytebuddy.build.gradle.api;
 
-import org.gradle.api.Transformer;
-
 /**
  * A placeholder representation of Gradle's {@code org.gradle.api.tasks.PathSensitivity} type.
  */

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/ModifierAdjustment.java
Patch:
@@ -31,6 +31,7 @@
 import org.objectweb.asm.FieldVisitor;
 import org.objectweb.asm.MethodVisitor;
 
+import javax.annotation.Nullable;
 import java.util.*;
 
 import static net.bytebuddy.matcher.ElementMatchers.*;
@@ -372,7 +373,7 @@ protected Adjustment(ElementMatcher<? super T> matcher, ModifierContributor.Reso
         /**
          * {@inheritDoc}
          */
-        public boolean matches(T target) {
+        public boolean matches(@Nullable T target) {
             return matcher.matches(target);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/Plugin.java
Patch:
@@ -29,6 +29,7 @@
 import net.bytebuddy.utility.CompoundList;
 import net.bytebuddy.utility.FileSystem;
 
+import javax.annotation.Nullable;
 import java.io.*;
 import java.lang.annotation.*;
 import java.lang.reflect.Constructor;
@@ -4765,7 +4766,7 @@ protected ForElementMatcher(ElementMatcher<? super TypeDescription> matcher) {
         /**
          * {@inheritDoc}
          */
-        public boolean matches(TypeDescription target) {
+        public boolean matches(@Nullable TypeDescription target) {
             return matcher.matches(target);
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/ToStringPlugin.java
Patch:
@@ -25,6 +25,7 @@
 import net.bytebuddy.implementation.ToStringMethod;
 import net.bytebuddy.matcher.ElementMatchers;
 
+import javax.annotation.Nullable;
 import java.lang.annotation.*;
 
 import static net.bytebuddy.matcher.ElementMatchers.*;
@@ -65,8 +66,8 @@ public Plugin make() {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(TypeDescription target) {
-        return target.getDeclaredAnnotations().isAnnotationPresent(Enhance.class);
+    public boolean matches(@Nullable TypeDescription target) {
+        return target != null && target.getDeclaredAnnotations().isAnnotationPresent(Enhance.class);
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/FieldRegistry.java
Patch:
@@ -23,6 +23,7 @@
 import net.bytebuddy.matcher.ElementMatcher;
 import net.bytebuddy.matcher.LatentMatcher;
 
+import javax.annotation.Nullable;
 import java.util.*;
 
 /**
@@ -316,7 +317,7 @@ protected Record bind(TypeDescription instrumentedType, FieldDescription fieldDe
                 /**
                  * {@inheritDoc}
                  */
-                public boolean matches(FieldDescription target) {
+                public boolean matches(@Nullable FieldDescription target) {
                     return matcher.matches(target);
                 }
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/RecordComponentRegistry.java
Patch:
@@ -23,6 +23,7 @@
 import net.bytebuddy.matcher.ElementMatcher;
 import net.bytebuddy.matcher.LatentMatcher;
 
+import javax.annotation.Nullable;
 import java.util.*;
 
 /**
@@ -288,7 +289,7 @@ protected Record bind(TypeDescription instrumentedType, RecordComponentDescripti
                 /**
                  * {@inheritDoc}
                  */
-                public boolean matches(RecordComponentDescription target) {
+                public boolean matches(@Nullable RecordComponentDescription target) {
                     return matcher.matches(target);
                 }
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AccessibilityMatcher.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T>The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class AccessibilityMatcher<T extends ByteCodeElement> extends ElementMatcher.Junction.AbstractBase<T> {
+public class AccessibilityMatcher<T extends ByteCodeElement> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The type that is to be checked for its viewing rights.
@@ -44,7 +44,7 @@ public AccessibilityMatcher(TypeDescription typeDescription) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return target.isAccessibleTo(typeDescription);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AnnotationTargetMatcher.java
Patch:
@@ -26,7 +26,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class AnnotationTargetMatcher<T extends AnnotationDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class AnnotationTargetMatcher<T extends AnnotationDescription> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The targeted element type.
@@ -45,7 +45,7 @@ public AnnotationTargetMatcher(ElementType elementType) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return target.getElementTypes().contains(elementType);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AnnotationTypeMatcher.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T> The exact type of the annotation description that is matched.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class AnnotationTypeMatcher<T extends AnnotationDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class AnnotationTypeMatcher<T extends AnnotationDescription> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The type matcher to apply to an annotation's type.
@@ -44,7 +44,7 @@ public AnnotationTypeMatcher(ElementMatcher<? super TypeDescription> matcher) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.getAnnotationType());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ArrayTypeMatcher.java
Patch:
@@ -24,12 +24,12 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class ArrayTypeMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.AbstractBase<T> {
+public class ArrayTypeMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return target.isArray();
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/BooleanMatcher.java
Patch:
@@ -17,6 +17,8 @@
 
 import net.bytebuddy.build.HashCodeAndEqualsPlugin;
 
+import javax.annotation.Nullable;
+
 /**
  * An element matcher that returns a fixed result.
  *
@@ -64,7 +66,7 @@ public BooleanMatcher(boolean matches) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    public boolean matches(@Nullable T target) {
         return matches;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CachingMatcher.java
Patch:
@@ -18,6 +18,7 @@
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.build.HashCodeAndEqualsPlugin;
 
+import javax.annotation.Nullable;
 import java.util.Iterator;
 import java.util.concurrent.ConcurrentMap;
 
@@ -55,7 +56,7 @@ public CachingMatcher(ElementMatcher<? super T> matcher, ConcurrentMap<? super T
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    public boolean matches(@Nullable T target) {
         Boolean cached = map.get(target);
         if (cached == null) {
             cached = onCacheMiss(target);

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionElementMatcher.java
Patch:
@@ -26,7 +26,7 @@
  * @param <T> The type of the elements contained by the collection.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class CollectionElementMatcher<T> extends ElementMatcher.Junction.AbstractBase<Iterable<? extends T>> {
+public class CollectionElementMatcher<T> extends ElementMatcher.Junction.ForNonNullValues<Iterable<? extends T>> {
 
     /**
      * The index of the matched element.
@@ -52,7 +52,7 @@ public CollectionElementMatcher(int index, ElementMatcher<? super T> matcher) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(Iterable<? extends T> target) {
+    protected boolean doMatch(Iterable<? extends T> target) {
         Iterator<? extends T> iterator = target.iterator();
         for (int index = 0; index < this.index; index++) {
             if (iterator.hasNext()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionErasureMatcher.java
Patch:
@@ -28,7 +28,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class CollectionErasureMatcher<T extends Iterable<? extends TypeDefinition>> extends ElementMatcher.Junction.AbstractBase<T> {
+public class CollectionErasureMatcher<T extends Iterable<? extends TypeDefinition>> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The matcher to be applied to the raw types.
@@ -47,7 +47,7 @@ public CollectionErasureMatcher(ElementMatcher<? super Iterable<? extends TypeDe
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         List<TypeDescription> typeDescriptions = new ArrayList<TypeDescription>();
         for (TypeDefinition typeDefinition : target) {
             typeDescriptions.add(typeDefinition.asErasure());

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionItemMatcher.java
Patch:
@@ -24,7 +24,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class CollectionItemMatcher<T> extends ElementMatcher.Junction.AbstractBase<Iterable<? extends T>> {
+public class CollectionItemMatcher<T> extends ElementMatcher.Junction.ForNonNullValues<Iterable<? extends T>> {
 
     /**
      * The element matcher to apply to each element of a collection.
@@ -43,7 +43,7 @@ public CollectionItemMatcher(ElementMatcher<? super T> matcher) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(Iterable<? extends T> target) {
+    protected boolean doMatch(Iterable<? extends T> target) {
         for (T value : target) {
             if (matcher.matches(value)) {
                 return true;

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionOneToOneMatcher.java
Patch:
@@ -30,7 +30,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class CollectionOneToOneMatcher<T> extends ElementMatcher.Junction.AbstractBase<Iterable<? extends T>> {
+public class CollectionOneToOneMatcher<T> extends ElementMatcher.Junction.ForNonNullValues<Iterable<? extends T>> {
 
     /**
      * The list of element matchers to match any elements of the matched iterable collection against.
@@ -50,7 +50,7 @@ public CollectionOneToOneMatcher(List<? extends ElementMatcher<? super T>> match
     /**
      * {@inheritDoc}
      */
-    public boolean matches(Iterable<? extends T> target) {
+    protected boolean doMatch(Iterable<? extends T> target) {
         if ((target instanceof Collection) && ((Collection<?>) target).size() != matchers.size()) {
             return false;
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionSizeMatcher.java
Patch:
@@ -26,7 +26,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class CollectionSizeMatcher<T extends Iterable<?>> extends ElementMatcher.Junction.AbstractBase<T> {
+public class CollectionSizeMatcher<T extends Iterable<?>> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The expected size of the matched collection.
@@ -46,7 +46,7 @@ public CollectionSizeMatcher(int size) {
      * {@inheritDoc}
      */
     @SuppressFBWarnings(value = "DLS_DEAD_LOCAL_STORE", justification = "Iteration required to count size of an iterable")
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         if (target instanceof Collection) {
             return ((Collection<?>) target).size() == size;
         } else {

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringAnnotationMatcher.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T> The actual matched type of this matcher.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class DeclaringAnnotationMatcher<T extends AnnotationSource> extends ElementMatcher.Junction.AbstractBase<T> {
+public class DeclaringAnnotationMatcher<T extends AnnotationSource> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The matcher to be applied to the provided annotation list.
@@ -44,7 +44,7 @@ public DeclaringAnnotationMatcher(ElementMatcher<? super AnnotationList> matcher
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.getDeclaredAnnotations());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringFieldMatcher.java
Patch:
@@ -26,7 +26,7 @@
  * @param <T> The exact type of the annotated element that is matched.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class DeclaringFieldMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.AbstractBase<T> {
+public class DeclaringFieldMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The field matcher to apply to the declared fields of the matched type description.
@@ -45,7 +45,7 @@ public DeclaringFieldMatcher(ElementMatcher<? super FieldList<? extends FieldDes
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.getDeclaredFields());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringMethodMatcher.java
Patch:
@@ -26,7 +26,7 @@
  * @param <T> The exact type of the annotated element that is matched.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class DeclaringMethodMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.AbstractBase<T> {
+public class DeclaringMethodMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The field matcher to apply to the declared fields of the matched type description.
@@ -45,7 +45,7 @@ public DeclaringMethodMatcher(ElementMatcher<? super MethodList<? extends Method
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.getDeclaredMethods());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringTypeMatcher.java
Patch:
@@ -27,7 +27,7 @@
  * @param <T> The exact type of the element being matched.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class DeclaringTypeMatcher<T extends DeclaredByType> extends ElementMatcher.Junction.AbstractBase<T> {
+public class DeclaringTypeMatcher<T extends DeclaredByType> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The type matcher to be applied if the target element is declared in a type.
@@ -46,7 +46,7 @@ public DeclaringTypeMatcher(ElementMatcher<? super TypeDescription.Generic> matc
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         TypeDefinition declaringType = target.getDeclaringType();
         return declaringType != null && matcher.matches(declaringType.asGenericType());
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DefinedShapeMatcher.java
Patch:
@@ -26,7 +26,7 @@
  */
 @HashCodeAndEqualsPlugin.Enhance
 public class DefinedShapeMatcher<T extends ByteCodeElement.TypeDependant<S, ?>, S extends ByteCodeElement.TypeDependant<?, ?>>
-        extends ElementMatcher.Junction.AbstractBase<T> {
+        extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The matcher to apply onto the defined shape of the matched entity.
@@ -45,7 +45,7 @@ public DefinedShapeMatcher(ElementMatcher<? super S> matcher) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.asDefined());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DescriptorMatcher.java
Patch:
@@ -24,7 +24,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class DescriptorMatcher<T extends NamedElement.WithDescriptor> extends ElementMatcher.Junction.AbstractBase<T> {
+public class DescriptorMatcher<T extends NamedElement.WithDescriptor> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * A matcher to apply to the descriptor.
@@ -43,7 +43,7 @@ public DescriptorMatcher(ElementMatcher<String> matcher) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.getDescriptor());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ErasureMatcher.java
Patch:
@@ -27,7 +27,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class ErasureMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.AbstractBase<T> {
+public class ErasureMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The matcher to apply to the raw type of the matched element.
@@ -46,7 +46,7 @@ public ErasureMatcher(ElementMatcher<? super TypeDescription> matcher) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.asErasure());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/FailSafeMatcher.java
Patch:
@@ -17,6 +17,8 @@
 
 import net.bytebuddy.build.HashCodeAndEqualsPlugin;
 
+import javax.annotation.Nullable;
+
 /**
  * A fail-safe matcher catches exceptions that are thrown by a delegate matcher and returns an alternative value.
  *
@@ -49,7 +51,7 @@ public FailSafeMatcher(ElementMatcher<? super T> matcher, boolean fallback) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    public boolean matches(@Nullable T target) {
         try {
             return matcher.matches(target);
         } catch (Exception ignored) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/FieldTypeMatcher.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class FieldTypeMatcher<T extends FieldDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class FieldTypeMatcher<T extends FieldDescription> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The type matcher to apply to the field's type.
@@ -44,7 +44,7 @@ public FieldTypeMatcher(ElementMatcher<? super TypeDescription.Generic> matcher)
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.getType());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/HasSuperClassMatcher.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class HasSuperClassMatcher<T extends TypeDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class HasSuperClassMatcher<T extends TypeDescription> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The matcher to apply to any super class of the matched type.
@@ -44,7 +44,7 @@ public HasSuperClassMatcher(ElementMatcher<? super TypeDescription.Generic> matc
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         if (target.isInterface()) {
             return matcher.matches(TypeDescription.Generic.OBJECT);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/HasSuperTypeMatcher.java
Patch:
@@ -29,7 +29,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class HasSuperTypeMatcher<T extends TypeDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class HasSuperTypeMatcher<T extends TypeDescription> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The matcher to apply to any super type of the matched type.
@@ -48,7 +48,7 @@ public HasSuperTypeMatcher(ElementMatcher<? super TypeDescription.Generic> match
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         Set<TypeDescription> previous = new HashSet<TypeDescription>();
         for (TypeDefinition typeDefinition : target) {
             if (!previous.add(typeDefinition.asErasure())) { // Main type can be an interface.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/InheritedAnnotationMatcher.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T> The actual matched type of this matcher.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class InheritedAnnotationMatcher<T extends TypeDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class InheritedAnnotationMatcher<T extends TypeDescription> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The matcher to be applied to the provided annotation list.
@@ -44,7 +44,7 @@ public InheritedAnnotationMatcher(ElementMatcher<? super AnnotationList> matcher
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.getInheritedAnnotations());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/InstanceTypeMatcher.java
Patch:
@@ -24,7 +24,7 @@
  * @param <T> The exact type of the object that is matched.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class InstanceTypeMatcher<T> extends ElementMatcher.Junction.AbstractBase<T> {
+public class InstanceTypeMatcher<T> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The matcher to apply to the object's type.
@@ -43,8 +43,8 @@ public InstanceTypeMatcher(ElementMatcher<? super TypeDescription> matcher) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
-        return target != null && matcher.matches(TypeDescription.ForLoadedType.of(target.getClass()));
+    protected boolean doMatch(T target) {
+        return matcher.matches(TypeDescription.ForLoadedType.of(target.getClass()));
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/IsNamedMatcher.java
Patch:
@@ -24,12 +24,12 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class IsNamedMatcher<T extends NamedElement.WithOptionalName> extends ElementMatcher.Junction.AbstractBase<T> {
+public class IsNamedMatcher<T extends NamedElement.WithOptionalName> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return target.isNamed();
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodExceptionTypeMatcher.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class MethodExceptionTypeMatcher<T extends MethodDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class MethodExceptionTypeMatcher<T extends MethodDescription> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The matcher to apply to the matched method's exceptions.
@@ -44,7 +44,7 @@ public MethodExceptionTypeMatcher(ElementMatcher<? super TypeList.Generic> match
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.getExceptionTypes());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodOverrideMatcher.java
Patch:
@@ -32,7 +32,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class MethodOverrideMatcher<T extends MethodDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class MethodOverrideMatcher<T extends MethodDescription> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The matcher that is to be applied to the type that declares a method of the same shape.
@@ -51,7 +51,7 @@ public MethodOverrideMatcher(ElementMatcher<? super TypeDescription.Generic> mat
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         Set<TypeDescription> duplicates = new HashSet<TypeDescription>();
         for (TypeDefinition typeDefinition : target.getDeclaringType()) {
             if (matches(target, typeDefinition) || matches(target, typeDefinition.getInterfaces(), duplicates)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypeMatcher.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class MethodParameterTypeMatcher<T extends ParameterDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class MethodParameterTypeMatcher<T extends ParameterDescription> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The matcher to apply to the type of the parameter.
@@ -44,7 +44,7 @@ public MethodParameterTypeMatcher(ElementMatcher<? super TypeDescription.Generic
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.getType());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypesMatcher.java
Patch:
@@ -27,7 +27,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class MethodParameterTypesMatcher<T extends ParameterList<?>> extends ElementMatcher.Junction.AbstractBase<T> {
+public class MethodParameterTypesMatcher<T extends ParameterList<?>> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The matcher to apply to the type of the parameter.
@@ -46,7 +46,7 @@ public MethodParameterTypesMatcher(ElementMatcher<? super List<? extends TypeDes
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.asTypeList());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParametersMatcher.java
Patch:
@@ -26,7 +26,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class MethodParametersMatcher<T extends MethodDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class MethodParametersMatcher<T extends MethodDescription> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The matcher to apply to the parameters.
@@ -45,7 +45,7 @@ public MethodParametersMatcher(ElementMatcher<? super ParameterList<? extends Pa
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.getParameters());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodReturnTypeMatcher.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class MethodReturnTypeMatcher<T extends MethodDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class MethodReturnTypeMatcher<T extends MethodDescription> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The type matcher to apply to the matched element's return type.
@@ -44,7 +44,7 @@ public MethodReturnTypeMatcher(ElementMatcher<? super TypeDescription.Generic> m
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.getReturnType());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodSortMatcher.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class MethodSortMatcher<T extends MethodDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class MethodSortMatcher<T extends MethodDescription> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * Returns an element matcher that matches a specific sort of method description.
@@ -56,7 +56,7 @@ public MethodSortMatcher(Sort sort) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return sort.isSort(target);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ModifierMatcher.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class ModifierMatcher<T extends ModifierReviewable> extends ElementMatcher.Junction.AbstractBase<T> {
+public class ModifierMatcher<T extends ModifierReviewable> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * Returns a new element matcher that matches an element by its modifier.
@@ -56,7 +56,7 @@ public ModifierMatcher(Mode mode) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return (mode.getModifiers() & target.getModifiers()) != 0;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NameMatcher.java
Patch:
@@ -31,7 +31,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class NameMatcher<T extends NamedElement> extends ElementMatcher.Junction.AbstractBase<T> {
+public class NameMatcher<T extends NamedElement> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The matcher that is applied to a byte code element's source code name.
@@ -50,7 +50,7 @@ public NameMatcher(ElementMatcher<String> matcher) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.getActualName());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NegatingMatcher.java
Patch:
@@ -17,6 +17,8 @@
 
 import net.bytebuddy.build.HashCodeAndEqualsPlugin;
 
+import javax.annotation.Nullable;
+
 /**
  * An element matcher that reverses the matching result of another matcher.
  *
@@ -42,7 +44,7 @@ public NegatingMatcher(ElementMatcher<? super T> matcher) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    public boolean matches(@Nullable T target) {
         return !matcher.matches(target);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NullMatcher.java
Patch:
@@ -17,6 +17,8 @@
 
 import net.bytebuddy.build.HashCodeAndEqualsPlugin;
 
+import javax.annotation.Nullable;
+
 /**
  * An element matcher that matches the {@code null} value.
  *
@@ -44,7 +46,7 @@ public static <T> ElementMatcher.Junction<T> make() {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    public boolean matches(@Nullable T target) {
         return target == null;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/PrimitiveTypeMatcher.java
Patch:
@@ -24,12 +24,12 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class PrimitiveTypeMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.AbstractBase<T> {
+public class PrimitiveTypeMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return target.isPrimitive();
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/RecordMatcher.java
Patch:
@@ -24,12 +24,12 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class RecordMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.AbstractBase<T> {
+public class RecordMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return target.isRecord();
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SignatureTokenMatcher.java
Patch:
@@ -24,7 +24,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class SignatureTokenMatcher<T extends MethodDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class SignatureTokenMatcher<T extends MethodDescription> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The matcher to match the signature token against.
@@ -43,7 +43,7 @@ public SignatureTokenMatcher(ElementMatcher<? super MethodDescription.SignatureT
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.asSignatureToken());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/StringMatcher.java
Patch:
@@ -23,7 +23,7 @@
  * {@link net.bytebuddy.matcher.StringMatcher.Mode}.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class StringMatcher extends ElementMatcher.Junction.AbstractBase<String> {
+public class StringMatcher extends ElementMatcher.Junction.ForNonNullValues<String> {
 
     /**
      * The text value to match against.
@@ -49,7 +49,7 @@ public StringMatcher(String value, Mode mode) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(String target) {
+    protected boolean doMatch(String target) {
         return mode.matches(value, target);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SubTypeMatcher.java
Patch:
@@ -24,7 +24,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class SubTypeMatcher<T extends TypeDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class SubTypeMatcher<T extends TypeDescription> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The type to be matched being a super type of the matched type.
@@ -43,7 +43,7 @@ public SubTypeMatcher(TypeDescription typeDescription) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return target.isAssignableTo(typeDescription);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SuperTypeMatcher.java
Patch:
@@ -24,7 +24,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class SuperTypeMatcher<T extends TypeDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class SuperTypeMatcher<T extends TypeDescription> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The type to be matched being a sub type of the matched type.
@@ -43,7 +43,7 @@ public SuperTypeMatcher(TypeDescription typeDescription) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return target.isAssignableFrom(typeDescription);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/TypeSortMatcher.java
Patch:
@@ -24,7 +24,7 @@
  * @param <T> The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class TypeSortMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.AbstractBase<T> {
+public class TypeSortMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * An element matcher to be applied to the type's sort.
@@ -43,7 +43,7 @@ public TypeSortMatcher(ElementMatcher<? super TypeDefinition.Sort> matcher) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return matcher.matches(target.getSort());
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/VisibilityMatcher.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T>The type of the matched entity.
  */
 @HashCodeAndEqualsPlugin.Enhance
-public class VisibilityMatcher<T extends ByteCodeElement> extends ElementMatcher.Junction.AbstractBase<T> {
+public class VisibilityMatcher<T extends ByteCodeElement> extends ElementMatcher.Junction.ForNonNullValues<T> {
 
     /**
      * The type that is to be checked for its viewing rights.
@@ -44,7 +44,7 @@ public VisibilityMatcher(TypeDescription typeDescription) {
     /**
      * {@inheritDoc}
      */
-    public boolean matches(T target) {
+    protected boolean doMatch(T target) {
         return target.isVisibleTo(typeDescription);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeDefaultTest.java
Patch:
@@ -213,8 +213,8 @@ public void testWithAuxiliaryField() throws Exception {
         assertThat(instrumentedType.getLoadedTypeInitializer().isAlive(), is(true));
     }
 
-    @SuppressWarnings("unchecked")
     @Test(expected = IllegalStateException.class)
+    @SuppressWarnings("unchecked")
     public void testWithAuxiliaryFieldConflict() throws Exception {
         TypeDescription.Generic fieldType = mock(TypeDescription.Generic.class);
         when(fieldType.accept(Mockito.any(TypeDescription.Generic.Visitor.class))).thenReturn(fieldType);

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/AbstractByteBuddyTask.java
Patch:
@@ -417,7 +417,7 @@ protected void doApply(Plugin.Engine.Source source, Plugin.Engine.Target target)
                                 ? Plugin.Engine.ErrorHandler.Enforcing.NO_LIVE_INITIALIZERS
                                 : Plugin.Engine.Listener.NoOp.INSTANCE, isFailFast()
                                 ? Plugin.Engine.ErrorHandler.Failing.FAIL_FAST
-                                : Plugin.Engine.Listener.NoOp.INSTANCE)
+                                : Plugin.Engine.ErrorHandler.Failing.FAIL_LAST)
                         .with(getThreads() == 0
                                 ? Plugin.Engine.Dispatcher.ForSerialTransformation.Factory.INSTANCE
                                 : new Plugin.Engine.Dispatcher.ForParallelTransformation.WithThrowawayExecutorService.Factory(getThreads()))

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/AbstractByteBuddyTaskExtension.java
Patch:
@@ -118,6 +118,7 @@ protected AbstractByteBuddyTaskExtension() {
         suffix = "";
         failOnLiveInitializer = true;
         warnOnEmptyTypeSet = true;
+        failFast = true;
         discovery = Discovery.EMPTY;
         adjustment = Adjustment.FULL;
         adjustmentErrorHandler = Adjustment.ErrorHandler.WARN;

File: byte-buddy-gradle-plugin/src/test/java/net/bytebuddy/build/gradle/ByteBuddyTaskExtensionTest.java
Patch:
@@ -39,13 +39,12 @@ public void testDefaultProperties() {
         assertThat(extension.getSuffix(), is(""));
         assertThat(extension.getThreads(), is(0));
         assertThat(extension.isExtendedParsing(), is(false));
-        assertThat(extension.isFailFast(), is(false));
+        assertThat(extension.isFailFast(), is(true));
         assertThat(extension.isFailOnLiveInitializer(), is(true));
         assertThat(extension.getAdjustment(), is(Adjustment.FULL));
         assertThat(extension.getAdjustmentErrorHandler(), is(Adjustment.ErrorHandler.WARN));
         assertThat(extension.getAdjustmentPostProcessor(), is((Action<Task>) Adjustment.NoOpPostProcessor.INSTANCE));
         assertThat(extension.isWarnOnEmptyTypeSet(), is(true));
-        assertThat(extension.isFailFast(), is(false));
         assertThat(extension.isLazy(), is(false));
         assertThat(extension.getDiscovery(), is(Discovery.EMPTY));
         assertThat(extension.getClassFileVersion(), nullValue(ClassFileVersion.class));

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/ByteBuddyMojo.java
Patch:
@@ -397,7 +397,7 @@ private Plugin.Engine.Summary apply(File root,
                                     ? Plugin.Engine.ErrorHandler.Enforcing.NO_LIVE_INITIALIZERS
                                     : Plugin.Engine.Listener.NoOp.INSTANCE, failFast
                                     ? Plugin.Engine.ErrorHandler.Failing.FAIL_FAST
-                                    : Plugin.Engine.Listener.NoOp.INSTANCE)
+                                    : Plugin.Engine.ErrorHandler.Failing.FAIL_LAST)
                             .with(threads == 0
                                     ? Plugin.Engine.Dispatcher.ForSerialTransformation.Factory.INSTANCE
                                     : new Plugin.Engine.Dispatcher.ForParallelTransformation.WithThrowawayExecutorService.Factory(threads))

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -2141,9 +2141,7 @@ public static Dynamic bootstrap(String name, MethodDescription.InDefinedShape bo
                             ? bootstrap.getDeclaringType()
                             : bootstrap.getReturnType().asErasure(),
                     new MethodHandle(bootstrap.isConstructor() ? MethodHandle.HandleType.INVOKE_SPECIAL_CONSTRUCTOR : MethodHandle.HandleType.INVOKE_STATIC,
-                            bootstrap.isConstructor()
-                                    ? bootstrap.getDeclaringType()
-                                    : bootstrap.getReturnType().asErasure(),
+                            bootstrap.getDeclaringType(),
                             bootstrap.getInternalName(),
                             bootstrap.getReturnType().asErasure(),
                             bootstrap.getParameters().asTypeList().asErasures()),

File: byte-buddy-dep/src/precompiled/java/net/bytebuddy/test/precompiled/DynamicConstantBootstrap.java
Patch:
@@ -164,7 +164,7 @@ public static DynamicConstantBootstrap make(int intValue,
 
     public static class Other {
 
-        public static DynamicConstantBootstrap bootstrap(MethodHandles.Lookup lookup, Object... args) {
+        public static DynamicConstantBootstrap other(MethodHandles.Lookup lookup, Object... args) {
             return new DynamicConstantBootstrap();
         }
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaConstantDynamicTest.java
Patch:
@@ -48,7 +48,7 @@ public void testDynamicConstantFactoryLookupOnlyOtherHost() throws Exception {
         Class<? extends Foo> baz = new ByteBuddy()
                 .subclass(Foo.class)
                 .method(isDeclaredBy(Foo.class))
-                .intercept(FixedValue.value(JavaConstant.Dynamic.bootstrap(FOO, bootstrap.getMethod("bootstrap",
+                .intercept(FixedValue.value(JavaConstant.Dynamic.bootstrap(FOO, bootstrap.getMethod("other",
                         Class.forName("java.lang.invoke.MethodHandles$Lookup"),
                         Object[].class))))
                 .make()

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultTest.java
Patch:
@@ -1066,12 +1066,11 @@ public void testDominantInterfaceMethodTriangle() throws Exception {
     }
 
     @Test
-    @Ignore("Documents known issue")
     public void testDominantInterfaceMethodTriangleDuplicate() throws Exception {
         TypeDescription typeDescription = TypeDescription.ForLoadedType.of(AmbiguousInterface.TopTypeWithDuplication.class);
         MethodGraph.Linked methodGraph = MethodGraph.Compiler.Default.forJavaHierarchy().compile((TypeDefinition) typeDescription);
         assertThat(methodGraph.listNodes().size(), is(12));
-        MethodDescription method = typeDescription.getInterfaces().get(0).getDeclaredMethods().getOnly();
+        MethodDescription method = typeDescription.getInterfaces().get(1).getDeclaredMethods().getOnly();
         MethodGraph.Node node = methodGraph.locate(method.asSignatureToken());
         assertThat(node.getSort(), is(MethodGraph.Node.Sort.RESOLVED));
         assertThat(node.getMethodTypes().size(), is(1));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategy.java
Patch:
@@ -635,7 +635,7 @@ enum ForPreloadedTypes implements ClassLoadingStrategy<ClassLoader> {
          *
          * @return {@code true} if Byte Buddy is executed as a native image using GraalVM.
          */
-        @SuppressFBWarnings(value = "LI_LAZY_INIT_STATIC", justification = "This behaviour is intended.")
+        @SuppressFBWarnings(value = "LI_LAZY_INIT_STATIC", justification = "This behaviour is intended to avoid early binding in native images.")
         public static boolean isGraalNativeRuntime() {
             if (GRAAL_NATIVE_RUNTIME == null) {
                 GRAAL_NATIVE_RUNTIME = "runtime".equals(doPrivileged(new GetSystemPropertyAction("org.graalvm.nativeimage.imagecode")));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategy.java
Patch:
@@ -15,6 +15,7 @@
  */
 package net.bytebuddy.dynamic.loading;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.build.AccessControllerPlugin;
 import net.bytebuddy.build.HashCodeAndEqualsPlugin;
 import net.bytebuddy.description.type.TypeDescription;
@@ -634,6 +635,7 @@ enum ForPreloadedTypes implements ClassLoadingStrategy<ClassLoader> {
          *
          * @return {@code true} if Byte Buddy is executed as a native image using GraalVM.
          */
+        @SuppressFBWarnings(value = "LI_LAZY_INIT_STATIC", justification = "This behaviour is intended.")
         public static boolean isGraalNativeRuntime() {
             if (GRAAL_NATIVE_RUNTIME == null) {
                 GRAAL_NATIVE_RUNTIME = "runtime".equals(doPrivileged(new GetSystemPropertyAction("org.graalvm.nativeimage.imagecode")));

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -1494,7 +1494,7 @@ public StackManipulation resolve(TypeDescription instrumentedType,
                                                              MethodDescription instrumentedMethod,
                                                              Assigner assigner,
                                                              Advice.ArgumentHandler argumentHandler,
-                                                             Advice.StackMapFrameHandler stackMapFrameHandler) {
+                                                             Advice.StackMapFrameHandler.ForPostProcessor stackMapFrameHandler) {
                                 return new StackManipulation.Compound(
                                     MethodVariableAccess.of(advice.getReturnType()).loadFrom(argumentHandler.enter()),
                                     MethodVariableAccess.store(instrumentedMethod.getParameters().get(0))
@@ -1522,7 +1522,7 @@ public StackManipulation resolve(TypeDescription instrumentedType,
                                                              MethodDescription instrumentedMethod,
                                                              Assigner assigner,
                                                              Advice.ArgumentHandler argumentHandler,
-                                                             Advice.StackMapFrameHandler stackMapFrameHandler) {
+                                                             Advice.StackMapFrameHandler.ForPostProcessor stackMapFrameHandler) {
                                 return new StackManipulation.Compound(
                                         MethodVariableAccess.of(advice.getReturnType()).loadFrom(argumentHandler.enter()),
                                         MethodVariableAccess.store(instrumentedMethod.getParameters().get(0))

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTarget.java
Patch:
@@ -112,7 +112,7 @@ private Implementation.SpecialMethodInvocation invokeSuper(MethodGraph.Node node
      */
     private Implementation.SpecialMethodInvocation invokeSuper(MethodRebaseResolver.Resolution resolution) {
         return resolution.isRebased()
-                ? RebasedMethodInvocation.of(resolution.getResolvedMethod(), instrumentedType, resolution.getPrependedParameters())
+                ? RebasedMethodInvocation.of(resolution.getResolvedMethod(), instrumentedType, resolution.getAppendedParameters())
                 : Implementation.SpecialMethodInvocation.Simple.of(resolution.getResolvedMethod(), instrumentedType);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionPreservedTest.java
Patch:
@@ -27,6 +27,6 @@ public void testPreservation() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testPreservationCannotAppendArguments() throws Exception {
-        new MethodRebaseResolver.Resolution.Preserved(methodDescription).getPrependedParameters();
+        new MethodRebaseResolver.Resolution.Preserved(methodDescription).getAppendedParameters();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/LegacyGetPackageClassLoader.java
Patch:
@@ -1,5 +1,7 @@
 package net.bytebuddy.test.utility;
 
+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
+
 import java.net.URL;
 import java.net.URLClassLoader;
 import java.util.jar.Manifest;
@@ -11,7 +13,7 @@
  */
 public class LegacyGetPackageClassLoader extends URLClassLoader {
     public LegacyGetPackageClassLoader() {
-        super(new URL[0], new URLClassLoader(new URL[0], null));
+        super(new URL[0], new URLClassLoader(new URL[0], ClassLoadingStrategy.BOOTSTRAP_LOADER));
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -3125,7 +3125,7 @@ protected ForEnterValue(TypeDescription.Generic target, TypeDescription.Generic
                 this(target,
                         enterType,
                         annotation.getValue(Factory.ENTER_READ_ONLY).resolve(Boolean.class),
-                        annotation.getValue(Factory.ENTER_READ_ONLY).load(Enter.class.getClassLoader()).resolve(Assigner.Typing.class));
+                        annotation.getValue(Factory.ENTER_TYPING).load(Enter.class.getClassLoader()).resolve(Assigner.Typing.class));
             }
 
             /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -3117,9 +3117,9 @@ class ForEnterValue implements OffsetMapping {
             /**
              * Creates a new offset mapping for the enter type.
              *
-             * @param target    The represented target type.
-             * @param enterType The enter type.
-             * @param enter     The represented annotation.
+             * @param target     The represented target type.
+             * @param enterType  The enter type.
+             * @param annotation The represented annotation.
              */
             protected ForEnterValue(TypeDescription.Generic target, TypeDescription.Generic enterType, AnnotationDescription.Loadable<Enter> annotation) {
                 this(target,

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -12396,13 +12396,13 @@ public StackManipulation resolve(TypeDescription instrumentedType,
                     if (instrumentedMethod.getReturnType().represents(void.class)) {
                         return StackManipulation.Trivial.INSTANCE;
                     }
-                    StackManipulation assignment = assigner.assign(type, instrumentedMethod.getReturnType(), typing);
+                    StackManipulation assignment = assigner.assign(type, TypeDefinition.Sort.describe(Throwable.class), typing);
                     if (!assignment.isValid()) {
-                        throw new IllegalStateException("Cannot assign " + type + " to " + instrumentedMethod.getReturnType());
+                        throw new IllegalStateException("Cannot assign " + type + " to " + Throwable.class.getName());
                     }
                     return new StackManipulation.Compound(value,
                             assignment,
-                            MethodVariableAccess.of(instrumentedMethod.getReturnType()).storeAt(argumentHandler.thrown()));
+                            MethodVariableAccess.REFERENCE.storeAt(argumentHandler.thrown()));
                 }
 
                 /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -12501,6 +12501,7 @@ public static class Factory implements PostProcessor.Factory {
             /**
              * Creates a new factory which a preresolved list of handler factories.
              */
+            @SuppressWarnings("unchecked")
             public Factory() {
                 this(Arrays.asList(ToArguments.Handler.Factory.INSTANCE,
                         ToThis.Handler.Factory.INSTANCE,
@@ -12536,7 +12537,7 @@ public Factory with(Class<? extends Annotation> type, Handler... handler) {
              * @param handlers The handlers to use upon discovery.
              * @return A new {@link AssignReturned.Factory} that includes the provided handlers.
              */
-            @SuppressWarnings("unchecked")
+            @SuppressWarnings({"rawtypes", "unchecked"})
             public Factory with(Class<? extends Annotation> type, List<Handler> handlers) {
                 return with(new Handler.Factory.Simple(type, handlers));
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -507,7 +507,7 @@ abstract class AbstractBase implements TypePool {
         static {
             Map<String, TypeDescription> primitiveTypes = new HashMap<String, TypeDescription>();
             Map<String, String> primitiveDescriptors = new HashMap<String, String>();
-            for (Class<?> primitiveType : new Class<?>[]{boolean.class,
+            for (Class<?> type : new Class<?>[]{boolean.class,
                     byte.class,
                     short.class,
                     char.class,
@@ -516,8 +516,8 @@ abstract class AbstractBase implements TypePool {
                     float.class,
                     double.class,
                     void.class}) {
-                primitiveTypes.put(primitiveType.getName(), TypeDescription.ForLoadedType.of(primitiveType));
-                primitiveDescriptors.put(Type.getDescriptor(primitiveType), primitiveType.getName());
+                primitiveTypes.put(type.getName(), TypeDescription.ForLoadedType.of(type));
+                primitiveDescriptors.put(Type.getDescriptor(type), type.getName());
             }
             PRIMITIVE_TYPES = Collections.unmodifiableMap(primitiveTypes);
             PRIMITIVE_DESCRIPTORS = Collections.unmodifiableMap(primitiveDescriptors);

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -12436,7 +12436,7 @@ public Factory with(Class<? extends Annotation> type, Handler... handler) {
              */
             @SuppressWarnings("unchecked")
             public Factory with(Class<? extends Annotation> type, List<Handler> handlers) {
-                return with(new Handler.Factory.Simple(type, handlers)));
+                return with(new Handler.Factory.Simple(type, handlers));
             }
 
             /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceAnnotationTest.java
Patch:
@@ -19,7 +19,7 @@ public static Collection<Object[]> data() {
         return Arrays.asList(new Object[][]{
                 {Advice.AllArguments.class, ElementType.PARAMETER},
                 {Advice.Argument.class, ElementType.PARAMETER},
-                {Advice.AssignReturned.ToArgument.class, ElementType.METHOD},
+                {Advice.AssignReturned.ToArguments.class, ElementType.METHOD},
                 {Advice.FieldValue.class, ElementType.PARAMETER},
                 {Advice.Enter.class, ElementType.PARAMETER},
                 {Advice.Exit.class, ElementType.PARAMETER},

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceAssignReturnedTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
-import net.bytebuddy.test.utility.DebuggingWrapper;
 import org.junit.Test;
 
 import static net.bytebuddy.matcher.ElementMatchers.named;
@@ -37,7 +36,7 @@ public String foo(String value) {
     public static class ToArgumentScalar {
 
         @Advice.OnMethodEnter
-        @Advice.AssignReturned.ToArgument(0)
+        @Advice.AssignReturned.ToArguments(@Advice.AssignReturned.ToArguments.ToArgument(0))
         public static String enter(@Advice.Argument(0) String arg) {
             if (!FOO.equals(arg)) {
                 throw new AssertionError();
@@ -46,7 +45,7 @@ public static String enter(@Advice.Argument(0) String arg) {
         }
 
         @Advice.OnMethodExit
-        @Advice.AssignReturned.ToArgument(0)
+        @Advice.AssignReturned.ToArguments(@Advice.AssignReturned.ToArguments.ToArgument(0))
         public static String exit(@Advice.Argument(0) String arg) {
             if (!BAR.equals(arg)) {
                 throw new AssertionError();

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/Nexus.java
Patch:
@@ -136,7 +136,7 @@ public static void initialize(Class<?> type, int identification) throws Exceptio
         if (typeInitializer != null) {
             Class.forName("net.bytebuddy.implementation.LoadedTypeInitializer",
                     true,
-                    type.getClassLoader()).getMethod("onLoad", Class.class).invoke(typeInitializer, type);
+                    typeInitializer.getClass().getClassLoader()).getMethod("onLoad", Class.class).invoke(typeInitializer, type);
         }
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionForLoadedTest.java
Patch:
@@ -1,7 +1,6 @@
 package net.bytebuddy.description.method;
 
 import net.bytebuddy.test.utility.JavaVersionRule;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import java.lang.reflect.Constructor;
@@ -33,7 +32,6 @@ protected boolean canReadDebugInformation() {
     @Test
     @Override
     @JavaVersionRule.Enforce(17)
-    @Ignore("Awaiting CI server update for EA versions")
     public void testEnumConstructorAnnotation() throws Exception {
         super.testEnumConstructorAnnotation();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTest.java
Patch:
@@ -5,7 +5,6 @@
 import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.matcher.ElementMatchers;
 import net.bytebuddy.test.utility.JavaVersionRule;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import java.lang.reflect.Constructor;
@@ -46,7 +45,6 @@ protected boolean canReadDebugInformation() {
     @Test
     @Override
     @JavaVersionRule.Enforce(17)
-    @Ignore("Awaiting CI server update for EA versions")
     public void testEnumConstructorAnnotation() throws Exception {
         super.testEnumConstructorAnnotation();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -19,7 +19,6 @@
 import net.bytebuddy.utility.OpenedClassReader;
 import org.hamcrest.CoreMatchers;
 import org.hamcrest.Matcher;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.MethodRule;
@@ -36,8 +35,9 @@
 import java.util.concurrent.Callable;
 
 import static net.bytebuddy.matcher.ElementMatchers.*;
-import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.CoreMatchers.not;
+import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
@@ -758,7 +758,6 @@ public void testNotSealed() throws Exception {
 
     @Test
     @JavaVersionRule.Enforce(17)
-    @Ignore("Awaiting CI server update for EA versions")
     public void testSealed() throws Exception {
         Class<?> sealed = Class.forName("net.bytebuddy.test.precompiled.Sealed");
         assertThat(describe(sealed).isSealed(), is(true));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldValue.java
Patch:
@@ -44,7 +44,7 @@
  * or getter's field if the intercepted method is an accessor method. Otherwise, the binding renders the target method
  * to be an illegal candidate for binding.
  * </p>
- *
+ * <p>
  * <b>Important</b>: Don't confuse this annotation with {@link net.bytebuddy.asm.Advice.FieldValue} annotation. This annotation
  * should be used only in combination with method delegation
  * ({@link net.bytebuddy.implementation.MethodDelegation MethodDelegation.to(...)}).

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Origin.java
Patch:
@@ -61,7 +61,7 @@
  * <b>Important:</b> A method handle or method type reference can only be used if the referenced method's types are all visible
  * to the instrumented type or an {@link IllegalAccessError} will be thrown at runtime.
  * </p>
- *
+ * <p>
  * <b>Important</b>: Don't confuse this annotation with {@link net.bytebuddy.asm.Advice.Origin} annotation. This annotation
  * should be used only in combination with method delegation
  * ({@link net.bytebuddy.implementation.MethodDelegation MethodDelegation.to(...)}).

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/StubValue.java
Patch:
@@ -29,13 +29,15 @@
 import java.lang.annotation.*;
 
 /**
+ * <p>
  * A stub value represents the (boxed) default value of the intercepted method's return type. This value can
  * only be assigned to a {@link java.lang.Object} parameter. This annotation is useful to conditionally return a
  * default value from a method when using an {@link java.lang.Object} return type in combination with the
  * {@link net.bytebuddy.implementation.bind.annotation.RuntimeType} annotation. The value is either representing
  * {@code null} if a method returns a reference type or {@code void} or a boxed primitive of the return type
  * representing the numeric value {@code 0}.
- *
+ * </p>
+ * <p>
  * <b>Important</b>: Don't confuse this annotation with {@link net.bytebuddy.asm.Advice.StubValue} annotation. This
  * annotation should be used only in combination with method delegation
  * ({@link net.bytebuddy.implementation.MethodDelegation MethodDelegation.to(...)}).

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/This.java
Patch:
@@ -28,10 +28,12 @@
 import java.lang.annotation.*;
 
 /**
+ * <p>
  * Parameters that are annotated with this annotation will be assigned a reference to the instrumented object, if
  * the instrumented method is not static. Otherwise, the method with this parameter annotation will be excluded from
  * the list of possible binding candidates of the static source method.
- *
+ * </p>
+ * <p>
  * <b>Important</b>: Don't confuse this annotation with {@link net.bytebuddy.asm.Advice.This} annotation. This annotation
  * should be used only in combination with method delegation
  * ({@link net.bytebuddy.implementation.MethodDelegation MethodDelegation.to(...)}).

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationDefaultCallTest.java
Patch:
@@ -5,9 +5,7 @@
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.implementation.bind.annotation.DefaultCall;
-import net.bytebuddy.implementation.bind.annotation.DefaultMethod;
 import net.bytebuddy.implementation.bind.annotation.SuperCall;
-import net.bytebuddy.implementation.bind.annotation.SuperMethod;
 import net.bytebuddy.test.utility.JavaVersionRule;
 import org.hamcrest.CoreMatchers;
 import org.junit.Rule;
@@ -141,7 +139,7 @@ public void testSuperAndDefaultMethod() throws Exception {
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER);
         Object instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         Method method = loaded.getLoaded().getMethod(FOO);
-        assertThat(method.invoke(instance), is((Object) FOO + FOO));
+        assertThat(method.invoke(instance), is((Object) (FOO + FOO)));
     }
 
     public static class RunnableClass {

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -9401,7 +9401,7 @@ public Default(ByteBuddy byteBuddy) {
                             new RawMatcher.ForElementMatchers(any(), isBootstrapClassLoader().or(isExtensionClassLoader())),
                             new RawMatcher.ForElementMatchers(nameStartsWith("net.bytebuddy.")
                                     .and(not(ElementMatchers.nameStartsWith(NamingStrategy.SuffixingRandom.BYTE_BUDDY_RENAME_PACKAGE + ".")))
-                                    .or(nameStartsWith("sun.reflect.").or(nameStartsWith("jdk.reflect.")))
+                                    .or(nameStartsWith("sun.reflect.").or(nameStartsWith("jdk.internal.reflect.")))
                                     .<TypeDescription>or(isSynthetic()))),
                     Collections.<Transformation>emptyList());
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -9401,7 +9401,7 @@ public Default(ByteBuddy byteBuddy) {
                             new RawMatcher.ForElementMatchers(any(), isBootstrapClassLoader().or(isExtensionClassLoader())),
                             new RawMatcher.ForElementMatchers(nameStartsWith("net.bytebuddy.")
                                     .and(not(ElementMatchers.nameStartsWith(NamingStrategy.SuffixingRandom.BYTE_BUDDY_RENAME_PACKAGE + ".")))
-                                    .or(nameStartsWith("sun.reflect.").or(nameStartsWith("jdk.reflect.")))
+                                    .or(nameStartsWith("sun.reflect.").or(nameStartsWith("jdk.internal.reflect.")))
                                     .<TypeDescription>or(isSynthetic()))),
                     Collections.<Transformation>emptyList());
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -5427,7 +5427,7 @@ protected Collector make(PoolStrategy poolStrategy,
          * <p>
          * <b>Note</b>: When applying a redefinition, it is normally required to use a {@link TypeStrategy} that applies
          * a redefinition instead of rebasing classes such as {@link TypeStrategy.Default#REDEFINE}. Also, consider
-         * the constrains given by this type strategy.
+         * the constraints given by this type strategy.
          * </p>
          */
         REDEFINITION(true, false) {
@@ -5469,7 +5469,7 @@ protected Collector make(PoolStrategy poolStrategy,
          * <p>
          * <b>Note</b>: When applying a retransformation, it is normally required to use a {@link TypeStrategy} that applies
          * a redefinition instead of rebasing classes such as {@link TypeStrategy.Default#REDEFINE}. Also, consider
-         * the constrains given by this type strategy.
+         * the constraints given by this type strategy.
          * </p>
          */
         RETRANSFORMATION(true, true) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -5252,7 +5252,7 @@ protected Collector make(PoolStrategy poolStrategy,
          * <p>
          * <b>Note</b>: When applying a redefinition, it is normally required to use a {@link TypeStrategy} that applies
          * a redefinition instead of rebasing classes such as {@link TypeStrategy.Default#REDEFINE}. Also, consider
-         * the constrains given by this type strategy.
+         * the constraints given by this type strategy.
          * </p>
          */
         REDEFINITION(true, false) {
@@ -5294,7 +5294,7 @@ protected Collector make(PoolStrategy poolStrategy,
          * <p>
          * <b>Note</b>: When applying a retransformation, it is normally required to use a {@link TypeStrategy} that applies
          * a redefinition instead of rebasing classes such as {@link TypeStrategy.Default#REDEFINE}. Also, consider
-         * the constrains given by this type strategy.
+         * the constraints given by this type strategy.
          * </p>
          */
         RETRANSFORMATION(true, true) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -45,7 +45,6 @@
 import java.security.PrivilegedAction;
 import java.security.ProtectionDomain;
 import java.util.*;
-import java.util.concurrent.ExecutionException;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.jar.JarOutputStream;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -1687,7 +1687,7 @@ interface Lookup {
         /**
          * A privileged action to resolve {@code java.lang.invoke.MethodHandles$Lookup#defineClass}, or {@code null},
          * if not available. This method must be invoked reflectively since the security manager checks the scope of
-         * invocation for this method such that no {@link JavaDispatcher} can be used.
+         * invocation for this method such that {@link JavaDispatcher} cannot be used.
          */
         protected enum DefineClassAction implements PrivilegedAction<Method> {
 
@@ -1699,6 +1699,7 @@ protected enum DefineClassAction implements PrivilegedAction<Method> {
             /**
              * {@inheritDoc}
              */
+            @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but be nulled out")
             public Method run() {
                 try {
                     return Class.forName("java.lang.invoke.MethodHandles$Lookup").getMethod("defineClass", byte[].class);

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -9220,7 +9220,7 @@ public Default(ByteBuddy byteBuddy) {
                             new RawMatcher.ForElementMatchers(any(), isBootstrapClassLoader().or(isExtensionClassLoader())),
                             new RawMatcher.ForElementMatchers(nameStartsWith("net.bytebuddy.")
                                     .and(not(ElementMatchers.nameStartsWith(NamingStrategy.SuffixingRandom.BYTE_BUDDY_RENAME_PACKAGE + ".")))
-                                    .or(nameStartsWith("sun.reflect."))
+                                    .or(nameStartsWith("sun.reflect.").or(nameStartsWith("jdk.reflect.")))
                                     .<TypeDescription>or(isSynthetic()))),
                     Collections.<Transformation>emptyList());
         }

File: byte-buddy-agent/src/test/java/net/bytebuddy/test/utility/AgentAttachmentRule.java
Patch:
@@ -62,7 +62,7 @@ private NoOpStatement(String reason) {
         }
 
         public void evaluate() {
-            Logger.getLogger("net.bytebuddy").warning("Ignoring test case: " + reason);
+            Logger.getLogger("net.bytebuddy").info("Omitting test case: " + reason);
         }
     }
 }

File: byte-buddy-agent/src/test/java/net/bytebuddy/test/utility/JavaVersionRule.java
Patch:
@@ -76,7 +76,7 @@ private NoOpStatement(int requiredVersion, String sort, Class<?> target) {
         }
 
         public void evaluate() {
-            Logger.getLogger("net.bytebuddy").warning("Ignoring test case: Requires a Java version " +
+            Logger.getLogger("net.bytebuddy").info("Omitting test case: Requires a Java version " +
                     "of " + sort + " " + requiredVersion
                     + (target == void.class ? "" : (" for target " + target)));
         }
@@ -85,7 +85,7 @@ public void evaluate() {
     private static class OpenJ9Statement extends Statement {
 
         public void evaluate() {
-            Logger.getLogger("net.bytebuddy").warning("Ignoring test case: Test not supported on OpenJ9");
+            Logger.getLogger("net.bytebuddy").info("Omitting test case: Test not supported on OpenJ9");
         }
     }
 }

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/ClassByExtensionBenchmark.java
Patch:
@@ -453,7 +453,7 @@ public ExampleClass benchmarkCglib() {
         enhancer.setInterceptDuringConstruction(true);
         enhancer.setClassLoader(newClassLoader());
         enhancer.setSuperclass(baseClass);
-        CallbackHelper callbackHelper = new CallbackHelper(baseClass, new Class[0]) {
+        CallbackHelper callbackHelper = new CallbackHelper(baseClass, new Class<?>[0]) {
             protected Object getCallback(Method method) {
                 if (method.getDeclaringClass() == baseClass) {
                     return new MethodInterceptor() {

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/ClassByImplementationBenchmark.java
Patch:
@@ -322,7 +322,7 @@ public ExampleInterface benchmarkCglib() {
         enhancer.setUseCache(false);
         enhancer.setClassLoader(newClassLoader());
         enhancer.setSuperclass(baseClass);
-        CallbackHelper callbackHelper = new CallbackHelper(Object.class, new Class[]{baseClass}) {
+        CallbackHelper callbackHelper = new CallbackHelper(Object.class, new Class<?>[]{baseClass}) {
             protected Object getCallback(Method method) {
                 if (method.getDeclaringClass() == baseClass) {
                     return new FixedValue() {

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/TypeReferenceAdjustment.java
Patch:
@@ -569,7 +569,7 @@ public void visitMethodInsn(int opcode, String ownerInternalName, String name, S
             }
 
             @Override
-            public void visitInvokeDynamicInsn(String name, String descriptor, Handle handle, Object[] argument) {
+            public void visitInvokeDynamicInsn(String name, String descriptor, Handle handle, Object... argument) {
                 resolve(Type.getType(descriptor));
                 resolve(handle);
                 for (Object anArgument : argument) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationValue.java
Patch:
@@ -2259,7 +2259,7 @@ public static <W extends Annotation> AnnotationValue<AnnotationDescription[], W[
          * @param typeDescription A description of the types contained in the array.
          * @return A description of the array of enumeration values.
          */
-        @SuppressWarnings("unchecked")
+        @SuppressWarnings({"unchecked", "rawtypes", "cast"})
         public static AnnotationValue<TypeDescription[], Class<?>[]> of(TypeDescription[] typeDescription) {
             List<AnnotationValue<TypeDescription, Class<?>>> values = new ArrayList<AnnotationValue<TypeDescription, Class<?>>>(typeDescription.length);
             for (TypeDescription value : typeDescription) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -879,7 +879,7 @@ public boolean equals(Object other) {
                     } else if (!(other instanceof Key)) {
                         return false;
                     }
-                    Key key = (Key) other;
+                    Key<?> key = (Key<?>) other;
                     return internalName.equals(key.internalName)
                             && parameterCount == key.parameterCount
                             && !Collections.disjoint(getIdentifiers(), key.getIdentifiers());

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3776,7 +3776,7 @@ public void visitMethodInsn(int opcode, String owner, String name, String descri
                 }
 
                 @Override
-                public void visitInvokeDynamicInsn(String name, String descriptor, Handle bootstrapMethod, Object[] bootstrapArgument) {
+                public void visitInvokeDynamicInsn(String name, String descriptor, Handle bootstrapMethod, Object... bootstrapArgument) {
                     constraint.assertInvokeDynamic();
                     for (Object constant : bootstrapArgument) {
                         if (constant instanceof ConstantDynamic) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -6291,7 +6291,7 @@ public Sort getSort() {
 
                     @Override
                     @CachedReturnPlugin.Enhance("resolved")
-                    @SuppressWarnings("unchecked")
+                    @SuppressWarnings({"unchecked", "rawtypes"})
                     protected AnnotationValue<TypeDescription, Class<?>> doResolve() {
                         Resolution resolution = typePool.describe(typeName);
                         return resolution.isResolved()
@@ -6389,7 +6389,7 @@ public Sort getSort() {
 
                     @Override
                     @CachedReturnPlugin.Enhance("resolved")
-                    @SuppressWarnings("unchecked")
+                    @SuppressWarnings({"unchecked", "rawtypes"})
                     protected AnnotationValue<EnumerationDescription, Enum<?>> doResolve() {
                         Resolution resolution = typePool.describe(typeName);
                         if (!resolution.isResolved()) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -786,7 +786,7 @@ public List<String> log(@Pipe Forwarder<List<String>, MemoryDatabase> pipe) {
         }
     }
 
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     class LoggingMemoryDatabase extends MemoryDatabase {
 
         public List<String> load(String info) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/TypeCacheTest.java
Patch:
@@ -90,7 +90,7 @@ public void testCacheTypeCollection() throws Exception {
             assertThat(typeCache.insert(classLoader, key, Void.class), is((Object) Void.class));
             assertThat(typeCache.find(classLoader, key), is((Object) Void.class));
         } catch (AssertionError ignored) {
-            Logger.getLogger("net.bytebuddy").warning("Cache was not cleared, possibly due to weak references not being collected, retrying...");
+            Logger.getLogger("net.bytebuddy").info("Cache was not cleared, possibly due to weak references not being collected, retrying...");
             for (int index = 0; index < 50; index++) {
                 System.gc();
                 Thread.sleep(50L);

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceBoxedParameterAssignmentTest.java
Patch:
@@ -98,6 +98,7 @@ public byte foo(byte value) {
         }
 
         @Advice.OnMethodEnter
+        @SuppressWarnings("cast")
         private static void enter(@Advice.AllArguments(readOnly = false, typing = Assigner.Typing.DYNAMIC) Object[] value) {
             value = new Object[]{(byte) NUMERIC_VALUE};
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -3543,6 +3543,8 @@ private static void enter(@Advice.AllArguments Object[] value) {
 
     public static class ExceptionWriterSample extends RuntimeException {
 
+        private static final long serialVersionUID = 1L;
+
         public static boolean exception;
 
         public String foo() {

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginEngineDispatcherForSerialTransformationTest.java
Patch:
@@ -71,8 +71,9 @@ public Plugin.Engine.Dispatcher.Materializable call() {
                 };
             }
         };
-        Mockito.doAnswer(new Answer() {
-            public Object answer(InvocationOnMock invocationOnMock) {
+        Mockito.doAnswer(new Answer<Void>() {
+
+            public Void answer(InvocationOnMock invocationOnMock) {
                 ((Runnable) invocationOnMock.getArgument(0)).run();
                 return null;
             }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/ByteCodeElementTokenListTest.java
Patch:
@@ -23,7 +23,7 @@ public class ByteCodeElementTokenListTest {
     private TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor;
 
     @Test
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public void testTransformation() throws Exception {
         when(original.accept(visitor)).thenReturn((ByteCodeElement.Token) transformed);
         ByteCodeElement.Token.TokenList<?> tokenList = new ByteCodeElement.Token.TokenList(original).accept(visitor);

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AnnotationDescriptionLatentTest.java
Patch:
@@ -11,7 +11,7 @@
 
 public class AnnotationDescriptionLatentTest extends AbstractAnnotationDescriptionTest {
 
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     private static AnnotationDescription build(Annotation annotation) throws Exception {
         AnnotationDescription.Builder builder = AnnotationDescription.Builder.ofType(annotation.annotationType());
         for (Method method : annotation.annotationType().getDeclaredMethods()) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/enumeration/AbstractEnumerationDescriptionTest.java
Patch:
@@ -59,6 +59,7 @@ public void testToString() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("cast")
     public void testType() throws Exception {
         assertThat(describe(Sample.FIRST).getEnumerationType(), is((TypeDescription) TypeDescription.ForLoadedType.of(Sample.class)));
         assertThat(describe(Sample.SECOND).getEnumerationType(), is((TypeDescription) TypeDescription.ForLoadedType.of(Sample.class)));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/AbstractFieldDescriptionTest.java
Patch:
@@ -70,6 +70,7 @@ public void testFieldModifier() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("cast")
     public void testFieldDeclaringType() throws Exception {
         assertThat(describe(first).getDeclaringType(), is((TypeDescription) TypeDescription.ForLoadedType.of(first.getDeclaringClass())));
         assertThat(describe(second).getDeclaringType(), is((TypeDescription) TypeDescription.ForLoadedType.of(second.getDeclaringClass())));
@@ -184,6 +185,7 @@ public void testAnnotations() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("cast")
     public void testGenericTypes() throws Exception {
         assertThat(describe(genericField).getType(), is(TypeDefinition.Sort.describe(genericField.getGenericType())));
         assertThat(describe(genericField).getType().asErasure(), is((TypeDescription) TypeDescription.ForLoadedType.of(genericField.getType())));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/AbstractMethodDescriptionTest.java
Patch:
@@ -142,6 +142,7 @@ public void testMethodModifiers() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("cast")
     public void testMethodDeclaringType() throws Exception {
         assertThat(describe(firstMethod).getDeclaringType(), is((TypeDescription) TypeDescription.ForLoadedType.of(firstMethod.getDeclaringClass())));
         assertThat(describe(secondMethod).getDeclaringType(), is((TypeDescription) TypeDescription.ForLoadedType.of(secondMethod.getDeclaringClass())));
@@ -768,7 +769,7 @@ public void testSyntethicParameter() throws Exception {
     }
 
     @Test
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes", "cast"})
     public void testIsDefault() throws Exception {
         Map<String, AnnotationValue<?, ?>> properties = new LinkedHashMap<String, AnnotationValue<?, ?>>();
         properties.put("boolean_property", AnnotationValue.ForConstant.of(true));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/GenericSignatureResolutionTest.java
Patch:
@@ -203,6 +203,7 @@ public abstract static class GenericType<T extends ArrayList<T> & Callable<T>,
             V extends ArrayList<? super ArrayList<V>>,
             W extends Callable<W[]>> extends ArrayList<T> implements Callable<T> {
 
+        private static final long serialVersionUID = 1L;
     }
 
     @SuppressWarnings("unused")

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericOfNonGenericTypeForReifiedErasureTest.java
Patch:
@@ -20,6 +20,7 @@ public void testNonGenerifiedType() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("cast")
     public void testGenerifiedType() throws Exception {
         TypeDescription.Generic typeDescription = TypeDescription.Generic.OfNonGenericType.ForReifiedErasure.of(TypeDescription.ForLoadedType.of(Qux.class));
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.NON_GENERIC));
@@ -71,6 +72,7 @@ public void testGenerifiedType() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("cast")
     public void testNonGenericIntermediateType() throws Exception {
         TypeDescription.Generic typeDescription = TypeDescription.Generic.OfNonGenericType.ForReifiedErasure.of(TypeDescription.ForLoadedType.of(GenericIntermediate.class))
                 .getSuperClass();

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericOfParameterizedTypeForReifiedTypeTest.java
Patch:
@@ -13,6 +13,7 @@ public class TypeDescriptionGenericOfParameterizedTypeForReifiedTypeTest {
     private static final String FOO = "foo", BAR = "bar";
 
     @Test
+    @SuppressWarnings("cast")
     public void testSuperType() throws Exception {
         TypeDescription.Generic typeDescription = new TypeDescription.Generic.OfParameterizedType.ForReifiedType(TypeDescription.ForLoadedType.of(Sample.class)
                 .getSuperClass());
@@ -41,6 +42,7 @@ public void testSuperType() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("cast")
     public void testInterfaceType() throws Exception {
         TypeDescription.Generic typeDescription = new TypeDescription.Generic.OfParameterizedType.ForReifiedType(TypeDescription.ForLoadedType.of(Sample.class)
                 .getInterfaces().getOnly());
@@ -66,6 +68,7 @@ public void testInterfaceType() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("cast")
     public void testNonGenericIntermediateType() throws Exception {
         TypeDescription.Generic typeDescription = TypeDescription.Generic.OfNonGenericType.ForReifiedErasure.of(TypeDescription.ForLoadedType.of(NonGenericSample.class))
                 .getSuperClass()

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorValidatorForTypeAnnotations.java
Patch:
@@ -38,7 +38,7 @@ public class TypeDescriptionGenericVisitorValidatorForTypeAnnotations {
     private TypeDescription.Generic legal, illegal, duplicate, otherLegal, otherIllegal;
 
     @Before
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public void setUp() throws Exception {
         when(otherLegal.accept(any(TypeDescription.Generic.Visitor.class))).thenReturn(true);
         when(otherIllegal.accept(any(TypeDescription.Generic.Visitor.class))).thenReturn(false);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeDefaultTest.java
Patch:
@@ -475,6 +475,7 @@ public void testRepresents() {
     }
 
     @Test
+    @SuppressWarnings("cast")
     public void testSuperClass() {
         assertThat(makePlainInstrumentedType().getSuperClass(), is(TypeDescription.Generic.OBJECT));
         assertThat(makePlainInstrumentedType().getSuperClass(), not((TypeDescription.Generic) TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Integer.class)));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultKeyTest.java
Patch:
@@ -76,21 +76,21 @@ public void testNotEqualsDistinctSet() throws Exception {
     }
 
     @Test(expected = IllegalStateException.class)
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public void testInitialEntryCannotInject() throws Exception {
         new MethodGraph.Compiler.Default.Key.Store.Entry.Initial(new MethodGraph.Compiler.Default.Key.Harmonized(FOO, -1, Collections.emptyMap()))
                 .inject(mock(MethodGraph.Compiler.Default.Key.Harmonized.class), Visibility.PUBLIC);
     }
 
     @Test(expected = IllegalStateException.class)
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public void testInitialEntryCannotBeTransformed() throws Exception {
         new MethodGraph.Compiler.Default.Key.Store.Entry.Initial(new MethodGraph.Compiler.Default.Key.Harmonized(FOO, -1, Collections.emptyMap()))
                 .asNode(mock(MethodGraph.Compiler.Default.Merger.class));
     }
 
     @Test(expected = IllegalStateException.class)
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public void testInitialEntryCannotExposeKey() throws Exception {
         new MethodGraph.Compiler.Default.Key.Store.Entry.Initial(new MethodGraph.Compiler.Default.Key.Harmonized(FOO, -1, Collections.emptyMap()))
                 .getKey();

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultTest.java
Patch:
@@ -1646,6 +1646,7 @@ public void foo(T t) {
             }
         }
 
+        @SuppressWarnings("rawtypes")
         public static class Raw extends Intermediate {
 
             public void foo(Number t) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilderTest.java
Patch:
@@ -50,7 +50,7 @@ protected DynamicType.Builder<?> createDisabledContext() {
         return new ByteBuddy().with(Implementation.Context.Disabled.Factory.INSTANCE).rebase(Foo.class);
     }
 
-    protected DynamicType.Builder createDisabledRetention(Class<?> annotatedClass) {
+    protected DynamicType.Builder<?> createDisabledRetention(Class<?> annotatedClass) {
         return new ByteBuddy().with(AnnotationRetention.DISABLED).rebase(annotatedClass);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilderTest.java
Patch:
@@ -40,7 +40,7 @@ protected DynamicType.Builder<?> createDisabledContext() {
         return new ByteBuddy().with(Implementation.Context.Disabled.Factory.INSTANCE).redefine(Foo.class);
     }
 
-    protected DynamicType.Builder createDisabledRetention(Class<?> annotatedClass) {
+    protected DynamicType.Builder<?> createDisabledRetention(Class<?> annotatedClass) {
         return new ByteBuddy().with(AnnotationRetention.DISABLED).redefine(annotatedClass);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderTest.java
Patch:
@@ -168,7 +168,7 @@ public void testAnnotationDefinition() throws Exception {
     }
 
     @Test
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public void testEnumerationDefinition() throws Exception {
         Class<? extends Enum<?>> type = new ByteBuddy()
                 .makeEnumeration(FOO, BAR)
@@ -183,10 +183,10 @@ public void testEnumerationDefinition() throws Exception {
         assertThat(type.isInterface(), is(false));
         assertThat(type.isAnnotation(), is(false));
         assertThat(type.isEnum(), is(true));
-        Enum foo = Enum.valueOf((Class) type, FOO);
+        Enum<?> foo = Enum.valueOf((Class) type, FOO);
         assertThat(foo.name(), is(FOO));
         assertThat(foo.ordinal(), is(0));
-        Enum bar = Enum.valueOf((Class) type, BAR);
+        Enum<?> bar = Enum.valueOf((Class) type, BAR);
         assertThat(bar.name(), is(BAR));
         assertThat(bar.ordinal(), is(1));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/FieldAccessorOtherTest.java
Patch:
@@ -160,6 +160,7 @@ public void testJavaConstant() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("rawtypes")
     public void testStaticFieldOfOtherClass() throws Exception {
         DynamicType.Loaded<Callable> loaded = new ByteBuddy()
                 .subclass(Callable.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/InvokeDynamicTest.java
Patch:
@@ -523,10 +523,10 @@ public void testLambdaMetaFactoryNoFunctionalInterface() throws Exception {
         InvokeDynamic.lambda(InvokeDynamicTest.class.getMethod("value"), ExecutorService.class);
     }
 
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     private Enum<?> makeEnum() throws Exception {
-        Class type = Class.forName(SAMPLE_ENUM);
-        return Enum.valueOf(type, INSTANCE);
+        Class<?> type = Class.forName(SAMPLE_ENUM);
+        return Enum.valueOf((Class) type, INSTANCE);
     }
 
     public static class Simple {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/SuperMethodCallOtherTest.java
Patch:
@@ -73,7 +73,7 @@ public class SuperMethodCallOtherTest {
     private MethodDescription.SignatureToken token;
 
     @Mock
-    private MethodList superClassMethods;
+    private MethodList<MethodDescription.InDefinedShape> superClassMethods;
 
     @Before
     public void setUp() throws Exception {
@@ -101,7 +101,7 @@ public void testConstructor() throws Exception {
     }
 
     @Test(expected = IllegalStateException.class)
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public void testStaticMethod() throws Exception {
         when(typeDescription.getSuperClass()).thenReturn(superClass);
         when(methodDescription.isStatic()).thenReturn(true);
@@ -115,7 +115,7 @@ public void testStaticMethod() throws Exception {
     }
 
     @Test(expected = IllegalStateException.class)
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public void testNoSuper() throws Exception {
         when(typeDescription.getSuperClass()).thenReturn(superClass);
         when(methodDescription.getParameters()).thenReturn((ParameterList) new ParameterList.Empty<ParameterDescription>());

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TypeProxyCreationTest.java
Patch:
@@ -202,6 +202,7 @@ public void testAllLegalNotIgnoreFinalizer() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("cast")
     public void testForConstructorConstruction() throws Exception {
         when(implementationTarget.getInstrumentedType()).thenReturn(foo);
         when(invocationFactory.invoke(eq(implementationTarget), eq(foo), any(MethodDescription.class)))

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinderTest.java
Patch:
@@ -90,7 +90,7 @@ private static MethodDelegationBinder.ParameterBinding<?> prepareArgumentBinder(
         when(parameterBinding.isValid()).thenReturn(true);
         when(parameterBinding.apply(any(MethodVisitor.class), any(Implementation.Context.class))).thenReturn(new StackManipulation.Size(0, 0));
         when(parameterBinding.getIdentificationToken()).thenReturn(identificationToken);
-        when(((TargetMethodAnnotationDrivenBinder.ParameterBinder) parameterBinder).bind(any(AnnotationDescription.Loadable.class),
+        when(parameterBinder.bind(any(AnnotationDescription.Loadable.class),
                 any(MethodDescription.class),
                 any(ParameterDescription.class),
                 any(Implementation.Target.class),
@@ -241,7 +241,7 @@ public void testDoNotBindOnIllegalMethodInvocation() throws Exception {
     }
 
     @Test
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public void testBindingByDefault() throws Exception {
         when(targetMethod.isAccessibleTo(instrumentedType)).thenReturn(true);
         when(assignmentBinding.isValid()).thenReturn(true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/DefinedShapeMatcherTest.java
Patch:
@@ -22,7 +22,7 @@ public DefinedShapeMatcherTest() {
     }
 
     @Test
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public void testMatch() throws Exception {
         when(matcher.matches(resolvedDependant)).thenReturn(true);
         when(dependent.asDefined()).thenReturn((ByteCodeElement.TypeDependant) resolvedDependant);
@@ -34,7 +34,7 @@ public void testMatch() throws Exception {
     }
 
     @Test
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public void testNoMatch() throws Exception {
         when(matcher.matches(resolvedDependant)).thenReturn(true);
         when(dependent.asDefined()).thenReturn((ByteCodeElement.TypeDependant) otherResolvedDependant);

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/LatentMatcherConjunctionTest.java
Patch:
@@ -28,14 +28,14 @@ public class LatentMatcherConjunctionTest {
     private TypeDescription typeDescription;
 
     @Before
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public void setUp() throws Exception {
         when(left.resolve(typeDescription)).thenReturn((ElementMatcher) leftMatcher);
         when(right.resolve(typeDescription)).thenReturn((ElementMatcher) rightMatcher);
     }
 
     @Test
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public void testManifestation() throws Exception {
         assertThat(new LatentMatcher.Conjunction(left, right).resolve(typeDescription),
                 hasPrototype((ElementMatcher) any().and((ElementMatcher) leftMatcher).and((ElementMatcher) rightMatcher)));

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/LatentMatcherDisjunctionTest.java
Patch:
@@ -28,14 +28,14 @@ public class LatentMatcherDisjunctionTest {
     private TypeDescription typeDescription;
 
     @Before
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public void setUp() throws Exception {
         when(left.resolve(typeDescription)).thenReturn((ElementMatcher) leftMatcher);
         when(right.resolve(typeDescription)).thenReturn((ElementMatcher) rightMatcher);
     }
 
     @Test
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public void testManifestation() throws Exception {
         assertThat(new LatentMatcher.Disjunction(left, right).resolve(typeDescription),
                 hasPrototype((ElementMatcher) none().or((ElementMatcher) leftMatcher).or((ElementMatcher) rightMatcher)));

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/MethodParameterTypesMatcherTest.java
Patch:
@@ -22,7 +22,7 @@ public class MethodParameterTypesMatcherTest extends AbstractElementMatcherTest<
     private TypeList.Generic typeList;
 
     @Mock
-    private ParameterList parameterList;
+    private ParameterList<?> parameterList;
 
     @SuppressWarnings("unchecked")
     public MethodParameterTypesMatcherTest() {

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolClassLoadingTest.java
Patch:
@@ -38,13 +38,15 @@ public void testLoadableBootstrapLoaderClass() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("cast")
     public void testArrayClass() throws Exception {
         TypePool.Resolution resolution = typePool.describe(Object[].class.getName());
         assertThat(resolution.isResolved(), is(true));
         assertThat(resolution.resolve(), is((TypeDescription) TypeDescription.ForLoadedType.of(Object[].class)));
     }
 
     @Test
+    @SuppressWarnings("cast")
     public void testPrimitiveClass() throws Exception {
         TypePool.Resolution resolution = typePool.describe(int.class.getName());
         assertThat(resolution.isResolved(), is(true));

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultHierarchyTest.java
Patch:
@@ -48,6 +48,7 @@ public void testParentFirst() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("cast")
     public void testChildSecond() throws Exception {
         TypePool typePool = new TypePool.Default(cacheProvider, classFileLocator, TypePool.Default.ReaderMode.FAST, parentPool);
         when(parentPool.describe(FOO)).thenReturn(resolution);

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/packaging/PackagePrivateType.java
Patch:
@@ -13,11 +13,12 @@ static class Type {
         /* empty */
     }
 
-    static interface InterfaceType {
+    interface InterfaceType {
         /* empty */
     }
 
     static class ExceptionType extends Exception {
-        /* empty */
+
+        private static final long serialVersionUID = 1L;
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/AccessControllerRule.java
Patch:
@@ -50,7 +50,7 @@ public Statement apply(Statement base, FrameworkMethod method, Object target) {
     private static class NoOpStatement extends Statement {
 
         public void evaluate() {
-            Logger.getLogger("net.bytebuddy").warning("Ignoring test case: Requires access controller API");
+            Logger.getLogger("net.bytebuddy").info("Omitting test case: Requires access controller API");
         }
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/AgentAttachmentRule.java
Patch:
@@ -62,7 +62,7 @@ private NoOpStatement(String reason) {
         }
 
         public void evaluate() {
-            Logger.getLogger("net.bytebuddy").warning("Ignoring test case: " + reason);
+            Logger.getLogger("net.bytebuddy").info("Omitting test case: " + reason);
         }
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/ClassJnaInjectionAvailableRule.java
Patch:
@@ -25,7 +25,7 @@ public Statement apply(Statement base, FrameworkMethod method, Object target) {
     private static class NoOpStatement extends Statement {
 
         public void evaluate() {
-            Logger.getLogger("net.bytebuddy").info("Ignored test case that can only be executed if class file injection via JNA is available");
+            Logger.getLogger("net.bytebuddy").info("Omitting test case that can only be executed if class file injection via JNA is available");
         }
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/ClassReflectionInjectionAvailableRule.java
Patch:
@@ -25,7 +25,7 @@ public Statement apply(Statement base, FrameworkMethod method, Object target) {
     private static class NoOpStatement extends Statement {
 
         public void evaluate() {
-            Logger.getLogger("net.bytebuddy").info("Ignored test case that can only be executed if class file injection is available");
+            Logger.getLogger("net.bytebuddy").info("Omitting test case that can only be executed if class file injection is available");
         }
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/ClassUnsafeInjectionAvailableRule.java
Patch:
@@ -25,7 +25,7 @@ public Statement apply(Statement base, FrameworkMethod method, Object target) {
     private static class NoOpStatement extends Statement {
 
         public void evaluate() {
-            Logger.getLogger("net.bytebuddy").info("Ignored test case that can only be executed if class file injection via sun.misc.Unsafe is available");
+            Logger.getLogger("net.bytebuddy").info("Omitting test case that can only be executed if class file injection via sun.misc.Unsafe is available");
         }
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/IntegrationRule.java
Patch:
@@ -32,7 +32,7 @@ public Statement apply(Statement base, FrameworkMethod method, Object target) {
     private static class NoOpStatement extends Statement {
 
         public void evaluate() {
-            Logger.getLogger("net.bytebuddy").warning("Ignored test case that is only to be run on the CI server due to long runtime");
+            Logger.getLogger("net.bytebuddy").info("Omitting test case that is only to be run on the CI server due to long runtime");
         }
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/JavaVersionRule.java
Patch:
@@ -76,7 +76,7 @@ private NoOpStatement(int requiredVersion, String sort, Class<?> target) {
         }
 
         public void evaluate() {
-            Logger.getLogger("net.bytebuddy").warning("Ignoring test case: Requires a Java version " +
+            Logger.getLogger("net.bytebuddy").info("Omitting test case: Requires a Java version " +
                     "of " + sort + " " + requiredVersion
                     + (target == void.class ? "" : (" for target " + target)));
         }
@@ -85,7 +85,7 @@ public void evaluate() {
     private static class OpenJ9Statement extends Statement {
 
         public void evaluate() {
-            Logger.getLogger("net.bytebuddy").warning("Ignoring test case: Test not supported on OpenJ9");
+            Logger.getLogger("net.bytebuddy").info("Omitting test case: Test not supported on OpenJ9");
         }
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/NativeSampleRule.java
Patch:
@@ -52,7 +52,7 @@ private NoOpStatement(String error) {
         }
 
         public void evaluate() {
-            Logger.getLogger("net.bytebuddy").warning("Ignored test case that requires the native sample class: " + error);
+            Logger.getLogger("net.bytebuddy").info("Omitting test case that requires the native sample class: " + error);
         }
     }
 }

File: byte-buddy-gradle-plugin/src/test/java/net/bytebuddy/test/utility/IntegrationRule.java
Patch:
@@ -32,7 +32,7 @@ public Statement apply(Statement base, FrameworkMethod method, Object target) {
     private static class NoOpStatement extends Statement {
 
         public void evaluate() throws Throwable {
-            Logger.getLogger("net.bytebuddy").warning("Ignored test case that is only to be run on the CI server due to long runtime");
+            Logger.getLogger("net.bytebuddy").info("Omitting test case that is only to be run on the CI server due to long runtime");
         }
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/DynamicTypeDefaultLoadedTest.java
Patch:
@@ -56,5 +56,8 @@ public void testLoadedTypeDescription() throws Exception {
         assertThat(dynamicType.getLoadedAuxiliaryTypes().size(), is(1));
         assertThat(dynamicType.getLoadedAuxiliaryTypes().keySet(), hasItem(auxiliaryTypeDescription));
         assertThat(dynamicType.getLoadedAuxiliaryTypes().get(auxiliaryTypeDescription), CoreMatchers.<Class<?>>is(AUXILIARY_TYPE));
+        assertThat(dynamicType.getAllLoaded().size(), is(2));
+        assertThat(dynamicType.getAllLoaded().keySet(), hasItem(mainTypeDescription));
+        assertThat(dynamicType.getAllLoaded().keySet(), hasItem(auxiliaryTypeDescription));
     }
 }

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/AbstractByteBuddyTaskConfiguration.java
Patch:
@@ -91,7 +91,7 @@ public void execute(final Project project) {
     }
 
     /**
-     * Configures the direTaskExecutionGraphctories of the compile and Byte Buddy tasks.
+     * Configures the directories of the compile and Byte Buddy tasks.
      *
      * @param source        The source directory set.
      * @param compileTask   The compile task.

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -24,7 +24,6 @@
 import org.objectweb.asm.Opcodes;
 
 import java.io.IOException;
-import java.security.AccessController;
 import java.security.PrivilegedAction;
 
 /**
@@ -157,7 +156,7 @@ protected ClassFileVersion(int versionNumber) {
      */
     @AccessControllerPlugin.Enhance
     private static <T> T doPrivileged(PrivilegedAction<T> action) {
-        return AccessController.doPrivileged(action); // action.run();
+        return action.run();
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -41,7 +41,6 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.*;
-import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.*;
 
@@ -398,7 +397,7 @@ protected ForLoadedExecutable(T executable) {
                  */
                 @AccessControllerPlugin.Enhance
                 private static <T> T doPrivileged(PrivilegedAction<T> action) {
-                    return AccessController.doPrivileged(action); // action.run();
+                    return action.run();
                 }
 
                 /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -37,7 +37,6 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.AbstractList;
 import java.util.Collections;
@@ -270,7 +269,7 @@ protected ForLoadedParameter(T executable, int index, ParameterAnnotationSource
          */
         @AccessControllerPlugin.Enhance
         private static <T> T doPrivileged(PrivilegedAction<T> action) {
-            return AccessController.doPrivileged(action); // action.run();
+            return action.run();
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterList.java
Patch:
@@ -26,7 +26,6 @@
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
-import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -169,7 +168,7 @@ protected ForLoadedExecutable(T executable, ParameterDescription.ForLoadedParame
          */
         @AccessControllerPlugin.Enhance
         private static <T> T doPrivileged(PrivilegedAction<T> action) {
-            return AccessController.doPrivileged(action); // action.run();
+            return action.run();
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/RecordComponentDescription.java
Patch:
@@ -32,7 +32,6 @@
 import java.lang.reflect.GenericSignatureFormatError;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
-import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.Collections;
 import java.util.List;
@@ -206,7 +205,7 @@ protected ForLoadedRecordComponent(AnnotatedElement recordComponent) {
          */
         @AccessControllerPlugin.Enhance
         private static <T> T doPrivileged(PrivilegedAction<T> action) {
-            return AccessController.doPrivileged(action); // action.run();
+            return action.run();
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDefinition.java
Patch:
@@ -24,7 +24,6 @@
 import net.bytebuddy.utility.dispatcher.JavaDispatcher;
 
 import java.lang.reflect.*;
-import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
@@ -228,7 +227,7 @@ enum Sort {
          */
         @AccessControllerPlugin.Enhance
         private static <T> T doPrivileged(PrivilegedAction<T> action) {
-            return AccessController.doPrivileged(action); // action.run();
+            return action.run();
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/NexusAccessor.java
Patch:
@@ -39,7 +39,6 @@
 import java.lang.ref.ReferenceQueue;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
-import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.Arrays;
 import java.util.Collections;
@@ -95,7 +94,7 @@ public NexusAccessor(ReferenceQueue<? super ClassLoader> referenceQueue) {
      */
     @AccessControllerPlugin.Enhance
     private static <T> T doPrivileged(PrivilegedAction<T> action) {
-        return AccessController.doPrivileged(action); // action.run();
+        return action.run();
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -28,7 +28,6 @@
 import java.lang.instrument.ClassFileTransformer;
 import java.lang.instrument.Instrumentation;
 import java.lang.instrument.UnmodifiableClassException;
-import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.security.ProtectionDomain;
 import java.util.*;
@@ -133,7 +132,7 @@ protected ClassReloadingStrategy(Instrumentation instrumentation,
      */
     @AccessControllerPlugin.Enhance
     private static <T> T doPrivileged(PrivilegedAction<T> action) {
-        return AccessController.doPrivileged(action); // action.run();
+        return action.run();
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -63,7 +63,6 @@
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
-import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.security.PrivilegedExceptionAction;
 import java.util.*;
@@ -1928,7 +1927,7 @@ protected Default(TypeDescription instrumentedType,
          */
         @AccessControllerPlugin.Enhance
         private static <T> T doPrivileged(PrivilegedAction<T> action) {
-            return AccessController.doPrivileged(action); // action.run();
+            return action.run();
         }
 
         /**
@@ -1941,7 +1940,7 @@ private static <T> T doPrivileged(PrivilegedAction<T> action) {
          */
         @AccessControllerPlugin.Enhance
         private static <T> T doPrivileged(PrivilegedExceptionAction<T> action) throws Exception {
-            return AccessController.doPrivileged(action); // action.run();
+            return action.run();
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/FileSystem.java
Patch:
@@ -19,7 +19,6 @@
 import net.bytebuddy.utility.dispatcher.JavaDispatcher;
 
 import java.io.*;
-import java.security.AccessController;
 import java.security.PrivilegedAction;
 
 /**
@@ -56,7 +55,7 @@ public enum FileSystem {
      */
     @AccessControllerPlugin.Enhance
     private static <T> T doPrivileged(PrivilegedAction<T> action) {
-        return AccessController.doPrivileged(action); // action.run();
+        return action.run();
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaModule.java
Patch:
@@ -26,7 +26,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.AnnotatedElement;
-import java.security.AccessController;
 import java.security.PrivilegedAction;
 
 /**
@@ -72,7 +71,7 @@ protected JavaModule(AnnotatedElement module) {
      */
     @AccessControllerPlugin.Enhance
     private static <T> T doPrivileged(PrivilegedAction<T> action) {
-        return AccessController.doPrivileged(action); // action.run();
+        return action.run();
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/OpenedClassReader.java
Patch:
@@ -21,7 +21,6 @@
 import org.objectweb.asm.ClassReader;
 import org.objectweb.asm.Opcodes;
 
-import java.security.AccessController;
 import java.security.PrivilegedAction;
 
 /**
@@ -74,7 +73,7 @@ private OpenedClassReader() {
      */
     @AccessControllerPlugin.Enhance
     private static <T> T doPrivileged(PrivilegedAction<T> action) {
-        return AccessController.doPrivileged(action); // action.run();
+        return action.run();
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/dispatcher/JavaDispatcher.java
Patch:
@@ -28,7 +28,6 @@
 
 import java.lang.annotation.*;
 import java.lang.reflect.*;
-import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.security.ProtectionDomain;
 import java.util.HashMap;
@@ -103,7 +102,7 @@ protected JavaDispatcher(Class<T> proxy, ClassLoader classLoader, boolean genera
      */
     @AccessControllerPlugin.Enhance
     private static <T> T doPrivileged(PrivilegedAction<T> action) {
-        return AccessController.doPrivileged(action); // action.run();
+        return action.run();
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -25,7 +25,6 @@
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
-import net.bytebuddy.matcher.ElementMatchers;
 import net.bytebuddy.utility.privilege.SetAccessibleAction;
 
 import java.lang.annotation.*;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -2488,9 +2488,7 @@ protected StackManipulation resolve(MethodDescription interceptedMethod, TypeDes
         DROPPING {
             @Override
             protected StackManipulation resolve(MethodDescription interceptedMethod, TypeDescription returnType, Assigner assigner, Assigner.Typing typing) {
-                return Removal.of(interceptedMethod.isConstructor()
-                        ? interceptedMethod.getDeclaringType()
-                        : interceptedMethod.getReturnType());
+                return Removal.of(returnType);
             }
         };
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -2488,9 +2488,7 @@ protected StackManipulation resolve(MethodDescription interceptedMethod, TypeDes
         DROPPING {
             @Override
             protected StackManipulation resolve(MethodDescription interceptedMethod, TypeDescription returnType, Assigner assigner, Assigner.Typing typing) {
-                return Removal.of(interceptedMethod.isConstructor()
-                        ? interceptedMethod.getDeclaringType()
-                        : interceptedMethod.getReturnType());
+                return Removal.of(returnType);
             }
         };
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/dispatcher/JavaDispatcher.java
Patch:
@@ -267,7 +267,7 @@ public T run() {
                         }
                         exceptions:
                         for (Class<?> type : resolved.getExceptionTypes()) {
-                            if (RuntimeException.class.isAssignableFrom(type)) {
+                            if (RuntimeException.class.isAssignableFrom(type) || Error.class.isAssignableFrom(type)) {
                                 continue;
                             }
                             for (Class<?> exception : method.getExceptionTypes()) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionForLoadedTest.java
Patch:
@@ -33,7 +33,7 @@ protected boolean canReadDebugInformation() {
     @Test
     @Override
     @JavaVersionRule.Enforce(17)
-    @Ignore("Fixed on Java 17 but not yet merged to all builds")
+    @Ignore("Awaiting CI server update for EA versions")
     public void testEnumConstructorAnnotation() throws Exception {
         super.testEnumConstructorAnnotation();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTest.java
Patch:
@@ -46,7 +46,7 @@ protected boolean canReadDebugInformation() {
     @Test
     @Override
     @JavaVersionRule.Enforce(17)
-    @Ignore("Fixed on Java 17 but not yet merged to all builds")
+    @Ignore("Awaiting CI server update for EA versions")
     public void testEnumConstructorAnnotation() throws Exception {
         super.testEnumConstructorAnnotation();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -19,6 +19,7 @@
 import net.bytebuddy.utility.OpenedClassReader;
 import org.hamcrest.CoreMatchers;
 import org.hamcrest.Matcher;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.MethodRule;
@@ -753,6 +754,7 @@ public void testNotSealed() throws Exception {
 
     @Test
     @JavaVersionRule.Enforce(17)
+    @Ignore("Awaiting CI server update for EA versions")
     public void testSealed() throws Exception {
         Class<?> sealed = Class.forName("net.bytebuddy.test.precompiled.Sealed");
         assertThat(describe(sealed).isSealed(), is(true));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -1481,6 +1481,7 @@ public void testNestMates() throws Exception {
     }
 
     @Test
+    @Ignore("Awaiting CI server update for EA versions")
     @JavaVersionRule.Enforce(17)
     public void testPermittedSubclasses() throws Exception {
         TypeDescription sample = new TypeDescription.Latent("foo.Qux",

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultTest.java
Patch:
@@ -1041,7 +1041,7 @@ public void testDiamondInheritanceInterface() throws Exception {
     }
 
     @Test
-    @Ignore("Open issue")
+    @Ignore("Documents known issue")
     public void testDominantInterfaceMethod() throws Exception {
         TypeDescription typeDescription = TypeDescription.ForLoadedType.of(BaseInterface.ExtensionType.class);
         MethodGraph.Linked methodGraph = MethodGraph.Compiler.Default.forJavaHierarchy().compile(typeDescription);

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/AccessControllerPlugin.java
Patch:
@@ -15,6 +15,7 @@
  */
 package net.bytebuddy.build;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.asm.AsmVisitorWrapper;
 import net.bytebuddy.description.method.MethodDescription;
@@ -193,10 +194,11 @@ public Plugin make() {
     /**
      * {@inheritDoc}
      */
+    @SuppressFBWarnings(value = "SBSC_USE_STRINGBUFFER_CONCATENATION", justification = "Collision is unlikely and buffer overhead not justified")
     public DynamicType.Builder<?> apply(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassFileLocator classFileLocator) {
         String name = NAME;
         while (!typeDescription.getDeclaredFields().filter(named(name)).isEmpty()) {
-            name += "$";
+            name = "$";
         }
         return builder
                 .defineField(name, boolean.class, Visibility.PRIVATE, Ownership.STATIC, FieldManifestation.FINAL)

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -184,7 +184,7 @@ public class ByteBuddy {
      * @see ClassFileVersion#ofThisVm(ClassFileVersion)
      */
     public ByteBuddy() {
-        this(ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V6));
+        this(ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5));
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -161,7 +161,7 @@ public void appendPrefix(StringBuilder toString, String key, int count) {
          * Initializes the rendering dispatcher.
          */
         static {
-            ClassFileVersion classFileVersion = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V6);
+            ClassFileVersion classFileVersion = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5);
             if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V14)) {
                 CURRENT = RenderingDispatcher.JAVA_14_CAPABLE_VM;
             } else {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationValue.java
Patch:
@@ -197,7 +197,7 @@ public String toSourceString(TypeDescription value) {
         /**
          * A rendering dispatcher for Java 14 onward.
          */
-        JAVA_14_CAPABLE_VM('{', '}', ClassFileVersion.ofThisVm().isLessThan(ClassFileVersion.JAVA_V17)) {
+        JAVA_14_CAPABLE_VM('{', '}', ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isLessThan(ClassFileVersion.JAVA_V17)) {
             @Override
             public String toSourceString(byte value) {
                 return "(byte)0x" + Integer.toHexString(value & 0xFF);
@@ -257,7 +257,7 @@ public String toSourceString(TypeDescription value) {
         public static final RenderingDispatcher CURRENT;
 
         static {
-            ClassFileVersion classFileVersion = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V6);
+            ClassFileVersion classFileVersion = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5);
             if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V14)) {
                 CURRENT = RenderingDispatcher.JAVA_14_CAPABLE_VM;
             } else if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V9)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -5066,7 +5066,7 @@ protected void apply(StringBuilder stringBuilder, TypeDescription erasure, Gener
                 /**
                  * A rendering delegate for the current VM.
                  */
-                protected static final RenderingDelegate CURRENT = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V6).isAtLeast(ClassFileVersion.JAVA_V8)
+                protected static final RenderingDelegate CURRENT = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isAtLeast(ClassFileVersion.JAVA_V8)
                         ? RenderingDelegate.FOR_JAVA_8_CAPABLE_VM
                         : RenderingDelegate.FOR_LEGACY_VM;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoader.java
Patch:
@@ -451,7 +451,7 @@ public Initializable run() {
                     } catch (Exception ignored) {
                         // On the bootstrap class loader, a lookup instance cannot be located reflectively. To avoid issuing a warning for accessing
                         // a protected method from outside of a class that is caused if the module system does not offer accessing the method.
-                        return ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V9) && ByteArrayClassLoader.class.getClassLoader() == null
+                        return ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isAtLeast(ClassFileVersion.JAVA_V9) && ByteArrayClassLoader.class.getClassLoader() == null
                                 ? SynchronizationStrategy.ForLegacyVm.INSTANCE
                                 : new ForJava7CapableVm(ClassLoader.class.getDeclaredMethod("getClassLoadingLock", String.class));
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -1559,7 +1559,7 @@ public Map<String, Class<?>> injectRaw(Map<? extends String, byte[]> types) {
          * @return {@code true} if the current VM is capable of defining classes using a lookup.
          */
         public static boolean isAvailable() {
-            return ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V9);
+            return ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isAtLeast(ClassFileVersion.JAVA_V9);
         }
 
         /**
@@ -2337,7 +2337,7 @@ public Map<String, Class<?>> injectRaw(Map<? extends String, byte[]> types) {
          * @return {@code true} if this class injector is available on this VM.
          */
         public static boolean isAvailable() {
-            return ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V6);
+            return ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isAtLeast(ClassFileVersion.JAVA_V6);
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -807,8 +807,8 @@ protected ForElementMatcher(TypeDescription instrumentedType, ElementMatcher<? s
             public MethodDescription resolve(TypeDescription targetType, MethodDescription instrumentedMethod) {
                 List<MethodDescription> candidates = CompoundList.<MethodDescription>of(
                         instrumentedType.getSuperClass().getDeclaredMethods().filter(isConstructor().and(matcher)),
-                        instrumentedType.getDeclaredMethods().filter(not(ElementMatchers.isVirtual()).and(not(is(instrumentedMethod))).and(matcher)),
-                        methodGraphCompiler.compile(targetType, instrumentedType).listNodes().asMethodList().filter(not(is(instrumentedMethod)).and(matcher)));
+                        instrumentedType.getDeclaredMethods().filter(not(ElementMatchers.isVirtual()).and(matcher)),
+                        methodGraphCompiler.compile(targetType, instrumentedType).listNodes().asMethodList().filter(matcher));
                 if (candidates.size() == 1) {
                     return candidates.get(0);
                 } else {

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaModule.java
Patch:
@@ -92,7 +92,7 @@ public static JavaModule of(Object module) {
      * @return {@code true} if the current VM supports modules.
      */
     public static boolean isSupported() {
-        return ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V9);
+        return ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isAtLeast(ClassFileVersion.JAVA_V9);
     }
 
     /**

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/ByteBuddyMojo.java
Patch:
@@ -374,7 +374,7 @@ private Plugin.Engine.Summary apply(File root,
                     String javaVersionString = findJavaVersionString(project);
                     ClassFileVersion classFileVersion;
                     if (javaVersionString == null) {
-                        classFileVersion = ClassFileVersion.ofThisVm();
+                        classFileVersion = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5);
                         getLog().warn("Could not locate Java target version, build is JDK dependant: " + classFileVersion.getMajorVersion());
                     } else {
                         classFileVersion = ClassFileVersion.ofJavaVersionString(javaVersionString);

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -345,8 +345,8 @@ public static JavaConstant ofDescription(Object value, TypePool typePool) {
                                 typePool.describe(Type.getType(CLASS_DESC.descriptorString(DIRECT_METHOD_HANDLE_DESC.owner(DYNAMIC_CONSTANT_DESC.bootstrapMethod(value)))).getClassName()).resolve(),
                                 DIRECT_METHOD_HANDLE_DESC.methodName(DYNAMIC_CONSTANT_DESC.bootstrapMethod(value)),
                                 typePool.describe(methodType.getReturnType().getSort() == Type.ARRAY
-                                        ? type.getReturnType().getInternalName().replace('/', '.')
-                                        : type.getReturnType().getClassName()).resolve(),
+                                        ? methodType.getReturnType().getInternalName().replace('/', '.')
+                                        : methodType.getReturnType().getClassName()).resolve(),
                                 parameterTypes),
                         arguments);
             } else {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -807,7 +807,7 @@ protected ForElementMatcher(TypeDescription instrumentedType, ElementMatcher<? s
             public MethodDescription resolve(TypeDescription targetType, MethodDescription instrumentedMethod) {
                 List<MethodDescription> candidates = CompoundList.<MethodDescription>of(
                         instrumentedType.getSuperClass().getDeclaredMethods().filter(isConstructor().and(matcher)),
-                        instrumentedType.getDeclaredMethods().filter(isMethod().and(not(ElementMatchers.isVirtual())).and(matcher)),
+                        instrumentedType.getDeclaredMethods().filter(not(ElementMatchers.isVirtual()).and(not(is(instrumentedMethod))).and(matcher)),
                         methodGraphCompiler.compile(targetType, instrumentedType).listNodes().asMethodList().filter(matcher));
                 if (candidates.size() == 1) {
                     return candidates.get(0);

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/FileSystem.java
Patch:
@@ -52,7 +52,7 @@ public enum FileSystem {
      */
     public void copy(File source, File target) throws IOException {
         Object[] option = STANDARD_COPY_OPTION.toArray(1);
-        if (option == null) {
+        if (option.length == 0) {
             InputStream inputStream = new FileInputStream(source);
             try {
                 OutputStream outputStream = new FileOutputStream(target);
@@ -83,7 +83,7 @@ public void copy(File source, File target) throws IOException {
      */
     public void move(File source, File target) throws IOException {
         Object[] option = STANDARD_COPY_OPTION.toArray(1);
-        if (option == null) {
+        if (option.length == 0) {
             InputStream inputStream = new FileInputStream(source);
             try {
                 OutputStream outputStream = new FileOutputStream(target);

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/FileSystemTest.java
Patch:
@@ -6,8 +6,8 @@
 
 import java.io.*;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 
 public class FileSystemTest {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -217,7 +217,7 @@ public static JavaConstant ofDescription(Object value, TypePool typePool) {
                 Type methodType = Type.getMethodType(DIRECT_METHOD_HANDLE_DESC.lookupDescriptor(DYNAMIC_CONSTANT_DESC.bootstrapMethod(value)));
                 List<TypeDescription> parameterTypes = new ArrayList<TypeDescription>(methodType.getArgumentTypes().length);
                 for (Type type : methodType.getArgumentTypes()) {
-                    parameterTypes.add(typePool.describe(methodType.getReturnType().getClassName()).resolve());
+                    parameterTypes.add(typePool.describe(type.getClassName()).resolve());
                 }
                 Object[] constant = DYNAMIC_CONSTANT_DESC.bootstrapArgs(value);
                 List<JavaConstant> arguments = new ArrayList<JavaConstant>(constant.length);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -812,8 +812,9 @@ public MethodDescription resolve(TypeDescription targetType, MethodDescription i
                 if (candidates.size() == 1) {
                     return candidates.get(0);
                 } else {
-                    throw new IllegalStateException(instrumentedType + " does not define exactly one virtual method or constructor for " + matcher +
-                            ", " + candidates.size() + " matched");
+                    throw new IllegalStateException(instrumentedType + " does not define exactly one virtual method or constructor for " + matcher
+                            + " but contained " + candidates.size()
+                            + " candidates: " + candidates);
                 }
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -413,6 +413,7 @@ protected interface Executable {
                  * @param value The {@code java.lang.reflect.Executable} to resolve.
                  * @return An instance of {@code java.lang.reflect.AnnotatedType} that represents the receiver of the supplied executable.
                  */
+                @JavaDispatcher.Defaults
                 AnnotatedElement getAnnotatedReceiverType(Object value);
             }
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -1575,7 +1575,7 @@ protected interface MethodHandles {
              * @param lookup The lookup to resolve.
              * @return An appropriate lookup instance.
              */
-            @JavaDispatcher.Static
+            @JavaDispatcher.IsStatic
             Object privateLookupIn(Class<?> type, @JavaDispatcher.Proxied("java.lang.invoke.MethodHandles$Lookup") Object lookup);
 
             /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaDispatcherTest.java
Patch:
@@ -124,21 +124,21 @@ public void testDeclaredException() throws Exception {
     @JavaDispatcher.Proxied("java.lang.Class")
     public interface StaticSample {
 
-        @JavaDispatcher.Static
+        @JavaDispatcher.IsStatic
         Class<?> forName(String name);
     }
 
     @JavaDispatcher.Proxied("java.lang.Class")
     public interface StaticAdjustedSample {
 
-        @JavaDispatcher.Static
+        @JavaDispatcher.IsStatic
         Class<?> forName(@JavaDispatcher.Proxied("java.lang.String") Object name);
     }
 
     @JavaDispatcher.Proxied("java.lang.Class")
     public interface StaticAdjustedIllegalSample {
 
-        @JavaDispatcher.Static
+        @JavaDispatcher.IsStatic
         Class<?> forName(@JavaDispatcher.Proxied("java.lang.String") Void name);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaDispatcher.java
Patch:
@@ -15,6 +15,7 @@
  */
 package net.bytebuddy.utility;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.build.HashCodeAndEqualsPlugin;
 import net.bytebuddy.description.method.MethodDescription;
@@ -972,9 +973,10 @@ protected ProxiedClassLoader(ClassLoader parent) {
          * @param dispatchers The dispatchers to implement.
          * @return An instance of the proxied type.
          */
+        @SuppressFBWarnings(value = {"REC_CATCH_EXCEPTION", "DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED"}, justification = "Expected internal invocation")
         protected static Object proxy(Class<?> proxy, Map<Method, Dispatcher> dispatchers) {
             ClassWriter classWriter = new ClassWriter(0);
-            classWriter.visit(ClassFileVersion.ofThisVm().getMinorMajorVersion(),
+            classWriter.visit(ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).getMinorMajorVersion(),
                     Opcodes.ACC_PUBLIC,
                     Type.getInternalName(proxy) + "$Proxy",
                     null,

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaDispatcher.java
Patch:
@@ -416,7 +416,6 @@ public int apply(MethodVisitor methodVisitor, Method method) {
         /**
          * A dispatcher that returns a fixed value.
          */
-        @HashCodeAndEqualsPlugin.Enhance
         enum ForDefaultValue implements Dispatcher {
 
             /**
@@ -877,6 +876,7 @@ public int apply(MethodVisitor methodVisitor, Method method) {
     /**
      * An invocation handler that invokes given dispatchers.
      */
+    @HashCodeAndEqualsPlugin.Enhance
     protected static class ProxiedInvocationHandler implements InvocationHandler {
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaDispatcher.java
Patch:
@@ -752,7 +752,7 @@ public int apply(MethodVisitor methodVisitor, Method method) {
                         Type.getInternalName(this.method.getDeclaringClass()),
                         this.method.getName(),
                         Type.getMethodDescriptor(this.method),
-                        false);
+                        this.method.getDeclaringClass().isInterface());
                 methodVisitor.visitInsn(Type.getReturnType(this.method).getOpcode(Opcodes.IRETURN));
                 return Math.max(offset - 1, Type.getReturnType(this.method).getSize());
             }
@@ -806,10 +806,10 @@ public int apply(MethodVisitor methodVisitor, Method method) {
                 for (int index = 0; index < source.length; index++) {
                     Type type = Type.getType(source[index]);
                     methodVisitor.visitVarInsn(type.getOpcode(Opcodes.ILOAD), offset);
-                    if (source[index] != (index == 0 ? this.method.getDeclaringClass() : target[index + 1])) {
+                    if (source[index] != (index == 0 ? this.method.getDeclaringClass() : target[index - 1])) {
                         methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(index == 0
                                 ? this.method.getDeclaringClass()
-                                : target[index + 1]));
+                                : target[index - 1]));
                     }
                     offset += type.getSize();
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -23,12 +23,15 @@
 import net.bytebuddy.description.annotation.AnnotationList;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.matcher.ElementMatcher;
+import net.bytebuddy.utility.JavaDispatcher;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.signature.SignatureWriter;
 
+import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Field;
 import java.lang.reflect.GenericSignatureFormatError;
 import java.lang.reflect.Modifier;
+import java.security.AccessController;
 import java.util.Collections;
 import java.util.List;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -2052,7 +2052,7 @@ abstract class AbstractBase<V> extends MethodDefinition.AbstractBase<V> implemen
                      * {@inheritDoc}
                      */
                     public MethodDefinition<V> receiverType(AnnotatedElement receiverType) {
-                        return receiverType(TypeDescription.Generic.AnnotationReader.DISPATCHER.resolve(receiverType));
+                        return receiverType(TypeDefinition.Sort.describeAnnotated(receiverType));
                     }
                 }
             }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -19,7 +19,6 @@
 import net.bytebuddy.utility.OpenedClassReader;
 import org.hamcrest.CoreMatchers;
 import org.hamcrest.Matcher;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.MethodRule;
@@ -750,7 +749,7 @@ public void testNonEnclosedAnonymousType() throws Exception {
     @Test
     public void testNotSealed() throws Exception {
         assertThat(describe(SampleClass.class).isSealed(), is(false));
-        assertThat(describe(SampleClass.class).getPermittedSubclasses(), nullValue(TypeList.class));
+        assertThat(describe(SampleClass.class).getPermittedSubtypes().isEmpty(), is(true));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -8851,7 +8851,7 @@ public Generic asGenericType() {
          */
         public TypeDescription getNestHost() {
             Class<?> host = DISPATCHER.getNestHost(type);
-            return TypeDescription.ForLoadedType.of(host == null ? type : host);
+            return host == null ? this : TypeDescription.ForLoadedType.of(host);
         }
 
         /**
@@ -8904,7 +8904,7 @@ public TypeList getPermittedSubclasses() {
             Class<?>[] subclass = DISPATCHER.getPermittedSubclasses(type);
             return subclass == null
                     ? new TypeList.Empty()
-                    : new TypeList.ForLoadedTypes(type);
+                    : new TypeList.ForLoadedTypes(subclass);
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationValue.java
Patch:
@@ -2537,14 +2537,14 @@ public Sort getSort() {
          * {@inheritDoc}
          */
         public AnnotationValue<U, V> filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
-            return this;
+            return new ForMismatchedType<>(property, value);
         }
 
         /**
          * {@inheritDoc}
          */
         public U resolve() {
-            throw new IllegalStateException(property + " cannot define " + value);
+            throw new IllegalStateException(value + " cannot be used as value for " + property);
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -6390,7 +6390,6 @@ protected AnnotationValue<Object, Object> doResolve() {
                         } else if (resolution.resolve().represents(double.class)) {
                             return new AnnotationValue.ForDescriptionArray<Object, Object>(double.class, resolution.resolve(), values);
                         } else {
-
                             MethodDescription.InDefinedShape property = typePool.describe(Type.getType(descriptor).getClassName())
                                     .resolve()
                                     .getDeclaredMethods()

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -6208,7 +6208,7 @@ protected AnnotationValue<AnnotationDescription, Annotation> doResolve() {
                                         .resolve()
                                         .getDeclaredMethods()
                                         .filter(named(property).and(takesArguments(0)))
-                                        .getOnly(), null); // missing: value
+                                        .getOnly(), resolution.resolve().getAnnotationType().getName());
                             }
                         } else {
                             return new AnnotationValue.ForAnnotationDescription<Annotation>(resolution.resolve());
@@ -6275,7 +6275,7 @@ protected AnnotationValue<EnumerationDescription, Enum<?>> doResolve() {
                                     .resolve()
                                     .getDeclaredMethods()
                                     .filter(named(property).and(takesArguments(0)))
-                                    .getOnly(), "L" + typeName.replace('.', '/') + ";." + value);
+                                    .getOnly(), typeName + "." + value);
                         } else if (resolution.resolve().getDeclaredFields().filter(named(value)).isEmpty()) {
                             return new AnnotationValue.ForEnumerationDescription.WithUnknownConstant(resolution.resolve(), value);
                         } else {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AnnotationValueForConstantTest.java
Patch:
@@ -4,8 +4,10 @@
 
 public class AnnotationValueForConstantTest {
 
+    /* TODO: Propert test
     @Test(expected = IllegalArgumentException.class)
     public void testIllegalArgument() throws Exception {
         AnnotationValue.ForConstant.of(new Object());
     }
+     */
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -5422,7 +5422,7 @@ protected String getBinaryName() {
                  */
                 private Resolution toAnnotationDescription(TypePool typePool) {
                     TypePool.Resolution resolution = typePool.describe(getBinaryName());
-                    return resolution.isResolved() && resolution.resolve().isAnnotation()
+                    return resolution.isResolved()
                             ? new Resolution.Simple(new LazyAnnotationDescription(typePool, resolution.resolve(), values))
                             : new Resolution.Illegal(getBinaryName());
                 }
@@ -5983,7 +5983,7 @@ protected static AnnotationList asList(TypePool typePool, List<? extends Annotat
                     List<AnnotationDescription> annotationDescriptions = new ArrayList<AnnotationDescription>(tokens.size());
                     for (AnnotationToken token : tokens) {
                         AnnotationToken.Resolution resolution = token.toAnnotationDescription(typePool);
-                        if (resolution.isResolved()) {
+                        if (resolution.isResolved() && resolution.resolve().getAnnotationType().isAnnotation()) {
                             annotationDescriptions.add(resolution.resolve());
                         }
                     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AbstractAnnotationDescriptionTest.java
Patch:
@@ -185,6 +185,7 @@ public void setUp() throws Exception {
                         ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V17),
                         ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V17)))
                 .make()
+                .include(new ByteBuddy().decorate(DefectiveAnnotation.class).make())
                 .include(new ByteBuddy().subclass(Object.class).name(BrokenAnnotationProperty.class.getName()).make())
                 .include(new ByteBuddy().subclass(Object.class).name(BrokenEnumerationProperty.class.getName()).make())
                 .load(getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST_PERSISTENT)

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -5422,7 +5422,7 @@ protected String getBinaryName() {
                  */
                 private Resolution toAnnotationDescription(TypePool typePool) {
                     TypePool.Resolution resolution = typePool.describe(getBinaryName());
-                    return resolution.isResolved()
+                    return resolution.isResolved() && resolution.resolve().isAnnotation()
                             ? new Resolution.Simple(new LazyAnnotationDescription(typePool, resolution.resolve(), values))
                             : new Resolution.Illegal(getBinaryName());
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationValue.java
Patch:
@@ -2417,7 +2417,7 @@ class ForMismatchedType<U, V> extends AbstractBase<U, V> {
         private final String value;
 
         /**
-         * Creates an annotation description for a mismatched typeName.
+         * Creates an annotation description for a mismatched type.
          *
          * @param property The property that does not defines a non-matching value.
          * @param value    A value description of the property.

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionForLoadedTest.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.description.method;
 
-import org.junit.Ignore;
+import net.bytebuddy.test.utility.JavaVersionRule;
 import org.junit.Test;
 
 import java.lang.reflect.Constructor;
@@ -31,7 +31,7 @@ protected boolean canReadDebugInformation() {
 
     @Test
     @Override
-    @Ignore("The JVM does not currently consider synthetic parameter indices for annotations")
+    @JavaVersionRule.Enforce(17)
     public void testEnumConstructorAnnotation() throws Exception {
         super.testEnumConstructorAnnotation();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTest.java
Patch:
@@ -4,7 +4,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.matcher.ElementMatchers;
-import org.junit.Ignore;
+import net.bytebuddy.test.utility.JavaVersionRule;
 import org.junit.Test;
 
 import java.lang.reflect.Constructor;
@@ -44,7 +44,7 @@ protected boolean canReadDebugInformation() {
 
     @Test
     @Override
-    @Ignore("The JVM does not currently consider synthetic parameter indices for annotations")
+    @JavaVersionRule.Enforce(17)
     public void testEnumConstructorAnnotation() throws Exception {
         super.testEnumConstructorAnnotation();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/BooleanMatcherTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.junit.Test;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.mock;
@@ -36,7 +37,7 @@ public void testToString() throws Exception {
 
     @Test
     public void testSingletonEquivalentToNewInstance() {
-        assertThat(BooleanMatcher.of(true), is((ElementMatcher.Junction<Object>) new BooleanMatcher<Object>(true)));
-        assertThat(BooleanMatcher.of(false), is((ElementMatcher.Junction<Object>) new BooleanMatcher<Object>(false)));
+        assertThat(BooleanMatcher.of(true), hasPrototype((ElementMatcher.Junction<Object>) new BooleanMatcher<Object>(true)));
+        assertThat(BooleanMatcher.of(false), hasPrototype((ElementMatcher.Junction<Object>) new BooleanMatcher<Object>(false)));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/MethodSortMatcherTest.java
Patch:
@@ -9,6 +9,7 @@
 import java.util.Arrays;
 import java.util.Collection;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.when;
@@ -61,7 +62,7 @@ public void testStringRepresentation() throws Exception {
 
     @Test
     public void testSingletonIsEquivalentToNewInstance() {
-        assertThat(MethodSortMatcher.of(sort), is((ElementMatcher.Junction<MethodDescription>) new MethodSortMatcher<MethodDescription>(sort)));
+        assertThat(MethodSortMatcher.of(sort), hasPrototype((ElementMatcher.Junction<MethodDescription>) new MethodSortMatcher<MethodDescription>(sort)));
     }
 
     private enum MockImplementation {

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/ModifierMatcherTest.java
Patch:
@@ -10,6 +10,7 @@
 import java.util.Arrays;
 import java.util.Collection;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.*;
@@ -76,6 +77,6 @@ public void testStringRepresentation() throws Exception {
 
     @Test
     public void testSingletonEquivalentToNewInstance() {
-        assertThat(ModifierMatcher.of(mode), is((ElementMatcher.Junction<ModifierReviewable>) new ModifierMatcher<ModifierReviewable>(mode)));
+        assertThat(ModifierMatcher.of(mode), hasPrototype((ElementMatcher.Junction<ModifierReviewable>) new ModifierMatcher<ModifierReviewable>(mode)));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/NullMatcherTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.junit.Test;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 
@@ -24,6 +25,6 @@ public void testPositiveToNegative() throws Exception {
 
     @Test
     public void testSingletonIsEquivalentToNewInstance() {
-        assertThat(NullMatcher.make(), is((ElementMatcher.Junction<Object>) new NullMatcher<Object>()));
+        assertThat(NullMatcher.make(), hasPrototype((ElementMatcher.Junction<Object>) new NullMatcher<Object>()));
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -3096,7 +3096,9 @@ public StackManipulation prepare() {
              * {@inheritDoc}
              */
             public StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
-                StackManipulation stackManipulation = assigner.assign(invokedMethod.getReturnType(), fieldDescription.getType(), typing);
+                StackManipulation stackManipulation = assigner.assign(invokedMethod.isConstructor()
+                        ? invokedMethod.getDeclaringType().asGenericType()
+                        : invokedMethod.getReturnType(), fieldDescription.getType(), typing);
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot assign result of " + invokedMethod + " to " + fieldDescription);
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -3096,7 +3096,9 @@ public StackManipulation prepare() {
              * {@inheritDoc}
              */
             public StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
-                StackManipulation stackManipulation = assigner.assign(invokedMethod.getReturnType(), fieldDescription.getType(), typing);
+                StackManipulation stackManipulation = assigner.assign(invokedMethod.isConstructor()
+                        ? invokedMethod.getDeclaringType().asGenericType()
+                        : invokedMethod.getReturnType(), fieldDescription.getType(), typing);
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot assign result of " + invokedMethod + " to " + fieldDescription);
                 }

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/ByteBuddyTask.java
Patch:
@@ -18,6 +18,7 @@
 import net.bytebuddy.build.Plugin;
 import net.bytebuddy.build.gradle.api.*;
 import org.gradle.api.file.ConfigurableFileCollection;
+import org.gradle.api.tasks.InputFiles;
 import org.gradle.api.tasks.InputDirectory;
 import org.gradle.api.tasks.OutputDirectory;
 import org.gradle.api.tasks.TaskAction;
@@ -68,7 +69,7 @@ public ByteBuddyTask() {
      *
      * @return The class path to supply to the plugin engine.
      */
-    @Incremental
+    @InputFiles
     @CompileClasspath
     public abstract ConfigurableFileCollection getClassPath();
 

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -1040,7 +1040,7 @@ public Response execute(String protocol, String... argument) {
                                 if (!library.GetExitCodeThread(thread, exitCode)) {
                                     throw new Win32Exception(Native.getLastError());
                                 } else if (exitCode.getValue() != 0) {
-                                    throw new IllegalStateException("Target could not dispatch command successfully");
+                                    throw new IllegalStateException("Target VM could not dispatch command successfully: " + exitCode.getValue());
                                 }
                                 if (!Kernel32.INSTANCE.ConnectNamedPipe(pipe, null)) {
                                     int code = Native.getLastError();

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaConstantSimpleTest.java
Patch:
@@ -50,4 +50,4 @@ public void testValueWrap() {
     public void testTypeMatchesConstant() {
         assertThat(JavaConstant.Simple.wrap(value).getTypeDescription(), is(typeDescription));
     }
-}
\ No newline at end of file
+}

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -8852,7 +8852,7 @@ public RecordComponentList<RecordComponentDescription.InDefinedShape> getRecordC
             Object[] recordComponent = RecordComponentDescription.ForLoadedRecordComponent.DISPATCHER.getRecordComponents(type);
             return recordComponent == null
                     ? new RecordComponentList.Empty<RecordComponentDescription.InDefinedShape>()
-                    : new RecordComponentList.ForLoadedRecordComponents();
+                    : new RecordComponentList.ForLoadedRecordComponents(recordComponent);
         }
 
         /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/LegacyGetPackageClassLoader.java
Patch:
@@ -15,6 +15,7 @@ public LegacyGetPackageClassLoader() {
     }
 
     @Override
+    @SuppressWarnings("deprecation")
     protected Package definePackage(String name, Manifest man, URL url) throws IllegalArgumentException {
         if (getPackage(name) != null) {
             throw new IllegalArgumentException(name);

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/AbstractByteBuddyTask.java
Patch:
@@ -322,7 +322,7 @@ protected void doApply(Plugin.Engine.Source source, Plugin.Engine.Target target)
         if (transformers.isEmpty()) {
             getLogger().warn("No transformations are specified or discovered. Skipping plugin application.");
         } else {
-            getLogger().debug("{} plugins are being applied via configuration and discovery", transformers.size());
+            getLogger().debug("{} plugins are being applied via configuration and discovery", transformations.size());
         }
         List<Plugin.Factory> factories = new ArrayList<Plugin.Factory>(transformations.size());
         for (Transformation transformation : transformations) {

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/ByteBuddyMojo.java
Patch:
@@ -216,10 +216,10 @@ public void execute() throws MojoExecutionException, MojoFailureException {
                         }
                     }
                     source = new Plugin.Engine.Source.Filtering(new Plugin.Engine.Source.ForFolder(new File(getOutputDirectory())), new FilePrefixMatcher(names));
-                    getLog().info("Incrementally processing: " + names.toString());
+                    getLog().debug("Incrementally processing: " + names.toString());
                 } else {
                     source = new Plugin.Engine.Source.ForFolder(new File(getOutputDirectory()));
-                    getLog().info("Cannot build incrementally - all names are processed");
+                    getLog().debug("Cannot build incrementally - all class files are processed");
                 }
                 Plugin.Engine.Summary summary = apply(new File(getOutputDirectory()), getClassPathElements(), source);
                 for (TypeDescription typeDescription : summary.getTransformed()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -37,6 +37,7 @@
 import net.bytebuddy.implementation.bytecode.member.MethodReturn;
 import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
 import net.bytebuddy.matcher.ElementMatcher;
+import net.bytebuddy.matcher.ElementMatchers;
 import net.bytebuddy.utility.CompoundList;
 import net.bytebuddy.utility.JavaConstant;
 import net.bytebuddy.utility.JavaType;
@@ -806,6 +807,7 @@ protected ForElementMatcher(TypeDescription instrumentedType, ElementMatcher<? s
             public MethodDescription resolve(TypeDescription targetType, MethodDescription instrumentedMethod) {
                 List<MethodDescription> candidates = CompoundList.<MethodDescription>of(
                         instrumentedType.getSuperClass().getDeclaredMethods().filter(isConstructor().and(matcher)),
+                        instrumentedType.getDeclaredMethods().filter(isMethod().and(not(ElementMatchers.isVirtual()))),
                         methodGraphCompiler.compile(targetType, instrumentedType).listNodes().asMethodList().filter(matcher));
                 if (candidates.size() == 1) {
                     return candidates.get(0);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassInjectorUsingReflectionTest.java
Patch:
@@ -62,9 +62,9 @@ public void testInjection() throws Exception {
     public void testInjectionOnLegacyClassloader() throws Exception {
         ClassLoader classLoader = new LegacyGetPackageClassLoader();
         new ClassInjector.UsingReflection(classLoader.getParent()).inject(Collections.singletonMap(TypeDescription.ForLoadedType.of(Foo.class),
-            ClassFileLocator.ForClassLoader.read(Foo.class)));
+                ClassFileLocator.ForClassLoader.read(Foo.class)));
         new ClassInjector.UsingReflection(classLoader).inject(Collections.singletonMap(TypeDescription.ForLoadedType.of(Foo.class),
-            ClassFileLocator.ForClassLoader.read(Foo.class)));
+                ClassFileLocator.ForClassLoader.read(Foo.class)));
         assertThat(classLoader.loadClass(Foo.class.getName()).getClassLoader(), is(classLoader));
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -681,6 +681,9 @@ public Composable setsDefaultValue() {
          * {@inheritDoc}
          */
         public Composable setsValue(Object value) {
+            if (value == null) {
+                return setsDefaultValue();
+            }
             Class<?> type = value.getClass();
             if (type == String.class) {
                 return setsValue(new TextConstant((String) value), String.class);

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -7726,7 +7726,7 @@ public void visit(int classFileVersion,
 
             @Override
             public void visitOuterClass(String typeName, String methodName, String methodDescriptor) {
-                if (methodName != null) {
+                if (methodName != null && !methodName.equals(MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME)) {
                     typeContainment = new LazyTypeDescription.TypeContainment.WithinMethod(typeName, methodName, methodDescriptor);
                 } else if (typeName != null) {
                     typeContainment = new LazyTypeDescription.TypeContainment.WithinType(typeName, true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultTest.java
Patch:
@@ -11,6 +11,7 @@
 import net.bytebuddy.implementation.LoadedTypeInitializer;
 import net.bytebuddy.matcher.ElementMatchers;
 import net.bytebuddy.test.utility.JavaVersionRule;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.MethodRule;
@@ -1040,6 +1041,7 @@ public void testDiamondInheritanceInterface() throws Exception {
     }
 
     @Test
+    @Ignore("Open issue")
     public void testDominantInterfaceMethod() throws Exception {
         TypeDescription typeDescription = TypeDescription.ForLoadedType.of(BaseInterface.ExtensionType.class);
         MethodGraph.Linked methodGraph = MethodGraph.Compiler.Default.forJavaHierarchy().compile(typeDescription);

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -1610,7 +1610,7 @@ public static Dynamic ofInvocation(MethodDescription.InDefinedShape methodDescri
                     methodDescription.getDeclaringType().getInternalName(),
                     methodDescription.getInternalName(),
                     methodDescription.getDescriptor(),
-                    false));
+                    methodDescription.getDeclaringType().isInterface()));
             Iterator<TypeDescription> iterator = (methodDescription.isStatic() || methodDescription.isConstructor()
                     ? methodDescription.getParameters().asTypeList().asErasures()
                     : CompoundList.of(methodDescription.getDeclaringType(), methodDescription.getParameters().asTypeList().asErasures())).iterator();

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -1610,7 +1610,7 @@ public static Dynamic ofInvocation(MethodDescription.InDefinedShape methodDescri
                     methodDescription.getDeclaringType().getInternalName(),
                     methodDescription.getInternalName(),
                     methodDescription.getDescriptor(),
-                    false));
+                    methodDescription.getDeclaringType().isInterface()));
             Iterator<TypeDescription> iterator = (methodDescription.isStatic() || methodDescription.isConstructor()
                     ? methodDescription.getParameters().asTypeList().asErasures()
                     : CompoundList.of(methodDescription.getDeclaringType(), methodDescription.getParameters().asTypeList().asErasures())).iterator();

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaConstantDynamicTest.java
Patch:
@@ -494,7 +494,7 @@ public void testInvocationOfVarargsMethod() throws Exception {
         assertThat(baz.getDeclaredFields().length, is(0));
         assertThat(baz.getDeclaredMethods().length, is(1));
         Foo foo = baz.getDeclaredConstructor().newInstance();
-        assertThat(baz.getDeclaredMethod(FOO).invoke(foo), equalTo(sourceIntegers));
+        assertThat((Integer[])baz.getDeclaredMethod(FOO).invoke(foo), equalTo(sourceIntegers));
         assertThat(baz.getDeclaredMethod(FOO).invoke(foo), sameInstance(baz.getDeclaredMethod(FOO).invoke(foo)));
     }
 

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/ByteBuddyPlugin.java
Patch:
@@ -63,6 +63,7 @@ public class ByteBuddyPlugin implements Plugin<Project> {
      * {@inheritDoc}
      */
     public void apply(Project project) {
+        project.getLogger().debug("Applying Byte Buddy Gradle plugin (legacy mode: {})", DISPATCHER instanceof Dispatcher.ForLegacyGradle);
         project.getPluginManager().apply(JavaBasePlugin.class);
         JavaPluginConvention convention = project.getConvention().findPlugin(JavaPluginConvention.class);
         if (convention == null) {

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/api/DirectoryProperty.java
Patch:
@@ -45,7 +45,7 @@ public interface DirectoryProperty extends Provider<Directory> {
      * @param path The method's argument.
      * @return The method's return value.
      */
-    DirectoryProperty dir(String path);
+    Provider<Directory> dir(String path);
 
     /**
      * A placeholder representation of Gradle's {@code org.gradle.api.file.DirectoryProperty#set} method.

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/ByteBuddyPlugin.java
Patch:
@@ -66,7 +66,7 @@ public void apply(Project project) {
         project.getPluginManager().apply(JavaBasePlugin.class);
         JavaPluginConvention convention = (JavaPluginConvention) project.getConvention().getPlugins().get("java");
         if (convention == null) {
-            project.getLogger().info("Not setting up explicit Byte Buddy configurations since Java plugin was not registered");
+            project.getLogger().warn("Not setting up explicit Byte Buddy configurations since Java plugin did not register convention");
         } else {
             for (SourceSet sourceSet : convention.getSourceSets()) {
                 String name = sourceSet.getName().equals("main") ? "byteBuddy" : (sourceSet.getName() + "ByteBuddy");

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -119,7 +119,7 @@ public class ClassFileVersion implements Comparable<ClassFileVersion> {
     /**
      * The class file version of Java 16.
      */
-    public static final ClassFileVersion JAVA_V16 = new ClassFileVersion(Opcodes.V16);
+    public static final ClassFileVersion JAVA_V16 = new ClassFileVersion(Opcodes.V15 + 1);
 
     /**
      * A version locator for the executing JVM.

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -7813,10 +7813,10 @@ public RecordComponentVisitor visitRecordComponent(String name, String descripto
                 return new RecordComponentExtractor(name, descriptor, signature);
             }
 
-            @Override
+            /*@Override
             public void visitPermittedSubclass(String permittedSubclass) {
                 permittedSubclasses.add(permittedSubclass);
-            }
+            }*/
 
             /**
              * Creates a type description from all data that is currently collected. This method should only be invoked

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/OpenedClassReader.java
Patch:
@@ -53,7 +53,7 @@ public class OpenedClassReader {
             experimental = false;
         }
         EXPERIMENTAL = experimental;
-        ASM_API = Opcodes.ASM9;
+        ASM_API = Opcodes.ASM8;
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/MetadataAwareClassVisitor.java
Patch:
@@ -162,7 +162,7 @@ protected void onVisitNestHost(String nestHost) {
         super.visitNestHost(nestHost);
     }
 
-    @Override
+    /*@Override
     public final void visitPermittedSubclass(String permittedSubclass) {
         onVisitPermittedSubclass(permittedSubclass);
     }
@@ -171,10 +171,10 @@ public final void visitPermittedSubclass(String permittedSubclass) {
      * An order-sensitive invocation of {@code ClassVisitor#visitPermittedSubclass}.
      *
      * @param permittedSubclass The internal name of the permitted subclass.
-     */
+     *//*
     protected void onVisitPermittedSubclass(String permittedSubclass) {
         super.visitPermittedSubclass(permittedSubclass);
-    }
+    }*/
 
     @Override
     public final void visitOuterClass(String owner, String name, String descriptor) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/ClassFileVersionKnownVersionsTest.java
Patch:
@@ -73,7 +73,7 @@ public static Collection<Object[]> data() {
                 {13, 13, Arrays.asList("1.13", "13"), Opcodes.V13, (short) 57, (short) 0, true, true, true},
                 {14, 14, Arrays.asList("1.14", "14"), Opcodes.V14, (short) 58, (short) 0, true, true, true},
                 {15, 15, Arrays.asList("1.15", "15"), Opcodes.V15, (short) 59, (short) 0, true, true, true},
-                {16, 16, Arrays.asList("1.16", "16"), Opcodes.V16, (short) 60, (short) 0, true, true, true}
+                {16, 16, Arrays.asList("1.16", "16"), Opcodes.V15 + 1, (short) 60, (short) 0, true, true, true}
         });
     }
 

File: byte-buddy-gradle-plugin/buildSrc/src/main/java/net/bytebuddy/build/gradle/transform/GradleTypeTransformer.java
Patch:
@@ -173,7 +173,7 @@ protected GradlePackageVisitor(String type, Map<String, String> names) {
          * @throws IOException If an I/O exception occurs.
          */
         protected static Map<String, String> toGradleTypeNames(String api, String type, File jar) throws IOException {
-            Map<String, String> names = new HashMap<>();
+            Map<String, String> names = new HashMap<String, String>();
             JarInputStream jarInputStream = new JarInputStream(new FileInputStream(jar));
             try {
                 JarEntry entry;

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultNativeApplicationTest.java
Patch:
@@ -41,7 +41,7 @@ public class AgentBuilderDefaultNativeApplicationTest {
     public MethodRule nativeSampleRule = new NativeSampleRule();
 
     @Rule
-    private MethodRule javaVersionRule = new JavaVersionRule();
+    public MethodRule javaVersionRule = new JavaVersionRule();
 
     private ClassLoader classLoader;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolver.java
Patch:
@@ -312,8 +312,8 @@ public TypeDescription getDeclaringType() {
                 public int getModifiers() {
                     return Opcodes.ACC_SYNTHETIC
                             | (methodDescription.isStatic() ? Opcodes.ACC_STATIC : EMPTY_MASK)
-                            | (methodDescription.isNative() ? Opcodes.ACC_NATIVE : EMPTY_MASK)
-                            | (instrumentedType.isInterface() ? Opcodes.ACC_PUBLIC : Opcodes.ACC_PRIVATE);
+                            | (methodDescription.isNative() ? Opcodes.ACC_NATIVE | Opcodes.ACC_FINAL : EMPTY_MASK)
+                            | (instrumentedType.isInterface() && !methodDescription.isNative() ? Opcodes.ACC_PUBLIC : Opcodes.ACC_PRIVATE);
                 }
 
                 /**

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/ByteBuddySimpleTask.java
Patch:
@@ -56,7 +56,7 @@ public ByteBuddySimpleTask() {
      *
      * @return The task's source folder.
      */
-    @InputFile
+    @InputDirectory
     public File getSource() {
         return source;
     }
@@ -75,7 +75,7 @@ public void setSource(File source) {
      *
      * @return The task's target folder.
      */
-    @OutputFile
+    @OutputDirectory
     public File getTarget() {
         return target;
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -8926,6 +8926,7 @@ enum CreationAction implements PrivilegedAction<Dispatcher> {
                 /**
                  * {@inheritDoc}
                  */
+                @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but trigger a fallback")
                 public Dispatcher run() {
                     try {
                         try {

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/ByteBuddySimpleTask.java
Patch:
@@ -133,6 +133,9 @@ protected Iterable<File> classPath() {
      */
     @TaskAction
     public void apply() throws IOException {
+        if (getProject().delete(getProject().fileTree(getTarget()))) {
+            getLogger().debug("Deleted all target files in {}", getTarget());
+        }
         doApply(getSource().isDirectory()
                 ? new Plugin.Engine.Source.ForFolder(getSource())
                 : new Plugin.Engine.Source.ForJarFile(getSource()), getTarget().isDirectory()

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/ByteBuddyTask.java
Patch:
@@ -116,16 +116,16 @@ protected Iterable<File> classPath() {
     @TaskAction
     public void apply(InputChanges inputChanges) throws IOException {
         Plugin.Engine.Source source;
-        if (inputChanges.isIncremental() && incrementalResolver != null) {
+        if (inputChanges.isIncremental() && getIncrementalResolver() != null) {
             getLogger().debug("Applying incremental build");
-            source = new IncrementalSource(source(), incrementalResolver.apply(getProject(),
+            source = new IncrementalSource(source(), getIncrementalResolver().apply(getProject(),
                     inputChanges.getFileChanges(getSource()),
                     source(),
                     target()));
         } else {
             getLogger().debug("Applying non-incremental build");
             if (getProject().delete(getTarget().getAsFileTree())) {
-                getLogger().debug("Deleted all target files");
+                getLogger().debug("Deleted all target files in {}", getTarget());
             }
             source = new Plugin.Engine.Source.ForFolder(getSource().getAsFile().get());
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -1415,7 +1415,7 @@ public List<ArgumentLoader> resolve(MethodDescription instrumentedMethod, Method
                     } else if (!instrumentedMethod.getParameters().get(index).getType().isArray()) {
                         throw new IllegalStateException("Cannot access an item from non-array parameter " + instrumentedMethod.getParameters().get(index));
                     }
-                    List<ArgumentLoader> argumentLoaders = new ArrayList<ArgumentLoader>(instrumentedMethod.getParameters().size());
+                    List<ArgumentLoader> argumentLoaders = new ArrayList<ArgumentLoader>(invokedMethod.getParameters().size());
                     for (int index = 0; index < invokedMethod.getParameters().size(); index++) {
                         argumentLoaders.add(new ForMethodParameterArrayElement(instrumentedMethod.getParameters().get(this.index), index++));
                     }

File: byte-buddy-gradle-plugin/buildSrc/src/test/java/net/bytebuddy/build/gradle/transform/GradleTypeTransformerTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.build.gradle.transform.api.Sample;
 import net.bytebuddy.build.gradle.transform.api.Substitution;
-import net.bytebuddy.build.gradle.transform.target.Target;
+import net.bytebuddy.build.gradle.transform.content.Target;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;

File: byte-buddy-gradle-plugin/src/test/java/net/bytebuddy/build/gradle/ByteBuddyTaskExtensionTest.java
Patch:
@@ -31,7 +31,7 @@ public static Collection<Object[]> data() {
     @Test
     public void testDefaultProperties() {
         assertThat(extension.getTransformations().size(), is(0));
-        assertThat(extension.getEntryPoint(), is(EntryPoint.Default.REBASE));
+        assertThat(extension.getEntryPoint(), is((EntryPoint) EntryPoint.Default.REBASE));
         assertThat(extension.getSuffix(), is(""));
         assertThat(extension.getThreads(), is(0));
         assertThat(extension.isExtendedParsing(), is(false));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/MethodDelegationBinder.java
Patch:
@@ -633,7 +633,7 @@ private MethodBinding doResolve(AmbiguityResolver ambiguityResolver, MethodDescr
                                 return right;
                             case AMBIGUOUS:
                             case UNKNOWN:
-                                throw new IllegalArgumentException("Cannot resolve ambiguous delegation of " + source + " to " + left + " or " + right);
+                                throw new IllegalArgumentException("Cannot resolve ambiguous delegation of " + source + " to " + left.getTarget() + " or " + right.getTarget());
                             default:
                                 throw new AssertionError();
                         }
@@ -659,12 +659,12 @@ private MethodBinding doResolve(AmbiguityResolver ambiguityResolver, MethodDescr
                                     case LEFT:
                                     case AMBIGUOUS:
                                     case UNKNOWN:
-                                        throw new IllegalArgumentException("Cannot resolve ambiguous delegation of " + source + " to " + left + " or " + right);
+                                        throw new IllegalArgumentException("Cannot resolve ambiguous delegation of " + source + " to " + left.getTarget() + " or " + right.getTarget());
                                     default:
                                         throw new AssertionError();
                                 }
                             default:
-                                throw new IllegalStateException("Unexpected amount of targets: " + targets);
+                                throw new IllegalStateException("Unexpected amount of targets: " + targets.size());
                         }
                     }
                 }

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/Transformation.java
Patch:
@@ -61,7 +61,7 @@ public List<PluginArgument> getArguments() {
      * @param closure The closure for configuring the argument.
      */
     public void argument(Closure<?> closure) {
-        getArguments().add(ConfigureUtil.configure(closure, new PluginArgument()));
+        getArguments().add(ConfigureUtil.configure(closure, new PluginArgument(getArguments().size())));
     }
 
     /**

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/AbstractByteBuddyTask.java
Patch:
@@ -89,6 +89,8 @@ protected AbstractByteBuddyTask() {
         transformations = new ArrayList<Transformation>();
         entryPoint = EntryPoint.Default.REBASE;
         suffix = "";
+        failOnLiveInitializer = true;
+        warnOnEmptyTypeSet = true;
     }
 
     /**

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/ByteBuddySimpleTask.java
Patch:
@@ -28,7 +28,7 @@
 /**
  * A Byte Buddy task implementation that does not use modern Gradle APIs.
  */
-public class ByteBuddyLegacyTask extends AbstractByteBuddyTask {
+public class ByteBuddySimpleTask extends AbstractByteBuddyTask {
 
     /**
      * The source file or folder.

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/ByteBuddySimpleTaskExtension.java
Patch:
@@ -16,12 +16,12 @@
 package net.bytebuddy.build.gradle;
 
 /**
- * A Byte Buddy legacy task extension.
+ * A Byte Buddy simple task extension.
  */
-public class ByteBuddyLegacyTaskExtension extends AbstractByteBuddyTaskExtension<ByteBuddyLegacyTask> {
+public class ByteBuddySimpleTaskExtension extends AbstractByteBuddyTaskExtension<ByteBuddySimpleTask> {
 
     @Override
-    protected void doConfigure(ByteBuddyLegacyTask task) {
+    protected void doConfigure(ByteBuddySimpleTask task) {
         /* do nothing */
     }
 }

File: byte-buddy-gradle-plugin/buildSrc/src/test/java/net/bytebuddy/build/gradle/transform/GradleTypeTransformerTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.build.gradle.transform.api.Sample;
 import net.bytebuddy.build.gradle.transform.api.Substitution;
-import net.bytebuddy.build.gradle.transform.target.Target;
+import net.bytebuddy.build.gradle.transform.content.Target;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/AbstractByteBuddyTaskConfiguration.java
Patch:
@@ -77,6 +77,8 @@ public void execute(Project project) {
             project.getLogger().debug("Configuring Byte Buddy task for source set '{}' as '{}'", sourceSet.getName(), name);
             JavaCompile compileTask = (JavaCompile) project.getTasks().getByName(sourceSet.getCompileJavaTaskName());
             T byteBuddyTask = project.getTasks().create(name, type);
+            byteBuddyTask.setGroup("Byte Buddy");
+            byteBuddyTask.setDescription("Transforms the classes compiled by " + compileTask.getName());
             byteBuddyTask.dependsOn(compileTask);
             extension.configure(byteBuddyTask);
             configureDirectories(sourceSet.getJava(), compileTask, byteBuddyTask);

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/Plugin.java
Patch:
@@ -3306,7 +3306,7 @@ interface Materializable {
                 void materialize(Target.Sink sink,
                                  List<TypeDescription> transformed,
                                  Map<TypeDescription,
-                                         List<Throwable>> failed,
+                                 List<Throwable>> failed,
                                  List<String> unresolved) throws IOException;
 
                 /**
@@ -3661,7 +3661,7 @@ protected ForParallelTransformation(Executor executor,
                                                     Target.Sink sink,
                                                     List<TypeDescription> transformed,
                                                     Map<TypeDescription,
-                                                            List<Throwable>> failed,
+                                                    List<Throwable>> failed,
                                                     List<String> unresolved) {
                     this.sink = sink;
                     this.transformed = transformed;

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/Plugin.java
Patch:
@@ -3276,7 +3276,7 @@ interface Dispatcher extends Closeable {
             /**
              * Accepts a new work assignment.
              *
-             * @param work The work to handle prefixed by a preprocessing step.
+             * @param work  The work to handle prefixed by a preprocessing step.
              * @param eager {@code true} if the processing does not need to be deferred until all preprocessing is complete.
              * @throws IOException If an I/O exception occurs.
              */

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -8595,7 +8595,7 @@ public static TypePool of(ClassLoader classLoader) {
          * @return An class loading type pool.
          */
         public static TypePool of(ClassLoader classLoader, TypePool parent) {
-            return new ClassLoading(CacheProvider.NoOp.INSTANCE, parent, classLoader);
+            return new ClassLoading(new CacheProvider.Simple(), parent, classLoader);
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -119,7 +119,7 @@ public class ClassFileVersion implements Comparable<ClassFileVersion> {
     /**
      * The class file version of Java 16.
      */
-    public static final ClassFileVersion JAVA_V16 = new ClassFileVersion(Opcodes.V15 + 1);
+    public static final ClassFileVersion JAVA_V16 = new ClassFileVersion(Opcodes.V16);
 
     /**
      * A version locator for the executing JVM.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/OpenedClassReader.java
Patch:
@@ -53,7 +53,7 @@ public class OpenedClassReader {
             experimental = false;
         }
         EXPERIMENTAL = experimental;
-        ASM_API = Opcodes.ASM8;
+        ASM_API = Opcodes.ASM9;
     }
 
     /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/ClassFileVersionKnownVersionsTest.java
Patch:
@@ -73,7 +73,7 @@ public static Collection<Object[]> data() {
                 {13, 13, Arrays.asList("1.13", "13"), Opcodes.V13, (short) 57, (short) 0, true, true, true},
                 {14, 14, Arrays.asList("1.14", "14"), Opcodes.V14, (short) 58, (short) 0, true, true, true},
                 {15, 15, Arrays.asList("1.15", "15"), Opcodes.V15, (short) 59, (short) 0, true, true, true},
-                {16, 16, Arrays.asList("1.16", "16"), Opcodes.V15 + 1, (short) 60, (short) 0, true, true, true}
+                {16, 16, Arrays.asList("1.16", "16"), Opcodes.V16, (short) 60, (short) 0, true, true, true}
         });
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultTest.java
Patch:
@@ -1056,6 +1056,7 @@ public void testVisibilityExtension() throws Exception {
                 MethodDescription.UNDEFINED,
                 TypeDescription.UNDEFINED,
                 Collections.<TypeDescription>emptyList(),
+                Collections.<TypeDescription>emptyList(),
                 false,
                 false,
                 false,
@@ -1097,6 +1098,7 @@ public void testOrphanedBridge() throws Exception {
                 MethodDescription.UNDEFINED,
                 TypeDescription.UNDEFINED,
                 Collections.<TypeDescription>emptyList(),
+                Collections.<TypeDescription>emptyList(),
                 false,
                 false,
                 false,

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultClassDescriptionTypeListTest.java
Patch:
@@ -10,7 +10,7 @@
 
 import static net.bytebuddy.matcher.ElementMatchers.anyOf;
 
-public class TypePoolDefaultLazyTypeListTest extends AbstractTypeListTest<Class<?>> {
+public class TypePoolDefaultClassDescriptionTypeListTest extends AbstractTypeListTest<Class<?>> {
 
     private TypePool typePool;
 

File: byte-buddy-agent/src/test/java/net/bytebuddy/agent/ByteBuddyAgentAttachmentTypeEvaluator.java
Patch:
@@ -2,8 +2,8 @@
 
 import org.junit.Test;
 
-import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.*;
 
 public class ByteBuddyAgentAttachmentTypeEvaluator {
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRawMatcherDisjunctionTest.java
Patch:
@@ -11,7 +11,7 @@
 import java.security.ProtectionDomain;
 
 import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.*;
 import static org.mockito.Mockito.*;
 
 public class AgentBuilderRawMatcherDisjunctionTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRawMatcherInversionTest.java
Patch:
@@ -11,7 +11,7 @@
 import java.security.ProtectionDomain;
 
 import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.*;
 import static org.mockito.Mockito.when;
 
 public class AgentBuilderRawMatcherInversionTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRedefinitionStrategyBatchAllocatorTest.java
Patch:
@@ -10,7 +10,7 @@
 
 import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.*;
 
 public class AgentBuilderRedefinitionStrategyBatchAllocatorTest {
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/RawMatcherForResolvableTypesTest.java
Patch:
@@ -4,8 +4,8 @@
 import net.bytebuddy.utility.JavaModule;
 import org.junit.Test;
 
-import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.*;
 
 public class RawMatcherForResolvableTypesTest {
 

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/TransformationAction.java
Patch:
@@ -160,7 +160,7 @@ private void apply(File root, Iterable<? extends File> classPath) throws IOExcep
             }
             if (!summary.getFailed().isEmpty()) {
                 throw new GradleException(summary.getFailed() + " type transformations have failed");
-            } else if (summary.getTransformed().isEmpty()) {
+            } else if (byteBuddyExtension.isWarnOnEmptyTypeSet() && summary.getTransformed().isEmpty()) {
                 project.getLogger().warn("No types were transformed during plugin execution");
             } else {
                 project.getLogger().info("Transformed {} types", summary.getTransformed().size());

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -1730,6 +1730,7 @@ public static VirtualMachine attach(String processId, int timeout, Dispatcher di
                                     if (answer.contains(' ' + key + ' ')) {
                                         return new ForOpenJ9(socket);
                                     } else {
+                                        socket.close();
                                         throw new IllegalStateException("Unexpected answered to attachment: " + answer);
                                     }
                                 } finally {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -216,6 +216,7 @@ public static WithImplicitTarget bootstrap(MethodDescription.InDefinedShape boot
                 arguments.add(Type.getType(((TypeDescription) constant).getDescriptor()));
                 types.add(TypeDescription.CLASS);
             } else {
+                arguments.add(constant);
                 TypeDescription typeDescription = TypeDescription.ForLoadedType.of(constant.getClass()).asUnboxed();
                 types.add(typeDescription);
                 if (JavaType.METHOD_TYPE.isInstance(constant) || JavaType.METHOD_HANDLE.isInstance(constant)) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/ClassFileVersionKnownVersionsTest.java
Patch:
@@ -72,7 +72,8 @@ public static Collection<Object[]> data() {
                 {12, 12, Arrays.asList("1.12", "12"), Opcodes.V12, (short) 56, (short) 0, true, true, true},
                 {13, 13, Arrays.asList("1.13", "13"), Opcodes.V13, (short) 57, (short) 0, true, true, true},
                 {14, 14, Arrays.asList("1.14", "14"), Opcodes.V14, (short) 58, (short) 0, true, true, true},
-                {15, 15, Arrays.asList("1.15", "15"), Opcodes.V15, (short) 59, (short) 0, true, true, true}
+                {15, 15, Arrays.asList("1.15", "15"), Opcodes.V15, (short) 59, (short) 0, true, true, true},
+                {16, 16, Arrays.asList("1.16", "16"), Opcodes.V15 + 1, (short) 60, (short) 0, true, true, true}
         });
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -1803,6 +1803,7 @@ public static Dynamic bootstrap(String name, MethodDescription.InDefinedShape bo
                     arguments.add(Type.getType(((TypeDescription) constant).getDescriptor()));
                     types.add(TypeDescription.CLASS);
                 } else {
+                    arguments.add(constant);
                     types.add(TypeDescription.ForLoadedType.of(constant.getClass()).asUnboxed());
                 }
             }
@@ -1818,7 +1819,7 @@ public static Dynamic bootstrap(String name, MethodDescription.InDefinedShape bo
                             bootstrap.getInternalName(),
                             bootstrap.getDescriptor(),
                             false),
-                    arguments),
+                    arguments.toArray()),
                     bootstrap.isConstructor()
                             ? bootstrap.getDeclaringType()
                             : bootstrap.getReturnType().asErasure());

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -254,10 +254,10 @@ public void testTrivialAdviceWithDelegationBootstrapped() throws Exception {
                         String.class,
                         JavaType.METHOD_TYPE.load(),
                         String.class,
+                        int.class,
                         Class.class,
-                        JavaType.METHOD_HANDLE.load(),
                         String.class,
-                        int.class)).to(TrivialAdviceDelegation.class).on(named(FOO)))
+                        JavaType.METHOD_HANDLE.load())).to(TrivialAdviceDelegation.class).on(named(FOO)))
                 .make()
                 .load(bootstrap.getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST)
                 .getLoaded();

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -1301,7 +1301,9 @@ public enum HandleType {
              * @return The handle type for the given method.
              */
             protected static HandleType of(MethodDescription.InDefinedShape methodDescription) {
-                if (methodDescription.isStatic()) {
+                if (methodDescription.isTypeInitializer()) {
+                    throw new IllegalArgumentException("Cannot create handle of type initializer " + methodDescription);
+                } else if (methodDescription.isStatic()) {
                     return INVOKE_STATIC;
                 } else if (methodDescription.isConstructor()) { // Private constructors must use this handle type.
                     return INVOKE_SPECIAL_CONSTRUCTOR;

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -1303,10 +1303,10 @@ public enum HandleType {
             protected static HandleType of(MethodDescription.InDefinedShape methodDescription) {
                 if (methodDescription.isStatic()) {
                     return INVOKE_STATIC;
+                } else if (methodDescription.isConstructor()) { // Private constructors must use this handle type.
+                    return INVOKE_SPECIAL_CONSTRUCTOR;
                 } else if (methodDescription.isPrivate()) {
                     return INVOKE_SPECIAL;
-                } else if (methodDescription.isConstructor()) {
-                    return INVOKE_SPECIAL_CONSTRUCTOR;
                 } else if (methodDescription.getDeclaringType().isInterface()) {
                     return INVOKE_INTERFACE;
                 } else {

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -6,11 +6,9 @@
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.implementation.Implementation;
-import net.bytebuddy.implementation.bytecode.Removal;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.assign.Assigner;
 import net.bytebuddy.implementation.bytecode.constant.ClassConstant;
-import net.bytebuddy.implementation.bytecode.constant.TextConstant;
 import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
 import net.bytebuddy.pool.TypePool;
 import net.bytebuddy.test.packaging.AdviceTestHelper;

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -1444,7 +1444,7 @@ public StackManipulation resolve(TypeDescription instrumentedType,
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(type.getDeclaredMethod(FOO, String.class).invoke(type.getDeclaredConstructor().newInstance(), "bar"), is((Object) "foo"));
+        assertThat(type.getDeclaredMethod(FOO, String.class).invoke(type.getDeclaredConstructor().newInstance(), BAR), is((Object) FOO));
     }
 
     @Test
@@ -1471,7 +1471,7 @@ public StackManipulation resolve(TypeDescription instrumentedType,
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(type.getDeclaredMethod(FOO, String.class).invoke(type.getDeclaredConstructor().newInstance(), "bar"), is((Object) "foo"));
+        assertThat(type.getDeclaredMethod(FOO, String.class).invoke(type.getDeclaredConstructor().newInstance(), BAR), is((Object) FOO));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/visitor/ExceptionTableSensitiveMethodVisitorTest.java
Patch:
@@ -25,6 +25,7 @@ public class ExceptionTableSensitiveMethodVisitorTest {
     public static Collection<Object[]> data() {
         return Arrays.asList(new Object[][]{
                 {Opcodes.ASM6, "visitLabel", new Class<?>[]{Label.class}, new Object[]{new Label()}},
+                {Opcodes.ASM6, "visitFrame", new Class<?>[]{int.class, int.class, Object[].class, int.class, Object[].class}, new Object[]{0, 0, new Object[0], 0, new Object[0]}},
                 {Opcodes.ASM6, "visitIntInsn", new Class<?>[]{int.class, int.class}, new Object[]{0, 0}},
                 {Opcodes.ASM6, "visitVarInsn", new Class<?>[]{int.class, int.class}, new Object[]{0, 0}},
                 {Opcodes.ASM6, "visitTypeInsn", new Class<?>[]{int.class, String.class}, new Object[]{0, ""}},

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberSubstitution.java
Patch:
@@ -1127,11 +1127,11 @@ public StackManipulation resolve(TypeDescription targetType,
                 if (!methodDescription.getReturnType().asErasure().isAssignableTo(result.asErasure())) {
                     throw new IllegalStateException("Cannot assign return value of " + methodDescription + " to " + result);
                 } else if (mapped.size() != parameters.size()) {
-                    throw new IllegalStateException("Cannot invoke " + methodDescription + " on " + parameters);
+                    throw new IllegalStateException("Cannot invoke " + methodDescription + " on " + parameters.size() + " parameters");
                 }
                 for (int index = 0; index < mapped.size(); index++) {
-                    if (!mapped.get(index).asErasure().isAssignableTo(parameters.get(index).asErasure())) {
-                        throw new IllegalStateException("Cannot invoke " + methodDescription + " on " + parameters);
+                    if (!parameters.get(index).asErasure().isAssignableTo(mapped.get(index).asErasure())) {
+                        throw new IllegalStateException("Cannot invoke " + methodDescription + " on parameter " + index + " of type " + parameters.get(index));
                     }
                 }
                 return methodDescription.isVirtual()

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -6199,7 +6199,7 @@ protected AnnotationValue<Object[], Object[]> doResolve() {
                         } else if (resolution.resolve().represents(String.class)) {
                             return new AnnotationValue.ForDescriptionArray<Object, Object>(String.class, resolution.resolve(), values);
                         } else {
-                            throw new IllegalStateException("Unexpected complex component type: " + resolution.resolve());
+                            return new ForIncompatibleType<Object[], Object[]>(resolution.resolve());
                         }
                     }
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -353,7 +353,7 @@ public static byte[] read(Class<?> type) {
             try {
                 ClassLoader classLoader = type.getClassLoader();
                 return locate(classLoader == null
-                        ? ClassLoader.getSystemClassLoader()
+                        ? BOOT_LOADER_PROXY
                         : classLoader, TypeDescription.ForLoadedType.getName(type)).resolve();
             } catch (IOException exception) {
                 throw new IllegalStateException("Cannot read class file for " + type, exception);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -353,7 +353,7 @@ public static byte[] read(Class<?> type) {
             try {
                 ClassLoader classLoader = type.getClassLoader();
                 return locate(classLoader == null
-                        ? ClassLoader.getSystemClassLoader()
+                        ? BOOT_LOADER_PROXY
                         : classLoader, TypeDescription.ForLoadedType.getName(type)).resolve();
             } catch (IOException exception) {
                 throw new IllegalStateException("Cannot read class file for " + type, exception);

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/RecordComponentList.java
Patch:
@@ -16,14 +16,12 @@
 package net.bytebuddy.description.type;
 
 import net.bytebuddy.description.ByteCodeElement;
-import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.matcher.ElementMatcher;
 import net.bytebuddy.matcher.FilterableList;
 
 import java.lang.reflect.AnnotatedElement;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 
 /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -762,7 +762,7 @@ public void testRecordComponents() throws Exception {
         @SuppressWarnings("unchecked")
         Class<? extends Annotation> typeAnnotation = (Class<? extends Annotation>) Class.forName("net.bytebuddy.test.precompiled.TypeAnnotation");
         MethodDescription.InDefinedShape value = new MethodDescription.ForLoadedMethod(typeAnnotation.getMethod("value"));
-        RecordComponentList recordComponents = describe(sampleRecord).getRecordComponents();
+        RecordComponentList<RecordComponentDescription.InDefinedShape> recordComponents = describe(sampleRecord).getRecordComponents();
         assertThat(recordComponents.size(), is(1));
         assertThat(recordComponents.getOnly().getActualName(), is(FOO));
         assertThat(recordComponents.getOnly().getAccessor(), is((MethodDescription) new MethodDescription.ForLoadedMethod(sampleRecord.getMethod(FOO))));

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/RecordComponentDescription.java
Patch:
@@ -15,6 +15,7 @@
  */
 package net.bytebuddy.description.type;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.build.HashCodeAndEqualsPlugin;
 import net.bytebuddy.description.DeclaredByType;
 import net.bytebuddy.description.NamedElement;
@@ -305,6 +306,7 @@ public boolean isInstance(Object instance) {
                 /**
                  * {@inheritDoc}
                  */
+                @SuppressFBWarnings(value = "PZLA_PREFER_ZERO_LENGTH_ARRAYS", justification = "Null value return is aligned with OpenJDK return value.")
                 public Object[] getRecordComponents(Class<?> type) {
                     return null;
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -7483,6 +7483,7 @@ private class LazyRecordComponentDescription extends RecordComponentDescription.
                 /**
                  * The record component's generic signature or {@code null} if the record component is non-generic.
                  */
+                @SuppressFBWarnings(value = "URF_UNREAD_FIELD", justification = "Only unused for now.")
                 private final String genericSignature;
 
                 /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -755,6 +755,7 @@ public void testNonRecordComponents() throws Exception {
 
     @Test
     @JavaVersionRule.Enforce(14)
+    @Ignore("Requires preview features")
     public void testRecordComponents() throws Exception {
         Class<?> sampleRecord = Class.forName("net.bytebuddy.test.precompiled.SampleRecord");
         assertThat(describe(sampleRecord).isRecord(), is(true));
@@ -783,6 +784,7 @@ public void testRecordComponents() throws Exception {
 
     @Test
     @JavaVersionRule.Enforce(14)
+    @Ignore("Requires preview features")
     public void testRecordComponentsField() throws Exception {
         Class<?> sampleRecord = Class.forName("net.bytebuddy.test.precompiled.SampleRecord");
         @SuppressWarnings("unchecked")

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/RecordComponentDescription.java
Patch:
@@ -306,7 +306,7 @@ public boolean isInstance(Object instance) {
                  * {@inheritDoc}
                  */
                 public Object[] getRecordComponents(Class<?> type) {
-                    return new Object[0];
+                    return null;
                 }
 
                 /**

File: byte-buddy-android/src/test/java/net/bytebuddy/android/AndroidClassLoadingStrategyTest.java
Patch:
@@ -78,7 +78,6 @@ public void testProcessing() throws Exception {
         verify(conversion).register(Foo.class.getName(), QUX);
         verify(conversion).register(Bar.class.getName(), BAZ);
         verify(conversion).drainTo(any(OutputStream.class));
-        verify(conversion).close();
         verifyNoMoreInteractions(conversion);
     }
 

File: byte-buddy-android/src/test/java/net/bytebuddy/android/AndroidClassLoadingStrategyTest.java
Patch:
@@ -78,6 +78,7 @@ public void testProcessing() throws Exception {
         verify(conversion).register(Foo.class.getName(), QUX);
         verify(conversion).register(Bar.class.getName(), BAZ);
         verify(conversion).drainTo(any(OutputStream.class));
+        verify(conversion).close();
         verifyNoMoreInteractions(conversion);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/OpenedClassReader.java
Patch:
@@ -53,7 +53,7 @@ public class OpenedClassReader {
             experimental = false;
         }
         EXPERIMENTAL = experimental;
-        ASM_API = Opcodes.ASM7;
+        ASM_API = Opcodes.ASM8;
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NameMatcher.java
Patch:
@@ -22,7 +22,7 @@
  * A method matcher that matches a byte code element's source code name:
  * <ul>
  * <li>The source code name of types is equal to their binary name where arrays are appended a {@code []} by
- * their arity and where inner classes are appended by dots to their outer class's source name.</li>
+ * their arity and where inner classes are appended by dollar signs to their outer class's source name.</li>
  * <li>Constructors and the type initializer methods are represented by the empty string as they do not
  * represent a source code name.</li>
  * <li>Fields are named as in the source code.</li>

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultTest.java
Patch:
@@ -196,8 +196,8 @@ public void testNonPublicMethodOnInterfaceAssertion() throws Exception {
                 .make();
     }
 
-    @Test
-    public void testNonPublicMethodOnInterfaceAssertionJava8() throws Exception {
+    @Test(expected = IllegalStateException.class)
+    public void testPackagePrivateMethodOnInterfaceAssertionJava8() throws Exception {
         new ByteBuddy(ClassFileVersion.JAVA_V8)
                 .makeInterface()
                 .defineMethod(FOO, void.class)

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/OpenedClassReader.java
Patch:
@@ -53,7 +53,7 @@ public class OpenedClassReader {
             experimental = false;
         }
         EXPERIMENTAL = experimental;
-        ASM_API = experimental ? (1 << 24 | 8 << 16) : Opcodes.ASM7;
+        ASM_API = Opcodes.ASM7;
     }
 
     /**

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/Attacher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/Installer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-android-test/src/main/java/net/bytebuddy/android/test/TestActivity.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-android-test/src/main/java/net/bytebuddy/android/test/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-android/src/main/java/net/bytebuddy/android/AndroidClassLoadingStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-android/src/main/java/net/bytebuddy/android/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/ClassByExtensionBenchmark.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/ClassByImplementationBenchmark.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/StubInvocationBenchmark.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/SuperClassInvocationBenchmark.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/TrivialClassCreationBenchmark.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/runner/QuickRunner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/runner/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/specimen/ExampleClass.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/specimen/ExampleInterface.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/specimen/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/NamingStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/TypeCache.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/LambdaFactory.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/ResettableClassFileTransformer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/AsmVisitorWrapper.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberAttributeExtension.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberRemoval.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberSubstitution.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/ModifierAdjustment.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/TypeConstantAdjustment.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/TypeReferenceAdjustment.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/BuildLogger.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/CachedReturnPlugin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/EntryPoint.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/HashCodeAndEqualsPlugin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/Plugin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/ToStringPlugin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/ByteCodeElement.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/DeclaredByType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/ModifierReviewable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/NamedElement.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/TypeVariableSource.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationSource.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/enumeration/EnumerationDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/enumeration/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/EnumerationState.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/FieldManifestation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/FieldPersistence.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/MethodArguments.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/MethodManifestation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/MethodStrictness.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/ModifierContributor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/Ownership.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/ParameterManifestation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/ProvisioningState.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/SynchronizationState.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/SyntheticState.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/TypeManifestation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/Visibility.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/PackageDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDefinition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeVariableToken.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/Nexus.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/NexusAccessor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/TargetType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/Transformer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/TypeResolutionStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/VisibilityBridgeStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoader.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/InjectionClassLoader.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/MultipleParentClassLoader.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/NoOpClassFileTransformer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/PackageDefinitionStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/ClassWriterStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/FieldLocator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/FieldRegistry.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodRegistry.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeInitializer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeValidation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/AbstractInliningDynamicTypeBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/DecoratingDynamicTypeBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/InliningImplementationMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/MethodNameTransformer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTarget.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTarget.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/DefaultMethodCall.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/EqualsMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -555,7 +555,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
         FLOAT {
             /** {@inheritDoc} */
             public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
-                methodVisitor.visitInsn(Opcodes.FCMPL);
+                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/Float", "compare", "(FF)I", false);
                 return new Size(-1, 0);
             }
         },
@@ -566,7 +566,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
         DOUBLE {
             /** {@inheritDoc} */
             public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
-                methodVisitor.visitInsn(Opcodes.DCMPL);
+                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/Double", "compare", "(DD)I", false);
                 return new Size(-2, 0);
             }
         },

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/ExceptionMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/HashCodeMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/LoadedTypeInitializer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodAccessorFactory.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/StubMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/SuperMethodCall.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/ToStringMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationAppender.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationRetention.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationValueFilter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/FieldAttributeAppender.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/MethodAttributeAppender.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/TypeAttributeAppender.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/AuxiliaryType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/PrivilegedMemberLookupAction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TrivialType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TypeProxy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/ArgumentTypeResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/DeclaringTypeResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/MethodDelegationBinder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/MethodNameEqualityResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/ParameterLengthResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/AllArguments.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Argument.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/BindingPriority.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Default.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultCall.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Empty.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/IgnoreForBinding.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Origin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/RuntimeType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/StubValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Super.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperCall.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/This.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Addition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/ByteCodeAppender.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Duplication.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Multiplication.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Removal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/StackManipulation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/StackSize.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Throw.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/TypeCreation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/Assigner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/InstanceCheck.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/TypeCasting.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveBoxingDelegate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveTypeAwareAssigner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveUnboxingDelegate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveWideningDelegate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/VoidAwareAssigner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/reference/GenericTypeAwareAssigner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/reference/ReferenceTypeAwareAssigner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/reference/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/collection/ArrayAccess.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/collection/ArrayFactory.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/collection/CollectionFactory.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/collection/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/ClassConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/DefaultValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/DoubleConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/FieldConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/FloatConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/IntegerConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/JavaConstantValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/LongConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/NullConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/SerializedConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/TextConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/FieldAccess.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/HandleInvocation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodInvocation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodReturn.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccess.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AccessibilityMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AnnotationTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ArrayTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/BooleanMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CachingMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderHierarchyMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderParentMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionElementMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionErasureMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionItemMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionOneToOneMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionSizeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringAnnotationMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringFieldMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringMethodMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DefinedShapeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DescriptorMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/EqualityMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ErasureMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/FailSafeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/FieldTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/FilterableList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/HasSuperClassMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/HasSuperTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/InheritedAnnotationMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/InstanceTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/IsNamedMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/LatentMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodExceptionTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodOverrideMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypesMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParametersMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodReturnTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodSortMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ModifierMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NameMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NegatingMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NullMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/PrimitiveTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SignatureTokenMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/StringMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SubTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SuperTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/TypeSortMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/VisibilityMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/CompoundList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaModule.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/OpenedClassReader.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/RandomString.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/StreamDrainer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/privilege/GetSystemPropertyAction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/privilege/SetAccessibleAction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/privilege/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/ExceptionTableSensitiveMethodVisitor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/LineNumberPrependingMethodVisitor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/LocalVariableAwareMethodVisitor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/MetadataAwareClassVisitor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/StackAwareMethodVisitor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2019 Rafael Winterhalter
+ * Copyright 2014 - 2020 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -10465,7 +10465,7 @@ public Factory run() {
                                             ClassFileBufferStrategy.class,
                                             InstallationListener.class,
                                             RawMatcher.class,
-                                            Transformation.class,
+                                            List.class,
                                             CircularityLock.class));
                         } catch (Exception ignored) {
                             return Factory.ForLegacyVm.INSTANCE;

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderClassFileBufferStrategyTest.java
Patch:
@@ -6,8 +6,8 @@
 
 import java.security.ProtectionDomain;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.mock;
 
 public class AgentBuilderClassFileBufferStrategyTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderInjectionStrategyTest.java
Patch:
@@ -17,8 +17,8 @@
 
 import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.instanceOf;
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/ResettableClassFileTransformerWithDelegationTest.java
Patch:
@@ -9,8 +9,8 @@
 import java.lang.instrument.Instrumentation;
 import java.security.ProtectionDomain;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.*;
 
 public class ResettableClassFileTransformerWithDelegationTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceArgumentHandlerCopyingTest.java
Patch:
@@ -6,8 +6,8 @@
 
 import static net.bytebuddy.matcher.ElementMatchers.isConstructor;
 import static net.bytebuddy.matcher.ElementMatchers.named;
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 
 public class AdviceArgumentHandlerCopyingTest {
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/MemberAttributeExtensionTest.java
Patch:
@@ -10,8 +10,8 @@
 
 import static net.bytebuddy.matcher.ElementMatchers.named;
 import static org.hamcrest.CoreMatchers.instanceOf;
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 
 public class MemberAttributeExtensionTest {
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/BuildLoggerTest.java
Patch:
@@ -5,8 +5,8 @@
 import java.io.PrintStream;
 
 import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.*;
 
 public class BuildLoggerTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/HashCodeAndEqualsPluginTest.java
Patch:
@@ -13,8 +13,8 @@
 import java.util.Comparator;
 
 import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginCompoundTest.java
Patch:
@@ -9,8 +9,8 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.*;
 
 public class PluginCompoundTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginEngineSourceEmptyTest.java
Patch:
@@ -5,9 +5,9 @@
 
 import java.util.jar.Manifest;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.nullValue;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 
 public class PluginEngineSourceEmptyTest {
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginEngineSourceForFolderTest.java
Patch:
@@ -14,10 +14,8 @@
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
 
-import static org.hamcrest.CoreMatchers.notNullValue;
-import static org.hamcrest.CoreMatchers.nullValue;
+import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 
 public class PluginEngineSourceForFolderTest {
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginEngineSourceInMemoryTest.java
Patch:
@@ -11,10 +11,8 @@
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
 
-import static org.hamcrest.CoreMatchers.notNullValue;
-import static org.hamcrest.CoreMatchers.nullValue;
+import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 
 public class PluginEngineSourceInMemoryTest {
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginEngineSummaryTest.java
Patch:
@@ -9,9 +9,9 @@
 
 import java.util.Collections;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.not;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 
 public class PluginEngineSummaryTest {
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginEngineTargetDiscardingTest.java
Patch:
@@ -6,8 +6,8 @@
 import java.util.Collections;
 import java.util.jar.Manifest;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verifyZeroInteractions;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginEngineTargetForFolderTest.java
Patch:
@@ -15,8 +15,8 @@
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.*;
 
 public class PluginEngineTargetForFolderTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginEngineTargetForJarFileTest.java
Patch:
@@ -15,9 +15,9 @@
 import java.util.jar.JarInputStream;
 import java.util.jar.Manifest;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.nullValue;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginEngineTargetInMemoryTest.java
Patch:
@@ -9,8 +9,8 @@
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.*;
 
 public class PluginEngineTargetInMemoryTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginFactorySimpleTest.java
Patch:
@@ -2,8 +2,8 @@
 
 import org.junit.Test;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.mock;
 
 public class PluginFactorySimpleTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginFactoryUsingReflectionArgumentResolverTypeTest.java
Patch:
@@ -7,8 +7,8 @@
 import java.util.Arrays;
 import java.util.Collection;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 
 @RunWith(Parameterized.class)
 public class PluginFactoryUsingReflectionArgumentResolverTypeTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginFactoryUsingReflectionTest.java
Patch:
@@ -5,10 +5,8 @@
 import net.bytebuddy.dynamic.DynamicType;
 import org.junit.Test;
 
-import static org.hamcrest.CoreMatchers.instanceOf;
-import static org.hamcrest.CoreMatchers.nullValue;
+import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 
 public class PluginFactoryUsingReflectionTest {
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginNoOpTest.java
Patch:
@@ -6,9 +6,9 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.sameInstance;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.mock;
 
 public class PluginNoOpTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/ToStringPluginTest.java
Patch:
@@ -6,8 +6,8 @@
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import org.junit.Test;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 
 public class ToStringPluginTest {
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassWriterStrategyDefaultTest.java
Patch:
@@ -10,8 +10,8 @@
 import org.objectweb.asm.ClassReader;
 import org.objectweb.asm.ClassWriter;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 
 public class ClassWriterStrategyDefaultTest {
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/PrivilegedMemberLookupActionTest.java
Patch:
@@ -17,8 +17,8 @@
 import java.util.Collection;
 import java.util.Collections;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 
 @RunWith(Parameterized.class)
 public class PrivilegedMemberLookupActionTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/InstanceCheckTest.java
Patch:
@@ -11,8 +11,8 @@
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.*;
 
 public class InstanceCheckTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/reference/GenericTypeAwareAssignerTest.java
Patch:
@@ -12,8 +12,8 @@
 
 import java.io.Serializable;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.*;
 
 public class GenericTypeAwareAssignerTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/ArrayTypeMatcherTest.java
Patch:
@@ -4,8 +4,8 @@
 import org.junit.Test;
 import org.mockito.Mock;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.when;
 
 public class ArrayTypeMatcherTest extends AbstractElementMatcherTest<ArrayTypeMatcher<?>> {

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/PrimitiveTypeMatcherTest.java
Patch:
@@ -4,8 +4,8 @@
 import org.junit.Test;
 import org.mockito.Mock;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.when;
 
 public class PrimitiveTypeMatcherTest extends AbstractElementMatcherTest<PrimitiveTypeMatcher<?>> {

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/visitor/MetadataAwareClassVisitorTest.java
Patch:
@@ -4,8 +4,8 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 
 public class MetadataAwareClassVisitorTest {
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRedefinitionStrategyResubmissionStrategyTest.java
Patch:
@@ -684,6 +684,7 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
         verifyNoMoreInteractions(rawMatcher);
         verifyZeroInteractions(redefinitionBatchAllocator);
         verify(listener).onError(Foo.class.getName(), Foo.class.getClassLoader(), JavaModule.ofType(Foo.class), false, error);
+        verify(listener).onDiscovery(Foo.class.getName(), Foo.class.getClassLoader(), JavaModule.ofType(Foo.class), true);
         verify(listener).onError(Foo.class.getName(), Foo.class.getClassLoader(), JavaModule.ofType(Foo.class), true, runtimeException);
         verify(listener).onComplete(Foo.class.getName(), Foo.class.getClassLoader(), JavaModule.ofType(Foo.class), true);
         verifyNoMoreInteractions(listener);
@@ -737,6 +738,7 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
         verifyNoMoreInteractions(rawMatcher);
         verifyZeroInteractions(redefinitionBatchAllocator);
         verify(listener).onError(Foo.class.getName(), Foo.class.getClassLoader(), JavaModule.ofType(Foo.class), false, error);
+        verify(listener).onDiscovery(Foo.class.getName(), Foo.class.getClassLoader(), JavaModule.ofType(Foo.class), true);
         verify(listener).onError(Foo.class.getName(), Foo.class.getClassLoader(), JavaModule.ofType(Foo.class), true, runtimeException);
         verify(listener).onComplete(Foo.class.getName(), Foo.class.getClassLoader(), JavaModule.ofType(Foo.class), true);
         verifyNoMoreInteractions(listener);

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -6858,7 +6858,6 @@ protected void consider(RawMatcher matcher,
                                     boolean unmodifiable) {
                 if (unmodifiable || !matcher.matches(typeDescription, type.getClassLoader(), module, classBeingRedefined, type.getProtectionDomain())) {
                     try {
-                        types.add(type);
                         try {
                             listener.onIgnored(typeDescription, type.getClassLoader(), module, classBeingRedefined != null);
                         } finally {
@@ -6867,6 +6866,8 @@ protected void consider(RawMatcher matcher,
                     } catch (Throwable ignored) {
                         // Ignore exceptions that are thrown by listeners to mimic the behavior of a transformation.
                     }
+                } else {
+                    types.add(type);
                 }
             }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultApplicationRedefinitionReiterationTest.java
Patch:
@@ -11,7 +11,6 @@
 import net.bytebuddy.test.utility.AgentAttachmentRule;
 import net.bytebuddy.test.utility.JavaVersionRule;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.MethodRule;
@@ -25,7 +24,6 @@
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 
-@Ignore // TODO
 public class AgentBuilderDefaultApplicationRedefinitionReiterationTest {
 
     private static final String FOO = "foo", BAR = "bar", QUX = "qux";

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -240,7 +240,7 @@ public static ClassFileVersion ofJavaVersion(int javaVersion) {
             case 14:
                 return JAVA_V14;
             case 15:
-                return JAVA_V14;
+                return JAVA_V15;
             default:
                 if (OpenedClassReader.EXPERIMENTAL && javaVersion > 0) {
                     return new ClassFileVersion(BASE_VERSION + javaVersion);

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -154,7 +154,7 @@ public Class<? extends VirtualMachine> run() {
             } catch (ClassNotFoundException exception) {
                 throw new IllegalStateException("Optional JNA dependency is not available", exception);
             }
-            return System.getProperty("java.vm.vendor", "").toUpperCase(Locale.US).contains("J9")
+            return System.getProperty("java.vm.name", "").toUpperCase(Locale.US).contains("J9")
                     ? ForOpenJ9.class
                     : ForHotSpot.class;
 

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -154,7 +154,7 @@ public Class<? extends VirtualMachine> run() {
             } catch (ClassNotFoundException exception) {
                 throw new IllegalStateException("Optional JNA dependency is not available", exception);
             }
-            return System.getProperty("java.vm.vendor", "").toUpperCase(Locale.US).contains("J9")
+            return System.getProperty("java.vm.name", "").toUpperCase(Locale.US).contains("J9")
                     ? ForOpenJ9.class
                     : ForHotSpot.class;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/Plugin.java
Patch:
@@ -21,6 +21,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.DynamicType;
+import net.bytebuddy.dynamic.TypeResolutionStrategy;
 import net.bytebuddy.dynamic.scaffold.inline.MethodNameTransformer;
 import net.bytebuddy.implementation.LoadedTypeInitializer;
 import net.bytebuddy.matcher.ElementMatcher;
@@ -3634,7 +3635,7 @@ public Summary apply(Source source, Target target, List<? extends Plugin.Factory
                                                 sink.retain(element);
                                                 failed.put(typeDescription, errored);
                                             } else if (!applied.isEmpty()) {
-                                                DynamicType dynamicType = builder.make();
+                                                DynamicType dynamicType = builder.make(TypeResolutionStrategy.Disabled.INSTANCE, typePool);
                                                 listener.onTransformation(typeDescription, applied);
                                                 for (Map.Entry<TypeDescription, LoadedTypeInitializer> entry : dynamicType.getLoadedTypeInitializers().entrySet()) {
                                                     if (entry.getValue().isAlive()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -4710,7 +4710,7 @@ protected Collector make() {
             @Override
             protected void check(Instrumentation instrumentation) {
                 if (!DISPATCHER.isRetransformClassesSupported(instrumentation)) {
-                    throw new IllegalStateException("Cannot apply redefinition on " + instrumentation);
+                    throw new IllegalStateException("Cannot apply retransformation on " + instrumentation);
                 }
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -5633,7 +5633,7 @@ public Iterable<? extends List<Class<?>>> onError(int index, List<Class<?>> batc
                  * {@inheritDoc}
                  */
                 public void onComplete(int amount, List<Class<?>> types, Map<List<Class<?>>, Throwable> failures) {
-                    printStream.printf(AgentBuilder.Listener.StreamWriting.PREFIX + " REDEFINE COMPLETE #%d batch(es) containing %d types [%d failed batch(es)]%n", amount, types.size(), failures.size());
+                    printStream.printf(AgentBuilder.Listener.StreamWriting.PREFIX + " REDEFINE COMPLETE %d batch(es) containing %d types [%d failed batch(es)]%n", amount, types.size(), failures.size());
                 }
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -59,8 +59,7 @@
  * the user of this injector is responsible for providing access to non-public properties.
  * </p>
  */
-public interface
-ClassInjector {
+public interface ClassInjector {
 
     /**
      * A permission for the {@code suppressAccessChecks} permission.

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -4710,7 +4710,7 @@ protected Collector make() {
             @Override
             protected void check(Instrumentation instrumentation) {
                 if (!DISPATCHER.isRetransformClassesSupported(instrumentation)) {
-                    throw new IllegalStateException("Cannot apply redefinition on " + instrumentation);
+                    throw new IllegalStateException("Cannot apply retransformation on " + instrumentation);
                 }
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -59,8 +59,7 @@
  * the user of this injector is responsible for providing access to non-public properties.
  * </p>
  */
-public interface
-ClassInjector {
+public interface ClassInjector {
 
     /**
      * A permission for the {@code suppressAccessChecks} permission.

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -315,7 +315,7 @@ public static ClassFileVersion ofClassFile(byte[] binaryRepresentation) {
         if (binaryRepresentation.length < 7) {
             throw new IllegalArgumentException("Supplied byte array is too short to be a class file with " + binaryRepresentation.length + " byte");
         }
-        return ofMinorMajor(((int) binaryRepresentation[6] << 8) | binaryRepresentation[7]);
+        return ofMinorMajor(binaryRepresentation[6] << 8 | binaryRepresentation[7] & 0xFF);
     }
 
     /**

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -2341,6 +2341,7 @@ protected interface WindowsLibrary extends StdCallLibrary {
                     /**
                      * A structure representing a mutex's security attributes.
                      */
+                    @SuppressFBWarnings(value = {"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD", "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD"}, justification = "Field required by native implementation.")
                     class SecurityAttributes extends Structure {
 
                         /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericBuilderTest.java
Patch:
@@ -150,7 +150,7 @@ public void testTypeAnnotationOwnerType() throws Exception {
 
     @Test
     @Override
-    @Ignore("The Java reflection API does not currently support generic inner types")
+    @Ignore("The OpenJDK reflection API does not currently support generic inner types")
     public void testTypeAnnotationNonGenericInnerType() throws Exception {
         super.testTypeAnnotationNonGenericInnerType();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -956,7 +956,7 @@ public void testAnnotationTypeOnNestedType() throws Exception {
     @Test
     @JavaVersionRule.Enforce(8)
     @SuppressWarnings("unchecked")
-    @Ignore("The Java reflection API does not currently support nested generic types")
+    @Ignore("The OpenJDK reflection API does not currently support nested generic types")
     public void testAnnotationTypeOnNestedParameterizedType() throws Exception {
         Class<? extends Annotation> typeAnnotationType = (Class<? extends Annotation>) Class.forName(TYPE_VARIABLE_NAME);
         MethodDescription.InDefinedShape value = TypeDescription.ForLoadedType.of(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/MemberSubstitutionTest.java
Patch:
@@ -941,6 +941,7 @@ public int foo() {
 
         public static class Extension extends VirtualMethodCallSubstitutionSample {
 
+            @Override
             public int foo() {
                 return 2;
             }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AnnotationDescriptionForLoadedAnnotationDifferentClassLoaderTest.java
Patch:
@@ -12,6 +12,7 @@ public class AnnotationDescriptionForLoadedAnnotationDifferentClassLoaderTest ex
     private ClassLoader classLoader;
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         classLoader = new ByteArrayClassLoader(ClassLoadingStrategy.BOOTSTRAP_LOADER,

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericBuilderTest.java
Patch:
@@ -142,12 +142,14 @@ public void testExplicitOwnerTypeOfNonGenericType() throws Exception {
     }
 
     @Test
+    @Override
     @JavaVersionRule.Enforce(9)
     public void testTypeAnnotationOwnerType() throws Exception {
         super.testTypeAnnotationOwnerType();
     }
 
     @Test
+    @Override
     @Ignore("The Java reflection API does not currently support generic inner types")
     public void testTypeAnnotationNonGenericInnerType() throws Exception {
         super.testTypeAnnotationNonGenericInnerType();

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/AbstractDynamicTypeBuilderForInliningTest.java
Patch:
@@ -76,6 +76,7 @@ public abstract class AbstractDynamicTypeBuilderForInliningTest extends Abstract
     private TypePool typePool;
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         typePool = TypePool.Default.ofSystemLoader();

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTargetTest.java
Patch:
@@ -40,6 +40,7 @@ public class SubclassImplementationTargetTest extends AbstractImplementationTarg
     private MethodDescription.SignatureToken superConstructorToken;
 
     @Before
+    @Override
     public void setUp() throws Exception {
         when(superGraph.locate(Mockito.any(MethodDescription.SignatureToken.class))).thenReturn(MethodGraph.Node.Unresolved.INSTANCE);
         when(superGraph.locate(invokableToken)).thenReturn(new MethodGraph.Node.Simple(invokableMethod));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationArgumentTest.java
Patch:
@@ -70,6 +70,7 @@ public void foo() {
 
     public static class Qux extends Baz {
 
+        @Override
         public void foo() {
             super.foo();
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationSuperTest.java
Patch:
@@ -184,6 +184,7 @@ public T qux(T value) {
 
     public static class Bar extends GenericBase<String> {
 
+        @Override
         public String qux(String value) {
             return super.qux(value);
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/AbstractTypeAttributeAppenderTest.java
Patch:
@@ -17,6 +17,7 @@ public abstract class AbstractTypeAttributeAppenderTest extends AbstractAttribut
     protected TypeDescription.Generic typeDescription;
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(instrumentedType.asGenericType()).thenReturn(typeDescription);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/FieldAttributeAppenderFactoryCompoundTest.java
Patch:
@@ -15,6 +15,7 @@ public class FieldAttributeAppenderFactoryCompoundTest extends AbstractFieldAttr
     private FieldAttributeAppender first, second;
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(firstFactory.make(instrumentedType)).thenReturn(first);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/MethodAttributeAppenderExplicitTest.java
Patch:
@@ -28,6 +28,7 @@ public class MethodAttributeAppenderExplicitTest extends AbstractMethodAttribute
     private ParameterDescription parameterDescription;
 
     @Before
+    @Override
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
         super.setUp();

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/MethodAttributeAppenderFactoryCompoundTest.java
Patch:
@@ -15,6 +15,7 @@ public class MethodAttributeAppenderFactoryCompoundTest extends AbstractMethodAt
     private MethodAttributeAppender first, second;
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(firstFactory.make(instrumentedType)).thenReturn(first);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/TypeAttributeAppenderForInstrumentedTypeDifferentiatingTest.java
Patch:
@@ -17,6 +17,7 @@ public class TypeAttributeAppenderForInstrumentedTypeDifferentiatingTest extends
     private TypeDescription.Generic pseudoType;
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(pseudoType.asGenericType()).thenReturn(pseudoType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/AbstractArgumentTypeResolverTest.java
Patch:
@@ -44,6 +44,7 @@ public boolean matches(ArgumentTypeResolver.ParameterIndexToken parameterIndexTo
     }
 
     @Before
+    @Override
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
         super.setUp();

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/ArgumentTypeResolverPrimitiveTest.java
Patch:
@@ -69,6 +69,7 @@ public static Collection<Object[]> data() {
     }
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(firstPrimitive.asErasure()).thenReturn(firstRawPrimitive);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/ArgumentTypeResolverReferenceTest.java
Patch:
@@ -24,6 +24,7 @@ public class ArgumentTypeResolverReferenceTest extends AbstractArgumentTypeResol
     private ParameterDescription weakTargetParameter, dominantTargetParameter;
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(weakTargetType.isAssignableFrom(dominantTargetType)).thenReturn(true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/DeclaringTypeResolverTest.java
Patch:
@@ -15,6 +15,7 @@ public class DeclaringTypeResolverTest extends AbstractAmbiguityResolverTest {
     private TypeDescription leftType, rightType;
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(leftMethod.getDeclaringType()).thenReturn(leftType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/MethodDelegationBinderAmbiguityResolverChainTest.java
Patch:
@@ -16,6 +16,7 @@ public class MethodDelegationBinderAmbiguityResolverChainTest extends AbstractAm
     private MethodDelegationBinder.AmbiguityResolver chain;
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         chain = new MethodDelegationBinder.AmbiguityResolver.Compound(first, second);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/ParameterLengthResolverTest.java
Patch:
@@ -15,6 +15,7 @@ public class ParameterLengthResolverTest extends AbstractAmbiguityResolverTest {
     private ParameterList<?> leftList, rightList;
 
     @Before
+    @Override
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
         super.setUp();

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/AllArgumentsBinderTest.java
Patch:
@@ -36,6 +36,7 @@ public AllArgumentsBinderTest() {
     }
 
     @Before
+    @Override
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
         super.setUp();

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ArgumentBinderTest.java
Patch:
@@ -32,6 +32,7 @@ public ArgumentBinderTest() {
     }
 
     @Before
+    @Override
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
         super.setUp();

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/DefaultBinderTest.java
Patch:
@@ -32,6 +32,7 @@ public DefaultBinderTest() {
     }
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(target.getType()).thenReturn(typeDescription);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/DefaultCallBinderTest.java
Patch:
@@ -37,6 +37,7 @@ public DefaultCallBinderTest() {
     }
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(target.getType()).thenReturn(genericTargetParameterType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/DefaultMethodBinderTest.java
Patch:
@@ -39,6 +39,7 @@ protected TargetMethodAnnotationDrivenBinder.ParameterBinder<DefaultMethod> getS
     }
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(target.getType()).thenReturn(genericTargetType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldProxyBinderTest.java
Patch:
@@ -41,6 +41,7 @@ public FieldProxyBinderTest() {
     }
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(getterMethod.getDeclaringType()).thenReturn(getterType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldValueBinderTest.java
Patch:
@@ -35,6 +35,7 @@ public FieldValueBinderTest() {
     }
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(fieldDescription.asDefined()).thenReturn(fieldDescription);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/MorphBinderTest.java
Patch:
@@ -43,6 +43,7 @@ protected TargetMethodAnnotationDrivenBinder.ParameterBinder<Morph> getSimpleBin
     }
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(genericMorphType.asErasure()).thenReturn(morphType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/OriginBinderTest.java
Patch:
@@ -43,6 +43,7 @@ public OriginBinderTest() {
     }
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(target.getType()).thenReturn(genericTargetType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/PipeBinderTest.java
Patch:
@@ -31,6 +31,7 @@ public PipeBinderTest() {
     }
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(targetMethod.getDeclaringType()).thenReturn(targetMethodType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/StubValueBinderTest.java
Patch:
@@ -23,6 +23,7 @@ public StubValueBinderTest() {
     }
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(genericType.asErasure()).thenReturn(type);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/SuperBinderTest.java
Patch:
@@ -27,6 +27,7 @@ public SuperBinderTest() {
     }
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(target.getType()).thenReturn(genericTargetType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/SuperCallBinderTest.java
Patch:
@@ -32,6 +32,7 @@ public SuperCallBinderTest() {
     }
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(target.getType()).thenReturn(genericTargetParameterType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/SuperMethodBinderTest.java
Patch:
@@ -38,6 +38,7 @@ protected TargetMethodAnnotationDrivenBinder.ParameterBinder<SuperMethod> getSim
     }
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(target.getType()).thenReturn(genericTargetType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ThisBinderTest.java
Patch:
@@ -23,6 +23,7 @@ public ThisBinderTest() {
     }
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         when(stackManipulation.isValid()).thenReturn(true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultEnumerationDescriptionTest.java
Patch:
@@ -13,6 +13,7 @@ public class TypePoolDefaultEnumerationDescriptionTest extends AbstractEnumerati
     private TypePool typePool;
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         typePool = TypePool.Default.ofSystemLoader();

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultFieldDescriptionTest.java
Patch:
@@ -14,6 +14,7 @@ public class TypePoolDefaultFieldDescriptionTest extends AbstractFieldDescriptio
     private TypePool typePool;
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         typePool = TypePool.Default.ofSystemLoader();

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultMethodDescriptionTest.java
Patch:
@@ -16,6 +16,7 @@ public class TypePoolDefaultMethodDescriptionTest extends AbstractMethodDescript
     private TypePool typePool;
 
     @Before
+    @Override
     public void setUp() throws Exception {
         super.setUp();
         typePool = new TypePool.Default(TypePool.CacheProvider.NoOp.INSTANCE,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/reference/GenericTypeAwareAssigner.java
Patch:
@@ -219,8 +219,8 @@ protected OfSimpleType(TypeDescription.Generic typeDescription, boolean polymorp
              * {@inheritDoc}
              */
             public Boolean onParameterizedType(TypeDescription.Generic parameterizedType) {
-                Queue<TypeDescription.Generic> candidates = new LinkedList<>(Collections.singleton(typeDescription));
-                Set<TypeDescription> previous = new HashSet<>(Collections.singleton(typeDescription.asErasure()));
+                Queue<TypeDescription.Generic> candidates = new LinkedList<TypeDescription.Generic>(Collections.singleton(typeDescription));
+                Set<TypeDescription> previous = new HashSet<TypeDescription>(Collections.singleton(typeDescription.asErasure()));
                 do {
                     TypeDescription.Generic candidate = candidates.remove();
                     if (candidate.asErasure().equals(parameterizedType.asErasure())) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/ResettableClassFileTransformer.java
Patch:
@@ -348,6 +348,7 @@ public boolean reset(Instrumentation instrumentation,
      * Implements a resettable class file transformer that allows for the delegation of a transformation. Typically implemented
      * when using a {@link net.bytebuddy.agent.builder.AgentBuilder.TransformerDecorator}.
      */
+    @HashCodeAndEqualsPlugin.Enhance
     abstract class WithDelegation extends AbstractBase {
 
         /**
@@ -357,6 +358,7 @@ abstract class WithDelegation extends AbstractBase {
 
         /**
          * Creates a new delegating resettable class file transformer.
+         *
          * @param classFileTransformer The class file transformer to delegate to.
          */
         protected WithDelegation(ResettableClassFileTransformer classFileTransformer) {

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -996,6 +996,7 @@ protected ForJnaSolarisDoor(SolarisLibrary library, int handle) {
                 /**
                  * {@inheritDoc}
                  */
+                @SuppressFBWarnings(value = {"UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD", "URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD"}, justification = "This pattern is required for use of JNA.")
                 public Response execute(String protocol, String... argument) throws IOException {
                     SolarisLibrary.DoorArgument door = new SolarisLibrary.DoorArgument();
                     try {

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -1054,6 +1054,7 @@ protected interface SolarisLibrary extends Library {
                      *
                      * @param processId The target process's id.
                      * @param signal    The signal to send.
+                     * @return The return code.
                      * @throws LastErrorException If an error occurred while sending the signal.
                      */
                     int kill(int processId, int signal) throws LastErrorException;
@@ -1083,6 +1084,7 @@ protected interface SolarisLibrary extends Library {
                      * Releases a descriptor.
                      *
                      * @param descriptor The descriptor to release.
+                     * @return The return code.
                      * @throws LastErrorException If the descriptor could not be closed.
                      */
                     int close(int descriptor) throws LastErrorException;

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -1176,7 +1176,7 @@ protected DoorDescription(Pointer pointer) {
 
                         @Override
                         protected List<String> getFieldOrder() {
-                            return Arrays.asList("attributes", "descriptor", "id");
+                            return Arrays.asList("attributes", "handle", "id");
                         }
                     }
                 }

File: byte-buddy-agent/src/test/java/net/bytebuddy/agent/VirtualMachineForOpenJ9Test.java
Patch:
@@ -22,7 +22,7 @@ public class VirtualMachineForOpenJ9Test {
     
     private static final String FOO = "foo", BAR = "bar";
 
-    private static final long PROCESS_ID = 42L, USER_ID = 84L, VM_ID = 168L;
+    private static final int PROCESS_ID = 42, USER_ID = 84, VM_ID = 168;
 
     private File temporaryFolder, attachFolder;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/JavaVersionRule.java
Patch:
@@ -76,7 +76,7 @@ private NoOpStatement(int requiredVersion, String sort) {
             this.sort = sort;
         }
 
-        public void evaluate() throws Throwable {
+        public void evaluate() {
             Logger.getLogger("net.bytebuddy").warning("Ignoring test case: Requires a Java version of " + sort + " " + requiredVersion);
         }
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategyTest.java
Patch:
@@ -200,7 +200,7 @@ public void testEngineSelfReport() throws Exception {
     }
 
     @Test
-    @JavaVersionRule.Enforce(hotSpot = 8)
+    @JavaVersionRule.Enforce(value = 8, atMost = 8, hotSpot = 8)
     @AgentAttachmentRule.Enforce(retransformsClasses = true)
     public void testAnonymousType() throws Exception {
         ClassLoader classLoader = new ByteArrayClassLoader(ClassLoadingStrategy.BOOTSTRAP_LOADER,

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -1244,6 +1244,7 @@ class ForJnaWindowsEnvironment implements Connector {
                  *
                  * @return An appropriate connector.
                  */
+                @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "The Exception is intentionally suppressed as it indicates incompatibility.")
                 public static Connector withInferredNamespace() {
                     try {
                         // This method is bundled with any OpenJ9 VM and is guaranteed to exist for any VM that does not use the non-global namespace.

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -1422,6 +1422,7 @@ protected interface WindowsLibrary extends Library {
                      * @param name          The semaphore's name.
                      * @return The handle or {@code null} if the handle could not be created.
                      */
+                    @SuppressWarnings("checkstyle:methodname")
                     WinNT.HANDLE OpenSemaphoreW(int access, boolean inheritHandle, String name);
 
                     /**
@@ -1433,6 +1434,7 @@ protected interface WindowsLibrary extends Library {
                      * @param name               The semaphore's name.
                      * @return The handle or {@code null} if the handle could not be created.
                      */
+                    @SuppressWarnings("checkstyle:methodname")
                     WinNT.HANDLE CreateSemaphoreW(WinBase.SECURITY_ATTRIBUTES securityAttributes, long count, long maximumCount, String name);
 
                     /**
@@ -1443,6 +1445,7 @@ protected interface WindowsLibrary extends Library {
                      * @param previousCount The previous count of the semaphore or {@code null}.
                      * @return {@code true} if the semaphore was successfully released.
                      */
+                    @SuppressWarnings("checkstyle:methodname")
                     boolean ReleaseSemaphore(WinNT.HANDLE handle, long count, Long previousCount);
                 }
 

File: byte-buddy-agent/src/test/java/net/bytebuddy/agent/VirtualMachineAttachmentTest.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.agent;
 
 import net.bytebuddy.dynamic.ClassFileLocator;
-import net.bytebuddy.test.utility.UnixRule;
+import net.bytebuddy.test.utility.AttachmentEmulationRule;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -24,7 +24,7 @@ public class VirtualMachineAttachmentTest {
     private static final String FOO = "foo";
 
     @Rule
-    public MethodRule unixRule = new UnixRule();
+    public MethodRule attachmentEmulationRule = new AttachmentEmulationRule();
 
     private File agent;
 
@@ -50,7 +50,7 @@ public void tearDown() throws Exception {
     }
 
     @Test
-    @UnixRule.Enforce
+    @AttachmentEmulationRule.Enforce
     public void testAttachment() throws Exception {
         assertThat(SampleAgent.argument, nullValue(String.class));
         VirtualMachine virtualMachine = (VirtualMachine) VirtualMachine.Resolver.INSTANCE.run()

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -841,7 +841,7 @@ private static void write(Socket socket, String value) throws IOException {
         }
 
         /**
-         * Reads a {©code 0}-terminated value from the target socket.
+         * Reads a {@code '\0'}-terminated value from the target socket.
          *
          * @param socket The socket to read from.
          * @return The value that was read.

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -841,7 +841,7 @@ private static void write(Socket socket, String value) throws IOException {
         }
 
         /**
-         * Reads a {©code 0}-terminated value from the target socket.
+         * Reads a {@code '\0'}-terminated value from the target socket.
          *
          * @param socket The socket to read from.
          * @return The value that was read.

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -1022,7 +1022,7 @@ public void decrementSemaphore(File directory, String name, int count) {
                  * @param flags             The flags to set.
                  * @param acceptUnavailable {@code true} if a {@code EAGAIN} code should be accepted.
                  */
-                @SuppressFBWarnings(value = "URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD", justification = "Modifier is required by JNA.")
+                @SuppressFBWarnings(value = {"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD", "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD"}, justification = "Modifier is required by JNA.")
                 private void notifySemaphore(File directory, String name, int count, short operation, short flags, boolean acceptUnavailable) {
                     int semaphore = library.semget(library.ftok(new File(directory, name).getAbsolutePath(), 0xA1), 2, 0666);
                     PosixLibrary.SemaphoreOperation buffer = new PosixLibrary.SemaphoreOperation();

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -972,11 +972,12 @@ public boolean isExistingProcess(long processId) {
                 /**
                  * {@inheritDoc}
                  */
+                @SuppressFBWarnings(value = "OS_OPEN_STREAM", justification = "The stream life-cycle is bound to its process.")
                 public long getOwnerIdOf(File file) {
                     try {
                         Process process = Runtime.getRuntime().exec("stat -c=%u " + file.getAbsolutePath());
                         try {
-                            String line = new BufferedReader(new InputStreamReader(process.getInputStream())).readLine();
+                            String line = new BufferedReader(new InputStreamReader(process.getInputStream(), "UTF-8")).readLine();
                             if (process.exitValue() != 0) {
                                 throw new IllegalStateException("Unexpected return by stat command: " + line);
                             }
@@ -1021,6 +1022,7 @@ public void decrementSemaphore(File directory, String name, int count) {
                  * @param flags             The flags to set.
                  * @param acceptUnavailable {@code true} if a {@code EAGAIN} code should be accepted.
                  */
+                @SuppressFBWarnings(value = "URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD", justification = "Modifier is required by JNA.")
                 private void notifySemaphore(File directory, String name, int count, short operation, short flags, boolean acceptUnavailable) {
                     int semaphore = library.semget(library.ftok(new File(directory, name).getAbsolutePath(), 0xA1), 2, 0666);
                     PosixLibrary.SemaphoreOperation buffer = new PosixLibrary.SemaphoreOperation();

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -1069,7 +1069,7 @@ enum ForUnixHotSpotVm implements AttachmentProvider {
              */
             public Accessor attempt() {
                 try {
-                    return new Accessor.Simple.WithoutExternalAttachment(VirtualMachine.Default.assertAvailability());
+                    return new Accessor.Simple.WithoutExternalAttachment(VirtualMachine.ForHotSpotVm.assertAvailability());
                 } catch (Throwable ignored) {
                     return Accessor.Unavailable.INSTANCE;
                 }

File: byte-buddy-agent/src/test/java/net/bytebuddy/agent/VirtualMachineForHotSpotVmAttachmentTest.java
Patch:
@@ -18,7 +18,7 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
 
-public class VirtualMachineDefaultAttachmentTest {
+public class VirtualMachineForHotSpotVmAttachmentTest {
 
     private static final String FOO = "foo";
 
@@ -51,7 +51,7 @@ public void tearDown() throws Exception {
     @Test
     @UnixRule.Enforce
     public void canAttachViaPosixSocket() throws Exception {
-        VirtualMachine virtualMachine = VirtualMachine.Default.attach(ByteBuddyAgent.ProcessProvider.ForCurrentVm.INSTANCE.resolve());
+        VirtualMachine virtualMachine = VirtualMachine.ForHotSpotVm.attach(ByteBuddyAgent.ProcessProvider.ForCurrentVm.INSTANCE.resolve());
         try {
             virtualMachine.loadAgent(agent.getAbsolutePath(), FOO);
         } finally {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/MethodAttributeAppender.java
Patch:
@@ -280,7 +280,7 @@ protected Explicit(Target target, List<? extends AnnotationDescription> annotati
             this.target = target;
             this.annotations = annotations;
         }
-    
+
         /**
          * Creates a method attribute appender factory that writes all annotations of a given method, both the method
          * annotations themselves and all annotations that are defined for every parameter.
@@ -291,7 +291,7 @@ protected Explicit(Target target, List<? extends AnnotationDescription> annotati
         public static Factory of(MethodDescription methodDescription) {
             return new Factory.Compound(ofMethodAnnotations(methodDescription), ofParameterAnnotations(methodDescription));
         }
-    
+
         /**
          * Creates a method attribute appender factory that writes all method annotations that are defined on the given method.
          *
@@ -301,7 +301,7 @@ public static Factory of(MethodDescription methodDescription) {
         public static Factory ofMethodAnnotations(MethodDescription methodDescription) {
             return new Explicit(methodDescription.getDeclaredAnnotations());
         }
-    
+
         /**
          * Creates a method attribute appender factory that writes all annotations that are defined for every parameter
          * of the given method.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/LocalVariableAwareMethodVisitor.java
Patch:
@@ -15,6 +15,7 @@
  */
 package net.bytebuddy.utility.visitor;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.utility.OpenedClassReader;
 import org.objectweb.asm.MethodVisitor;
@@ -42,6 +43,7 @@ public LocalVariableAwareMethodVisitor(MethodVisitor methodVisitor, MethodDescri
     }
 
     @Override
+    @SuppressFBWarnings(value = "SF_SWITCH_NO_DEFAULT", justification = "No action required on default option.")
     public void visitVarInsn(int opcode, int offset) {
         switch (opcode) {
             case Opcodes.ISTORE:

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/MemberSubstitutionTest.java
Patch:
@@ -12,6 +12,7 @@
 import net.bytebuddy.test.packaging.MemberSubstitutionTestHelper;
 import org.junit.Test;
 
+import java.util.Collections;
 import java.util.concurrent.Callable;
 
 import static net.bytebuddy.matcher.ElementMatchers.any;

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -5943,8 +5943,8 @@ public void injectCompletionFrame(MethodVisitor methodVisitor) {
                             }
                             methodVisitor.visitFrame(Opcodes.F_APPEND, local.length, local, EMPTY.length, EMPTY);
                         }
-                    //} else if (currentFrameDivergence < 3 && endTypes.isEmpty()) {
-                    //    methodVisitor.visitFrame(Opcodes.F_CHOP, currentFrameDivergence, EMPTY, EMPTY.length, EMPTY);
+                    } else if (currentFrameDivergence < 3 && endTypes.isEmpty()) {
+                        methodVisitor.visitFrame(Opcodes.F_CHOP, currentFrameDivergence, EMPTY, EMPTY.length, EMPTY);
                     } else {
                         injectFullFrame(methodVisitor, CompoundList.of(startTypes, endTypes), Collections.<TypeDescription>emptyList());
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -1039,6 +1039,7 @@ protected static Initializable make() throws Exception {
                         override = new ByteBuddy()
                                 .redefine(AccessibleObject.class)
                                 .name("net.bytebuddy.mirror." + AccessibleObject.class.getSimpleName())
+                                .noNestMate()
                                 .visit(new MemberRemoval().stripInvokables(any()))
                                 .make()
                                 .load(AccessibleObject.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
@@ -1896,6 +1897,7 @@ public Initializable run() {
                                     override = new ByteBuddy()
                                             .redefine(AccessibleObject.class)
                                             .name("net.bytebuddy.mirror." + AccessibleObject.class.getSimpleName())
+                                            .noNestMate()
                                             .visit(new MemberRemoval().stripInvokables(any()))
                                             .make()
                                             .load(AccessibleObject.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -9,6 +9,7 @@
 import net.bytebuddy.implementation.bytecode.assign.Assigner;
 import net.bytebuddy.implementation.bytecode.constant.ClassConstant;
 import net.bytebuddy.pool.TypePool;
+import net.bytebuddy.test.packaging.AdviceTestHelper;
 import org.junit.Test;
 import org.mockito.Mockito;
 import org.objectweb.asm.ClassReader;
@@ -1403,7 +1404,7 @@ public void testNonAssignableSerializableValue() throws Exception {
     public void testInvisibleField() throws Exception {
         new ByteBuddy()
                 .redefine(SampleExtension.class)
-                .visit(Advice.withCustomMapping().bind(Custom.class, Sample.class.getDeclaredField("object")).to(CustomAdvice.class).on(named(FOO)))
+                .visit(Advice.withCustomMapping().bind(Custom.class, AdviceTestHelper.class.getDeclaredField("object")).to(CustomAdvice.class).on(named(FOO)))
                 .make();
     }
 
@@ -1728,7 +1729,7 @@ public void testInlineAdviceCannotWriteReturn() throws Exception {
     public void testInvisibleDelegationAdvice() throws Exception {
         new ByteBuddy()
                 .redefine(Sample.class)
-                .visit(Advice.to(NonVisibleAdvice.class).on(named(FOO)))
+                .visit(Advice.to(AdviceTestHelper.class).on(named(FOO)))
                 .make();
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/MemberSubstitutionTest.java
Patch:
@@ -7,6 +7,7 @@
 import net.bytebuddy.dynamic.loading.ByteArrayClassLoader;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.pool.TypePool;
+import net.bytebuddy.test.packaging.MemberSubstitutionTestHelper;
 import org.junit.Test;
 
 import java.util.concurrent.Callable;
@@ -612,7 +613,7 @@ public void testMethodSelfDelegationSample() throws Exception {
     public void testFieldNotAccessible() throws Exception {
         new ByteBuddy()
                 .redefine(StaticFieldAccessSample.class)
-                .visit(MemberSubstitution.strict().field(named(FOO)).replaceWith(ValidationTarget.class.getDeclaredField(FOO)).on(named(RUN)))
+                .visit(MemberSubstitution.strict().field(named(FOO)).replaceWith(MemberSubstitutionTestHelper.class.getDeclaredField(FOO)).on(named(RUN)))
                 .make();
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/packaging/FieldDescriptionTestHelper.java
Patch:
@@ -2,6 +2,6 @@
 
 import net.bytebuddy.description.field.AbstractFieldDescriptionTest;
 
-public class VisibilityFieldTestHelper extends AbstractFieldDescriptionTest.PublicType {
+public class FieldDescriptionTestHelper extends AbstractFieldDescriptionTest.PublicType {
     /* empty */
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/packaging/MethodDescriptionTestHelper.java
Patch:
@@ -2,6 +2,6 @@
 
 import net.bytebuddy.description.method.AbstractMethodDescriptionTest;
 
-public abstract class VisibilityMethodTestHelper extends AbstractMethodDescriptionTest.PublicType {
+public abstract class MethodDescriptionTestHelper extends AbstractMethodDescriptionTest.PublicType {
     /* empty */
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/AbstractFieldDescriptionTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.description.field;
 
+import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.description.annotation.AnnotationList;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
@@ -144,7 +145,7 @@ public void testIsVisibleTo() throws Exception {
         assertThat(describe(PublicType.class.getDeclaredField("packagePrivateField"))
                 .isVisibleTo(TypeDescription.ForLoadedType.of(FirstSample.class)), is(true));
         assertThat(describe(PublicType.class.getDeclaredField("privateField"))
-                .isVisibleTo(TypeDescription.ForLoadedType.of(FirstSample.class)), is(false));
+                .isVisibleTo(TypeDescription.ForLoadedType.of(FirstSample.class)), is(ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V11)));
         assertThat(describe(PublicType.class.getDeclaredField("publicField"))
                 .isVisibleTo(TypeDescription.OBJECT), is(true));
         assertThat(describe(PublicType.class.getDeclaredField("protectedField"))

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/AbstractMethodDescriptionTest.java
Patch:
@@ -410,7 +410,7 @@ public void testMethodIsVisibleTo() throws Exception {
         assertThat(describe(PublicType.class.getDeclaredMethod("packagePrivateMethod"))
                 .isVisibleTo(TypeDescription.ForLoadedType.of(Sample.class)), is(true));
         assertThat(describe(PublicType.class.getDeclaredMethod("privateMethod"))
-                .isVisibleTo(TypeDescription.ForLoadedType.of(Sample.class)), is(false));
+                .isVisibleTo(TypeDescription.ForLoadedType.of(Sample.class)), is(ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V11)));
         assertThat(describe(PublicType.class.getDeclaredMethod("publicMethod"))
                 .isVisibleTo(TypeDescription.OBJECT), is(true));
         assertThat(describe(PublicType.class.getDeclaredMethod("protectedMethod"))
@@ -462,7 +462,7 @@ public void testConstructorIsVisibleTo() throws Exception {
         assertThat(describe(PublicType.class.getDeclaredConstructor(Object.class))
                 .isVisibleTo(TypeDescription.ForLoadedType.of(Sample.class)), is(true));
         assertThat(describe(PublicType.class.getDeclaredConstructor(String.class))
-                .isVisibleTo(TypeDescription.ForLoadedType.of(Sample.class)), is(false));
+                .isVisibleTo(TypeDescription.ForLoadedType.of(Sample.class)), is(ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V11)));
         assertThat(describe(PublicType.class.getDeclaredConstructor())
                 .isVisibleTo(TypeDescription.OBJECT), is(true));
         assertThat(describe(PublicType.class.getDeclaredConstructor(Void.class))

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/MultipleParentClassLoader.java
Patch:
@@ -243,6 +243,7 @@ public Builder(boolean sealed) {
          * Creates a new builder.
          *
          * @param classLoaders The class loaders that were collected until now.
+         * @param sealed       {@code true} if the created class loader is sealed.
          */
         private Builder(List<? extends ClassLoader> classLoaders, boolean sealed) {
             this.classLoaders = classLoaders;

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/Attacher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/Installer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-android-test/src/main/java/net/bytebuddy/android/test/TestActivity.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-android-test/src/main/java/net/bytebuddy/android/test/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-android/src/main/java/net/bytebuddy/android/AndroidClassLoadingStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-android/src/main/java/net/bytebuddy/android/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/ClassByExtensionBenchmark.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/ClassByImplementationBenchmark.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/StubInvocationBenchmark.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/SuperClassInvocationBenchmark.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/TrivialClassCreationBenchmark.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/runner/QuickRunner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/runner/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/specimen/ExampleClass.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/specimen/ExampleInterface.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/specimen/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/NamingStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/TypeCache.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/LambdaFactory.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/ResettableClassFileTransformer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/AsmVisitorWrapper.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberRemoval.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberSubstitution.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/ModifierAdjustment.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/TypeConstantAdjustment.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/TypeReferenceAdjustment.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/BuildLogger.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/CachedReturnPlugin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/EntryPoint.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/HashCodeAndEqualsPlugin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/Plugin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/ToStringPlugin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/ByteCodeElement.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/DeclaredByType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/ModifierReviewable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/NamedElement.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/TypeVariableSource.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationSource.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/enumeration/EnumerationDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/enumeration/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/EnumerationState.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/FieldManifestation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/FieldPersistence.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/MethodArguments.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/MethodManifestation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/MethodStrictness.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/ModifierContributor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/Ownership.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/ParameterManifestation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/ProvisioningState.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/SynchronizationState.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/SyntheticState.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/TypeManifestation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/Visibility.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/PackageDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDefinition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeVariableToken.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/Nexus.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/NexusAccessor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/TargetType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/Transformer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/TypeResolutionStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoader.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/InjectionClassLoader.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/MultipleParentClassLoader.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/NoOpClassFileTransformer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/PackageDefinitionStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/ClassWriterStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/FieldLocator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/FieldRegistry.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodRegistry.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeInitializer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeValidation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/AbstractInliningDynamicTypeBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/DecoratingDynamicTypeBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/InliningImplementationMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/MethodNameTransformer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTarget.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTarget.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/DefaultMethodCall.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/EqualsMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/ExceptionMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/HashCodeMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/LoadedTypeInitializer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodAccessorFactory.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/StubMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/SuperMethodCall.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/ToStringMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationAppender.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationRetention.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationValueFilter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/FieldAttributeAppender.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/MethodAttributeAppender.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/TypeAttributeAppender.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/AuxiliaryType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/PrivilegedMemberLookupAction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TrivialType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TypeProxy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/ArgumentTypeResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/DeclaringTypeResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/MethodDelegationBinder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/MethodNameEqualityResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/ParameterLengthResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/AllArguments.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Argument.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/BindingPriority.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Default.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultCall.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Empty.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/IgnoreForBinding.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Origin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/RuntimeType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/StubValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Super.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperCall.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/This.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Addition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/ByteCodeAppender.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Duplication.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Multiplication.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Removal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/StackManipulation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/StackSize.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Throw.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/TypeCreation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/Assigner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/InstanceCheck.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/TypeCasting.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveBoxingDelegate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveTypeAwareAssigner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveUnboxingDelegate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveWideningDelegate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/VoidAwareAssigner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/reference/ReferenceTypeAwareAssigner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/reference/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/collection/ArrayAccess.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/collection/ArrayFactory.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/collection/CollectionFactory.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/collection/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/ClassConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/DefaultValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/DoubleConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/FieldConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/FloatConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/IntegerConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/JavaConstantValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/LongConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/NullConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/SerializedConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/TextConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/FieldAccess.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/HandleInvocation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodInvocation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodReturn.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccess.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AccessibilityMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AnnotationTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ArrayTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/BooleanMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CachingMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderHierarchyMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderParentMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionElementMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionErasureMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionItemMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionOneToOneMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionSizeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringAnnotationMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringFieldMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringMethodMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DefinedShapeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DescriptorMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/EqualityMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ErasureMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/FailSafeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/FieldTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/FilterableList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/HasSuperTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/InheritedAnnotationMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/InstanceTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/IsNamedMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/LatentMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodExceptionTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodOverrideMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypesMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParametersMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodReturnTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodSortMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ModifierMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NameMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NegatingMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NullMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/PrimitiveTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SignatureTokenMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/StringMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SubTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SuperTypeMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/TypeSortMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/VisibilityMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/CompoundList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaModule.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/OpenedClassReader.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/RandomString.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/StreamDrainer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/privilege/GetSystemPropertyAction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/privilege/SetAccessibleAction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/privilege/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/ExceptionTableSensitiveMethodVisitor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/LineNumberPrependingMethodVisitor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/MetadataAwareClassVisitor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/StackAwareMethodVisitor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/precompiled/java/net/bytebuddy/build/CachedReturnPlugin$Object.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/precompiled/java/net/bytebuddy/build/CachedReturnPlugin$boolean.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/precompiled/java/net/bytebuddy/build/CachedReturnPlugin$byte.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/precompiled/java/net/bytebuddy/build/CachedReturnPlugin$char.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 - 2018 Rafael Winterhalter
+ * Copyright 2014 - 2019 Rafael Winterhalter
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -4453,7 +4453,7 @@ public ClassFileLocator resolve(String name,
     }
 
     /**
-     * A decorator that allows to change the class file transformer that is registered
+     * A decorator that allows to change the class file transformer that is registered.
      */
     interface TransformerDecorator {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -59,6 +59,7 @@
 import net.bytebuddy.implementation.bytecode.member.MethodReturn;
 import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
 import net.bytebuddy.matcher.ElementMatcher;
+import net.bytebuddy.matcher.ElementMatchers;
 import net.bytebuddy.matcher.LatentMatcher;
 import net.bytebuddy.pool.TypePool;
 import net.bytebuddy.utility.CompoundList;
@@ -8347,7 +8348,7 @@ public Default(ByteBuddy byteBuddy) {
                     ClassFileBufferStrategy.Default.RETAINING,
                     InstallationListener.NoOp.INSTANCE,
                     new RawMatcher.Disjunction(
-                            new RawMatcher.ForElementMatchers(any(), isBootstrapClassLoader()),
+                            new RawMatcher.ForElementMatchers(any(), isBootstrapClassLoader().or(isExtensionClassLoader())),
                             new RawMatcher.ForElementMatchers(nameStartsWith("net.bytebuddy.").or(nameStartsWith("sun.reflect.")).<TypeDescription>or(isSynthetic()))),
                     Transformation.Ignored.INSTANCE);
         }

File: byte-buddy-dep/src/test/java/NoPackageType.java
Patch:
@@ -1,2 +0,0 @@
-public class NoPackageType {
-}

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderTest.java
Patch:
@@ -22,6 +22,7 @@
 import net.bytebuddy.test.scope.GenericType;
 import net.bytebuddy.test.utility.InjectionStrategyResolver;
 import net.bytebuddy.test.utility.JavaVersionRule;
+import net.bytebuddy.utility.JavaType;
 import org.hamcrest.CoreMatchers;
 import org.junit.Rule;
 import org.junit.Test;
@@ -44,6 +45,7 @@
 import static net.bytebuddy.matcher.ElementMatchers.named;
 import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.Assert.assertTrue;
 
 public class SubclassDynamicTypeBuilderTest extends AbstractDynamicTypeBuilderTest {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -1409,7 +1409,9 @@ public Map<String, Class<?>> injectRaw(Map<? extends String, byte[]> types) {
             Map<String, Class<?>> result = new HashMap<String, Class<?>>();
             for (Map.Entry<? extends String, byte[]> entry : types.entrySet()) {
                 int index = entry.getKey().lastIndexOf('.');
-                if (index == -1 || !entry.getKey().substring(0, index).equals(TypeDescription.ForLoadedType.of(lookupType()).getPackage().getName())) {
+                String expectedPackage = TypeDescription.ForLoadedType.of(lookupType()).getPackage().getName();
+                String actualPackage = index == -1 ? "" : entry.getKey().substring(0, index);
+                if (!expectedPackage.equals(actualPackage)) {
                     throw new IllegalArgumentException(entry.getKey() + " must be defined in the same package as " + lookup);
                 }
                 result.put(entry.getKey(), DISPATCHER.defineClass(lookup, entry.getValue()));

File: byte-buddy-dep/src/test/java/NoPackageType.java
Patch:
@@ -0,0 +1,2 @@
+public class NoPackageType {
+}

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -348,9 +348,7 @@ public int compareTo(ClassFileVersion other) {
                 : getMajorVersion() - other.getMajorVersion());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "Java " + getJavaVersion();
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -128,9 +128,7 @@ public MethodBinding bind(Implementation.Target implementationTarget,
             return methodDelegationBindingBuilder.build(methodTermination);
         }
 
-        /**
-         * {@inheritDoc}
-         */
+        @Override
         public String toString() {
             return candidate.toString();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AccessibilityMatcher.java
Patch:
@@ -33,9 +33,7 @@ public boolean matches(T target) {
         return target.isAccessibleTo(typeDescription);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "isAccessibleTo(" + typeDescription + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AnnotationTypeMatcher.java
Patch:
@@ -33,9 +33,7 @@ public boolean matches(T target) {
         return matcher.matches(target.getAnnotationType());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "ofAnnotationType(" + matcher + ')';
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/BooleanMatcher.java
Patch:
@@ -31,9 +31,7 @@ public boolean matches(T target) {
         return matches;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return Boolean.toString(matches);
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CachingMatcher.java
Patch:
@@ -60,9 +60,7 @@ protected boolean onCacheMiss(T target) {
         return cached;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "cached(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderHierarchyMatcher.java
Patch:
@@ -39,9 +39,7 @@ public boolean matches(T target) {
         return matcher.matches(null);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "hasChild(" + matcher + ')';
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderParentMatcher.java
Patch:
@@ -38,9 +38,7 @@ public boolean matches(T target) {
         return target == null;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "isParentOf(" + classLoader + ')';
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionElementMatcher.java
Patch:
@@ -49,9 +49,7 @@ public boolean matches(Iterable<? extends T> target) {
         return iterator.hasNext() && matcher.matches(iterator.next());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "with(" + index + " matches " + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionErasureMatcher.java
Patch:
@@ -40,9 +40,7 @@ public boolean matches(T target) {
         return matcher.matches(typeDescriptions);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "erasures(" + matcher + ')';
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionItemMatcher.java
Patch:
@@ -37,9 +37,7 @@ public boolean matches(Iterable<? extends T> target) {
         return false;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "whereOne(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionOneToOneMatcher.java
Patch:
@@ -48,9 +48,7 @@ public boolean matches(Iterable<? extends T> target) {
         return true;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         StringBuilder stringBuilder = new StringBuilder("containing(");
         boolean first = true;

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionSizeMatcher.java
Patch:
@@ -43,9 +43,7 @@ public boolean matches(T target) {
         }
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "ofSize(" + size + ')';
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringAnnotationMatcher.java
Patch:
@@ -33,9 +33,7 @@ public boolean matches(T target) {
         return matcher.matches(target.getDeclaredAnnotations());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "declaresAnnotations(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringFieldMatcher.java
Patch:
@@ -34,9 +34,7 @@ public boolean matches(T target) {
         return matcher.matches(target.getDeclaredFields());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "declaresFields(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringMethodMatcher.java
Patch:
@@ -34,9 +34,7 @@ public boolean matches(T target) {
         return matcher.matches(target.getDeclaredMethods());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "declaresMethods(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringTypeMatcher.java
Patch:
@@ -36,9 +36,7 @@ public boolean matches(T target) {
         return declaringType != null && matcher.matches(declaringType.asGenericType());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "declaredBy(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DefinedShapeMatcher.java
Patch:
@@ -34,9 +34,7 @@ public boolean matches(T target) {
         return matcher.matches(target.asDefined());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "isDefinedAs(" + matcher + ')';
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DescriptorMatcher.java
Patch:
@@ -32,9 +32,7 @@ public boolean matches(T target) {
         return matcher.matches(target.getDescriptor());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "hasDescriptor(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/EqualityMatcher.java
Patch:
@@ -31,9 +31,7 @@ public boolean matches(T target) {
         return value.equals(target);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "is(" + value + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ErasureMatcher.java
Patch:
@@ -35,9 +35,7 @@ public boolean matches(T target) {
         return matcher.matches(target.asErasure());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "erasure(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/FailSafeMatcher.java
Patch:
@@ -42,9 +42,7 @@ public boolean matches(T target) {
         }
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "failSafe(try(" + matcher + ") or " + fallback + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/FieldTypeMatcher.java
Patch:
@@ -33,9 +33,7 @@ public boolean matches(T target) {
         return matcher.matches(target.getType());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "ofType(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/InheritedAnnotationMatcher.java
Patch:
@@ -33,9 +33,7 @@ public boolean matches(T target) {
         return matcher.matches(target.getInheritedAnnotations());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "inheritsAnnotations(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/InstanceTypeMatcher.java
Patch:
@@ -32,9 +32,7 @@ public boolean matches(T target) {
         return target != null && matcher.matches(TypeDescription.ForLoadedType.of(target.getClass()));
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "ofType(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/IsNamedMatcher.java
Patch:
@@ -18,9 +18,7 @@ public boolean matches(T target) {
         return target.isNamed();
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "isNamed()";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodExceptionTypeMatcher.java
Patch:
@@ -33,9 +33,7 @@ public boolean matches(T target) {
         return matcher.matches(target.getExceptionTypes());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "exceptions(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodOverrideMatcher.java
Patch:
@@ -83,9 +83,7 @@ private boolean matches(MethodDescription target, TypeDefinition typeDefinition)
         return false;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "isOverriddenFrom(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypeMatcher.java
Patch:
@@ -33,9 +33,7 @@ public boolean matches(T target) {
         return matcher.matches(target.getType());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "hasType(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypesMatcher.java
Patch:
@@ -35,9 +35,7 @@ public boolean matches(T target) {
         return matcher.matches(target.asTypeList());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "hasTypes(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParametersMatcher.java
Patch:
@@ -34,9 +34,7 @@ public boolean matches(T target) {
         return matcher.matches(target.getParameters());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "hasParameter(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodReturnTypeMatcher.java
Patch:
@@ -33,9 +33,7 @@ public boolean matches(T target) {
         return matcher.matches(target.getReturnType());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "returns(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NameMatcher.java
Patch:
@@ -39,9 +39,7 @@ public boolean matches(T target) {
         return matcher.matches(target.getActualName());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "name(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NegatingMatcher.java
Patch:
@@ -31,9 +31,7 @@ public boolean matches(T target) {
         return !matcher.matches(target);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "not(" + matcher + ')';
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NullMatcher.java
Patch:
@@ -17,9 +17,7 @@ public boolean matches(T target) {
         return target == null;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "isNull()";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SignatureTokenMatcher.java
Patch:
@@ -32,9 +32,7 @@ public boolean matches(T target) {
         return matcher.matches(target.asSignatureToken());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "signature(" + matcher + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/StringMatcher.java
Patch:
@@ -38,9 +38,7 @@ public boolean matches(String target) {
         return mode.matches(value, target);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return mode.getDescription() + '(' + value + ')';
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SubTypeMatcher.java
Patch:
@@ -32,9 +32,7 @@ public boolean matches(T target) {
         return target.isAssignableTo(typeDescription);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "isSubTypeOf(" + typeDescription + ')';
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SuperTypeMatcher.java
Patch:
@@ -32,9 +32,7 @@ public boolean matches(T target) {
         return target.isAssignableFrom(typeDescription);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "isSuperTypeOf(" + typeDescription + ')';
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/TypeSortMatcher.java
Patch:
@@ -32,9 +32,7 @@ public boolean matches(T target) {
         return matcher.matches(target.getSort());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "ofSort(" + matcher + ')';
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/VisibilityMatcher.java
Patch:
@@ -33,9 +33,7 @@ public boolean matches(T target) {
         return target.isVisibleTo(typeDescription);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public String toString() {
         return "isVisibleTo(" + typeDescription + ")";
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberSubstitution.java
Patch:
@@ -958,7 +958,7 @@ public FieldDescription resolve(TypeDescription targetType, ByteCodeElement targ
                             } else if (fields.size() > 1) {
                                 throw new IllegalStateException("Ambiguous field location of " + fields);
                             }
-                            current = instrumentedType.getSuperClass();
+                            current = current.getSuperClass();
                         } while (current != null);
                         throw new IllegalStateException("Cannot locate field matching " + matcher + " on " + targetType);
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -1500,7 +1500,7 @@ public Factory(MethodCall methodCall) {
                  * {@inheritDoc}
                  */
                 public InstrumentedType prepare(InstrumentedType instrumentedType) {
-                    return instrumentedType;
+                    return methodCall.prepare(instrumentedType);
                 }
 
                 /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/Plugin.java
Patch:
@@ -3207,7 +3207,7 @@ public Engine ignore(ElementMatcher<? super TypeDescription> matcher) {
                         classFileLocator,
                         listener,
                         errorHandler,
-                        ignoredTypeMatcher.or(matcher));
+                        ignoredTypeMatcher.<TypeDescription>or(matcher));
             }
 
             /**

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/TransformationAction.java
Patch:
@@ -90,8 +90,8 @@ private void apply(File root, Iterable<? extends File> classPath) throws IOExcep
                                     Plugin.Factory.UsingReflection.ArgumentResolver.ForType.of(Logger.class, project.getLogger()),
                                     Plugin.Factory.UsingReflection.ArgumentResolver.ForType.of(BuildLogger.class, new GradleBuildLogger(project.getLogger()))));
                     project.getLogger().info("Resolved plugin: {}", transformation.getRawPlugin());
-                } catch (Exception exception) {
-                    throw new GradleException("Cannot resolve plugin: " + transformation.getRawPlugin(), exception);
+                } catch (Throwable throwable) {
+                    throw new GradleException("Cannot resolve plugin: " + transformation.getRawPlugin(), throwable);
                 }
             }
             EntryPoint entryPoint = byteBuddyExtension.getInitialization().getEntryPoint(classLoaderResolver, root, classPath);

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/ByteBuddyMojo.java
Patch:
@@ -231,8 +231,8 @@ private void apply(File root, List<? extends String> classPath) throws MojoExecu
                                     Plugin.Factory.UsingReflection.ArgumentResolver.ForType.of(Log.class, getLog()),
                                     Plugin.Factory.UsingReflection.ArgumentResolver.ForType.of(BuildLogger.class, new MavenBuildLogger(getLog()))));
                     getLog().info("Resolved plugin: " + transformation.getRawPlugin());
-                } catch (Exception exception) {
-                    throw new MojoExecutionException("Cannot resolve plugin: " + transformation.getRawPlugin(), exception);
+                } catch (Throwable throwable) {
+                    throw new MojoExecutionException("Cannot resolve plugin: " + transformation.getRawPlugin(), throwable);
                 }
             }
             EntryPoint entryPoint = (initialization == null

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/Initialization.java
Patch:
@@ -7,7 +7,7 @@
 /**
  * Defines a configuration for a Maven build's type transformation.
  */
-@SuppressFBWarnings(value = "UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD", justification = "Written to by Maven")
+@SuppressFBWarnings(value = "UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD", justification = "Written to by Maven.")
 public class Initialization extends AbstractUserConfiguration {
 
     /**

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/PluginArgument.java
Patch:
@@ -1,10 +1,12 @@
 package net.bytebuddy.build.maven;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.build.Plugin;
 
 /**
  * Describes an argument to a {@link Plugin} constuctor.
  */
+@SuppressFBWarnings(value = "UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD", justification = "Written to by Maven.")
 public class PluginArgument {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/Plugin.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.build;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.description.type.TypeDescription;
@@ -1963,6 +1964,7 @@ interface Element {
                 /**
                  * An element representation for a byte array.
                  */
+                @SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "Not mutating the byte array is part of the class contract.")
                 @HashCodeAndEqualsPlugin.Enhance
                 class ForByteArray implements Element {
 
@@ -2346,6 +2348,7 @@ public boolean hasNext() {
                     /**
                      * {@inheritDoc}
                      */
+                    @SuppressFBWarnings(value = "IT_NO_SUCH_ELEMENT", justification = "Exception is thrown by invoking removeFirst on an empty list.")
                     public Element next() {
                         try {
                             return new Element.ForFile(folder, files.removeFirst());

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/Plugin.java
Patch:
@@ -479,7 +479,7 @@ class ForIndex implements ArgumentResolver {
                     /**
                      * A mapping of primitive types to their wrapper types.
                      */
-                    protected static final Map<Class<?>, Class<?>> WRAPPER_TYPES;
+                    private static final Map<Class<?>, Class<?>> WRAPPER_TYPES;
 
                     /*
                      * Creates the primitive to wrapper type mapping.

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/TypeReferenceAdjustment.java
Patch:
@@ -74,7 +74,7 @@ public static TypeReferenceAdjustment relaxed() {
      * @return A new type reference adjustment that uses the supplied filter for excluding types.
      */
     public TypeReferenceAdjustment filter(ElementMatcher<? super TypeDescription> filter) {
-        return new TypeReferenceAdjustment(strict, this.filter.or(filter));
+        return new TypeReferenceAdjustment(strict, this.filter.<TypeDescription>or(filter));
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -497,6 +497,7 @@ protected Direct(Method findLoadedClass,
                  * @return A direct dispatcher for class injection.
                  * @throws Exception If the creation is impossible.
                  */
+                @SuppressFBWarnings(value = "DP_DO_INSIDE_DO_PRIVILEGED", justification = "Privilege is explicit caller responsibility")
                 protected static Initializable make() throws Exception {
                     Method getPackage;
                     if (JavaModule.isSupported()) { // Avoid accidental lookup of method with same name in Java 8 J9 VM.
@@ -552,7 +553,6 @@ public boolean isAvailable() {
                 /**
                  * {@inheritDoc}
                  */
-                @SuppressFBWarnings(value = {"DP_DO_INSIDE_DO_PRIVILEGED", "REC_CATCH_EXCEPTION"}, justification = "Privilege is explicit user responsibility")
                 public Dispatcher initialize() {
                     SecurityManager securityManager = System.getSecurityManager();
                     if (securityManager != null) {
@@ -1887,7 +1887,6 @@ public boolean isAvailable() {
                 /**
                  * {@inheritDoc}
                  */
-                @SuppressFBWarnings(value = "DP_DO_INSIDE_DO_PRIVILEGED", justification = "Privilege is explicit caller responsibility")
                 public Dispatcher initialize() {
                     SecurityManager securityManager = System.getSecurityManager();
                     if (securityManager != null) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -6310,7 +6310,7 @@ protected LazyNestMemberList(TypeDescription typeDescription, TypePool typePool,
                 public TypeDescription get(int index) {
                     return index == 0
                             ? typeDescription
-                            : typePool.describe(nestMembers.get(index)).resolve();
+                            : typePool.describe(nestMembers.get(index - 1)).resolve();
                 }
 
                 /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/AbstractMethodDescriptionTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.description.method;
 
+import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.description.TypeVariableSource;
 import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.annotation.AnnotationList;
@@ -513,7 +514,8 @@ public void testMethodIsAccessibleTo() throws Exception {
         assertThat(describe(PublicType.class.getDeclaredMethod("packagePrivateMethod"))
                 .isAccessibleTo(TypeDescription.ForLoadedType.of(Sample.class)), is(true));
         assertThat(describe(PublicType.class.getDeclaredMethod("privateMethod"))
-                .isAccessibleTo(TypeDescription.ForLoadedType.of(Sample.class)), is(false));
+                        .isAccessibleTo(TypeDescription.ForLoadedType.of(Sample.class)),
+                is(ClassFileVersion.of(PublicType.class).isAtLeast(ClassFileVersion.JAVA_V11))); // introduction of nest mates
         assertThat(describe(PublicType.class.getDeclaredMethod("publicMethod"))
                 .isAccessibleTo(TypeDescription.OBJECT), is(true));
         assertThat(describe(PublicType.class.getDeclaredMethod("protectedMethod"))

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -6581,7 +6581,7 @@ public boolean isRetransformClassesSupported(Instrumentation instrumentation) {
                  * {@inheritDoc}
                  */
                 public void retransformClasses(Instrumentation instrumentation, Class<?>[] type) {
-                    throw new IllegalStateException("The current VM does not support retransformation");
+                    throw new UnsupportedOperationException("The current VM does not support retransformation");
                 }
             }
 
@@ -9300,15 +9300,15 @@ public boolean isNativeMethodPrefixSupported(Instrumentation instrumentation) {
                  * {@inheritDoc}
                  */
                 public void setNativeMethodPrefix(Instrumentation instrumentation, ClassFileTransformer classFileTransformer, String prefix) {
-                    throw new IllegalStateException("The current VM does not support native method prefixes");
+                    throw new UnsupportedOperationException("The current VM does not support native method prefixes");
                 }
 
                 /**
                  * {@inheritDoc}
                  */
                 public void addTransformer(Instrumentation instrumentation, ClassFileTransformer classFileTransformer, boolean canRetransform) {
                     if (canRetransform) {
-                        throw new IllegalStateException("The current VM does not support retransformation");
+                        throw new UnsupportedOperationException("The current VM does not support retransformation");
                     }
                     instrumentation.addTransformer(classFileTransformer);
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -523,21 +523,21 @@ enum ForLegacyVm implements Dispatcher {
                  * {@inheritDoc}
                  */
                 public int getModifiers(AccessibleObject executable, int index) {
-                    throw new IllegalStateException("Cannot dispatch method for java.lang.reflect.Parameter");
+                    throw new UnsupportedOperationException("Cannot dispatch method for java.lang.reflect.Parameter");
                 }
 
                 /**
                  * {@inheritDoc}
                  */
                 public boolean isNamePresent(AccessibleObject executable, int index) {
-                    throw new IllegalStateException("Cannot dispatch method for java.lang.reflect.Parameter");
+                    throw new UnsupportedOperationException("Cannot dispatch method for java.lang.reflect.Parameter");
                 }
 
                 /**
                  * {@inheritDoc}
                  */
                 public String getName(AccessibleObject executable, int index) {
-                    throw new IllegalStateException("Cannot dispatch method for java.lang.reflect.Parameter");
+                    throw new UnsupportedOperationException("Cannot dispatch method for java.lang.reflect.Parameter");
                 }
             }
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -2571,7 +2571,7 @@ public Generic resolveReceiverType(AccessibleObject executable) {
                      * {@inheritDoc}
                      */
                     public Generic resolve(AnnotatedElement annotatedType) {
-                        throw new IllegalStateException("Loaded annotated type cannot be represented on this VM");
+                        throw new UnsupportedOperationException("Loaded annotated type cannot be represented on this VM");
                     }
                 }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -1623,7 +1623,7 @@ public Unresolved(String message) {
                          * {@inheritDoc}
                          */
                         public Dispatcher initialize() {
-                            throw new IllegalStateException("Could not locate classes vector: " + message);
+                            throw new UnsupportedOperationException("Could not locate classes vector: " + message);
                         }
                     }
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/NexusAccessor.java
Patch:
@@ -322,7 +322,7 @@ public boolean isAlive() {
              * {@inheritDoc}
              */
             public void clean(Reference<? extends ClassLoader> reference) {
-                throw new IllegalStateException("Could not initialize Nexus accessor: " + message);
+                throw new UnsupportedOperationException("Could not initialize Nexus accessor: " + message);
             }
 
             /**
@@ -333,7 +333,7 @@ public void register(String name,
                                  ReferenceQueue<? super ClassLoader> referenceQueue,
                                  int identification,
                                  LoadedTypeInitializer loadedTypeInitializer) {
-                throw new IllegalStateException("Could not initialize Nexus accessor: " + message);
+                throw new UnsupportedOperationException("Could not initialize Nexus accessor: " + message);
             }
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -373,7 +373,7 @@ public boolean isRetransformClassesSupported(Instrumentation instrumentation) {
              */
             public void addTransformer(Instrumentation instrumentation, ClassFileTransformer classFileTransformer, boolean canRetransform) {
                 if (canRetransform) {
-                    throw new IllegalStateException();
+                    throw new UnsupportedOperationException("Cannot apply retransformation on legacy VM");
                 } else {
                     instrumentation.addTransformer(classFileTransformer);
                 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/ParameterDescriptionForLoadedParameterDispatcherTest.java
Patch:
@@ -16,17 +16,17 @@ public void setUp() throws Exception {
         accessibleObject = Foo.class.getDeclaredConstructor();
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test(expected = UnsupportedOperationException.class)
     public void testLegacyVmGetName() throws Exception {
         ParameterDescription.ForLoadedParameter.Dispatcher.ForLegacyVm.INSTANCE.getName(accessibleObject, FOO);
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test(expected = UnsupportedOperationException.class)
     public void testLegacyVmGetModifiers() throws Exception {
         ParameterDescription.ForLoadedParameter.Dispatcher.ForLegacyVm.INSTANCE.getModifiers(accessibleObject, FOO);
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test(expected = UnsupportedOperationException.class)
     public void testLegacyVmIsNamePresent() throws Exception {
         ParameterDescription.ForLoadedParameter.Dispatcher.ForLegacyVm.INSTANCE.isNamePresent(accessibleObject, FOO);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericAnnotationReaderTest.java
Patch:
@@ -28,7 +28,7 @@ public void testLegacyVmReturnsNoOpReaders() throws Exception {
                 nullValue(TypeDescription.Generic.class));
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test(expected = UnsupportedOperationException.class)
     public void testCannotResolveAnnotatedType() throws Exception {
         TypeDescription.Generic.AnnotationReader.Dispatcher.ForLegacyVm.INSTANCE.resolve(null);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/NexusTest.java
Patch:
@@ -186,12 +186,12 @@ public void testUnavailableState() throws Exception {
         assertThat(new NexusAccessor.Dispatcher.Unavailable("unavailable").isAlive(), is(false));
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test(expected = UnsupportedOperationException.class)
     public void testUnavailableDispatcherRegisterThrowsException() throws Exception {
         new NexusAccessor.Dispatcher.Unavailable("unavailable").register(FOO, classLoader, Nexus.NO_QUEUE, BAR, loadedTypeInitializer);
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test(expected = UnsupportedOperationException.class)
     @SuppressWarnings("unchecked")
     public void testUnavailableDispatcherCleanThrowsException() throws Exception {
         new NexusAccessor.Dispatcher.Unavailable("unavailable").clean(mock(Reference.class));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassInjectorUsingReflectionTest.java
Patch:
@@ -155,20 +155,20 @@ public void testDispatcherFaultyInitializationDefinePackage() throws Exception {
 
     @Test(expected = UnsupportedOperationException.class)
     public void testDispatcherFaultyDispatcherDefineClass() throws Exception {
-        new ClassInjector.UsingReflection.Dispatcher.Unavailable(new Exception()).defineClass(null,
+        new ClassInjector.UsingReflection.Dispatcher.Unavailable(FOO).defineClass(null,
                 null,
                 null,
                 null);
     }
 
     @Test(expected = UnsupportedOperationException.class)
     public void testDispatcherFaultyDispatcherGetPackage() throws Exception {
-        new ClassInjector.UsingReflection.Dispatcher.Unavailable(new Exception()).getPackage(null, null);
+        new ClassInjector.UsingReflection.Dispatcher.Unavailable(FOO).getPackage(null, null);
     }
 
     @Test(expected = UnsupportedOperationException.class)
     public void testDispatcherFaultyDispatcherDefinePackage() throws Exception {
-        new ClassInjector.UsingReflection.Dispatcher.Unavailable(new Exception()).definePackage(null,
+        new ClassInjector.UsingReflection.Dispatcher.Unavailable(FOO).definePackage(null,
                 null,
                 null,
                 null,

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassInjectorUsingUnsafeTest.java
Patch:
@@ -43,12 +43,12 @@ public void testUnsafeInjection() throws Exception {
     public void testAvailability() throws Exception {
         assertThat(ClassInjector.UsingUnsafe.isAvailable(), is(true));
         assertThat(new ClassInjector.UsingUnsafe(ClassLoader.getSystemClassLoader()).isAlive(), is(true));
-        assertThat(new ClassInjector.UsingUnsafe.Dispatcher.Disabled(null).isAvailable(), is(false));
+        assertThat(new ClassInjector.UsingUnsafe.Dispatcher.Unavailable(null).isAvailable(), is(false));
     }
 
     @Test(expected = RuntimeException.class)
     public void testUnavailableThrowsException() throws Exception {
-        new ClassInjector.UsingUnsafe.Dispatcher.Disabled("foo").initialize();
+        new ClassInjector.UsingUnsafe.Dispatcher.Unavailable("foo").initialize();
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaConstantMethodTypeDispatcherTest.java
Patch:
@@ -6,12 +6,12 @@
 
 public class JavaConstantMethodTypeDispatcherTest {
 
-    @Test(expected = IllegalStateException.class)
+    @Test(expected = UnsupportedOperationException.class)
     public void testLegacyVmReturnType() throws Exception {
         JavaConstant.MethodType.Dispatcher.ForLegacyVm.INSTANCE.returnType(mock(Object.class));
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test(expected = UnsupportedOperationException.class)
     public void testLegacyVmParameterArray() throws Exception {
         JavaConstant.MethodType.Dispatcher.ForLegacyVm.INSTANCE.parameterArray(mock(Object.class));
     }

File: byte-buddy-dep/src/main/resources/net/bytebuddy/build/CachedReturnPlugin$boolean.java
Patch:
@@ -6,6 +6,7 @@
 /**
  * An advice class for caching a {@code boolean} value.
  */
+@SuppressFBWarnings(value = "NM_CLASS_NAMING_CONVENTION", justification = "Name is chosen to optimize for simple lookup")
 class CachedReturnPlugin$boolean {
 
     /**

File: byte-buddy-dep/src/main/resources/net/bytebuddy/build/CachedReturnPlugin$byte.java
Patch:
@@ -6,6 +6,7 @@
 /**
  * An advice class for caching a {@code byte} value.
  */
+@SuppressFBWarnings(value = "NM_CLASS_NAMING_CONVENTION", justification = "Name is chosen to optimize for simple lookup")
 class CachedReturnPlugin$byte {
 
     /**

File: byte-buddy-dep/src/main/resources/net/bytebuddy/build/CachedReturnPlugin$char.java
Patch:
@@ -6,6 +6,7 @@
 /**
  * An advice class for caching a {@code char} value.
  */
+@SuppressFBWarnings(value = "NM_CLASS_NAMING_CONVENTION", justification = "Name is chosen to optimize for simple lookup")
 class CachedReturnPlugin$char {
 
     /**

File: byte-buddy-dep/src/main/resources/net/bytebuddy/build/CachedReturnPlugin$double.java
Patch:
@@ -6,6 +6,7 @@
 /**
  * An advice class for caching a {@code double} value.
  */
+@SuppressFBWarnings(value = "NM_CLASS_NAMING_CONVENTION", justification = "Name is chosen to optimize for simple lookup")
 class CachedReturnPlugin$double {
 
     /**

File: byte-buddy-dep/src/main/resources/net/bytebuddy/build/CachedReturnPlugin$float.java
Patch:
@@ -6,6 +6,7 @@
 /**
  * An advice class for caching a {@code float} value.
  */
+@SuppressFBWarnings(value = "NM_CLASS_NAMING_CONVENTION", justification = "Name is chosen to optimize for simple lookup")
 class CachedReturnPlugin$float {
 
     /**

File: byte-buddy-dep/src/main/resources/net/bytebuddy/build/CachedReturnPlugin$int.java
Patch:
@@ -6,6 +6,7 @@
 /**
  * An advice class for caching a {@code int} value.
  */
+@SuppressFBWarnings(value = "NM_CLASS_NAMING_CONVENTION", justification = "Name is chosen to optimize for simple lookup")
 class CachedReturnPlugin$int {
 
     /**

File: byte-buddy-dep/src/main/resources/net/bytebuddy/build/CachedReturnPlugin$long.java
Patch:
@@ -6,6 +6,7 @@
 /**
  * An advice class for caching a {@code long} value.
  */
+@SuppressFBWarnings(value = "NM_CLASS_NAMING_CONVENTION", justification = "Name is chosen to optimize for simple lookup")
 class CachedReturnPlugin$long {
 
     /**

File: byte-buddy-dep/src/main/resources/net/bytebuddy/build/CachedReturnPlugin$short.java
Patch:
@@ -6,6 +6,7 @@
 /**
  * An advice class for caching a {@code short} value.
  */
+@SuppressFBWarnings(value = "NM_CLASS_NAMING_CONVENTION", justification = "Name is chosen to optimize for simple lookup")
 class CachedReturnPlugin$short {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -4500,14 +4500,14 @@ protected Collector make() {
          * </p>
          */
         RETRANSFORMATION(true, true) {
-            /** {@inheritDoc} */
+            @Override
             protected void check(Instrumentation instrumentation) {
                 if (!instrumentation.isRetransformClassesSupported()) {
                     throw new IllegalStateException("Cannot apply redefinition on " + instrumentation);
                 }
             }
 
-            /** {@inheritDoc} */
+            @Override
             protected Collector make() {
                 return new Collector.ForRetransformation();
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -435,7 +435,7 @@ protected ForJava6CapableVm(Method isModifiableClass,
              */
             public boolean isModifiableClass(Instrumentation instrumentation, Class<?> type) {
                 try {
-                    return (Boolean) isModifiableClass.invoke(instrumentation);
+                    return (Boolean) isModifiableClass.invoke(instrumentation, type);
                 } catch (IllegalAccessException exception) {
                     throw new IllegalStateException("Cannot access java.lang.instrument.Instrumentation#isModifiableClass", exception);
                 } catch (InvocationTargetException exception) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -7215,6 +7215,7 @@ public TypeList getNestMembers() {
     /**
      * A type description implementation that represents a loaded type.
      */
+    @SuppressFBWarnings(value = "SE_TRANSIENT_FIELD_NOT_RESTORED", justification = "Field is only used as a cache store and is implicitly recomputed")
     class ForLoadedType extends AbstractBase implements Serializable {
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -7215,7 +7215,6 @@ public TypeList getNestMembers() {
     /**
      * A type description implementation that represents a loaded type.
      */
-    @SuppressFBWarnings(value = "SE_BAD_FIELD", justification = "Build plugin does not currently support transient field generation")
     class ForLoadedType extends AbstractBase implements Serializable {
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -6974,7 +6974,7 @@ public void visitInnerClass(String internalName, String outerName, String innerN
                             typeContainment = new LazyTypeDescription.TypeContainment.WithinType(outerName, false);
                         }
                     }
-                } else if (outerName != null && innerName != null && internalName.equals(this.internalName + "$" + innerName)) {
+                } else if (outerName != null && innerName != null && outerName.equals(this.internalName)) {
                     declaredTypes.add("L" + internalName + ";");
                 }
             }

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/PluginNoOpTest.java
Patch:
@@ -19,7 +19,7 @@ public void setUp() throws Exception {
         plugin = new Plugin.NoOp();
     }
 
-    @Test
+    @Test(expected = IllegalStateException.class)
     public void testNoOpApplication() {
         plugin.apply(mock(DynamicType.Builder.class), mock(TypeDescription.class), mock(ClassFileLocator.class));
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/Plugin.java
Patch:
@@ -86,7 +86,7 @@ class Compound implements Plugin {
          * @param plugin The plugins to apply.
          */
         public Compound(Plugin... plugin) {
-            this(Arrays.asList(plugin))
+            this(Arrays.asList(plugin));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -7215,6 +7215,7 @@ public TypeList getNestMembers() {
     /**
      * A type description implementation that represents a loaded type.
      */
+    @SuppressFBWarnings(value = "SE_BAD_FIELD", justification = "Build plugin does not currently support transient field generation")
     class ForLoadedType extends AbstractBase implements Serializable {
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -3774,7 +3774,7 @@ protected InnerTypeDefinitionForTypeAdapter(TypeDescription typeDescription) {
                     @Override
                     public Builder<U> asAnonymousType() {
                         return Adapter.this.materialize(instrumentedType
-                                        .withDeclaringType(typeDescription)
+                                        .withDeclaringType(TypeDescription.UNDEFINED)
                                         .withEnclosingType(typeDescription)
                                         .withAnonymousClass(true)
                                         .withLocalClass(false),

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -7006,7 +7006,7 @@ public boolean isNestMateOf(TypeDescription typeDescription) {
 
         @Override
         public boolean isMemberType() {
-            return !isLocalType() && getEnclosingType() != null;
+            return !isLocalType() && !isAnonymousType() && getDeclaringType() != null;
         }
 
         @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -1210,8 +1210,8 @@ public String getSimpleName() {
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST.opened())
                 .getLoaded();
         Class<?> type = createPlainWithoutValidation()
-                .innerTypeOf(outer)
                 .name(sample.getName())
+                .innerTypeOf(outer)
                 .make()
                 .load((InjectionClassLoader) outer.getClassLoader(), InjectionClassLoader.Strategy.INSTANCE)
                 .getLoaded();
@@ -1271,8 +1271,8 @@ public String getSimpleName() {
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST.opened())
                 .getLoaded();
         Class<?> type = createPlainWithoutValidation()
-                .innerTypeOf(outer.getConstructor())
                 .name(sample.getName())
+                .innerTypeOf(outer.getConstructor())
                 .make()
                 .load((InjectionClassLoader) outer.getClassLoader(), InjectionClassLoader.Strategy.INSTANCE)
                 .getLoaded();
@@ -1316,8 +1316,8 @@ public void visit(int version, int access, String name, String signature, String
                         };
                     }
                 })
-                .nestHost(outer)
                 .name(sample.getName())
+                .nestHost(outer)
                 .make()
                 .load((InjectionClassLoader) outer.getClassLoader(), InjectionClassLoader.Strategy.INSTANCE)
                 .getLoaded();

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -2738,17 +2738,17 @@ public TypeList getDeclaredTypes() {
             }
 
             @Override
-            public boolean isAnonymousClass() {
+            public boolean isAnonymousType() {
                 return anonymousType;
             }
 
             @Override
-            public boolean isLocalClass() {
+            public boolean isLocalType() {
                 return !anonymousType && typeContainment.isLocalType();
             }
 
             @Override
-            public boolean isMemberClass() {
+            public boolean isMemberType() {
                 return typeContainment.isMemberClass();
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/CachedReturnPlugin.java
Patch:
@@ -44,7 +44,8 @@ public CachedReturnPlugin() {
 
     @Override
     public DynamicType.Builder<?> apply(DynamicType.Builder<?> builder, TypeDescription typeDescription) {
-        for (MethodDescription.InDefinedShape methodDescription : typeDescription.getDeclaredMethods().filter(isAnnotatedWith(Enhance.class))) {
+        for (MethodDescription.InDefinedShape methodDescription : typeDescription.getDeclaredMethods()
+                .filter(not(isBridge()).<MethodDescription>and(isAnnotatedWith(Enhance.class)))) {
             if (methodDescription.isAbstract()) {
                 throw new IllegalStateException("Cannot cache the value of an abstract method: " + methodDescription);
             } else if (!methodDescription.getParameters().isEmpty()) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/FieldByFieldComparison.java
Patch:
@@ -55,7 +55,7 @@ private static boolean matches(Class<?> type, Object left, Object right, Set<Pai
         }
         while (type.getName().startsWith("net.bytebuddy.")) {
             for (Field field : type.getDeclaredFields()) {
-                if (Modifier.isStatic(field.getModifiers())) {
+                if (Modifier.isStatic(field.getModifiers()) || field.isSynthetic() && !field.getName().equals("this$0")) {
                     continue;
                 }
                 HashCodeAndEqualsPlugin.ValueHandling valueHandling = field.getAnnotation(HashCodeAndEqualsPlugin.ValueHandling.class);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1318,7 +1318,7 @@ interface InnerTypeDefinition<S> extends Builder<S> {
             /**
              * A builder for defining properties of an inner type that is declared within another type but not a method or constructor.
              *
-             * @param <U>
+             * @param <U> A loaded type that the built type is guaranteed to be a subclass of.
              */
             interface ForType<U> extends InnerTypeDefinition<U> {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -1770,9 +1770,10 @@ public StackManipulation resolve(Target implementationTarget,
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot invoke " + invokedMethod + " on " + resolution.getField());
                 }
-                return new StackManipulation.Compound(invokedMethod.isStatic()
+                return new StackManipulation.Compound(invokedMethod.isStatic() || resolution.getField().isStatic()
                         ? StackManipulation.Trivial.INSTANCE
-                        : MethodVariableAccess.loadThis(), FieldAccess.forField(resolution.getField()).read(), stackManipulation);
+                        : MethodVariableAccess.loadThis(),
+                        FieldAccess.forField(resolution.getField()).read(), stackManipulation);
             }
 
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/DecoratingDynamicTypeBuilderTest.java
Patch:
@@ -16,8 +16,7 @@
 
 import java.lang.annotation.Annotation;
 
-import static net.bytebuddy.matcher.ElementMatchers.any;
-import static net.bytebuddy.matcher.ElementMatchers.named;
+import static net.bytebuddy.matcher.ElementMatchers.*;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.mock;
@@ -31,7 +30,7 @@ public void testDecoration() throws Exception {
         Object instance = new ByteBuddy()
                 .decorate(Foo.class)
                 .annotateType(new Annotation[0])
-                .ignoreAlso(new LatentMatcher.Resolved<MethodDescription>(any()))
+                .ignoreAlso(new LatentMatcher.Resolved<MethodDescription>(none()))
                 .visit(new AsmVisitorWrapper.ForDeclaredMethods()
                         .method(named(FOO), new AsmVisitorWrapper.ForDeclaredMethods.MethodVisitorWrapper() {
                             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeDefaultTest.java
Patch:
@@ -559,7 +559,7 @@ public void testNestMates() throws Exception {
         InstrumentedType instrumentedType = makePlainInstrumentedType();
         assertThat(instrumentedType.getNestMembers().size(), is(1));
         assertThat(instrumentedType.getNestMembers(), hasItems((TypeDescription) instrumentedType));
-        InstrumentedType transformed = instrumentedType.withNestMember(new TypeList.Explicit(typeDescription));
+        InstrumentedType transformed = instrumentedType.withNestMembers(new TypeList.Explicit(typeDescription));
         assertThat(transformed.getNestHost(), is((TypeDescription) transformed));
         assertThat(transformed.getNestMembers(), hasItems(transformed, typeDescription));
     }
@@ -775,14 +775,14 @@ public void testNestHostPrimitive() throws Exception {
     @Test(expected = IllegalStateException.class)
     public void testNestMemberArray() throws Exception {
         makePlainInstrumentedType()
-                .withNestMember(new TypeList.Explicit(TypeDescription.ForLoadedType.of(Object[].class)))
+                .withNestMembers(new TypeList.Explicit(TypeDescription.ForLoadedType.of(Object[].class)))
                 .validated();
     }
 
     @Test(expected = IllegalStateException.class)
     public void testNestMemberPrimitive() throws Exception {
         makePlainInstrumentedType()
-                .withNestMember(new TypeList.Explicit(TypeDescription.ForLoadedType.of(void.class)))
+                .withNestMembers(new TypeList.Explicit(TypeDescription.ForLoadedType.of(void.class)))
                 .validated();
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeFrozenTest.java
Patch:
@@ -95,7 +95,7 @@ public void testWithNestHost() {
 
     @Test(expected = IllegalStateException.class)
     public void testWithNestMember() {
-        new InstrumentedType.Frozen(TypeDescription.STRING, LoadedTypeInitializer.NoOp.INSTANCE).withNestMember(mock(TypeList.class));
+        new InstrumentedType.Frozen(TypeDescription.STRING, LoadedTypeInitializer.NoOp.INSTANCE).withNestMembers(mock(TypeList.class));
     }
 
     @Test(expected = IllegalStateException.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultTest.java
Patch:
@@ -1056,7 +1056,6 @@ public void testVisibilityExtension() throws Exception {
                 Collections.<TypeDescription>emptyList(),
                 false,
                 false,
-                false,
                 TargetType.DESCRIPTION,
                 Collections.<TypeDescription>emptyList());
         MethodDescription.SignatureToken signatureToken = new MethodDescription.SignatureToken("foo",
@@ -1096,7 +1095,6 @@ public void testOrphanedBridge() throws Exception {
                 Collections.<TypeDescription>emptyList(),
                 false,
                 false,
-                false,
                 TargetType.DESCRIPTION,
                 Collections.<TypeDescription>emptyList());
         MethodGraph.Linked methodGraph = MethodGraph.Compiler.Default.forJavaHierarchy().compile(typeDescription);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3809,7 +3809,7 @@ public void visitNestHostExperimental(String nestHost) {
 
                 @Override
                 public void visitOuterClass(String owner, String name, String descriptor) {
-                    onOuterClass();
+                    onOuterType();
                 }
 
                 @Override
@@ -3821,7 +3821,7 @@ protected void onNestHost() {
                 }
 
                 @Override
-                protected void onOuterClass() {
+                protected void onOuterType() {
                     MethodDescription.InDefinedShape enclosingMethod = instrumentedType.getEnclosingMethod();
                     if (enclosingMethod != null) {
                         super.visitOuterClass(enclosingMethod.getDeclaringType().getInternalName(),
@@ -3976,8 +3976,8 @@ protected MethodVisitor redefine(MethodDescription methodDescription, boolean ab
 
                 @Override
                 public void visitInnerClass(String internalName, String outerName, String innerName, int modifiers) {
-                    declaredTypes.remove(internalName);
                     if (!internalName.equals(instrumentedType.getInternalName())) {
+                        declaredTypes.remove(internalName);
                         super.visitInnerClass(internalName, outerName, innerName, modifiers);
                     }
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/visitor/MetadataAwareClassVisitor.java
Patch:
@@ -43,7 +43,7 @@ protected MetadataAwareClassVisitor(int api, ClassVisitor classVisitor) {
     /**
      * Invoked if the outer class was not visited.
      */
-    protected abstract void onOuterClass();
+    protected abstract void onOuterType();
 
     /**
      * Invoked if the attribute visitation is about to complete.
@@ -66,7 +66,7 @@ protected void considerTriggerNestHost() {
     protected void considerTriggerOuterClass() {
         if (triggerOuterClass) {
             triggerOuterClass = false;
-            onOuterClass();
+            onOuterType();
         }
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/visitor/MetadataAwareClassVisitorTest.java
Patch:
@@ -130,7 +130,7 @@ protected void onNestHost() {
         }
 
         @Override
-        protected void onOuterClass() {
+        protected void onOuterType() {
             outerClassVisited = true;
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3976,7 +3976,7 @@ protected MethodVisitor redefine(MethodDescription methodDescription, boolean ab
 
                 @Override
                 public void visitInnerClass(String internalName, String outerName, String innerName, int modifiers) {
-                    declaredTypes.remove(innerName);
+                    declaredTypes.remove(internalName);
                     if (internalName.equals(instrumentedType.getInternalName())) {
                         modifiers = instrumentedType.getModifiers();
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -2802,7 +2802,9 @@ public TypeDescription getNestHost() {
 
             @Override
             public TypeList getNestMembers() {
-                return new LazyNestMemberList(this, typePool, nestMembers);
+                return nestHost == null
+                        ? new LazyNestMemberList(this, typePool, nestMembers)
+                        : typePool.describe(nestHost).resolve().getNestMembers();
             }
 
             @Override

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -316,7 +316,7 @@ protected void connect() throws IOException {
                     }
                 }
                 if (timeout != 0) {
-                  ((AFUNIXSocket) socket).setSoTimeout((int) timeUnit.toMillis(timeout));
+                    ((AFUNIXSocket) socket).setSoTimeout((int) timeUnit.toMillis(timeout));
                 }
                 ((AFUNIXSocket) socket).connect(new AFUNIXSocketAddress(socketFile));
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -1511,7 +1511,7 @@ public static Dynamic ofInvocation(MethodDescription.InDefinedShape methodDescri
             } else if (methodDescription.getParameters().size() + (methodDescription.isStatic() || methodDescription.isConstructor() ? 0 : 1) != rawArguments.size()) {
                 throw new IllegalArgumentException("Cannot assign " + rawArguments + " to " + methodDescription);
             }
-            Iterator<TypeDescription> iterator = (methodDescription.isStatic()
+            Iterator<TypeDescription> iterator = (methodDescription.isStatic() || methodDescription.isConstructor()
                     ? methodDescription.getParameters().asTypeList().asErasures()
                     : CompoundList.of(methodDescription.getDeclaringType(), methodDescription.getParameters().asTypeList().asErasures())).iterator();
             List<Object> arguments = new ArrayList<Object>(rawArguments.size());

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -1763,7 +1763,7 @@ public JavaConstant withType(TypeDescription typeDescription) {
                 throw new IllegalArgumentException("Constant value cannot represent void");
             } else if (value.getBootstrapMethod().getName().equals(MethodDescription.CONSTRUCTOR_INTERNAL_NAME)
                     ? !this.typeDescription.isAssignableTo(typeDescription)
-                    : (!typeDescription.isAssignableTo(this.typeDescription) && !(typeDescription.isPrimitive() && this.typeDescription.represents(Object.class)))) {
+                    : (!typeDescription.asBoxed().isInHierarchyWith(this.typeDescription.asBoxed()))) {
                 throw new IllegalArgumentException(typeDescription + " is not compatible with bootstrapped type " + this.typeDescription);
             }
             return new Dynamic(new org.objectweb.asm.ConstantDynamic(value.getName(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaConstantDynamicTest.java
Patch:
@@ -521,7 +521,7 @@ public void testIllegalTypeResolutionForVoid() throws Exception {
 
     @Test(expected = IllegalArgumentException.class)
     public void testIncompatibleTypeForMethod() throws Exception {
-        JavaConstant.Dynamic.ofInvocation(Object.class.getMethod("toString"), FOO).withType(Object.class);
+        JavaConstant.Dynamic.ofInvocation(Object.class.getMethod("toString"), FOO).withType(Integer.class);
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -1602,7 +1602,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> isEquals(
      * @return A matcher that only matches the {@link Object#clone()} method.
      */
     public static <T extends MethodDescription> ElementMatcher.Junction<T> isClone() {
-        return named("clone").and(takesArguments(0)).and(returns(TypeDescription.OBJECT));
+        return named("clone").and(takesArguments(0));
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -147,7 +147,7 @@ public static AssignerConfigurable value(TypeDescription fixedValue) {
      * @return An implementation for the given {@code value}.
      */
     public static AssignerConfigurable value(JavaConstant fixedValue) {
-        return new ForPoolValue(fixedValue.asStackManipulation(), fixedValue.getType());
+        return new ForPoolValue(new JavaConstantValue(fixedValue), fixedValue.getType());
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -2007,7 +2007,7 @@ protected ForJavaConstant(JavaConstant javaConstant) {
 
                 @Override
                 public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
-                    return new Resolved.Simple(javaConstant.asStackManipulation(), javaConstant.getType());
+                    return new Resolved.Simple(new JavaConstantValue(javaConstant), javaConstant.getType());
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -307,7 +307,7 @@ public MethodCall with(EnumerationDescription... enumerationDescription) {
     public MethodCall with(JavaConstant... javaConstant) {
         List<ArgumentLoader.Factory> argumentLoaders = new ArrayList<ArgumentLoader.Factory>(javaConstant.length);
         for (JavaConstant aJavaConstant : javaConstant) {
-            argumentLoaders.add(new ArgumentLoader.ForStackManipulation(aJavaConstant.asStackManipulation(), aJavaConstant.getType()));
+            argumentLoaders.add(new ArgumentLoader.ForStackManipulation(new JavaConstantValue(aJavaConstant), aJavaConstant.getType()));
         }
         return with(argumentLoaders);
     }
@@ -1386,9 +1386,9 @@ public static ArgumentLoader.Factory of(Object value) {
                 } else if (value instanceof Class) {
                     return new ForStackManipulation(ClassConstant.of(TypeDescription.ForLoadedType.of((Class<?>) value)), Class.class);
                 } else if (JavaType.METHOD_HANDLE.getTypeStub().isInstance(value)) {
-                    return new ForStackManipulation(JavaConstant.MethodHandle.ofLoaded(value).asStackManipulation(), JavaType.METHOD_HANDLE.getTypeStub());
+                    return new ForStackManipulation(new JavaConstantValue(JavaConstant.MethodHandle.ofLoaded(value)), JavaType.METHOD_HANDLE.getTypeStub());
                 } else if (JavaType.METHOD_TYPE.getTypeStub().isInstance(value)) {
-                    return new ForStackManipulation(JavaConstant.MethodType.ofLoaded(value).asStackManipulation(), JavaType.METHOD_TYPE.getTypeStub());
+                    return new ForStackManipulation(new JavaConstantValue(JavaConstant.MethodType.ofLoaded(value)), JavaType.METHOD_TYPE.getTypeStub());
                 } else if (value instanceof Enum<?>) {
                     EnumerationDescription enumerationDescription = new EnumerationDescription.ForLoadedEnumeration((Enum<?>) value);
                     return new ForStackManipulation(FieldAccess.forEnumeration(enumerationDescription), enumerationDescription.getEnumerationType());

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -249,7 +249,7 @@ public ParameterBinding<?> bind(AnnotationDescription.Loadable<S> annotation,
                     stackManipulation = ClassConstant.of((TypeDescription) value);
                     suppliedType = TypeDescription.CLASS;
                 } else if (JavaType.METHOD_HANDLE.getTypeStub().isInstance(value)) {
-                    stackManipulation = JavaConstant.MethodHandle.ofLoaded(value).asStackManipulation();
+                    stackManipulation = new JavaConstantValue(JavaConstant.MethodHandle.ofLoaded(value));
                     suppliedType = JavaType.METHOD_HANDLE.getTypeStub();
                 } else if (value instanceof JavaConstant.MethodHandle) {
                     stackManipulation = new JavaConstantValue((JavaConstant.MethodHandle) value);

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -1602,7 +1602,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> isEquals(
      * @return A matcher that only matches the {@link Object#clone()} method.
      */
     public static <T extends MethodDescription> ElementMatcher.Junction<T> isClone() {
-        return named("clone").and(takesArguments(0)).and(returns(TypeDescription.OBJECT));
+        return named("clone").and(takesArguments(0));
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -1739,7 +1739,7 @@ public static Dynamic bootstrap(MethodDescription.InDefinedShape bootstrapMethod
             }
             return new Dynamic(new org.objectweb.asm.ConstantDynamic(bootstrapMethod.getName(),
                     bootstrapMethod.getReturnType().asErasure().getDescriptor(),
-                    new Handle(bootstrapMethod.isConstructor() ? Opcodes.H_NEWINVOKESPECIAL : Opcodes.INVOKESTATIC,
+                    new Handle(bootstrapMethod.isConstructor() ? Opcodes.H_NEWINVOKESPECIAL : Opcodes.H_INVOKESTATIC,
                             bootstrapMethod.getDeclaringType().getInternalName(),
                             bootstrapMethod.getInternalName(),
                             bootstrapMethod.getDescriptor(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultMethod.java
Patch:
@@ -48,7 +48,7 @@
      *
      * @return {@code true} if this method should be looked up using an {@link java.security.AccessController}.
      */
-    boolean privileged() default true;
+    boolean privileged() default false;
 
     /**
      * Specifies an explicit type that declares the default method to invoke.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Origin.java
Patch:
@@ -73,7 +73,7 @@
      *
      * @return {@code true} if the class should be looked up using an {@link java.security.AccessController}.
      */
-    boolean privileged() default true;
+    boolean privileged() default false;
 
     /**
      * A binder for binding parameters that are annotated with {@link net.bytebuddy.implementation.bind.annotation.Origin}.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperMethod.java
Patch:
@@ -44,7 +44,7 @@
      *
      * @return {@code true} if this method should be looked up using an {@link java.security.AccessController}.
      */
-    boolean privileged() default true;
+    boolean privileged() default false;
 
     /**
      * Indicates that the assigned method should attempt the invocation of an unambiguous default method if no super method is available.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -198,7 +198,7 @@ protected ByteCodeAppender.Size apply(MethodVisitor methodVisitor,
             throw new IllegalStateException("It is not possible to apply an invocation handler onto the static method " + instrumentedMethod);
         }
         MethodConstant.CanCache methodConstant = privileged
-                ? MethodConstant.of(instrumentedMethod.asDefined())
+                ? MethodConstant.ofPrivileged(instrumentedMethod.asDefined())
                 : MethodConstant.of(instrumentedMethod.asDefined());
         StackManipulation.Size stackSize = new StackManipulation.Compound(
                 preparingManipulation,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/PrivilegedMethodConstantAction.java
Patch:
@@ -82,8 +82,8 @@ public enum PrivilegedMethodConstantAction implements AuxiliaryType {
      * @param name        The name of the method.
      * @param firstField  The name of the first field to define.
      * @param firstType   The type of the first field to define.
-     * @param secondField The name of the first field to define.
-     * @param secondType  The type of the first field to define.
+     * @param secondField The name of the second field to define.
+     * @param secondType  The type of the second field to define.
      */
     PrivilegedMethodConstantAction(String name, String firstField, Class<?> firstType, String secondField, Class<?> secondType) {
         try {

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -1519,7 +1519,7 @@ class WithTransformationsOnly extends Listener.Adapter {
             private final Listener delegate;
 
             /**
-             * Creates a new listener that only delegates events if they are succesful or failed transformations.
+             * Creates a new listener that only delegates events if they are successful or failed transformations.
              *
              * @param delegate The delegate listener.
              */
@@ -4334,7 +4334,7 @@ protected boolean isEnabled() {
         protected abstract Collector make();
 
         /**
-         * Applies this redefinition strategy by submitting all loaded types to redefiniton. If this redefinition strategy is disabled,
+         * Applies this redefinition strategy by submitting all loaded types to redefinition. If this redefinition strategy is disabled,
          * this method is non-operational.
          *
          * @param instrumentation               The instrumentation instance to use.
@@ -5781,7 +5781,7 @@ protected ResubmissionListener(ElementMatcher<? super Throwable> matcher, Concur
                     }
 
                     @Override
-                    @SuppressFBWarnings(value = "GC_UNRELATED_TYPES", justification = "Use of unrelated key is inteded for avoiding unnecessary weak reference")
+                    @SuppressFBWarnings(value = "GC_UNRELATED_TYPES", justification = "Use of unrelated key is intended for avoiding unnecessary weak reference")
                     public void onError(String typeName, ClassLoader classLoader, JavaModule module, boolean loaded, Throwable throwable) {
                         if (!loaded && matcher.matches(throwable)) {
                             Set<String> types = this.types.get(new LookupKey(classLoader));

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -2425,7 +2425,7 @@ public Generic resolve(AnnotatedElement annotatedType) {
                     }
 
                     /**
-                     * A delegator for an existing {@code java.lang.reflect.Annotatedelement}.
+                     * A delegator for an existing {@code java.lang.reflect.AnnotatedElement}.
                      */
                     @HashCodeAndEqualsPlugin.Enhance
                     protected static class Resolved extends Delegator {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoader.java
Patch:
@@ -228,7 +228,7 @@ public ByteArrayClassLoader(ClassLoader parent,
      * Resolves a method handle in the scope of the {@link ByteArrayClassLoader} class.
      *
      * @return A method handle for this class.
-     * @throws Exception If the method handle facitily is not supported by the current virtual machine.
+     * @throws Exception If the method handle facility is not supported by the current virtual machine.
      */
     private static Object methodHandle() throws Exception {
         return Class.forName("java.lang.invoke.MethodHandles").getMethod("lookup").invoke(null);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -131,7 +131,7 @@ public static ClassReloadingStrategy of(Instrumentation instrumentation) {
      * </p>
      * or after the start up using the Attach API. A convenience installer for the OpenJDK is provided by the
      * {@code ByteBuddyAgent} within the {@code byte-buddy-agent} module. The strategy is determined by the agent's support
-     * for redefinition where are retransformation is prefered over a redefinition.
+     * for redefinition where are retransformation is preferred over a redefinition.
      *
      * @return A class reloading strategy which uses the Byte Buddy agent's {@link java.lang.instrument.Instrumentation}.
      */

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/EqualsMethod.java
Patch:
@@ -56,7 +56,7 @@ public class EqualsMethod implements Implementation {
     private final TypeCompatibilityCheck typeCompatibilityCheck;
 
     /**
-     * A matcher to filter fields that should not be used for a equality resoltion.
+     * A matcher to filter fields that should not be used for a equality resolution.
      */
     private final ElementMatcher.Junction<? super FieldDescription.InDefinedShape> ignored;
 
@@ -79,7 +79,7 @@ protected EqualsMethod(SuperClassCheck superClassCheck) {
      *
      * @param superClassCheck        The baseline equality to check.
      * @param typeCompatibilityCheck The instance type compatibility check.
-     * @param ignored                A matcher to filter fields that should not be used for a equality resoltion.
+     * @param ignored                A matcher to filter fields that should not be used for a equality resolution.
      * @param nonNullable            A matcher to determine fields of a reference type that cannot be {@code null}.
      */
     private EqualsMethod(SuperClassCheck superClassCheck,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -2741,7 +2741,7 @@ public InvokeDynamic as(Class<?> type) {
         /**
          * A step in the invoke dynamic domain specific language that allows to explicitly specify a field type for a reference value.
          */
-        @SuppressFBWarnings(value = "EQ_DOESNT_OVERRIDE_EQUALS", justification = "Super type implementation convers use case")
+        @SuppressFBWarnings(value = "EQ_DOESNT_OVERRIDE_EQUALS", justification = "Super type implementation covers use case")
         protected static class OfInstance extends WithImplicitType {
 
             /**
@@ -2804,7 +2804,7 @@ protected InvokeDynamic materialize() {
         /**
          * An invoke dynamic implementation where the last argument is an implicitly typed method argument.
          */
-        @SuppressFBWarnings(value = "EQ_DOESNT_OVERRIDE_EQUALS", justification = "Super type implementation convers use case")
+        @SuppressFBWarnings(value = "EQ_DOESNT_OVERRIDE_EQUALS", justification = "Super type implementation covers use case")
         protected static class OfArgument extends WithImplicitType {
 
             /**
@@ -2858,7 +2858,7 @@ protected InvokeDynamic materialize() {
         /**
          * An invoke dynamic implementation where the last argument is an implicitly typed field value.
          */
-        @SuppressFBWarnings(value = "EQ_DOESNT_OVERRIDE_EQUALS", justification = "Super type implementation convers use case")
+        @SuppressFBWarnings(value = "EQ_DOESNT_OVERRIDE_EQUALS", justification = "Super type implementation covers use case")
         protected static class OfField extends WithImplicitType {
 
             /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -1409,11 +1409,11 @@ public List<ArgumentLoader> make(TypeDescription instrumentedType, MethodDescrip
 
             @Override
             public StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
-                StackManipulation assigment = assigner.assign(typeDefinition.asGenericType(), target.getType(), typing);
-                if (!assigment.isValid()) {
+                StackManipulation assignment = assigner.assign(typeDefinition.asGenericType(), target.getType(), typing);
+                if (!assignment.isValid()) {
                     throw new IllegalStateException("Cannot assign " + target + " to " + typeDefinition);
                 }
-                return new StackManipulation.Compound(stackManipulation, assigment);
+                return new StackManipulation.Compound(stackManipulation, assignment);
             }
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/ToStringMethod.java
Patch:
@@ -305,7 +305,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
     }
 
     /**
-     * A prefix resolver is responsible for providing a value that is preprended to a {@link Object#toString()} implementation.
+     * A prefix resolver is responsible for providing a value that is prepended to a {@link Object#toString()} implementation.
      */
     public interface PrefixResolver {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Multiplication.java
Patch:
@@ -5,7 +5,7 @@
 import org.objectweb.asm.Opcodes;
 
 /**
- * A stack manipulation that multiplies to numbers on the operand stack.
+ * A stack manipulation that multiplies two numbers on the operand stack.
  */
 public enum Multiplication implements StackManipulation {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -304,7 +304,7 @@ public static <T> ElementMatcher.Junction<T> none() {
      * None of the values must be {@code null}.
      * </p>
      * <p>
-     * <b>Important</b>: This method cannot be used interchangably with any of its overloaded versions which also apply a type
+     * <b>Important</b>: This method cannot be used interchangeably with any of its overloaded versions which also apply a type
      * conversion.
      * </p>
      *
@@ -322,7 +322,7 @@ public static <T> ElementMatcher.Junction<T> anyOf(Object... value) {
      * None of the values must be {@code null}.
      * </p>
      * <p>
-     * <b>Important</b>: This method cannot be used interchangably with any of the overloaded versions of {@link ElementMatchers#anyOf(Object...)}
+     * <b>Important</b>: This method cannot be used interchangeably with any of the overloaded versions of {@link ElementMatchers#anyOf(Object...)}
      * which also apply a type conversion.
      * </p>
      *
@@ -2102,7 +2102,7 @@ public static <T extends AnnotationDescription> ElementMatcher.Junction<T> annot
     }
 
     /**
-     * Matches exactly the bootstrap {@link java.lang.ClassLoader} . The returned matcher is a synonym to
+     * Matches exactly the bootstrap {@link java.lang.ClassLoader}. The returned matcher is a synonym to
      * a matcher matching {@code null}.
      *
      * @param <T> The type of the matched object.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaModule.java
Patch:
@@ -411,7 +411,7 @@ public boolean canRead(Object source, Object target) {
             public void addReads(Instrumentation instrumentation, Object source, Object target) {
                 try {
                     if (!(Boolean) isModifiableModule.invoke(instrumentation, source)) {
-                        throw new IllegalStateException(source + " is not modifable");
+                        throw new IllegalStateException(source + " is not modifiable");
                     }
                 } catch (IllegalAccessException exception) {
                     throw new IllegalStateException("Cannot access " + redefineModule, exception);

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -1519,7 +1519,7 @@ class WithTransformationsOnly extends Listener.Adapter {
             private final Listener delegate;
 
             /**
-             * Creates a new listener that only delegates events if they are succesful or failed transformations.
+             * Creates a new listener that only delegates events if they are successful or failed transformations.
              *
              * @param delegate The delegate listener.
              */
@@ -4334,7 +4334,7 @@ protected boolean isEnabled() {
         protected abstract Collector make();
 
         /**
-         * Applies this redefinition strategy by submitting all loaded types to redefiniton. If this redefinition strategy is disabled,
+         * Applies this redefinition strategy by submitting all loaded types to redefinition. If this redefinition strategy is disabled,
          * this method is non-operational.
          *
          * @param instrumentation               The instrumentation instance to use.
@@ -5781,7 +5781,7 @@ protected ResubmissionListener(ElementMatcher<? super Throwable> matcher, Concur
                     }
 
                     @Override
-                    @SuppressFBWarnings(value = "GC_UNRELATED_TYPES", justification = "Use of unrelated key is inteded for avoiding unnecessary weak reference")
+                    @SuppressFBWarnings(value = "GC_UNRELATED_TYPES", justification = "Use of unrelated key is intended for avoiding unnecessary weak reference")
                     public void onError(String typeName, ClassLoader classLoader, JavaModule module, boolean loaded, Throwable throwable) {
                         if (!loaded && matcher.matches(throwable)) {
                             Set<String> types = this.types.get(new LookupKey(classLoader));

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -2425,7 +2425,7 @@ public Generic resolve(AnnotatedElement annotatedType) {
                     }
 
                     /**
-                     * A delegator for an existing {@code java.lang.reflect.Annotatedelement}.
+                     * A delegator for an existing {@code java.lang.reflect.AnnotatedElement}.
                      */
                     @HashCodeAndEqualsPlugin.Enhance
                     protected static class Resolved extends Delegator {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoader.java
Patch:
@@ -228,7 +228,7 @@ public ByteArrayClassLoader(ClassLoader parent,
      * Resolves a method handle in the scope of the {@link ByteArrayClassLoader} class.
      *
      * @return A method handle for this class.
-     * @throws Exception If the method handle facitily is not supported by the current virtual machine.
+     * @throws Exception If the method handle facility is not supported by the current virtual machine.
      */
     private static Object methodHandle() throws Exception {
         return Class.forName("java.lang.invoke.MethodHandles").getMethod("lookup").invoke(null);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -131,7 +131,7 @@ public static ClassReloadingStrategy of(Instrumentation instrumentation) {
      * </p>
      * or after the start up using the Attach API. A convenience installer for the OpenJDK is provided by the
      * {@code ByteBuddyAgent} within the {@code byte-buddy-agent} module. The strategy is determined by the agent's support
-     * for redefinition where are retransformation is prefered over a redefinition.
+     * for redefinition where are retransformation is preferred over a redefinition.
      *
      * @return A class reloading strategy which uses the Byte Buddy agent's {@link java.lang.instrument.Instrumentation}.
      */

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/EqualsMethod.java
Patch:
@@ -56,7 +56,7 @@ public class EqualsMethod implements Implementation {
     private final TypeCompatibilityCheck typeCompatibilityCheck;
 
     /**
-     * A matcher to filter fields that should not be used for a equality resoltion.
+     * A matcher to filter fields that should not be used for a equality resolution.
      */
     private final ElementMatcher.Junction<? super FieldDescription.InDefinedShape> ignored;
 
@@ -79,7 +79,7 @@ protected EqualsMethod(SuperClassCheck superClassCheck) {
      *
      * @param superClassCheck        The baseline equality to check.
      * @param typeCompatibilityCheck The instance type compatibility check.
-     * @param ignored                A matcher to filter fields that should not be used for a equality resoltion.
+     * @param ignored                A matcher to filter fields that should not be used for a equality resolution.
      * @param nonNullable            A matcher to determine fields of a reference type that cannot be {@code null}.
      */
     private EqualsMethod(SuperClassCheck superClassCheck,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -2741,7 +2741,7 @@ public InvokeDynamic as(Class<?> type) {
         /**
          * A step in the invoke dynamic domain specific language that allows to explicitly specify a field type for a reference value.
          */
-        @SuppressFBWarnings(value = "EQ_DOESNT_OVERRIDE_EQUALS", justification = "Super type implementation convers use case")
+        @SuppressFBWarnings(value = "EQ_DOESNT_OVERRIDE_EQUALS", justification = "Super type implementation covers use case")
         protected static class OfInstance extends WithImplicitType {
 
             /**
@@ -2804,7 +2804,7 @@ protected InvokeDynamic materialize() {
         /**
          * An invoke dynamic implementation where the last argument is an implicitly typed method argument.
          */
-        @SuppressFBWarnings(value = "EQ_DOESNT_OVERRIDE_EQUALS", justification = "Super type implementation convers use case")
+        @SuppressFBWarnings(value = "EQ_DOESNT_OVERRIDE_EQUALS", justification = "Super type implementation covers use case")
         protected static class OfArgument extends WithImplicitType {
 
             /**
@@ -2858,7 +2858,7 @@ protected InvokeDynamic materialize() {
         /**
          * An invoke dynamic implementation where the last argument is an implicitly typed field value.
          */
-        @SuppressFBWarnings(value = "EQ_DOESNT_OVERRIDE_EQUALS", justification = "Super type implementation convers use case")
+        @SuppressFBWarnings(value = "EQ_DOESNT_OVERRIDE_EQUALS", justification = "Super type implementation covers use case")
         protected static class OfField extends WithImplicitType {
 
             /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -1409,11 +1409,11 @@ public List<ArgumentLoader> make(TypeDescription instrumentedType, MethodDescrip
 
             @Override
             public StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
-                StackManipulation assigment = assigner.assign(typeDefinition.asGenericType(), target.getType(), typing);
-                if (!assigment.isValid()) {
+                StackManipulation assignment = assigner.assign(typeDefinition.asGenericType(), target.getType(), typing);
+                if (!assignment.isValid()) {
                     throw new IllegalStateException("Cannot assign " + target + " to " + typeDefinition);
                 }
-                return new StackManipulation.Compound(stackManipulation, assigment);
+                return new StackManipulation.Compound(stackManipulation, assignment);
             }
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/ToStringMethod.java
Patch:
@@ -305,7 +305,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
     }
 
     /**
-     * A prefix resolver is responsible for providing a value that is preprended to a {@link Object#toString()} implementation.
+     * A prefix resolver is responsible for providing a value that is prepended to a {@link Object#toString()} implementation.
      */
     public interface PrefixResolver {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Multiplication.java
Patch:
@@ -5,7 +5,7 @@
 import org.objectweb.asm.Opcodes;
 
 /**
- * A stack manipulation that multiplies to numbers on the operand stack.
+ * A stack manipulation that multiplies two numbers on the operand stack.
  */
 public enum Multiplication implements StackManipulation {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -304,7 +304,7 @@ public static <T> ElementMatcher.Junction<T> none() {
      * None of the values must be {@code null}.
      * </p>
      * <p>
-     * <b>Important</b>: This method cannot be used interchangably with any of its overloaded versions which also apply a type
+     * <b>Important</b>: This method cannot be used interchangeably with any of its overloaded versions which also apply a type
      * conversion.
      * </p>
      *
@@ -322,7 +322,7 @@ public static <T> ElementMatcher.Junction<T> anyOf(Object... value) {
      * None of the values must be {@code null}.
      * </p>
      * <p>
-     * <b>Important</b>: This method cannot be used interchangably with any of the overloaded versions of {@link ElementMatchers#anyOf(Object...)}
+     * <b>Important</b>: This method cannot be used interchangeably with any of the overloaded versions of {@link ElementMatchers#anyOf(Object...)}
      * which also apply a type conversion.
      * </p>
      *
@@ -2102,7 +2102,7 @@ public static <T extends AnnotationDescription> ElementMatcher.Junction<T> annot
     }
 
     /**
-     * Matches exactly the bootstrap {@link java.lang.ClassLoader} . The returned matcher is a synonym to
+     * Matches exactly the bootstrap {@link java.lang.ClassLoader}. The returned matcher is a synonym to
      * a matcher matching {@code null}.
      *
      * @param <T> The type of the matched object.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaModule.java
Patch:
@@ -411,7 +411,7 @@ public boolean canRead(Object source, Object target) {
             public void addReads(Instrumentation instrumentation, Object source, Object target) {
                 try {
                     if (!(Boolean) isModifiableModule.invoke(instrumentation, source)) {
-                        throw new IllegalStateException(source + " is not modifable");
+                        throw new IllegalStateException(source + " is not modifiable");
                     }
                 } catch (IllegalAccessException exception) {
                     throw new IllegalStateException("Cannot access " + redefineModule, exception);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodInvocation.java
Patch:
@@ -71,7 +71,7 @@ public enum MethodInvocation {
     private final int legacyOpcode;
 
     /**
-     * The handle being used for a dynamic method invocation before Java 11
+     * The handle being used for a dynamic method invocation before Java 11.
      */
     private final int legacyHandle;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/MemberSubstitution.java
Patch:
@@ -1340,7 +1340,8 @@ public void visitMethodInsn(int opcode, String owner, String internalName, Strin
                 } else { // Invokevirtual and invokeinterface can represent a private, non-static method from Java 11.
                     TypeDescription typeDescription = resolution.resolve();
                     candidates = typeDescription.getDeclaredMethods()
-                            .filter(named(internalName).and(hasDescriptor(descriptor)).and(isPrivate()).and(not(isStatic())));
+                            .filter(isPrivate().and(not(isStatic())))
+                            .filter(named(internalName).and(hasDescriptor(descriptor)));
                     if (candidates.isEmpty()) {
                         candidates = methodGraphCompiler.compile(resolution.resolve())
                                 .listNodes()

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -13,6 +13,7 @@
 import net.bytebuddy.test.scope.EnclosingType;
 import net.bytebuddy.test.utility.ClassFileExtraction;
 import net.bytebuddy.test.visibility.Sample;
+import net.bytebuddy.utility.OpenedClassReader;
 import org.hamcrest.CoreMatchers;
 import org.hamcrest.Matcher;
 import org.junit.Test;
@@ -710,7 +711,7 @@ private static class SignatureMalformer extends ClassVisitor {
         private static final String FOO = "foo";
 
         public SignatureMalformer(ClassVisitor classVisitor) {
-            super(Opcodes.ASM6, classVisitor);
+            super(OpenedClassReader.ASM_API, classVisitor);
         }
 
         public static Class<?> malform(Class<?> type) throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionGenericTest.java
Patch:
@@ -1971,7 +1971,9 @@ public static class GenericDisintegrator extends ClassVisitor {
 
         public static Field make() throws IOException, ClassNotFoundException, NoSuchFieldException {
             ClassReader classReader = new ClassReader(InconsistentGenerics.class.getName());
-            ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);
+            ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
+            // TODO: Requires fix in ASM - https://gitlab.ow2.org/asm/asm/issues/317833
+//            ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);
             classReader.accept(new GenericDisintegrator(classWriter), 0);
             return new ByteArrayClassLoader(ClassLoadingStrategy.BOOTSTRAP_LOADER,
                     Collections.singletonMap(InconsistentGenerics.class.getName(), classWriter.toByteArray()),

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionGenericTest.java
Patch:
@@ -1971,7 +1971,9 @@ public static class GenericDisintegrator extends ClassVisitor {
 
         public static Field make() throws IOException, ClassNotFoundException, NoSuchFieldException {
             ClassReader classReader = new ClassReader(InconsistentGenerics.class.getName());
-            ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);
+            ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
+            // TODO: Requires fix in ASM - https://gitlab.ow2.org/asm/asm/issues/317833
+//            ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);
             classReader.accept(new GenericDisintegrator(classWriter), 0);
             return new ByteArrayClassLoader(ClassLoadingStrategy.BOOTSTRAP_LOADER,
                     Collections.singletonMap(InconsistentGenerics.class.getName(), classWriter.toByteArray()),

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceArgumentHandlerCopyingTest.java
Patch:
@@ -1,11 +1,8 @@
 package net.bytebuddy.asm;
 
 import net.bytebuddy.ByteBuddy;
-import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
-import net.bytebuddy.test.utility.DebuggingWrapper;
 import org.junit.Test;
-import org.objectweb.asm.ClassReader;
 
 import static net.bytebuddy.matcher.ElementMatchers.isConstructor;
 import static net.bytebuddy.matcher.ElementMatchers.named;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/PackageDescription.java
Patch:
@@ -21,8 +21,7 @@ public interface PackageDescription extends NamedElement.WithRuntimeName, Annota
     int PACKAGE_MODIFIERS = Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT | Opcodes.ACC_SYNTHETIC;
 
     /**
-     * Represents any undefined property of a type description that is instead represented as {@code null} in order
-     * to resemble the Java reflection API which returns {@code null} and is intuitive to many Java developers.
+     * A named constant for an undefined package what applies for primitive and array types.
      */
     PackageDescription UNDEFINED = null;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -709,9 +709,9 @@ public boolean isMemberClass() {
         @Override
         public PackageDescription getPackage() {
             int packageIndex = name.lastIndexOf('.');
-            return packageIndex == -1
-                    ? PackageDescription.UNDEFINED
-                    : new PackageDescription.Simple(name.substring(0, packageIndex));
+            return new PackageDescription.Simple(packageIndex == -1
+                    ? EMPTY_NAME
+                    : name.substring(0, packageIndex));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -3700,7 +3700,7 @@ public int prepare(MethodVisitor methodVisitor) {
 
                 @Override
                 public ForAdvice bindEnter(MethodDescription adviceMethod) {
-                    return new ForAdvice.ForMethodEnter(instrumentedMethod, adviceMethod, enterType);
+                    return new ForAdvice.ForMethodEnter(instrumentedMethod, adviceMethod, exitType);
                 }
 
                 @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceSuppressionTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
-import net.bytebuddy.test.utility.DebuggingWrapper;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -75,7 +74,6 @@ public AdviceSuppressionTest(Class<?> type) {
     public void testIllegalAssignment() throws Exception {
         Class<?> dynamicType = new ByteBuddy()
                 .redefine(type)
-                .visit(DebuggingWrapper.makeDefault(false))
                 .visit(Advice.to(type).on(named(FOO)))
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -9,7 +9,6 @@
 import net.bytebuddy.implementation.bytecode.assign.Assigner;
 import net.bytebuddy.implementation.bytecode.constant.ClassConstant;
 import net.bytebuddy.pool.TypePool;
-import net.bytebuddy.test.utility.DebuggingWrapper;
 import org.junit.Test;
 import org.mockito.Mockito;
 import org.objectweb.asm.ClassReader;
@@ -213,7 +212,6 @@ public void testTrivialDelegation() throws Exception {
     public void testTrivialAdvice() throws Exception {
         Class<?> type = new ByteBuddy()
                 .redefine(Sample.class)
-                .visit(DebuggingWrapper.makeDefault(false))
                 .visit(Advice.to(TrivialAdvice.class).on(named(FOO)))
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceRepeatOnDefaultValueTest.java
Patch:
@@ -147,7 +147,7 @@ public void testAdvice() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(type.getDeclaredMethod(FOO).invoke(type.getDeclaredConstructor().newInstance()), is(3));
+        assertThat(type.getDeclaredMethod(FOO).invoke(type.getDeclaredConstructor().newInstance()), is((Object) 3));
     }
 
     @SuppressWarnings("unused")

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceRepeatOnNonDefaultValueTest.java
Patch:
@@ -146,7 +146,7 @@ public void testAdvice() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(type.getDeclaredMethod(FOO).invoke(type.getDeclaredConstructor().newInstance()), is(3));
+        assertThat(type.getDeclaredMethod(FOO).invoke(type.getDeclaredConstructor().newInstance()), is((Object) 3));
     }
 
     @SuppressWarnings("unused")

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -8293,7 +8293,6 @@ protected AdviceVisitor(MethodVisitor methodVisitor,
 
         @Override
         protected void onAfterExceptionTable() {
-            // TODO: Stack map frames at beginning of method?
             methodEnter.prepare();
             onUserPrepare();
             methodExit.prepare();

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -4569,7 +4569,7 @@ protected static Object toFrame(TypeDescription typeDescription) {
 
             @Override
             public StackMapFrameHandler.ForAdvice bindEnter(MethodDescription.InDefinedShape adviceMethod) {
-                return new ForAdvice(adviceMethod, initialTypes, CompoundList.of(initialTypes, enterTypes), TranslationMode.ENTER);
+                return new ForAdvice(adviceMethod, initialTypes, enterTypes, TranslationMode.ENTER);
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -402,7 +402,7 @@ protected static Advice to(TypeDescription enterAdvice,
             methodExit = locate(OnMethodExit.class, INLINE_EXIT, methodExit, methodDescription);
         }
         if (!methodExit.isAlive()) {
-            throw new IllegalArgumentException("No enter advice defined by " + exitAdvice);
+            throw new IllegalArgumentException("No exit advice defined by " + exitAdvice);
         }
         try {
             return new Advice(methodEnter.asMethodEnter(userFactories, methodEnter.isBinary()

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -210,7 +210,7 @@ public ForLoadedField(Field field) {
         @Override
         public TypeDescription.Generic getType() {
             if (TypeDescription.AbstractBase.RAW_TYPES) {
-                return new TypeDescription.Generic.OfNonGenericType.ForLoadedType(field.getType());
+                return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(field.getType());
             }
             return new TypeDescription.Generic.LazyProjection.ForLoadedFieldType(field);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -958,7 +958,7 @@ public TypeDescription getDeclaringType() {
         @Override
         public TypeDescription.Generic getReturnType() {
             if (TypeDescription.AbstractBase.RAW_TYPES) {
-                return new TypeDescription.Generic.OfNonGenericType.ForLoadedType(method.getReturnType());
+                return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(method.getReturnType());
             }
             return new TypeDescription.Generic.LazyProjection.ForLoadedReturnType(method);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -608,7 +608,7 @@ private ForValue(Assigner assigner, Assigner.Typing typing, String fieldName, Ob
             super(assigner, typing);
             this.fieldName = fieldName;
             this.value = value;
-            fieldType = new TypeDescription.Generic.OfNonGenericType.ForLoadedType(value.getClass());
+            fieldType = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(value.getClass());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -37,7 +37,7 @@ public abstract class InvocationHandlerAdapter implements Implementation {
     /**
      * A type description of the {@link InvocationHandler}.
      */
-    private static final TypeDescription.Generic INVOCATION_HANDLER_TYPE = new TypeDescription.Generic.OfNonGenericType.ForLoadedType(InvocationHandler.class);
+    private static final TypeDescription.Generic INVOCATION_HANDLER_TYPE = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(InvocationHandler.class);
 
     /**
      * Indicates that a value should not be cached.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -1208,7 +1208,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
                     return instrumentedType
                             .withField(new FieldDescription.Token(name,
                                     Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
-                                    new TypeDescription.Generic.OfNonGenericType.ForLoadedType(value.getClass())))
+                                    TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(value.getClass())))
                             .withInitializer(new LoadedTypeInitializer.ForStaticField(name, value));
                 }
 
@@ -1895,7 +1895,7 @@ public MethodCall on(Object target) {
          */
         public <T> MethodCall on(T target, Class<? super T> type) {
             return new MethodCall(methodLocator,
-                    new TargetHandler.ForValue(target, new TypeDescription.Generic.OfNonGenericType.ForLoadedType(type)),
+                    new TargetHandler.ForValue(target, TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(type)),
                     argumentLoaders,
                     new MethodInvoker.ForVirtualInvocation(type),
                     terminationHandler,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -179,7 +179,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
                     Collections.<TypeVariableToken>emptyList(),
                     TypeDescription.Generic.OBJECT,
                     Collections.<ParameterDescription.Token>emptyList(),
-                    Collections.singletonList(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Exception.class)),
+                    Collections.singletonList(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Exception.class)),
                     Collections.<AnnotationDescription>emptyList(),
                     AnnotationValue.UNDEFINED,
                     TypeDescription.Generic.UNDEFINED);

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaType.java
Patch:
@@ -75,7 +75,7 @@ public enum JavaType {
         } catch (Exception ignored) {
             typeDescription = new TypeDescription.Latent(typeName,
                     modifiers,
-                    new TypeDescription.Generic.OfNonGenericType.ForLoadedType(superClass),
+                    TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(superClass),
                     new TypeList.Generic.ForLoadedTypes(interfaces));
         }
         this.typeDescription = typeDescription;

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AbstractAnnotationDescriptionTest.java
Patch:
@@ -453,7 +453,7 @@ private void assertValue(Annotation annotation, String methodName, Object unload
                 methodName,
                 Opcodes.ACC_PUBLIC,
                 Collections.<TypeVariableToken>emptyList(),
-                new TypeDescription.Generic.OfNonGenericType.ForLoadedType(annotation.annotationType().getDeclaredMethod(methodName).getReturnType()),
+                TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(annotation.annotationType().getDeclaredMethod(methodName).getReturnType()),
                 Collections.<ParameterDescription.Token>emptyList(),
                 Collections.<TypeDescription.Generic>emptyList(),
                 Collections.<AnnotationDescription>emptyList(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorSubstitutorForAttachmentTest.java
Patch:
@@ -22,7 +22,7 @@ public void testAttachment() throws Exception {
         TypeDescription target = TypeDescription.ForLoadedType.of(Bar.class);
         TypeDescription.Generic attached = detached.accept(new TypeDescription.Generic.Visitor.Substitutor.ForAttachment(target.asGenericType(), target));
         assertThat(attached.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
-        assertThat(attached.asErasure(), sameInstance(target));
+        assertThat(attached.asErasure(), is(target));
         assertThat(attached.getTypeArguments().size(), is(4));
         assertThat(attached.getTypeArguments().get(0).getSort(), is(TypeDefinition.Sort.VARIABLE));
         assertThat(attached.getTypeArguments().get(0).getSymbol(), is("T"));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -435,7 +435,7 @@ public void testTypeVariableTransformation() throws Exception {
                 .transform(named(BAR), new Transformer<TypeVariableToken>() {
                     @Override
                     public TypeVariableToken transform(TypeDescription instrumentedType, TypeVariableToken target) {
-                        return new TypeVariableToken(target.getSymbol(), Collections.singletonList(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Integer.class)));
+                        return new TypeVariableToken(target.getSymbol(), Collections.singletonList(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Integer.class)));
                     }
                 })
                 .make()
@@ -1182,7 +1182,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
                     TypeDescription.Generic.OBJECT,
                     Collections.singletonList(new ParameterDescription.Token(TypeDescription.Generic.OBJECT,
                             Collections.singletonList(AnnotationDescription.Builder.ofType(SampleAnnotation.class).define(FOO, QUX).build()))),
-                    Collections.singletonList(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Exception.class)),
+                    Collections.singletonList(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Exception.class)),
                     Collections.singletonList(AnnotationDescription.Builder.ofType(SampleAnnotation.class).define(FOO, BAR).build()),
                     AnnotationValue.UNDEFINED,
                     TypeDescription.Generic.UNDEFINED));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeDefaultTest.java
Patch:
@@ -427,8 +427,8 @@ public void testRepresents() {
     @Test
     public void testSuperClass() {
         assertThat(makePlainInstrumentedType().getSuperClass(), is(TypeDescription.Generic.OBJECT));
-        assertThat(makePlainInstrumentedType().getSuperClass(), not((TypeDescription.Generic) new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Integer.class)));
-        assertThat(makePlainInstrumentedType().getSuperClass(), not((TypeDescription.Generic) new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Serializable.class)));
+        assertThat(makePlainInstrumentedType().getSuperClass(), not((TypeDescription.Generic) TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Integer.class)));
+        assertThat(makePlainInstrumentedType().getSuperClass(), not((TypeDescription.Generic) TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Serializable.class)));
     }
 
     @Test
@@ -1254,7 +1254,7 @@ public void testInconsistentReceiverConstructorInnerClass() throws Exception {
     public void testTypeVariableOutOfScopeIsErased() throws Exception {
         TypeDescription typeDescription = new InstrumentedType.Default("foo",
                 Opcodes.ACC_PUBLIC,
-                new TypeDescription.Generic.OfNonGenericType.ForLoadedType(AbstractOuter.ExtendedInner.class),
+                TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(AbstractOuter.ExtendedInner.class),
                 Collections.<TypeVariableToken>emptyList(),
                 Collections.<TypeDescription.Generic>emptyList(),
                 Collections.<FieldDescription.Token>emptyList(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultTest.java
Patch:
@@ -1041,9 +1041,9 @@ public void testDiamondInheritanceInterface() throws Exception {
     public void testVisibilityExtension() throws Exception {
         TypeDescription typeDescription = new InstrumentedType.Default("foo",
                 Opcodes.ACC_PUBLIC,
-                new TypeDescription.Generic.OfNonGenericType.ForLoadedType(VisibilityExtension.Base.class),
+                TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(VisibilityExtension.Base.class),
                 Collections.<TypeVariableToken>emptyList(),
-                Collections.<TypeDescription.Generic>singletonList(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(VisibilityExtension.class)),
+                Collections.<TypeDescription.Generic>singletonList(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(VisibilityExtension.class)),
                 Collections.<FieldDescription.Token>emptyList(),
                 Collections.<MethodDescription.Token>emptyList(),
                 Collections.<AnnotationDescription>emptyList(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterMethodPoolRecordTest.java
Patch:
@@ -226,7 +226,7 @@ public void testDefinedMethodPrepended() throws Exception {
 
     @Test
     public void testDefaultValueMethod() throws Exception {
-        when(methodDescription.getReturnType()).thenReturn(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(String.class));
+        when(methodDescription.getReturnType()).thenReturn(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(String.class));
         when(methodDescription.isDefaultValue(AnnotationValue.ForConstant.of(FOO))).thenReturn(true);
         TypeWriter.MethodPool.Record record = new TypeWriter.MethodPool.Record.ForDefinedMethod.WithAnnotationDefaultValue(methodDescription,
                 AnnotationValue.ForConstant.of(FOO),
@@ -248,7 +248,7 @@ public void testDefaultValueMethod() throws Exception {
 
     @Test
     public void testDefaultValueMethodHeadOnly() throws Exception {
-        when(methodDescription.getReturnType()).thenReturn(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(String.class));
+        when(methodDescription.getReturnType()).thenReturn(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(String.class));
         when(parameterDescription.hasModifiers()).thenReturn(true);
         when(parameterDescription.isNamed()).thenReturn(true);
         when(methodDescription.isDefaultValue(AnnotationValue.ForConstant.of(FOO))).thenReturn(true);
@@ -283,7 +283,7 @@ public void testDefaultValueMethodBodyOnly() throws Exception {
     public void testDefaultValueMethodWithParameters() throws Exception {
         when(parameterDescription.hasModifiers()).thenReturn(true);
         when(parameterDescription.isNamed()).thenReturn(true);
-        when(methodDescription.getReturnType()).thenReturn(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(String.class));
+        when(methodDescription.getReturnType()).thenReturn(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(String.class));
         when(methodDescription.isDefaultValue(AnnotationValue.ForConstant.of(FOO))).thenReturn(true);
         TypeWriter.MethodPool.Record record = new TypeWriter.MethodPool.Record.ForDefinedMethod.WithAnnotationDefaultValue(methodDescription,
                 AnnotationValue.ForConstant.of(FOO),

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/EmptyBinderTest.java
Patch:
@@ -33,7 +33,7 @@ public class EmptyBinderTest extends AbstractAnnotationBinderTest<Empty> {
 
     public EmptyBinderTest(Class<?> type, int opcode) {
         super(Empty.class);
-        typeDescription = new TypeDescription.Generic.OfNonGenericType.ForLoadedType(type);
+        typeDescription = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(type);
         this.opcode = opcode;
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldValueBinderTest.java
Patch:
@@ -300,7 +300,7 @@ public void testGetterNameDiscoveryBoolean() throws Exception {
         when(stackManipulation.isValid()).thenReturn(true);
         when(source.getInternalName()).thenReturn("isFoo");
         when(source.getActualName()).thenReturn("isFoo");
-        when(source.getReturnType()).thenReturn(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(boolean.class));
+        when(source.getReturnType()).thenReturn(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(boolean.class));
         when(source.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
         MethodDelegationBinder.ParameterBinding<?> binding = FieldValue.Binder.INSTANCE.bind(annotationDescription,
                 source,

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveTypeAwareAssignerBoxingTest.java
Patch:
@@ -88,7 +88,7 @@ public void testBoxingAssignment() {
         verifyNoMoreInteractions(sourceTypeDescription);
         verify(targetTypeDescription, atLeast(1)).isPrimitive();
         verifyNoMoreInteractions(targetTypeDescription);
-        verify(chainedAssigner).assign(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(targetType), targetTypeDescription, Assigner.Typing.STATIC);
+        verify(chainedAssigner).assign(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(targetType), targetTypeDescription, Assigner.Typing.STATIC);
         verifyNoMoreInteractions(chainedAssigner);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveTypeAwareAssignerImplicitUnboxingTest.java
Patch:
@@ -94,7 +94,7 @@ public void testImplicitUnboxingAssignment() {
         verify(target, atLeast(0)).represents(any(Class.class));
         verify(target, atLeast(1)).isPrimitive();
         verifyNoMoreInteractions(target);
-        verify(chainedAssigner).assign(source, new TypeDescription.Generic.OfNonGenericType.ForLoadedType(wrapperType), Assigner.Typing.DYNAMIC);
+        verify(chainedAssigner).assign(source, TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(wrapperType), Assigner.Typing.DYNAMIC);
         verifyNoMoreInteractions(chainedAssigner);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveUnboxingDelegateDirectTest.java
Patch:
@@ -139,7 +139,7 @@ public void testImplicitBoxing() throws Exception {
                 unboxingMethodDescriptor,
                 false);
         verifyNoMoreInteractions(methodVisitor);
-        verify(chainedAssigner).assign(referenceTypeDescription, new TypeDescription.Generic.OfNonGenericType.ForLoadedType(wrapperType), Assigner.Typing.DYNAMIC);
+        verify(chainedAssigner).assign(referenceTypeDescription, TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(wrapperType), Assigner.Typing.DYNAMIC);
         verifyNoMoreInteractions(chainedAssigner);
         verify(stackManipulation, atLeast(1)).isValid();
         verify(stackManipulation).apply(methodVisitor, implementationContext);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveUnboxingDelegateOtherTest.java
Patch:
@@ -7,7 +7,7 @@ public class PrimitiveUnboxingDelegateOtherTest {
 
     @Test(expected = IllegalArgumentException.class)
     public void testIllegalSourceTypeThrowsException() throws Exception {
-        PrimitiveUnboxingDelegate.forReferenceType(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(int.class));
+        PrimitiveUnboxingDelegate.forReferenceType(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(int.class));
     }
 
     @Test(expected = IllegalArgumentException.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/reference/ReferenceTypeAwareAssignerTest.java
Patch:
@@ -93,7 +93,7 @@ public void testTargetToSourceAssignableRuntimeType() throws Exception {
 
     @Test
     public void testPrimitiveAssignabilityWhenEqual() throws Exception {
-        TypeDescription.Generic primitiveType = new TypeDescription.Generic.OfNonGenericType.ForLoadedType(int.class); // Note: cannot mock equals
+        TypeDescription.Generic primitiveType = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(int.class); // Note: cannot mock equals
         StackManipulation stackManipulation = ReferenceTypeAwareAssigner.INSTANCE.assign(primitiveType, primitiveType, Assigner.Typing.DYNAMIC);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);
@@ -104,8 +104,8 @@ public void testPrimitiveAssignabilityWhenEqual() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testPrimitiveAssignabilityWhenNotEqual() throws Exception {
-        TypeDescription.Generic primitiveType = new TypeDescription.Generic.OfNonGenericType.ForLoadedType(int.class); // Note: cannot mock equals
-        TypeDescription.Generic otherPrimitiveType = new TypeDescription.Generic.OfNonGenericType.ForLoadedType(long.class); // Note: cannot mock equals
+        TypeDescription.Generic primitiveType = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(int.class); // Note: cannot mock equals
+        TypeDescription.Generic otherPrimitiveType = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(long.class); // Note: cannot mock equals
         StackManipulation stackManipulation = ReferenceTypeAwareAssigner.INSTANCE.assign(primitiveType, otherPrimitiveType, Assigner.Typing.DYNAMIC);
         assertThat(stackManipulation.isValid(), is(false));
         stackManipulation.apply(methodVisitor, implementationContext);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccessOtherTest.java
Patch:
@@ -44,23 +44,23 @@ public void testThisReference() throws Exception {
     @Test
     public void testLoadParameter() throws Exception {
         ParameterDescription parameterDescription = mock(ParameterDescription.class);
-        when(parameterDescription.getType()).thenReturn(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(int.class));
+        when(parameterDescription.getType()).thenReturn(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(int.class));
         when(parameterDescription.getOffset()).thenReturn(4);
         assertThat(MethodVariableAccess.load(parameterDescription), hasPrototype(MethodVariableAccess.INTEGER.loadFrom(4)));
     }
 
     @Test
     public void testStoreParameter() throws Exception {
         ParameterDescription parameterDescription = mock(ParameterDescription.class);
-        when(parameterDescription.getType()).thenReturn(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(int.class));
+        when(parameterDescription.getType()).thenReturn(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(int.class));
         when(parameterDescription.getOffset()).thenReturn(4);
         assertThat(MethodVariableAccess.store(parameterDescription), hasPrototype(MethodVariableAccess.INTEGER.storeAt(4)));
     }
 
     @Test
     public void testIncrementParameter() throws Exception {
         ParameterDescription parameterDescription = mock(ParameterDescription.class);
-        when(parameterDescription.getType()).thenReturn(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(int.class));
+        when(parameterDescription.getType()).thenReturn(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(int.class));
         when(parameterDescription.getOffset()).thenReturn(4);
         assertThat(MethodVariableAccess.increment(parameterDescription, 42), hasPrototype(MethodVariableAccess.INTEGER.increment(4, 42)));
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -429,7 +429,7 @@ protected ForModule(JavaModule module) {
          *
          * @return A class file locator that locates classes of the boot layer.
          */
-        @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception is supposed to be rethrown")
+        @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should always be wrapped for clarity")
         public static ClassFileLocator ofBootLayer() {
             try {
                 Map<String, ClassFileLocator> bootModules = new HashMap<String, ClassFileLocator>();

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionOneToOneMatcher.java
Patch:
@@ -58,6 +58,6 @@ public String toString() {
             }
             stringBuilder.append(value);
         }
-        return stringBuilder.append(")").toString();
+        return stringBuilder.append(')').toString();
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -21,6 +21,7 @@
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.dynamic.loading.ClassReloadingStrategy;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
+import net.bytebuddy.dynamic.scaffold.TypeValidation;
 import net.bytebuddy.dynamic.scaffold.inline.MethodNameTransformer;
 import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
 import net.bytebuddy.implementation.ExceptionMethod;
@@ -9697,6 +9698,7 @@ enum CreationAction implements PrivilegedAction<Factory> {
                     public Factory run() {
                         try {
                             return new Factory.ForJava9CapableVm(new ByteBuddy()
+                                    .with(TypeValidation.DISABLED)
                                     .subclass(ExecutingTransformer.class)
                                     .name(ExecutingTransformer.class.getName() + "$ByteBuddy$ModuleSupport")
                                     .method(named("transform").and(takesArgument(0, JavaType.MODULE.load())))

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -6,6 +6,7 @@
 import net.bytebuddy.description.modifier.Visibility;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.DynamicType;
+import net.bytebuddy.dynamic.scaffold.TypeValidation;
 import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
 import net.bytebuddy.implementation.FixedValue;
 import net.bytebuddy.implementation.MethodCall;
@@ -719,6 +720,7 @@ public static Initializable make() throws Exception {
                         getPackage = ClassLoader.class.getDeclaredMethod("getPackage", String.class);
                     }
                     DynamicType.Builder<?> builder = new ByteBuddy()
+                            .with(TypeValidation.DISABLED)
                             .subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS)
                             .name(ClassLoader.class.getName() + "$ByteBuddyAccessor$" + RandomString.make())
                             .defineMethod("findLoadedClass", Class.class, Visibility.PUBLIC)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -17,6 +17,7 @@
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
+import net.bytebuddy.dynamic.scaffold.TypeValidation;
 import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.MethodAccessorFactory;
@@ -136,6 +137,7 @@ public DynamicType make(String auxiliaryTypeName,
         MethodDescription accessorMethod = methodAccessorFactory.registerAccessorFor(specialMethodInvocation, MethodAccessorFactory.AccessType.DEFAULT);
         LinkedHashMap<String, TypeDescription> parameterFields = extractFields(accessorMethod);
         DynamicType.Builder<?> builder = new ByteBuddy(classFileVersion)
+                .with(TypeValidation.DISABLED)
                 .with(PrecomputedMethodGraph.INSTANCE)
                 .subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS)
                 .name(auxiliaryTypeName)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TrivialType.java
Patch:
@@ -5,6 +5,7 @@
 import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
+import net.bytebuddy.dynamic.scaffold.TypeValidation;
 import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
 import net.bytebuddy.implementation.MethodAccessorFactory;
 
@@ -45,6 +46,7 @@ public DynamicType make(String auxiliaryTypeName,
                             ClassFileVersion classFileVersion,
                             MethodAccessorFactory methodAccessorFactory) {
         return new ByteBuddy(classFileVersion)
+                .with(TypeValidation.DISABLED)
                 .with(MethodGraph.Empty.INSTANCE) // avoid parsing the graph
                 .subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS)
                 .annotateType(eager

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TypeProxy.java
Patch:
@@ -11,6 +11,7 @@
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.TargetType;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
+import net.bytebuddy.dynamic.scaffold.TypeValidation;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.MethodAccessorFactory;
 import net.bytebuddy.implementation.bytecode.*;
@@ -98,6 +99,7 @@ public DynamicType make(String auxiliaryTypeName,
                             ClassFileVersion classFileVersion,
                             MethodAccessorFactory methodAccessorFactory) {
         return new ByteBuddy(classFileVersion)
+                .with(TypeValidation.DISABLED)
                 .ignore(ignoreFinalizer ? isFinalizer() : ElementMatchers.<MethodDescription>none())
                 .subclass(proxiedType)
                 .name(auxiliaryTypeName)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -11,6 +11,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
+import net.bytebuddy.dynamic.scaffold.TypeValidation;
 import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
 import net.bytebuddy.implementation.ExceptionMethod;
 import net.bytebuddy.implementation.Implementation;
@@ -932,6 +933,7 @@ public DynamicType make(String auxiliaryTypeName,
                                     ClassFileVersion classFileVersion,
                                     MethodAccessorFactory methodAccessorFactory) {
                 return fieldResolver.apply(new ByteBuddy(classFileVersion)
+                        .with(TypeValidation.DISABLED)
                         .subclass(fieldResolver.getProxyType(), ConstructorStrategy.Default.NO_CONSTRUCTORS)
                         .name(auxiliaryTypeName)
                         .modifiers(DEFAULT_TYPE_MODIFIER)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -11,6 +11,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
+import net.bytebuddy.dynamic.scaffold.TypeValidation;
 import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.MethodAccessorFactory;
@@ -339,6 +340,7 @@ public DynamicType make(String auxiliaryTypeName,
                                     ClassFileVersion classFileVersion,
                                     MethodAccessorFactory methodAccessorFactory) {
                 return new ByteBuddy(classFileVersion)
+                        .with(TypeValidation.DISABLED)
                         .subclass(morphingType, ConstructorStrategy.Default.NO_CONSTRUCTORS)
                         .name(auxiliaryTypeName)
                         .modifiers(DEFAULT_TYPE_MODIFIER)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -15,6 +15,7 @@
 import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
+import net.bytebuddy.dynamic.scaffold.TypeValidation;
 import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.MethodAccessorFactory;
@@ -258,6 +259,7 @@ public DynamicType make(String auxiliaryTypeName,
                                     MethodAccessorFactory methodAccessorFactory) {
                 LinkedHashMap<String, TypeDescription> parameterFields = extractFields(sourceMethod);
                 DynamicType.Builder<?> builder = new ByteBuddy(classFileVersion)
+                        .with(TypeValidation.DISABLED)
                         .subclass(forwardingType, ConstructorStrategy.Default.NO_CONSTRUCTORS)
                         .name(auxiliaryTypeName)
                         .modifiers(DEFAULT_TYPE_MODIFIER)

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionGenericTest.java
Patch:
@@ -777,6 +777,7 @@ public void testShadowedTypeVariableType() throws Exception {
     @Test
     public void testNestedTypeVariableType() throws Exception {
         TypeDescription.Generic typeDescription = describeType(NestedTypeVariableType.class.getDeclaredField(FOO));
+        // Some JVM versions do not prefix the outer type correctly.
         assertThat(typeDescription.getTypeName(), is(NestedTypeVariableType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
         assertThat(typeDescription.getStackSize(), is(StackSize.SINGLE));
@@ -792,6 +793,7 @@ public void testNestedTypeVariableType() throws Exception {
     @Test
     public void testNestedSpecifiedTypeVariableType() throws Exception {
         TypeDescription.Generic typeDescription = describeType(NestedSpecifiedTypeVariableType.class.getDeclaredField(FOO));
+        // Some JVM versions do not prefix the outer type correctly.
         assertThat(typeDescription.getTypeName(), is(NestedSpecifiedTypeVariableType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
         assertThat(typeDescription.getStackSize(), is(StackSize.SINGLE));
@@ -807,6 +809,7 @@ public void testNestedSpecifiedTypeVariableType() throws Exception {
     @Test
     public void testNestedStaticTypeVariableType() throws Exception {
         TypeDescription.Generic typeDescription = describeType(NestedStaticTypeVariableType.class.getDeclaredField(FOO));
+        // Some JVM versions do not prefix the outer type correctly.
         assertThat(typeDescription.getTypeName(), is(NestedStaticTypeVariableType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
         assertThat(typeDescription.getStackSize(), is(StackSize.SINGLE));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/NexusAccessor.java
Patch:
@@ -127,7 +127,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                         new TextConstant(Nexus.class.getName()),
                         MethodInvocation.invoke(new MethodDescription.ForLoadedMethod(ClassLoader.class.getMethod("loadClass", String.class))),
                         new TextConstant("initialize"),
-                        ArrayFactory.forType(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Class.class))
+                        ArrayFactory.forType(TypeDescription.Generic.CLASS)
                                 .withValues(Arrays.asList(
                                         ClassConstant.of(TypeDescription.CLASS),
                                         ClassConstant.of(TypeDescription.ForLoadedType.of(int.class)))),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -820,7 +820,7 @@ public ForInstrumentedType(TypeDescription instrumentedType) {
             public StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
                 StackManipulation stackManipulation = new StackManipulation.Compound(
                         ClassConstant.of(instrumentedType),
-                        assigner.assign(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Class.class), target.getType(), typing));
+                        assigner.assign(TypeDescription.Generic.OfNonGenericType.ForLoadedType.CLASS, target.getType(), typing));
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot assign Class value to " + target);
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodConstant.java
Patch:
@@ -76,7 +76,7 @@ public boolean isValid() {
     public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
         return new Compound(
                 preparation(),
-                ArrayFactory.forType(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Class.class))
+                ArrayFactory.forType(TypeDescription.Generic.OfNonGenericType.CLASS)
                         .withValues(typeConstantsFor(methodDescription.getParameters().asTypeList().asErasures())),
                 MethodInvocation.invoke(accessorMethod())
         ).apply(methodVisitor, implementationContext);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/NexusAccessor.java
Patch:
@@ -127,7 +127,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                         new TextConstant(Nexus.class.getName()),
                         MethodInvocation.invoke(new MethodDescription.ForLoadedMethod(ClassLoader.class.getMethod("loadClass", String.class))),
                         new TextConstant("initialize"),
-                        ArrayFactory.forType(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Class.class))
+                        ArrayFactory.forType(TypeDescription.Generic.CLASS)
                                 .withValues(Arrays.asList(
                                         ClassConstant.of(TypeDescription.CLASS),
                                         ClassConstant.of(TypeDescription.ForLoadedType.of(int.class)))),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -820,7 +820,7 @@ public ForInstrumentedType(TypeDescription instrumentedType) {
             public StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
                 StackManipulation stackManipulation = new StackManipulation.Compound(
                         ClassConstant.of(instrumentedType),
-                        assigner.assign(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Class.class), target.getType(), typing));
+                        assigner.assign(TypeDescription.Generic.OfNonGenericType.ForLoadedType.CLASS, target.getType(), typing));
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot assign Class value to " + target);
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodConstant.java
Patch:
@@ -76,7 +76,7 @@ public boolean isValid() {
     public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
         return new Compound(
                 preparation(),
-                ArrayFactory.forType(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Class.class))
+                ArrayFactory.forType(TypeDescription.Generic.OfNonGenericType.CLASS)
                         .withValues(typeConstantsFor(methodDescription.getParameters().asTypeList().asErasures())),
                 MethodInvocation.invoke(accessorMethod())
         ).apply(methodVisitor, implementationContext);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/NexusAccessor.java
Patch:
@@ -127,7 +127,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                         new TextConstant(Nexus.class.getName()),
                         MethodInvocation.invoke(new MethodDescription.ForLoadedMethod(ClassLoader.class.getMethod("loadClass", String.class))),
                         new TextConstant("initialize"),
-                        ArrayFactory.forType(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Class.class))
+                        ArrayFactory.forType(TypeDescription.Generic.CLASS)
                                 .withValues(Arrays.asList(
                                         ClassConstant.of(TypeDescription.CLASS),
                                         ClassConstant.of(TypeDescription.ForLoadedType.of(int.class)))),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -820,7 +820,7 @@ public ForInstrumentedType(TypeDescription instrumentedType) {
             public StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
                 StackManipulation stackManipulation = new StackManipulation.Compound(
                         ClassConstant.of(instrumentedType),
-                        assigner.assign(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Class.class), target.getType(), typing));
+                        assigner.assign(TypeDescription.Generic.OfNonGenericType.ForLoadedType.CLASS, target.getType(), typing));
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot assign Class value to " + target);
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodConstant.java
Patch:
@@ -76,7 +76,7 @@ public boolean isValid() {
     public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
         return new Compound(
                 preparation(),
-                ArrayFactory.forType(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Class.class))
+                ArrayFactory.forType(TypeDescription.Generic.OfNonGenericType.CLASS)
                         .withValues(typeConstantsFor(methodDescription.getParameters().asTypeList().asErasures())),
                 MethodInvocation.invoke(accessorMethod())
         ).apply(methodVisitor, implementationContext);

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -234,7 +234,7 @@ public static ClassFileVersion of(Class<?> type) throws IOException {
      * @throws IOException If an error occurs while reading the class file.
      */
     public static ClassFileVersion of(Class<?> type, ClassFileLocator classFileLocator) throws IOException {
-        return of(new TypeDescription.ForLoadedType(type), classFileLocator);
+        return of(TypeDescription.ForLoadedType.of(type), classFileLocator);
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/LambdaFactory.java
Patch:
@@ -74,7 +74,7 @@ public LambdaFactory(Object target, Method dispatcher) {
     @SuppressWarnings("all")
     public static boolean register(ClassFileTransformer classFileTransformer, Object classFileFactory) {
         try {
-            TypeDescription typeDescription = new TypeDescription.ForLoadedType(LambdaFactory.class);
+            TypeDescription typeDescription = TypeDescription.ForLoadedType.of(LambdaFactory.class);
             Class<?> lambdaFactory = ClassInjector.UsingReflection.ofSystemClassLoader()
                     .inject(Collections.singletonMap(typeDescription, ClassFileLocator.ForClassLoader.read(LambdaFactory.class).resolve()))
                     .get(typeDescription);

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationValue.java
Patch:
@@ -1683,7 +1683,7 @@ public int hashCode() {
 
             @Override
             public String toString() {
-                return RenderingDispatcher.CURRENT.toSourceString(new TypeDescription.ForLoadedType(type));
+                return RenderingDispatcher.CURRENT.toSourceString(TypeDescription.ForLoadedType.of(type));
             }
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/enumeration/EnumerationDescription.java
Patch:
@@ -107,7 +107,7 @@ public String getValue() {
 
         @Override
         public TypeDescription getEnumerationType() {
-            return new TypeDescription.ForLoadedType(value.getDeclaringClass());
+            return TypeDescription.ForLoadedType.of(value.getDeclaringClass());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -227,7 +227,7 @@ public String getName() {
 
         @Override
         public TypeDescription getDeclaringType() {
-            return new TypeDescription.ForLoadedType(field.getDeclaringClass());
+            return TypeDescription.ForLoadedType.of(field.getDeclaringClass());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -844,7 +844,7 @@ public ForLoadedConstructor(Constructor<?> constructor) {
 
         @Override
         public TypeDescription getDeclaringType() {
-            return new TypeDescription.ForLoadedType(constructor.getDeclaringClass());
+            return TypeDescription.ForLoadedType.of(constructor.getDeclaringClass());
         }
 
         @Override
@@ -952,7 +952,7 @@ public ForLoadedMethod(Method method) {
 
         @Override
         public TypeDescription getDeclaringType() {
-            return new TypeDescription.ForLoadedType(method.getDeclaringClass());
+            return TypeDescription.ForLoadedType.of(method.getDeclaringClass());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/NexusAccessor.java
Patch:
@@ -130,7 +130,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                         ArrayFactory.forType(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Class.class))
                                 .withValues(Arrays.asList(
                                         ClassConstant.of(TypeDescription.CLASS),
-                                        ClassConstant.of(new TypeDescription.ForLoadedType(int.class)))),
+                                        ClassConstant.of(TypeDescription.ForLoadedType.of(int.class)))),
                         MethodInvocation.invoke(new MethodDescription.ForLoadedMethod(Class.class.getMethod("getMethod", String.class, Class[].class))),
                         NullConstant.INSTANCE,
                         ArrayFactory.forType(TypeDescription.Generic.OBJECT)
@@ -200,8 +200,8 @@ public Dispatcher run() {
                 } else {
                     try {
                         Class<?> nexusType = new ClassInjector.UsingReflection(ClassLoader.getSystemClassLoader(), ClassLoadingStrategy.NO_PROTECTION_DOMAIN)
-                                .inject(Collections.singletonMap(new TypeDescription.ForLoadedType(Nexus.class), ClassFileLocator.ForClassLoader.read(Nexus.class).resolve()))
-                                .get(new TypeDescription.ForLoadedType(Nexus.class));
+                                .inject(Collections.singletonMap(TypeDescription.ForLoadedType.of(Nexus.class), ClassFileLocator.ForClassLoader.read(Nexus.class).resolve()))
+                                .get(TypeDescription.ForLoadedType.of(Nexus.class));
                         return new Dispatcher.Available(nexusType.getMethod("register", String.class, ClassLoader.class, ReferenceQueue.class, int.class, Object.class),
                                 nexusType.getMethod("clean", Reference.class));
                     } catch (Exception exception) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/TargetType.java
Patch:
@@ -11,7 +11,7 @@ public final class TargetType {
     /**
      * A description of the {@link net.bytebuddy.dynamic.TargetType}.
      */
-    public static final TypeDescription DESCRIPTION = new TypeDescription.ForLoadedType(TargetType.class);
+    public static final TypeDescription DESCRIPTION = TypeDescription.ForLoadedType.of(TargetType.class);
 
     /**
      * Resolves the given type description to the supplied target type if it represents the {@link TargetType} placeholder.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -987,7 +987,7 @@ public UsingLookup in(Class<?> type) {
         public Map<TypeDescription, Class<?>> inject(Map<? extends TypeDescription, byte[]> types) {
             Map<TypeDescription, Class<?>> loaded = new HashMap<TypeDescription, Class<?>>();
             for (Map.Entry<? extends TypeDescription, byte[]> entry : types.entrySet()) {
-                if (!entry.getKey().isSamePackage(new TypeDescription.ForLoadedType(lookupType()))) {
+                if (!entry.getKey().isSamePackage(TypeDescription.ForLoadedType.of(lookupType()))) {
                     throw new IllegalArgumentException(entry.getKey() + " must be defined in the same package as " + lookup);
                 }
                 loaded.put(entry.getKey(), DISPATCHER.defineClass(lookup, entry.getValue()));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/EqualsMethod.java
Patch:
@@ -40,7 +40,7 @@ public class EqualsMethod implements Implementation {
     /**
      * The {@link Object#equals(Object)} method.
      */
-    private static final MethodDescription.InDefinedShape EQUALS = new TypeDescription.ForLoadedType(Object.class)
+    private static final MethodDescription.InDefinedShape EQUALS = TypeDescription.OBJECT
             .getDeclaredMethods()
             .filter(isEquals())
             .getOnly();
@@ -244,7 +244,7 @@ protected StackManipulation resolve(TypeDescription instrumentedType) {
         /**
          * The {@link Object#getClass()} method.
          */
-        protected static final MethodDescription.InDefinedShape GET_CLASS = new TypeDescription.ForLoadedType(Object.class)
+        protected static final MethodDescription.InDefinedShape GET_CLASS = TypeDescription.ForLoadedType.of(Object.class)
                 .getDeclaredMethods()
                 .filter(named("getClass"))
                 .getOnly();

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/ExceptionMethod.java
Patch:
@@ -44,7 +44,7 @@ public ExceptionMethod(ConstructionDelegate constructionDelegate) {
      * instrumented methods.
      */
     public static Implementation throwing(Class<? extends Throwable> exceptionType) {
-        return throwing(new TypeDescription.ForLoadedType(exceptionType));
+        return throwing(TypeDescription.ForLoadedType.of(exceptionType));
     }
 
     /**
@@ -74,7 +74,7 @@ public static Implementation throwing(TypeDescription exceptionType) {
      * instrumented methods.
      */
     public static Implementation throwing(Class<? extends Throwable> exceptionType, String message) {
-        return throwing(new TypeDescription.ForLoadedType(exceptionType), message);
+        return throwing(TypeDescription.ForLoadedType.of(exceptionType), message);
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -511,7 +511,7 @@ public PropertyConfigurable withAssigner(Assigner assigner, Assigner.Typing typi
 
         @Override
         public AssignerConfigurable in(Class<?> type) {
-            return in(new TypeDescription.ForLoadedType(type));
+            return in(TypeDescription.ForLoadedType.of(type));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -76,7 +76,7 @@ public static AssignerConfigurable value(Object fixedValue) {
         if (type == String.class) {
             return new ForPoolValue(new TextConstant((String) fixedValue), TypeDescription.STRING);
         } else if (type == Class.class) {
-            return new ForPoolValue(ClassConstant.of(new TypeDescription.ForLoadedType((Class<?>) fixedValue)), TypeDescription.CLASS);
+            return new ForPoolValue(ClassConstant.of(TypeDescription.ForLoadedType.of((Class<?>) fixedValue)), TypeDescription.CLASS);
         } else if (type == Boolean.class) {
             return new ForPoolValue(IntegerConstant.forValue((Boolean) fixedValue), boolean.class);
         } else if (type == Byte.class) {
@@ -497,7 +497,7 @@ protected static class ForPoolValue extends FixedValue implements AssignerConfig
          * @param loadedType           A type description representing the loaded type.
          */
         protected ForPoolValue(StackManipulation valueLoadInstruction, Class<?> loadedType) {
-            this(valueLoadInstruction, new TypeDescription.ForLoadedType(loadedType));
+            this(valueLoadInstruction, TypeDescription.ForLoadedType.of(loadedType));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/HashCodeMethod.java
Patch:
@@ -44,7 +44,7 @@ public class HashCodeMethod implements Implementation {
     /**
      * The {@link Object#hashCode()} method.
      */
-    private static final MethodDescription.InDefinedShape HASH_CODE = new TypeDescription.ForLoadedType(Object.class)
+    private static final MethodDescription.InDefinedShape HASH_CODE = TypeDescription.ForLoadedType.of(Object.class)
             .getDeclaredMethods()
             .filter(isHashCode())
             .getOnly();

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -1373,7 +1373,7 @@ public static ArgumentLoader.Factory of(Object value) {
                 } else if (value instanceof Double) {
                     return new ForStackManipulation(DoubleConstant.forValue((Double) value), double.class);
                 } else if (value instanceof Class) {
-                    return new ForStackManipulation(ClassConstant.of(new TypeDescription.ForLoadedType((Class<?>) value)), Class.class);
+                    return new ForStackManipulation(ClassConstant.of(TypeDescription.ForLoadedType.of((Class<?>) value)), Class.class);
                 } else if (JavaType.METHOD_HANDLE.getTypeStub().isInstance(value)) {
                     return new ForStackManipulation(JavaConstant.MethodHandle.ofLoaded(value).asStackManipulation(), JavaType.METHOD_HANDLE.getTypeStub());
                 } else if (JavaType.METHOD_TYPE.getTypeStub().isInstance(value)) {
@@ -1717,7 +1717,7 @@ protected ForVirtualInvocation(TypeDescription typeDescription) {
              * @param type The type to virtually invoke the method upon.
              */
             protected ForVirtualInvocation(Class<?> type) {
-                this(new TypeDescription.ForLoadedType(type));
+                this(TypeDescription.ForLoadedType.of(type));
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -1191,7 +1191,7 @@ public WithCustomProperties filter(ElementMatcher<? super MethodDescription> mat
          * @return A method delegation that redirects method calls to a static method of the supplied type.
          */
         public MethodDelegation to(Class<?> type) {
-            return to(new TypeDescription.ForLoadedType(type));
+            return to(TypeDescription.ForLoadedType.of(type));
         }
 
         /**
@@ -1361,7 +1361,7 @@ public MethodDelegation to(Object target, Type type, String fieldName, MethodGra
          * @return A delegation that redirects method calls to a constructor of the supplied type.
          */
         public MethodDelegation toConstructor(Class<?> type) {
-            return toConstructor(new TypeDescription.ForLoadedType(type));
+            return toConstructor(TypeDescription.ForLoadedType.of(type));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/ToStringMethod.java
Patch:
@@ -33,15 +33,15 @@ public class ToStringMethod implements Implementation {
     /**
      * The {@link StringBuilder#StringBuilder(String)} constructor.
      */
-    private static final MethodDescription.InDefinedShape STRING_BUILDER_CONSTRUCTOR = new TypeDescription.ForLoadedType(StringBuilder.class)
+    private static final MethodDescription.InDefinedShape STRING_BUILDER_CONSTRUCTOR = TypeDescription.ForLoadedType.of(StringBuilder.class)
             .getDeclaredMethods()
             .filter(isConstructor().and(ElementMatchers.takesArguments(String.class)))
             .getOnly();
 
     /**
      * The {@link StringBuilder#toString()} method.
      */
-    private static final MethodDescription.InDefinedShape TO_STRING = new TypeDescription.ForLoadedType(StringBuilder.class)
+    private static final MethodDescription.InDefinedShape TO_STRING = TypeDescription.ForLoadedType.of(StringBuilder.class)
             .getDeclaredMethods()
             .filter(isToString())
             .getOnly();
@@ -276,7 +276,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                 throw new IllegalStateException("toString method does not return String-compatible type: " + instrumentedMethod);
             }
             List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(Math.max(0, fieldDescriptions.size() * 7 - 2) + 10);
-            stackManipulations.add(TypeCreation.of(new TypeDescription.ForLoadedType(StringBuilder.class)));
+            stackManipulations.add(TypeCreation.of(TypeDescription.ForLoadedType.of(StringBuilder.class)));
             stackManipulations.add(Duplication.SINGLE);
             stackManipulations.add(new TextConstant(prefix));
             stackManipulations.add(MethodInvocation.invoke(STRING_BUILDER_CONSTRUCTOR));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -171,7 +171,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
         @SuppressFBWarnings(value = "SE_BAD_FIELD_STORE", justification = "Precomputed method graph is not intended for serialization")
         PrecomputedMethodGraph() {
             LinkedHashMap<MethodDescription.SignatureToken, MethodGraph.Node> nodes = new LinkedHashMap<MethodDescription.SignatureToken, MethodGraph.Node>();
-            MethodDescription callMethod = new MethodDescription.Latent(new TypeDescription.ForLoadedType(Callable.class),
+            MethodDescription callMethod = new MethodDescription.Latent(TypeDescription.ForLoadedType.of(Callable.class),
                     "call",
                     Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
                     Collections.<TypeVariableToken>emptyList(),
@@ -182,7 +182,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
                     AnnotationValue.UNDEFINED,
                     TypeDescription.Generic.UNDEFINED);
             nodes.put(callMethod.asSignatureToken(), new MethodGraph.Node.Simple(callMethod));
-            MethodDescription runMethod = new MethodDescription.Latent(new TypeDescription.ForLoadedType(Runnable.class),
+            MethodDescription runMethod = new MethodDescription.Latent(TypeDescription.ForLoadedType.of(Runnable.class),
                     "run",
                     Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
                     Collections.<TypeVariableToken>emptyList(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TypeProxy.java
Patch:
@@ -128,7 +128,7 @@ protected enum AbstractMethodErrorThrow implements StackManipulation {
          */
         @SuppressFBWarnings(value = "SE_BAD_FIELD_STORE", justification = "Fields of enumerations are never serialized")
         AbstractMethodErrorThrow() {
-            TypeDescription abstractMethodError = new TypeDescription.ForLoadedType(AbstractMethodError.class);
+            TypeDescription abstractMethodError = TypeDescription.ForLoadedType.of(AbstractMethodError.class);
             MethodDescription constructor = abstractMethodError.getDeclaredMethods()
                     .filter(isConstructor().and(takesArguments(0))).getOnly();
             implementation = new Compound(TypeCreation.of(abstractMethodError),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Default.java
Patch:
@@ -71,7 +71,7 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<Defaul
          * Extracts method references of the default annotation.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> annotationProperties = new TypeDescription.ForLoadedType(Default.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> annotationProperties = TypeDescription.ForLoadedType.of(Default.class).getDeclaredMethods();
             SERIALIZABLE_PROXY = annotationProperties.filter(named("serializableProxy")).getOnly();
             PROXY_TYPE = annotationProperties.filter(named("proxyType")).getOnly();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultCall.java
Patch:
@@ -94,7 +94,7 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<Defaul
          * Looks up method constants of the default call annotation.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> annotationProperties = new TypeDescription.ForLoadedType(DefaultCall.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> annotationProperties = TypeDescription.ForLoadedType.of(DefaultCall.class).getDeclaredMethods();
             TARGET_TYPE = annotationProperties.filter(named("targetType")).getOnly();
             SERIALIZABLE_PROXY = annotationProperties.filter(named("serializableProxy")).getOnly();
             NULL_IF_IMPOSSIBLE = annotationProperties.filter(named("nullIfImpossible")).getOnly();

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultMethod.java
Patch:
@@ -86,7 +86,7 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<Defaul
          * Locates method constants for properties of the default method annotation.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> methodList = new TypeDescription.ForLoadedType(DefaultMethod.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> methodList = TypeDescription.ForLoadedType.of(DefaultMethod.class).getDeclaredMethods();
             CACHED = methodList.filter(named("cached")).getOnly();
             TARGET_TYPE = methodList.filter(named("targetType")).getOnly();
             NULL_IF_IMPOSSIBLE = methodList.filter(named("nullIfImpossible")).getOnly();
@@ -222,7 +222,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                 StackManipulation stackManipulation = MethodConstant.forMethod(implementationContext.registerAccessorFor(specialMethodInvocation,
                         MethodAccessorFactory.AccessType.PUBLIC));
                 return (cached
-                        ? FieldAccess.forField(implementationContext.cache(stackManipulation, new TypeDescription.ForLoadedType(Method.class))).read()
+                        ? FieldAccess.forField(implementationContext.cache(stackManipulation, TypeDescription.ForLoadedType.of(Method.class))).read()
                         : stackManipulation).apply(methodVisitor, implementationContext);
             }
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -99,7 +99,7 @@ class Binder extends TargetMethodAnnotationDrivenBinder.ParameterBinder.ForField
          * Fetches a reference to all annotation properties.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> methodList = new TypeDescription.ForLoadedType(FieldProxy.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> methodList = TypeDescription.ForLoadedType.of(FieldProxy.class).getDeclaredMethods();
             DECLARING_TYPE = methodList.filter(named("declaringType")).getOnly();
             FIELD_NAME = methodList.filter(named("value")).getOnly();
             SERIALIZABLE_PROXY = methodList.filter(named("serializableProxy")).getOnly();
@@ -114,7 +114,7 @@ class Binder extends TargetMethodAnnotationDrivenBinder.ParameterBinder.ForField
          * @return A binder for the {@link FieldProxy} annotation.
          */
         public static TargetMethodAnnotationDrivenBinder.ParameterBinder<FieldProxy> install(Class<?> type) {
-            return install(new TypeDescription.ForLoadedType(type));
+            return install(TypeDescription.ForLoadedType.of(type));
         }
 
         /**
@@ -164,7 +164,7 @@ public static TargetMethodAnnotationDrivenBinder.ParameterBinder<FieldProxy> ins
          * @return A binder for the {@link FieldProxy} annotation.
          */
         public static TargetMethodAnnotationDrivenBinder.ParameterBinder<FieldProxy> install(Class<?> getterType, Class<?> setterType) {
-            return install(new TypeDescription.ForLoadedType(getterType), new TypeDescription.ForLoadedType(setterType));
+            return install(TypeDescription.ForLoadedType.of(getterType), TypeDescription.ForLoadedType.of(setterType));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldValue.java
Patch:
@@ -78,7 +78,7 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<FieldV
          * Initializes the methods of the annotation that is read by this binder.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> methodList = new TypeDescription.ForLoadedType(FieldValue.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> methodList = TypeDescription.ForLoadedType.of(FieldValue.class).getDeclaredMethods();
             DECLARING_TYPE = methodList.filter(named("declaringType")).getOnly();
             FIELD_NAME = methodList.filter(named("value")).getOnly();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -103,7 +103,7 @@ class Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<Morph
          * Looks up references for all annotation properties of the morph annotation.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> methodList = new TypeDescription.ForLoadedType(Morph.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> methodList = TypeDescription.ForLoadedType.of(Morph.class).getDeclaredMethods();
             SERIALIZABLE_PROXY = methodList.filter(named("serializableProxy")).getOnly();
             DEFAULT_METHOD = methodList.filter(named("defaultMethod")).getOnly();
             DEFAULT_TARGET = methodList.filter(named("defaultTarget")).getOnly();
@@ -134,7 +134,7 @@ protected Binder(MethodDescription forwardingMethod) {
          * annotation.
          */
         public static TargetMethodAnnotationDrivenBinder.ParameterBinder<Morph> install(Class<?> type) {
-            return install(new TypeDescription.ForLoadedType(type));
+            return install(TypeDescription.ForLoadedType.of(type));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -108,7 +108,7 @@ protected Binder(MethodDescription forwardingMethod) {
          * annotation.
          */
         public static TargetMethodAnnotationDrivenBinder.ParameterBinder<Pipe> install(Class<?> type) {
-            return install(new TypeDescription.ForLoadedType(type));
+            return install(TypeDescription.ForLoadedType.of(type));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Super.java
Patch:
@@ -156,7 +156,7 @@ protected StackManipulation proxyFor(TypeDescription parameterType,
          * Extracts method references to the annotation methods.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> annotationProperties = new TypeDescription.ForLoadedType(Super.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> annotationProperties = TypeDescription.ForLoadedType.of(Super.class).getDeclaredMethods();
             IGNORE_FINALIZER = annotationProperties.filter(named("ignoreFinalizer")).getOnly();
             SERIALIZABLE_PROXY = annotationProperties.filter(named("serializableProxy")).getOnly();
             CONSTRUCTOR_PARAMETERS = annotationProperties.filter(named("constructorParameters")).getOnly();
@@ -204,7 +204,7 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<Super>
          * Extracts method references of the super annotation.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> annotationProperties = new TypeDescription.ForLoadedType(Super.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> annotationProperties = TypeDescription.ForLoadedType.of(Super.class).getDeclaredMethods();
             STRATEGY = annotationProperties.filter(named("strategy")).getOnly();
             PROXY_TYPE = annotationProperties.filter(named("proxyType")).getOnly();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperMethod.java
Patch:
@@ -132,7 +132,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                 StackManipulation stackManipulation = MethodConstant.forMethod(implementationContext.registerAccessorFor(specialMethodInvocation,
                         MethodAccessorFactory.AccessType.PUBLIC));
                 return (cached
-                        ? FieldAccess.forField(implementationContext.cache(stackManipulation, new TypeDescription.ForLoadedType(Method.class))).read()
+                        ? FieldAccess.forField(implementationContext.cache(stackManipulation, TypeDescription.ForLoadedType.of(Method.class))).read()
                         : stackManipulation).apply(methodVisitor, implementationContext);
             }
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveBoxingDelegate.java
Patch:
@@ -86,7 +86,7 @@ public enum PrimitiveBoxingDelegate {
                             StackSize sizeDifference,
                             String boxingMethodName,
                             String boxingMethodDescriptor) {
-        this.wrapperType = new TypeDescription.ForLoadedType(wrapperType);
+        this.wrapperType = TypeDescription.ForLoadedType.of(wrapperType);
         this.size = sizeDifference.toDecreasingSize();
         this.boxingMethodName = boxingMethodName;
         this.boxingMethodDescriptor = boxingMethodDescriptor;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveUnboxingDelegate.java
Patch:
@@ -95,8 +95,8 @@ public enum PrimitiveUnboxingDelegate implements StackManipulation {
                               String unboxingMethodName,
                               String unboxingMethodDescriptor) {
         this.size = sizeDifference.toIncreasingSize();
-        this.wrapperType = new TypeDescription.ForLoadedType(wrapperType);
-        this.primitiveType = new TypeDescription.ForLoadedType(primitiveType);
+        this.wrapperType = TypeDescription.ForLoadedType.of(wrapperType);
+        this.primitiveType = TypeDescription.ForLoadedType.of(primitiveType);
         this.unboxingMethodName = unboxingMethodName;
         this.unboxingMethodDescriptor = unboxingMethodDescriptor;
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/FieldConstant.java
Patch:
@@ -99,7 +99,7 @@ public boolean isValid() {
 
         @Override
         public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
-            return FieldAccess.forField(implementationContext.cache(fieldConstant, new TypeDescription.ForLoadedType(Field.class)))
+            return FieldAccess.forField(implementationContext.cache(fieldConstant, TypeDescription.ForLoadedType.of(Field.class)))
                     .read()
                     .apply(methodVisitor, implementationContext);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodConstant.java
Patch:
@@ -236,7 +236,7 @@ protected static class CachedMethod implements StackManipulation {
         /**
          * A description of the {@link java.lang.reflect.Method} type.
          */
-        private static final TypeDescription METHOD_TYPE = new TypeDescription.ForLoadedType(Method.class);
+        private static final TypeDescription METHOD_TYPE = TypeDescription.ForLoadedType.of(Method.class);
 
         /**
          * The stack manipulation that is represented by this caching wrapper.
@@ -290,7 +290,7 @@ protected static class CachedConstructor implements StackManipulation {
         /**
          * A description of the {@link java.lang.reflect.Constructor} type.
          */
-        private static final TypeDescription CONSTRUCTOR_TYPE = new TypeDescription.ForLoadedType(Constructor.class);
+        private static final TypeDescription CONSTRUCTOR_TYPE = TypeDescription.ForLoadedType.of(Constructor.class);
 
         /**
          * The stack manipulation that is represented by this caching wrapper.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/SerializedConstant.java
Patch:
@@ -70,9 +70,9 @@ public boolean isValid() {
     public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
         try {
             return new StackManipulation.Compound(
-                    TypeCreation.of(new TypeDescription.ForLoadedType(ObjectInputStream.class)),
+                    TypeCreation.of(TypeDescription.ForLoadedType.of(ObjectInputStream.class)),
                     Duplication.SINGLE,
-                    TypeCreation.of(new TypeDescription.ForLoadedType(ByteArrayInputStream.class)),
+                    TypeCreation.of(TypeDescription.ForLoadedType.of(ByteArrayInputStream.class)),
                     Duplication.SINGLE,
                     new TextConstant(serialization),
                     new TextConstant(CHARSET),

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/InstanceTypeMatcher.java
Patch:
@@ -27,7 +27,7 @@ public InstanceTypeMatcher(ElementMatcher<? super TypeDescription> matcher) {
 
     @Override
     public boolean matches(T target) {
-        return target != null && matcher.matches(new TypeDescription.ForLoadedType(target.getClass()));
+        return target != null && matcher.matches(TypeDescription.ForLoadedType.of(target.getClass()));
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaType.java
Patch:
@@ -71,7 +71,7 @@ public enum JavaType {
     JavaType(String typeName, int modifiers, Class<?> superClass, Class<?>... interfaces) {
         TypeDescription typeDescription;
         try {
-            typeDescription = new TypeDescription.ForLoadedType(Class.forName(typeName));
+            typeDescription = TypeDescription.ForLoadedType.of(Class.forName(typeName));
         } catch (Exception ignored) {
             typeDescription = new TypeDescription.Latent(typeName,
                     modifiers,

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/RawMatcherForResolvableTypesTest.java
Patch:
@@ -11,7 +11,7 @@ public class RawMatcherForResolvableTypesTest {
 
     @Test
     public void testUnloadedMatches() throws Exception {
-        assertThat(AgentBuilder.RawMatcher.ForResolvableTypes.INSTANCE.matches(new TypeDescription.ForLoadedType(Foo.class),
+        assertThat(AgentBuilder.RawMatcher.ForResolvableTypes.INSTANCE.matches(TypeDescription.ForLoadedType.of(Foo.class),
                 Foo.class.getClassLoader(),
                 JavaModule.ofType(Foo.class),
                 null,
@@ -20,7 +20,7 @@ public void testUnloadedMatches() throws Exception {
 
     @Test
     public void testResolvableMatches() throws Exception {
-        assertThat(AgentBuilder.RawMatcher.ForResolvableTypes.INSTANCE.matches(new TypeDescription.ForLoadedType(Foo.class),
+        assertThat(AgentBuilder.RawMatcher.ForResolvableTypes.INSTANCE.matches(TypeDescription.ForLoadedType.of(Foo.class),
                 Foo.class.getClassLoader(),
                 JavaModule.ofType(Foo.class),
                 Foo.class,
@@ -29,7 +29,7 @@ public void testResolvableMatches() throws Exception {
 
     @Test
     public void testUnresolvableDoesNotMatch() throws Exception {
-        assertThat(AgentBuilder.RawMatcher.ForResolvableTypes.INSTANCE.matches(new TypeDescription.ForLoadedType(Bar.class),
+        assertThat(AgentBuilder.RawMatcher.ForResolvableTypes.INSTANCE.matches(TypeDescription.ForLoadedType.of(Bar.class),
                 Bar.class.getClassLoader(),
                 JavaModule.ofType(Bar.class),
                 Bar.class,

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -1855,7 +1855,7 @@ public void testInvisibleDelegationAdvice() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testNonResolvedAdvice() throws Exception {
-        Advice.to(new TypeDescription.ForLoadedType(TrivialAdvice.class));
+        Advice.to(TypeDescription.ForLoadedType.of(TrivialAdvice.class));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AnnotationListEmptyTest.java
Patch:
@@ -20,7 +20,7 @@ public void testAnnotationIsPresent() throws Exception {
 
     @Test
     public void testAnnotationIsPresentDescription() throws Exception {
-        assertThat(new AnnotationList.Empty().isAnnotationPresent(new TypeDescription.ForLoadedType(Annotation.class)), is(false));
+        assertThat(new AnnotationList.Empty().isAnnotationPresent(TypeDescription.ForLoadedType.of(Annotation.class)), is(false));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/enumeration/EnumerationDescriptionLatentTest.java
Patch:
@@ -9,6 +9,6 @@ public class EnumerationDescriptionLatentTest extends AbstractEnumerationDescrip
     protected EnumerationDescription describe(Enum<?> enumeration,
                                               Class<?> carrierType,
                                               MethodDescription.InDefinedShape annotationMethod) {
-        return new EnumerationDescription.Latent(new TypeDescription.ForLoadedType(enumeration.getDeclaringClass()), enumeration.name());
+        return new EnumerationDescription.Latent(TypeDescription.ForLoadedType.of(enumeration.getDeclaringClass()), enumeration.name());
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/FieldDescriptionLatentTest.java
Patch:
@@ -10,7 +10,7 @@ public class FieldDescriptionLatentTest extends AbstractFieldDescriptionTest {
 
     @Override
     protected FieldDescription.InDefinedShape describe(Field field) {
-        return new FieldDescription.Latent(new TypeDescription.ForLoadedType(field.getDeclaringClass()),
+        return new FieldDescription.Latent(TypeDescription.ForLoadedType.of(field.getDeclaringClass()),
                 field.getName(),
                 field.getModifiers(),
                 TypeDefinition.Sort.describe(field.getGenericType()),

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTest.java
Patch:
@@ -17,13 +17,13 @@ public class MethodDescriptionLatentTest extends AbstractMethodDescriptionTest {
 
     @Override
     protected MethodDescription.InDefinedShape describe(Method method) {
-        return new MethodDescription.Latent(new TypeDescription.ForLoadedType(method.getDeclaringClass()),
+        return new MethodDescription.Latent(TypeDescription.ForLoadedType.of(method.getDeclaringClass()),
                 new MethodDescription.ForLoadedMethod(method).asToken(ElementMatchers.is(method.getDeclaringClass())));
     }
 
     @Override
     protected MethodDescription.InDefinedShape describe(Constructor<?> constructor) {
-        return new MethodDescription.Latent(new TypeDescription.ForLoadedType(constructor.getDeclaringClass()),
+        return new MethodDescription.Latent(TypeDescription.ForLoadedType.of(constructor.getDeclaringClass()),
                 new MethodDescription.ForLoadedConstructor(constructor).asToken(ElementMatchers.is(constructor.getDeclaringClass())));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractPackageDescriptionTest.java
Patch:
@@ -27,8 +27,8 @@ public void testNonTrivialPackage() throws Exception {
 
     @Test
     public void testPackageContains() throws Exception {
-        assertThat(describe(Child.class).contains(new TypeDescription.ForLoadedType(Child.class)), is(true));
-        assertThat(describe(Object.class).contains(new TypeDescription.ForLoadedType(Child.class)), is(false));
+        assertThat(describe(Child.class).contains(TypeDescription.ForLoadedType.of(Child.class)), is(true));
+        assertThat(describe(Object.class).contains(TypeDescription.ForLoadedType.of(Child.class)), is(false));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionArrayProjectionTest.java
Patch:
@@ -12,7 +12,7 @@ public class TypeDescriptionArrayProjectionTest extends AbstractTypeDescriptionT
 
     @Override
     protected TypeDescription describe(Class<?> type) {
-        return TypeDescription.ArrayProjection.of(new TypeDescription.ForLoadedType(type), 0);
+        return TypeDescription.ArrayProjection.of(TypeDescription.ForLoadedType.of(type), 0);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericOfParameterizedTypeForGenerifiedErasureTest.java
Patch:
@@ -15,7 +15,7 @@ public void testNonGenerifiedType() throws Exception {
 
     @Test
     public void testGenerifiedType() throws Exception {
-        TypeDescription.Generic typeDescription = TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(new TypeDescription.ForLoadedType(Foo.class));
+        TypeDescription.Generic typeDescription = TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(TypeDescription.ForLoadedType.of(Foo.class));
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
         assertThat(typeDescription.getTypeArguments().size(), is(1));
         assertThat(typeDescription.getTypeArguments().getOnly().getSort(), is(TypeDefinition.Sort.VARIABLE));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorAnnotationStripperTest.java
Patch:
@@ -86,7 +86,7 @@ public void testTypeVariable() throws Exception {
 
     @Test
     public void testParameterized() throws Exception {
-        TypeDescription.Generic typeDescription = TypeDescription.Generic.Builder.parameterizedType(new TypeDescription.ForLoadedType(Collection.class),
+        TypeDescription.Generic typeDescription = TypeDescription.Generic.Builder.parameterizedType(TypeDescription.ForLoadedType.of(Collection.class),
                 TypeDescription.Generic.Builder.rawType(Object.class).annotate(annotationDescription).build()).annotate(annotationDescription).build();
         assertThat(TypeDescription.Generic.Visitor.AnnotationStripper.INSTANCE.onParameterizedType(typeDescription), is(typeDescription));
         assertThat(TypeDescription.Generic.Visitor.AnnotationStripper.INSTANCE.onParameterizedType(typeDescription).getDeclaredAnnotations().size(), is(0));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorAssignerTest.java
Patch:
@@ -49,7 +49,7 @@ public class TypeDescriptionGenericVisitorAssignerTest {
 
     @Before
     public void setUp() throws Exception {
-        FieldList<?> fields = new TypeDescription.ForLoadedType(GenericTypes.class).getDeclaredFields();
+        FieldList<?> fields = TypeDescription.ForLoadedType.of(GenericTypes.class).getDeclaredFields();
         collectionRaw = fields.filter(named("collectionRaw")).getOnly().getType();
         collectionWildcard = fields.filter(named("collectionWildcard")).getOnly().getType();
         collectionTypeVariableT = fields.filter(named("collectionTypeVariableT")).getOnly().getType();

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorReifyingTest.java
Patch:
@@ -34,7 +34,7 @@ public void testInitiatingGenerifiedNonGenericType() throws Exception {
 
     @Test
     public void testInitiatingNonGenerifiedNonGenericType() throws Exception {
-        when(generic.asErasure()).thenReturn(new TypeDescription.ForLoadedType(Foo.class));
+        when(generic.asErasure()).thenReturn(TypeDescription.ForLoadedType.of(Foo.class));
         assertThat(TypeDescription.Generic.Visitor.Reifying.INITIATING.onNonGenericType(generic), not(sameInstance(generic)));
         assertThat(TypeDescription.Generic.Visitor.Reifying.INITIATING.onNonGenericType(generic).getSort(), is(TypeDefinition.Sort.NON_GENERIC));
     }
@@ -67,7 +67,7 @@ public void testInheritingGenerifiedNonGenericType() throws Exception {
 
     @Test
     public void testInheritingNonGenerifiedNonGenericType() throws Exception {
-        when(generic.asErasure()).thenReturn(new TypeDescription.ForLoadedType(Foo.class));
+        when(generic.asErasure()).thenReturn(TypeDescription.ForLoadedType.of(Foo.class));
         assertThat(TypeDescription.Generic.Visitor.Reifying.INHERITING.onNonGenericType(generic), not(sameInstance(generic)));
         assertThat(TypeDescription.Generic.Visitor.Reifying.INHERITING.onNonGenericType(generic).getSort(), is(TypeDefinition.Sort.NON_GENERIC));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorSubstitutorForAttachmentTest.java
Patch:
@@ -19,7 +19,7 @@ public class TypeDescriptionGenericVisitorSubstitutorForAttachmentTest {
     public void testAttachment() throws Exception {
         TypeDescription.Generic original = TypeDefinition.Sort.describe(Foo.Inner.class.getDeclaredField(FOO).getGenericType());
         TypeDescription.Generic detached = original.accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(ElementMatchers.is(Foo.Inner.class)));
-        TypeDescription target = new TypeDescription.ForLoadedType(Bar.class);
+        TypeDescription target = TypeDescription.ForLoadedType.of(Bar.class);
         TypeDescription.Generic attached = detached.accept(new TypeDescription.Generic.Visitor.Substitutor.ForAttachment(target.asGenericType(), target));
         assertThat(attached.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
         assertThat(attached.asErasure(), sameInstance(target));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeListExplicitTest.java
Patch:
@@ -6,12 +6,12 @@ public class TypeListExplicitTest extends AbstractTypeListTest<TypeDescription>
 
     @Override
     protected TypeDescription getFirst() throws Exception {
-        return new TypeDescription.ForLoadedType(Foo.class);
+        return TypeDescription.ForLoadedType.of(Foo.class);
     }
 
     @Override
     protected TypeDescription getSecond() throws Exception {
-        return new TypeDescription.ForLoadedType(Bar.class);
+        return TypeDescription.ForLoadedType.of(Bar.class);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeListForLoadedTest.java
Patch:
@@ -21,6 +21,6 @@ protected TypeList asList(List<Class<?>> elements) {
 
     @Override
     protected TypeDescription asElement(Class<?> element) {
-        return new TypeDescription.ForLoadedType(element);
+        return TypeDescription.ForLoadedType.of(element);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/TransformerForFieldTest.java
Patch:
@@ -94,7 +94,7 @@ public void testModifierTransformation() throws Exception {
 
     @Test
     public void testNoChangesUnlessSpecified() throws Exception {
-        TypeDescription typeDescription = new TypeDescription.ForLoadedType(Bar.class);
+        TypeDescription typeDescription = TypeDescription.ForLoadedType.of(Bar.class);
         FieldDescription fieldDescription = typeDescription.getSuperClass().getDeclaredFields().filter(named(FOO)).getOnly();
         FieldDescription transformed = Transformer.ForField.withModifiers().transform(typeDescription, fieldDescription);
         assertThat(transformed, is(fieldDescription));
@@ -103,7 +103,7 @@ public void testNoChangesUnlessSpecified() throws Exception {
 
     @Test
     public void testRetainsInstrumentedType() throws Exception {
-        TypeDescription typeDescription = new TypeDescription.ForLoadedType(Bar.class);
+        TypeDescription typeDescription = TypeDescription.ForLoadedType.of(Bar.class);
         FieldDescription fieldDescription = typeDescription.getSuperClass().getDeclaredFields().filter(named(BAR)).getOnly();
         FieldDescription transformed = Transformer.ForField.withModifiers().transform(typeDescription, fieldDescription);
         assertThat(transformed, is(fieldDescription));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/TransformerForMethodTest.java
Patch:
@@ -145,7 +145,7 @@ public void testModifierTransformation() throws Exception {
 
     @Test
     public void testNoChangesUnlessSpecified() throws Exception {
-        TypeDescription typeDescription = new TypeDescription.ForLoadedType(Bar.class);
+        TypeDescription typeDescription = TypeDescription.ForLoadedType.of(Bar.class);
         MethodDescription methodDescription = typeDescription.getSuperClass().getDeclaredMethods().filter(named(FOO)).getOnly();
         MethodDescription transformed = Transformer.ForMethod.withModifiers().transform(typeDescription, methodDescription);
         assertThat(transformed, is(methodDescription));
@@ -154,7 +154,7 @@ public void testNoChangesUnlessSpecified() throws Exception {
 
     @Test
     public void testRetainsInstrumentedType() throws Exception {
-        TypeDescription typeDescription = new TypeDescription.ForLoadedType(Bar.class);
+        TypeDescription typeDescription = TypeDescription.ForLoadedType.of(Bar.class);
         MethodDescription methodDescription = typeDescription.getSuperClass().getDeclaredMethods().filter(named(BAR)).getOnly();
         MethodDescription transformed = Transformer.ForMethod.withModifiers().transform(typeDescription, methodDescription);
         assertThat(transformed, is(methodDescription));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassInjectorUsingReflectionTest.java
Patch:
@@ -52,7 +52,7 @@ public void testBootstrapClassLoader() throws Exception {
     @ClassInjectionAvailableRule.Enforce
     public void testInjection() throws Exception {
         new ClassInjector.UsingReflection(classLoader)
-                .inject(Collections.<TypeDescription, byte[]>singletonMap(new TypeDescription.ForLoadedType(Foo.class), ClassFileExtraction.extract(Foo.class)));
+                .inject(Collections.<TypeDescription, byte[]>singletonMap(TypeDescription.ForLoadedType.of(Foo.class), ClassFileExtraction.extract(Foo.class)));
         assertThat(classLoader.loadClass(Foo.class.getName()).getClassLoader(), is(classLoader));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassInjectorUsingUnsafeTest.java
Patch:
@@ -34,8 +34,8 @@ public void setUp() throws Exception {
     @ClassUnsafeInjectionAvailableRule.Enforce
     public void testUnsafeInjection() throws Exception {
         assertThat(new ClassInjector.UsingUnsafe(classLoader)
-                .inject(Collections.singletonMap(new TypeDescription.ForLoadedType(Foo.class), ClassFileExtraction.extract(Foo.class)))
-                .get(new TypeDescription.ForLoadedType(Foo.class)), notNullValue(Class.class));
+                .inject(Collections.singletonMap(TypeDescription.ForLoadedType.of(Foo.class), ClassFileExtraction.extract(Foo.class)))
+                .get(TypeDescription.ForLoadedType.of(Foo.class)), notNullValue(Class.class));
         assertThat(Class.forName(Foo.class.getName(), false, classLoader).getName(), is(Foo.class.getName()));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategyDefaultTest.java
Patch:
@@ -46,7 +46,7 @@ public class ClassLoadingStrategyDefaultTest {
     public void setUp() throws Exception {
         classLoader = new URLClassLoader(new URL[0], null);
         binaryRepresentations = new LinkedHashMap<TypeDescription, byte[]>();
-        typeDescription = new TypeDescription.ForLoadedType(Foo.class);
+        typeDescription = TypeDescription.ForLoadedType.of(Foo.class);
         binaryRepresentations.put(typeDescription, ClassFileExtraction.extract(Foo.class));
         protectionDomain = getClass().getProtectionDomain();
         when(packageDefinitionStrategy.define(any(ClassLoader.class), any(String.class), any(String.class)))

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategyForUnsafeInjectionTest.java
Patch:
@@ -36,7 +36,7 @@ public class ClassLoadingStrategyForUnsafeInjectionTest {
     public void setUp() throws Exception {
         classLoader = new URLClassLoader(new URL[0], null);
         binaryRepresentations = new LinkedHashMap<TypeDescription, byte[]>();
-        typeDescription = new TypeDescription.ForLoadedType(Foo.class);
+        typeDescription = TypeDescription.ForLoadedType.of(Foo.class);
         binaryRepresentations.put(typeDescription, ClassFileExtraction.extract(Foo.class));
         protectionDomain = getClass().getProtectionDomain();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategyUsingLookupTest.java
Patch:
@@ -29,7 +29,7 @@ public class ClassLoadingStrategyUsingLookupTest {
 
     @Before
     public void setUp() throws Exception {
-        typeDescription = new TypeDescription.ForLoadedType(Foo.class);
+        typeDescription = TypeDescription.ForLoadedType.of(Foo.class);
         binaryRepresentation = new byte[]{1, 2, 3};
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/AbstractDynamicTypeBuilderForInliningTest.java
Patch:
@@ -453,7 +453,7 @@ public void testEnabledAnnotationRetention() throws Exception {
     @SuppressWarnings("unchecked")
     public void testAnnotationTypeOnInterfaceType() throws Exception {
         Class<? extends Annotation> typeAnnotationType = (Class<? extends Annotation>) Class.forName(TYPE_VARIABLE_NAME);
-        MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
+        MethodDescription.InDefinedShape value = TypeDescription.ForLoadedType.of(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Class<?> type = create(Class.forName(SIMPLE_TYPE_ANNOTATED))
                 .merge(TypeManifestation.ABSTRACT)
                 .implement(TypeDescription.Generic.Builder.rawType(Callable.class)
@@ -475,7 +475,7 @@ public void testAnnotationTypeOnInterfaceType() throws Exception {
     @SuppressWarnings("unchecked")
     public void testAnnotationTypeOnTypeVariableType() throws Exception {
         Class<? extends Annotation> typeAnnotationType = (Class<? extends Annotation>) Class.forName(TYPE_VARIABLE_NAME);
-        MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
+        MethodDescription.InDefinedShape value = TypeDescription.ForLoadedType.of(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Class<?> type = create(Class.forName(SIMPLE_TYPE_ANNOTATED))
                 .merge(TypeManifestation.ABSTRACT)
                 .typeVariable(BAR, TypeDescription.Generic.Builder.rawType(Callable.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderTest.java
Patch:
@@ -496,7 +496,7 @@ public void testNoVisibilityBridgeForAbstractMethod() throws Exception {
     @SuppressWarnings("unchecked")
     public void testAnnotationTypeOnSuperClass() throws Exception {
         Class<? extends Annotation> typeAnnotationType = (Class<? extends Annotation>) Class.forName(TYPE_VARIABLE_NAME);
-        MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
+        MethodDescription.InDefinedShape value = TypeDescription.ForLoadedType.of(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Class<?> type = new ByteBuddy()
                 .subclass(TypeDescription.Generic.Builder.rawType(Object.class)
                         .build(AnnotationDescription.Builder.ofType(typeAnnotationType).define(VALUE, BAZ).build()))
@@ -514,7 +514,7 @@ public void testAnnotationTypeOnSuperClass() throws Exception {
     @SuppressWarnings("unchecked")
     public void testReceiverTypeDefinition() throws Exception {
         Class<? extends Annotation> typeAnnotationType = (Class<? extends Annotation>) Class.forName(TYPE_VARIABLE_NAME);
-        MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
+        MethodDescription.InDefinedShape value = TypeDescription.ForLoadedType.of(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Method method = createPlain()
                 .defineMethod(FOO, void.class)
                 .intercept(StubMethod.INSTANCE)
@@ -535,7 +535,7 @@ public void testReceiverTypeDefinition() throws Exception {
     @SuppressWarnings("unchecked")
     public void testReceiverTypeInterception() throws Exception {
         Class<? extends Annotation> typeAnnotationType = (Class<? extends Annotation>) Class.forName(TYPE_VARIABLE_NAME);
-        MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
+        MethodDescription.InDefinedShape value = TypeDescription.ForLoadedType.of(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Method method = createPlain()
                 .method(named("toString"))
                 .intercept(StubMethod.INSTANCE)

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/AbstractMethodCallProxyTest.java
Patch:
@@ -36,7 +36,7 @@ public class AbstractMethodCallProxyTest {
     private MethodAccessorFactory methodAccessorFactory;
 
     protected Class<?> proxyOnlyDeclaredMethodOf(Class<?> proxyTarget) throws Exception {
-        MethodDescription.InDefinedShape proxyMethod = new TypeDescription.ForLoadedType(proxyTarget)
+        MethodDescription.InDefinedShape proxyMethod = TypeDescription.ForLoadedType.of(proxyTarget)
                 .getDeclaredMethods().filter(not(isConstructor())).getOnly();
         when(methodAccessorFactory.registerAccessorFor(specialMethodInvocation, MethodAccessorFactory.AccessType.DEFAULT)).thenReturn(proxyMethod);
         String auxiliaryTypeName = getClass().getName() + "$" + proxyTarget.getSimpleName() + "$Proxy";

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TypeProxyCreationTest.java
Patch:
@@ -65,7 +65,7 @@ public void setUp() throws Exception {
         for (ModifierContributor modifierContributor : AuxiliaryType.DEFAULT_TYPE_MODIFIER) {
             modifiers = modifiers | modifierContributor.getMask();
         }
-        foo = new TypeDescription.ForLoadedType(Foo.class);
+        foo = TypeDescription.ForLoadedType.of(Foo.class);
         fooMethods = MethodGraph.Compiler.DEFAULT.compile(foo)
                 .listNodes()
                 .asMethodList()
@@ -211,7 +211,7 @@ public void testForConstructorConstruction() throws Exception {
         when(methodAccessorFactory.registerAccessorFor(specialMethodInvocation, MethodAccessorFactory.AccessType.DEFAULT)).thenReturn(proxyMethod);
         StackManipulation stackManipulation = new TypeProxy.ForSuperMethodByConstructor(foo,
                 implementationTarget,
-                Collections.singletonList((TypeDescription) new TypeDescription.ForLoadedType(Void.class)),
+                Collections.singletonList((TypeDescription) TypeDescription.ForLoadedType.of(Void.class)),
                 true,
                 false);
         MethodVisitor methodVisitor = mock(MethodVisitor.class);
@@ -291,7 +291,7 @@ public void testForReflectionFactoryConstruction() throws Exception {
         MethodVisitor methodVisitor = mock(MethodVisitor.class);
         Implementation.Context implementationContext = mock(Implementation.Context.class);
         when(implementationContext.register(any(AuxiliaryType.class)))
-                .thenReturn(new TypeDescription.ForLoadedType(FooProxyMake.class));
+                .thenReturn(TypeDescription.ForLoadedType.of(FooProxyMake.class));
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);
         assertThat(size.getSizeImpact(), is(1));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/DefaultCallBinderTest.java
Patch:
@@ -94,7 +94,7 @@ public void testExplicitLookup() throws Exception {
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = DefaultCall.Binder.INSTANCE
                 .bind(annotationDescription, source, target, implementationTarget, assigner, Assigner.Typing.STATIC);
         assertThat(parameterBinding.isValid(), is(true));
-        verify(implementationTarget).invokeDefault(token, new TypeDescription.ForLoadedType(INTERFACE_TYPE));
+        verify(implementationTarget).invokeDefault(token, TypeDescription.ForLoadedType.of(INTERFACE_TYPE));
         verifyNoMoreInteractions(implementationTarget);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/DefaultMethodBinderTest.java
Patch:
@@ -100,7 +100,7 @@ public void testBindNoInterface() throws Exception {
     public void testBindExplicit() throws Exception {
         when(targetType.isAssignableFrom(Method.class)).thenReturn(true);
         when(source.isMethod()).thenReturn(true);
-        when(implementationTarget.invokeDefault(token, new TypeDescription.ForLoadedType(Runnable.class))).thenReturn(specialMethodInvocation);
+        when(implementationTarget.invokeDefault(token, TypeDescription.ForLoadedType.of(Runnable.class))).thenReturn(specialMethodInvocation);
         when(specialMethodInvocation.isValid()).thenReturn(true);
         when(annotation.targetType()).thenReturn((Class) Runnable.class);
         when(instrumentedType.getInterfaces()).thenReturn(new TypeList.Generic.Explicit(genericInterfaceType, genericInterfaceType));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/MorphBinderTest.java
Patch:
@@ -121,7 +121,7 @@ public void testDefaultMethodCallExplicitInvalid() throws Exception {
         when(morphMethod.getDeclaringType()).thenReturn(morphType);
         when(annotation.defaultMethod()).thenReturn(true);
         doReturn(Foo.class).when(annotation).defaultTarget();
-        when(implementationTarget.invokeDefault(morphToken, new TypeDescription.ForLoadedType(Foo.class)))
+        when(implementationTarget.invokeDefault(morphToken, TypeDescription.ForLoadedType.of(Foo.class)))
                 .thenReturn(specialMethodInvocation);
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = new Morph.Binder(morphMethod)
                 .bind(annotationDescription, source, target, implementationTarget, assigner, Assigner.Typing.STATIC);
@@ -137,7 +137,7 @@ public void testDefaultMethodCallExplicitValid() throws Exception {
         when(morphMethod.getDeclaringType()).thenReturn(morphType);
         when(annotation.defaultMethod()).thenReturn(true);
         doReturn(Foo.class).when(annotation).defaultTarget();
-        when(implementationTarget.invokeDefault(morphToken, new TypeDescription.ForLoadedType(Foo.class)))
+        when(implementationTarget.invokeDefault(morphToken, TypeDescription.ForLoadedType.of(Foo.class)))
                 .thenReturn(specialMethodInvocation);
         when(specialMethodInvocation.isValid()).thenReturn(true);
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = new Morph.Binder(morphMethod)

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/OriginBinderTest.java
Patch:
@@ -128,7 +128,7 @@ public void testModifierBinding() throws Exception {
     @Test
     @JavaVersionRule.Enforce(7)
     public void testMethodHandleBinding() throws Exception {
-        when(genericTargetType.asErasure()).thenReturn(new TypeDescription.ForLoadedType(JavaType.METHOD_HANDLE.load()));
+        when(genericTargetType.asErasure()).thenReturn(TypeDescription.ForLoadedType.of(JavaType.METHOD_HANDLE.load()));
         when(methodDescription.getReturnType()).thenReturn(TypeDescription.Generic.VOID);
         when(methodDescription.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
         TypeDescription typeDescription = mock(TypeDescription.class);
@@ -142,7 +142,7 @@ public void testMethodHandleBinding() throws Exception {
     @Test
     @JavaVersionRule.Enforce(7)
     public void testMethodTypeBinding() throws Exception {
-        when(genericTargetType.asErasure()).thenReturn(new TypeDescription.ForLoadedType(JavaType.METHOD_TYPE.load()));
+        when(genericTargetType.asErasure()).thenReturn(TypeDescription.ForLoadedType.of(JavaType.METHOD_TYPE.load()));
         when(methodDescription.getReturnType()).thenReturn(TypeDescription.Generic.VOID);
         when(methodDescription.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = Origin.Binder.INSTANCE

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinderTest.java
Patch:
@@ -126,10 +126,10 @@ public void setUp() throws Exception {
         when(targetMethod.getParameters())
                 .thenReturn((ParameterList) new ParameterList.Explicit<ParameterDescription>(firstParameter, secondParameter));
         when(firstPseudoAnnotation.getAnnotationType())
-                .thenReturn(new TypeDescription.ForLoadedType(FirstPseudoAnnotation.class));
+                .thenReturn(TypeDescription.ForLoadedType.of(FirstPseudoAnnotation.class));
         when(firstPseudoAnnotation.prepare(FirstPseudoAnnotation.class)).thenReturn(firstPseudoAnnotation);
         when(secondPseudoAnnotation.getAnnotationType())
-                .thenReturn(new TypeDescription.ForLoadedType(SecondPseudoAnnotation.class));
+                .thenReturn(TypeDescription.ForLoadedType.of(SecondPseudoAnnotation.class));
         when(secondPseudoAnnotation.prepare(SecondPseudoAnnotation.class)).thenReturn(secondPseudoAnnotation);
         when(sourceTypeDescription.getStackSize()).thenReturn(StackSize.ZERO);
         when(targetTypeDescription.getStackSize()).thenReturn(StackSize.ZERO);
@@ -156,7 +156,7 @@ public void testConflictingBinderBinding() throws Exception {
     public void testIgnoreForBindingAnnotation() throws Exception {
         when(targetMethod.isAccessibleTo(instrumentedType)).thenReturn(true);
         AnnotationDescription ignoreForBinding = mock(AnnotationDescription.class);
-        when(ignoreForBinding.getAnnotationType()).thenReturn(new TypeDescription.ForLoadedType(IgnoreForBinding.class));
+        when(ignoreForBinding.getAnnotationType()).thenReturn(TypeDescription.ForLoadedType.of(IgnoreForBinding.class));
         when(targetMethod.getDeclaredAnnotations()).thenReturn(new AnnotationList.Explicit(Collections.singletonList(ignoreForBinding)));
         when(termination.isValid()).thenReturn(true);
         MethodDelegationBinder methodDelegationBinder = TargetMethodAnnotationDrivenBinder.of(Collections.<TargetMethodAnnotationDrivenBinder.ParameterBinder<?>>emptyList());

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveBoxingDelegateTest.java
Patch:
@@ -64,7 +64,7 @@ public PrimitiveBoxingDelegateTest(Class<?> primitiveType,
         this.primitiveType = primitiveType;
         primitiveTypeDescription = mock(TypeDescription.class);
         when(primitiveTypeDescription.represents(primitiveType)).thenReturn(true);
-        referenceTypeDescription = new TypeDescription.ForLoadedType(referenceType);
+        referenceTypeDescription = TypeDescription.ForLoadedType.of(referenceType);
         this.boxingMethodDescriptor = boxingMethodDescriptor;
         this.sizeChange = sizeChange;
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveWideningDelegateOtherTest.java
Patch:
@@ -12,6 +12,6 @@ public void testIllegalSourceTypeThrowsException() throws Exception {
 
     @Test(expected = IllegalArgumentException.class)
     public void testIllegalTargetTypeThrowsException() throws Exception {
-        PrimitiveWideningDelegate.forPrimitive(new TypeDescription.ForLoadedType(int.class)).widenTo(TypeDescription.OBJECT);
+        PrimitiveWideningDelegate.forPrimitive(TypeDescription.ForLoadedType.of(int.class)).widenTo(TypeDescription.OBJECT);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/collection/ArrayAccessTest.java
Patch:
@@ -37,7 +37,7 @@ public class ArrayAccessTest {
     private Implementation.Context implementationContext;
 
     public ArrayAccessTest(Class<?> type, int loadOpcode, int storeOpcode) {
-        typeDescription = new TypeDescription.ForLoadedType(type);
+        typeDescription = TypeDescription.ForLoadedType.of(type);
         this.loadOpcode = loadOpcode;
         this.storeOpcode = storeOpcode;
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/ClassConstantPrimitiveTest.java
Patch:
@@ -35,8 +35,8 @@ public class ClassConstantPrimitiveTest {
     private Implementation.Context implementationContext;
 
     public ClassConstantPrimitiveTest(Class<?> primitiveType, Class<?> wrapperType) {
-        this.primitiveType = new TypeDescription.ForLoadedType(primitiveType);
-        this.wrapperType = new TypeDescription.ForLoadedType(wrapperType);
+        this.primitiveType = TypeDescription.ForLoadedType.of(primitiveType);
+        this.wrapperType = TypeDescription.ForLoadedType.of(wrapperType);
     }
 
     @Parameterized.Parameters

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/FieldConstantTest.java
Patch:
@@ -53,7 +53,7 @@ public void setUp() throws Exception {
         when(fieldDescription.getInternalName()).thenReturn(BAR);
         when(fieldDescription.getDeclaringType()).thenReturn(declaringType);
         when(declaringType.getDescriptor()).thenReturn("L" + QUX + ";");
-        when(implementationContext.cache(new FieldConstant(fieldDescription), new TypeDescription.ForLoadedType(Field.class)))
+        when(implementationContext.cache(new FieldConstant(fieldDescription), TypeDescription.ForLoadedType.of(Field.class)))
                 .thenReturn(cacheField);
         when(cacheField.getDeclaringType()).thenReturn(cacheDeclaringType);
         when(cacheField.isStatic()).thenReturn(true);
@@ -143,7 +143,7 @@ public void testCached() throws Exception {
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);
         assertThat(size.getSizeImpact(), is(1));
         assertThat(size.getMaximalSize(), is(1));
-        verify(implementationContext).cache(new FieldConstant(fieldDescription), new TypeDescription.ForLoadedType(Field.class));
+        verify(implementationContext).cache(new FieldConstant(fieldDescription), TypeDescription.ForLoadedType.of(Field.class));
         verifyNoMoreInteractions(implementationContext);
         verify(methodVisitor).visitFieldInsn(Opcodes.GETSTATIC, BAZ, FOO + BAR, QUX + BAZ);
         verifyNoMoreInteractions(methodVisitor);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/MethodConstantTest.java
Patch:
@@ -109,7 +109,7 @@ public void testMethodCached() throws Exception {
         assertThat(size.getMaximalSize(), is(1));
         verify(methodVisitor).visitFieldInsn(Opcodes.GETSTATIC, BAZ, FOO, QUX);
         verifyNoMoreInteractions(methodVisitor);
-        verify(implementationContext).cache(MethodConstant.forMethod(methodDescription), new TypeDescription.ForLoadedType(Method.class));
+        verify(implementationContext).cache(MethodConstant.forMethod(methodDescription), TypeDescription.ForLoadedType.of(Method.class));
         verifyNoMoreInteractions(implementationContext);
     }
 
@@ -135,7 +135,7 @@ public void testConstructorCached() throws Exception {
         assertThat(size.getMaximalSize(), is(1));
         verify(methodVisitor).visitFieldInsn(Opcodes.GETSTATIC, BAZ, FOO, QUX);
         verifyNoMoreInteractions(methodVisitor);
-        verify(implementationContext).cache(MethodConstant.forMethod(methodDescription), new TypeDescription.ForLoadedType(Constructor.class));
+        verify(implementationContext).cache(MethodConstant.forMethod(methodDescription), TypeDescription.ForLoadedType.of(Constructor.class));
         verifyNoMoreInteractions(implementationContext);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/InstanceTypeMatcherTest.java
Patch:
@@ -23,13 +23,13 @@ public InstanceTypeMatcherTest() {
 
     @Test
     public void testMatch() throws Exception {
-        when(matcher.matches(new TypeDescription.ForLoadedType(object.getClass()))).thenReturn(true);
+        when(matcher.matches(TypeDescription.ForLoadedType.of(object.getClass()))).thenReturn(true);
         assertThat(new InstanceTypeMatcher<Object>(matcher).matches(object), is(true));
     }
 
     @Test
     public void testNoMatch() throws Exception {
-        when(matcher.matches(new TypeDescription.ForLoadedType(object.getClass()))).thenReturn(false);
+        when(matcher.matches(TypeDescription.ForLoadedType.of(object.getClass()))).thenReturn(false);
         assertThat(new InstanceTypeMatcher<Object>(matcher).matches(object), is(false));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolClassLoadingTest.java
Patch:
@@ -40,14 +40,14 @@ public void testLoadableBootstrapLoaderClass() throws Exception {
     public void testArrayClass() throws Exception {
         TypePool.Resolution resolution = typePool.describe(Object[].class.getName());
         assertThat(resolution.isResolved(), is(true));
-        assertThat(resolution.resolve(), is((TypeDescription) new TypeDescription.ForLoadedType(Object[].class)));
+        assertThat(resolution.resolve(), is((TypeDescription) TypeDescription.ForLoadedType.of(Object[].class)));
     }
 
     @Test
     public void testPrimitiveClass() throws Exception {
         TypePool.Resolution resolution = typePool.describe(int.class.getName());
         assertThat(resolution.isResolved(), is(true));
-        assertThat(resolution.resolve(), is((TypeDescription) new TypeDescription.ForLoadedType(int.class)));
+        assertThat(resolution.resolve(), is((TypeDescription) TypeDescription.ForLoadedType.of(int.class)));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultHierarchyTest.java
Patch:
@@ -62,7 +62,7 @@ public TypePool.Resolution answer(InvocationOnMock invocationOnMock) throws Thro
         });
         TypePool.Resolution resolution = typePool.describe(FOO);
         assertThat(resolution.isResolved(), is(true));
-        assertThat(resolution.resolve(), is((TypeDescription) new TypeDescription.ForLoadedType(Foo.class)));
+        assertThat(resolution.resolve(), is((TypeDescription) TypeDescription.ForLoadedType.of(Foo.class)));
         verify(cacheProvider).find(FOO);
         verify(cacheProvider).register(FOO, resolution);
         verifyZeroInteractions(cacheProvider);

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultLazyTypeListTest.java
Patch:
@@ -41,6 +41,6 @@ protected TypeList asList(List<Class<?>> elements) {
 
     @Override
     protected TypeDescription asElement(Class<?> element) {
-        return new TypeDescription.ForLoadedType(element);
+        return TypeDescription.ForLoadedType.of(element);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/ClassFileExtraction.java
Patch:
@@ -38,7 +38,7 @@ public static Map<String, byte[]> of(Class<?>... type) throws IOException {
     public static byte[] extract(Class<?> type, AsmVisitorWrapper asmVisitorWrapper) throws IOException {
         ClassReader classReader = new ClassReader(type.getName());
         ClassWriter classWriter = new ClassWriter(classReader, AsmVisitorWrapper.NO_FLAGS);
-        classReader.accept(asmVisitorWrapper.wrap(new TypeDescription.ForLoadedType(type),
+        classReader.accept(asmVisitorWrapper.wrap(TypeDescription.ForLoadedType.of(type),
                 classWriter,
                 new IllegalContext(),
                 TypePool.Empty.INSTANCE,

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaConstantMethodTypeTest.java
Patch:
@@ -58,14 +58,14 @@ public void testMethodTypeOfConstructor() throws Exception {
     @SuppressWarnings("unchecked")
     public void testMethodTypeOfGetter() throws Exception {
         JavaConstant.MethodType methodType = JavaConstant.MethodType.ofGetter(Foo.class.getDeclaredField(BAR));
-        assertThat(methodType.getReturnType(), is((TypeDescription) new TypeDescription.ForLoadedType(Void.class)));
+        assertThat(methodType.getReturnType(), is((TypeDescription) TypeDescription.ForLoadedType.of(Void.class)));
         assertThat(methodType.getParameterTypes(), is(Collections.<TypeDescription>emptyList()));
     }
 
     @Test
     public void testMethodTypeOfStaticGetter() throws Exception {
         JavaConstant.MethodType methodType = JavaConstant.MethodType.ofGetter(Foo.class.getDeclaredField(QUX));
-        assertThat(methodType.getReturnType(), is((TypeDescription) new TypeDescription.ForLoadedType(Void.class)));
+        assertThat(methodType.getReturnType(), is((TypeDescription) TypeDescription.ForLoadedType.of(Void.class)));
         assertThat(methodType.getParameterTypes(), is(Collections.<TypeDescription>emptyList()));
     }
 
@@ -88,7 +88,7 @@ public void testMethodTypeOfStaticSetter() throws Exception {
     @Test
     public void testMethodTypeOfConstant() throws Exception {
         JavaConstant.MethodType methodType = JavaConstant.MethodType.ofConstant(new Foo(null));
-        assertThat(methodType.getReturnType(), is((TypeDescription) new TypeDescription.ForLoadedType(Foo.class)));
+        assertThat(methodType.getReturnType(), is((TypeDescription) TypeDescription.ForLoadedType.of(Foo.class)));
         assertThat(methodType.getParameterTypes(), is(Collections.<TypeDescription>emptyList()));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaTypeTest.java
Patch:
@@ -76,7 +76,7 @@ public void testParameter() throws Exception {
     public void testExecutable() throws Exception {
         assertThat(JavaType.EXECUTABLE.getTypeStub().getName(), is("java.lang.reflect.Executable"));
         assertThat(JavaType.EXECUTABLE.getTypeStub().getModifiers(), is(Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT));
-        assertThat(JavaType.EXECUTABLE.getTypeStub().getSuperClass(), is((TypeDefinition) new TypeDescription.ForLoadedType(AccessibleObject.class)));
+        assertThat(JavaType.EXECUTABLE.getTypeStub().getSuperClass(), is((TypeDefinition) TypeDescription.ForLoadedType.of(AccessibleObject.class)));
         assertThat(JavaType.EXECUTABLE.getTypeStub().getInterfaces().size(), is(2));
         assertThat(JavaType.EXECUTABLE.getTypeStub().getInterfaces().contains(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Member.class)), is(true));
         assertThat(JavaType.EXECUTABLE.getTypeStub().getInterfaces().contains(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(GenericDeclaration.class)), is(true));

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -234,7 +234,7 @@ public static ClassFileVersion of(Class<?> type) throws IOException {
      * @throws IOException If an error occurs while reading the class file.
      */
     public static ClassFileVersion of(Class<?> type, ClassFileLocator classFileLocator) throws IOException {
-        return of(new TypeDescription.ForLoadedType(type), classFileLocator);
+        return of(TypeDescription.ForLoadedType.of(type), classFileLocator);
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/LambdaFactory.java
Patch:
@@ -74,7 +74,7 @@ public LambdaFactory(Object target, Method dispatcher) {
     @SuppressWarnings("all")
     public static boolean register(ClassFileTransformer classFileTransformer, Object classFileFactory) {
         try {
-            TypeDescription typeDescription = new TypeDescription.ForLoadedType(LambdaFactory.class);
+            TypeDescription typeDescription = TypeDescription.ForLoadedType.of(LambdaFactory.class);
             Class<?> lambdaFactory = ClassInjector.UsingReflection.ofSystemClassLoader()
                     .inject(Collections.singletonMap(typeDescription, ClassFileLocator.ForClassLoader.read(LambdaFactory.class).resolve()))
                     .get(typeDescription);

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationValue.java
Patch:
@@ -1683,7 +1683,7 @@ public int hashCode() {
 
             @Override
             public String toString() {
-                return RenderingDispatcher.CURRENT.toSourceString(new TypeDescription.ForLoadedType(type));
+                return RenderingDispatcher.CURRENT.toSourceString(TypeDescription.ForLoadedType.of(type));
             }
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/enumeration/EnumerationDescription.java
Patch:
@@ -107,7 +107,7 @@ public String getValue() {
 
         @Override
         public TypeDescription getEnumerationType() {
-            return new TypeDescription.ForLoadedType(value.getDeclaringClass());
+            return TypeDescription.ForLoadedType.of(value.getDeclaringClass());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -844,7 +844,7 @@ public ForLoadedConstructor(Constructor<?> constructor) {
 
         @Override
         public TypeDescription getDeclaringType() {
-            return new TypeDescription.ForLoadedType(constructor.getDeclaringClass());
+            return TypeDescription.ForLoadedType.of(constructor.getDeclaringClass());
         }
 
         @Override
@@ -952,7 +952,7 @@ public ForLoadedMethod(Method method) {
 
         @Override
         public TypeDescription getDeclaringType() {
-            return new TypeDescription.ForLoadedType(method.getDeclaringClass());
+            return TypeDescription.ForLoadedType.of(method.getDeclaringClass());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/NexusAccessor.java
Patch:
@@ -130,7 +130,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                         ArrayFactory.forType(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Class.class))
                                 .withValues(Arrays.asList(
                                         ClassConstant.of(TypeDescription.CLASS),
-                                        ClassConstant.of(new TypeDescription.ForLoadedType(int.class)))),
+                                        ClassConstant.of(TypeDescription.ForLoadedType.of(int.class)))),
                         MethodInvocation.invoke(new MethodDescription.ForLoadedMethod(Class.class.getMethod("getMethod", String.class, Class[].class))),
                         NullConstant.INSTANCE,
                         ArrayFactory.forType(TypeDescription.Generic.OBJECT)
@@ -200,8 +200,8 @@ public Dispatcher run() {
                 } else {
                     try {
                         Class<?> nexusType = new ClassInjector.UsingReflection(ClassLoader.getSystemClassLoader(), ClassLoadingStrategy.NO_PROTECTION_DOMAIN)
-                                .inject(Collections.singletonMap(new TypeDescription.ForLoadedType(Nexus.class), ClassFileLocator.ForClassLoader.read(Nexus.class).resolve()))
-                                .get(new TypeDescription.ForLoadedType(Nexus.class));
+                                .inject(Collections.singletonMap(TypeDescription.ForLoadedType.of(Nexus.class), ClassFileLocator.ForClassLoader.read(Nexus.class).resolve()))
+                                .get(TypeDescription.ForLoadedType.of(Nexus.class));
                         return new Dispatcher.Available(nexusType.getMethod("register", String.class, ClassLoader.class, ReferenceQueue.class, int.class, Object.class),
                                 nexusType.getMethod("clean", Reference.class));
                     } catch (Exception exception) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/TargetType.java
Patch:
@@ -11,7 +11,7 @@ public final class TargetType {
     /**
      * A description of the {@link net.bytebuddy.dynamic.TargetType}.
      */
-    public static final TypeDescription DESCRIPTION = new TypeDescription.ForLoadedType(TargetType.class);
+    public static final TypeDescription DESCRIPTION = TypeDescription.ForLoadedType.of(TargetType.class);
 
     /**
      * Resolves the given type description to the supplied target type if it represents the {@link TargetType} placeholder.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -987,7 +987,7 @@ public UsingLookup in(Class<?> type) {
         public Map<TypeDescription, Class<?>> inject(Map<? extends TypeDescription, byte[]> types) {
             Map<TypeDescription, Class<?>> loaded = new HashMap<TypeDescription, Class<?>>();
             for (Map.Entry<? extends TypeDescription, byte[]> entry : types.entrySet()) {
-                if (!entry.getKey().isSamePackage(new TypeDescription.ForLoadedType(lookupType()))) {
+                if (!entry.getKey().isSamePackage(TypeDescription.ForLoadedType.of(lookupType()))) {
                     throw new IllegalArgumentException(entry.getKey() + " must be defined in the same package as " + lookup);
                 }
                 loaded.put(entry.getKey(), DISPATCHER.defineClass(lookup, entry.getValue()));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/EqualsMethod.java
Patch:
@@ -244,7 +244,7 @@ protected StackManipulation resolve(TypeDescription instrumentedType) {
         /**
          * The {@link Object#getClass()} method.
          */
-        protected static final MethodDescription.InDefinedShape GET_CLASS = new TypeDescription.ForLoadedType(Object.class)
+        protected static final MethodDescription.InDefinedShape GET_CLASS = TypeDescription.ForLoadedType.of(Object.class)
                 .getDeclaredMethods()
                 .filter(named("getClass"))
                 .getOnly();

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/ExceptionMethod.java
Patch:
@@ -44,7 +44,7 @@ public ExceptionMethod(ConstructionDelegate constructionDelegate) {
      * instrumented methods.
      */
     public static Implementation throwing(Class<? extends Throwable> exceptionType) {
-        return throwing(new TypeDescription.ForLoadedType(exceptionType));
+        return throwing(TypeDescription.ForLoadedType.of(exceptionType));
     }
 
     /**
@@ -74,7 +74,7 @@ public static Implementation throwing(TypeDescription exceptionType) {
      * instrumented methods.
      */
     public static Implementation throwing(Class<? extends Throwable> exceptionType, String message) {
-        return throwing(new TypeDescription.ForLoadedType(exceptionType), message);
+        return throwing(TypeDescription.ForLoadedType.of(exceptionType), message);
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -76,7 +76,7 @@ public static AssignerConfigurable value(Object fixedValue) {
         if (type == String.class) {
             return new ForPoolValue(new TextConstant((String) fixedValue), TypeDescription.STRING);
         } else if (type == Class.class) {
-            return new ForPoolValue(ClassConstant.of(new TypeDescription.ForLoadedType((Class<?>) fixedValue)), TypeDescription.CLASS);
+            return new ForPoolValue(ClassConstant.of(TypeDescription.ForLoadedType.of((Class<?>) fixedValue)), TypeDescription.CLASS);
         } else if (type == Boolean.class) {
             return new ForPoolValue(IntegerConstant.forValue((Boolean) fixedValue), boolean.class);
         } else if (type == Byte.class) {
@@ -497,7 +497,7 @@ protected static class ForPoolValue extends FixedValue implements AssignerConfig
          * @param loadedType           A type description representing the loaded type.
          */
         protected ForPoolValue(StackManipulation valueLoadInstruction, Class<?> loadedType) {
-            this(valueLoadInstruction, new TypeDescription.ForLoadedType(loadedType));
+            this(valueLoadInstruction, TypeDescription.ForLoadedType.of(loadedType));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/HashCodeMethod.java
Patch:
@@ -44,7 +44,7 @@ public class HashCodeMethod implements Implementation {
     /**
      * The {@link Object#hashCode()} method.
      */
-    private static final MethodDescription.InDefinedShape HASH_CODE = new TypeDescription.ForLoadedType(Object.class)
+    private static final MethodDescription.InDefinedShape HASH_CODE = TypeDescription.ForLoadedType.of(Object.class)
             .getDeclaredMethods()
             .filter(isHashCode())
             .getOnly();

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -1373,7 +1373,7 @@ public static ArgumentLoader.Factory of(Object value) {
                 } else if (value instanceof Double) {
                     return new ForStackManipulation(DoubleConstant.forValue((Double) value), double.class);
                 } else if (value instanceof Class) {
-                    return new ForStackManipulation(ClassConstant.of(new TypeDescription.ForLoadedType((Class<?>) value)), Class.class);
+                    return new ForStackManipulation(ClassConstant.of(TypeDescription.ForLoadedType.of((Class<?>) value)), Class.class);
                 } else if (JavaType.METHOD_HANDLE.getTypeStub().isInstance(value)) {
                     return new ForStackManipulation(JavaConstant.MethodHandle.ofLoaded(value).asStackManipulation(), JavaType.METHOD_HANDLE.getTypeStub());
                 } else if (JavaType.METHOD_TYPE.getTypeStub().isInstance(value)) {
@@ -1717,7 +1717,7 @@ protected ForVirtualInvocation(TypeDescription typeDescription) {
              * @param type The type to virtually invoke the method upon.
              */
             protected ForVirtualInvocation(Class<?> type) {
-                this(new TypeDescription.ForLoadedType(type));
+                this(TypeDescription.ForLoadedType.of(type));
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -1191,7 +1191,7 @@ public WithCustomProperties filter(ElementMatcher<? super MethodDescription> mat
          * @return A method delegation that redirects method calls to a static method of the supplied type.
          */
         public MethodDelegation to(Class<?> type) {
-            return to(new TypeDescription.ForLoadedType(type));
+            return to(TypeDescription.ForLoadedType.of(type));
         }
 
         /**
@@ -1361,7 +1361,7 @@ public MethodDelegation to(Object target, Type type, String fieldName, MethodGra
          * @return A delegation that redirects method calls to a constructor of the supplied type.
          */
         public MethodDelegation toConstructor(Class<?> type) {
-            return toConstructor(new TypeDescription.ForLoadedType(type));
+            return toConstructor(TypeDescription.ForLoadedType.of(type));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/ToStringMethod.java
Patch:
@@ -33,15 +33,15 @@ public class ToStringMethod implements Implementation {
     /**
      * The {@link StringBuilder#StringBuilder(String)} constructor.
      */
-    private static final MethodDescription.InDefinedShape STRING_BUILDER_CONSTRUCTOR = new TypeDescription.ForLoadedType(StringBuilder.class)
+    private static final MethodDescription.InDefinedShape STRING_BUILDER_CONSTRUCTOR = TypeDescription.ForLoadedType.of(StringBuilder.class)
             .getDeclaredMethods()
             .filter(isConstructor().and(ElementMatchers.takesArguments(String.class)))
             .getOnly();
 
     /**
      * The {@link StringBuilder#toString()} method.
      */
-    private static final MethodDescription.InDefinedShape TO_STRING = new TypeDescription.ForLoadedType(StringBuilder.class)
+    private static final MethodDescription.InDefinedShape TO_STRING = TypeDescription.ForLoadedType.of(StringBuilder.class)
             .getDeclaredMethods()
             .filter(isToString())
             .getOnly();
@@ -276,7 +276,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                 throw new IllegalStateException("toString method does not return String-compatible type: " + instrumentedMethod);
             }
             List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(Math.max(0, fieldDescriptions.size() * 7 - 2) + 10);
-            stackManipulations.add(TypeCreation.of(new TypeDescription.ForLoadedType(StringBuilder.class)));
+            stackManipulations.add(TypeCreation.of(TypeDescription.ForLoadedType.of(StringBuilder.class)));
             stackManipulations.add(Duplication.SINGLE);
             stackManipulations.add(new TextConstant(prefix));
             stackManipulations.add(MethodInvocation.invoke(STRING_BUILDER_CONSTRUCTOR));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -171,7 +171,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
         @SuppressFBWarnings(value = "SE_BAD_FIELD_STORE", justification = "Precomputed method graph is not intended for serialization")
         PrecomputedMethodGraph() {
             LinkedHashMap<MethodDescription.SignatureToken, MethodGraph.Node> nodes = new LinkedHashMap<MethodDescription.SignatureToken, MethodGraph.Node>();
-            MethodDescription callMethod = new MethodDescription.Latent(new TypeDescription.ForLoadedType(Callable.class),
+            MethodDescription callMethod = new MethodDescription.Latent(TypeDescription.ForLoadedType.of(Callable.class),
                     "call",
                     Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
                     Collections.<TypeVariableToken>emptyList(),
@@ -182,7 +182,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
                     AnnotationValue.UNDEFINED,
                     TypeDescription.Generic.UNDEFINED);
             nodes.put(callMethod.asSignatureToken(), new MethodGraph.Node.Simple(callMethod));
-            MethodDescription runMethod = new MethodDescription.Latent(new TypeDescription.ForLoadedType(Runnable.class),
+            MethodDescription runMethod = new MethodDescription.Latent(TypeDescription.ForLoadedType.of(Runnable.class),
                     "run",
                     Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
                     Collections.<TypeVariableToken>emptyList(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TypeProxy.java
Patch:
@@ -128,7 +128,7 @@ protected enum AbstractMethodErrorThrow implements StackManipulation {
          */
         @SuppressFBWarnings(value = "SE_BAD_FIELD_STORE", justification = "Fields of enumerations are never serialized")
         AbstractMethodErrorThrow() {
-            TypeDescription abstractMethodError = new TypeDescription.ForLoadedType(AbstractMethodError.class);
+            TypeDescription abstractMethodError = TypeDescription.ForLoadedType.of(AbstractMethodError.class);
             MethodDescription constructor = abstractMethodError.getDeclaredMethods()
                     .filter(isConstructor().and(takesArguments(0))).getOnly();
             implementation = new Compound(TypeCreation.of(abstractMethodError),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Default.java
Patch:
@@ -71,7 +71,7 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<Defaul
          * Extracts method references of the default annotation.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> annotationProperties = new TypeDescription.ForLoadedType(Default.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> annotationProperties = TypeDescription.ForLoadedType.of(Default.class).getDeclaredMethods();
             SERIALIZABLE_PROXY = annotationProperties.filter(named("serializableProxy")).getOnly();
             PROXY_TYPE = annotationProperties.filter(named("proxyType")).getOnly();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultCall.java
Patch:
@@ -94,7 +94,7 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<Defaul
          * Looks up method constants of the default call annotation.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> annotationProperties = new TypeDescription.ForLoadedType(DefaultCall.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> annotationProperties = TypeDescription.ForLoadedType.of(DefaultCall.class).getDeclaredMethods();
             TARGET_TYPE = annotationProperties.filter(named("targetType")).getOnly();
             SERIALIZABLE_PROXY = annotationProperties.filter(named("serializableProxy")).getOnly();
             NULL_IF_IMPOSSIBLE = annotationProperties.filter(named("nullIfImpossible")).getOnly();

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultMethod.java
Patch:
@@ -86,7 +86,7 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<Defaul
          * Locates method constants for properties of the default method annotation.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> methodList = new TypeDescription.ForLoadedType(DefaultMethod.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> methodList = TypeDescription.ForLoadedType.of(DefaultMethod.class).getDeclaredMethods();
             CACHED = methodList.filter(named("cached")).getOnly();
             TARGET_TYPE = methodList.filter(named("targetType")).getOnly();
             NULL_IF_IMPOSSIBLE = methodList.filter(named("nullIfImpossible")).getOnly();
@@ -222,7 +222,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                 StackManipulation stackManipulation = MethodConstant.forMethod(implementationContext.registerAccessorFor(specialMethodInvocation,
                         MethodAccessorFactory.AccessType.PUBLIC));
                 return (cached
-                        ? FieldAccess.forField(implementationContext.cache(stackManipulation, new TypeDescription.ForLoadedType(Method.class))).read()
+                        ? FieldAccess.forField(implementationContext.cache(stackManipulation, TypeDescription.ForLoadedType.of(Method.class))).read()
                         : stackManipulation).apply(methodVisitor, implementationContext);
             }
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -99,7 +99,7 @@ class Binder extends TargetMethodAnnotationDrivenBinder.ParameterBinder.ForField
          * Fetches a reference to all annotation properties.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> methodList = new TypeDescription.ForLoadedType(FieldProxy.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> methodList = TypeDescription.ForLoadedType.of(FieldProxy.class).getDeclaredMethods();
             DECLARING_TYPE = methodList.filter(named("declaringType")).getOnly();
             FIELD_NAME = methodList.filter(named("value")).getOnly();
             SERIALIZABLE_PROXY = methodList.filter(named("serializableProxy")).getOnly();
@@ -114,7 +114,7 @@ class Binder extends TargetMethodAnnotationDrivenBinder.ParameterBinder.ForField
          * @return A binder for the {@link FieldProxy} annotation.
          */
         public static TargetMethodAnnotationDrivenBinder.ParameterBinder<FieldProxy> install(Class<?> type) {
-            return install(new TypeDescription.ForLoadedType(type));
+            return install(TypeDescription.ForLoadedType.of(type));
         }
 
         /**
@@ -164,7 +164,7 @@ public static TargetMethodAnnotationDrivenBinder.ParameterBinder<FieldProxy> ins
          * @return A binder for the {@link FieldProxy} annotation.
          */
         public static TargetMethodAnnotationDrivenBinder.ParameterBinder<FieldProxy> install(Class<?> getterType, Class<?> setterType) {
-            return install(new TypeDescription.ForLoadedType(getterType), new TypeDescription.ForLoadedType(setterType));
+            return install(TypeDescription.ForLoadedType.of(getterType), TypeDescription.ForLoadedType.of(setterType));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldValue.java
Patch:
@@ -78,7 +78,7 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<FieldV
          * Initializes the methods of the annotation that is read by this binder.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> methodList = new TypeDescription.ForLoadedType(FieldValue.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> methodList = TypeDescription.ForLoadedType.of(FieldValue.class).getDeclaredMethods();
             DECLARING_TYPE = methodList.filter(named("declaringType")).getOnly();
             FIELD_NAME = methodList.filter(named("value")).getOnly();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -103,7 +103,7 @@ class Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<Morph
          * Looks up references for all annotation properties of the morph annotation.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> methodList = new TypeDescription.ForLoadedType(Morph.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> methodList = TypeDescription.ForLoadedType.of(Morph.class).getDeclaredMethods();
             SERIALIZABLE_PROXY = methodList.filter(named("serializableProxy")).getOnly();
             DEFAULT_METHOD = methodList.filter(named("defaultMethod")).getOnly();
             DEFAULT_TARGET = methodList.filter(named("defaultTarget")).getOnly();
@@ -134,7 +134,7 @@ protected Binder(MethodDescription forwardingMethod) {
          * annotation.
          */
         public static TargetMethodAnnotationDrivenBinder.ParameterBinder<Morph> install(Class<?> type) {
-            return install(new TypeDescription.ForLoadedType(type));
+            return install(TypeDescription.ForLoadedType.of(type));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -108,7 +108,7 @@ protected Binder(MethodDescription forwardingMethod) {
          * annotation.
          */
         public static TargetMethodAnnotationDrivenBinder.ParameterBinder<Pipe> install(Class<?> type) {
-            return install(new TypeDescription.ForLoadedType(type));
+            return install(TypeDescription.ForLoadedType.of(type));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Super.java
Patch:
@@ -156,7 +156,7 @@ protected StackManipulation proxyFor(TypeDescription parameterType,
          * Extracts method references to the annotation methods.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> annotationProperties = new TypeDescription.ForLoadedType(Super.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> annotationProperties = TypeDescription.ForLoadedType.of(Super.class).getDeclaredMethods();
             IGNORE_FINALIZER = annotationProperties.filter(named("ignoreFinalizer")).getOnly();
             SERIALIZABLE_PROXY = annotationProperties.filter(named("serializableProxy")).getOnly();
             CONSTRUCTOR_PARAMETERS = annotationProperties.filter(named("constructorParameters")).getOnly();
@@ -204,7 +204,7 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<Super>
          * Extracts method references of the super annotation.
          */
         static {
-            MethodList<MethodDescription.InDefinedShape> annotationProperties = new TypeDescription.ForLoadedType(Super.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> annotationProperties = TypeDescription.ForLoadedType.of(Super.class).getDeclaredMethods();
             STRATEGY = annotationProperties.filter(named("strategy")).getOnly();
             PROXY_TYPE = annotationProperties.filter(named("proxyType")).getOnly();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperMethod.java
Patch:
@@ -132,7 +132,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                 StackManipulation stackManipulation = MethodConstant.forMethod(implementationContext.registerAccessorFor(specialMethodInvocation,
                         MethodAccessorFactory.AccessType.PUBLIC));
                 return (cached
-                        ? FieldAccess.forField(implementationContext.cache(stackManipulation, new TypeDescription.ForLoadedType(Method.class))).read()
+                        ? FieldAccess.forField(implementationContext.cache(stackManipulation, TypeDescription.ForLoadedType.of(Method.class))).read()
                         : stackManipulation).apply(methodVisitor, implementationContext);
             }
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/FieldConstant.java
Patch:
@@ -99,7 +99,7 @@ public boolean isValid() {
 
         @Override
         public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
-            return FieldAccess.forField(implementationContext.cache(fieldConstant, new TypeDescription.ForLoadedType(Field.class)))
+            return FieldAccess.forField(implementationContext.cache(fieldConstant, TypeDescription.ForLoadedType.of(Field.class)))
                     .read()
                     .apply(methodVisitor, implementationContext);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodConstant.java
Patch:
@@ -236,7 +236,7 @@ protected static class CachedMethod implements StackManipulation {
         /**
          * A description of the {@link java.lang.reflect.Method} type.
          */
-        private static final TypeDescription METHOD_TYPE = new TypeDescription.ForLoadedType(Method.class);
+        private static final TypeDescription METHOD_TYPE = TypeDescription.ForLoadedType.of(Method.class);
 
         /**
          * The stack manipulation that is represented by this caching wrapper.
@@ -290,7 +290,7 @@ protected static class CachedConstructor implements StackManipulation {
         /**
          * A description of the {@link java.lang.reflect.Constructor} type.
          */
-        private static final TypeDescription CONSTRUCTOR_TYPE = new TypeDescription.ForLoadedType(Constructor.class);
+        private static final TypeDescription CONSTRUCTOR_TYPE = TypeDescription.ForLoadedType.of(Constructor.class);
 
         /**
          * The stack manipulation that is represented by this caching wrapper.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/SerializedConstant.java
Patch:
@@ -70,9 +70,9 @@ public boolean isValid() {
     public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
         try {
             return new StackManipulation.Compound(
-                    TypeCreation.of(new TypeDescription.ForLoadedType(ObjectInputStream.class)),
+                    TypeCreation.of(TypeDescription.ForLoadedType.of(ObjectInputStream.class)),
                     Duplication.SINGLE,
-                    TypeCreation.of(new TypeDescription.ForLoadedType(ByteArrayInputStream.class)),
+                    TypeCreation.of(TypeDescription.ForLoadedType.of(ByteArrayInputStream.class)),
                     Duplication.SINGLE,
                     new TextConstant(serialization),
                     new TextConstant(CHARSET),

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/InstanceTypeMatcher.java
Patch:
@@ -27,7 +27,7 @@ public InstanceTypeMatcher(ElementMatcher<? super TypeDescription> matcher) {
 
     @Override
     public boolean matches(T target) {
-        return target != null && matcher.matches(new TypeDescription.ForLoadedType(target.getClass()));
+        return target != null && matcher.matches(TypeDescription.ForLoadedType.of(target.getClass()));
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -747,7 +747,7 @@ public int hashCode() {
 
                 @Override
                 public String toString() {
-                    return RenderingDispatcher.CURRENT.toSourceString(new TypeDescription.ForLoadedType(type));
+                    return RenderingDispatcher.CURRENT.toSourceString(TypeDescription.ForLoadedType.of(type));
                 }
             }
         }
@@ -5652,7 +5652,7 @@ private static class Loadable<S extends Annotation> extends LazyAnnotationDescri
                      * @param values         A map of annotation value names to their value representations.
                      */
                     private Loadable(TypePool typePool, Class<S> annotationType, Map<String, AnnotationValue<?, ?>> values) {
-                        super(typePool, new ForLoadedType(annotationType), values);
+                        super(typePool, ForLoadedType.of(annotationType), values);
                         this.annotationType = annotationType;
                     }
 
@@ -7659,7 +7659,7 @@ public static TypePool ofClassPath() {
         @Override
         public Resolution doDescribe(String name) {
             try {
-                return new Resolution.Simple(new TypeDescription.ForLoadedType(Class.forName(name, false, classLoader)));
+                return new Resolution.Simple(TypeDescription.ForLoadedType.of(Class.forName(name, false, classLoader)));
             } catch (ClassNotFoundException ignored) {
                 return new Resolution.Illegal(name);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaType.java
Patch:
@@ -71,7 +71,7 @@ public enum JavaType {
     JavaType(String typeName, int modifiers, Class<?> superClass, Class<?>... interfaces) {
         TypeDescription typeDescription;
         try {
-            typeDescription = new TypeDescription.ForLoadedType(Class.forName(typeName));
+            typeDescription = TypeDescription.ForLoadedType.of(Class.forName(typeName));
         } catch (Exception ignored) {
             typeDescription = new TypeDescription.Latent(typeName,
                     modifiers,

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/RawMatcherForResolvableTypesTest.java
Patch:
@@ -11,7 +11,7 @@ public class RawMatcherForResolvableTypesTest {
 
     @Test
     public void testUnloadedMatches() throws Exception {
-        assertThat(AgentBuilder.RawMatcher.ForResolvableTypes.INSTANCE.matches(new TypeDescription.ForLoadedType(Foo.class),
+        assertThat(AgentBuilder.RawMatcher.ForResolvableTypes.INSTANCE.matches(TypeDescription.ForLoadedType.of(Foo.class),
                 Foo.class.getClassLoader(),
                 JavaModule.ofType(Foo.class),
                 null,
@@ -20,7 +20,7 @@ public void testUnloadedMatches() throws Exception {
 
     @Test
     public void testResolvableMatches() throws Exception {
-        assertThat(AgentBuilder.RawMatcher.ForResolvableTypes.INSTANCE.matches(new TypeDescription.ForLoadedType(Foo.class),
+        assertThat(AgentBuilder.RawMatcher.ForResolvableTypes.INSTANCE.matches(TypeDescription.ForLoadedType.of(Foo.class),
                 Foo.class.getClassLoader(),
                 JavaModule.ofType(Foo.class),
                 Foo.class,
@@ -29,7 +29,7 @@ public void testResolvableMatches() throws Exception {
 
     @Test
     public void testUnresolvableDoesNotMatch() throws Exception {
-        assertThat(AgentBuilder.RawMatcher.ForResolvableTypes.INSTANCE.matches(new TypeDescription.ForLoadedType(Bar.class),
+        assertThat(AgentBuilder.RawMatcher.ForResolvableTypes.INSTANCE.matches(TypeDescription.ForLoadedType.of(Bar.class),
                 Bar.class.getClassLoader(),
                 JavaModule.ofType(Bar.class),
                 Bar.class,

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -1855,7 +1855,7 @@ public void testInvisibleDelegationAdvice() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testNonResolvedAdvice() throws Exception {
-        Advice.to(new TypeDescription.ForLoadedType(TrivialAdvice.class));
+        Advice.to(TypeDescription.ForLoadedType.of(TrivialAdvice.class));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AnnotationListEmptyTest.java
Patch:
@@ -20,7 +20,7 @@ public void testAnnotationIsPresent() throws Exception {
 
     @Test
     public void testAnnotationIsPresentDescription() throws Exception {
-        assertThat(new AnnotationList.Empty().isAnnotationPresent(new TypeDescription.ForLoadedType(Annotation.class)), is(false));
+        assertThat(new AnnotationList.Empty().isAnnotationPresent(TypeDescription.ForLoadedType.of(Annotation.class)), is(false));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/enumeration/EnumerationDescriptionLatentTest.java
Patch:
@@ -9,6 +9,6 @@ public class EnumerationDescriptionLatentTest extends AbstractEnumerationDescrip
     protected EnumerationDescription describe(Enum<?> enumeration,
                                               Class<?> carrierType,
                                               MethodDescription.InDefinedShape annotationMethod) {
-        return new EnumerationDescription.Latent(new TypeDescription.ForLoadedType(enumeration.getDeclaringClass()), enumeration.name());
+        return new EnumerationDescription.Latent(TypeDescription.ForLoadedType.of(enumeration.getDeclaringClass()), enumeration.name());
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/FieldDescriptionLatentTest.java
Patch:
@@ -10,7 +10,7 @@ public class FieldDescriptionLatentTest extends AbstractFieldDescriptionTest {
 
     @Override
     protected FieldDescription.InDefinedShape describe(Field field) {
-        return new FieldDescription.Latent(new TypeDescription.ForLoadedType(field.getDeclaringClass()),
+        return new FieldDescription.Latent(TypeDescription.ForLoadedType.of(field.getDeclaringClass()),
                 field.getName(),
                 field.getModifiers(),
                 TypeDefinition.Sort.describe(field.getGenericType()),

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTest.java
Patch:
@@ -17,13 +17,13 @@ public class MethodDescriptionLatentTest extends AbstractMethodDescriptionTest {
 
     @Override
     protected MethodDescription.InDefinedShape describe(Method method) {
-        return new MethodDescription.Latent(new TypeDescription.ForLoadedType(method.getDeclaringClass()),
+        return new MethodDescription.Latent(TypeDescription.ForLoadedType.of(method.getDeclaringClass()),
                 new MethodDescription.ForLoadedMethod(method).asToken(ElementMatchers.is(method.getDeclaringClass())));
     }
 
     @Override
     protected MethodDescription.InDefinedShape describe(Constructor<?> constructor) {
-        return new MethodDescription.Latent(new TypeDescription.ForLoadedType(constructor.getDeclaringClass()),
+        return new MethodDescription.Latent(TypeDescription.ForLoadedType.of(constructor.getDeclaringClass()),
                 new MethodDescription.ForLoadedConstructor(constructor).asToken(ElementMatchers.is(constructor.getDeclaringClass())));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractPackageDescriptionTest.java
Patch:
@@ -27,8 +27,8 @@ public void testNonTrivialPackage() throws Exception {
 
     @Test
     public void testPackageContains() throws Exception {
-        assertThat(describe(Child.class).contains(new TypeDescription.ForLoadedType(Child.class)), is(true));
-        assertThat(describe(Object.class).contains(new TypeDescription.ForLoadedType(Child.class)), is(false));
+        assertThat(describe(Child.class).contains(TypeDescription.ForLoadedType.of(Child.class)), is(true));
+        assertThat(describe(Object.class).contains(TypeDescription.ForLoadedType.of(Child.class)), is(false));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionArrayProjectionTest.java
Patch:
@@ -12,7 +12,7 @@ public class TypeDescriptionArrayProjectionTest extends AbstractTypeDescriptionT
 
     @Override
     protected TypeDescription describe(Class<?> type) {
-        return TypeDescription.ArrayProjection.of(new TypeDescription.ForLoadedType(type), 0);
+        return TypeDescription.ArrayProjection.of(TypeDescription.ForLoadedType.of(type), 0);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericOfParameterizedTypeForGenerifiedErasureTest.java
Patch:
@@ -15,7 +15,7 @@ public void testNonGenerifiedType() throws Exception {
 
     @Test
     public void testGenerifiedType() throws Exception {
-        TypeDescription.Generic typeDescription = TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(new TypeDescription.ForLoadedType(Foo.class));
+        TypeDescription.Generic typeDescription = TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(TypeDescription.ForLoadedType.of(Foo.class));
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
         assertThat(typeDescription.getTypeArguments().size(), is(1));
         assertThat(typeDescription.getTypeArguments().getOnly().getSort(), is(TypeDefinition.Sort.VARIABLE));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorAnnotationStripperTest.java
Patch:
@@ -86,7 +86,7 @@ public void testTypeVariable() throws Exception {
 
     @Test
     public void testParameterized() throws Exception {
-        TypeDescription.Generic typeDescription = TypeDescription.Generic.Builder.parameterizedType(new TypeDescription.ForLoadedType(Collection.class),
+        TypeDescription.Generic typeDescription = TypeDescription.Generic.Builder.parameterizedType(TypeDescription.ForLoadedType.of(Collection.class),
                 TypeDescription.Generic.Builder.rawType(Object.class).annotate(annotationDescription).build()).annotate(annotationDescription).build();
         assertThat(TypeDescription.Generic.Visitor.AnnotationStripper.INSTANCE.onParameterizedType(typeDescription), is(typeDescription));
         assertThat(TypeDescription.Generic.Visitor.AnnotationStripper.INSTANCE.onParameterizedType(typeDescription).getDeclaredAnnotations().size(), is(0));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorAssignerTest.java
Patch:
@@ -49,7 +49,7 @@ public class TypeDescriptionGenericVisitorAssignerTest {
 
     @Before
     public void setUp() throws Exception {
-        FieldList<?> fields = new TypeDescription.ForLoadedType(GenericTypes.class).getDeclaredFields();
+        FieldList<?> fields = TypeDescription.ForLoadedType.of(GenericTypes.class).getDeclaredFields();
         collectionRaw = fields.filter(named("collectionRaw")).getOnly().getType();
         collectionWildcard = fields.filter(named("collectionWildcard")).getOnly().getType();
         collectionTypeVariableT = fields.filter(named("collectionTypeVariableT")).getOnly().getType();

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorReifyingTest.java
Patch:
@@ -34,7 +34,7 @@ public void testInitiatingGenerifiedNonGenericType() throws Exception {
 
     @Test
     public void testInitiatingNonGenerifiedNonGenericType() throws Exception {
-        when(generic.asErasure()).thenReturn(new TypeDescription.ForLoadedType(Foo.class));
+        when(generic.asErasure()).thenReturn(TypeDescription.ForLoadedType.of(Foo.class));
         assertThat(TypeDescription.Generic.Visitor.Reifying.INITIATING.onNonGenericType(generic), not(sameInstance(generic)));
         assertThat(TypeDescription.Generic.Visitor.Reifying.INITIATING.onNonGenericType(generic).getSort(), is(TypeDefinition.Sort.NON_GENERIC));
     }
@@ -67,7 +67,7 @@ public void testInheritingGenerifiedNonGenericType() throws Exception {
 
     @Test
     public void testInheritingNonGenerifiedNonGenericType() throws Exception {
-        when(generic.asErasure()).thenReturn(new TypeDescription.ForLoadedType(Foo.class));
+        when(generic.asErasure()).thenReturn(TypeDescription.ForLoadedType.of(Foo.class));
         assertThat(TypeDescription.Generic.Visitor.Reifying.INHERITING.onNonGenericType(generic), not(sameInstance(generic)));
         assertThat(TypeDescription.Generic.Visitor.Reifying.INHERITING.onNonGenericType(generic).getSort(), is(TypeDefinition.Sort.NON_GENERIC));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorSubstitutorForAttachmentTest.java
Patch:
@@ -19,7 +19,7 @@ public class TypeDescriptionGenericVisitorSubstitutorForAttachmentTest {
     public void testAttachment() throws Exception {
         TypeDescription.Generic original = TypeDefinition.Sort.describe(Foo.Inner.class.getDeclaredField(FOO).getGenericType());
         TypeDescription.Generic detached = original.accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(ElementMatchers.is(Foo.Inner.class)));
-        TypeDescription target = new TypeDescription.ForLoadedType(Bar.class);
+        TypeDescription target = TypeDescription.ForLoadedType.of(Bar.class);
         TypeDescription.Generic attached = detached.accept(new TypeDescription.Generic.Visitor.Substitutor.ForAttachment(target.asGenericType(), target));
         assertThat(attached.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
         assertThat(attached.asErasure(), sameInstance(target));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeListExplicitTest.java
Patch:
@@ -6,12 +6,12 @@ public class TypeListExplicitTest extends AbstractTypeListTest<TypeDescription>
 
     @Override
     protected TypeDescription getFirst() throws Exception {
-        return new TypeDescription.ForLoadedType(Foo.class);
+        return TypeDescription.ForLoadedType.of(Foo.class);
     }
 
     @Override
     protected TypeDescription getSecond() throws Exception {
-        return new TypeDescription.ForLoadedType(Bar.class);
+        return TypeDescription.ForLoadedType.of(Bar.class);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeListForLoadedTest.java
Patch:
@@ -21,6 +21,6 @@ protected TypeList asList(List<Class<?>> elements) {
 
     @Override
     protected TypeDescription asElement(Class<?> element) {
-        return new TypeDescription.ForLoadedType(element);
+        return TypeDescription.ForLoadedType.of(element);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/TransformerForFieldTest.java
Patch:
@@ -94,7 +94,7 @@ public void testModifierTransformation() throws Exception {
 
     @Test
     public void testNoChangesUnlessSpecified() throws Exception {
-        TypeDescription typeDescription = new TypeDescription.ForLoadedType(Bar.class);
+        TypeDescription typeDescription = TypeDescription.ForLoadedType.of(Bar.class);
         FieldDescription fieldDescription = typeDescription.getSuperClass().getDeclaredFields().filter(named(FOO)).getOnly();
         FieldDescription transformed = Transformer.ForField.withModifiers().transform(typeDescription, fieldDescription);
         assertThat(transformed, is(fieldDescription));
@@ -103,7 +103,7 @@ public void testNoChangesUnlessSpecified() throws Exception {
 
     @Test
     public void testRetainsInstrumentedType() throws Exception {
-        TypeDescription typeDescription = new TypeDescription.ForLoadedType(Bar.class);
+        TypeDescription typeDescription = TypeDescription.ForLoadedType.of(Bar.class);
         FieldDescription fieldDescription = typeDescription.getSuperClass().getDeclaredFields().filter(named(BAR)).getOnly();
         FieldDescription transformed = Transformer.ForField.withModifiers().transform(typeDescription, fieldDescription);
         assertThat(transformed, is(fieldDescription));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/TransformerForMethodTest.java
Patch:
@@ -145,7 +145,7 @@ public void testModifierTransformation() throws Exception {
 
     @Test
     public void testNoChangesUnlessSpecified() throws Exception {
-        TypeDescription typeDescription = new TypeDescription.ForLoadedType(Bar.class);
+        TypeDescription typeDescription = TypeDescription.ForLoadedType.of(Bar.class);
         MethodDescription methodDescription = typeDescription.getSuperClass().getDeclaredMethods().filter(named(FOO)).getOnly();
         MethodDescription transformed = Transformer.ForMethod.withModifiers().transform(typeDescription, methodDescription);
         assertThat(transformed, is(methodDescription));
@@ -154,7 +154,7 @@ public void testNoChangesUnlessSpecified() throws Exception {
 
     @Test
     public void testRetainsInstrumentedType() throws Exception {
-        TypeDescription typeDescription = new TypeDescription.ForLoadedType(Bar.class);
+        TypeDescription typeDescription = TypeDescription.ForLoadedType.of(Bar.class);
         MethodDescription methodDescription = typeDescription.getSuperClass().getDeclaredMethods().filter(named(BAR)).getOnly();
         MethodDescription transformed = Transformer.ForMethod.withModifiers().transform(typeDescription, methodDescription);
         assertThat(transformed, is(methodDescription));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassInjectorUsingReflectionTest.java
Patch:
@@ -52,7 +52,7 @@ public void testBootstrapClassLoader() throws Exception {
     @ClassInjectionAvailableRule.Enforce
     public void testInjection() throws Exception {
         new ClassInjector.UsingReflection(classLoader)
-                .inject(Collections.<TypeDescription, byte[]>singletonMap(new TypeDescription.ForLoadedType(Foo.class), ClassFileExtraction.extract(Foo.class)));
+                .inject(Collections.<TypeDescription, byte[]>singletonMap(TypeDescription.ForLoadedType.of(Foo.class), ClassFileExtraction.extract(Foo.class)));
         assertThat(classLoader.loadClass(Foo.class.getName()).getClassLoader(), is(classLoader));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassInjectorUsingUnsafeTest.java
Patch:
@@ -34,8 +34,8 @@ public void setUp() throws Exception {
     @ClassUnsafeInjectionAvailableRule.Enforce
     public void testUnsafeInjection() throws Exception {
         assertThat(new ClassInjector.UsingUnsafe(classLoader)
-                .inject(Collections.singletonMap(new TypeDescription.ForLoadedType(Foo.class), ClassFileExtraction.extract(Foo.class)))
-                .get(new TypeDescription.ForLoadedType(Foo.class)), notNullValue(Class.class));
+                .inject(Collections.singletonMap(TypeDescription.ForLoadedType.of(Foo.class), ClassFileExtraction.extract(Foo.class)))
+                .get(TypeDescription.ForLoadedType.of(Foo.class)), notNullValue(Class.class));
         assertThat(Class.forName(Foo.class.getName(), false, classLoader).getName(), is(Foo.class.getName()));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategyDefaultTest.java
Patch:
@@ -46,7 +46,7 @@ public class ClassLoadingStrategyDefaultTest {
     public void setUp() throws Exception {
         classLoader = new URLClassLoader(new URL[0], null);
         binaryRepresentations = new LinkedHashMap<TypeDescription, byte[]>();
-        typeDescription = new TypeDescription.ForLoadedType(Foo.class);
+        typeDescription = TypeDescription.ForLoadedType.of(Foo.class);
         binaryRepresentations.put(typeDescription, ClassFileExtraction.extract(Foo.class));
         protectionDomain = getClass().getProtectionDomain();
         when(packageDefinitionStrategy.define(any(ClassLoader.class), any(String.class), any(String.class)))

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategyForUnsafeInjectionTest.java
Patch:
@@ -36,7 +36,7 @@ public class ClassLoadingStrategyForUnsafeInjectionTest {
     public void setUp() throws Exception {
         classLoader = new URLClassLoader(new URL[0], null);
         binaryRepresentations = new LinkedHashMap<TypeDescription, byte[]>();
-        typeDescription = new TypeDescription.ForLoadedType(Foo.class);
+        typeDescription = TypeDescription.ForLoadedType.of(Foo.class);
         binaryRepresentations.put(typeDescription, ClassFileExtraction.extract(Foo.class));
         protectionDomain = getClass().getProtectionDomain();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategyUsingLookupTest.java
Patch:
@@ -29,7 +29,7 @@ public class ClassLoadingStrategyUsingLookupTest {
 
     @Before
     public void setUp() throws Exception {
-        typeDescription = new TypeDescription.ForLoadedType(Foo.class);
+        typeDescription = TypeDescription.ForLoadedType.of(Foo.class);
         binaryRepresentation = new byte[]{1, 2, 3};
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/AbstractDynamicTypeBuilderForInliningTest.java
Patch:
@@ -453,7 +453,7 @@ public void testEnabledAnnotationRetention() throws Exception {
     @SuppressWarnings("unchecked")
     public void testAnnotationTypeOnInterfaceType() throws Exception {
         Class<? extends Annotation> typeAnnotationType = (Class<? extends Annotation>) Class.forName(TYPE_VARIABLE_NAME);
-        MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
+        MethodDescription.InDefinedShape value = TypeDescription.ForLoadedType.of(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Class<?> type = create(Class.forName(SIMPLE_TYPE_ANNOTATED))
                 .merge(TypeManifestation.ABSTRACT)
                 .implement(TypeDescription.Generic.Builder.rawType(Callable.class)
@@ -475,7 +475,7 @@ public void testAnnotationTypeOnInterfaceType() throws Exception {
     @SuppressWarnings("unchecked")
     public void testAnnotationTypeOnTypeVariableType() throws Exception {
         Class<? extends Annotation> typeAnnotationType = (Class<? extends Annotation>) Class.forName(TYPE_VARIABLE_NAME);
-        MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
+        MethodDescription.InDefinedShape value = TypeDescription.ForLoadedType.of(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Class<?> type = create(Class.forName(SIMPLE_TYPE_ANNOTATED))
                 .merge(TypeManifestation.ABSTRACT)
                 .typeVariable(BAR, TypeDescription.Generic.Builder.rawType(Callable.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderTest.java
Patch:
@@ -496,7 +496,7 @@ public void testNoVisibilityBridgeForAbstractMethod() throws Exception {
     @SuppressWarnings("unchecked")
     public void testAnnotationTypeOnSuperClass() throws Exception {
         Class<? extends Annotation> typeAnnotationType = (Class<? extends Annotation>) Class.forName(TYPE_VARIABLE_NAME);
-        MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
+        MethodDescription.InDefinedShape value = TypeDescription.ForLoadedType.of(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Class<?> type = new ByteBuddy()
                 .subclass(TypeDescription.Generic.Builder.rawType(Object.class)
                         .build(AnnotationDescription.Builder.ofType(typeAnnotationType).define(VALUE, BAZ).build()))
@@ -514,7 +514,7 @@ public void testAnnotationTypeOnSuperClass() throws Exception {
     @SuppressWarnings("unchecked")
     public void testReceiverTypeDefinition() throws Exception {
         Class<? extends Annotation> typeAnnotationType = (Class<? extends Annotation>) Class.forName(TYPE_VARIABLE_NAME);
-        MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
+        MethodDescription.InDefinedShape value = TypeDescription.ForLoadedType.of(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Method method = createPlain()
                 .defineMethod(FOO, void.class)
                 .intercept(StubMethod.INSTANCE)
@@ -535,7 +535,7 @@ public void testReceiverTypeDefinition() throws Exception {
     @SuppressWarnings("unchecked")
     public void testReceiverTypeInterception() throws Exception {
         Class<? extends Annotation> typeAnnotationType = (Class<? extends Annotation>) Class.forName(TYPE_VARIABLE_NAME);
-        MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
+        MethodDescription.InDefinedShape value = TypeDescription.ForLoadedType.of(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Method method = createPlain()
                 .method(named("toString"))
                 .intercept(StubMethod.INSTANCE)

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/AbstractMethodCallProxyTest.java
Patch:
@@ -36,7 +36,7 @@ public class AbstractMethodCallProxyTest {
     private MethodAccessorFactory methodAccessorFactory;
 
     protected Class<?> proxyOnlyDeclaredMethodOf(Class<?> proxyTarget) throws Exception {
-        MethodDescription.InDefinedShape proxyMethod = new TypeDescription.ForLoadedType(proxyTarget)
+        MethodDescription.InDefinedShape proxyMethod = TypeDescription.ForLoadedType.of(proxyTarget)
                 .getDeclaredMethods().filter(not(isConstructor())).getOnly();
         when(methodAccessorFactory.registerAccessorFor(specialMethodInvocation, MethodAccessorFactory.AccessType.DEFAULT)).thenReturn(proxyMethod);
         String auxiliaryTypeName = getClass().getName() + "$" + proxyTarget.getSimpleName() + "$Proxy";

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TypeProxyCreationTest.java
Patch:
@@ -65,7 +65,7 @@ public void setUp() throws Exception {
         for (ModifierContributor modifierContributor : AuxiliaryType.DEFAULT_TYPE_MODIFIER) {
             modifiers = modifiers | modifierContributor.getMask();
         }
-        foo = new TypeDescription.ForLoadedType(Foo.class);
+        foo = TypeDescription.ForLoadedType.of(Foo.class);
         fooMethods = MethodGraph.Compiler.DEFAULT.compile(foo)
                 .listNodes()
                 .asMethodList()
@@ -211,7 +211,7 @@ public void testForConstructorConstruction() throws Exception {
         when(methodAccessorFactory.registerAccessorFor(specialMethodInvocation, MethodAccessorFactory.AccessType.DEFAULT)).thenReturn(proxyMethod);
         StackManipulation stackManipulation = new TypeProxy.ForSuperMethodByConstructor(foo,
                 implementationTarget,
-                Collections.singletonList((TypeDescription) new TypeDescription.ForLoadedType(Void.class)),
+                Collections.singletonList((TypeDescription) TypeDescription.ForLoadedType.of(Void.class)),
                 true,
                 false);
         MethodVisitor methodVisitor = mock(MethodVisitor.class);
@@ -291,7 +291,7 @@ public void testForReflectionFactoryConstruction() throws Exception {
         MethodVisitor methodVisitor = mock(MethodVisitor.class);
         Implementation.Context implementationContext = mock(Implementation.Context.class);
         when(implementationContext.register(any(AuxiliaryType.class)))
-                .thenReturn(new TypeDescription.ForLoadedType(FooProxyMake.class));
+                .thenReturn(TypeDescription.ForLoadedType.of(FooProxyMake.class));
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);
         assertThat(size.getSizeImpact(), is(1));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/DefaultCallBinderTest.java
Patch:
@@ -94,7 +94,7 @@ public void testExplicitLookup() throws Exception {
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = DefaultCall.Binder.INSTANCE
                 .bind(annotationDescription, source, target, implementationTarget, assigner, Assigner.Typing.STATIC);
         assertThat(parameterBinding.isValid(), is(true));
-        verify(implementationTarget).invokeDefault(token, new TypeDescription.ForLoadedType(INTERFACE_TYPE));
+        verify(implementationTarget).invokeDefault(token, TypeDescription.ForLoadedType.of(INTERFACE_TYPE));
         verifyNoMoreInteractions(implementationTarget);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/DefaultMethodBinderTest.java
Patch:
@@ -100,7 +100,7 @@ public void testBindNoInterface() throws Exception {
     public void testBindExplicit() throws Exception {
         when(targetType.isAssignableFrom(Method.class)).thenReturn(true);
         when(source.isMethod()).thenReturn(true);
-        when(implementationTarget.invokeDefault(token, new TypeDescription.ForLoadedType(Runnable.class))).thenReturn(specialMethodInvocation);
+        when(implementationTarget.invokeDefault(token, TypeDescription.ForLoadedType.of(Runnable.class))).thenReturn(specialMethodInvocation);
         when(specialMethodInvocation.isValid()).thenReturn(true);
         when(annotation.targetType()).thenReturn((Class) Runnable.class);
         when(instrumentedType.getInterfaces()).thenReturn(new TypeList.Generic.Explicit(genericInterfaceType, genericInterfaceType));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/MorphBinderTest.java
Patch:
@@ -121,7 +121,7 @@ public void testDefaultMethodCallExplicitInvalid() throws Exception {
         when(morphMethod.getDeclaringType()).thenReturn(morphType);
         when(annotation.defaultMethod()).thenReturn(true);
         doReturn(Foo.class).when(annotation).defaultTarget();
-        when(implementationTarget.invokeDefault(morphToken, new TypeDescription.ForLoadedType(Foo.class)))
+        when(implementationTarget.invokeDefault(morphToken, TypeDescription.ForLoadedType.of(Foo.class)))
                 .thenReturn(specialMethodInvocation);
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = new Morph.Binder(morphMethod)
                 .bind(annotationDescription, source, target, implementationTarget, assigner, Assigner.Typing.STATIC);
@@ -137,7 +137,7 @@ public void testDefaultMethodCallExplicitValid() throws Exception {
         when(morphMethod.getDeclaringType()).thenReturn(morphType);
         when(annotation.defaultMethod()).thenReturn(true);
         doReturn(Foo.class).when(annotation).defaultTarget();
-        when(implementationTarget.invokeDefault(morphToken, new TypeDescription.ForLoadedType(Foo.class)))
+        when(implementationTarget.invokeDefault(morphToken, TypeDescription.ForLoadedType.of(Foo.class)))
                 .thenReturn(specialMethodInvocation);
         when(specialMethodInvocation.isValid()).thenReturn(true);
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = new Morph.Binder(morphMethod)

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/OriginBinderTest.java
Patch:
@@ -128,7 +128,7 @@ public void testModifierBinding() throws Exception {
     @Test
     @JavaVersionRule.Enforce(7)
     public void testMethodHandleBinding() throws Exception {
-        when(genericTargetType.asErasure()).thenReturn(new TypeDescription.ForLoadedType(JavaType.METHOD_HANDLE.load()));
+        when(genericTargetType.asErasure()).thenReturn(TypeDescription.ForLoadedType.of(JavaType.METHOD_HANDLE.load()));
         when(methodDescription.getReturnType()).thenReturn(TypeDescription.Generic.VOID);
         when(methodDescription.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
         TypeDescription typeDescription = mock(TypeDescription.class);
@@ -142,7 +142,7 @@ public void testMethodHandleBinding() throws Exception {
     @Test
     @JavaVersionRule.Enforce(7)
     public void testMethodTypeBinding() throws Exception {
-        when(genericTargetType.asErasure()).thenReturn(new TypeDescription.ForLoadedType(JavaType.METHOD_TYPE.load()));
+        when(genericTargetType.asErasure()).thenReturn(TypeDescription.ForLoadedType.of(JavaType.METHOD_TYPE.load()));
         when(methodDescription.getReturnType()).thenReturn(TypeDescription.Generic.VOID);
         when(methodDescription.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = Origin.Binder.INSTANCE

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinderTest.java
Patch:
@@ -126,10 +126,10 @@ public void setUp() throws Exception {
         when(targetMethod.getParameters())
                 .thenReturn((ParameterList) new ParameterList.Explicit<ParameterDescription>(firstParameter, secondParameter));
         when(firstPseudoAnnotation.getAnnotationType())
-                .thenReturn(new TypeDescription.ForLoadedType(FirstPseudoAnnotation.class));
+                .thenReturn(TypeDescription.ForLoadedType.of(FirstPseudoAnnotation.class));
         when(firstPseudoAnnotation.prepare(FirstPseudoAnnotation.class)).thenReturn(firstPseudoAnnotation);
         when(secondPseudoAnnotation.getAnnotationType())
-                .thenReturn(new TypeDescription.ForLoadedType(SecondPseudoAnnotation.class));
+                .thenReturn(TypeDescription.ForLoadedType.of(SecondPseudoAnnotation.class));
         when(secondPseudoAnnotation.prepare(SecondPseudoAnnotation.class)).thenReturn(secondPseudoAnnotation);
         when(sourceTypeDescription.getStackSize()).thenReturn(StackSize.ZERO);
         when(targetTypeDescription.getStackSize()).thenReturn(StackSize.ZERO);
@@ -156,7 +156,7 @@ public void testConflictingBinderBinding() throws Exception {
     public void testIgnoreForBindingAnnotation() throws Exception {
         when(targetMethod.isAccessibleTo(instrumentedType)).thenReturn(true);
         AnnotationDescription ignoreForBinding = mock(AnnotationDescription.class);
-        when(ignoreForBinding.getAnnotationType()).thenReturn(new TypeDescription.ForLoadedType(IgnoreForBinding.class));
+        when(ignoreForBinding.getAnnotationType()).thenReturn(TypeDescription.ForLoadedType.of(IgnoreForBinding.class));
         when(targetMethod.getDeclaredAnnotations()).thenReturn(new AnnotationList.Explicit(Collections.singletonList(ignoreForBinding)));
         when(termination.isValid()).thenReturn(true);
         MethodDelegationBinder methodDelegationBinder = TargetMethodAnnotationDrivenBinder.of(Collections.<TargetMethodAnnotationDrivenBinder.ParameterBinder<?>>emptyList());

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveBoxingDelegateTest.java
Patch:
@@ -64,7 +64,7 @@ public PrimitiveBoxingDelegateTest(Class<?> primitiveType,
         this.primitiveType = primitiveType;
         primitiveTypeDescription = mock(TypeDescription.class);
         when(primitiveTypeDescription.represents(primitiveType)).thenReturn(true);
-        referenceTypeDescription = new TypeDescription.ForLoadedType(referenceType);
+        referenceTypeDescription = TypeDescription.ForLoadedType.of(referenceType);
         this.boxingMethodDescriptor = boxingMethodDescriptor;
         this.sizeChange = sizeChange;
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveWideningDelegateOtherTest.java
Patch:
@@ -12,6 +12,6 @@ public void testIllegalSourceTypeThrowsException() throws Exception {
 
     @Test(expected = IllegalArgumentException.class)
     public void testIllegalTargetTypeThrowsException() throws Exception {
-        PrimitiveWideningDelegate.forPrimitive(new TypeDescription.ForLoadedType(int.class)).widenTo(TypeDescription.OBJECT);
+        PrimitiveWideningDelegate.forPrimitive(TypeDescription.ForLoadedType.of(int.class)).widenTo(TypeDescription.OBJECT);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/collection/ArrayAccessTest.java
Patch:
@@ -37,7 +37,7 @@ public class ArrayAccessTest {
     private Implementation.Context implementationContext;
 
     public ArrayAccessTest(Class<?> type, int loadOpcode, int storeOpcode) {
-        typeDescription = new TypeDescription.ForLoadedType(type);
+        typeDescription = TypeDescription.ForLoadedType.of(type);
         this.loadOpcode = loadOpcode;
         this.storeOpcode = storeOpcode;
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/ClassConstantPrimitiveTest.java
Patch:
@@ -35,8 +35,8 @@ public class ClassConstantPrimitiveTest {
     private Implementation.Context implementationContext;
 
     public ClassConstantPrimitiveTest(Class<?> primitiveType, Class<?> wrapperType) {
-        this.primitiveType = new TypeDescription.ForLoadedType(primitiveType);
-        this.wrapperType = new TypeDescription.ForLoadedType(wrapperType);
+        this.primitiveType = TypeDescription.ForLoadedType.of(primitiveType);
+        this.wrapperType = TypeDescription.ForLoadedType.of(wrapperType);
     }
 
     @Parameterized.Parameters

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/FieldConstantTest.java
Patch:
@@ -53,7 +53,7 @@ public void setUp() throws Exception {
         when(fieldDescription.getInternalName()).thenReturn(BAR);
         when(fieldDescription.getDeclaringType()).thenReturn(declaringType);
         when(declaringType.getDescriptor()).thenReturn("L" + QUX + ";");
-        when(implementationContext.cache(new FieldConstant(fieldDescription), new TypeDescription.ForLoadedType(Field.class)))
+        when(implementationContext.cache(new FieldConstant(fieldDescription), TypeDescription.ForLoadedType.of(Field.class)))
                 .thenReturn(cacheField);
         when(cacheField.getDeclaringType()).thenReturn(cacheDeclaringType);
         when(cacheField.isStatic()).thenReturn(true);
@@ -143,7 +143,7 @@ public void testCached() throws Exception {
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);
         assertThat(size.getSizeImpact(), is(1));
         assertThat(size.getMaximalSize(), is(1));
-        verify(implementationContext).cache(new FieldConstant(fieldDescription), new TypeDescription.ForLoadedType(Field.class));
+        verify(implementationContext).cache(new FieldConstant(fieldDescription), TypeDescription.ForLoadedType.of(Field.class));
         verifyNoMoreInteractions(implementationContext);
         verify(methodVisitor).visitFieldInsn(Opcodes.GETSTATIC, BAZ, FOO + BAR, QUX + BAZ);
         verifyNoMoreInteractions(methodVisitor);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/MethodConstantTest.java
Patch:
@@ -109,7 +109,7 @@ public void testMethodCached() throws Exception {
         assertThat(size.getMaximalSize(), is(1));
         verify(methodVisitor).visitFieldInsn(Opcodes.GETSTATIC, BAZ, FOO, QUX);
         verifyNoMoreInteractions(methodVisitor);
-        verify(implementationContext).cache(MethodConstant.forMethod(methodDescription), new TypeDescription.ForLoadedType(Method.class));
+        verify(implementationContext).cache(MethodConstant.forMethod(methodDescription), TypeDescription.ForLoadedType.of(Method.class));
         verifyNoMoreInteractions(implementationContext);
     }
 
@@ -135,7 +135,7 @@ public void testConstructorCached() throws Exception {
         assertThat(size.getMaximalSize(), is(1));
         verify(methodVisitor).visitFieldInsn(Opcodes.GETSTATIC, BAZ, FOO, QUX);
         verifyNoMoreInteractions(methodVisitor);
-        verify(implementationContext).cache(MethodConstant.forMethod(methodDescription), new TypeDescription.ForLoadedType(Constructor.class));
+        verify(implementationContext).cache(MethodConstant.forMethod(methodDescription), TypeDescription.ForLoadedType.of(Constructor.class));
         verifyNoMoreInteractions(implementationContext);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/InstanceTypeMatcherTest.java
Patch:
@@ -23,13 +23,13 @@ public InstanceTypeMatcherTest() {
 
     @Test
     public void testMatch() throws Exception {
-        when(matcher.matches(new TypeDescription.ForLoadedType(object.getClass()))).thenReturn(true);
+        when(matcher.matches(TypeDescription.ForLoadedType.of(object.getClass()))).thenReturn(true);
         assertThat(new InstanceTypeMatcher<Object>(matcher).matches(object), is(true));
     }
 
     @Test
     public void testNoMatch() throws Exception {
-        when(matcher.matches(new TypeDescription.ForLoadedType(object.getClass()))).thenReturn(false);
+        when(matcher.matches(TypeDescription.ForLoadedType.of(object.getClass()))).thenReturn(false);
         assertThat(new InstanceTypeMatcher<Object>(matcher).matches(object), is(false));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolClassLoadingTest.java
Patch:
@@ -40,14 +40,14 @@ public void testLoadableBootstrapLoaderClass() throws Exception {
     public void testArrayClass() throws Exception {
         TypePool.Resolution resolution = typePool.describe(Object[].class.getName());
         assertThat(resolution.isResolved(), is(true));
-        assertThat(resolution.resolve(), is((TypeDescription) new TypeDescription.ForLoadedType(Object[].class)));
+        assertThat(resolution.resolve(), is((TypeDescription) TypeDescription.ForLoadedType.of(Object[].class)));
     }
 
     @Test
     public void testPrimitiveClass() throws Exception {
         TypePool.Resolution resolution = typePool.describe(int.class.getName());
         assertThat(resolution.isResolved(), is(true));
-        assertThat(resolution.resolve(), is((TypeDescription) new TypeDescription.ForLoadedType(int.class)));
+        assertThat(resolution.resolve(), is((TypeDescription) TypeDescription.ForLoadedType.of(int.class)));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultHierarchyTest.java
Patch:
@@ -62,7 +62,7 @@ public TypePool.Resolution answer(InvocationOnMock invocationOnMock) throws Thro
         });
         TypePool.Resolution resolution = typePool.describe(FOO);
         assertThat(resolution.isResolved(), is(true));
-        assertThat(resolution.resolve(), is((TypeDescription) new TypeDescription.ForLoadedType(Foo.class)));
+        assertThat(resolution.resolve(), is((TypeDescription) TypeDescription.ForLoadedType.of(Foo.class)));
         verify(cacheProvider).find(FOO);
         verify(cacheProvider).register(FOO, resolution);
         verifyZeroInteractions(cacheProvider);

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultLazyTypeListTest.java
Patch:
@@ -41,6 +41,6 @@ protected TypeList asList(List<Class<?>> elements) {
 
     @Override
     protected TypeDescription asElement(Class<?> element) {
-        return new TypeDescription.ForLoadedType(element);
+        return TypeDescription.ForLoadedType.of(element);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/ClassFileExtraction.java
Patch:
@@ -38,7 +38,7 @@ public static Map<String, byte[]> of(Class<?>... type) throws IOException {
     public static byte[] extract(Class<?> type, AsmVisitorWrapper asmVisitorWrapper) throws IOException {
         ClassReader classReader = new ClassReader(type.getName());
         ClassWriter classWriter = new ClassWriter(classReader, AsmVisitorWrapper.NO_FLAGS);
-        classReader.accept(asmVisitorWrapper.wrap(new TypeDescription.ForLoadedType(type),
+        classReader.accept(asmVisitorWrapper.wrap(TypeDescription.ForLoadedType.of(type),
                 classWriter,
                 new IllegalContext(),
                 TypePool.Empty.INSTANCE,

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaConstantMethodTypeTest.java
Patch:
@@ -58,14 +58,14 @@ public void testMethodTypeOfConstructor() throws Exception {
     @SuppressWarnings("unchecked")
     public void testMethodTypeOfGetter() throws Exception {
         JavaConstant.MethodType methodType = JavaConstant.MethodType.ofGetter(Foo.class.getDeclaredField(BAR));
-        assertThat(methodType.getReturnType(), is((TypeDescription) new TypeDescription.ForLoadedType(Void.class)));
+        assertThat(methodType.getReturnType(), is((TypeDescription) TypeDescription.ForLoadedType.of(Void.class)));
         assertThat(methodType.getParameterTypes(), is(Collections.<TypeDescription>emptyList()));
     }
 
     @Test
     public void testMethodTypeOfStaticGetter() throws Exception {
         JavaConstant.MethodType methodType = JavaConstant.MethodType.ofGetter(Foo.class.getDeclaredField(QUX));
-        assertThat(methodType.getReturnType(), is((TypeDescription) new TypeDescription.ForLoadedType(Void.class)));
+        assertThat(methodType.getReturnType(), is((TypeDescription) TypeDescription.ForLoadedType.of(Void.class)));
         assertThat(methodType.getParameterTypes(), is(Collections.<TypeDescription>emptyList()));
     }
 
@@ -88,7 +88,7 @@ public void testMethodTypeOfStaticSetter() throws Exception {
     @Test
     public void testMethodTypeOfConstant() throws Exception {
         JavaConstant.MethodType methodType = JavaConstant.MethodType.ofConstant(new Foo(null));
-        assertThat(methodType.getReturnType(), is((TypeDescription) new TypeDescription.ForLoadedType(Foo.class)));
+        assertThat(methodType.getReturnType(), is((TypeDescription) TypeDescription.ForLoadedType.of(Foo.class)));
         assertThat(methodType.getParameterTypes(), is(Collections.<TypeDescription>emptyList()));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaTypeTest.java
Patch:
@@ -76,7 +76,7 @@ public void testParameter() throws Exception {
     public void testExecutable() throws Exception {
         assertThat(JavaType.EXECUTABLE.getTypeStub().getName(), is("java.lang.reflect.Executable"));
         assertThat(JavaType.EXECUTABLE.getTypeStub().getModifiers(), is(Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT));
-        assertThat(JavaType.EXECUTABLE.getTypeStub().getSuperClass(), is((TypeDefinition) new TypeDescription.ForLoadedType(AccessibleObject.class)));
+        assertThat(JavaType.EXECUTABLE.getTypeStub().getSuperClass(), is((TypeDefinition) TypeDescription.ForLoadedType.of(AccessibleObject.class)));
         assertThat(JavaType.EXECUTABLE.getTypeStub().getInterfaces().size(), is(2));
         assertThat(JavaType.EXECUTABLE.getTypeStub().getInterfaces().contains(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Member.class)), is(true));
         assertThat(JavaType.EXECUTABLE.getTypeStub().getInterfaces().contains(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(GenericDeclaration.class)), is(true));

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -227,7 +227,7 @@ public String getName() {
 
         @Override
         public TypeDescription getDeclaringType() {
-            return new TypeDescription.ForLoadedType(field.getDeclaringClass());
+            return TypeDescription.ForLoadedType.of(field.getDeclaringClass());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/EqualsMethod.java
Patch:
@@ -40,7 +40,7 @@ public class EqualsMethod implements Implementation {
     /**
      * The {@link Object#equals(Object)} method.
      */
-    private static final MethodDescription.InDefinedShape EQUALS = new TypeDescription.ForLoadedType(Object.class)
+    private static final MethodDescription.InDefinedShape EQUALS = TypeDescription.OBJECT
             .getDeclaredMethods()
             .filter(isEquals())
             .getOnly();

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -511,7 +511,7 @@ public PropertyConfigurable withAssigner(Assigner assigner, Assigner.Typing typi
 
         @Override
         public AssignerConfigurable in(Class<?> type) {
-            return in(new TypeDescription.ForLoadedType(type));
+            return in(TypeDescription.ForLoadedType.of(type));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveBoxingDelegate.java
Patch:
@@ -86,7 +86,7 @@ public enum PrimitiveBoxingDelegate {
                             StackSize sizeDifference,
                             String boxingMethodName,
                             String boxingMethodDescriptor) {
-        this.wrapperType = new TypeDescription.ForLoadedType(wrapperType);
+        this.wrapperType = TypeDescription.ForLoadedType.of(wrapperType);
         this.size = sizeDifference.toDecreasingSize();
         this.boxingMethodName = boxingMethodName;
         this.boxingMethodDescriptor = boxingMethodDescriptor;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveUnboxingDelegate.java
Patch:
@@ -95,8 +95,8 @@ public enum PrimitiveUnboxingDelegate implements StackManipulation {
                               String unboxingMethodName,
                               String unboxingMethodDescriptor) {
         this.size = sizeDifference.toIncreasingSize();
-        this.wrapperType = new TypeDescription.ForLoadedType(wrapperType);
-        this.primitiveType = new TypeDescription.ForLoadedType(primitiveType);
+        this.wrapperType = TypeDescription.ForLoadedType.of(wrapperType);
+        this.primitiveType = TypeDescription.ForLoadedType.of(primitiveType);
         this.unboxingMethodName = unboxingMethodName;
         this.unboxingMethodDescriptor = unboxingMethodDescriptor;
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -227,7 +227,7 @@ public String getName() {
 
         @Override
         public TypeDescription getDeclaringType() {
-            return new TypeDescription.ForLoadedType(field.getDeclaringClass());
+            return TypeDescription.ForLoadedType.of(field.getDeclaringClass());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/EqualsMethod.java
Patch:
@@ -40,7 +40,7 @@ public class EqualsMethod implements Implementation {
     /**
      * The {@link Object#equals(Object)} method.
      */
-    private static final MethodDescription.InDefinedShape EQUALS = new TypeDescription.ForLoadedType(Object.class)
+    private static final MethodDescription.InDefinedShape EQUALS = TypeDescription.OBJECT
             .getDeclaredMethods()
             .filter(isEquals())
             .getOnly();

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -511,7 +511,7 @@ public PropertyConfigurable withAssigner(Assigner assigner, Assigner.Typing typi
 
         @Override
         public AssignerConfigurable in(Class<?> type) {
-            return in(new TypeDescription.ForLoadedType(type));
+            return in(TypeDescription.ForLoadedType.of(type));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveBoxingDelegate.java
Patch:
@@ -86,7 +86,7 @@ public enum PrimitiveBoxingDelegate {
                             StackSize sizeDifference,
                             String boxingMethodName,
                             String boxingMethodDescriptor) {
-        this.wrapperType = new TypeDescription.ForLoadedType(wrapperType);
+        this.wrapperType = TypeDescription.ForLoadedType.of(wrapperType);
         this.size = sizeDifference.toDecreasingSize();
         this.boxingMethodName = boxingMethodName;
         this.boxingMethodDescriptor = boxingMethodDescriptor;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveUnboxingDelegate.java
Patch:
@@ -95,8 +95,8 @@ public enum PrimitiveUnboxingDelegate implements StackManipulation {
                               String unboxingMethodName,
                               String unboxingMethodDescriptor) {
         this.size = sizeDifference.toIncreasingSize();
-        this.wrapperType = new TypeDescription.ForLoadedType(wrapperType);
-        this.primitiveType = new TypeDescription.ForLoadedType(primitiveType);
+        this.wrapperType = TypeDescription.ForLoadedType.of(wrapperType);
+        this.primitiveType = TypeDescription.ForLoadedType.of(primitiveType);
         this.unboxingMethodName = unboxingMethodName;
         this.unboxingMethodDescriptor = unboxingMethodDescriptor;
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -431,7 +431,7 @@ protected Direct(Method findLoadedClass,
                 protected static Initializable make() throws Exception {
                     Method getPackage;
                     try {
-                        getPackage = ClassLoader.class.getDeclaredMethod("getDefinedPackage", String.class);
+                        getPackage = ClassLoader.class.getMethod("getDefinedPackage", String.class);
                     } catch (NoSuchMethodException ignored) {
                         getPackage = ClassLoader.class.getDeclaredMethod("getPackage", String.class);
                     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoaderSynchronizationStrategyTest.java
Patch:
@@ -17,7 +17,7 @@ public class ByteArrayClassLoaderSynchronizationStrategyTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private ClassLoader classLoader;
+    private ByteArrayClassLoader classLoader;
 
     @Test
     public void testInitialize() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/FieldByFieldComparison.java
Patch:
@@ -53,7 +53,7 @@ private static boolean matches(Class<?> type, Object left, Object right, Set<Pai
         } else if (mockingDetails(left).isMock() || mockingDetails(left).isSpy() || mockingDetails(right).isMock() || mockingDetails(right).isSpy()) {
             return left == right;
         }
-        while (type != Object.class) {
+        while (type.getName().startsWith("net.bytebuddy.")) {
             for (Field field : type.getDeclaredFields()) {
                 if (Modifier.isStatic(field.getModifiers())) {
                     continue;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategy.java
Patch:
@@ -142,8 +142,9 @@ public Configurable<ClassLoader> allowExistingTypes() {
         }
 
         /**
-         * <p></p>
+         * <p>
          * A class loading strategy which applies a class loader injection while applying a given {@link java.security.ProtectionDomain} on class injection.
+         * </p>
          * <p>
          * <b>Important</b>: Class injection requires access to JVM internal methods that are sealed by security managers and the
          * Java Platform module system. Since Java 11, access to these methods is no longer feasible unless those packages

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CachingMatcher.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.matcher;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.build.HashCodeAndEqualsPlugin;
 
 import java.util.Iterator;
@@ -10,7 +11,7 @@
  *
  * @param <T> The actual matched type of this matcher.
  */
-@HashCodeAndEqualsPlugin.Enhance
+@HashCodeAndEqualsPlugin.Enhance(permitSubclassEquality = true)
 public class CachingMatcher<T> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**
@@ -67,6 +68,7 @@ public String toString() {
      *
      * @param <S> The actual matched type of this matcher.
      */
+    @SuppressFBWarnings(value = "EQ_DOESNT_OVERRIDE_EQUALS", justification = "Equality does not consider eviction size")
     public static class WithInlineEviction<S> extends CachingMatcher<S> {
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -7,6 +7,7 @@
 import org.objectweb.asm.ClassReader;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.OpenedClassReader;
 
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
@@ -245,7 +246,7 @@ public static ClassFileVersion of(Class<?> type, ClassFileLocator classFileLocat
      * @throws IOException If an error occurs while reading the class file.
      */
     public static ClassFileVersion of(TypeDescription typeDescription, ClassFileLocator classFileLocator) throws IOException {
-        ClassReader classReader = new ClassReader(classFileLocator.locate(typeDescription.getName()).resolve());
+        ClassReader classReader = new OpenedClassReader(classFileLocator.locate(typeDescription.getName()).resolve());
         VersionExtractor versionExtractor = new VersionExtractor();
         classReader.accept(versionExtractor, ClassReader.SKIP_CODE);
         return ClassFileVersion.ofMinorMajor(versionExtractor.getClassFileVersionNumber());

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -317,7 +317,7 @@ protected static Advice to(TypeDescription advice, ClassFileLocator classFileLoc
         }
         try {
             ClassReader classReader = methodEnter.isBinary() || methodExit.isBinary()
-                    ? new ClassReader(classFileLocator.locate(advice.getName()).resolve())
+                    ? new OpenedClassReader(classFileLocator.locate(advice.getName()).resolve())
                     : UNDEFINED;
             return new Advice(methodEnter.asMethodEnter(userFactories, classReader, methodExit), methodExit.asMethodExit(userFactories, classReader, methodEnter));
         } catch (IOException exception) {
@@ -405,9 +405,9 @@ protected static Advice to(TypeDescription enterAdvice,
         }
         try {
             return new Advice(methodEnter.asMethodEnter(userFactories, methodEnter.isBinary()
-                    ? new ClassReader(classFileLocator.locate(enterAdvice.getName()).resolve())
+                    ? new OpenedClassReader(classFileLocator.locate(enterAdvice.getName()).resolve())
                     : UNDEFINED, methodExit), methodExit.asMethodExit(userFactories, methodExit.isBinary()
-                    ? new ClassReader(classFileLocator.locate(exitAdvice.getName()).resolve())
+                    ? new OpenedClassReader(classFileLocator.locate(exitAdvice.getName()).resolve())
                     : UNDEFINED, methodEnter));
         } catch (IOException exception) {
             throw new IllegalStateException("Error reading class file of " + enterAdvice + " or " + exitAdvice, exception);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -2908,7 +2908,7 @@ protected UnresolvedType create(TypeInitializer typeInitializer) {
                 try {
                     int writerFlags = asmVisitorWrapper.mergeWriter(AsmVisitorWrapper.NO_FLAGS);
                     int readerFlags = asmVisitorWrapper.mergeReader(AsmVisitorWrapper.NO_FLAGS);
-                    ClassReader classReader = new ClassReader(classFileLocator.locate(originalType.getName()).resolve());
+                    ClassReader classReader = new OpenedClassReader(classFileLocator.locate(originalType.getName()).resolve());
                     ClassWriter classWriter = new FrameComputingClassWriter(classReader, writerFlags, typePool);
                     ContextRegistry contextRegistry = new ContextRegistry();
                     classReader.accept(writeTo(ValidatingClassVisitor.of(classWriter, typeValidation),

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -1045,7 +1045,7 @@ protected Resolution doDescribe(String name) {
          * @return A type description of the binary data.
          */
         private TypeDescription parse(byte[] binaryRepresentation) {
-            ClassReader classReader = new ClassReader(binaryRepresentation);
+            ClassReader classReader = new OpenedClassReader(binaryRepresentation);
             TypeExtractor typeExtractor = new TypeExtractor();
             classReader.accept(typeExtractor, readerMode.getFlags());
             return typeExtractor.toTypeDescription();

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterModifierPreservationTest.java
Patch:
@@ -16,6 +16,7 @@
 import org.objectweb.asm.ClassReader;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.OpenedClassReader;
 
 import java.util.Arrays;
 import java.util.Collection;
@@ -60,7 +61,7 @@ public TypeWriterModifierPreservationTest(Class<?> type) {
     @Test
     public void testModifiers() throws Exception {
         TypeModifierExtractor typeModifierExtractor = new TypeModifierExtractor();
-        new ClassReader(ClassFileLocator.ForClassLoader.read(type).resolve()).accept(typeModifierExtractor, 0);
+        new OpenedClassReader(ClassFileLocator.ForClassLoader.read(type).resolve()).accept(typeModifierExtractor, 0);
         new ByteBuddy()
                 .redefine(type)
                 .visit(new TypeValidator.Wrapper(typeModifierExtractor))

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -1532,6 +1532,9 @@ public void onError(String typeName, ClassLoader classLoader, JavaModule module,
         @EqualsAndHashCode(callSuper = false)
         class WithErrorsOnly extends Listener.Adapter {
 
+            /**
+             * The delegate listener.
+             */
             private final Listener delegate;
 
             /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/TypeCache.java
Patch:
@@ -1,7 +1,6 @@
 package net.bytebuddy;
 
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import net.bytebuddy.build.HashCodeAndEqualsPlugin;
 import net.bytebuddy.utility.CompoundList;
 
 import java.lang.ref.Reference;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/ArgumentTypeResolver.java
Patch:
@@ -1,6 +1,5 @@
 package net.bytebuddy.implementation.bind;
 
-import net.bytebuddy.build.HashCodeAndEqualsPlugin;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/FieldConstant.java
Patch:
@@ -1,6 +1,5 @@
 package net.bytebuddy.implementation.bytecode.constant;
 
-import net.bytebuddy.build.HashCodeAndEqualsPlugin;
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderInstallationListenerTest.java
Patch:
@@ -9,6 +9,7 @@
 import java.io.PrintStream;
 import java.lang.instrument.Instrumentation;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.nullValue;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -155,9 +156,9 @@ public void testCompoundListenerReset() throws Exception {
     @Test
     public void testStreamWritingToSystem() throws Exception {
         assertThat(AgentBuilder.InstallationListener.StreamWriting.toSystemOut(),
-                is((AgentBuilder.InstallationListener) new AgentBuilder.InstallationListener.StreamWriting(System.out)));
+                hasPrototype((AgentBuilder.InstallationListener) new AgentBuilder.InstallationListener.StreamWriting(System.out)));
         assertThat(AgentBuilder.InstallationListener.StreamWriting.toSystemError(),
-                is((AgentBuilder.InstallationListener) new AgentBuilder.InstallationListener.StreamWriting(System.err)));
+                hasPrototype((AgentBuilder.InstallationListener) new AgentBuilder.InstallationListener.StreamWriting(System.err)));
     }
 
     private static class PseudoAdapter extends AgentBuilder.InstallationListener.Adapter {

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderListenerTest.java
Patch:
@@ -16,6 +16,7 @@
 import java.util.Collections;
 
 import static net.bytebuddy.matcher.ElementMatchers.none;
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.*;
@@ -169,12 +170,12 @@ public void testStreamWritingOnIgnore() throws Exception {
 
     @Test
     public void testStreamWritingStandardOutput() throws Exception {
-        assertThat(AgentBuilder.Listener.StreamWriting.toSystemOut(), is((AgentBuilder.Listener) new AgentBuilder.Listener.StreamWriting(System.out)));
+        assertThat(AgentBuilder.Listener.StreamWriting.toSystemOut(), hasPrototype((AgentBuilder.Listener) new AgentBuilder.Listener.StreamWriting(System.out)));
     }
 
     @Test
     public void testStreamWritingStandardError() throws Exception {
-        assertThat(AgentBuilder.Listener.StreamWriting.toSystemError(), is((AgentBuilder.Listener) new AgentBuilder.Listener.StreamWriting(System.err)));
+        assertThat(AgentBuilder.Listener.StreamWriting.toSystemError(), hasPrototype((AgentBuilder.Listener) new AgentBuilder.Listener.StreamWriting(System.err)));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderLocationStrategyCompoundTest.java
Patch:
@@ -8,6 +8,7 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.*;
@@ -34,7 +35,7 @@ public void testApplication() throws Exception {
         AgentBuilder.LocationStrategy locationStrategy = new AgentBuilder.LocationStrategy.Compound(first, second);
         when(first.classFileLocator(classLoader, module)).thenReturn(firstLocator);
         when(second.classFileLocator(classLoader, module)).thenReturn(secondLocator);
-        assertThat(locationStrategy.classFileLocator(classLoader, module), is((ClassFileLocator) new ClassFileLocator.Compound(firstLocator, secondLocator)));
+        assertThat(locationStrategy.classFileLocator(classLoader, module), hasPrototype((ClassFileLocator) new ClassFileLocator.Compound(firstLocator, secondLocator)));
         verify(first).classFileLocator(classLoader, module);
         verifyNoMoreInteractions(first);
         verify(second).classFileLocator(classLoader, module);

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRedefinitionStrategyBatchAllocatorTest.java
Patch:
@@ -8,6 +8,7 @@
 import java.util.Iterator;
 import java.util.List;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
 
@@ -43,9 +44,9 @@ public void testForFixed() throws Exception {
     @Test
     public void testForFixedFactory() throws Exception {
         assertThat(AgentBuilder.RedefinitionStrategy.BatchAllocator.ForFixedSize.ofSize(1),
-                is((AgentBuilder.RedefinitionStrategy.BatchAllocator) new AgentBuilder.RedefinitionStrategy.BatchAllocator.ForFixedSize(1)));
+                hasPrototype((AgentBuilder.RedefinitionStrategy.BatchAllocator) new AgentBuilder.RedefinitionStrategy.BatchAllocator.ForFixedSize(1)));
         assertThat(AgentBuilder.RedefinitionStrategy.BatchAllocator.ForFixedSize.ofSize(0),
-                is((AgentBuilder.RedefinitionStrategy.BatchAllocator) AgentBuilder.RedefinitionStrategy.BatchAllocator.ForTotal.INSTANCE));
+                hasPrototype((AgentBuilder.RedefinitionStrategy.BatchAllocator) AgentBuilder.RedefinitionStrategy.BatchAllocator.ForTotal.INSTANCE));
     }
 
     @Test(expected = IllegalArgumentException.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/FieldDescriptionTokenTest.java
Patch:
@@ -11,6 +11,7 @@
 
 import java.util.Collections;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.matchesPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.when;
@@ -61,7 +62,7 @@ public void testVisitor() throws Exception {
 
     @Test
     public void testSignatureTokenTransformation() throws Exception {
-        when(type.accept(new TypeDescription.Generic.Visitor.Reducing(typeDescription))).thenReturn(rawType);
+        when(type.accept(matchesPrototype(new TypeDescription.Generic.Visitor.Reducing(typeDescription)))).thenReturn(rawType);
         assertThat(new FieldDescription.Token(FOO, MODIFIERS, type, Collections.singletonList(annotation)).asSignatureToken(typeDescription),
                 is(new FieldDescription.SignatureToken(FOO, rawType)));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionTokenTest.java
Patch:
@@ -13,6 +13,7 @@
 
 import java.util.Collections;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.matchesPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.when;
@@ -108,10 +109,10 @@ public void testVisitor() throws Exception {
 
     @Test
     public void testSignatureTokenTransformation() throws Exception {
-        when(returnType.accept(new TypeDescription.Generic.Visitor.Reducing(typeDescription, Collections.singletonList(typeVariableToken))))
+        when(returnType.accept(matchesPrototype(new TypeDescription.Generic.Visitor.Reducing(typeDescription, typeVariableToken))))
                 .thenReturn(rawReturnType);
         when(parameterToken.getType()).thenReturn(parameterType);
-        when(parameterType.accept(new TypeDescription.Generic.Visitor.Reducing(typeDescription, Collections.singletonList(typeVariableToken))))
+        when(parameterType.accept(matchesPrototype(new TypeDescription.Generic.Visitor.Reducing(typeDescription, typeVariableToken))))
                 .thenReturn(rawParameterType);
         assertThat(new MethodDescription.Token(FOO,
                         MODIFIERS,

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeInitializerTest.java
Patch:
@@ -12,6 +12,7 @@
 import org.mockito.Mock;
 import org.objectweb.asm.MethodVisitor;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.*;
@@ -38,7 +39,7 @@ public class TypeInitializerTest {
 
     @Test
     public void testNoneExpansion() throws Exception {
-        assertThat(TypeInitializer.None.INSTANCE.expandWith(byteCodeAppender), is((TypeInitializer) new TypeInitializer.Simple(byteCodeAppender)));
+        assertThat(TypeInitializer.None.INSTANCE.expandWith(byteCodeAppender), hasPrototype((TypeInitializer) new TypeInitializer.Simple(byteCodeAppender)));
     }
 
     @Test
@@ -62,7 +63,7 @@ public void testNoneWrap() throws Exception {
     @Test
     public void testSimpleExpansion() throws Exception {
         assertThat(new TypeInitializer.Simple(byteCodeAppender).expandWith(byteCodeAppender),
-                is((TypeInitializer) new TypeInitializer.Simple(new ByteCodeAppender.Compound(byteCodeAppender, byteCodeAppender))));
+                hasPrototype((TypeInitializer) new TypeInitializer.Simple(new ByteCodeAppender.Compound(byteCodeAppender, byteCodeAppender))));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassFileLocatorForModuleTest.java
Patch:
@@ -12,6 +12,7 @@
 
 import java.io.ByteArrayInputStream;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.junit.Assert.fail;
@@ -42,13 +43,13 @@ public void setUp() throws Exception {
     @Test
     public void testCreationNamed() throws Exception {
         when(module.isNamed()).thenReturn(true);
-        assertThat(ClassFileLocator.ForModule.of(module), is((ClassFileLocator) new ClassFileLocator.ForModule(module)));
+        assertThat(ClassFileLocator.ForModule.of(module), hasPrototype((ClassFileLocator) new ClassFileLocator.ForModule(module)));
     }
 
     @Test
     public void testCreationUnnamed() throws Exception {
         when(module.isNamed()).thenReturn(false);
-        assertThat(ClassFileLocator.ForModule.of(module), is((ClassFileLocator) new ClassFileLocator.ForClassLoader(classLoader)));
+        assertThat(ClassFileLocator.ForModule.of(module), hasPrototype((ClassFileLocator) new ClassFileLocator.ForClassLoader(classLoader)));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/TypeResolutionStrategyTest.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.Collections;
 import java.util.Map;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.matchesPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.*;
@@ -76,7 +77,7 @@ public void testActive() throws Exception {
         Field field = TypeResolutionStrategy.Active.Resolved.class.getDeclaredField("identification");
         field.setAccessible(true);
         int identification = (Integer) field.get(resolved);
-        when(typeInitializer.expandWith(new NexusAccessor.InitializationAppender(identification))).thenReturn(otherTypeInitializer);
+        when(typeInitializer.expandWith(matchesPrototype(new NexusAccessor.InitializationAppender(identification)))).thenReturn(otherTypeInitializer);
         assertThat(resolved.injectedInto(typeInitializer), is(otherTypeInitializer));
         assertThat(resolved.initialize(dynamicType, classLoader, classLoadingStrategy),
                 is(Collections.<TypeDescription, Class<?>>singletonMap(typeDescription, Foo.class)));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/FieldLocatorForClassHierarchyTest.java
Patch:
@@ -8,6 +8,7 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
 
@@ -71,7 +72,7 @@ public void testClassHierarchyNotFoundWrongType() throws Exception {
 
     @Test
     public void testFactory() throws Exception {
-        assertThat(FieldLocator.ForClassHierarchy.Factory.INSTANCE.make(typeDescription), is((FieldLocator) new FieldLocator.ForClassHierarchy(typeDescription)));
+        assertThat(FieldLocator.ForClassHierarchy.Factory.INSTANCE.make(typeDescription), hasPrototype((FieldLocator) new FieldLocator.ForClassHierarchy(typeDescription)));
     }
 
     @SuppressWarnings("unused")

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/FieldLocatorForExactTypeTest.java
Patch:
@@ -8,6 +8,7 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
 
@@ -57,7 +58,7 @@ public void testExactTypeNotFoundWrongType() throws Exception {
 
     @Test
     public void testFactory() throws Exception {
-        assertThat(new FieldLocator.ForExactType.Factory(locatedType).make(typeDescription), is((FieldLocator) new FieldLocator.ForExactType(locatedType, typeDescription)));
+        assertThat(new FieldLocator.ForExactType.Factory(locatedType).make(typeDescription), hasPrototype((FieldLocator) new FieldLocator.ForExactType(locatedType, typeDescription)));
     }
 
     @SuppressWarnings("unused")

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/FieldLocatorForTopLevelTypeTest.java
Patch:
@@ -8,6 +8,7 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
 
@@ -52,7 +53,7 @@ public void testExactTypeNotFoundWrongType() throws Exception {
 
     @Test
     public void testFactory() throws Exception {
-        assertThat(FieldLocator.ForTopLevelType.Factory.INSTANCE.make(typeDescription), is((FieldLocator) new FieldLocator.ForTopLevelType(typeDescription)));
+        assertThat(FieldLocator.ForTopLevelType.Factory.INSTANCE.make(typeDescription), hasPrototype((FieldLocator) new FieldLocator.ForTopLevelType(typeDescription)));
     }
 
     @SuppressWarnings("unused")

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultHarmonizerForJVMMethodTest.java
Patch:
@@ -11,6 +11,7 @@
 
 import java.util.Collections;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.not;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -68,7 +69,7 @@ public void testMethodParameterTypesEquality() throws Exception {
 
     @Test
     public void testFactory() throws Exception {
-        assertThat(MethodGraph.Compiler.Default.forJVMHierarchy(), is((MethodGraph.Compiler) new MethodGraph.Compiler
+        assertThat(MethodGraph.Compiler.Default.forJVMHierarchy(), hasPrototype((MethodGraph.Compiler) new MethodGraph.Compiler
                 .Default<MethodGraph.Compiler.Default.Harmonizer.ForJVMMethod.Token>(MethodGraph.Compiler.Default.Harmonizer.ForJVMMethod.INSTANCE,
                 MethodGraph.Compiler.Default.Merger.Directional.LEFT, TypeDescription.Generic.Visitor.Reifying.INITIATING)));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultHarmonizerForJavaMethodTest.java
Patch:
@@ -11,6 +11,7 @@
 
 import java.util.Collections;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.not;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -72,7 +73,7 @@ public void testMethodParameterTypesEquality() throws Exception {
 
     @Test
     public void testFactory() throws Exception {
-        assertThat(MethodGraph.Compiler.Default.forJavaHierarchy(), is((MethodGraph.Compiler) new MethodGraph.Compiler
+        assertThat(MethodGraph.Compiler.Default.forJavaHierarchy(), hasPrototype((MethodGraph.Compiler) new MethodGraph.Compiler
                 .Default<MethodGraph.Compiler.Default.Harmonizer.ForJavaMethod.Token>(MethodGraph.Compiler.Default.Harmonizer.ForJavaMethod.INSTANCE,
                 MethodGraph.Compiler.Default.Merger.Directional.LEFT, TypeDescription.Generic.Visitor.Reifying.INITIATING)));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphSimpleTest.java
Patch:
@@ -10,6 +10,7 @@
 
 import java.util.Collections;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.when;
@@ -33,12 +34,12 @@ public void setUp() throws Exception {
     @Test
     public void testNodeList() throws Exception {
         assertThat(MethodGraph.Simple.of(Collections.singletonList(methodDescription)).listNodes().getOnly(),
-                is((MethodGraph.Node) new MethodGraph.Node.Simple(methodDescription)));
+                hasPrototype((MethodGraph.Node) new MethodGraph.Node.Simple(methodDescription)));
     }
 
     @Test
     public void testNodeLocation() throws Exception {
         assertThat(MethodGraph.Simple.of(Collections.singletonList(methodDescription)).locate(token),
-                is((MethodGraph.Node) new MethodGraph.Node.Simple(methodDescription)));
+                hasPrototype((MethodGraph.Node) new MethodGraph.Node.Simple(methodDescription)));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterMethodPoolRecordTest.java
Patch:
@@ -25,6 +25,7 @@
 
 import java.util.Collections;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.instanceOf;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -124,7 +125,7 @@ public void testSkippedMethod() throws Exception {
     @Test
     public void testSkippedMethodCannotBePrepended() throws Exception {
         when(methodDescription.getReturnType()).thenReturn(TypeDescription.Generic.OBJECT);
-        assertThat(new TypeWriter.MethodPool.Record.ForNonImplementedMethod(methodDescription).prepend(byteCodeAppender), is((TypeWriter.MethodPool.Record)
+        assertThat(new TypeWriter.MethodPool.Record.ForNonImplementedMethod(methodDescription).prepend(byteCodeAppender), hasPrototype((TypeWriter.MethodPool.Record)
                 new TypeWriter.MethodPool.Record.ForDefinedMethod.WithBody(methodDescription,
                         new ByteCodeAppender.Compound(byteCodeAppender, new ByteCodeAppender.Simple(DefaultValue.REFERENCE, MethodReturn.REFERENCE)))));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverDefaultTest.java
Patch:
@@ -19,6 +19,7 @@
 
 import java.util.Collections;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.matchesPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.not;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -64,10 +65,10 @@ public void setUp() throws Exception {
         when(methodDescription.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
         when(methodDescription.getReturnType()).thenReturn(TypeDescription.Generic.VOID);
         when(methodDescription.getInternalName()).thenReturn(FOO);
-        when(methodDescription.asToken(ElementMatchers.is(instrumentedType))).thenReturn(token);
+        when(methodDescription.asToken(matchesPrototype(ElementMatchers.is(instrumentedType)))).thenReturn(token);
         when(methodDescription.asSignatureToken()).thenReturn(signatureToken);
         when(instrumentedType.getDeclaredMethods()).thenReturn(new MethodList.Explicit<MethodDescription.InDefinedShape>(methodDescription));
-        when(otherMethod.asToken(ElementMatchers.is(instrumentedType))).thenReturn(otherToken);
+        when(otherMethod.asToken(matchesPrototype(ElementMatchers.is(instrumentedType)))).thenReturn(otherToken);
         when(methodNameTransformer.transform(methodDescription)).thenReturn(BAR);
         when(auxiliaryTypeNamingStrategy.name(instrumentedType)).thenReturn(QUX);
         when(classFileVersion.getMinorMajorVersion()).thenReturn(Opcodes.V1_6);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategyDefaultTest.java
Patch:
@@ -27,6 +27,7 @@
 
 import java.util.Collections;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.matchesPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.*;
@@ -71,7 +72,7 @@ public void setUp() throws Exception {
         when(superClass.getDeclaredMethods()).thenReturn(new MethodList.Explicit<MethodDescription.InGenericShape>(methodDescription));
         when(methodDescription.isConstructor()).thenReturn(true);
         when(methodDescription.isVisibleTo(instrumentedType)).thenReturn(true);
-        when(methodDescription.asToken(ElementMatchers.is(instrumentedType))).thenReturn(token);
+        when(methodDescription.asToken(matchesPrototype(ElementMatchers.is(instrumentedType)))).thenReturn(token);
         when(token.getName()).thenReturn(FOO);
         when(token.getModifiers()).thenReturn(MODIFIERS);
         when(token.getTypeVariableTokens()).thenReturn(new ByteCodeElement.Token.TokenList<TypeVariableToken>());

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDisabledTest.java
Patch:
@@ -15,6 +15,7 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.mock;
@@ -48,7 +49,7 @@ public void testFactory() throws Exception {
                 mock(AuxiliaryType.NamingStrategy.class),
                 mock(TypeInitializer.class),
                 classFileVersion,
-                mock(ClassFileVersion.class)), is((Implementation.Context.ExtractableView) new Implementation.Context.Disabled(instrumentedType, classFileVersion)));
+                mock(ClassFileVersion.class)), hasPrototype((Implementation.Context.ExtractableView) new Implementation.Context.Disabled(instrumentedType, classFileVersion)));
     }
 
     @Test(expected = IllegalStateException.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationOtherTest.java
Patch:
@@ -9,7 +9,7 @@
 
 import static net.bytebuddy.matcher.ElementMatchers.any;
 import static net.bytebuddy.matcher.ElementMatchers.isToString;
-import static org.hamcrest.CoreMatchers.is;
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.MatcherAssert.assertThat;
 
 public class MethodDelegationOtherTest {
@@ -62,7 +62,7 @@ public void testCannotDelegateToInstanceFieldFromStaticMethod() throws Exception
     public void testEmptyConfiguration() throws Exception {
         assertThat(MethodDelegation.withEmptyConfiguration()
                 .withBinders(TargetMethodAnnotationDrivenBinder.ParameterBinder.DEFAULTS)
-                .withResolvers(MethodDelegationBinder.AmbiguityResolver.DEFAULT), is(MethodDelegation.withDefaultConfiguration()));
+                .withResolvers(MethodDelegationBinder.AmbiguityResolver.DEFAULT), hasPrototype(MethodDelegation.withDefaultConfiguration()));
     }
 
     static class Foo {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/MethodDelegationBinderTerminationHandlerTest.java
Patch:
@@ -13,6 +13,7 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.*;
@@ -58,7 +59,7 @@ public void testReturning() throws Exception {
                 Assigner.Typing.STATIC,
                 source,
                 target);
-        assertThat(stackManipulation, is((StackManipulation) new StackManipulation.Compound(this.stackManipulation, MethodReturn.REFERENCE)));
+        assertThat(stackManipulation, hasPrototype((StackManipulation) new StackManipulation.Compound(this.stackManipulation, MethodReturn.REFERENCE)));
         verify(assigner).assign(genericTargetType, genericSourceType, Assigner.Typing.STATIC);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/ByteCodeAppenderSizeTest.java
Patch:
@@ -15,8 +15,9 @@ public void testMerge() throws Exception {
         ByteCodeAppender.Size right = new ByteCodeAppender.Size(BIGGER, LOWER);
         ByteCodeAppender.Size mergedLeft = left.merge(right);
         ByteCodeAppender.Size mergedRight = right.merge(left);
-        assertThat(mergedLeft, is(mergedRight));
         assertThat(mergedLeft.getOperandStackSize(), is(BIGGER));
         assertThat(mergedLeft.getLocalVariableSize(), is(BIGGER));
+        assertThat(mergedRight.getOperandStackSize(), is(BIGGER));
+        assertThat(mergedRight.getLocalVariableSize(), is(BIGGER));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/collection/ArrayAccessOtherTest.java
Patch:
@@ -8,6 +8,7 @@
 
 import java.util.Collections;
 
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.mock;
@@ -23,7 +24,7 @@ public void testVoidThrowsException() throws Exception {
     public void testForEach() throws Exception {
         StackManipulation stackManipulation = mock(StackManipulation.class);
         assertThat(ArrayAccess.REFERENCE.forEach(Collections.singletonList(stackManipulation)),
-                is((StackManipulation) new StackManipulation.Compound(new StackManipulation.Compound(Duplication.SINGLE,
+                hasPrototype((StackManipulation) new StackManipulation.Compound(new StackManipulation.Compound(Duplication.SINGLE,
                         IntegerConstant.forValue(0),
                         ArrayAccess.REFERENCE.new Loader(),
                         stackManipulation))));

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/AbstractFilterableListTest.java
Patch:
@@ -24,11 +24,11 @@ protected S asList(U... element) {
 
     protected S asList(U element) {
         return asList(Collections.singletonList(element));
-    };
+    }
 
     protected S emptyList() {
         return asList(Collections.<U>emptyList());
-    };
+    }
 
     protected abstract T asElement(U element);
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/LatentMatcherConjunctionTest.java
Patch:
@@ -9,6 +9,7 @@
 import org.mockito.Mock;
 
 import static net.bytebuddy.matcher.ElementMatchers.any;
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.when;
@@ -38,6 +39,6 @@ public void setUp() throws Exception {
     @SuppressWarnings("unchecked")
     public void testManifestation() throws Exception {
         assertThat(new LatentMatcher.Conjunction(left, right).resolve(typeDescription),
-                is((ElementMatcher) any().and((ElementMatcher) leftMatcher).and((ElementMatcher) rightMatcher)));
+                hasPrototype((ElementMatcher) any().and((ElementMatcher) leftMatcher).and((ElementMatcher) rightMatcher)));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/LatentMatcherDisjunctionTest.java
Patch:
@@ -9,6 +9,7 @@
 import org.mockito.Mock;
 
 import static net.bytebuddy.matcher.ElementMatchers.none;
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.when;
@@ -38,6 +39,6 @@ public void setUp() throws Exception {
     @SuppressWarnings("unchecked")
     public void testManifestation() throws Exception {
         assertThat(new LatentMatcher.Disjunction(left, right).resolve(typeDescription),
-                is((ElementMatcher) none().or((ElementMatcher) leftMatcher).or((ElementMatcher) rightMatcher)));
+                hasPrototype((ElementMatcher) none().or((ElementMatcher) leftMatcher).or((ElementMatcher) rightMatcher)));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/LatentMatcherForSelfDeclaredMethodTest.java
Patch:
@@ -9,6 +9,7 @@
 
 import static net.bytebuddy.matcher.ElementMatchers.isDeclaredBy;
 import static net.bytebuddy.matcher.ElementMatchers.not;
+import static net.bytebuddy.test.utility.FieldByFieldComparison.hasPrototype;
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
 
@@ -23,12 +24,12 @@ public class LatentMatcherForSelfDeclaredMethodTest {
     @Test
     @SuppressWarnings("unchecked")
     public void testDeclared() throws Exception {
-        assertThat(LatentMatcher.ForSelfDeclaredMethod.DECLARED.resolve(typeDescription), is((ElementMatcher) isDeclaredBy(typeDescription)));
+        assertThat(LatentMatcher.ForSelfDeclaredMethod.DECLARED.resolve(typeDescription), hasPrototype((ElementMatcher) isDeclaredBy(typeDescription)));
     }
 
     @Test
     @SuppressWarnings("unchecked")
     public void testNotDeclared() throws Exception {
-        assertThat(LatentMatcher.ForSelfDeclaredMethod.NOT_DECLARED.resolve(typeDescription), is((ElementMatcher) not(isDeclaredBy(typeDescription))));
+        assertThat(LatentMatcher.ForSelfDeclaredMethod.NOT_DECLARED.resolve(typeDescription), hasPrototype((ElementMatcher) not(isDeclaredBy(typeDescription))));
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/EqualsMethod.java
Patch:
@@ -12,7 +12,6 @@
 import net.bytebuddy.implementation.bytecode.StackSize;
 import net.bytebuddy.implementation.bytecode.assign.InstanceCheck;
 import net.bytebuddy.implementation.bytecode.assign.TypeCasting;
-import net.bytebuddy.implementation.bytecode.constant.ClassConstant;
 import net.bytebuddy.implementation.bytecode.constant.IntegerConstant;
 import net.bytebuddy.implementation.bytecode.member.FieldAccess;
 import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
@@ -219,9 +218,10 @@ public StackManipulation resolve(TypeDescription instrumentedType) {
                 return new StackManipulation.Compound(
                         MethodVariableAccess.REFERENCE.loadFrom(1),
                         ConditionalReturn.onNullValue(),
+                        MethodVariableAccess.REFERENCE.loadFrom(0),
+                        MethodInvocation.invoke(GET_CLASS),
                         MethodVariableAccess.REFERENCE.loadFrom(1),
                         MethodInvocation.invoke(GET_CLASS),
-                        ClassConstant.of(instrumentedType),
                         ConditionalReturn.onNonIdentity()
                 );
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/EqualsMethod.java
Patch:
@@ -119,7 +119,7 @@ public static EqualsMethod isolated() {
      * @return A new version of this equals method implementation that also ignores any fields matched by the provided matcher.
      */
     public EqualsMethod withIgnoredFields(ElementMatcher<? super FieldDescription.InDefinedShape> ignored) {
-        return new EqualsMethod(superClassCheck, typeCompatibilityCheck, this.ignored.or(ignored), nonNullable);
+        return new EqualsMethod(superClassCheck, typeCompatibilityCheck, this.ignored.<FieldDescription.InDefinedShape>or(ignored), nonNullable);
     }
 
     /**
@@ -131,7 +131,7 @@ public EqualsMethod withIgnoredFields(ElementMatcher<? super FieldDescription.In
      * the provided matcher.
      */
     public EqualsMethod withNonNullableFields(ElementMatcher<? super FieldDescription.InDefinedShape> nonNullable) {
-        return new EqualsMethod(superClassCheck, typeCompatibilityCheck, ignored, this.nonNullable.or(nonNullable));
+        return new EqualsMethod(superClassCheck, typeCompatibilityCheck, ignored, this.nonNullable.<FieldDescription.InDefinedShape>or(nonNullable));
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/HashCodeMethod.java
Patch:
@@ -132,7 +132,7 @@ public static HashCodeMethod usingOffset(int value) {
      * @return A new version of this hash code method implementation that also ignores any fields matched by the provided matcher.
      */
     public HashCodeMethod withIgnoredFields(ElementMatcher<? super FieldDescription.InDefinedShape> ignored) {
-        return new HashCodeMethod(offsetProvider, multiplier, this.ignored.or(ignored), nonNullable);
+        return new HashCodeMethod(offsetProvider, multiplier, this.ignored.<FieldDescription.InDefinedShape>or(ignored), nonNullable);
     }
 
     /**
@@ -144,7 +144,7 @@ public HashCodeMethod withIgnoredFields(ElementMatcher<? super FieldDescription.
      * the provided matcher.
      */
     public HashCodeMethod withNonNullableFields(ElementMatcher<? super FieldDescription.InDefinedShape> nonNullable) {
-        return new HashCodeMethod(offsetProvider, multiplier, ignored, this.nonNullable.or(nonNullable));
+        return new HashCodeMethod(offsetProvider, multiplier, ignored, this.nonNullable.<FieldDescription.InDefinedShape>or(nonNullable));
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/ToStringMethod.java
Patch:
@@ -167,7 +167,7 @@ public static ToStringMethod prefixedBy(PrefixResolver prefixResolver) {
      * @return A new version of this toString method implementation that also ignores any fields matched by the provided matcher.
      */
     public ToStringMethod withIgnoredFields(ElementMatcher<? super FieldDescription.InDefinedShape> ignored) {
-        return new ToStringMethod(prefixResolver, start, end, separator, definer, this.ignored.or(ignored));
+        return new ToStringMethod(prefixResolver, start, end, separator, definer, this.ignored.<FieldDescription.InDefinedShape>or(ignored));
     }
 
     /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/EqualsMethodTest.java
Patch:
@@ -4,11 +4,9 @@
 import net.bytebuddy.description.modifier.Visibility;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
-import net.bytebuddy.test.utility.DebuggingWrapper;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
-import sun.security.ssl.Debug;
 
 import java.util.Arrays;
 import java.util.Collection;

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceNoRegularReturnTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
-import net.bytebuddy.test.utility.DebuggingWrapper;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -47,7 +46,6 @@ public static Collection<Object[]> data() {
     public void testNoRegularReturnWithSkip() throws Exception {
         Class<?> type = new ByteBuddy()
                 .redefine(this.type)
-                .visit(DebuggingWrapper.makeDefault(false))
                 .visit(Advice.to(EnterAdviceSkip.class).on(named(FOO)))
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -4137,6 +4137,7 @@ protected ForAdvice(MethodDescription.InDefinedShape adviceMethod,
                     this.startTypes = startTypes;
                     this.endTypes = endTypes;
                     stackSize = Math.max(stackSize, adviceMethod.getReturnType().getStackSize().getSize());
+                    localVariableLength = Math.max(localVariableLength, instrumentedMethod.getStackSize() + adviceMethod.getReturnType().getStackSize().getSize());
                 }
 
                 @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceNoRegularReturnTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
+import net.bytebuddy.test.utility.DebuggingWrapper;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -46,6 +47,7 @@ public static Collection<Object[]> data() {
     public void testNoRegularReturnWithSkip() throws Exception {
         Class<?> type = new ByteBuddy()
                 .redefine(this.type)
+                .visit(DebuggingWrapper.makeDefault(false))
                 .visit(Advice.to(EnterAdviceSkip.class).on(named(FOO)))
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -364,7 +364,7 @@ public static synchronized Instrumentation install(AttachmentProvider attachment
     private static void install(AttachmentProvider attachmentProvider, String processId, String argument, AgentProvider agentProvider) {
         AttachmentProvider.Accessor attachmentAccessor = attachmentProvider.attempt();
         if (!attachmentAccessor.isAvailable()) {
-            throw new IllegalStateException("No compatible attachment provider is not available");
+            throw new IllegalStateException("No compatible attachment provider is available");
         }
         try {
             if (ATTACHMENT_TYPE_EVALUATOR.requiresExternalAttachment(processId)) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -488,6 +488,7 @@ public ByteCodeAppender appender(Target implementationTarget) {
     }
 
     public enum ToStringAssigner implements Assigner {
+
         INSTANCE;
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/EqualsMethod.java
Patch:
@@ -1,6 +1,5 @@
 package net.bytebuddy.implementation;
 
-import jdk.nashorn.internal.codegen.types.Type;
 import lombok.EqualsAndHashCode;
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.description.field.FieldDescription;
@@ -23,6 +22,7 @@
 import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
 
 import java.util.ArrayList;
 import java.util.List;

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/Initialization.java
Patch:
@@ -33,12 +33,12 @@ public static Initialization makeDefault() {
      * @param groupId             This project's group id.
      * @param artifactId          This project's artifact id.
      * @param version             This project's version id.
-     * @param packing             This project's packing
+     * @param packaging             This project's packaging
      * @return The resolved entry point.
      * @throws MojoExecutionException If the entry point cannot be created.
      */
     @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Applies Maven exception wrapper")
-    public EntryPoint getEntryPoint(ClassLoaderResolver classLoaderResolver, String groupId, String artifactId, String version, String packing) throws MojoExecutionException {
+    public EntryPoint getEntryPoint(ClassLoaderResolver classLoaderResolver, String groupId, String artifactId, String version, String packaging) throws MojoExecutionException {
         if (entryPoint == null || entryPoint.isEmpty()) {
             throw new MojoExecutionException("Entry point name is not defined");
         }
@@ -48,7 +48,7 @@ public EntryPoint getEntryPoint(ClassLoaderResolver classLoaderResolver, String
             }
         }
         try {
-            return (EntryPoint) Class.forName(entryPoint, false, classLoaderResolver.resolve(asCoordinate(groupId, artifactId, version, packing)))
+            return (EntryPoint) Class.forName(entryPoint, false, classLoaderResolver.resolve(asCoordinate(groupId, artifactId, version, packaging)))
                     .getDeclaredConstructor()
                     .newInstance();
         } catch (Exception exception) {

File: byte-buddy-maven-plugin/src/test/java/net/bytebuddy/build/maven/ByteBuddyMojoTest.java
Patch:
@@ -38,7 +38,7 @@
 
 public class ByteBuddyMojoTest {
 
-    private static final String FOO = "foo", BAR = "bar", QUX = "qux", TEMP = "tmp";
+    private static final String FOO = "foo", BAR = "bar", QUX = "qux", TEMP = "tmp", JAR = "jar";
 
     @Rule
     public MojoRule mojoRule = new MojoRule();
@@ -285,6 +285,7 @@ private void execute(String goal, String target) throws Exception {
             mojoRule.setVariableValueToObject(mojo, "groupId", FOO);
             mojoRule.setVariableValueToObject(mojo, "artifactId", BAR);
             mojoRule.setVariableValueToObject(mojo, "version", QUX);
+            mojoRule.setVariableValueToObject(mojo, "packaging", JAR);
             mojo.setLog(new SilentLog());
             mojo.execute();
         } finally {

File: byte-buddy-maven-plugin/src/test/java/net/bytebuddy/build/maven/InitializationTest.java
Patch:
@@ -34,11 +34,11 @@ public void testResolved() throws Exception {
         initalization.groupId = BAR;
         initalization.artifactId = QUX;
         initalization.version = BAZ;
-        initalization.packing = JAR;
+        initalization.packaging = JAR;
         assertThat(initalization.getGroupId(FOO), is(BAR));
         assertThat(initalization.getArtifactId(FOO), is(QUX));
         assertThat(initalization.getVersion(FOO), is(BAZ));
-        assertThat(initalization.getPacking(JAR), is(JAR));
+        assertThat(initalization.getPackaging(JAR), is(JAR));
     }
 
     @Test

File: byte-buddy-maven-plugin/src/test/java/net/bytebuddy/build/maven/MavenCoordinateTest.java
Patch:
@@ -14,14 +14,14 @@ public class MavenCoordinateTest {
 
     @Test
     public void testAsArtifact() throws Exception {
-        Artifact artifact = new MavenCoordinate(FOO, BAR, QUX,JAR).asArtifact();
+        Artifact artifact = new MavenCoordinate(FOO, BAR, QUX, JAR).asArtifact();
         assertThat(artifact.getGroupId(), is(FOO));
         assertThat(artifact.getArtifactId(), is(BAR));
         assertThat(artifact.getVersion(), is(QUX));
         assertThat(artifact.getExtension(), is(JAR));
     }
 
-    @Test @Ignore
+    @Test
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(MavenCoordinate.class).apply();
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -7486,7 +7486,7 @@ public void visitMaxs(int stackSize, int localVariableLength) {
 
         @Override
         public void visitLocalVariable(String name, String descriptor, String signature, Label start, Label end, int index) {
-            mv.visitLocalVariable(name, descriptor, signature, start, end, argumentHandler.argument(index)); // TODO: Index is not offset?
+            mv.visitLocalVariable(name, descriptor, signature, start, end, argumentHandler.variable(index));
         }
 
         @Override
@@ -7499,9 +7499,9 @@ public AnnotationVisitor visitLocalVariableAnnotation(int typeReference,
                                                               boolean visible) {
             int[] translated = new int[index.length];
             for (int anIndex = 0; anIndex < index.length; anIndex++) {
-                translated[anIndex] = argumentHandler.argument(index[anIndex]);
+                translated[anIndex] = argumentHandler.variable(index[anIndex]);
             }
-            return mv.visitLocalVariableAnnotation(typeReference, typePath, start, end, translated, descriptor, visible); // TODO: Index is not offset?
+            return mv.visitLocalVariableAnnotation(typeReference, typePath, start, end, translated, descriptor, visible);
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/OffsetHandler.java
Patch:
@@ -189,9 +189,9 @@ public int prepare(MethodVisitor methodVisitor) {
 
         @Override
         public int argument(int offset) {
-            return offset > instrumentedMethod.getStackSize()
-                    ? offset + enterType.getStackSize().getSize()
-                    : offset;
+            return offset < instrumentedMethod.getStackSize()
+                    ? offset
+                    : offset + enterType.getStackSize().getSize();
         }
 
         @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceOffsetHandlerTest.java
Patch:
@@ -18,7 +18,6 @@ public class AdviceOffsetHandlerTest {
     public void testShortMethod() throws Exception {
         Class<?> type = new ByteBuddy()
                 .redefine(ShortMethod.class)
-                .visit(DebuggingWrapper.makeDefault(true))
                 .visit(Advice.to(EmptyAdvice.class).on(named(FOO)).readerFlags(ClassReader.SKIP_DEBUG))
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -535,7 +535,6 @@ public void testAdviceWithOptionalThisReferenceOptional() throws Exception {
     public void testAdviceWithEntranceValue() throws Exception {
         Class<?> type = new ByteBuddy()
                 .redefine(Sample.class)
-                .visit(DebuggingWrapper.makeDefault(false))
                 .visit(Advice.to(EntranceValueAdvice.class).on(named(FOO)))
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -7416,7 +7416,7 @@ protected void onUserEnd() {
                 if (doesReturn) {
                     stackMapFrameHandler.injectReturnFrame(methodVisitor);
                     if (!returnType.equals(Type.VOID_TYPE)) {
-                        methodVisitor.visitVarInsn(returnType.getOpcode(Opcodes.ISTORE), offsetHandler.enter());
+                        methodVisitor.visitVarInsn(returnType.getOpcode(Opcodes.ISTORE), offsetHandler.returned());
                     }
                 }
                 onUserReturn();
@@ -7425,7 +7425,7 @@ protected void onUserEnd() {
                 if (returnType.equals(Type.VOID_TYPE)) {
                     methodVisitor.visitInsn(Opcodes.RETURN);
                 } else {
-                    methodVisitor.visitVarInsn(returnType.getOpcode(Opcodes.ILOAD), offsetHandler.enter());
+                    methodVisitor.visitVarInsn(returnType.getOpcode(Opcodes.ILOAD), offsetHandler.returned());
                     methodVisitor.visitInsn(returnType.getOpcode(Opcodes.IRETURN));
                 }
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -1743,7 +1743,7 @@ public Target resolve(TypeDescription instrumentedType, MethodDescription instru
                         throw new IllegalStateException("Cannot assign " + parameterDescription + " to " + target);
                     }
                     valueReads.add(new StackManipulation.Compound(MethodVariableAccess.of(parameterDescription.getType())
-                            .loadFrom(offsetHandler.argument(parameterDescription.getIndex())), readAssignment));
+                            .loadFrom(offsetHandler.argument(parameterDescription.getOffset())), readAssignment));
                 }
                 if (readOnly) {
                     return new Target.ForArray.ReadOnly(target, valueReads);
@@ -1755,7 +1755,7 @@ public Target resolve(TypeDescription instrumentedType, MethodDescription instru
                             throw new IllegalStateException("Cannot assign " + target + " to " + parameterDescription);
                         }
                         valueWrites.add(new StackManipulation.Compound(writeAssignment, MethodVariableAccess.of(parameterDescription.getType())
-                                .storeAt(offsetHandler.argument(parameterDescription.getIndex()))));
+                                .storeAt(offsetHandler.argument(parameterDescription.getOffset()))));
                     }
                     return new Target.ForArray.ReadWrite(target, valueReads, valueWrites);
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/OffsetHandler.java
Patch:
@@ -189,9 +189,9 @@ public int prepare(MethodVisitor methodVisitor) {
 
         @Override
         public int argument(int offset) {
-            return offset < instrumentedMethod.getStackSize()
-                    ? offset
-                    : offset + enterType.getStackSize().getSize();
+            return offset > instrumentedMethod.getStackSize()
+                    ? offset + enterType.getStackSize().getSize()
+                    : offset;
         }
 
         @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -12,6 +12,7 @@
 import net.bytebuddy.implementation.bytecode.constant.TextConstant;
 import net.bytebuddy.matcher.ElementMatchers;
 import net.bytebuddy.pool.TypePool;
+import net.bytebuddy.test.utility.DebuggingWrapper;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 import org.mockito.Mockito;
@@ -534,6 +535,7 @@ public void testAdviceWithOptionalThisReferenceOptional() throws Exception {
     public void testAdviceWithEntranceValue() throws Exception {
         Class<?> type = new ByteBuddy()
                 .redefine(Sample.class)
+                .visit(DebuggingWrapper.makeDefault(false))
                 .visit(Advice.to(EntranceValueAdvice.class).on(named(FOO)))
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -7143,6 +7143,7 @@ protected AdviceVisitor(MethodVisitor methodVisitor,
             List<TypeDescription> enterTypes = methodEnter.getEnterType().represents(void.class)
                     ? Collections.<TypeDescription>emptyList()
                     : Collections.singletonList(methodEnter.getEnterType().asErasure());
+            OffsetHandler offsetHandler = OffsetHandler.Factory.of(methodExit.isCopyArguments()).make(instrumentedMethod);
             methodSizeHandler = MethodSizeHandler.Default.of(instrumentedMethod, enterTypes, exitTypes, writerFlags);
             stackMapFrameHandler = StackMapFrameHandler.Default.of(instrumentedType,
                     instrumentedMethod,
@@ -7151,7 +7152,6 @@ protected AdviceVisitor(MethodVisitor methodVisitor,
                     implementationContext.getClassFileVersion(),
                     writerFlags,
                     readerFlags);
-            OffsetHandler offsetHandler = OffsetHandler.Factory.of(methodExit.isCopyArguments()).make(instrumentedMethod);
             this.methodEnter = methodEnter.bind(instrumentedType,
                     instrumentedMethod,
                     methodVisitor,

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/ByteBuddyMojo.java
Patch:
@@ -278,7 +278,7 @@ private ExecutionStatus transform(File root,
             } catch (Throwable throwable) {
                 throw new MojoExecutionException("Cannot create Byte Buddy instance", throwable);
             }
-            ExecutionStatus processDirectoryStatus = processDirectory(root,
+            return processDirectory(root,
                     root,
                     byteBuddy,
                     entryPoint,
@@ -288,7 +288,6 @@ private ExecutionStatus transform(File root,
                     classFileLocator,
                     typePool,
                     plugins);
-            return processDirectoryStatus;
         } finally {
             classFileLocator.close();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -70,7 +70,7 @@
  * <pre>
  * ByteBuddy byteBuddy = new ByteBuddy();
  * byteBuddy.foo()</pre>
- * Instead, the following method chain is corrent use of the API:
+ * Instead, the following method chain is correct use of the API:
  * <pre>
  * ByteBuddy byteBuddy = new ByteBuddy().foo();</pre>
  * <p>

File: byte-buddy-dep/src/main/java/net/bytebuddy/TypeCache.java
Patch:
@@ -206,7 +206,7 @@ protected Reference<Class<?>> wrap(Class<?> type) {
         };
 
         /**
-         * Wrapes a type as a {@link Reference}.
+         * Wraps a type as a {@link Reference}.
          *
          * @param type The type to wrap.
          * @return The reference that represents the type.
@@ -314,7 +314,7 @@ public boolean equals(Object other) {
     public static class WithInlineExpunction<S> extends TypeCache<S> {
 
         /**
-         * Creats a new type cache with inlined expunction.
+         * Creates a new type cache with inlined expunction.
          *
          * @param sort The reference type to use for stored types.
          */

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/AsmVisitorWrapper.java
Patch:
@@ -58,7 +58,7 @@ public interface AsmVisitorWrapper {
      * @param implementationContext The implementation context of the current instrumentation.
      * @param typePool              The type pool that was provided for the class creation.
      * @param fields                The instrumented type's fields.
-     * @param methods               The instrumented type's methods non-ingored declared and virtually inherited methods.
+     * @param methods               The instrumented type's methods non-ignored declared and virtually inherited methods.
      * @param writerFlags           The ASM {@link org.objectweb.asm.ClassWriter} flags to consider.
      * @param readerFlags           The ASM {@link org.objectweb.asm.ClassReader} flags to consider.
      * @return A new {@code ClassVisitor} that usually delegates to the {@code ClassVisitor} delivered in the argument.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -36,7 +36,7 @@
 public interface AnnotationDescription {
 
     /**
-     * Indicates an inexistent annotation in a type-safe manner.
+     * Indicates a nonexistent annotation in a type-safe manner.
      */
     AnnotationDescription.Loadable<?> UNDEFINED = null;
 
@@ -540,7 +540,7 @@ class ForLoadedAnnotation<S extends Annotation> extends AbstractBase.ForPrepared
 
         /**
          * The annotation's loaded type which might be loaded by a different class loader than the value's
-         * annotation type but must be structually equal to it.
+         * annotation type but must be structurally equal to it.
          */
         private final Class<S> annotationType;
 
@@ -559,7 +559,7 @@ protected ForLoadedAnnotation(S annotation) {
          *
          * @param annotation     The annotation to represent.
          * @param annotationType The annotation's loaded type which might be loaded by a different class loader than the value's
-         *                       annotation type but must be structually equal to it.
+         *                       annotation type but must be structurally equal to it.
          */
         private ForLoadedAnnotation(S annotation, Class<S> annotationType) {
             this.annotation = annotation;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/package-info.java
Patch:
@@ -1,6 +1,6 @@
 /**
  * Classes of this package allow the representation of Java classes, their member and their meta data. Using the
  * reflection API, it would be required to load classes but by using these descriptions, it is possible to
- * represent byte code elements without pripor loading.
+ * represent byte code elements without prior loading.
  */
 package net.bytebuddy.description;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -397,7 +397,7 @@ protected OfTypeVariables(List<TypeVariable<?>> typeVariables) {
                  * Creates a list of the type variables of the supplied generic declaration.
                  *
                  * @param genericDeclaration The generic declaration to represent.
-                 * @return A genric type list for the returned generic declaration.
+                 * @return A generic type list for the returned generic declaration.
                  */
                 public static Generic of(GenericDeclaration genericDeclaration) {
                     return new OfTypeVariables(genericDeclaration.getTypeParameters());
@@ -525,7 +525,7 @@ public static class WithResolvedErasure extends Generic.AbstractBase {
 
                 /**
                  * Creates a list of generic type descriptions that are resolved lazily, i.e. type variables are not resolved
-                 * when computing an erausre.
+                 * when computing an erasure.
                  *
                  * @param detachedTypes The detached types this list represents.
                  * @param visitor       The visitor to use for attaching the detached types.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -778,7 +778,7 @@ public static ClassFileLocator ofModulePath() throws IOException {
         /**
          * <p>
          * Resolves a class file locator for a Java module path that reads class files directly from the file system. All
-         * elements of the module path are resolved releatively to this VM's {@code user.dir}.
+         * elements of the module path are resolved relative to this VM's {@code user.dir}.
          * </p>
          * <p>
          * <b>Note</b>: The resulting class file locator does not include classes of the bootstrap class loader.
@@ -1156,7 +1156,7 @@ protected interface Dispatcher {
                     Vector<Class<?>> extract(ClassLoader classLoader);
 
                     /**
-                     * An unitialized version of a dispatcher for extracting a class loader's loaded classes.
+                     * An uninitialized version of a dispatcher for extracting a class loader's loaded classes.
                      */
                     interface Initializable {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/NexusAccessor.java
Patch:
@@ -53,7 +53,7 @@ public NexusAccessor() {
     }
 
     /**
-     * Creates a new accessor for a {@link Nexus} where any GC eligible are enqueued to the supplid reference queue. Any such enqueued
+     * Creates a new accessor for a {@link Nexus} where any GC eligible are enqueued to the supplied reference queue. Any such enqueued
      * reference can be explicitly removed from the nexus via the {@link NexusAccessor#clean(Reference)} method. Nexus entries can
      * become stale if a class loader is garbage collected after a class was loaded but before a class was initialized.
      *

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/Transformer.java
Patch:
@@ -83,7 +83,7 @@ public ForField(Transformer<FieldDescription.Token> transformer) {
         }
 
         /**
-         * Creates a field transformer that patches the transformed field by the givien modifier contributors.
+         * Creates a field transformer that patches the transformed field by the given modifier contributors.
          *
          * @param modifierContributor The modifier contributors to apply.
          * @return A suitable field transformer.
@@ -93,7 +93,7 @@ public static Transformer<FieldDescription> withModifiers(ModifierContributor.Fo
         }
 
         /**
-         * Creates a field transformer that patches the transformed field by the givien modifier contributors.
+         * Creates a field transformer that patches the transformed field by the given modifier contributors.
          *
          * @param modifierContributors The modifier contributors to apply.
          * @return A suitable field transformer.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -279,7 +279,7 @@ interface Initializable {
                 /**
                  * Initializes this dispatcher.
                  *
-                 * @return The initiailized dispatcher.
+                 * @return The initialized dispatcher.
                  */
                 Dispatcher initialize();
             }
@@ -290,7 +290,7 @@ interface Initializable {
             enum CreationAction implements PrivilegedAction<Initializable> {
 
                 /**
-                 * The singelton instance.
+                 * The singleton instance.
                  */
                 INSTANCE;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategy.java
Patch:
@@ -359,7 +359,7 @@ class UsingLookup implements ClassLoadingStrategy<ClassLoader> {
         private final ClassLoader classLoader;
 
         /**
-         * Creaes a new class loading strategy that uses a lookup type.
+         * Creates a new class loading strategy that uses a lookup type.
          *
          * @param classInjector The class injector to use.
          * @param classLoader   The class loader in the supplied class injector defines classes.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1416,7 +1416,7 @@ abstract class Default<S> implements TypeWriter<S> {
          * @param fieldPool                    The field pool to use.
          * @param auxiliaryTypes               The explicit auxiliary types to add to the created type.
          * @param fields                       The instrumented type's declared fields.
-         * @param methods                      The instrumented type's declared and virtually inhertied methods.
+         * @param methods                      The instrumented type's declared and virtually inherited methods.
          * @param instrumentedMethods          The instrumented methods relevant to this type creation.
          * @param loadedTypeInitializer        The loaded type initializer to apply onto the created type after loading.
          * @param typeInitializer              The type initializer to include in the created type's type initializer.
@@ -3198,7 +3198,7 @@ public void complete(ClassVisitor classVisitor, Implementation.Context.Extractab
                     }
 
                     /**
-                     * A frame writer is responsible for adding empty frames on jumo instructions.
+                     * A frame writer is responsible for adding empty frames on jump instructions.
                      */
                     protected interface FrameWriter {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolver.java
Patch:
@@ -27,7 +27,7 @@
  * This way a method can exist in two versions within a class:
  * <ol>
  * <li>The rebased method which represents the original implementation as it is present in a class file.</li>
- * <li>An overriden method which implements user code which is still able to invoke the original, rebased method.</li>
+ * <li>An overridden method which implements user code which is still able to invoke the original, rebased method.</li>
  * </ol>
  */
 public interface MethodRebaseResolver {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -467,7 +467,7 @@ public interface OwnerTypeLocatable extends AssignerConfigurable {
     }
 
     /**
-     * A field accessor for an implicit property where a getter or setter property is infered from the signature.
+     * A field accessor for an implicit property where a getter or setter property is inferred from the signature.
      */
     protected static class ForImplicitProperty extends FieldAccessor implements OwnerTypeLocatable {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -2829,7 +2829,7 @@ protected static class OfArgument extends WithImplicitType {
              * @param terminationHandler A handler that handles the method return.
              * @param assigner           The assigner to be used.
              * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
-             * @param index              The index of of the argument to supply to the bootstapped method.
+             * @param index              The index of of the argument to supply to the bootstrapped method.
              */
             protected OfArgument(MethodDescription.InDefinedShape bootstrapMethod,
                                  List<?> handleArguments,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -1902,7 +1902,7 @@ public <T> MethodCall on(T target, Class<? super T> type) {
          * Invokes the specified method on the instrumented method's argument of the given index.
          *
          * @param index The index of the method's argument on which the specified method should be invoked.
-         * @return Amethod call that invokes the provided method on the given method argument.
+         * @return A method call that invokes the provided method on the given method argument.
          */
         public MethodCall onArgument(int index) {
             if (index < 0) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationAppender.java
Patch:
@@ -364,7 +364,7 @@ class ForTypeAnnotations implements TypeDescription.Generic.Visitor<AnnotationAp
         private static final char INNER_CLASS_PATH = '.';
 
         /**
-         * Represents an index tzpe delimiter within a type path.
+         * Represents an index type delimiter within a type path.
          */
         private static final char INDEXED_TYPE_DELIMITER = ';';
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/ArgumentTypeResolver.java
Patch:
@@ -18,7 +18,7 @@
  * type is considered as dominant.</li>
  * <li>If this result is dominant for both the left and the right target method, this resolver will consider the binding as
  * ambiguous.</li>
- * <li>If none of the methods is dominant and if the comparison did not result in an ambigous resolution, the method that
+ * <li>If none of the methods is dominant and if the comparison did not result in an ambiguous resolution, the method that
  * consists of the most one-to-one parameter bindings is considered dominant.</li>
  * </ol>
  * Primitive types are considered dominant in the same manner as by the Java compiler.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/MethodDelegationBinder.java
Patch:
@@ -46,7 +46,7 @@ interface Record {
          *
          * @param implementationTarget The target of the current implementation onto which this binding is to be applied.
          * @param source               The method that is to be bound to the {@code target} method.
-         * @param terminationHandler   Ther termination handler to apply.
+         * @param terminationHandler   The termination handler to apply.
          * @param methodInvoker        The method invoker to use.
          * @param assigner             The assigner to use.
          * @return A binding representing this attempt to bind the {@code source} method to the {@code target} method.
@@ -639,7 +639,7 @@ public MethodBinding resolve(AmbiguityResolver ambiguityResolver, MethodDescript
         }
 
         /**
-         * Bindinds a method using another resolver and prints the selected binding to a {@link PrintStream}.
+         * Binds a method using another resolver and prints the selected binding to a {@link PrintStream}.
          */
         @EqualsAndHashCode
         class StreamWriting implements BindingResolver {
@@ -968,7 +968,7 @@ public StackManipulation resolve(Assigner assigner, Assigner.Typing typing, Meth
     }
 
     /**
-     * A helper class that allows to identify a best binding for a given type and source method chosing from a list of given
+     * A helper class that allows to identify a best binding for a given type and source method choosing from a list of given
      * target methods by using a given {@link net.bytebuddy.implementation.bind.MethodDelegationBinder}
      * and an {@link net.bytebuddy.implementation.bind.MethodDelegationBinder.AmbiguityResolver}.
      * <p>&nbsp;</p>

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -295,9 +295,9 @@ protected MethodDelegationBinder.ParameterBinding<?> bind(FieldDescription field
         protected interface FieldResolver {
 
             /**
-             * Returns {@code true} if the field access can be establised.
+             * Returns {@code true} if the field access can be established.
              *
-             * @return {@code true} if the field access can be establised.
+             * @return {@code true} if the field access can be established.
              */
             boolean isResolved();
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Super.java
Patch:
@@ -47,7 +47,7 @@
  * proxy by default. If this is absolutely necessary, this can however be enabled by setting {@link Super#ignoreFinalizer()}
  * to {@code false}.
  * <p>&nbsp;</p>
- * If a method parameter is not a super type of the instrumented type, the method with the parameter that is annoted by
+ * If a method parameter is not a super type of the instrumented type, the method with the parameter that is annotated by
  * #{@code Super} is not considered a possible delegation target.
  *
  * @see net.bytebuddy.implementation.MethodDelegation

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperMethod.java
Patch:
@@ -40,7 +40,7 @@
     boolean cached() default true;
 
     /**
-     * Indicates that the assigned method should attemt the invocation of an unambiguous default method if no super method is available.
+     * Indicates that the assigned method should attempt the invocation of an unambiguous default method if no super method is available.
      *
      * @return {@code true} if a default method should be invoked if it is not ambiguous and no super class method is available.
      */

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -37,7 +37,7 @@ public class TargetMethodAnnotationDrivenBinder implements MethodDelegationBinde
     /**
      * Creates a new target method annotation-driven binder.
      *
-     * @param delegationProcessor The delegation proessor to use.
+     * @param delegationProcessor The delegation processor to use.
      */
     protected TargetMethodAnnotationDrivenBinder(DelegationProcessor delegationProcessor) {
         this.delegationProcessor = delegationProcessor;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveBoxingDelegate.java
Patch:
@@ -96,7 +96,7 @@ public enum PrimitiveBoxingDelegate {
      * Locates a boxing delegate for a given primitive type.
      *
      * @param typeDefinition A non-void primitive type.
-     * @return A delegate capable of boxing the given primitve type.
+     * @return A delegate capable of boxing the given primitive type.
      */
     public static PrimitiveBoxingDelegate forPrimitive(TypeDefinition typeDefinition) {
         if (typeDefinition.represents(boolean.class)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/FieldConstant.java
Patch:
@@ -33,7 +33,7 @@ public FieldConstant(FieldDescription.InDefinedShape fieldDescription) {
     }
 
     /**
-     * Retruns a cached version of this field constant.
+     * Returns a cached version of this field constant.
      *
      * @return A cached version of this field constant.
      */

File: byte-buddy-dep/src/main/java/net/bytebuddy/package-info.java
Patch:
@@ -11,6 +11,6 @@
  *    .getLoaded();
  * dynamicType.newInstance().toString; // returns "Hello World!"</pre>
  * creates a subclass of the {@link java.lang.Object} class which implements the {@link java.io.Serializable}
- * interface. The {@link java.lang.Object#toString()} method is overriden to return {@code Hello World!}.
+ * interface. The {@link java.lang.Object#toString()} method is overridden to return {@code Hello World!}.
  */
 package net.bytebuddy;

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/CompoundList.java
Patch:
@@ -10,7 +10,7 @@
 public class CompoundList {
 
     /**
-     * A compund list cannot be created.
+     * A compound list cannot be created.
      */
     private CompoundList() {
         throw new UnsupportedOperationException("Cannot create a compound list");

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -845,7 +845,7 @@ public Initializable run() {
             }
 
             /**
-             * An abstract base impleementation of a dispatcher.
+             * An abstract base implementation of a dispatcher.
              */
             @EqualsAndHashCode
             abstract class AbstractBase implements Dispatcher, Initializable {

File: byte-buddy-dep/src/test/java/net/bytebuddy/TypeCacheTest.java
Patch:
@@ -86,7 +86,7 @@ public void testCacheTypeCollection() throws Exception {
                 .getLoaded();
         assertThat(typeCache.insert(classLoader, key, type), is((Object) type));
         assertThat(typeCache.find(classLoader, key), is((Object) type));
-        type = null; // Make eligable for GC
+        type = null; // Make eligible for GC
         for (int index = 0; index < 2; index++) {
             System.gc();
             Thread.sleep(50L);

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/PostCompilationAction.java
Patch:
@@ -20,7 +20,7 @@ public class PostCompilationAction implements Action<AbstractCompile> {
     private final ByteBuddyExtension byteBuddyExtension;
 
     /**
-     * Createsa a new post compilation action.
+     * Creates a new post compilation action.
      *
      * @param project            The current project.
      * @param byteBuddyExtension The Byte Buddy extension of this build.

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -70,7 +70,7 @@
  * <pre>
  * ByteBuddy byteBuddy = new ByteBuddy();
  * byteBuddy.foo()</pre>
- * Instead, the following method chain is corrent use of the API:
+ * Instead, the following method chain is correct use of the API:
  * <pre>
  * ByteBuddy byteBuddy = new ByteBuddy().foo();</pre>
  * <p>

File: byte-buddy-dep/src/main/java/net/bytebuddy/TypeCache.java
Patch:
@@ -206,7 +206,7 @@ protected Reference<Class<?>> wrap(Class<?> type) {
         };
 
         /**
-         * Wrapes a type as a {@link Reference}.
+         * Wraps a type as a {@link Reference}.
          *
          * @param type The type to wrap.
          * @return The reference that represents the type.
@@ -314,7 +314,7 @@ public boolean equals(Object other) {
     public static class WithInlineExpunction<S> extends TypeCache<S> {
 
         /**
-         * Creats a new type cache with inlined expunction.
+         * Creates a new type cache with inlined expunction.
          *
          * @param sort The reference type to use for stored types.
          */

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/AsmVisitorWrapper.java
Patch:
@@ -58,7 +58,7 @@ public interface AsmVisitorWrapper {
      * @param implementationContext The implementation context of the current instrumentation.
      * @param typePool              The type pool that was provided for the class creation.
      * @param fields                The instrumented type's fields.
-     * @param methods               The instrumented type's methods non-ingored declared and virtually inherited methods.
+     * @param methods               The instrumented type's methods non-ignored declared and virtually inherited methods.
      * @param writerFlags           The ASM {@link org.objectweb.asm.ClassWriter} flags to consider.
      * @param readerFlags           The ASM {@link org.objectweb.asm.ClassReader} flags to consider.
      * @return A new {@code ClassVisitor} that usually delegates to the {@code ClassVisitor} delivered in the argument.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -36,7 +36,7 @@
 public interface AnnotationDescription {
 
     /**
-     * Indicates an inexistent annotation in a type-safe manner.
+     * Indicates a nonexistent annotation in a type-safe manner.
      */
     AnnotationDescription.Loadable<?> UNDEFINED = null;
 
@@ -540,7 +540,7 @@ class ForLoadedAnnotation<S extends Annotation> extends AbstractBase.ForPrepared
 
         /**
          * The annotation's loaded type which might be loaded by a different class loader than the value's
-         * annotation type but must be structually equal to it.
+         * annotation type but must be structurally equal to it.
          */
         private final Class<S> annotationType;
 
@@ -559,7 +559,7 @@ protected ForLoadedAnnotation(S annotation) {
          *
          * @param annotation     The annotation to represent.
          * @param annotationType The annotation's loaded type which might be loaded by a different class loader than the value's
-         *                       annotation type but must be structually equal to it.
+         *                       annotation type but must be structurally equal to it.
          */
         private ForLoadedAnnotation(S annotation, Class<S> annotationType) {
             this.annotation = annotation;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/package-info.java
Patch:
@@ -1,6 +1,6 @@
 /**
  * Classes of this package allow the representation of Java classes, their member and their meta data. Using the
  * reflection API, it would be required to load classes but by using these descriptions, it is possible to
- * represent byte code elements without pripor loading.
+ * represent byte code elements without prior loading.
  */
 package net.bytebuddy.description;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -397,7 +397,7 @@ protected OfTypeVariables(List<TypeVariable<?>> typeVariables) {
                  * Creates a list of the type variables of the supplied generic declaration.
                  *
                  * @param genericDeclaration The generic declaration to represent.
-                 * @return A genric type list for the returned generic declaration.
+                 * @return A generic type list for the returned generic declaration.
                  */
                 public static Generic of(GenericDeclaration genericDeclaration) {
                     return new OfTypeVariables(genericDeclaration.getTypeParameters());
@@ -525,7 +525,7 @@ public static class WithResolvedErasure extends Generic.AbstractBase {
 
                 /**
                  * Creates a list of generic type descriptions that are resolved lazily, i.e. type variables are not resolved
-                 * when computing an erausre.
+                 * when computing an erasure.
                  *
                  * @param detachedTypes The detached types this list represents.
                  * @param visitor       The visitor to use for attaching the detached types.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -778,7 +778,7 @@ public static ClassFileLocator ofModulePath() throws IOException {
         /**
          * <p>
          * Resolves a class file locator for a Java module path that reads class files directly from the file system. All
-         * elements of the module path are resolved releatively to this VM's {@code user.dir}.
+         * elements of the module path are resolved relative to this VM's {@code user.dir}.
          * </p>
          * <p>
          * <b>Note</b>: The resulting class file locator does not include classes of the bootstrap class loader.
@@ -1156,7 +1156,7 @@ protected interface Dispatcher {
                     Vector<Class<?>> extract(ClassLoader classLoader);
 
                     /**
-                     * An unitialized version of a dispatcher for extracting a class loader's loaded classes.
+                     * An uninitialized version of a dispatcher for extracting a class loader's loaded classes.
                      */
                     interface Initializable {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/NexusAccessor.java
Patch:
@@ -53,7 +53,7 @@ public NexusAccessor() {
     }
 
     /**
-     * Creates a new accessor for a {@link Nexus} where any GC eligible are enqueued to the supplid reference queue. Any such enqueued
+     * Creates a new accessor for a {@link Nexus} where any GC eligible are enqueued to the supplied reference queue. Any such enqueued
      * reference can be explicitly removed from the nexus via the {@link NexusAccessor#clean(Reference)} method. Nexus entries can
      * become stale if a class loader is garbage collected after a class was loaded but before a class was initialized.
      *

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/Transformer.java
Patch:
@@ -83,7 +83,7 @@ public ForField(Transformer<FieldDescription.Token> transformer) {
         }
 
         /**
-         * Creates a field transformer that patches the transformed field by the givien modifier contributors.
+         * Creates a field transformer that patches the transformed field by the given modifier contributors.
          *
          * @param modifierContributor The modifier contributors to apply.
          * @return A suitable field transformer.
@@ -93,7 +93,7 @@ public static Transformer<FieldDescription> withModifiers(ModifierContributor.Fo
         }
 
         /**
-         * Creates a field transformer that patches the transformed field by the givien modifier contributors.
+         * Creates a field transformer that patches the transformed field by the given modifier contributors.
          *
          * @param modifierContributors The modifier contributors to apply.
          * @return A suitable field transformer.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -279,7 +279,7 @@ interface Initializable {
                 /**
                  * Initializes this dispatcher.
                  *
-                 * @return The initiailized dispatcher.
+                 * @return The initialized dispatcher.
                  */
                 Dispatcher initialize();
             }
@@ -290,7 +290,7 @@ interface Initializable {
             enum CreationAction implements PrivilegedAction<Initializable> {
 
                 /**
-                 * The singelton instance.
+                 * The singleton instance.
                  */
                 INSTANCE;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategy.java
Patch:
@@ -359,7 +359,7 @@ class UsingLookup implements ClassLoadingStrategy<ClassLoader> {
         private final ClassLoader classLoader;
 
         /**
-         * Creaes a new class loading strategy that uses a lookup type.
+         * Creates a new class loading strategy that uses a lookup type.
          *
          * @param classInjector The class injector to use.
          * @param classLoader   The class loader in the supplied class injector defines classes.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1416,7 +1416,7 @@ abstract class Default<S> implements TypeWriter<S> {
          * @param fieldPool                    The field pool to use.
          * @param auxiliaryTypes               The explicit auxiliary types to add to the created type.
          * @param fields                       The instrumented type's declared fields.
-         * @param methods                      The instrumented type's declared and virtually inhertied methods.
+         * @param methods                      The instrumented type's declared and virtually inherited methods.
          * @param instrumentedMethods          The instrumented methods relevant to this type creation.
          * @param loadedTypeInitializer        The loaded type initializer to apply onto the created type after loading.
          * @param typeInitializer              The type initializer to include in the created type's type initializer.
@@ -3198,7 +3198,7 @@ public void complete(ClassVisitor classVisitor, Implementation.Context.Extractab
                     }
 
                     /**
-                     * A frame writer is responsible for adding empty frames on jumo instructions.
+                     * A frame writer is responsible for adding empty frames on jump instructions.
                      */
                     protected interface FrameWriter {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolver.java
Patch:
@@ -27,7 +27,7 @@
  * This way a method can exist in two versions within a class:
  * <ol>
  * <li>The rebased method which represents the original implementation as it is present in a class file.</li>
- * <li>An overriden method which implements user code which is still able to invoke the original, rebased method.</li>
+ * <li>An overridden method which implements user code which is still able to invoke the original, rebased method.</li>
  * </ol>
  */
 public interface MethodRebaseResolver {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -467,7 +467,7 @@ public interface OwnerTypeLocatable extends AssignerConfigurable {
     }
 
     /**
-     * A field accessor for an implicit property where a getter or setter property is infered from the signature.
+     * A field accessor for an implicit property where a getter or setter property is inferred from the signature.
      */
     protected static class ForImplicitProperty extends FieldAccessor implements OwnerTypeLocatable {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -2829,7 +2829,7 @@ protected static class OfArgument extends WithImplicitType {
              * @param terminationHandler A handler that handles the method return.
              * @param assigner           The assigner to be used.
              * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
-             * @param index              The index of of the argument to supply to the bootstapped method.
+             * @param index              The index of of the argument to supply to the bootstrapped method.
              */
             protected OfArgument(MethodDescription.InDefinedShape bootstrapMethod,
                                  List<?> handleArguments,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -1902,7 +1902,7 @@ public <T> MethodCall on(T target, Class<? super T> type) {
          * Invokes the specified method on the instrumented method's argument of the given index.
          *
          * @param index The index of the method's argument on which the specified method should be invoked.
-         * @return Amethod call that invokes the provided method on the given method argument.
+         * @return A method call that invokes the provided method on the given method argument.
          */
         public MethodCall onArgument(int index) {
             if (index < 0) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationAppender.java
Patch:
@@ -364,7 +364,7 @@ class ForTypeAnnotations implements TypeDescription.Generic.Visitor<AnnotationAp
         private static final char INNER_CLASS_PATH = '.';
 
         /**
-         * Represents an index tzpe delimiter within a type path.
+         * Represents an index type delimiter within a type path.
          */
         private static final char INDEXED_TYPE_DELIMITER = ';';
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/ArgumentTypeResolver.java
Patch:
@@ -18,7 +18,7 @@
  * type is considered as dominant.</li>
  * <li>If this result is dominant for both the left and the right target method, this resolver will consider the binding as
  * ambiguous.</li>
- * <li>If none of the methods is dominant and if the comparison did not result in an ambigous resolution, the method that
+ * <li>If none of the methods is dominant and if the comparison did not result in an ambiguous resolution, the method that
  * consists of the most one-to-one parameter bindings is considered dominant.</li>
  * </ol>
  * Primitive types are considered dominant in the same manner as by the Java compiler.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/MethodDelegationBinder.java
Patch:
@@ -46,7 +46,7 @@ interface Record {
          *
          * @param implementationTarget The target of the current implementation onto which this binding is to be applied.
          * @param source               The method that is to be bound to the {@code target} method.
-         * @param terminationHandler   Ther termination handler to apply.
+         * @param terminationHandler   The termination handler to apply.
          * @param methodInvoker        The method invoker to use.
          * @param assigner             The assigner to use.
          * @return A binding representing this attempt to bind the {@code source} method to the {@code target} method.
@@ -639,7 +639,7 @@ public MethodBinding resolve(AmbiguityResolver ambiguityResolver, MethodDescript
         }
 
         /**
-         * Bindinds a method using another resolver and prints the selected binding to a {@link PrintStream}.
+         * Binds a method using another resolver and prints the selected binding to a {@link PrintStream}.
          */
         @EqualsAndHashCode
         class StreamWriting implements BindingResolver {
@@ -968,7 +968,7 @@ public StackManipulation resolve(Assigner assigner, Assigner.Typing typing, Meth
     }
 
     /**
-     * A helper class that allows to identify a best binding for a given type and source method chosing from a list of given
+     * A helper class that allows to identify a best binding for a given type and source method choosing from a list of given
      * target methods by using a given {@link net.bytebuddy.implementation.bind.MethodDelegationBinder}
      * and an {@link net.bytebuddy.implementation.bind.MethodDelegationBinder.AmbiguityResolver}.
      * <p>&nbsp;</p>

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -295,9 +295,9 @@ protected MethodDelegationBinder.ParameterBinding<?> bind(FieldDescription field
         protected interface FieldResolver {
 
             /**
-             * Returns {@code true} if the field access can be establised.
+             * Returns {@code true} if the field access can be established.
              *
-             * @return {@code true} if the field access can be establised.
+             * @return {@code true} if the field access can be established.
              */
             boolean isResolved();
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Super.java
Patch:
@@ -47,7 +47,7 @@
  * proxy by default. If this is absolutely necessary, this can however be enabled by setting {@link Super#ignoreFinalizer()}
  * to {@code false}.
  * <p>&nbsp;</p>
- * If a method parameter is not a super type of the instrumented type, the method with the parameter that is annoted by
+ * If a method parameter is not a super type of the instrumented type, the method with the parameter that is annotated by
  * #{@code Super} is not considered a possible delegation target.
  *
  * @see net.bytebuddy.implementation.MethodDelegation

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperMethod.java
Patch:
@@ -40,7 +40,7 @@
     boolean cached() default true;
 
     /**
-     * Indicates that the assigned method should attemt the invocation of an unambiguous default method if no super method is available.
+     * Indicates that the assigned method should attempt the invocation of an unambiguous default method if no super method is available.
      *
      * @return {@code true} if a default method should be invoked if it is not ambiguous and no super class method is available.
      */

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -37,7 +37,7 @@ public class TargetMethodAnnotationDrivenBinder implements MethodDelegationBinde
     /**
      * Creates a new target method annotation-driven binder.
      *
-     * @param delegationProcessor The delegation proessor to use.
+     * @param delegationProcessor The delegation processor to use.
      */
     protected TargetMethodAnnotationDrivenBinder(DelegationProcessor delegationProcessor) {
         this.delegationProcessor = delegationProcessor;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveBoxingDelegate.java
Patch:
@@ -96,7 +96,7 @@ public enum PrimitiveBoxingDelegate {
      * Locates a boxing delegate for a given primitive type.
      *
      * @param typeDefinition A non-void primitive type.
-     * @return A delegate capable of boxing the given primitve type.
+     * @return A delegate capable of boxing the given primitive type.
      */
     public static PrimitiveBoxingDelegate forPrimitive(TypeDefinition typeDefinition) {
         if (typeDefinition.represents(boolean.class)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/FieldConstant.java
Patch:
@@ -33,7 +33,7 @@ public FieldConstant(FieldDescription.InDefinedShape fieldDescription) {
     }
 
     /**
-     * Retruns a cached version of this field constant.
+     * Returns a cached version of this field constant.
      *
      * @return A cached version of this field constant.
      */

File: byte-buddy-dep/src/main/java/net/bytebuddy/package-info.java
Patch:
@@ -11,6 +11,6 @@
  *    .getLoaded();
  * dynamicType.newInstance().toString; // returns "Hello World!"</pre>
  * creates a subclass of the {@link java.lang.Object} class which implements the {@link java.io.Serializable}
- * interface. The {@link java.lang.Object#toString()} method is overriden to return {@code Hello World!}.
+ * interface. The {@link java.lang.Object#toString()} method is overridden to return {@code Hello World!}.
  */
 package net.bytebuddy;

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/CompoundList.java
Patch:
@@ -10,7 +10,7 @@
 public class CompoundList {
 
     /**
-     * A compund list cannot be created.
+     * A compound list cannot be created.
      */
     private CompoundList() {
         throw new UnsupportedOperationException("Cannot create a compound list");

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -845,7 +845,7 @@ public Initializable run() {
             }
 
             /**
-             * An abstract base impleementation of a dispatcher.
+             * An abstract base implementation of a dispatcher.
              */
             @EqualsAndHashCode
             abstract class AbstractBase implements Dispatcher, Initializable {

File: byte-buddy-dep/src/test/java/net/bytebuddy/TypeCacheTest.java
Patch:
@@ -86,7 +86,7 @@ public void testCacheTypeCollection() throws Exception {
                 .getLoaded();
         assertThat(typeCache.insert(classLoader, key, type), is((Object) type));
         assertThat(typeCache.find(classLoader, key), is((Object) type));
-        type = null; // Make eligable for GC
+        type = null; // Make eligible for GC
         for (int index = 0; index < 2; index++) {
             System.gc();
             Thread.sleep(50L);

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/PostCompilationAction.java
Patch:
@@ -20,7 +20,7 @@ public class PostCompilationAction implements Action<AbstractCompile> {
     private final ByteBuddyExtension byteBuddyExtension;
 
     /**
-     * Createsa a new post compilation action.
+     * Creates a new post compilation action.
      *
      * @param project            The current project.
      * @param byteBuddyExtension The Byte Buddy extension of this build.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategy.java
Patch:
@@ -42,7 +42,8 @@ public interface ConstructorStrategy {
      * {@link net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy#extractConstructors(TypeDescription)}
      * method of this instance.
      *
-     * @param methodRegistry The original method registry.
+     * @param instrumentedType The instrumented type.
+     * @param methodRegistry   The original method registry.
      * @return A method registry that is capable of providing byte code for the constructors that were added by this strategy.
      */
     MethodRegistry inject(TypeDescription instrumentedType, MethodRegistry methodRegistry);

File: byte-buddy-maven-plugin/src/test/java/net/bytebuddy/build/maven/ExecutionStatusTest.java
Patch:
@@ -29,7 +29,7 @@ public class ExecutionStatusTest {
     @Test
     public void emptyStatusCombinationIsSuccessful() {
         assertThat(
-                new ExecutionStatus.Combined(Collections.emptySet()).failed(),
+                new ExecutionStatus.Combined(Collections.<ExecutionStatus>emptySet()).failed(),
                 is(false)
         );
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -158,7 +158,7 @@ public DynamicType.Unloaded<T> make(TypeResolutionStrategy typeResolutionStrateg
     @Override
     public DynamicType.Unloaded<T> make(TypeResolutionStrategy typeResolutionStrategy, TypePool typePool) {
         MethodRegistry.Compiled methodRegistry = constructorStrategy
-                .inject(this.methodRegistry)
+                .inject(instrumentedType, this.methodRegistry)
                 .prepare(applyConstructorStrategy(instrumentedType), methodGraphCompiler, typeValidation, new InstrumentableMatcher(ignoredMethods))
                 .compile(SubclassImplementationTarget.Factory.SUPER_CLASS, classFileVersion);
         return TypeWriter.Default.<T>forCreation(methodRegistry,

File: byte-buddy-maven-plugin/src/test/java/net/bytebuddy/build/maven/ByteBuddyMojoTest.java
Patch:
@@ -35,8 +35,7 @@
 import static junit.framework.TestCase.fail;
 import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.Mockito.*;
+import static org.mockito.Mockito.when;
 
 public class ByteBuddyMojoTest {
 

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -389,7 +389,6 @@ private static void install(AttachmentProvider attachmentProvider, String proces
      * @param argument           The argument to provide to the agent or {@code null} if no argument should be supplied.
      * @throws Exception If an exception occurs during the attachment or the external process fails the attachment.
      */
-    @SuppressFBWarnings(value = "DLS_DEAD_LOCAL_STORE_OF_NULL", justification = "Caused by Java 10 compiler")
     private static void installExternal(AttachmentProvider.Accessor.ExternalAttachment externalAttachment,
                                         String processId,
                                         File agent,
@@ -863,7 +862,6 @@ public Compound(AttachmentProvider... attachmentProvider) {
              *
              * @param attachmentProviders A list of attachment providers in the order of their application.
              */
-            @SuppressFBWarnings(value = "DLS_DEAD_LOCAL_STORE_OF_NULL", justification = "Caused by Java 10 compiler")
             public Compound(List<? extends AttachmentProvider> attachmentProviders) {
                 this.attachmentProviders = new ArrayList<AttachmentProvider>();
                 for (AttachmentProvider attachmentProvider : attachmentProviders) {
@@ -876,7 +874,6 @@ public Compound(List<? extends AttachmentProvider> attachmentProviders) {
             }
 
             @Override
-            @SuppressFBWarnings(value = "DLS_DEAD_LOCAL_STORE_OF_NULL", justification = "Caused by Java 10 compiler")
             public Accessor attempt() {
                 for (AttachmentProvider attachmentProvider : attachmentProviders) {
                     Accessor accessor = attachmentProvider.attempt();

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -389,6 +389,7 @@ private static void install(AttachmentProvider attachmentProvider, String proces
      * @param argument           The argument to provide to the agent or {@code null} if no argument should be supplied.
      * @throws Exception If an exception occurs during the attachment or the external process fails the attachment.
      */
+    @SuppressFBWarnings(value = "DLS_DEAD_LOCAL_STORE_OF_NULL", justification = "Caused by Java 10 compiler")
     private static void installExternal(AttachmentProvider.Accessor.ExternalAttachment externalAttachment,
                                         String processId,
                                         File agent,
@@ -862,6 +863,7 @@ public Compound(AttachmentProvider... attachmentProvider) {
              *
              * @param attachmentProviders A list of attachment providers in the order of their application.
              */
+            @SuppressFBWarnings(value = "DLS_DEAD_LOCAL_STORE_OF_NULL", justification = "Caused by Java 10 compiler")
             public Compound(List<? extends AttachmentProvider> attachmentProviders) {
                 this.attachmentProviders = new ArrayList<AttachmentProvider>();
                 for (AttachmentProvider attachmentProvider : attachmentProviders) {
@@ -874,6 +876,7 @@ public Compound(List<? extends AttachmentProvider> attachmentProviders) {
             }
 
             @Override
+            @SuppressFBWarnings(value = "DLS_DEAD_LOCAL_STORE_OF_NULL", justification = "Caused by Java 10 compiler")
             public Accessor attempt() {
                 for (AttachmentProvider attachmentProvider : attachmentProviders) {
                     Accessor accessor = attachmentProvider.attempt();

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/Attacher.java
Patch:
@@ -42,7 +42,7 @@ public class Attacher {
     public static void main(String[] args) {
         try {
             String argument;
-            if (args.length < 3 || args[3].isEmpty()) {
+            if (args.length < 4 || args[3].isEmpty()) {
                 argument = null;
             } else {
                 StringBuilder stringBuilder = new StringBuilder(args[3].substring(1));

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -7176,7 +7176,7 @@ public Generic getSuperClass() {
             if (RAW_TYPES) {
                 return type.getSuperclass() == null
                         ? TypeDescription.Generic.UNDEFINED
-                        : new Generic.OfNonGenericType.ForLoadedType(type);
+                        : new Generic.OfNonGenericType.ForLoadedType(type.getSuperclass());
             }
             return type.getSuperclass() == null
                     ? TypeDescription.Generic.UNDEFINED
@@ -7188,7 +7188,7 @@ public TypeList.Generic getInterfaces() {
             if (RAW_TYPES) {
                 return isArray()
                         ? ARRAY_INTERFACES
-                        : new TypeList.Generic.ForLoadedTypes(type);
+                        : new TypeList.Generic.ForLoadedTypes(type.getInterfaces());
             }
             return isArray()
                     ? ARRAY_INTERFACES

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -331,7 +331,7 @@ class ForJava9CapableVm implements VersionLocator {
             private static final Object STATIC_METHOD = null;
 
             /**
-             * The {@code java java.lang.Runtime#current()} method.
+             * The {@code java.lang.Runtime#version()} method.
              */
             private final Method current;
 
@@ -343,7 +343,7 @@ class ForJava9CapableVm implements VersionLocator {
             /**
              * Creates a new version locator for a Java 9 capable VM.
              *
-             * @param current The {@code java.lang.Runtime#current()} method.
+             * @param current The {@code java.lang.Runtime#version()} method.
              * @param major   The {@code java.lang.Runtime.Version#major()} method.
              */
             protected ForJava9CapableVm(Method current, Method major) {
@@ -364,7 +364,7 @@ public ClassFileVersion locate() {
         }
 
         /**
-         * A version locator for a JVM that does not provide the {@code jdk.Version} class.
+         * A version locator for a JVM that does not provide the {@code java.lang.Runtime.Version} class.
          */
         enum ForLegacyVm implements VersionLocator, PrivilegedAction<String> {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -331,7 +331,7 @@ class ForJava9CapableVm implements VersionLocator {
             private static final Object STATIC_METHOD = null;
 
             /**
-             * The {@code java java.lang.Runtime#current()} method.
+             * The {@code java.lang.Runtime#version()} method.
              */
             private final Method current;
 
@@ -343,7 +343,7 @@ class ForJava9CapableVm implements VersionLocator {
             /**
              * Creates a new version locator for a Java 9 capable VM.
              *
-             * @param current The {@code java.lang.Runtime#current()} method.
+             * @param current The {@code java.lang.Runtime#version()} method.
              * @param major   The {@code java.lang.Runtime.Version#major()} method.
              */
             protected ForJava9CapableVm(Method current, Method major) {
@@ -364,7 +364,7 @@ public ClassFileVersion locate() {
         }
 
         /**
-         * A version locator for a JVM that does not provide the {@code jdk.Version} class.
+         * A version locator for a JVM that does not provide the {@code java.lang.Runtime.Version} class.
          */
         enum ForLegacyVm implements VersionLocator, PrivilegedAction<String> {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -5,17 +5,14 @@
 import net.bytebuddy.description.NamedElement;
 import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.annotation.AnnotationList;
-import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.matcher.ElementMatcher;
-import net.bytebuddy.utility.privilege.GetSystemPropertyAction;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.signature.SignatureWriter;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.GenericSignatureFormatError;
 import java.lang.reflect.Modifier;
-import java.security.AccessController;
 import java.util.Collections;
 import java.util.List;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3761,7 +3761,7 @@ public FieldVisitor visitField(int modifiers,
                  *
                  * @param record           The field pool value to apply during visitation of the existing field.
                  * @param defaultValue     The default value to write onto the field which might be {@code null}.
-                 * @param genericSignature The original generic signature which can be {@code null}.
+                 * @param genericSignature The field's original generic signature which can be {@code null}.
                  * @return A field visitor for visiting the existing field definition.
                  */
                 protected FieldVisitor redefine(FieldPool.Record record, Object defaultValue, String genericSignature) {
@@ -3808,8 +3808,8 @@ public MethodVisitor visitMethod(int modifiers,
                  * {@link net.bytebuddy.dynamic.scaffold.TypeWriter.MethodPool}.
                  *
                  * @param methodDescription The method being considered for redefinition.
-                 * @param abstractOrigin    {@code true} if the original method is abstract, i.e. there is no implementation
-                 *                          to preserve.
+                 * @param abstractOrigin    {@code true} if the original method is abstract, i.e. there is no implementation to preserve.
+                 * @param genericSignature  The method's original generic signature which can be {@code null}.
                  * @return A method visitor which is capable of consuming the original method.
                  */
                 protected MethodVisitor redefine(MethodDescription methodDescription, boolean abstractOrigin, String genericSignature) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoader.java
Patch:
@@ -567,7 +567,7 @@ public Package apply(ByteArrayClassLoader classLoader, String name) {
     }
 
     /**
-     * A persistence handler decides on weather the byte array that represents a loaded class is exposed by
+     * A persistence handler decides on whether the byte array that represents a loaded class is exposed by
      * the {@link java.lang.ClassLoader#getResourceAsStream(String)} method.
      */
     public enum PersistenceHandler {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoader.java
Patch:
@@ -567,7 +567,7 @@ public Package apply(ByteArrayClassLoader classLoader, String name) {
     }
 
     /**
-     * A persistence handler decides on weather the byte array that represents a loaded class is exposed by
+     * A persistence handler decides on whether the byte array that represents a loaded class is exposed by
      * the {@link java.lang.ClassLoader#getResourceAsStream(String)} method.
      */
     public enum PersistenceHandler {

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -116,7 +116,7 @@
  * <b>Note</b>: It is not possible to trigger break points in inlined advice methods as the debugging information of the inlined advice is not
  * preserved. It is not possible in Java to reference more than one source file per class what makes translating such debugging information
  * impossible. It is however possible to set break points in advice methods when invoking the original advice target. This allows debugging
- * of advice code within unit tests that invoke the advice method without instrumentation. As a conequence of not transferring debugging information,
+ * of advice code within unit tests that invoke the advice method without instrumentation. As a consequence of not transferring debugging information,
  * the names of the parameters of an advice method do not matter when inlining, neither does any meta information on the advice method's body
  * such as annotations or parameter modifiers.
  * </p>

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -116,7 +116,7 @@
  * <b>Note</b>: It is not possible to trigger break points in inlined advice methods as the debugging information of the inlined advice is not
  * preserved. It is not possible in Java to reference more than one source file per class what makes translating such debugging information
  * impossible. It is however possible to set break points in advice methods when invoking the original advice target. This allows debugging
- * of advice code within unit tests that invoke the advice method without instrumentation. As a conequence of not transferring debugging information,
+ * of advice code within unit tests that invoke the advice method without instrumentation. As a consequence of not transferring debugging information,
  * the names of the parameters of an advice method do not matter when inlining, neither does any meta information on the advice method's body
  * such as annotations or parameter modifiers.
  * </p>

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -8553,10 +8553,9 @@ public <T extends Annotation> WithCustomMapping bind(Class<T> type, OffsetMappin
          * a parameter of an advice method, the dynamic value is asked to provide a value that is then assigned to the parameter in question.
          *
          * @param offsetMapping The dynamic value that is computed for binding the parameter to a value.
-         * @param <T>           The annotation type.
          * @return A new builder for an advice that considers the supplied annotation type during binding.
          */
-        public <T extends Annotation> WithCustomMapping bind(OffsetMapping.Factory<? super T> offsetMapping) {
+        public WithCustomMapping bind(OffsetMapping.Factory<?> offsetMapping) {
             Map<Class<? extends Annotation>, OffsetMapping.Factory<?>> offsetMappings = new HashMap<Class<? extends Annotation>, OffsetMapping.Factory<?>>(this.offsetMappings);
             if (!offsetMapping.getAnnotationType().isAnnotation()) {
                 throw new IllegalArgumentException("Not an annotation type: " + offsetMapping.getAnnotationType());

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -8553,7 +8553,6 @@ public <T extends Annotation> WithCustomMapping bind(Class<T> type, OffsetMappin
          * a parameter of an advice method, the dynamic value is asked to provide a value that is then assigned to the parameter in question.
          *
          * @param offsetMapping The dynamic value that is computed for binding the parameter to a value.
-         * @param <T>           The annotation type.
          * @return A new builder for an advice that considers the supplied annotation type during binding.
          */
         public WithCustomMapping bind(OffsetMapping.Factory<?> offsetMapping) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -203,6 +203,7 @@ public class MethodDelegation implements Implementation.Composable {
      * @param implementationDelegate The implementation delegate to use by this method delegator.
      * @param parameterBinders       The parameter binders to use by this method delegator.
      * @param ambiguityResolver      The ambiguity resolver to use by this method delegator.
+     * @param bindingResolver        The binding resolver being used to select the relevant method binding.
      */
     protected MethodDelegation(ImplementationDelegate implementationDelegate,
                                List<TargetMethodAnnotationDrivenBinder.ParameterBinder<?>> parameterBinders,

File: byte-buddy-maven-plugin/src/test/java/net/bytebuddy/build/maven/ByteBuddyMojoTest.java
Patch:
@@ -276,7 +276,6 @@ private void execute(String goal, String target) throws Exception {
         mojoRule.setVariableValueToObject(mojo, "groupId", FOO);
         mojoRule.setVariableValueToObject(mojo, "artifactId", BAR);
         mojoRule.setVariableValueToObject(mojo, "version", QUX);
-        mojoRule.setVariableValueToObject(mojo, "packaging", "jar");
         mojo.setLog(new SilentLog());
         mojo.execute();
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -4185,7 +4185,7 @@ public Map<TypeDescription, byte[]> getAuxiliaryTypes() {
         public Map<TypeDescription, File> saveIn(File folder) throws IOException {
             Map<TypeDescription, File> savedFiles = new HashMap<TypeDescription, File>();
             File target = new File(folder, typeDescription.getName().replace('.', File.separatorChar) + CLASS_FILE_EXTENSION);
-            if (target.getParentFile() != null && !target.getParentFile().exists() && !target.getParentFile().mkdirs()) {
+            if (target.getParentFile() != null && !target.getParentFile().isDirectory() && !target.getParentFile().mkdirs()) {
                 throw new IllegalArgumentException("Could not create directory: " + target.getParentFile());
             }
             OutputStream outputStream = new FileOutputStream(target);
@@ -4205,7 +4205,7 @@ public Map<TypeDescription, File> saveIn(File folder) throws IOException {
         public File inject(File sourceJar, File targetJar) throws IOException {
             JarInputStream jarInputStream = new JarInputStream(new BufferedInputStream(new FileInputStream(sourceJar)));
             try {
-                if (!targetJar.exists() && !targetJar.createNewFile()) {
+                if (!targetJar.isFile() && !targetJar.createNewFile()) {
                     throw new IllegalArgumentException("Could not create file: " + targetJar);
                 }
                 JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(targetJar), jarInputStream.getManifest());
@@ -4282,7 +4282,7 @@ public File toJar(File file) throws IOException {
 
         @Override
         public File toJar(File file, Manifest manifest) throws IOException {
-            if (!file.exists() && !file.createNewFile()) {
+            if (!file.isFile() && !file.createNewFile()) {
                 throw new IllegalArgumentException("Could not create file: " + file);
             }
             JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(file), manifest);

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -434,7 +434,9 @@ private static void installExternal(AttachmentProvider.Accessor.ExternalAttachme
             }
         } finally {
             if (attachmentJar != null) {
-                attachmentJar.delete();
+                if (!attachmentJar.delete()) {
+                    attachmentJar.deleteOnExit();
+                }
             }
         }
     }

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -310,7 +310,9 @@ protected void connect() throws IOException {
                     } catch (InterruptedException exception) {
                         throw new IllegalStateException("Interrupted during wait for process", exception);
                     } finally {
-                        attachFile.delete();
+                        if (!attachFile.delete()) {
+                            attachFile.deleteOnExit();
+                        }
                     }
                 }
                 ((AFUNIXSocket) socket).setSoTimeout((int) timeUnit.toMillis(timeout));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1634,8 +1634,8 @@ public DynamicType.Unloaded<S> make(TypeResolutionStrategy.Resolved typeResoluti
             if (DUMP_FOLDER != null) {
                 try {
                     AccessController.doPrivileged(new ClassDumpAction(DUMP_FOLDER, instrumentedType, unresolvedType.getBinaryRepresentation()));
-                } catch (Exception ignored) {
-                    /* empty */
+                } catch (Exception exception) {
+                    exception.printStackTrace();
                 }
             }
             return unresolvedType.toDynamicType(typeResolutionStrategy);

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -5760,6 +5760,7 @@ protected abstract static class ForMethodExit extends Inlining.Resolved implemen
                      * @param enterType     The type of the value supplied by the enter advice method or
                      *                      a description of {@code void} if no such value exists.
                      */
+                    @SuppressWarnings("unchecked")
                     protected ForMethodExit(MethodDescription.InDefinedShape adviceMethod,
                                             List<? extends OffsetMapping.Factory<?>> userFactories,
                                             ClassReader classReader,
@@ -6941,6 +6942,7 @@ protected abstract static class ForMethodExit extends Delegating.Resolved<Bound.
                      * @param enterType     The type of the value supplied by the enter advice method or
                      *                      a description of {@code void} if no such value exists.
                      */
+                    @SuppressWarnings("unchecked")
                     protected ForMethodExit(MethodDescription.InDefinedShape adviceMethod,
                                             List<? extends OffsetMapping.Factory<?>> userFactories,
                                             TypeDefinition enterType) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/AgentAttachmentRule.java
Patch:
@@ -10,7 +10,6 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 import java.lang.instrument.Instrumentation;
-import java.security.AccessController;
 import java.util.logging.Logger;
 
 /**

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/TransformationAction.java
Patch:
@@ -61,13 +61,10 @@ public TransformationAction(Project project, ByteBuddyExtension extension, Abstr
 
     @Override
     public void execute(Task task) {
-        ByteBuddyLogHandler byteBuddyLogHandler = ByteBuddyLogHandler.initialize(project);
         try {
             processOutputDirectory(this.task.getDestinationDir(), this.task.getClasspath());
         } catch (IOException exception) {
             throw new GradleException("Error accessing file system", exception);
-        } finally {
-            byteBuddyLogHandler.reset();
         }
     }
 

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/ByteBuddyMojo.java
Patch:
@@ -139,13 +139,10 @@ public void execute() throws MojoExecutionException, MojoFailureException {
             getLog().warn("No transformations are specified. Skipping plugin application.");
             return;
         }
-        ByteBuddyLogHandler byteBuddyLogHandler = ByteBuddyLogHandler.initialize(getLog());
         try {
             processOutputDirectory(new File(getOutputDirectory()), getClassPathElements());
         } catch (IOException exception) {
             throw new MojoFailureException("Error during writing process", exception);
-        } finally {
-            byteBuddyLogHandler.reset();
         }
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/NexusAccessor.java
Patch:
@@ -35,8 +35,6 @@
 @EqualsAndHashCode
 public class NexusAccessor {
 
-    public static final String PROPERTY;
-
     /**
      * The dispatcher to use.
      */

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/Attacher.java
Patch:
@@ -1,5 +1,7 @@
 package net.bytebuddy.agent;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+
 import java.io.File;
 import java.lang.reflect.InvocationTargetException;
 
@@ -37,6 +39,7 @@ public class Attacher {
      *             of strings where the first argument is proceeded by any single character
      *             which is stripped off.
      */
+    @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but trigger a fallback")
     public static void main(String[] args) {
         try {
             String argument;

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -1115,6 +1115,7 @@ enum InstallationAction implements PrivilegedAction<AttachmentTypeEvaluator> {
             private static final String JDK_ALLOW_SELF_ATTACH = "jdk.attach.allowAttachSelf";
 
             @Override
+            @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but trigger a fallback")
             public AttachmentTypeEvaluator run() {
                 try {
                     if (Boolean.getBoolean(JDK_ALLOW_SELF_ATTACH)) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccessTest.java
Patch:
@@ -85,8 +85,8 @@ public void testStoring() throws Exception {
         StackManipulation stackManipulation = MethodVariableAccess.of(typeDefinition).storeAt(4);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);
-        assertThat(size.getSizeImpact(), is(this.size));
-        assertThat(size.getMaximalSize(), is(this.size));
+        assertThat(size.getSizeImpact(), is(-this.size));
+        assertThat(size.getMaximalSize(), is(0));
         verify(methodVisitor).visitVarInsn(writeCode, 4);
         verifyNoMoreInteractions(methodVisitor);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccessTest.java
Patch:
@@ -85,8 +85,8 @@ public void testStoring() throws Exception {
         StackManipulation stackManipulation = MethodVariableAccess.of(typeDefinition).storeAt(4);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);
-        assertThat(size.getSizeImpact(), is(this.size));
-        assertThat(size.getMaximalSize(), is(this.size));
+        assertThat(size.getSizeImpact(), is(-this.size));
+        assertThat(size.getMaximalSize(), is(0));
         verify(methodVisitor).visitVarInsn(writeCode, 4);
         verifyNoMoreInteractions(methodVisitor);
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -8924,7 +8924,7 @@ public synchronized boolean reset(Instrumentation instrumentation,
                                               RedefinitionStrategy.Listener redefinitionListener) {
                 if (instrumentation.removeTransformer(this)) {
                     redefinitionStrategy.apply(instrumentation,
-                            Listener.NoOp.INSTANCE,
+                            listener,
                             CircularityLock.Inactive.INSTANCE,
                             poolStrategy,
                             locationStrategy,

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -2438,8 +2438,8 @@ public Target resolve(TypeDescription instrumentedType, MethodDescription instru
                     if (instrumentedMethod.isStatic() || !context.isInitialized()) {
                         if (optional) {
                             return readOnly
-                                    ? new Target.ForDefaultValue.ReadOnly(instrumentedType.getDeclaringType())
-                                    : new Target.ForDefaultValue.ReadWrite(instrumentedType.getDeclaringType());
+                                    ? new Target.ForDefaultValue.ReadOnly(instrumentedType)
+                                    : new Target.ForDefaultValue.ReadWrite(instrumentedType);
                         } else {
                             throw new IllegalStateException("Cannot map this reference for static method or constructor start: " + instrumentedMethod);
                         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultApplicationResubmissionTest.java
Patch:
@@ -72,8 +72,8 @@ public boolean isAlive() {
                         }
 
                         @Override
-                        public void schedule(final Runnable job) {
-                            scheduledExecutorService.scheduleWithFixedDelay(job, TIMEOUT, TIMEOUT, TimeUnit.SECONDS);
+                        public Cancelable schedule(final Runnable job) {
+                            return new Cancelable.ForFuture(scheduledExecutorService.scheduleWithFixedDelay(job, TIMEOUT, TIMEOUT, TimeUnit.SECONDS));
                         }
                     })
                     .type(ElementMatchers.is(Foo.class), ElementMatchers.is(classLoader)).transform(new FooTransformer())

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1095,7 +1095,7 @@ public void apply(ClassVisitor classVisitor,
                     for (MethodDescription.TypeToken bridgeType : bridgeTypes) {
                         MethodDescription.InDefinedShape bridgeMethod = new AccessorBridge(bridgeTarget, bridgeType, instrumentedType);
                         MethodDescription.InDefinedShape bridgeTarget = new BridgeTarget(this.bridgeTarget, instrumentedType);
-                        MethodVisitor methodVisitor = classVisitor.visitMethod(bridgeMethod.getActualModifiers(true),
+                        MethodVisitor methodVisitor = classVisitor.visitMethod(bridgeMethod.getActualModifiers(true, getVisibility()),
                                 bridgeMethod.getInternalName(),
                                 bridgeMethod.getDescriptor(),
                                 MethodDescription.NON_GENERIC_SIGNATURE,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1079,7 +1079,7 @@ public MethodDescription getMethod() {
 
                 @Override
                 public Visibility getVisibility() {
-                    return bridgeTarget.getVisibility();
+                    return delegate.getVisibility();
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -38,7 +38,7 @@
 /**
  * Using this annotation it is possible to access fields by getter and setter types. Before this annotation can be
  * used, it needs to be installed with two types. The getter type must be defined in a single-method interface
- * with a single method that returns an {@link java.lang.Object} type and takes no arguments. The getter interface
+ * with a single method that returns an {@link java.lang.Object} type and takes no arguments. The setter interface
  * must similarly return {@code void} and take a single {@link java.lang.Object} argument. After installing these
  * interfaces with the {@link FieldProxy.Binder}, this
  * binder needs to be registered with a {@link net.bytebuddy.implementation.MethodDelegation} before it can be used.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -38,7 +38,7 @@
 /**
  * Using this annotation it is possible to access fields by getter and setter types. Before this annotation can be
  * used, it needs to be installed with two types. The getter type must be defined in a single-method interface
- * with a single method that returns an {@link java.lang.Object} type and takes no arguments. The getter interface
+ * with a single method that returns an {@link java.lang.Object} type and takes no arguments. The setter interface
  * must similarly return {@code void} and take a single {@link java.lang.Object} argument. After installing these
  * interfaces with the {@link FieldProxy.Binder}, this
  * binder needs to be registered with a {@link net.bytebuddy.implementation.MethodDelegation} before it can be used.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/NoOpClassFileTransformer.java
Patch:
@@ -1,5 +1,7 @@
 package net.bytebuddy.dynamic.loading;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+
 import java.lang.instrument.ClassFileTransformer;
 import java.security.ProtectionDomain;
 
@@ -19,6 +21,7 @@ public enum NoOpClassFileTransformer implements ClassFileTransformer {
     private static final byte[] NO_TRANSFORMATION = null;
 
     @Override
+    @SuppressFBWarnings(value = "EI_EXPOSE_REP", justification = "Array is guaranteed to be null")
     public byte[] transform(ClassLoader loader,
                             String className,
                             Class<?> classBeingRedefined,

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -419,7 +419,9 @@ public void testIsAssignable() throws Exception {
 
     @Test
     public void testIsAssignableClassLoader() throws Exception {
-        ClassLoader classLoader = new ByteArrayClassLoader(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassFileExtraction.of(SimpleType.class));
+        ClassLoader classLoader = new ByteArrayClassLoader(ClassLoadingStrategy.BOOTSTRAP_LOADER,
+                ClassFileExtraction.of(SimpleType.class),
+                ByteArrayClassLoader.PersistenceHandler.MANIFEST);
         Class<?> otherSimpleType = classLoader.loadClass(SimpleType.class.getName());
         assertThat(describe(SimpleType.class).isAssignableFrom(describe(otherSimpleType)), is(true));
         assertThat(describe(SimpleType.class).isAssignableTo(describe(otherSimpleType)), is(true));

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodList.java
Patch:
@@ -49,8 +49,8 @@ protected MethodList<S> wrap(List<S> values) {
         @Override
         public ByteCodeElement.Token.TokenList<MethodDescription.Token> asTokenList(ElementMatcher<? super TypeDescription> matcher) {
             List<MethodDescription.Token> tokens = new ArrayList<MethodDescription.Token>(size());
-            for (MethodDescription fieldDescription : this) {
-                tokens.add(fieldDescription.asToken(matcher));
+            for (MethodDescription methodDescription : this) {
+                tokens.add(methodDescription.asToken(matcher));
             }
             return new ByteCodeElement.Token.TokenList<MethodDescription.Token>(tokens);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -956,9 +956,9 @@ public boolean matches(TypeDescription typeDescription,
             }
 
             /**
-             * Returns an inverted version of this matcher,
+             * Returns an inverted version of this matcher.
              *
-             * @return An inverted version of this matcher,
+             * @return An inverted version of this matcher.
              */
             public RawMatcher inverted() {
                 return new Inversion(this);

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/TransformationAction.java
Patch:
@@ -211,7 +211,7 @@ private void processClassFile(File root,
                                   ClassFileLocator classFileLocator,
                                   TypePool typePool,
                                   List<Plugin> plugins) {
-        String typeName = file.replace(File.separatorChar, '.').substring(0, file.length() - CLASS_FILE_EXTENSION.length());
+        String typeName = file.replace('/', '.').substring(0, file.length() - CLASS_FILE_EXTENSION.length());
         project.getLogger().debug("Processing class file: {}", typeName);
         TypeDescription typeDescription = typePool.describe(typeName).resolve();
         DynamicType.Builder<?> builder;

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/ByteBuddyMojo.java
Patch:
@@ -317,7 +317,7 @@ private void processClassFile(File root,
                                   ClassFileLocator classFileLocator,
                                   TypePool typePool,
                                   List<Plugin> plugins) throws MojoExecutionException, MojoFailureException {
-        String typeName = file.replace(File.separatorChar, '.').substring(0, file.length() - CLASS_FILE_EXTENSION.length());
+        String typeName = file.replace('/', '.').substring(0, file.length() - CLASS_FILE_EXTENSION.length());
         getLog().debug("Processing class file: " + typeName);
         TypeDescription typeDescription = typePool.describe(typeName).resolve();
         DynamicType.Builder<?> builder;

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/TransformationAction.java
Patch:
@@ -211,7 +211,7 @@ private void processClassFile(File root,
                                   ClassFileLocator classFileLocator,
                                   TypePool typePool,
                                   List<Plugin> plugins) {
-        String typeName = file.replace(File.separatorChar, '.').substring(0, file.length() - CLASS_FILE_EXTENSION.length());
+        String typeName = file.replace('/', '.').substring(0, file.length() - CLASS_FILE_EXTENSION.length());
         project.getLogger().debug("Processing class file: {}", typeName);
         TypeDescription typeDescription = typePool.describe(typeName).resolve();
         DynamicType.Builder<?> builder;

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/ByteBuddyMojo.java
Patch:
@@ -317,7 +317,7 @@ private void processClassFile(File root,
                                   ClassFileLocator classFileLocator,
                                   TypePool typePool,
                                   List<Plugin> plugins) throws MojoExecutionException, MojoFailureException {
-        String typeName = file.replace(File.separatorChar, '.').substring(0, file.length() - CLASS_FILE_EXTENSION.length());
+        String typeName = file.replace('/', '.').substring(0, file.length() - CLASS_FILE_EXTENSION.length());
         getLog().debug("Processing class file: " + typeName);
         TypeDescription typeDescription = typePool.describe(typeName).resolve();
         DynamicType.Builder<?> builder;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodRegistry.java
Patch:
@@ -438,9 +438,10 @@ public MethodRegistry.Prepared prepare(InstrumentedType instrumentedType,
                     }
                 }
                 if (visibilityBridge
+                        && !node.getSort().isMadeVisible()
                         && methodDescription.isPublic()
+                        && !methodDescription.isDefaultMethod()
                         && !(methodDescription.isAbstract() || methodDescription.isFinal())
-                        && !node.getSort().isMadeVisible()
                         && methodDescription.getDeclaringType().isPackagePrivate()) {
                     // Visibility bridges are required for public classes that inherit a public method from a package-private class.
                     implementations.put(methodDescription, Prepared.Entry.forVisibilityBridge(methodDescription, node.getVisibility()));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -838,9 +838,7 @@ protected OfVisibilityBridge(MethodDescription visibilityBridge,
                     public static Record of(TypeDescription instrumentedType, MethodDescription bridgeTarget, MethodAttributeAppender attributeAppender) {
                         return new OfVisibilityBridge(new VisibilityBridge(instrumentedType, bridgeTarget),
                                 bridgeTarget,
-                                (bridgeTarget.isDefaultMethod()
-                                        ? bridgeTarget.getDeclaringType()
-                                        : instrumentedType.getSuperClass()).asErasure(),
+                                instrumentedType.getSuperClass().asErasure(),
                                 attributeAppender);
                     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -4916,6 +4916,7 @@ protected ResubmissionListener(ElementMatcher<? super Throwable> matcher, Concur
                     }
 
                     @Override
+                    @SuppressFBWarnings(value = "GC_UNRELATED_TYPES", justification = "Use of unrelated key is inteded for avoiding unnecessary weak reference")
                     public void onError(String typeName, ClassLoader classLoader, JavaModule module, boolean loaded, Throwable throwable) {
                         if (!loaded && matcher.matches(throwable)) {
                             Set<String> types = this.types.get(new LookupKey(classLoader));

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRedefinitionStrategyResubmissionStrategyTest.java
Patch:
@@ -1,6 +1,5 @@
 package net.bytebuddy.agent.builder;
 
-import com.sun.tools.javac.util.List;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
@@ -25,6 +24,7 @@
 import java.net.URLClassLoader;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.List;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/TypeCache.java
Patch:
@@ -167,7 +167,7 @@ public Class<?> findOrInsert(ClassLoader classLoader, T key, Callable<Class<?>>
      * Removes any stale class loader entries from the cache.
      */
     public void expungeStaleEntries() {
-        Object reference;
+        Reference<?> reference;
         while ((reference = poll()) != null) {
             cache.remove(reference);
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -1,6 +1,5 @@
 package net.bytebuddy.agent.builder;
 
-import com.sun.org.apache.regexp.internal.RE;
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.build.EntryPoint;
 import net.bytebuddy.build.Plugin;
@@ -36,7 +35,6 @@
 import java.lang.instrument.Instrumentation;
 import java.lang.instrument.UnmodifiableClassException;
 import java.lang.reflect.Constructor;
-import java.security.AccessControlContext;
 import java.security.ProtectionDomain;
 import java.util.*;
 
@@ -2043,7 +2041,7 @@ public void testDisableClassFormatChanges() throws Exception {
         assertThat(new AgentBuilder.Default().disableClassFormatChanges(), is(new AgentBuilder.Default(new ByteBuddy()
                 .with(Implementation.Context.Disabled.Factory.INSTANCE))
                 .with(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)
-                .with(AgentBuilder.TypeStrategy.Default.REDEFINE_DECLARED_ONLY)));
+                .with(AgentBuilder.TypeStrategy.Default.REDEFINE_FROZEN)));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderTypeStrategyTest.java
Patch:
@@ -64,7 +64,7 @@ public void testRedefine() throws Exception {
     public void testRedefineDeclaredOnly() throws Exception {
         when(byteBuddy.redefine(typeDescription, classFileLocator)).thenReturn((DynamicType.Builder) dynamicTypeBuilder);
         when(dynamicTypeBuilder.ignoreAlso(LatentMatcher.ForSelfDeclaredMethod.NOT_DECLARED)).thenReturn((DynamicType.Builder) dynamicTypeBuilder);
-        assertThat(AgentBuilder.TypeStrategy.Default.REDEFINE_DECLARED_ONLY.builder(typeDescription, byteBuddy, classFileLocator, methodNameTransformer),
+        assertThat(AgentBuilder.TypeStrategy.Default.REDEFINE_FROZEN.builder(typeDescription, byteBuddy, classFileLocator, methodNameTransformer),
                 is((DynamicType.Builder) dynamicTypeBuilder));
         verify(byteBuddy).redefine(typeDescription, classFileLocator);
         verifyNoMoreInteractions(byteBuddy);

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultWithLazyResolutionTypeDescriptionTest.java
Patch:
@@ -110,7 +110,6 @@ public void testReferencedTypeIsCached() throws Exception {
     }
 
     @Test
-    @Ignore("Lazy-chain is currently broken")
     public void testNonGenericResolutionIsLazyForSimpleCreation() throws Exception {
         ClassFileLocator classFileLocator = spy(ClassFileLocator.ForClassLoader.ofClassPath());
         new ByteBuddy()
@@ -123,7 +122,7 @@ public void testNonGenericResolutionIsLazyForSimpleCreation() throws Exception {
     }
 
     @Test
-    @Ignore("Lazy-chain is currently broken")
+    @Ignore("Lazy-chain is currently broken for generic types")
     public void testGenericResolutionIsLazyForSimpleCreation() throws Exception {
         ClassFileLocator classFileLocator = spy(ClassFileLocator.ForClassLoader.ofClassPath());
         new ByteBuddy()

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionErasureMatcher.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.List;
 
 /**
- * An element matcher that matches a collection of types by their raw types.
+ * An element matcher that matches a collection of types by their erasures.
  *
  * @param <T> The type of the matched entity.
  */

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionErasureMatcher.java
Patch:
@@ -13,7 +13,7 @@
  * @param <T> The type of the matched entity.
  */
 @EqualsAndHashCode(callSuper = false)
-public class CollectionRawTypeMatcher<T extends Iterable<? extends TypeDefinition>> extends ElementMatcher.Junction.AbstractBase<T> {
+public class CollectionErasureMatcher<T extends Iterable<? extends TypeDefinition>> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**
      * The matcher to be applied to the raw types.
@@ -25,7 +25,7 @@ public class CollectionRawTypeMatcher<T extends Iterable<? extends TypeDefinitio
      *
      * @param matcher The matcher to be applied to the raw types.
      */
-    public CollectionRawTypeMatcher(ElementMatcher<? super Iterable<? extends TypeDescription>> matcher) {
+    public CollectionErasureMatcher(ElementMatcher<? super Iterable<? extends TypeDescription>> matcher) {
         this.matcher = matcher;
     }
 
@@ -40,6 +40,6 @@ public boolean matches(T target) {
 
     @Override
     public String toString() {
-        return "rawTypes(" + matcher + ')';
+        return "erasures(" + matcher + ')';
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -262,7 +262,7 @@ public <T> DynamicType.Builder<T> subclass(Class<T> superType, ConstructorStrate
      * <p>
      * When extending a class, Byte Buddy imitates all visible constructors of the subclassed type. Any constructor is implemented
      * to only invoke its super type constructor of equal signature. Another behavior can be specified by supplying an explicit
-     * {@link ConstructorStrategy} by {@link ByteBuddy#subclassGeneric(Type, ConstructorStrategy)}.
+     * {@link ConstructorStrategy} by {@link ByteBuddy#subclass(Type, ConstructorStrategy)}.
      * </p>
      * <p>
      * <b>Note</b>: This methods implements the supplied types <i>as is</i>, i.e. any {@link Class} values are implemented
@@ -314,7 +314,7 @@ public DynamicType.Builder<?> subclass(Type superType, ConstructorStrategy const
      * <p>
      * When extending a class, Byte Buddy imitates all visible constructors of the subclassed type and sets them to be {@code public}.
      * Any constructor is implemented to only invoke its super type constructor of equal signature. Another behavior can be specified by
-     * supplying an explicit {@link ConstructorStrategy} by {@link ByteBuddy#subclassGeneric(TypeDefinition, ConstructorStrategy)}.
+     * supplying an explicit {@link ConstructorStrategy} by {@link ByteBuddy#subclass(TypeDefinition, ConstructorStrategy)}.
      * </p>
      * <p>
      * <b>Note</b>: This methods implements the supplied types <i>as is</i>, i.e. any {@link TypeDescription} values are implemented

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultApplicationSuperTypeLoadingTest.java
Patch:
@@ -48,7 +48,7 @@ public class AgentBuilderDefaultApplicationSuperTypeLoadingTest {
     @Before
     public void setUp() throws Exception {
         classLoader = new ByteArrayClassLoader(ClassLoadingStrategy.BOOTSTRAP_LOADER,
-                ClassFileExtraction.of(Foo.class, Bar.class),
+                ClassFileExtraction.of(Foo.class, Bar.class, AgentBuilderDefaultApplicationSuperTypeLoadingTest.class),
                 ClassLoadingStrategy.NO_PROTECTION_DOMAIN,
                 ByteArrayClassLoader.PersistenceHandler.MANIFEST,
                 PackageDefinitionStrategy.NoOp.INSTANCE);

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericOfParameterizedTypeForReifiedTypeTest.java
Patch:
@@ -10,7 +10,7 @@ public class TypeDescriptionGenericOfParameterizedTypeForReifiedTypeTest {
     @Test
     public void testGenerifiedType() throws Exception {
         TypeDescription.Generic typeDescription = new TypeDescription.Generic.OfParameterizedType.ForReifiedType(new TypeDescription.ForLoadedType(Qux.class).getSuperClass());
-        assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.NON_GENERIC));
+        assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
         assertThat(typeDescription.asErasure(), is((TypeDescription) new TypeDescription.ForLoadedType(Bar.class)));
         assertThat(typeDescription.getSuperClass().getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
         assertThat(typeDescription.getSuperClass().asErasure(), is((TypeDescription) new TypeDescription.ForLoadedType(Foo.class)));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -454,7 +454,7 @@ protected Default(Harmonizer<T> harmonizer, Merger merger, TypeDescription.Gener
              * @return A default compiler for the given harmonizer and merger.
              */
             public static <S> Compiler of(Harmonizer<S> harmonizer, Merger merger) {
-                return new Default<S>(harmonizer, merger, TypeDescription.Generic.Visitor.Reifying.INSTANCE);
+                return new Default<S>(harmonizer, merger, TypeDescription.Generic.Visitor.Reifying.INITIATING);
             }
 
             /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorReifyingTest.java
Patch:
@@ -11,7 +11,7 @@
 import static org.mockito.Mockito.when;
 
 public class TypeDescriptionGenericVisitorReifyingTest {
-
+/*
     @Rule
     public TestRule mockitoRule = new MockitoRule(this);
 
@@ -49,7 +49,7 @@ public void testGenericArray() throws Exception {
     public void testWildcard() throws Exception {
         TypeDescription.Generic.Visitor.Reifying.INSTANCE.onWildcard(generic);
     }
-
+*/ // TODO: FIXME
     private static class Foo<T> {
         /* empty */
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultHarmonizerForJVMMethodTest.java
Patch:
@@ -73,7 +73,7 @@ public void testMethodParameterTypesEquality() throws Exception {
     public void testFactory() throws Exception {
         assertThat(MethodGraph.Compiler.Default.forJVMHierarchy(), is((MethodGraph.Compiler) new MethodGraph.Compiler
                 .Default<MethodGraph.Compiler.Default.Harmonizer.ForJVMMethod.Token>(MethodGraph.Compiler.Default.Harmonizer.ForJVMMethod.INSTANCE,
-                MethodGraph.Compiler.Default.Merger.Directional.LEFT, TypeDescription.Generic.Visitor.Reifying.INSTANCE)));
+                MethodGraph.Compiler.Default.Merger.Directional.LEFT, TypeDescription.Generic.Visitor.Reifying.INITIATING)));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultHarmonizerForJavaMethodTest.java
Patch:
@@ -77,7 +77,7 @@ public void testMethodParameterTypesEquality() throws Exception {
     public void testFactory() throws Exception {
         assertThat(MethodGraph.Compiler.Default.forJavaHierarchy(), is((MethodGraph.Compiler) new MethodGraph.Compiler
                 .Default<MethodGraph.Compiler.Default.Harmonizer.ForJavaMethod.Token>(MethodGraph.Compiler.Default.Harmonizer.ForJavaMethod.INSTANCE,
-                MethodGraph.Compiler.Default.Merger.Directional.LEFT, TypeDescription.Generic.Visitor.Reifying.INSTANCE)));
+                MethodGraph.Compiler.Default.Merger.Directional.LEFT, TypeDescription.Generic.Visitor.Reifying.INITIATING)));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -488,7 +488,7 @@ public DynamicType.Builder<?> apply(DynamicType.Builder<?> builder,
                                                     FieldDescription fieldDescription,
                                                     Assigner assigner,
                                                     MethodAccessorFactory methodAccessorFactory) {
-                    return builder.method(is(getterMethod)).intercept(new FieldGetter(fieldDescription, assigner, methodAccessorFactory));
+                    return builder.method(definedMethod(is(getterMethod))).intercept(new FieldGetter(fieldDescription, assigner, methodAccessorFactory));
                 }
             }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -611,7 +611,7 @@ public void testTypeAnnotationOnInterfaceType() throws Exception {
         MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Class<?> type = createPlain()
                 .merge(TypeManifestation.ABSTRACT)
-                .implementGeneric(TypeDescription.Generic.Builder.rawType(Runnable.class)
+                .implement(TypeDescription.Generic.Builder.rawType(Runnable.class)
                         .build(AnnotationDescription.Builder.ofType(typeAnnotationType).define(VALUE, INTEGER_VALUE).build()))
                 .make()
                 .load(typeAnnotationType.getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST)

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/AbstractDynamicTypeBuilderForInliningTest.java
Patch:
@@ -477,7 +477,7 @@ public void testAnnotationTypeOnInterfaceType() throws Exception {
         MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Class<?> type = create(Class.forName(SIMPLE_TYPE_ANNOTATED))
                 .merge(TypeManifestation.ABSTRACT)
-                .implementGeneric(TypeDescription.Generic.Builder.rawType(Callable.class)
+                .implement(TypeDescription.Generic.Builder.rawType(Callable.class)
                         .build(AnnotationDescription.Builder.ofType(typeAnnotationType).define(VALUE, QUX * 3).build()))
                 .make()
                 .load(typeAnnotationType.getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST)

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderTest.java
Patch:
@@ -342,7 +342,6 @@ public void testDoesNotOverridePrivateMethod() throws Exception {
     }
 
     @Test
-    @Ignore("TODO: Fixme")
     public void testGenericTypeRawExtension() throws Exception {
         Class<?> dynamicType = new ByteBuddy()
                 .subclass(GenericType.Inner.class)
@@ -492,7 +491,7 @@ public void testAnnotationTypeOnSuperClass() throws Exception {
         Class<? extends Annotation> typeAnnotationType = (Class<? extends Annotation>) Class.forName(TYPE_VARIABLE_NAME);
         MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Class<?> type = new ByteBuddy()
-                .subclassGeneric(TypeDescription.Generic.Builder.rawType(Object.class)
+                .subclass(TypeDescription.Generic.Builder.rawType(Object.class)
                         .build(AnnotationDescription.Builder.ofType(typeAnnotationType).define(VALUE, BAZ).build()))
                 .make()
                 .load(typeAnnotationType.getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST)

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -276,7 +276,7 @@ public <T> DynamicType.Builder<T> subclass(Class<T> superType, ConstructorStrate
      * @return A type builder for creating a new class extending the provided class or interface.
      */
     public DynamicType.Builder<?> subclass(TypeDescription superType) {
-        return subclassGeneric(TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(superType));
+        return subclassGeneric(TypeDescription.Generic.OfParameterizedType.ForReifiedErasure.of(superType));
     }
 
     /**
@@ -297,7 +297,7 @@ public DynamicType.Builder<?> subclass(TypeDescription superType) {
      * @return A type builder for creating a new class extending the provided class or interface.
      */
     public DynamicType.Builder<?> subclass(TypeDescription superType, ConstructorStrategy constructorStrategy) {
-        return subclassGeneric(TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(superType), constructorStrategy);
+        return subclassGeneric(TypeDescription.Generic.OfParameterizedType.ForReifiedErasure.of(superType), constructorStrategy);
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -314,14 +314,14 @@ public TypeDescription.Generic getReceiverType() {
                 } else if (isConstructor()) {
                     TypeDescription declaringType = getDeclaringType(), enclosingDeclaringType = getDeclaringType().getEnclosingType();
                     if (enclosingDeclaringType == null) {
-                        return TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(declaringType);
+                        return TypeDescription.Generic.OfParameterizedType.ForReifiedErasure.of(declaringType); // TODO: Fix
                     } else {
                         return declaringType.isStatic()
                                 ? enclosingDeclaringType.asGenericType()
-                                : TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(enclosingDeclaringType);
+                                : TypeDescription.Generic.OfParameterizedType.ForReifiedErasure.of(enclosingDeclaringType); // TODO: Fix
                     }
                 } else {
-                    return TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(getDeclaringType());
+                    return TypeDescription.Generic.OfParameterizedType.ForReifiedErasure.of(getDeclaringType()); // TODO: Fix
                 }
             }
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -683,7 +683,7 @@ public ForGenerifiedErasures(List<? extends TypeDescription> typeDescriptions) {
 
             @Override
             public TypeDescription.Generic get(int index) {
-                return TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(typeDescriptions.get(index));
+                return TypeDescription.Generic.OfParameterizedType.ForReifiedErasure.of(typeDescriptions.get(index));
             }
 
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultHarmonizerForJVMMethodTest.java
Patch:
@@ -73,7 +73,7 @@ public void testMethodParameterTypesEquality() throws Exception {
     public void testFactory() throws Exception {
         assertThat(MethodGraph.Compiler.Default.forJVMHierarchy(), is((MethodGraph.Compiler) new MethodGraph.Compiler
                 .Default<MethodGraph.Compiler.Default.Harmonizer.ForJVMMethod.Token>(MethodGraph.Compiler.Default.Harmonizer.ForJVMMethod.INSTANCE,
-                MethodGraph.Compiler.Default.Merger.Directional.LEFT)));
+                MethodGraph.Compiler.Default.Merger.Directional.LEFT, TypeDescription.Generic.Visitor.Reifying.INSTANCE)));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultHarmonizerForJavaMethodTest.java
Patch:
@@ -77,7 +77,7 @@ public void testMethodParameterTypesEquality() throws Exception {
     public void testFactory() throws Exception {
         assertThat(MethodGraph.Compiler.Default.forJavaHierarchy(), is((MethodGraph.Compiler) new MethodGraph.Compiler
                 .Default<MethodGraph.Compiler.Default.Harmonizer.ForJavaMethod.Token>(MethodGraph.Compiler.Default.Harmonizer.ForJavaMethod.INSTANCE,
-                MethodGraph.Compiler.Default.Merger.Directional.LEFT)));
+                MethodGraph.Compiler.Default.Merger.Directional.LEFT, TypeDescription.Generic.Visitor.Reifying.INSTANCE)));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -611,7 +611,7 @@ public void testTypeAnnotationOnInterfaceType() throws Exception {
         MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Class<?> type = createPlain()
                 .merge(TypeManifestation.ABSTRACT)
-                .implement(TypeDescription.Generic.Builder.rawType(Runnable.class)
+                .implementGeneric(TypeDescription.Generic.Builder.rawType(Runnable.class)
                         .build(AnnotationDescription.Builder.ofType(typeAnnotationType).define(VALUE, INTEGER_VALUE).build()))
                 .make()
                 .load(typeAnnotationType.getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST)

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/AbstractDynamicTypeBuilderForInliningTest.java
Patch:
@@ -477,7 +477,7 @@ public void testAnnotationTypeOnInterfaceType() throws Exception {
         MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Class<?> type = create(Class.forName(SIMPLE_TYPE_ANNOTATED))
                 .merge(TypeManifestation.ABSTRACT)
-                .implement(TypeDescription.Generic.Builder.rawType(Callable.class)
+                .implementGeneric(TypeDescription.Generic.Builder.rawType(Callable.class)
                         .build(AnnotationDescription.Builder.ofType(typeAnnotationType).define(VALUE, QUX * 3).build()))
                 .make()
                 .load(typeAnnotationType.getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST)

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderTest.java
Patch:
@@ -342,7 +342,7 @@ public void testDoesNotOverridePrivateMethod() throws Exception {
     }
 
     @Test
-    @Ignore("Is not longer true with proper raw type handling")
+    @Ignore("TODO: Fixme")
     public void testGenericTypeRawExtension() throws Exception {
         Class<?> dynamicType = new ByteBuddy()
                 .subclass(GenericType.Inner.class)
@@ -492,7 +492,7 @@ public void testAnnotationTypeOnSuperClass() throws Exception {
         Class<? extends Annotation> typeAnnotationType = (Class<? extends Annotation>) Class.forName(TYPE_VARIABLE_NAME);
         MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Class<?> type = new ByteBuddy()
-                .subclass(TypeDescription.Generic.Builder.rawType(Object.class)
+                .subclassGeneric(TypeDescription.Generic.Builder.rawType(Object.class)
                         .build(AnnotationDescription.Builder.ofType(typeAnnotationType).define(VALUE, BAZ).build()))
                 .make()
                 .load(typeAnnotationType.getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST)

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationFieldProxyTest.java
Patch:
@@ -5,7 +5,9 @@
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.implementation.bind.annotation.Argument;
 import net.bytebuddy.implementation.bind.annotation.FieldProxy;
+import net.bytebuddy.test.utility.DebuggingWrapper;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.Serializable;
@@ -14,6 +16,7 @@
 import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.assertThat;
 
+@Ignore("TODO: Fixme")
 public class MethodDelegationFieldProxyTest {
 
     private static final String FOO = "foo", BAR = "bar", QUX = "qux";

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/ByteCodeElement.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.description;
 
-import net.bytebuddy.description.annotation.AnnotatedCodeElement;
+import net.bytebuddy.description.annotation.AnnotationSource;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.matcher.ElementMatcher;
 import net.bytebuddy.matcher.FilterableList;
@@ -12,7 +12,7 @@
 /**
  * Implementations describe an element represented in byte code, i.e. a type, a field or a method or a constructor.
  */
-public interface ByteCodeElement extends NamedElement.WithRuntimeName, ModifierReviewable, DeclaredByType, AnnotatedCodeElement {
+public interface ByteCodeElement extends NamedElement.WithRuntimeName, ModifierReviewable, DeclaredByType, AnnotationSource {
 
     /**
      * The generic type signature of a non-generic byte code element.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -5,7 +5,7 @@
 import net.bytebuddy.description.ByteCodeElement;
 import net.bytebuddy.description.ModifierReviewable;
 import net.bytebuddy.description.NamedElement;
-import net.bytebuddy.description.annotation.AnnotatedCodeElement;
+import net.bytebuddy.description.annotation.AnnotationSource;
 import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.annotation.AnnotationList;
 import net.bytebuddy.description.type.TypeDefinition;
@@ -25,7 +25,7 @@
 /**
  * Description of the parameter of a Java method or constructor.
  */
-public interface ParameterDescription extends AnnotatedCodeElement,
+public interface ParameterDescription extends AnnotationSource,
         NamedElement.WithRuntimeName,
         NamedElement.WithOptionalName,
         ModifierReviewable.ForParameterDescription,

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/PackageDescription.java
Patch:
@@ -1,14 +1,14 @@
 package net.bytebuddy.description.type;
 
 import net.bytebuddy.description.NamedElement;
-import net.bytebuddy.description.annotation.AnnotatedCodeElement;
+import net.bytebuddy.description.annotation.AnnotationSource;
 import net.bytebuddy.description.annotation.AnnotationList;
 import org.objectweb.asm.Opcodes;
 
 /**
  * A package description represents a Java package.
  */
-public interface PackageDescription extends NamedElement.WithRuntimeName, AnnotatedCodeElement {
+public interface PackageDescription extends NamedElement.WithRuntimeName, AnnotationSource {
 
     /**
      * The name of a Java class representing a package description.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/Transformer.java
Patch:
@@ -486,7 +486,7 @@ public TypeDescription.Generic onTypeVariable(TypeDescription.Generic typeVariab
                     if (attached == null) {
                         throw new IllegalArgumentException("Cannot attach undefined variable: " + typeVariable);
                     } else {
-                        return new TypeDescription.Generic.OfTypeVariable.WithAnnotationOverlay(attached, typeVariable.getDeclaredAnnotations());
+                        return new TypeDescription.Generic.OfTypeVariable.WithAnnotationOverlay(attached, typeVariable);
                     }
                 }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringAnnotationMatcher.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import lombok.EqualsAndHashCode;
-import net.bytebuddy.description.annotation.AnnotatedCodeElement;
+import net.bytebuddy.description.annotation.AnnotationSource;
 import net.bytebuddy.description.annotation.AnnotationList;
 
 /**
@@ -10,7 +10,7 @@
  * @param <T> The actual matched type of this matcher.
  */
 @EqualsAndHashCode(callSuper = false)
-public class DeclaringAnnotationMatcher<T extends AnnotatedCodeElement> extends ElementMatcher.Junction.AbstractBase<T> {
+public class DeclaringAnnotationMatcher<T extends AnnotationSource> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**
      * The matcher to be applied to the provided annotation list.

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericOfTypeVariableWithAnnotationOverlayTest.java
Patch:
@@ -3,6 +3,7 @@
 import net.bytebuddy.description.TypeVariableSource;
 import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.annotation.AnnotationList;
+import net.bytebuddy.description.annotation.AnnotationSource;
 import net.bytebuddy.implementation.bytecode.StackSize;
 import net.bytebuddy.test.utility.MockitoRule;
 import org.junit.Before;
@@ -11,8 +12,6 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 
-import java.util.Collections;
-
 import static org.hamcrest.CoreMatchers.*;
 import static org.junit.Assert.assertThat;
 import static org.mockito.Mockito.mock;
@@ -44,7 +43,7 @@ public void setUp() throws Exception {
         when(original.getUpperBounds()).thenReturn(new TypeList.Generic.Explicit(upperBound));
         when(original.getLowerBounds()).thenReturn(new TypeList.Generic.Explicit(lowerBound));
         when(original.getTypeVariableSource()).thenReturn(typeVariableSource);
-        typeVariable = new TypeDescription.Generic.OfTypeVariable.WithAnnotationOverlay(original, Collections.singletonList(annotationDescription));
+        typeVariable = new TypeDescription.Generic.OfTypeVariable.WithAnnotationOverlay(original, new AnnotationSource.Explicit(annotationDescription));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorSubstitutorForTokenNormalizationTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.description.type;
 
+import net.bytebuddy.description.annotation.AnnotationSource;
 import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.annotation.AnnotationList;
 import net.bytebuddy.dynamic.TargetType;
@@ -44,7 +45,7 @@ public void setUp() throws Exception {
     @Test
     public void testTargetType() throws Exception {
         TypeDescription.Generic typeDescription = new TypeDescription.Generic.Visitor.Substitutor.ForTokenNormalization(target)
-                .onSimpleType(new TypeDescription.Generic.OfNonGenericType.Latent(TargetType.DESCRIPTION, Collections.singletonList(annotationDescription)));
+                .onSimpleType(new TypeDescription.Generic.OfNonGenericType.Latent(TargetType.DESCRIPTION, new AnnotationSource.Explicit(annotationDescription)));
         assertThat(typeDescription.asErasure(), is(target));
         assertThat(typeDescription.getDeclaredAnnotations(), is(Collections.singletonList(annotationDescription)));
     }
@@ -57,7 +58,7 @@ public void testNotTargetType() throws Exception {
     @Test
     public void testTypeVariable() throws Exception {
         TypeDescription.Generic typeDescription = new TypeDescription.Generic.Visitor.Substitutor.ForTokenNormalization(target).onTypeVariable(source);
-        assertThat(typeDescription, is((TypeDescription.Generic) new TypeDescription.Generic.OfTypeVariable.Symbolic(FOO, Collections.singletonList(annotationDescription))));
+        assertThat(typeDescription, is((TypeDescription.Generic) new TypeDescription.Generic.OfTypeVariable.Symbolic(FOO, new AnnotationSource.Explicit(annotationDescription))));
         assertThat(typeDescription.getDeclaredAnnotations(), is(Collections.singletonList(annotationDescription)));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionGenericTest.java
Patch:
@@ -1116,6 +1116,7 @@ public void testMethodTypeVariableWithExtensionIsRetained() throws Exception {
     }
 
     @Test
+    @Ignore("Is not longer true with proper raw type handling")
     public void testMethodTypeVariableErasedBound() throws Exception {
         TypeDescription.Generic typeDescription = describeType(MemberVariable.class.getDeclaredField(BAR)).getSuperClass();
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.NON_GENERIC));
@@ -1126,6 +1127,7 @@ public void testMethodTypeVariableErasedBound() throws Exception {
     }
 
     @Test
+    @Ignore("Is not longer true with proper raw type handling")
     public void testMethodTypeVariableWithExtensionErasedBound() throws Exception {
         TypeDescription.Generic typeDescription = describeType(MemberVariable.class.getDeclaredField(BAR)).getSuperClass();
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.NON_GENERIC));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderTest.java
Patch:
@@ -24,6 +24,7 @@
 import net.bytebuddy.test.utility.JavaVersionRule;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.hamcrest.CoreMatchers;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.MethodRule;
@@ -341,6 +342,7 @@ public void testDoesNotOverridePrivateMethod() throws Exception {
     }
 
     @Test
+    @Ignore("Is not longer true with proper raw type handling")
     public void testGenericTypeRawExtension() throws Exception {
         Class<?> dynamicType = new ByteBuddy()
                 .subclass(GenericType.Inner.class)

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/TypeVariableSource.java
Patch:
@@ -56,7 +56,7 @@ public interface TypeVariableSource extends ModifierReviewable.OfAbstraction {
      *
      * @return {@code true} if this type code element has a generic declaration.
      */
-    boolean isGenericDeclaration();
+    boolean isGenerified();
 
     /**
      * A visitor that can be applied to a type variable source.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -679,7 +679,7 @@ public <T> T accept(TypeVariableSource.Visitor<T> visitor) {
         }
 
         @Override
-        public boolean isGenericDeclaration() {
+        public boolean isGenerified() {
             return !getTypeVariables().isEmpty();
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/AbstractMethodDescriptionTest.java
Patch:
@@ -709,9 +709,9 @@ public void testEnclosingSource() throws Exception {
     }
 
     @Test
-    public void testIsGenericDeclaration() throws Exception {
-        assertThat(describe(genericMethodWithTypeVariable).isGenericDeclaration(), is(true));
-        assertThat(describe(firstMethod).isGenericDeclaration(), is(false));
+    public void testIsGenerified() throws Exception {
+        assertThat(describe(genericMethodWithTypeVariable).isGenerified(), is(true));
+        assertThat(describe(firstMethod).isGenerified(), is(false));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -451,7 +451,7 @@ public ForDetachedTypes(List<? extends TypeDescription.Generic> detachedTypes,
              * @param detachedTypes   The detached types.
              * @return A type list representing the detached types being attached to the provided type description.
              */
-            public static Generic attach(TypeDescription typeDescription, List<? extends TypeDescription.Generic> detachedTypes) {
+            public static Generic attachLazy(TypeDescription typeDescription, List<? extends TypeDescription.Generic> detachedTypes) {
                 return new WithLazyResolution(detachedTypes, TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(typeDescription));
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -676,7 +676,7 @@ public Generic getSuperClass() {
 
         @Override
         public TypeList.Generic getInterfaces() {
-            return TypeList.Generic.ForDetachedTypes.attach(this, interfaceTypes);
+            return TypeList.Generic.ForDetachedTypes.attachLazy(this, interfaceTypes);
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -671,7 +671,7 @@ public TypeDescription getDeclaringType() {
         public Generic getSuperClass() {
             return superClass == null
                     ? Generic.UNDEFINED
-                    : superClass.accept(Generic.Visitor.Substitutor.ForAttachment.of(this));
+                    : new Generic.LazyProjection.WithLazyNavigation.Detached(superClass, Generic.Visitor.Substitutor.ForAttachment.of(this));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -1485,7 +1485,7 @@ public Resubmitting with(RedefinitionStrategy.Listener redefinitionListener) {
                         redefinitionStrategy,
                         redefinitionBatchAllocator,
                         new RedefinitionStrategy.Listener.Compound(this.redefinitionListener, redefinitionListener),
-                        this.matcher.and(matcher));
+                        matcher);
             }
 
             /**
@@ -1501,7 +1501,7 @@ public Resubmitting filter(ElementMatcher<? super Throwable> matcher) {
                         redefinitionStrategy,
                         redefinitionBatchAllocator,
                         redefinitionListener,
-                        this.matcher.and(matcher));
+                        this.matcher.<Throwable>and(matcher));
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -2906,6 +2906,7 @@ public Class<?> load(String name, ClassLoader classLoader) throws ClassNotFoundE
              * </p>
              * <p>
              * <b>Important</b>: This strategy can dead-lock under two circumstances:
+             * </p>
              * <ul>
              * <li>
              * <b>Classes declare circularities</b>: Under normal circumstances, such scenarios result in a {@link ClassCircularityError} but
@@ -2916,7 +2917,8 @@ public Class<?> load(String name, ClassLoader classLoader) throws ClassNotFoundE
              * be released by this strategy.
              * </li>
              * </ul>
-             * For these reasons, it is not recommended to use this strategy when the target class loader is unknown or if the target application
+             * <p>
+             * For the above reasons, it is not recommended to use this strategy when the target class loader is unknown or if the target application
              * might contain corrupt class files.
              * </p>
              */

File: byte-buddy-dep/src/test/java/net/bytebuddy/ClassFileVersionTest.java
Patch:
@@ -46,7 +46,6 @@ public void testVersionOfClass() throws Exception {
     @Test
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(ClassFileVersion.class).apply();
-        ObjectPropertyAssertion.of(ClassFileVersion.VersionExtractor.class).applyBasic();
         ObjectPropertyAssertion.of(ClassFileVersion.VersionLocator.CreationAction.class).apply();
         ObjectPropertyAssertion.of(ClassFileVersion.VersionLocator.ForLegacyVm.class).apply();
         final Iterator<Method> methods = Arrays.asList(Object.class.getDeclaredMethods()).iterator();

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderCircularityLockTest.java
Patch:
@@ -31,7 +31,6 @@ public void testCircularityLockInactive() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(AgentBuilder.CircularityLock.Default.class).applyBasic();
         ObjectPropertyAssertion.of(AgentBuilder.CircularityLock.Inactive.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRedefinitionStrategyBatchAllocatorTest.java
Patch:
@@ -283,8 +283,6 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(AgentBuilder.RedefinitionStrategy.BatchAllocator.ForFixedSize.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.RedefinitionStrategy.BatchAllocator.ForMatchedGrouping.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.RedefinitionStrategy.BatchAllocator.Slicing.class).apply();
-        ObjectPropertyAssertion.of(AgentBuilder.RedefinitionStrategy.BatchAllocator.Slicing.SlicingIterable.class).applyBasic();
-        ObjectPropertyAssertion.of(AgentBuilder.RedefinitionStrategy.BatchAllocator.Slicing.SlicingIterable.SlicingIterator.class).applyBasic();
         ObjectPropertyAssertion.of(AgentBuilder.RedefinitionStrategy.BatchAllocator.Slicing.Partitioning.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRedefinitionStrategyTest.java
Patch:
@@ -75,8 +75,5 @@ public void testRedefinitionStrategyNotSupportedThrowsException() throws Excepti
     @Test
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(AgentBuilder.RedefinitionStrategy.class).apply();
-        ObjectPropertyAssertion.of(AgentBuilder.RedefinitionStrategy.Collector.PrependableIterator.class).applyBasic();
-        ObjectPropertyAssertion.of(AgentBuilder.RedefinitionStrategy.Collector.ForRedefinition.class).applyBasic();
-        ObjectPropertyAssertion.of(AgentBuilder.RedefinitionStrategy.Collector.ForRetransformation.class).applyBasic();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/TypeConstantAdjustmentTest.java
Patch:
@@ -152,7 +152,5 @@ public void testInstrumentationLegacyClassOtherType() throws Exception {
     @Test
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(TypeConstantAdjustment.class).apply();
-        ObjectPropertyAssertion.of(TypeConstantAdjustment.TypeConstantDissolvingClassVisitor.class).applyBasic();
-        ObjectPropertyAssertion.of(TypeConstantAdjustment.TypeConstantDissolvingClassVisitor.TypeConstantDissolvingMethodVisitor.class).applyBasic();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassFileLocatorAgentBasedTest.java
Patch:
@@ -125,7 +125,6 @@ public Collection<Class<?>> create() {
                 return Collections.<Class<?>>singletonList(otherIterator.next());
             }
         }).apply();
-        ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.ExtractionClassFileTransformer.class).applyBasic();
         ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.ClassLoadingDelegate.ForDelegatingClassLoader.Dispatcher.CreationAction.class).apply();
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategyTest.java
Patch:
@@ -272,7 +272,6 @@ public void apply(Instrumentation mock) {
         }).apply();
         ObjectPropertyAssertion.of(ClassReloadingStrategy.BootstrapInjection.Enabled.class).apply();
         ObjectPropertyAssertion.of(ClassReloadingStrategy.Strategy.class).apply();
-        ObjectPropertyAssertion.of(ClassReloadingStrategy.Strategy.ClassRedefinitionTransformer.class).applyBasic();
         ObjectPropertyAssertion.of(ClassReloadingStrategy.Strategy.ClassResettingTransformer.class).apply();
         ObjectPropertyAssertion.of(ClassReloadingStrategy.BootstrapInjection.Enabled.class).apply();
         ObjectPropertyAssertion.of(ClassReloadingStrategy.BootstrapInjection.Disabled.class).apply();

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/MultipleParentClassLoaderTest.java
Patch:
@@ -179,8 +179,6 @@ public void testMultipleParentClassLoaderExplicitParentNotPreIncludedWithOther()
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(MultipleParentClassLoader.class).applyBasic();
-        ObjectPropertyAssertion.of(MultipleParentClassLoader.CompoundEnumeration.class).applyBasic();
         ObjectPropertyAssertion.of(MultipleParentClassLoader.Builder.class).apply();
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldValueBinderTest.java
Patch:
@@ -337,7 +337,6 @@ public void testSetterNameDiscovery() throws Exception {
     @Test
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(FieldValue.Binder.class).apply();
-        ObjectPropertyAssertion.of(FieldValue.Binder.Delegate.class).applyBasic();
     }
 
     public static class Foo {

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolCacheProviderTest.java
Patch:
@@ -48,6 +48,5 @@ public void testSimple() throws Exception {
     @Test
     public void testSimpleObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(TypePool.CacheProvider.NoOp.class).apply();
-        ObjectPropertyAssertion.of(TypePool.CacheProvider.Simple.class).applyBasic();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterInitializerRemapperTest.java
Patch:
@@ -42,11 +42,11 @@ public void testInitializer() throws Exception {
                 .getLoaded().getName(), true, classLoader);
     }
 
-    public static class NoInitializer {
-
+    private static class NoInitializer {
+        /* empty */
     }
 
-    public static class BranchingInitializer {
+    private static class BranchingInitializer {
 
         static {
             int ignored = 0;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3191,7 +3191,6 @@ public void onFrame(int type, int localVariableLength) {
                                 switch (type) {
                                     case Opcodes.F_SAME:
                                     case Opcodes.F_SAME1:
-                                        currentLocalVariableLength = 0;
                                         break;
                                     case Opcodes.F_APPEND:
                                         currentLocalVariableLength += localVariableLength;

File: byte-buddy-dep/src/main/java/net/bytebuddy/TypeCache.java
Patch:
@@ -71,6 +71,7 @@ public TypeCache(Sort sort) {
      * @param key         The key for the type in question.
      * @return The stored type or {@code null} if no type was stored.
      */
+    @SuppressFBWarnings(value = "GC_UNRELATED_TYPES", justification = "Cross-comparison is intended")
     public Class<?> find(ClassLoader classLoader, T key) {
         ConcurrentMap<T, Reference<Class<?>>> storage = cache.get(new LookupKey(classLoader));
         if (storage == null) {
@@ -93,6 +94,7 @@ public Class<?> find(ClassLoader classLoader, T key) {
      * @param type        The type to insert of no previous type was stored in the cache.
      * @return The supplied type or a previously submitted type for the same class loader and key combination.
      */
+    @SuppressFBWarnings(value = "GC_UNRELATED_TYPES", justification = "Cross-comparison is intended")
     public Class<?> insert(ClassLoader classLoader, T key, Class<?> type) {
         ConcurrentMap<T, Reference<Class<?>>> storage = cache.get(new LookupKey(classLoader));
         if (storage == null) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -1447,6 +1447,7 @@ protected Resubmitting(Instrumentation instrumentation,
             }
 
             @Override
+            @SuppressFBWarnings(value = "GC_UNRELATED_TYPES", justification = "Cross-comparison is intended")
             public void onError(String typeName, ClassLoader classLoader, JavaModule module, boolean loaded, Throwable throwable) {
                 if (!loaded) {
                     Set<String> types = this.types.get(new LookupKey(classLoader));
@@ -1524,6 +1525,7 @@ protected LookupKey(ClassLoader classLoader) {
                 }
 
                 @Override
+                @SuppressFBWarnings(value = "EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS", justification = "Cross-comparison is intended")
                 public boolean equals(Object object) {
                     if (this == object) {
                         return true;
@@ -1573,6 +1575,7 @@ protected boolean isBootstrapLoader() {
                 }
 
                 @Override
+                @SuppressFBWarnings(value = "EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS", justification = "Cross-comparison is intended")
                 public boolean equals(Object object) {
                     if (this == object) {
                         return true;

File: byte-buddy-dep/src/main/java/net/bytebuddy/TypeCache.java
Patch:
@@ -52,7 +52,7 @@ public class TypeCache<T> extends ReferenceQueue<ClassLoader> {
     /**
      * The underlying map containing cached objects.
      */
-    protected final ConcurrentMap<Object, ConcurrentMap<T, Reference<Class<?>>>> cache;
+    protected final ConcurrentMap<StorageKey, ConcurrentMap<T, Reference<Class<?>>>> cache;
 
     /**
      * Creates a new type cache.
@@ -61,7 +61,7 @@ public class TypeCache<T> extends ReferenceQueue<ClassLoader> {
      */
     public TypeCache(Sort sort) {
         this.sort = sort;
-        cache = new ConcurrentHashMap<Object, ConcurrentMap<T, Reference<Class<?>>>>();
+        cache = new ConcurrentHashMap<StorageKey, ConcurrentMap<T, Reference<Class<?>>>>();
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -2713,6 +2713,7 @@ public Class<?> load(String name, ClassLoader classLoader) throws ClassNotFoundE
                     /**
                      * A class loading action that simply loads a type.
                      */
+                    @EqualsAndHashCode
                     protected static class SimpleClassLoadingAction implements Callable<Class<?>> {
 
                         /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDescriptionStrategyTest.java
Patch:
@@ -97,6 +97,5 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(AgentBuilder.DescriptionStrategy.SuperTypeLoading.Asynchronous.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.DescriptionStrategy.SuperTypeLoading.Asynchronous.ThreadSwitchingClassLoadingDelegate.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.DescriptionStrategy.SuperTypeLoading.Asynchronous.ThreadSwitchingClassLoadingDelegate.SimpleClassLoadingAction.class).apply();
-        ObjectPropertyAssertion.of(AgentBuilder.DescriptionStrategy.SuperTypeLoading.Asynchronous.ThreadSwitchingClassLoadingDelegate.NotifyingClassLoadingAction.class).apply();
     }
 }

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/ByteBuddyLogHandler.java
Patch:
@@ -1,6 +1,5 @@
 package net.bytebuddy.build.maven;
 
-import lombok.EqualsAndHashCode;
 import org.apache.maven.plugin.logging.Log;
 
 import java.util.logging.Handler;
@@ -11,7 +10,6 @@
 /**
  * A log handler for only printing Byte Buddy specific log-messages if debug logging is enabled for a plugin.
  */
-@EqualsAndHashCode(callSuper = false)
 public class ByteBuddyLogHandler extends Handler {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -575,7 +575,7 @@ public TypeDescription getType() {
         @Override
         public boolean equals(Object other) {
             if (this == other) return true;
-            if (other == null || getClass() != other.getClass()) return false;
+            if (!(other instanceof SignatureToken)) return false;
             SignatureToken that = (SignatureToken) other;
             return name.equals(that.name) && type.equals(that.type);
         }
@@ -589,7 +589,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return "FieldDescription.SignatureToken{" +
+            return "SignatureToken{" +
                     "name='" + name + '\'' +
                     ", type=" + type +
                     '}';

File: byte-buddy-android/src/main/java/net/bytebuddy/android/AndroidClassLoadingStrategy.java
Patch:
@@ -319,14 +319,14 @@ private ForSdkCompiler getOuter() {
                     return ForSdkCompiler.this;
                 }
 
-                @Override
+                @Override // HE: Remove when Lombok support for getOuter is added.
                 public boolean equals(Object other) {
                     return this == other || !(other == null || getClass() != other.getClass())
                             && ForSdkCompiler.this.equals(((Conversion) other).getOuter())
                             && dexFile.equals(((Conversion) other).dexFile);
                 }
 
-                @Override
+                @Override // HE: Remove when Lombok support for getOuter is added.
                 public int hashCode() {
                     return dexFile.hashCode() + 31 * ForSdkCompiler.this.hashCode();
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/AsmVisitorWrapper.java
Patch:
@@ -124,7 +124,7 @@ public int mergeReader(int flags) {
     /**
      * An ASM visitor wrapper that allows to wrap declared fields of the instrumented type with a {@link FieldVisitorWrapper}.
      */
-    @EqualsAndHashCode(callSuper = false)
+    @EqualsAndHashCode
     class ForDeclaredFields extends AbstractBase {
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeVariableToken.java
Patch:
@@ -99,7 +99,7 @@ public TypeVariableToken accept(TypeDescription.Generic.Visitor<? extends TypeDe
     @Override
     public boolean equals(Object other) {
         if (this == other) return true;
-        if (other == null || getClass() != other.getClass()) return false;
+        if (!(other instanceof TypeVariableToken)) return false;
         TypeVariableToken that = (TypeVariableToken) other;
         return symbol.equals(that.symbol)
                 && bounds.equals(that.bounds)

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/Nexus.java
Patch:
@@ -24,7 +24,7 @@
  * system class loader in its hierarchy.
  * </p>
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class Nexus extends WeakReference<ClassLoader> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoader.java
Patch:
@@ -402,7 +402,7 @@ private ByteArrayClassLoader getOuter() {
             return ByteArrayClassLoader.this;
         }
 
-        @Override
+        @Override //
         public boolean equals(Object object) {
             if (this == object) return true;
             if (object == null || getClass() != object.getClass()) return false;
@@ -658,7 +658,7 @@ public URL run() {
             /**
              * A stream handler that returns the given binary representation.
              */
-            @EqualsAndHashCode(callSuper = false)
+            @EqualsAndHashCode
             protected static class ByteArrayUrlStreamHandler extends URLStreamHandler {
 
                 /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -414,7 +414,7 @@ public Linked compile(TypeDescription typeDescription) {
          *
          * @param <T> The type of the harmonizer token to be used for linking methods of different types.
          */
-        @EqualsAndHashCode(callSuper = false)
+        @EqualsAndHashCode
         class Default<T> extends AbstractBase {
 
             /**
@@ -609,8 +609,7 @@ protected Token(MethodDescription.TypeToken typeToken) {
 
                         @Override
                         public boolean equals(Object other) {
-                            return this == other || other instanceof Token
-                                    && typeToken.getParameterTypes().equals(((Token) other).typeToken.getParameterTypes());
+                            return this == other || (other instanceof Token && typeToken.getParameterTypes().equals(((Token) other).typeToken.getParameterTypes()));
                         }
 
                         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -342,7 +342,7 @@ private ForOriginType getOuter() {
                 return ForOriginType.this;
             }
 
-            @Override
+            @Override // HE: Remove when Lombok support for getOuter is added.
             public boolean equals(Object o) {
                 if (this == o) return true;
                 if (o == null || getClass() != o.getClass()) return false;
@@ -351,7 +351,7 @@ public boolean equals(Object o) {
                         && getOuter().equals(appender.getOuter());
             }
 
-            @Override
+            @Override // HE: Remove when Lombok support for getOuter is added.
             public int hashCode() {
                 return 31 * getOuter().hashCode() + originType.hashCode();
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -1197,7 +1197,7 @@ public String getInternalName() {
             /**
              * An abstract method pool entry that delegates the implementation of a method to itself.
              */
-            @EqualsAndHashCode(callSuper = false)
+            @EqualsAndHashCode
             protected abstract static class DelegationRecord extends TypeWriter.MethodPool.Record.ForDefinedMethod implements ByteCodeAppender {
 
                 /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -2412,7 +2412,7 @@ private MethodCall getOuter() {
             return MethodCall.this;
         }
 
-        @Override
+        @Override // HE: Remove when Lombok support for getOuter is added.
         public boolean equals(Object other) {
             if (this == other) return true;
             if (other == null || getClass() != other.getClass()) return false;
@@ -2422,7 +2422,7 @@ public boolean equals(Object other) {
 
         }
 
-        @Override
+        @Override // HE: Remove when Lombok support for getOuter is added.
         public int hashCode() {
             return implementationTarget.hashCode() + 31 * MethodCall.this.hashCode();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -370,14 +370,14 @@ private MethodCall getMethodCall() {
                 return MethodCall.this;
             }
 
-            @Override
+            @Override // HE: Remove when Lombok support for getOuter is added.
             public boolean equals(Object other) {
                 return this == other || !(other == null || getClass() != other.getClass())
                         && instrumentedType.equals(((Appender) other).instrumentedType)
                         && MethodCall.this.equals(((Appender) other).getMethodCall());
             }
 
-            @Override
+            @Override // HE: Remove when Lombok support for getOuter is added.
             public int hashCode() {
                 return 31 * MethodCall.this.hashCode() + instrumentedType.hashCode();
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -573,14 +573,14 @@ private MethodCall getMethodCall() {
                         return MethodCall.this;
                     }
 
-                    @Override
+                    @Override // HE: Remove when Lombok support for getOuter is added.
                     public boolean equals(Object other) {
                         return this == other || !(other == null || getClass() != other.getClass())
                                 && MethodCall.this.equals(((Appender) other).getMethodCall())
                                 && typeDescription.equals(((Appender) other).typeDescription);
                     }
 
-                    @Override
+                    @Override // HE: Remove when Lombok support for getOuter is added.
                     public int hashCode() {
                         return typeDescription.hashCode() + 31 * MethodCall.this.hashCode();
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -486,14 +486,14 @@ private MethodCall getMethodCall() {
                         return MethodCall.this;
                     }
 
-                    @Override
+                    @Override // HE: Remove when Lombok support for getOuter is added.
                     public boolean equals(Object other) {
                         return this == other || !(other == null || getClass() != other.getClass())
                                 && instrumentedType.equals(((Appender) other).instrumentedType)
                                 && MethodCall.this.equals(((Appender) other).getMethodCall());
                     }
 
-                    @Override
+                    @Override // HE: Remove when Lombok support for getOuter is added.
                     public int hashCode() {
                         return 31 * MethodCall.this.hashCode() + instrumentedType.hashCode();
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -287,7 +287,7 @@ public ParameterBinding<?> bind(AnnotationDescription.Loadable<S> annotation,
              *
              * @param <U> The bound annotation's type.
              */
-            @EqualsAndHashCode(callSuper = false)
+            @EqualsAndHashCode
             public static class OfConstant<U extends Annotation> extends ForFixedValue<U> {
 
                 /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/collection/ArrayFactory.java
Patch:
@@ -299,14 +299,14 @@ private ArrayFactory getArrayFactory() {
             return ArrayFactory.this;
         }
 
-        @Override
+        @Override // HE: Remove when Lombok support for getOuter is added.
         public boolean equals(Object other) {
             return this == other || !(other == null || getClass() != other.getClass())
                     && ArrayFactory.this.equals(((ArrayStackManipulation) other).getArrayFactory())
                     && stackManipulations.equals(((ArrayStackManipulation) other).stackManipulations);
         }
 
-        @Override
+        @Override // HE: Remove when Lombok support for getOuter is added.
         public int hashCode() {
             return stackManipulations.hashCode();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodInvocation.java
Patch:
@@ -354,7 +354,7 @@ private MethodInvocation getOuterInstance() {
             return MethodInvocation.this;
         }
 
-        @Override
+        @Override // HE: Remove when Lombok support for getOuter is added.
         public boolean equals(Object other) {
             if (this == other) return true;
             if (other == null || getClass() != other.getClass()) return false;
@@ -364,7 +364,7 @@ public boolean equals(Object other) {
                     && typeDescription.equals(that.typeDescription);
         }
 
-        @Override
+        @Override // HE: Remove when Lombok support for getOuter is added.
         public int hashCode() {
             int result = typeDescription.hashCode();
             result = 31 * result + MethodInvocation.this.hashCode();

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccess.java
Patch:
@@ -348,14 +348,14 @@ private MethodVariableAccess getMethodVariableAccess() {
             return MethodVariableAccess.this;
         }
 
-        @Override
+        @Override // HE: Remove when Lombok support for getOuter is added.
         public boolean equals(Object other) {
             return this == other || !(other == null || getClass() != other.getClass())
                     && MethodVariableAccess.this == ((OffsetLoading) other).getMethodVariableAccess()
                     && offset == ((OffsetLoading) other).offset;
         }
 
-        @Override
+        @Override // HE: Remove when Lombok support for getOuter is added.
         public int hashCode() {
             return MethodVariableAccess.this.hashCode() + 31 * offset;
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AccessibilityMatcher.java
Patch:
@@ -9,7 +9,7 @@
  *
  * @param <T>The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class AccessibilityMatcher<T extends ByteCodeElement> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AnnotationTypeMatcher.java
Patch:
@@ -9,7 +9,7 @@
  *
  * @param <T> The exact type of the annotation description that is matched.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class AnnotationTypeMatcher<T extends AnnotationDescription> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/BooleanMatcher.java
Patch:
@@ -7,7 +7,7 @@
  *
  * @param <T> The actual matched type of this matcher.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class BooleanMatcher<T> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderHierarchyMatcher.java
Patch:
@@ -8,7 +8,7 @@
  *
  * @param <T> The exact type of the class loader that is matched.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class ClassLoaderHierarchyMatcher<T extends ClassLoader> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderParentMatcher.java
Patch:
@@ -7,7 +7,7 @@
  *
  * @param <T> The exact type of the class loader that is matched.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class ClassLoaderParentMatcher<T extends ClassLoader> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionElementMatcher.java
Patch:
@@ -10,7 +10,7 @@
  *
  * @param <T> The type of the elements contained by the collection.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class CollectionElementMatcher<T> extends ElementMatcher.Junction.AbstractBase<Iterable<? extends T>> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionItemMatcher.java
Patch:
@@ -8,7 +8,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class CollectionItemMatcher<T> extends ElementMatcher.Junction.AbstractBase<Iterable<? extends T>> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionOneToOneMatcher.java
Patch:
@@ -14,7 +14,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class CollectionOneToOneMatcher<T> extends ElementMatcher.Junction.AbstractBase<Iterable<? extends T>> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionRawTypeMatcher.java
Patch:
@@ -12,7 +12,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class CollectionRawTypeMatcher<T extends Iterable<? extends TypeDefinition>> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionSizeMatcher.java
Patch:
@@ -10,7 +10,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class CollectionSizeMatcher<T extends Iterable<?>> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringAnnotationMatcher.java
Patch:
@@ -9,7 +9,7 @@
  *
  * @param <T> The actual matched type of this matcher.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class DeclaringAnnotationMatcher<T extends AnnotatedCodeElement> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringFieldMatcher.java
Patch:
@@ -10,7 +10,7 @@
  *
  * @param <T> The exact type of the annotated element that is matched.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class DeclaringFieldMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringMethodMatcher.java
Patch:
@@ -10,7 +10,7 @@
  *
  * @param <T> The exact type of the annotated element that is matched.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class DeclaringMethodMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringTypeMatcher.java
Patch:
@@ -11,7 +11,7 @@
  *
  * @param <T> The exact type of the element being matched.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class DeclaringTypeMatcher<T extends DeclaredByType> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DefinedShapeMatcher.java
Patch:
@@ -9,7 +9,7 @@
  * @param <T> The type of the matched entity.
  * @param <S> The type of the defined shape of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class DefinedShapeMatcher<T extends ByteCodeElement.TypeDependant<S, ?>, S extends ByteCodeElement.TypeDependant<?, ?>>
         extends ElementMatcher.Junction.AbstractBase<T> {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DescriptorMatcher.java
Patch:
@@ -8,7 +8,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class DescriptorMatcher<T extends ByteCodeElement> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatcher.java
Patch:
@@ -76,7 +76,7 @@ public <U extends V> Junction<U> or(ElementMatcher<? super U> other) {
          *
          * @param <W> The type of the object that is being matched.
          */
-        @EqualsAndHashCode(callSuper = false)
+        @EqualsAndHashCode
         class Conjunction<W> extends AbstractBase<W> {
 
             /**
@@ -112,7 +112,7 @@ public String toString() {
          *
          * @param <W> The type of the object that is being matched.
          */
-        @EqualsAndHashCode(callSuper = false)
+        @EqualsAndHashCode
         class Disjunction<W> extends AbstractBase<W> {
 
             /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/EqualityMatcher.java
Patch:
@@ -7,7 +7,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class EqualityMatcher<T> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/FailSafeMatcher.java
Patch:
@@ -7,7 +7,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class FailSafeMatcher<T> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/FieldTypeMatcher.java
Patch:
@@ -9,7 +9,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class FieldTypeMatcher<T extends FieldDescription> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/HasSuperTypeMatcher.java
Patch:
@@ -12,7 +12,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class HasSuperTypeMatcher<T extends TypeDescription> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/InheritedAnnotationMatcher.java
Patch:
@@ -9,7 +9,7 @@
  *
  * @param <T> The actual matched type of this matcher.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class InheritedAnnotationMatcher<T extends TypeDescription> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/InstanceTypeMatcher.java
Patch:
@@ -8,7 +8,7 @@
  *
  * @param <T> The exact type of the object that is matched.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class InstanceTypeMatcher<T> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/IsNamedMatcher.java
Patch:
@@ -8,7 +8,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class IsNamedMatcher<T extends NamedElement.WithOptionalName> extends ElementMatcher.Junction.AbstractBase<T> {
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodExceptionTypeMatcher.java
Patch:
@@ -9,7 +9,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class MethodExceptionTypeMatcher<T extends MethodDescription> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodOverrideMatcher.java
Patch:
@@ -16,7 +16,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class MethodOverrideMatcher<T extends MethodDescription> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypeMatcher.java
Patch:
@@ -9,7 +9,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class MethodParameterTypeMatcher<T extends ParameterDescription> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypesMatcher.java
Patch:
@@ -11,7 +11,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class MethodParameterTypesMatcher<T extends ParameterList<?>> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParametersMatcher.java
Patch:
@@ -10,7 +10,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class MethodParametersMatcher<T extends MethodDescription> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodReturnTypeMatcher.java
Patch:
@@ -9,7 +9,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class MethodReturnTypeMatcher<T extends MethodDescription> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodSortMatcher.java
Patch:
@@ -9,7 +9,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class MethodSortMatcher<T extends MethodDescription> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ModifierMatcher.java
Patch:
@@ -9,7 +9,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class ModifierMatcher<T extends ModifierReviewable> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NameMatcher.java
Patch:
@@ -15,7 +15,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class NameMatcher<T extends NamedElement> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NullMatcher.java
Patch:
@@ -7,7 +7,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class NullMatcher<T> extends ElementMatcher.Junction.AbstractBase<T> {
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/RawTypeMatcher.java
Patch:
@@ -10,7 +10,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class RawTypeMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/StringMatcher.java
Patch:
@@ -7,7 +7,7 @@
  * An element matcher that compares two strings by a given pattern which is characterized by a
  * {@link net.bytebuddy.matcher.StringMatcher.Mode}.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class StringMatcher extends ElementMatcher.Junction.AbstractBase<String> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SubTypeMatcher.java
Patch:
@@ -8,7 +8,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class SubTypeMatcher<T extends TypeDescription> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SuperTypeMatcher.java
Patch:
@@ -8,7 +8,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class SuperTypeMatcher<T extends TypeDescription> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/TypeSortMatcher.java
Patch:
@@ -8,7 +8,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class TypeSortMatcher<T extends TypeDefinition> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/VisibilityMatcher.java
Patch:
@@ -9,7 +9,7 @@
  *
  * @param <T>The type of the matched entity.
  */
-@EqualsAndHashCode(callSuper = false)
+@EqualsAndHashCode
 public class VisibilityMatcher<T extends ByteCodeElement> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -268,7 +268,7 @@ public TypeDescription getType() {
         @Override
         public boolean equals(Object other) {
             if (this == other) return true;
-            if (other == null || getClass() != other.getClass()) return false;
+            if (!(other instanceof MethodType)) return false;
             MethodType that = (MethodType) other;
             return parameterTypes.equals(that.parameterTypes) && returnType.equals(that.returnType);
 
@@ -684,7 +684,7 @@ public String getDescriptor() {
         @Override
         public boolean equals(Object other) {
             if (this == other) return true;
-            if (other == null || getClass() != other.getClass()) return false;
+            if (!(other instanceof MethodHandle)) return false;
             MethodHandle aDefault = (MethodHandle) other;
             return handleType == aDefault.handleType
                     && name.equals(aDefault.name)

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -490,6 +490,7 @@ protected ForModule(JavaModule module) {
          *
          * @return A class file locator that locates classes of the boot layer.
          */
+        @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception is supposed to be rethrown")
         public static ClassFileLocator ofBootLayer() {
             try {
                 Map<String, ClassFileLocator> bootModules = new HashMap<String, ClassFileLocator>();

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -992,7 +992,7 @@ public UsingUnsafe(ClassLoader classLoader, ProtectionDomain protectionDomain) {
          *
          * @return A class injector for the bootstrap loader.
          */
-        public ClassInjector ofBootstrapLoader() {
+        public static ClassInjector ofBootstrapLoader() {
             return new UsingUnsafe(ClassLoadingStrategy.BOOTSTRAP_LOADER);
         }
 
@@ -1001,7 +1001,7 @@ public ClassInjector ofBootstrapLoader() {
          *
          * @return A class injector for the system class loader.
          */
-        public ClassInjector ofClassPath() {
+        public static ClassInjector ofClassPath() {
             return new UsingUnsafe(ClassLoader.getSystemClassLoader());
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationOtherTest.java
Patch:
@@ -60,8 +60,8 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(MethodDelegation.class).apply();
         ObjectPropertyAssertion.of(MethodDelegation.WithCustomProperties.class).apply();
         ObjectPropertyAssertion.of(MethodDelegation.Appender.class).apply();
-        ObjectPropertyAssertion.of(MethodDelegation.ImplementationDelegate.ForField.class).apply();
-        ObjectPropertyAssertion.of(MethodDelegation.ImplementationDelegate.ForInstance.class).apply();
+        ObjectPropertyAssertion.of(MethodDelegation.ImplementationDelegate.ForField.WithInstance.class).apply();
+        ObjectPropertyAssertion.of(MethodDelegation.ImplementationDelegate.ForField.WithLookup.class).apply();
         ObjectPropertyAssertion.of(MethodDelegation.ImplementationDelegate.ForConstruction.class).apply();
         ObjectPropertyAssertion.of(MethodDelegation.ImplementationDelegate.ForStaticMethod.class).apply();
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -9,7 +9,6 @@
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
 import net.bytebuddy.implementation.bind.MethodDelegationBinder;
-import net.bytebuddy.implementation.bind.annotation.Argument;
 import net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder;
 import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
 import net.bytebuddy.implementation.bytecode.Duplication;
@@ -146,7 +145,7 @@
  * it is never considered as a target for a method delegation.
  * </p>
  * <p>
- * <b>Important</b>: For invoking a method on another instance, use the {@link Forwarding} implementation. A method delegation
+ * <b>Important</b>: For invoking a method on another instance, use the {@link MethodCall} implementation. A method delegation
  * intends to bind a interceptor class and its resolution algorithm will not necessarily yield a delegation to the intercepted
  * method.
  * </p>
@@ -552,7 +551,7 @@ public MethodDelegation defineAmbiguityResolver(MethodDelegationBinder.Ambiguity
      * @param assigner The assigner to apply.
      * @return A method delegation implementation that makes use of the given designer.
      */
-    public MethodDelegation withAssigner(Assigner assigner) {
+    public Implementation.Composable withAssigner(Assigner assigner) {
         return new MethodDelegation(implementationDelegate,
                 parameterBinders,
                 terminationHandler,

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -702,7 +702,7 @@ public static List<String> log(@SuperCall Callable<List<String>> zuper) throws E
     @SuppressWarnings("unused")
     public static class ChangingLoggerInterceptor {
 
-        public static List<String> log(@Super MemoryDatabase zuper, String info) {
+        public static List<String> log(String info, @Super MemoryDatabase zuper) { // TODO: Update info on implicit arguments
             println("Calling database");
             try {
                 return zuper.load(info + " (logged access)");

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationSuperTest.java
Patch:
@@ -196,7 +196,7 @@ public String qux(String value) {
 
     public static class GenericBaz {
 
-        public static String baz(@Super GenericBase<String> foo, String value) {
+        public static String baz(String value, @Super GenericBase<String> foo) {
             assertThat(foo, not(instanceOf(Serializable.class)));
             return foo.qux(value) + QUX;
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/DefaultMethodCall.java
Patch:
@@ -226,13 +226,13 @@ private StackManipulation locateDefault(MethodDescription methodDescription) {
             MethodDescription.SignatureToken methodToken = methodDescription.asSignatureToken();
             SpecialMethodInvocation specialMethodInvocation = SpecialMethodInvocation.Illegal.INSTANCE;
             for (TypeDescription typeDescription : prioritizedInterfaces) {
-                specialMethodInvocation = implementationTarget.invokeDefault(typeDescription, methodToken);
+                specialMethodInvocation = implementationTarget.invokeDefault(methodToken, typeDescription);
                 if (specialMethodInvocation.isValid()) {
                     return specialMethodInvocation;
                 }
             }
             for (TypeDescription typeDescription : nonPrioritizedInterfaces) {
-                SpecialMethodInvocation other = implementationTarget.invokeDefault(typeDescription, methodToken);
+                SpecialMethodInvocation other = implementationTarget.invokeDefault(methodToken, typeDescription);
                 if (specialMethodInvocation.isValid() && other.isValid()) {
                     throw new IllegalStateException(methodDescription + " has an ambiguous default method with "
                             + other.getMethodDescription() + " and " + specialMethodInvocation.getMethodDescription());

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -2785,7 +2785,7 @@ public StackManipulation invoke(MethodDescription invokedMethod, Target implemen
                 if (!invokedMethod.isInvokableOn(implementationTarget.getInstrumentedType())) {
                     throw new IllegalStateException("Cannot invoke " + invokedMethod + " as default method of " + implementationTarget.getInstrumentedType());
                 }
-                StackManipulation stackManipulation = implementationTarget.invokeDefault(invokedMethod.getDeclaringType().asErasure(), invokedMethod.asSignatureToken());
+                StackManipulation stackManipulation = implementationTarget.invokeDefault(invokedMethod.asSignatureToken(), invokedMethod.getDeclaringType().asErasure());
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot invoke " + invokedMethod + " on " + implementationTarget.getInstrumentedType());
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TypeProxy.java
Patch:
@@ -395,7 +395,7 @@ public Implementation.SpecialMethodInvocation invoke(Implementation.Target imple
                 public Implementation.SpecialMethodInvocation invoke(Implementation.Target implementationTarget,
                                                                      TypeDescription proxiedType,
                                                                      MethodDescription instrumentedMethod) {
-                    return implementationTarget.invokeDefault(proxiedType, instrumentedMethod.asSignatureToken());
+                    return implementationTarget.invokeDefault(instrumentedMethod.asSignatureToken(), proxiedType);
                 }
             };
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/AbstractImplementationTargetTest.java
Patch:
@@ -86,7 +86,7 @@ public void setUp() throws Exception {
 
     @Test
     public void testDefaultMethodInvocation() throws Exception {
-        Implementation.SpecialMethodInvocation specialMethodInvocation = makeImplementationTarget().invokeDefault(defaultMethodDeclaringType, defaultToken);
+        Implementation.SpecialMethodInvocation specialMethodInvocation = makeImplementationTarget().invokeDefault(defaultToken, defaultMethodDeclaringType);
         assertThat(specialMethodInvocation.isValid(), is(true));
         assertThat(specialMethodInvocation.getMethodDescription(), is((MethodDescription) defaultMethod));
         assertThat(specialMethodInvocation.getTypeDescription(), is(defaultMethodDeclaringType));
@@ -103,13 +103,13 @@ public void testDefaultMethodInvocation() throws Exception {
     @Test
     public void testDefaultMethodInvocationNotSupported() throws Exception {
         defaultMethodInvocation = Implementation.Target.AbstractBase.DefaultMethodInvocation.DISABLED;
-        Implementation.SpecialMethodInvocation specialMethodInvocation = makeImplementationTarget().invokeDefault(defaultMethodDeclaringType, defaultToken);
+        Implementation.SpecialMethodInvocation specialMethodInvocation = makeImplementationTarget().invokeDefault(defaultToken, defaultMethodDeclaringType);
         assertThat(specialMethodInvocation.isValid(), is(false));
     }
 
     @Test
     public void testIllegalDefaultMethod() throws Exception {
-        assertThat(makeImplementationTarget().invokeDefault(defaultMethodDeclaringType, mock(MethodDescription.SignatureToken.class)).isValid(), is(false));
+        assertThat(makeImplementationTarget().invokeDefault(mock(MethodDescription.SignatureToken.class), defaultMethodDeclaringType).isValid(), is(false));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TypeProxyInvocationFactoryDefaultTest.java
Patch:
@@ -50,10 +50,10 @@ public void testSuperMethod() throws Exception {
 
     @Test
     public void testDefaultMethod() throws Exception {
-        when(implementationTarget.invokeDefault(typeDescription, token)).thenReturn(specialMethodInvocation);
+        when(implementationTarget.invokeDefault(token, typeDescription)).thenReturn(specialMethodInvocation);
         assertThat(TypeProxy.InvocationFactory.Default.DEFAULT_METHOD.invoke(implementationTarget, typeDescription, methodDescription),
                 is(specialMethodInvocation));
-        verify(implementationTarget).invokeDefault(typeDescription, token);
+        verify(implementationTarget).invokeDefault(token, typeDescription);
         verifyNoMoreInteractions(implementationTarget);
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoader.java
Patch:
@@ -277,6 +277,7 @@ enum CreationAction implements PrivilegedAction<Initializable> {
             INSTANCE;
 
             @Override
+            @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but trigger a fallback")
             public Initializable run() {
                 try {
                     return new ForJava7CapableVm(ClassLoader.class.getDeclaredMethod("getClassLoadingLock", String.class));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoader.java
Patch:
@@ -348,6 +348,7 @@ public Object getClassLoadingLock(ClassLoader classLoader, String name) {
             }
 
             @Override
+            @SuppressFBWarnings(value = "DP_DO_INSIDE_DO_PRIVILEGED", justification = "Privilege is explicitly user responsibility")
             public SynchronizationStrategy initialize() {
                 try {
                     method.setAccessible(true);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -685,6 +685,7 @@ public Object getClassLoadingLock(ClassLoader classLoader, String name) {
                     }
 
                     @Override
+                    @SuppressFBWarnings(value = "DP_DO_INSIDE_DO_PRIVILEGED", justification = "Privilege is explicit user responsibility")
                     protected void onInitialization() {
                         getClassLoadingLock.setAccessible(true);
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -379,7 +379,6 @@ protected static Dispatcher.Initializable make() {
                             getPackage = ClassLoader.class.getDeclaredMethod("getPackage", String.class);
                         }
                         try {
-
                             return new Dispatcher.Resolved.ForJava7CapableVm(ClassLoader.class.getDeclaredMethod("findLoadedClass", String.class),
                                     ClassLoader.class.getDeclaredMethod("defineClass",
                                             String.class,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -450,7 +450,7 @@ public Package definePackage(ClassLoader classLoader,
                 }
 
                 @Override
-                @SuppressFBWarnings(value = "DP_DO_INSIDE_DO_PRIVILEGED", justification = "Privilege is explicit user responsibility")
+                @SuppressFBWarnings(value = {"DP_DO_INSIDE_DO_PRIVILEGED", "REC_CATCH_EXCEPTION"}, justification = "Privilege is explicit user responsibility")
                 public Dispatcher initialize() {
                     try {
                         // This is safe even in a multi-threaded environment as all threads set the instances accessible before invoking any methods.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodInvocation.java
Patch:
@@ -536,7 +536,7 @@ public String toString() {
     /**
      * Performs a method invocation on a method handle with a polymorphic type signature.
      */
-    protected class HandleInvocation implements StackManipulation {
+    protected static class HandleInvocation implements StackManipulation {
 
         /**
          * The internal name of the method handle type.
@@ -646,7 +646,7 @@ protected String getMethodName() {
 
         @Override
         public String toString() {
-            return "MethodInvocation.nHandleType." + name();
+            return "MethodInvocation.HandleType." + name();
         }
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationDynamicTest.java
Patch:
@@ -71,7 +71,7 @@ public void testDynamicStaticBootstrap() throws Exception {
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);
         assertThat(size.getSizeImpact(), is(0));
-        assertThat(size.getSizeImpact(), is(0));
+        assertThat(size.getMaximalSize(), is(0));
         verify(methodVisitor).visitInvokeDynamicInsn(FOO, "(" + FOO + BAR + ")" + QUX, new Handle(Opcodes.H_INVOKESTATIC, BAR, QUX, BAZ, false), argument);
     }
 
@@ -84,7 +84,7 @@ public void testDynamicConstructorBootstrap() throws Exception {
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);
         assertThat(size.getSizeImpact(), is(0));
-        assertThat(size.getSizeImpact(), is(0));
+        assertThat(size.getMaximalSize(), is(0));
         verify(methodVisitor).visitInvokeDynamicInsn(FOO, "(" + FOO + BAR + ")" + QUX, new Handle(Opcodes.H_NEWINVOKESPECIAL, BAR, QUX, BAZ, false), argument);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3582,7 +3582,7 @@ public void onFrame(int type, int localVariableLength) {
                                         currentLocalVariableLength = localVariableLength;
                                         break;
                                     default:
-                                        throw new IllegalStateException();
+                                        throw new IllegalStateException("Unexpected frame type: " + type);
                                 }
                             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3917,7 +3917,7 @@ public MethodVisitor visitMethod(int modifiers,
                                 instrumentedType,
                                 methodPool,
                                 annotationValueFilterFactory,
-                                (writerFlags & ClassWriter.COMPUTE_FRAMES) != 0 && implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V6),
+                                (writerFlags & ClassWriter.COMPUTE_FRAMES) == 0 && implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V6),
                                 (readerFlags & ClassReader.EXPAND_FRAMES) != 0));
                     } else {
                         MethodDescription methodDescription = declarableMethods.remove(internalName + descriptor);

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTypeTest.java
Patch:
@@ -6,6 +6,7 @@
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bytecode.assign.Assigner;
 import net.bytebuddy.pool.TypePool;
+import net.bytebuddy.test.utility.DebuggingWrapper;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -1322,7 +1322,7 @@ public Size applyCode(MethodVisitor methodVisitor, Context implementationContext
 
                 @Override
                 public TypeWriter.MethodPool.Record prepend(ByteCodeAppender byteCodeAppender) {
-                    throw new UnsupportedOperationException("Cannot prepend code to a delegation");
+                    throw new UnsupportedOperationException("Cannot prepend code to a delegation for " + methodDescription);
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -503,6 +503,7 @@ interface ExtractableView extends Context {
              * to the provided class visitor. This contains any fields for value caching, any accessor method and it
              * writes the type initializer. The type initializer must therefore never be written manually.
              *
+             * @param drain                        The drain to write the type initializer to.
              * @param classVisitor                 The class visitor to which the extractable view is to be written.
              * @param annotationValueFilterFactory The annotation value filter factory to apply when writing annotation.
              */

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDisabledTest.java
Patch:
@@ -79,8 +79,6 @@ public void testCannotRegisterAuxiliaryType() throws Exception {
         new Implementation.Context.Disabled(instrumentedType, classFileVersion).register(mock(AuxiliaryType.class));
     }
 
-    // TODO: Test coverage!
-
     @Test
     public void testClassFileVersion() throws Exception {
         assertThat(new Implementation.Context.Disabled(instrumentedType, classFileVersion).getClassFileVersion(), is(classFileVersion));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodRegistry.java
Patch:
@@ -1056,7 +1056,7 @@ public MethodList<?> getInstrumentedMethods() {
             public Record target(MethodDescription methodDescription) {
                 Entry entry = implementations.get(methodDescription);
                 return entry == null
-                        ? Record.ForNonDefinedMethod.INSTANCE
+                        ? Record.ForUndefinedMethod.INSTANCE
                         : entry.bind(instrumentedType, supportsBridges);
             }
 
@@ -1161,7 +1161,7 @@ protected Entry(Handler.Compiled handler,
                  */
                 protected Record bind(TypeDescription instrumentedType, boolean supportsBridges) {
                     if (bridgeMethod && !supportsBridges) {
-                        return Record.ForNonDefinedMethod.INSTANCE;
+                        return Record.ForUndefinedMethod.INSTANCE;
                     }
                     Record record = handler.assemble(methodDescription, attributeAppender, visibility);
                     return supportsBridges

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodRegistryDefaultTest.java
Patch:
@@ -316,7 +316,7 @@ public void testSkipEntryIfNotMatchedAndVisible() throws Exception {
         verify(secondHandler).prepare(secondType);
         verifyZeroInteractions(firstFactory);
         verifyZeroInteractions(secondFactory);
-        assertThat(methodRegistry.target(instrumentedMethod), instanceOf(TypeWriter.MethodPool.Record.ForNonDefinedMethod.class));
+        assertThat(methodRegistry.target(instrumentedMethod), instanceOf(TypeWriter.MethodPool.Record.ForUndefinedMethod.class));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultTest.java
Patch:
@@ -580,7 +580,6 @@ public TypeWriter.Default.ForInlining<?> create() {
         ObjectPropertyAssertion.of(TypeWriter.Default.ForInlining.RedefinitionClassVisitor.AttributeObtainingFieldVisitor.class).applyBasic();
         ObjectPropertyAssertion.of(TypeWriter.Default.ForInlining.RedefinitionClassVisitor.AttributeObtainingMethodVisitor.class).applyBasic();
         ObjectPropertyAssertion.of(TypeWriter.Default.ForInlining.RedefinitionClassVisitor.CodePreservingMethodVisitor.class).applyBasic();
-        ObjectPropertyAssertion.of(TypeWriter.Default.ForInlining.RedefinitionClassVisitor.TypeInitializerInjection.class).applyBasic();
         ObjectPropertyAssertion.of(TypeWriter.Default.ValidatingClassVisitor.class).applyBasic();
         ObjectPropertyAssertion.of(TypeWriter.Default.ValidatingClassVisitor.ValidatingFieldVisitor.class).applyBasic();
         ObjectPropertyAssertion.of(TypeWriter.Default.ValidatingClassVisitor.ValidatingMethodVisitor.class).applyBasic();

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDefaultOtherTest.java
Patch:
@@ -47,7 +47,7 @@ public void testFrozenTypeInitializerRetainsInitializer() throws Exception {
         implementationContext.prohibitTypeInitializer();
         assertThat(implementationContext.isRetainTypeInitializer(), is(true));
     }
-
+/*
     @Test(expected = IllegalStateException.class)
     public void testFrozenTypeInitializerFrozenThrowsExceptionOnDrain() throws Exception {
         TypeDescription instrumentedType = mock(TypeDescription.class);
@@ -66,7 +66,7 @@ public void testFrozenTypeInitializerFrozenThrowsExceptionOnDrain() throws Excep
                 mock(Implementation.Context.ExtractableView.InjectedCode.class),
                 mock(AnnotationValueFilter.Factory.class));
     }
-
+*/
     @Test
     public void testInstrumentationGetter() throws Exception {
         TypeDescription instrumentedType = mock(TypeDescription.class);

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -8575,7 +8575,7 @@ protected static class ClassLoadingTypeList extends TypeList.Generic.AbstractBas
             private final ClassLoader classLoader;
 
             /**
-             * Creates a class loading
+             * Creates a class loading type list.
              *
              * @param delegate    The delegate type list.
              * @param classLoader The class loader to use for loading types which might be {@code null} to represent the bootstrap class loader.

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -3066,7 +3066,7 @@ public Compound(List<? extends LocationStrategy> locationStrategies) {
                 this.locationStrategies = new ArrayList<LocationStrategy>();
                 for (LocationStrategy locationStrategy : locationStrategies) {
                     if (locationStrategy instanceof Compound) {
-                        this.locationStrategies.addAll(((Compound) locationStrategies).locationStrategies);
+                        this.locationStrategies.addAll(((Compound) locationStrategy).locationStrategies);
                     } else {
                         this.locationStrategies.add(locationStrategy);
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -4082,8 +4082,8 @@ public <V> MethodDefinition.ReceiverTypeDefinition<U> defaultValue(V value, Clas
                      */
                     private MethodDefinition.ImplementationDefinition<U> interfaceType() {
                         ElementMatcher.Junction<MethodDescription> elementMatcher = none();
-                        for (TypeDescription.Generic typeDescription : interfaces) {
-                            elementMatcher = elementMatcher.or(isDeclaredBy(isSubTypeOf(typeDescription.asErasure())));
+                        for (TypeDescription typeDescription : interfaces.asErasures()) {
+                            elementMatcher = elementMatcher.or(isDeclaredBy(isSuperTypeOf(typeDescription)));
                         }
                         return materialize().invokable(isDeclaredBy(isInterface()).and(elementMatcher));
                     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/SuperMethodCallOtherTest.java
Patch:
@@ -178,7 +178,7 @@ public void testInheritedDefaultMethod() throws Exception {
     @Test(expected = IllegalStateException.class)
     @JavaVersionRule.Enforce(8)
     public void testAmbiguousDirectDefaultMethodThrowsException() throws Exception {
-        DynamicType.Loaded<?> loaded = new ByteBuddy()
+        new ByteBuddy()
                 .subclass(Object.class)
                 .implement(Class.forName(SINGLE_DEFAULT_METHOD), Class.forName(CONFLICTING_INTERFACE))
                 .intercept(SuperMethodCall.INSTANCE)

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -592,7 +592,6 @@ enum ForToolsJarVm implements AttachmentProvider {
             @SuppressFBWarnings(value = "DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED", justification = "Privilege is explicit user responsibility")
             public Accessor attempt() {
                 File toolsJar = new File(System.getProperty(JAVA_HOME_PROPERTY), toolsJarPath);
-                System.out.println("Tools jar: " + toolsJar + " is present: " + toolsJar.isFile());
                 try {
                     return toolsJar.isFile() && toolsJar.canRead()
                             ? Accessor.Simple.of(new URLClassLoader(new URL[]{toolsJar.toURI().toURL()}, BOOTSTRAP_CLASS_LOADER))

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -978,7 +978,7 @@ public StackManipulation resolve(MethodDescription invokedMethod, MethodDescript
                 FieldLocator.Resolution resolution = fieldLocatorFactory.make(instrumentedType).locate(name);
                 if (!resolution.isResolved()) {
                     throw new IllegalStateException("Could not locate field name " + name + " on " + instrumentedType);
-                } else if (!resolution.getField().isStatic() && !instrumentedType.isAssignableTo(resolution.getField().getType().asErasure())) {
+                } else if (!resolution.getField().isStatic() && !instrumentedType.isAssignableTo(resolution.getField().getDeclaringType().asErasure())) {
                     throw new IllegalStateException("Cannot access " + resolution.getField() + " from " + instrumentedType);
                 }
                 return new StackManipulation.Compound(invokedMethod.isStatic()

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -591,7 +591,8 @@ enum ForToolsJarVm implements AttachmentProvider {
             @Override
             @SuppressFBWarnings(value = "DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED", justification = "Privilege is explicit user responsibility")
             public Accessor attempt() {
-                File toolsJar = new File(System.getProperty(JAVA_HOME_PROPERTY).replace('\\', '/') + "/../" + toolsJarPath);
+                File toolsJar = new File(System.getProperty(JAVA_HOME_PROPERTY), toolsJarPath);
+                System.out.println("Tools jar: " + toolsJar + " is present: " + toolsJar.isFile());
                 try {
                     return toolsJar.isFile() && toolsJar.canRead()
                             ? Accessor.Simple.of(new URLClassLoader(new URL[]{toolsJar.toURI().toURL()}, BOOTSTRAP_CLASS_LOADER))

File: byte-buddy-gradle-plugin/src/test/java/net/bytebuddy/build/gradle/TransformationActionTest.java
Patch:
@@ -39,7 +39,7 @@
 
 public class TransformationActionTest {
 
-    private static final String FOO = "foo", BAR = "bar", QUX = "qux", TEMP = "tmp";
+    private static final String FOO = "foo", BAR = "bar", QUX = "qux", TEMP = ".tmp";
 
     @Rule
     public TestRule mockitoRule = new MockitoRule(this);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -248,7 +248,9 @@ public FieldLocation with(FieldLocator.Factory fieldLocatorFactory) {
 
             @Override
             public Prepared prepare(TypeDescription instrumentedType) {
-                if (!instrumentedType.isAssignableTo(fieldDescription.getDeclaringType().asErasure()) || !fieldDescription.isVisibleTo(instrumentedType)) {
+                if (!instrumentedType.isAssignableTo(fieldDescription.getDeclaringType().asErasure())) {
+                    throw new IllegalStateException(fieldDescription + " is not declared by " + instrumentedType);
+                } else if (!fieldDescription.isVisibleTo(instrumentedType)) {
                     throw new IllegalStateException("Cannot access " + fieldDescription + " from " + instrumentedType);
                 }
                 return this;

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/TransformationAction.java
Patch:
@@ -211,7 +211,7 @@ private void processClassFile(File root,
                                   ClassFileLocator classFileLocator,
                                   TypePool typePool,
                                   List<Plugin> plugins) {
-        String typeName = file.replace('/', '.').substring(0, file.length() - CLASS_FILE_EXTENSION.length());
+        String typeName = file.replace(File.separatorChar, '.').substring(0, file.length() - CLASS_FILE_EXTENSION.length());
         project.getLogger().debug("Processing class file: {}", typeName);
         TypeDescription typeDescription = typePool.describe(typeName).resolve();
         DynamicType.Builder<?> builder;

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/ByteBuddyMojo.java
Patch:
@@ -317,7 +317,7 @@ private void processClassFile(File root,
                                   ClassFileLocator classFileLocator,
                                   TypePool typePool,
                                   List<Plugin> plugins) throws MojoExecutionException, MojoFailureException {
-        String typeName = file.replace('/', '.').substring(0, file.length() - CLASS_FILE_EXTENSION.length());
+        String typeName = file.replace(File.separatorChar, '.').substring(0, file.length() - CLASS_FILE_EXTENSION.length());
         getLog().debug("Processing class file: " + typeName);
         TypeDescription typeDescription = typePool.describe(typeName).resolve();
         DynamicType.Builder<?> builder;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -248,7 +248,7 @@ public FieldLocation with(FieldLocator.Factory fieldLocatorFactory) {
 
             @Override
             public Prepared prepare(TypeDescription instrumentedType) {
-                if (!instrumentedType.isAssignableTo(fieldDescription.getDeclaringType().asErasure()) || !fieldDescription.isAccessibleTo(instrumentedType)) {
+                if (!instrumentedType.isAssignableTo(fieldDescription.getDeclaringType().asErasure()) || !fieldDescription.isVisibleTo(instrumentedType)) {
                     throw new IllegalStateException("Cannot access " + fieldDescription + " from " + instrumentedType);
                 }
                 return this;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -2382,7 +2382,7 @@ public StackManipulation invoke(MethodDescription invokedMethod, Target implemen
                 if (invokedMethod.isVirtual() && !invokedMethod.isInvokableOn(implementationTarget.getInstrumentedType())) {
                     throw new IllegalStateException("Cannot invoke " + invokedMethod + " on " + implementationTarget.getInstrumentedType());
                 } else if (!invokedMethod.isVisibleTo(implementationTarget.getInstrumentedType())) {
-                    throw new IllegalStateException(implementationTarget.getInstrumentedType() + " cannot see " + invokedMethod);
+                    throw new IllegalStateException(invokedMethod + " is not visible to " + implementationTarget.getInstrumentedType());
                 }
                 return invokedMethod.isVirtual()
                         ? MethodInvocation.invoke(invokedMethod).virtual(implementationTarget.getInstrumentedType())
@@ -2429,8 +2429,8 @@ public StackManipulation invoke(MethodDescription invokedMethod, Target implemen
                     throw new IllegalStateException("Cannot invoke " + invokedMethod + " virtually");
                 } else if (!invokedMethod.isInvokableOn(typeDescription.asErasure())) {
                     throw new IllegalStateException("Cannot invoke " + invokedMethod + " on " + typeDescription);
-                } else if (!typeDescription.asErasure().isVisibleTo(implementationTarget.getInstrumentedType())) {
-                    throw new IllegalStateException(typeDescription + " is not visible to " + implementationTarget.getInstrumentedType());
+                } else if (!typeDescription.asErasure().isAccessibleTo(implementationTarget.getInstrumentedType())) {
+                    throw new IllegalStateException(typeDescription + " is not accessible to " + implementationTarget.getInstrumentedType());
                 }
                 return MethodInvocation.invoke(invokedMethod).virtual(typeDescription.asErasure());
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -871,7 +871,7 @@ public ImplementationDelegate filter(ElementMatcher<? super MethodDescription> m
 
             @Override
             public Resolution resolve(TypeDescription instrumentedType) {
-                return new Resolution(candidates.filter(isVisibleTo(instrumentedType)));
+                return new Resolution(candidates.filter(isAccessibleTo(instrumentedType)));
             }
 
             @Override
@@ -1185,7 +1185,7 @@ public ImplementationDelegate filter(ElementMatcher<? super MethodDescription> m
 
             @Override
             public Resolution resolve(TypeDescription instrumentedType) {
-                return new Resolution(candidates.filter(isVisibleTo(instrumentedType)),
+                return new Resolution(candidates.filter(isAccessibleTo(instrumentedType)),
                         new StackManipulation.Compound(TypeCreation.of(typeDescription), Duplication.SINGLE),
                         MethodDelegationBinder.MethodInvoker.Simple.INSTANCE);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -25,6 +25,7 @@
 import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
 import net.bytebuddy.implementation.bytecode.member.MethodReturn;
 import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
+import net.bytebuddy.matcher.ElementMatchers;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
@@ -391,7 +392,7 @@ public DynamicType make(String auxiliaryTypeName,
                         .intercept(specialMethodInvocation.getMethodDescription().isStatic()
                                 ? StaticFieldConstructor.INSTANCE
                                 : new InstanceFieldConstructor(instrumentedType))
-                        .method(isDeclaredBy(morphingType))
+                        .method(ElementMatchers.<MethodDescription>isAbstract().and(isDeclaredBy(morphingType)))
                         .intercept(new MethodCall(methodAccessorFactory.registerAccessorFor(specialMethodInvocation), assigner))
                         .make();
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -27,6 +27,7 @@
 import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
 import net.bytebuddy.implementation.bytecode.member.MethodReturn;
 import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
+import net.bytebuddy.matcher.ElementMatchers;
 import org.objectweb.asm.MethodVisitor;
 
 import java.io.Serializable;
@@ -297,7 +298,7 @@ public DynamicType make(String auxiliaryTypeName,
                         .name(auxiliaryTypeName)
                         .modifiers(DEFAULT_TYPE_MODIFIER)
                         .implement(serializableProxy ? new Class<?>[]{Serializable.class} : new Class<?>[0])
-                        .method(isDeclaredBy(forwardingType))
+                        .method(ElementMatchers.<MethodDescription>isAbstract().and(isDeclaredBy(forwardingType)))
                         .intercept(new MethodCall(sourceMethod, assigner))
                         .defineConstructor().withParameters(parameterFields.values())
                         .intercept(ConstructorCall.INSTANCE);

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.agent;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import org.newsclub.net.unix.AFUNIXSocket;
 import org.newsclub.net.unix.AFUNIXSocketAddress;
 
@@ -262,6 +263,7 @@ public static VirtualMachine attach(String processId) throws IOException {
             }
 
             @Override
+            @SuppressFBWarnings(value = "DMI_HARDCODED_ABSOLUTE_FILENAME", justification = "This is a Unix-specific implementation")
             protected void connect() throws IOException {
                 File socketFile = new File(TEMPORARY_DIRECTORY, SOCKET_FILE_PREFIX + processId);
                 if (!socketFile.exists()) {

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/VirtualMachine.java
Patch:
@@ -81,7 +81,7 @@ abstract class ForHotSpot implements VirtualMachine {
         protected final String processId;
 
         /**
-         * Creates a new HotSpot-compatible VM implementation
+         * Creates a new HotSpot-compatible VM implementation.
          *
          * @param processId The target process's id.
          */

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -302,7 +302,7 @@ private static void install(AttachmentProvider attachmentProvider, String proces
             try {
                 virtualMachineType
                         .getDeclaredMethod(LOAD_AGENT_METHOD_NAME, String.class, String.class)
-                        .invoke(virtualMachineInstance, agentProvider.resolve().getAbsolutePath(), null);
+                        .invoke(virtualMachineInstance, agentProvider.resolve().getAbsolutePath(), argument);
             } finally {
                 virtualMachineType
                         .getDeclaredMethod(DETACH_METHOD_NAME)

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -286,12 +286,14 @@ public interface TypeDescription extends TypeDefinition, ByteCodeElement, TypeVa
 
     /**
      * Returns a description of this type that represents this type as a boxed type for primitive types, unless its {@code void}.
+     *
      * @return A description of this type in its boxed form.
      */
     TypeDescription asBoxed();
 
     /**
      * Returns a description of this type that represents this type as an unboxed type for boxing types, unless its {@link Void}.
+     *
      * @return A description of this type in its unboxed form.
      */
     TypeDescription asUnboxed();

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -5042,7 +5042,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                                 new StackManipulation.Compound(fieldAccess),
                                 new StackManipulation.Compound(parameterAccess),
                                 MethodInvocation.invoke(targetMethod),
-                                MethodReturn.of(targetMethod.getReturnType().asErasure())
+                                MethodReturn.of(targetMethod.getReturnType())
                         ).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());
                     }
 
@@ -5297,8 +5297,8 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                                 bridgeTargetInvocation,
                                 bridgeTargetInvocation.getMethodDescription().getReturnType().asErasure().isAssignableTo(instrumentedMethod.getReturnType().asErasure())
                                         ? StackManipulation.Trivial.INSTANCE
-                                        : TypeCasting.to(instrumentedMethod.getReceiverType().asErasure()),
-                                MethodReturn.of(instrumentedMethod.getReturnType().asErasure())
+                                        : TypeCasting.to(instrumentedMethod.getReceiverType()),
+                                MethodReturn.of(instrumentedMethod.getReturnType())
 
                         )).apply(methodVisitor, implementationContext, instrumentedMethod);
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -220,7 +220,7 @@ public class Advice implements AsmVisitorWrapper.ForDeclaredMethods.MethodVisito
      * @param methodExit  The dispatcher for instrumenting the instrumented method upon exiting.
      */
     protected Advice(Dispatcher.Resolved.ForMethodEnter methodEnter, Dispatcher.Resolved.ForMethodExit methodExit) {
-        this(methodEnter, methodExit, Assigner.DEFAULT, Removal.pop(TypeDescription.THROWABLE), SuperMethodCall.INSTANCE);
+        this(methodEnter, methodExit, Assigner.DEFAULT, Removal.of(TypeDescription.THROWABLE), SuperMethodCall.INSTANCE);
     }
 
     /**
@@ -1918,7 +1918,7 @@ protected ReadWrite(TypeDefinition typeDefinition, StackManipulation readAssignm
 
                         @Override
                         public StackManipulation resolveWrite() {
-                            return Removal.pop(typeDefinition);
+                            return Removal.of(typeDefinition);
                         }
 
                         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -945,7 +945,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                         return new ByteCodeAppender.Simple(
                                 MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(),
                                 MethodInvocation.invoke(bridgeTarget).special(superClass),
-                                MethodReturn.of(instrumentedMethod.getReturnType().asErasure())
+                                MethodReturn.of(instrumentedMethod.getReturnType())
                         ).apply(methodVisitor, implementationContext, instrumentedMethod);
                     }
 
@@ -1173,7 +1173,7 @@ public void apply(ClassVisitor classVisitor,
                                 bridgeTarget.getReturnType().asErasure().isAssignableTo(bridgeMethod.getReturnType().asErasure())
                                         ? StackManipulation.Trivial.INSTANCE
                                         : TypeCasting.to(bridgeMethod.getReturnType().asErasure()),
-                                MethodReturn.of(bridgeMethod.getReturnType().asErasure())
+                                MethodReturn.of(bridgeMethod.getReturnType())
                         ).apply(methodVisitor, implementationContext, bridgeMethod);
                         methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());
                         methodVisitor.visitEnd();

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/DefaultMethodCall.java
Patch:
@@ -210,7 +210,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
             StackManipulation.Size stackSize = new StackManipulation.Compound(
                     MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(),
                     defaultMethodInvocation,
-                    MethodReturn.of(instrumentedMethod.getReturnType().asErasure())
+                    MethodReturn.of(instrumentedMethod.getReturnType())
             ).apply(methodVisitor, implementationContext);
             return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -125,7 +125,7 @@ protected StackManipulation setter(FieldDescription fieldDescription, ParameterD
         }
         return access(fieldDescription,
                 parameterDescription.getDeclaringMethod(),
-                new StackManipulation.Compound(MethodVariableAccess.of(fieldDescription.getType().asErasure()).loadFrom(parameterDescription.getOffset()),
+                new StackManipulation.Compound(MethodVariableAccess.of(fieldDescription.getType()).loadFrom(parameterDescription.getOffset()),
                         assigner.assign(parameterDescription.getType(), fieldDescription.getType(), typing),
                         FieldAccess.forField(fieldDescription).write()));
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -212,7 +212,7 @@ protected ByteCodeAppender.Size apply(MethodVisitor methodVisitor,
         StackManipulation.Size stackSize = new StackManipulation.Compound(
                 valueLoadingInstruction,
                 assignment,
-                MethodReturn.of(instrumentedMethod.getReturnType().asErasure())
+                MethodReturn.of(instrumentedMethod.getReturnType())
         ).apply(methodVisitor, implementationContext);
         return new ByteCodeAppender.Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Forwarding.java
Patch:
@@ -330,7 +330,7 @@ protected enum TerminationHandler {
         DROPPING {
             @Override
             protected StackManipulation resolve(TypeDefinition returnType) {
-                return Removal.pop(returnType);
+                return Removal.of(returnType);
             }
         },
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -1467,7 +1467,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                     StackManipulation.Size stackSize = new StackManipulation.Compound(
                             MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(),
                             accessorMethodInvocation,
-                            MethodReturn.of(instrumentedMethod.getReturnType().asErasure())
+                            MethodReturn.of(instrumentedMethod.getReturnType())
                     ).apply(methodVisitor, implementationContext);
                     return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
                 }
@@ -1521,7 +1521,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                                     ? StackManipulation.Trivial.INSTANCE
                                     : MethodVariableAccess.REFERENCE.loadFrom(0),
                             FieldAccess.forField(fieldDescription).read(),
-                            MethodReturn.of(fieldDescription.getType().asErasure())
+                            MethodReturn.of(fieldDescription.getType())
                     ).apply(methodVisitor, implementationContext);
                     return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -184,7 +184,7 @@ protected ByteCodeAppender.Size apply(MethodVisitor methodVisitor,
                 ArrayFactory.forType(TypeDescription.Generic.OBJECT).withValues(argumentValuesOf(instrumentedMethod)),
                 MethodInvocation.invoke(INVOCATION_HANDLER_TYPE.getDeclaredMethods().getOnly()),
                 assigner.assign(TypeDescription.Generic.OBJECT, instrumentedMethod.getReturnType(), Assigner.Typing.DYNAMIC),
-                MethodReturn.of(instrumentedMethod.getReturnType().asErasure())
+                MethodReturn.of(instrumentedMethod.getReturnType())
         ).apply(methodVisitor, implementationContext);
         return new ByteCodeAppender.Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/StubMethod.java
Patch:
@@ -41,8 +41,8 @@ public Size apply(MethodVisitor methodVisitor,
                       Context implementationContext,
                       MethodDescription instrumentedMethod) {
         StackManipulation.Size stackSize = new StackManipulation.Compound(
-                DefaultValue.of(instrumentedMethod.getReturnType().asErasure()),
-                MethodReturn.of(instrumentedMethod.getReturnType().asErasure())
+                DefaultValue.of(instrumentedMethod.getReturnType()),
+                MethodReturn.of(instrumentedMethod.getReturnType())
         ).apply(methodVisitor, implementationContext);
         return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/SuperMethodCall.java
Patch:
@@ -143,7 +143,7 @@ protected enum TerminationHandler {
             RETURNING {
                 @Override
                 protected StackManipulation of(MethodDescription methodDescription) {
-                    return MethodReturn.of(methodDescription.getReturnType().asErasure());
+                    return MethodReturn.of(methodDescription.getReturnType());
                 }
             },
 
@@ -153,7 +153,7 @@ protected StackManipulation of(MethodDescription methodDescription) {
             DROPPING {
                 @Override
                 protected StackManipulation of(MethodDescription methodDescription) {
-                    return Removal.pop(methodDescription.getReturnType().asErasure());
+                    return Removal.of(methodDescription.getReturnType());
                 }
             };
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -304,8 +304,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                 for (FieldDescription fieldDescription : fieldList) {
                     fieldLoading[index] = new StackManipulation.Compound(
                             thisReference,
-                            MethodVariableAccess.of(fieldDescription.getType().asErasure())
-                                    .loadFrom(instrumentedMethod.getParameters().get(index).getOffset()),
+                            MethodVariableAccess.of(fieldDescription.getType()).loadFrom(instrumentedMethod.getParameters().get(index).getOffset()),
                             FieldAccess.forField(fieldDescription).write()
                     );
                     index++;
@@ -427,7 +426,7 @@ public Size apply(MethodVisitor methodVisitor,
                         new StackManipulation.Compound(fieldLoading),
                         MethodInvocation.invoke(accessorMethod),
                         assigner.assign(accessorMethod.getReturnType(), instrumentedMethod.getReturnType(), Assigner.Typing.DYNAMIC),
-                        MethodReturn.of(instrumentedMethod.getReturnType().asErasure())
+                        MethodReturn.of(instrumentedMethod.getReturnType())
                 ).apply(methodVisitor, implementationContext);
                 return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TypeProxy.java
Patch:
@@ -867,7 +867,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                             fieldLoadingInstruction,
                             MethodVariableAccess.allArgumentsOf(instrumentedMethod).asBridgeOf(proxyMethod),
                             MethodInvocation.invoke(proxyMethod),
-                            MethodReturn.of(instrumentedMethod.getReturnType().asErasure())
+                            MethodReturn.of(instrumentedMethod.getReturnType())
                     ).apply(methodVisitor, implementationContext);
                 }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -422,8 +422,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                         for (FieldDescription fieldDescription : fieldList) {
                             fieldLoading[index] = new StackManipulation.Compound(
                                     thisReference,
-                                    MethodVariableAccess.of(fieldDescription.getType().asErasure())
-                                            .loadFrom(instrumentedMethod.getParameters().get(index).getOffset()),
+                                    MethodVariableAccess.of(fieldDescription.getType()).loadFrom(instrumentedMethod.getParameters().get(index).getOffset()),
                                     FieldAccess.forField(fieldDescription).write()
                             );
                             index++;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Duplication.java
Patch:
@@ -86,7 +86,7 @@ public StackManipulation flipOver(TypeDefinition typeDefinition) {
      * @param typeDefinition The type to be duplicated.
      * @return A stack manipulation that duplicates the given type.
      */
-    public static Duplication duplicate(TypeDefinition typeDefinition) {
+    public static Duplication of(TypeDefinition typeDefinition) {
         switch (typeDefinition.getStackSize()) {
             case SINGLE:
                 return SINGLE;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Removal.java
Patch:
@@ -57,7 +57,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
      * @param typeDefinition The type to remove from the stack.
      * @return A stack manipulation that represents the removal.
      */
-    public static StackManipulation pop(TypeDefinition typeDefinition) {
+    public static StackManipulation of(TypeDefinition typeDefinition) {
         switch (typeDefinition.getStackSize()) {
             case SINGLE:
                 return SINGLE;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/VoidAwareAssigner.java
Patch:
@@ -43,7 +43,7 @@ public StackManipulation assign(TypeDescription.Generic source, TypeDescription.
                     ? DefaultValue.of(target)
                     : StackManipulation.Illegal.INSTANCE;
         } else if (/* source != void.class && */ target.represents(void.class)) {
-            return Removal.pop(source);
+            return Removal.of(source);
         } else /* source != void.class && target != void.class */ {
             return chained.assign(source, target, typing);
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/DuplicationWithFlipTest.java
Patch:
@@ -63,7 +63,7 @@ public void setUp() throws Exception {
 
     @Test
     public void testFlip() throws Exception {
-        StackManipulation stackManipulation = Duplication.duplicate(top).flipOver(second);
+        StackManipulation stackManipulation = Duplication.of(top).flipOver(second);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);
         assertThat(size.getMaximalSize(), is(topSize.getSize()));

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -8713,7 +8713,9 @@ protected Object doResolve(TypeDescription instrumentedType,
                                            AnnotationDescription.Loadable<Annotation> annotation,
                                            Assigner assigner,
                                            boolean initialized) {
-                    if (value instanceof Class) {
+                    if (value == null) {
+                        return null;
+                    } else if (value instanceof Class) {
                         return new TypeDescription.ForLoadedType((Class<?>) value);
                     } else if (JavaType.METHOD_HANDLE.getTypeStub().isInstance(value)) {
                         return JavaConstant.MethodHandle.ofLoaded(value);

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRedefinitionStrategyTest.java
Patch:
@@ -59,5 +59,7 @@ public void testRedefinitionStrategyNotSupportedThrowsException() throws Excepti
     @Test
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(AgentBuilder.RedefinitionStrategy.class).apply();
+        ObjectPropertyAssertion.of(AgentBuilder.RedefinitionStrategy.Collector.ForRedefinition.class).applyBasic();
+        ObjectPropertyAssertion.of(AgentBuilder.RedefinitionStrategy.Collector.ForRetransformation.class).applyBasic();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/AdditionObjectPropertiesTest.java
Patch:
@@ -3,10 +3,10 @@
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
-public class DuplicationObjectPropertiesTest {
+public class AdditionObjectPropertiesTest {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(Duplication.class).apply();
+        ObjectPropertyAssertion.of(Addition.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceAnnotationTest.java
Patch:
@@ -18,15 +18,15 @@ public class AdviceAnnotationTest {
     public static Collection<Object[]> data() {
         return Arrays.asList(new Object[][]{
                 {Advice.Argument.class, ElementType.PARAMETER},
-                {Advice.BoxedArguments.class, ElementType.PARAMETER},
-                {Advice.BoxedReturn.class, ElementType.PARAMETER},
+                {Advice.AllArguments.class, ElementType.PARAMETER},
                 {Advice.FieldValue.class, ElementType.PARAMETER},
                 {Advice.Enter.class, ElementType.PARAMETER},
                 {Advice.Unused.class, ElementType.PARAMETER},
                 {Advice.Origin.class, ElementType.PARAMETER},
                 {Advice.Return.class, ElementType.PARAMETER},
                 {Advice.This.class, ElementType.PARAMETER},
                 {Advice.Thrown.class, ElementType.PARAMETER},
+                {Advice.StubValue.class, ElementType.PARAMETER},
                 {Advice.OnMethodEnter.class, ElementType.METHOD},
                 {Advice.OnMethodExit.class, ElementType.METHOD}
         });

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceInconsistentStackSizeTest.java
Patch:
@@ -11,6 +11,7 @@
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
 import net.bytebuddy.implementation.bytecode.StackSize;
+import net.bytebuddy.implementation.bytecode.assign.Assigner;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -111,7 +112,7 @@ public void testInconsistentStackSizeAdvice() throws Exception {
     private static class ExitAdvice {
 
         @Advice.OnMethodExit
-        private static void exit(@Advice.BoxedReturn(readOnly = false) Object returned, @Value Object value) {
+        private static void exit(@Advice.Return(readOnly = false, typing = Assigner.Typing.DYNAMIC) Object returned, @Value Object value) {
             returned = value;
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/TypeConstantAdjustment.java
Patch:
@@ -3,6 +3,7 @@
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.pool.TypePool;
 import org.objectweb.asm.*;
 
 /**
@@ -36,7 +37,7 @@ public int mergeReader(int flags) {
     }
 
     @Override
-    public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, int writerFlags, int readerFlags) {
+    public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, TypePool typePool, int writerFlags, int readerFlags) {
         return new TypeConstantDissolvingClassVisitor(classVisitor);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3093,6 +3093,7 @@ protected UnresolvedType create(TypeInitializer typeInitializer) {
                     ContextRegistry contextRegistry = new ContextRegistry();
                     classReader.accept(writeTo(asmVisitorWrapper.wrap(instrumentedType,
                             ValidatingClassVisitor.of(classWriter, typeValidation),
+                            typePool,
                             writerFlags,
                             readerFlags), typeInitializer, contextRegistry), readerFlags);
                     return new UnresolvedType(classWriter.toByteArray(), contextRegistry.getAuxiliaryTypes());
@@ -3855,6 +3856,7 @@ protected UnresolvedType create(TypeInitializer typeInitializer) {
                 ClassWriter classWriter = new FrameComputingClassWriter(writerFlags, typePool);
                 ClassVisitor classVisitor = asmVisitorWrapper.wrap(instrumentedType,
                         ValidatingClassVisitor.of(classWriter, typeValidation),
+                        typePool,
                         writerFlags,
                         asmVisitorWrapper.mergeReader(AsmVisitorWrapper.NO_FLAGS));
                 classVisitor.visit(classFileVersion.getMinorMajorVersion(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTypeTest.java
Patch:
@@ -3,6 +3,7 @@
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
+import net.bytebuddy.pool.TypePool;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -1955,7 +1956,7 @@ public static Object exit(@Advice.Return Object result,
     private static class SerializationAssertion extends AsmVisitorWrapper.AbstractBase {
 
         @Override
-        public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, int writerFlags, int readerFlags) {
+        public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, TypePool typePool, int writerFlags, int readerFlags) {
             return new SerializationClassVisitor(classVisitor);
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AsmVisitorWrapperNoOpTest.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.asm;
 
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.pool.TypePool;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 import org.objectweb.asm.ClassVisitor;
@@ -12,12 +13,12 @@
 
 public class AsmVisitorWrapperNoOpTest {
 
-    private static final int FOO = 42, IRRELEVANT = -1;
+    private static final int FOO = 42, IGNORED = -1;
 
     @Test
     public void testWrapperChain() throws Exception {
         ClassVisitor classVisitor = mock(ClassVisitor.class);
-        assertThat(AsmVisitorWrapper.NoOp.INSTANCE.wrap(mock(TypeDescription.class), classVisitor, IRRELEVANT, IRRELEVANT), is(classVisitor));
+        assertThat(AsmVisitorWrapper.NoOp.INSTANCE.wrap(mock(TypeDescription.class), classVisitor, mock(TypePool.class), IGNORED, IGNORED), is(classVisitor));
         verifyZeroInteractions(classVisitor);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AbstractAnnotationDescriptionTest.java
Patch:
@@ -8,6 +8,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeVariableToken;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
+import net.bytebuddy.pool.TypePool;
 import org.hamcrest.CoreMatchers;
 import org.junit.Before;
 import org.junit.Ignore;
@@ -710,7 +711,7 @@ class Carrier {
     private static class AnnotationValueBreaker extends AsmVisitorWrapper.AbstractBase {
 
         @Override
-        public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, int writerFlags, int readerFlags) {
+        public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, TypePool typePool, int writerFlags, int readerFlags) {
             return new BreakingClassVisitor(classVisitor);
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -25,6 +25,7 @@
 import net.bytebuddy.implementation.bytecode.constant.TextConstant;
 import net.bytebuddy.implementation.bytecode.member.FieldAccess;
 import net.bytebuddy.implementation.bytecode.member.MethodReturn;
+import net.bytebuddy.pool.TypePool;
 import net.bytebuddy.test.utility.CallTraceable;
 import net.bytebuddy.test.utility.ClassFileExtraction;
 import net.bytebuddy.test.utility.JavaVersionRule;
@@ -348,7 +349,7 @@ public void testPreparedMethod() throws Exception {
     @Test
     public void testWriterHint() throws Exception {
         AsmVisitorWrapper asmVisitorWrapper = mock(AsmVisitorWrapper.class);
-        when(asmVisitorWrapper.wrap(any(TypeDescription.class), any(ClassVisitor.class), anyInt(), anyInt())).then(new Answer<ClassVisitor>() {
+        when(asmVisitorWrapper.wrap(any(TypeDescription.class), any(ClassVisitor.class), any(TypePool.class), anyInt(), anyInt())).then(new Answer<ClassVisitor>() {
             @Override
             public ClassVisitor answer(InvocationOnMock invocationOnMock) throws Throwable {
                 return new ClassVisitor(Opcodes.ASM5, (ClassVisitor) invocationOnMock.getArguments()[1]) {
@@ -373,7 +374,7 @@ public void visitEnd() {
         assertThat(type.getDeclaredMethod(FOO).invoke(type.getDeclaredConstructor().newInstance()), is((Object) FOO));
         verify(asmVisitorWrapper).mergeWriter(0);
         verify(asmVisitorWrapper, atMost(1)).mergeReader(0);
-        verify(asmVisitorWrapper).wrap(any(TypeDescription.class), any(ClassVisitor.class), anyInt(), anyInt());
+        verify(asmVisitorWrapper).wrap(any(TypeDescription.class), any(ClassVisitor.class), any(TypePool.class), anyInt(), anyInt());
         verifyNoMoreInteractions(asmVisitorWrapper);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoaderChildFirstTest.java
Patch:
@@ -3,6 +3,7 @@
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.asm.AsmVisitorWrapper;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.pool.TypePool;
 import net.bytebuddy.test.utility.ClassFileExtraction;
 import net.bytebuddy.test.utility.MockitoRule;
 import org.hamcrest.CoreMatchers;
@@ -218,7 +219,7 @@ public int mergeReader(int flags) {
         }
 
         @Override
-        public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, int writerFlags, int readerFlags) {
+        public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, TypePool typePool, int writerFlags, int readerFlags) {
             return new ClassRemapper(classVisitor, new SimpleRemapper(oldName, newName));
         }
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterModifierPreservationTest.java
Patch:
@@ -4,6 +4,7 @@
 import net.bytebuddy.asm.AsmVisitorWrapper;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
+import net.bytebuddy.pool.TypePool;
 import net.bytebuddy.test.scope.EnclosingType;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -125,7 +126,7 @@ public Wrapper(TypeModifierExtractor typeModifierExtractor) {
             }
 
             @Override
-            public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, int writerFlags, int readerFlags) {
+            public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, TypePool typePool, int writerFlags, int readerFlags) {
                 return new TypeValidator(classVisitor, modifiers, inner);
             }
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/AbstractDynamicTypeBuilderForInliningTest.java
Patch:
@@ -378,7 +378,7 @@ public void testFieldTransformationExistingField() throws Exception {
     @Test
     public void testReaderHint() throws Exception {
         AsmVisitorWrapper asmVisitorWrapper = mock(AsmVisitorWrapper.class);
-        when(asmVisitorWrapper.wrap(any(TypeDescription.class), any(ClassVisitor.class), anyInt(), anyInt())).then(new Answer<ClassVisitor>() {
+        when(asmVisitorWrapper.wrap(any(TypeDescription.class), any(ClassVisitor.class), any(TypePool.class), anyInt(), anyInt())).then(new Answer<ClassVisitor>() {
             @Override
             public ClassVisitor answer(InvocationOnMock invocationOnMock) throws Throwable {
                 return new ClassVisitor(Opcodes.ASM5, (ClassVisitor) invocationOnMock.getArguments()[1]) {
@@ -399,7 +399,7 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si
         assertThat(type.getDeclaredMethod(FOO).invoke(type.getDeclaredConstructor().newInstance()), is((Object) BAR));
         verify(asmVisitorWrapper).mergeWriter(0);
         verify(asmVisitorWrapper).mergeReader(0);
-        verify(asmVisitorWrapper).wrap(any(TypeDescription.class), any(ClassVisitor.class), anyInt(), anyInt());
+        verify(asmVisitorWrapper).wrap(any(TypeDescription.class), any(ClassVisitor.class), any(TypePool.class), anyInt(), anyInt());
         verifyNoMoreInteractions(asmVisitorWrapper);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/ClassFileExtraction.java
Patch:
@@ -2,6 +2,7 @@
 
 import net.bytebuddy.asm.AsmVisitorWrapper;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.pool.TypePool;
 import org.junit.Test;
 import org.objectweb.asm.ClassReader;
 import org.objectweb.asm.ClassWriter;
@@ -30,6 +31,7 @@ public static byte[] extract(Class<?> type, AsmVisitorWrapper asmVisitorWrapper)
         ClassWriter classWriter = new ClassWriter(classReader, AsmVisitorWrapper.NO_FLAGS);
         classReader.accept(asmVisitorWrapper.wrap(new TypeDescription.ForLoadedType(type),
                 classWriter,
+                TypePool.Empty.INSTANCE,
                 AsmVisitorWrapper.NO_FLAGS,
                 AsmVisitorWrapper.NO_FLAGS), AsmVisitorWrapper.NO_FLAGS);
         return classWriter.toByteArray();

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/DebuggingWrapper.java
Patch:
@@ -2,6 +2,7 @@
 
 import net.bytebuddy.asm.AsmVisitorWrapper;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.pool.TypePool;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.util.CheckClassAdapter;
 import org.objectweb.asm.util.Printer;
@@ -52,7 +53,7 @@ public int mergeReader(int flags) {
     }
 
     @Override
-    public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, int writerFlags, int readerFlags) {
+    public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, TypePool typePool, int writerFlags, int readerFlags) {
         return check
                 ? new CheckClassAdapter(new TraceClassVisitor(classVisitor, printer, printWriter))
                 : new TraceClassVisitor(classVisitor, printer, printWriter);

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaType.java
Patch:
@@ -36,7 +36,7 @@ public enum JavaType {
     CALL_SITE("java.lang.invoke.CallSite", Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT, Object.class),
 
     /**
-     * The Java 7 {@code java.lang.reflect.Parameter} type.
+     * The Java 8 {@code java.lang.reflect.Parameter} type.
      */
     PARAMETER("java.lang.reflect.Parameter", Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL, Object.class, AnnotatedElement.class),
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaTypeTest.java
Patch:
@@ -91,12 +91,12 @@ public void testJava7Types() throws Exception {
         assertThat(JavaType.METHOD_TYPE.load(), notNullValue(Class.class));
         assertThat(JavaType.METHOD_HANDLES_LOOKUP.load(), notNullValue(Class.class));
         assertThat(JavaType.CALL_SITE.load(), notNullValue(Class.class));
-        assertThat(JavaType.PARAMETER.load(), notNullValue(Class.class));
     }
 
     @Test
     @JavaVersionRule.Enforce(8)
     public void testJava8Types() throws Exception {
+        assertThat(JavaType.PARAMETER.load(), notNullValue(Class.class));
         assertThat(JavaType.EXECUTABLE.load(), notNullValue(Class.class));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceCustomAnnotationOnParameterTest.java
Patch:
@@ -61,7 +61,7 @@ public void testPrimitiveField() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(type.getDeclaredMethod(FOO).invoke(type.getDeclaredConstructor().newInstance()), is(expected));
+        assertThat(type.getDeclaredMethod(FOO, argumentType).invoke(type.getDeclaredConstructor().newInstance(), expected), is(expected));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -124,7 +124,7 @@ public interface MethodDescription extends TypeVariableSource,
     /**
      * Checks if this method description represents a method, i.e. not a constructor or a type initializer.
      *
-     * @return {@code true} if this method description represents a method.
+     * @return {@code true} if this method description represents a Java method.
      */
     boolean isMethod();
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -120,8 +120,8 @@ protected StackManipulation getter(FieldDescription fieldDescription, MethodDesc
      * @return A stack manipulation that sets the field's value.
      */
     protected StackManipulation setter(FieldDescription fieldDescription, ParameterDescription parameterDescription) {
-        if (fieldDescription.isFinal() && !parameterDescription.getDeclaringMethod().isConstructor()) {
-            throw new IllegalArgumentException("Cannot apply setter on final field " + fieldDescription + " outside of constructor");
+        if (fieldDescription.isFinal() && parameterDescription.getDeclaringMethod().isMethod()) {
+            throw new IllegalArgumentException("Cannot set final field " + fieldDescription + " from " + parameterDescription.getDeclaringMethod());
         }
         return access(fieldDescription,
                 parameterDescription.getDeclaringMethod(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -13,6 +13,7 @@
 import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
 import net.bytebuddy.utility.JavaConstant;
 import net.bytebuddy.utility.JavaType;
+import net.bytebuddy.utility.RandomString;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
@@ -599,7 +600,7 @@ protected static class ForStaticField extends FixedValue implements AssignerConf
          * @param typing     Indicates if dynamic type castings should be attempted for incompatible assignments.
          */
         protected ForStaticField(Object fixedValue, Assigner assigner, Assigner.Typing typing) {
-            this(String.format("%s$%d", PREFIX, Math.abs(fixedValue.hashCode() % Integer.MAX_VALUE)), fixedValue, assigner, typing);
+            this(String.format("%s$%s", PREFIX, RandomString.hashOf(fixedValue.hashCode())), fixedValue, assigner, typing);
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Forwarding.java
Patch:
@@ -13,6 +13,7 @@
 import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
 import net.bytebuddy.implementation.bytecode.member.MethodReturn;
 import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
+import net.bytebuddy.utility.RandomString;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
@@ -88,7 +89,7 @@ public static Implementation.Composable to(Object delegate, String fieldName) {
      * @return A corresponding implementation.
      */
     public static Implementation.Composable to(Object delegate, Type type) {
-        return to(delegate, String.format("%s$%d", FIELD_PREFIX, Math.abs(delegate.hashCode() % Integer.MAX_VALUE)), type);
+        return to(delegate, String.format("%s$%s", FIELD_PREFIX, RandomString.hashOf(delegate.hashCode())), type);
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -20,6 +20,7 @@
 import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
 import net.bytebuddy.matcher.ElementMatcher;
 import net.bytebuddy.utility.CompoundList;
+import net.bytebuddy.utility.RandomString;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
@@ -368,7 +369,7 @@ public static MethodDelegation to(Object delegate, Type type) {
     public static MethodDelegation to(Object delegate, Type type, MethodGraph.Compiler methodGraphCompiler) {
         return to(delegate,
                 type,
-                String.format("%s$%d", ImplementationDelegate.FIELD_NAME_PREFIX, Math.abs(delegate.hashCode() % Integer.MAX_VALUE)),
+                String.format("%s$%s", ImplementationDelegate.FIELD_NAME_PREFIX, RandomString.hashOf(delegate.hashCode())),
                 methodGraphCompiler);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/InvocationHandlerAdapterTest.java
Patch:
@@ -168,6 +168,7 @@ public void testIncompatibleFieldType() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(InvocationHandlerAdapter.ForInstance.class).apply();
         ObjectPropertyAssertion.of(InvocationHandlerAdapter.ForInstance.Appender.class).apply();
         ObjectPropertyAssertion.of(InvocationHandlerAdapter.ForInstance.Appender.class).skipSynthetic().apply();
         ObjectPropertyAssertion.of(InvocationHandlerAdapter.ForField.class).apply();

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -556,7 +556,7 @@ protected StackManipulation resolve(Assigner assigner, MethodDescription source,
         },
 
         /**
-         * A termination handler that drops the delegate method's return value,
+         * A termination handler that drops the delegate method's return value.
          */
         DROPPING {
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -2965,7 +2965,7 @@ public int resolveAccess(MethodVisitor methodVisitor, int opcode) {
                                         false);
                                 return getAdditionalOffset() + (methodDescription.getParameters().isEmpty()
                                         ? 0
-                                        : 2);
+                                        : 3);
                             default:
                                 throw new IllegalStateException("Unexpected opcode: " + opcode);
                         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -1731,7 +1731,7 @@ protected WithExplicitType(String fieldName, FieldLocator.Factory fieldLocatorFa
                     protected Resolved doResolve(StackManipulation access, TypeDescription.Generic typeDescription, Assigner assigner, Assigner.Typing typing) {
                         StackManipulation stackManipulation = assigner.assign(typeDescription, this.typeDescription.asGenericType(), typing);
                         if (!stackManipulation.isValid()) {
-                            throw new IllegalArgumentException("Cannot assign " + typeDescription + " to " + this.typeDescription);
+                            throw new IllegalStateException("Cannot assign " + typeDescription + " to " + this.typeDescription);
                         }
                         return new Resolved.Simple(new StackManipulation.Compound(access, stackManipulation), this.typeDescription);
                     }
@@ -1855,7 +1855,7 @@ protected WithExplicitType(int index, TypeDescription typeDescription) {
                     protected Resolved doResolve(StackManipulation access, TypeDescription.Generic type, Assigner assigner, Assigner.Typing typing) {
                         StackManipulation stackManipulation = assigner.assign(type, typeDescription.asGenericType(), typing);
                         if (!stackManipulation.isValid()) {
-                            throw new IllegalArgumentException("Cannot assign " + type + " to " + typeDescription);
+                            throw new IllegalStateException("Cannot assign " + type + " to " + typeDescription);
                         }
                         return new Resolved.Simple(new StackManipulation.Compound(access, stackManipulation), typeDescription);
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -5881,7 +5881,7 @@ public int hashCode() {
 
             @Override
             public boolean equals(Object other) {
-                return resolve().equals(other);
+                return other instanceof TypeDefinition && resolve().equals(other);
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -659,7 +659,7 @@ public TypeList asErasures() {
             /**
              * A type projection of an interface type.
              */
-            private static class TypeProjection extends TypeDescription.Generic.LazyProjection.OfAnnotatedElement {
+            private static class TypeProjection extends TypeDescription.Generic.LazyProjection.WithLazyNavigation.OfAnnotatedElement {
 
                 /**
                  * The type of which an interface type is represented.
@@ -746,7 +746,7 @@ public TypeList asErasures() {
             /**
              * A projection of a specific exception type.
              */
-            private static class TypeProjection extends TypeDescription.Generic.LazyProjection.OfAnnotatedElement {
+            private static class TypeProjection extends TypeDescription.Generic.LazyProjection.WithEagerNavigation.OfAnnotatedElement {
 
                 /**
                  * The constructor of which the exception types are represented.
@@ -833,7 +833,7 @@ public TypeList asErasures() {
             /**
              * A projection of a specific exception type.
              */
-            private static class TypeProjection extends TypeDescription.Generic.LazyProjection.OfAnnotatedElement {
+            private static class TypeProjection extends TypeDescription.Generic.LazyProjection.WithEagerNavigation.OfAnnotatedElement {
 
                 /**
                  * The method of which the exception types are represented.

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -6582,7 +6582,7 @@ public int getStackSize() {
             /**
              * A representation of a generic type that is described by a {@link GenericTypeToken}.
              */
-            private static class TokenizedGenericType extends Generic.LazyProjection {
+            private static class TokenizedGenericType extends Generic.LazyProjection.WithEagerNavigation {
 
                 /**
                  * The type pool to use for locating referenced types.
@@ -6818,7 +6818,7 @@ public int size() {
                 /**
                  * A lazy description of a non-well-defined described generic type.
                  */
-                protected static class Malformed extends LazyProjection {
+                protected static class Malformed extends LazyProjection.WithEagerNavigation {
 
                     /**
                      * The type pool to use for locating types.

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/AbstractMethodDescriptionTest.java
Patch:
@@ -5,6 +5,7 @@
 import net.bytebuddy.description.annotation.AnnotationList;
 import net.bytebuddy.description.annotation.AnnotationValue;
 import net.bytebuddy.description.enumeration.EnumerationDescription;
+import net.bytebuddy.description.modifier.Visibility;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
@@ -623,6 +624,8 @@ public void testGetActualModifiers() throws Exception {
         assertThat(describe(firstMethod).getActualModifiers(true), is(Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC));
         assertThat(describe(firstMethod).getActualModifiers(false), is(Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC | Opcodes.ACC_ABSTRACT));
         assertThat(describe(DeprecationSample.class.getDeclaredMethod("foo")).getActualModifiers(), is(Opcodes.ACC_PRIVATE | Opcodes.ACC_DEPRECATED));
+        assertThat(describe(firstMethod).getActualModifiers(true, Visibility.PUBLIC), is(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC));
+        assertThat(describe(secondMethod).getActualModifiers(false, Visibility.PRIVATE), is(Opcodes.ACC_PROTECTED | Opcodes.ACC_ABSTRACT));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -1021,10 +1021,11 @@ public void testCanOverloadFieldByType() throws Exception {
     }
 
     @Test
-    @Ignore() // TODO: Fix!
+//    @Ignore() // TODO: Fix!
     public void testInterfaceMakesClassMethodPublic() throws Exception {
         Class<?> type = createPlain()
                 .implement(Cloneable.class)
+                .method(named("clone"))
                 .intercept(FixedValue.self())
                 .make()
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST)

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/FieldManifestation.java
Patch:
@@ -53,7 +53,7 @@ public int getMask() {
 
     @Override
     public int getRange() {
-        return Opcodes.ACC_FINAL | Opcodes.ACC_VOLATILE;
+        return Opcodes.ACC_FINAL | Opcodes.ACC_VOLATILE | Opcodes.ACC_TRANSIENT;
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/modifier/ModifierContributorTest.java
Patch:
@@ -27,6 +27,7 @@ public static Collection<Object[]> data() {
                 {FieldManifestation.class},
                 {MethodArguments.class},
                 {MethodManifestation.class},
+                {MethodStrictness.class},
                 {Ownership.class},
                 {ParameterManifestation.class},
                 {ProvisioningState.class},

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/modifier/FieldManifestationTest.java
Patch:
@@ -36,7 +36,7 @@ public static Collection<Object[]> data() {
                 {FieldManifestation.PLAIN, 0, true, false, false, false, true},
                 {FieldManifestation.FINAL, Opcodes.ACC_FINAL, false, true, false, false, false},
                 {FieldManifestation.VOLATILE, Opcodes.ACC_VOLATILE, false, false, true, false, false},
-                {FieldManifestation.TRANSIENT, Opcodes.ACC_TRANSIENT, false, false, true, true, false},
+                {FieldManifestation.TRANSIENT, Opcodes.ACC_TRANSIENT, false, false, false, true, false},
                 {FieldManifestation.VOLATILE_TRANSIENT, Opcodes.ACC_VOLATILE | Opcodes.ACC_TRANSIENT, false, false, true, true, false},
         });
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -1820,6 +1820,7 @@ public void testExecutingTransformerReturnsNullValue() throws Exception {
                 mock(AgentBuilder.Default.NativeMethodStrategy.class),
                 initializationStrategy,
                 mock(AgentBuilder.Default.BootstrapInjectionStrategy.class),
+                AgentBuilder.LambdaInstrumentationStrategy.DISABLED,
                 AgentBuilder.DescriptionStrategy.Default.HYBRID,
                 mock(AgentBuilder.FallbackStrategy.class),
                 mock(AgentBuilder.RawMatcher.class),
@@ -1850,6 +1851,7 @@ public void testExecutingTransformerDoesNotRecurse() throws Exception {
                 mock(AgentBuilder.Default.NativeMethodStrategy.class),
                 initializationStrategy,
                 mock(AgentBuilder.Default.BootstrapInjectionStrategy.class),
+                AgentBuilder.LambdaInstrumentationStrategy.DISABLED,
                 AgentBuilder.DescriptionStrategy.Default.HYBRID,
                 mock(AgentBuilder.FallbackStrategy.class),
                 mock(AgentBuilder.RawMatcher.class),
@@ -1887,6 +1889,7 @@ public void testExecutingTransformerDoesNotRecurseWithModules() throws Exception
                 mock(AgentBuilder.Default.NativeMethodStrategy.class),
                 initializationStrategy,
                 mock(AgentBuilder.Default.BootstrapInjectionStrategy.class),
+                AgentBuilder.LambdaInstrumentationStrategy.DISABLED,
                 AgentBuilder.DescriptionStrategy.Default.HYBRID,
                 mock(AgentBuilder.FallbackStrategy.class),
                 mock(AgentBuilder.RawMatcher.class),

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/FixedValueTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.implementation;
 
+import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.test.utility.CallTraceable;
@@ -13,6 +14,7 @@
 import org.junit.Test;
 import org.junit.rules.MethodRule;
 
+import static net.bytebuddy.matcher.ElementMatchers.named;
 import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.assertThat;
 
@@ -120,7 +122,7 @@ public void testThisValue() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testThisValueStatic() throws Exception {
-        implement(FooBarQuxBaz.class, FixedValue.self());
+        new ByteBuddy().redefine(FooBarQuxBaz.class).method(named("bar")).intercept(FixedValue.self()).make();
     }
 
     @Test(expected = IllegalStateException.class)

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -3688,8 +3688,8 @@ protected void apply(Instrumentation instrumentation,
                             }
                         }
                     }
-                    redefinitionListener.onBatch(index, batch, types);
                     if (!transformations.isEmpty()) {
+                        redefinitionListener.onBatch(index, batch, types);
                         try {
                             doApply(transformations, instrumentation);
                         } catch (Throwable throwable) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/ResettableClassFileTransformer.java
Patch:
@@ -170,7 +170,7 @@ class WithErrors implements Reset {
             /**
              * Creates a new result with errors.
              *
-             * @param errors A map of errors occurred during a class file transformer reset.
+             * @param failures A map of errors occurred during a class file transformer reset.
              */
             protected WithErrors(Map<Class<?>, Throwable> failures) {
                 this.failures = failures;
@@ -179,7 +179,7 @@ protected WithErrors(Map<Class<?>, Throwable> failures) {
             /**
              * Creates a result of a potentially empty error mapping.
              *
-             * @param errors A map of errors that occurred during a reset.
+             * @param failures A map of errors that occurred during a reset.
              * @return An appropriate result.
              */
             public static Reset ofPotentiallyErroneous(Map<Class<?>, Throwable> failures) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassFileLocatorForJarFileTest.java
Patch:
@@ -89,7 +89,8 @@ public void testClassPath() throws Exception {
     public void testRuntimeJar() throws Exception {
         ClassFileLocator classFileLocator = ClassFileLocator.ForJarFile.ofRuntimeJar();
         try {
-            assertThat(classFileLocator.locate(Object.class.getName()).isResolved(), is(true));
+            // java.lang.Object is not contained in the rt.jar for some JVMs.
+            assertThat(classFileLocator.locate(Void.class.getName()).isResolved(), is(true));
         } finally {
             classFileLocator.close();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -3763,7 +3763,7 @@ public MethodDefinition<U> annotateMethod(Collection<? extends AnnotationDescrip
                         @Override
                         public MethodDefinition<U> annotateParameter(int index, Collection<? extends AnnotationDescription> annotations) {
                             List<ParameterDescription.Token> parameterTokens = new ArrayList<ParameterDescription.Token>(token.getParameterTokens());
-                            parameterTokens.add(index, new ParameterDescription.Token(token.getParameterTokens().get(index).getType(),
+                            parameterTokens.set(index, new ParameterDescription.Token(token.getParameterTokens().get(index).getType(),
                                     CompoundList.of(token.getParameterTokens().get(index).getAnnotations(), new ArrayList<AnnotationDescription>(annotations)),
                                     token.getParameterTokens().get(index).getName(),
                                     token.getParameterTokens().get(index).getModifiers()));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -3763,7 +3763,7 @@ public MethodDefinition<U> annotateMethod(Collection<? extends AnnotationDescrip
                         @Override
                         public MethodDefinition<U> annotateParameter(int index, Collection<? extends AnnotationDescription> annotations) {
                             List<ParameterDescription.Token> parameterTokens = new ArrayList<ParameterDescription.Token>(token.getParameterTokens());
-                            parameterTokens.add(index, new ParameterDescription.Token(token.getParameterTokens().get(index).getType(),
+                            parameterTokens.set(index, new ParameterDescription.Token(token.getParameterTokens().get(index).getType(),
                                     CompoundList.of(token.getParameterTokens().get(index).getAnnotations(), new ArrayList<AnnotationDescription>(annotations)),
                                     token.getParameterTokens().get(index).getName(),
                                     token.getParameterTokens().get(index).getModifiers()));

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -1763,6 +1763,7 @@ public void apply(MethodDescription mock) {
         ObjectPropertyAssertion.of(Advice.Dispatcher.OffsetMapping.Target.ForBoxedArgument.ReadWrite.class).apply();
         ObjectPropertyAssertion.of(Advice.Dispatcher.OffsetMapping.Target.ForSerializedObject.class).apply();
         ObjectPropertyAssertion.of(Advice.Dispatcher.OffsetMapping.Target.ForNullConstant.class).apply();
+        ObjectPropertyAssertion.of(Advice.Dispatcher.OffsetMapping.Target.ForType.class).apply();
         ObjectPropertyAssertion.of(Advice.Dispatcher.OffsetMapping.Target.ForExecutable.ForMethod.class).apply();
         ObjectPropertyAssertion.of(Advice.Dispatcher.OffsetMapping.Target.ForExecutable.ForConstructor.class).apply();
         final int[] value = new int[1];

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -5667,7 +5667,7 @@ protected void convertValue(MethodVisitor methodVisitor, MethodSizeHandler.ForAd
                         /**
                          * A skip dispatcher for a reference value.
                          */
-                        FOR_REFERENCE(Opcodes.ALOAD, Opcodes.IFNONNULL) {
+                        FOR_REFERENCE(Opcodes.ALOAD, Opcodes.IFNULL) {
                             @Override
                             protected void convertValue(MethodVisitor methodVisitor, MethodSizeHandler.ForAdvice methodSizeHandler) {
                                 /* do nothing */

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -4627,7 +4627,7 @@ protected ForReturnValue(boolean readOnly, TypeDescription targetType) {
                 @Override
                 public Target resolve(MethodDescription.InDefinedShape instrumentedMethod, Context context) {
                     if (!readOnly && !instrumentedMethod.getReturnType().asErasure().equals(targetType)) {
-                        throw new IllegalStateException("read-only return type of " + instrumentedMethod + " is not equal to " + targetType);
+                        throw new IllegalStateException("Non read-only return type of " + instrumentedMethod + " is not equal to " + targetType);
                     } else if (readOnly && !instrumentedMethod.getReturnType().asErasure().isAssignableTo(targetType)) {
                         throw new IllegalStateException("Cannot assign return type of " + instrumentedMethod + " to " + targetType);
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -4627,7 +4627,7 @@ protected ForReturnValue(boolean readOnly, TypeDescription targetType) {
                 @Override
                 public Target resolve(MethodDescription.InDefinedShape instrumentedMethod, Context context) {
                     if (!readOnly && !instrumentedMethod.getReturnType().asErasure().equals(targetType)) {
-                        throw new IllegalStateException("read-only return type of " + instrumentedMethod + " is not equal to " + targetType);
+                        throw new IllegalStateException("Non read-only return type of " + instrumentedMethod + " is not equal to " + targetType);
                     } else if (readOnly && !instrumentedMethod.getReturnType().asErasure().isAssignableTo(targetType)) {
                         throw new IllegalStateException("Cannot assign return type of " + instrumentedMethod + " to " + targetType);
                     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/LambdaFactoryTest.java
Patch:
@@ -118,7 +118,7 @@ public Method create() {
 
     public static class PseudoFactory {
 
-        private Object args[];
+        private Object[] args;
 
         public byte[] make(Object a1, String a2, Object a3, Object a4, Object a5, Object a6, boolean a7, List<?> a8, List<?> a9, Collection<?> a10) {
             args = new Object[]{a1, a2, a3, a4, a5, a6, a7, a8, a9, a10};

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AnnotationValueRenderingDispatcherTest.java
Patch:
@@ -57,7 +57,7 @@ public void testFloat() throws Exception {
         assertThat(AnnotationValue.RenderingDispatcher.JAVA_9_CAPABLE_VM.toSourceString(42f), is("42.0f"));
         assertThat(AnnotationValue.RenderingDispatcher.JAVA_9_CAPABLE_VM.toSourceString(Float.POSITIVE_INFINITY), is("1.0f/0.0f"));
         assertThat(AnnotationValue.RenderingDispatcher.JAVA_9_CAPABLE_VM.toSourceString(Float.NEGATIVE_INFINITY), is("-1.0f/0.0f"));
-        assertThat(AnnotationValue.RenderingDispatcher.JAVA_9_CAPABLE_VM.toSourceString(0f/0f), is("0.0f/0.0f"));
+        assertThat(AnnotationValue.RenderingDispatcher.JAVA_9_CAPABLE_VM.toSourceString(0f / 0f), is("0.0f/0.0f"));
     }
 
     @Test
@@ -66,7 +66,7 @@ public void testDouble() throws Exception {
         assertThat(AnnotationValue.RenderingDispatcher.JAVA_9_CAPABLE_VM.toSourceString(42d), is("42.0"));
         assertThat(AnnotationValue.RenderingDispatcher.JAVA_9_CAPABLE_VM.toSourceString(Double.POSITIVE_INFINITY), is("1.0/0.0"));
         assertThat(AnnotationValue.RenderingDispatcher.JAVA_9_CAPABLE_VM.toSourceString(Double.NEGATIVE_INFINITY), is("-1.0/0.0"));
-        assertThat(AnnotationValue.RenderingDispatcher.JAVA_9_CAPABLE_VM.toSourceString(0d/0d), is("0.0/0.0"));
+        assertThat(AnnotationValue.RenderingDispatcher.JAVA_9_CAPABLE_VM.toSourceString(0d / 0d), is("0.0/0.0"));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericOfParameterizedTypeRenderingDelegateTest.java
Patch:
@@ -66,4 +66,4 @@ public void testCurrent() throws Exception {
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(TypeDescription.Generic.OfParameterizedType.RenderingDelegate.class).apply();
     }
-}
\ No newline at end of file
+}

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/DynamicTypeDefaultTest.java
Patch:
@@ -34,7 +34,7 @@ public class DynamicTypeDefaultTest {
     @Rule
     public TestRule mockitoRule = new MockitoRule(this);
 
-    private byte[] BINARY_FIRST = new byte[]{1, 2, 3}, BINARY_SECOND = new byte[]{4, 5, 6}, BINARY_THIRD = new byte[]{7, 8, 9};
+    private static final byte[] BINARY_FIRST = new byte[]{1, 2, 3}, BINARY_SECOND = new byte[]{4, 5, 6}, BINARY_THIRD = new byte[]{7, 8, 9};
 
     @Mock
     private LoadedTypeInitializer mainLoadedTypeInitializer, auxiliaryLoadedTypeInitializer;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/AbstractDynamicTypeBuilderForInliningTest.java
Patch:
@@ -62,7 +62,7 @@ public abstract class AbstractDynamicTypeBuilderForInliningTest extends Abstract
 
     private static final String FOO = "foo", BAR = "bar";
 
-    private final int QUX = 42;
+    private static final int QUX = 42;
 
     private static final String PARAMETER_NAME_CLASS = "net.bytebuddy.test.precompiled.ParameterNames";
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/MethodCallProxyTest.java
Patch:
@@ -96,7 +96,7 @@ public void foo() {
     @SuppressWarnings("unused")
     public static class StaticMethod extends CallTraceable {
 
-        public static CallTraceable CALL_TRACEABLE = new CallTraceable();
+        public static final CallTraceable CALL_TRACEABLE = new CallTraceable();
 
         public static void foo() {
             CALL_TRACEABLE.register(FOO);

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -1386,8 +1386,8 @@ private static byte[] transform(ClassFileTransformer classFileTransformer,
                                     ProtectionDomain protectionDomain,
                                     byte[] binaryRepresentation) throws Exception {
         try {
-            return (byte[]) ClassFileTransformer.class.getDeclaredMethod("transform", Class.forName("java.lang.reflect.Module"), String.class, Class.class, ProtectionDomain.class, byte[].class)
-                    .invoke(classFileTransformer, javaModule.unwrap(), typeName, type, protectionDomain, binaryRepresentation);
+            return (byte[]) ClassFileTransformer.class.getDeclaredMethod("transform", Class.forName("java.lang.reflect.Module"), ClassLoader.class, String.class, Class.class, ProtectionDomain.class, byte[].class)
+                    .invoke(classFileTransformer, javaModule.unwrap(), classLoader, typeName, type, protectionDomain, binaryRepresentation);
         } catch (Exception ignored) {
             return classFileTransformer.transform(classLoader, typeName, type, protectionDomain, binaryRepresentation);
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderLocationStrategySimpleTest.java
Patch:
@@ -5,7 +5,7 @@
 import net.bytebuddy.utility.JavaModule;
 import org.junit.Test;
 
-import static org.hamcrest.core.Is.is;
+import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
 import static org.mockito.Mockito.mock;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderTransformerForBuildPluginTest.java
Patch:
@@ -10,8 +10,8 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.*;
 
 public class AgentBuilderTransformerForBuildPluginTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderTypeStrategyForBuildEntryPointTest.java
Patch:
@@ -13,8 +13,8 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.*;
 
 public class AgentBuilderTypeStrategyForBuildEntryPointTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceSizeConversionTest.java
Patch:
@@ -10,8 +10,8 @@
 import java.util.Collection;
 
 import static net.bytebuddy.matcher.ElementMatchers.named;
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 
 @RunWith(Parameterized.class)
 public class AdviceSizeConversionTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/build/EntryPointDefaultTest.java
Patch:
@@ -15,7 +15,7 @@
 
 import static net.bytebuddy.matcher.ElementMatchers.isDeclaredBy;
 import static net.bytebuddy.matcher.ElementMatchers.not;
-import static org.hamcrest.core.Is.is;
+import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
 import static org.mockito.Mockito.when;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassFileLocatorForClassLoaderTest.java
Patch:
@@ -62,7 +62,7 @@ public void testNonLocatable() throws Exception {
     public void testReadTypeBootstrapClassLoader() throws Exception {
         ClassFileLocator.Resolution resolution = ClassFileLocator.ForClassLoader.read(Object.class);
         assertThat(resolution.isResolved(), is(true));
-        InputStream inputStream = getClass().getClassLoader().getResourceAsStream(Object.class.getName().replace('.', '/') + ".class");
+        InputStream inputStream = Object.class.getResourceAsStream(Object.class.getSimpleName() + ".class");
         try {
             assertThat(resolution.resolve(), is(StreamDrainer.DEFAULT.drain(inputStream)));
         } finally {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassFileLocatorPackageDiscriminatingTest.java
Patch:
@@ -12,8 +12,8 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.*;
 
 public class ClassFileLocatorPackageDiscriminatingTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassFileLocatorForModuleTest.java
Patch:
@@ -88,7 +88,7 @@ public void testBootPathLegacy() throws Exception {
     public void testBootPath() throws Exception {
         ClassFileLocator classFileLocator = ClassFileLocator.ForModule.ofBootLayer();
         assertThat(classFileLocator.locate(Object.class.getName()).isResolved(), is(true));
-        assertThat(classFileLocator.locate(getClass().getName()).isResolved(), is(true));
+        assertThat(classFileLocator.locate(getClass().getName()).isResolved(), is(false));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassFileLocatorForModuleWeaklyReferencedTest.java
Patch:
@@ -99,7 +99,7 @@ public void testCreationUnnamedBoot() throws Exception {
     public void testLocateModules() throws Exception {
         ClassFileLocator classFileLocator = new ClassFileLocator.ForModule.WeaklyReferenced(JavaModule.ofType(Object.class).unwrap());
         assertThat(classFileLocator.locate(Object.class.getName()).isResolved(), is(true));
-        assertThat(classFileLocator.locate(getClass().getName()).isResolved(), is(true));
+        assertThat(classFileLocator.locate(getClass().getName()).isResolved(), is(false));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -7364,7 +7364,7 @@ public int getModifiers() {
     /**
      * A type description implementation that represents a loaded type.
      */
-    class ForLoadedType extends AbstractBase {
+    class ForLoadedType extends AbstractBase implements Serializable {
 
         /**
          * The loaded type this instance represents.

File: byte-buddy-gradle-plugin/src/main/java/net/bytebuddy/build/gradle/Initialization.java
Patch:
@@ -27,9 +27,9 @@ public static Initialization makeDefault() {
     }
 
     /**
-     * Sets the default entry point or any constant name of {@link EntryPoint.Default}.
+     * Sets the default entry point or any constant name of {@link net.bytebuddy.build.EntryPoint.Default}.
      *
-     * @param entryPoint The default entry point or any constant name of {@link EntryPoint.Default}.
+     * @param entryPoint The default entry point or any constant name of {@link net.bytebuddy.build.EntryPoint.Default}.
      */
     public void setEntryPoint(String entryPoint) {
         this.entryPoint = entryPoint;

File: byte-buddy-gradle-plugin/src/test/java/net/bytebuddy/build/gradle/ByteBuddyPluginTest.java
Patch:
@@ -100,6 +100,7 @@ public void testIncrementalCompilationFails() throws IOException {
                 .forwardOutput()
                 .buildAndFail();
         assertThat(result.getOutput(), containsString("Transformations aren't supported when incremental compilation is enabled."));
+        throw new AssertionError("Property!");
     }
 
     private void createSampleBuildFiles() throws IOException {

File: byte-buddy-gradle-plugin/src/test/java/net/bytebuddy/build/gradle/TransformationActionTest.java
Patch:
@@ -86,7 +86,7 @@ public void setUp() throws Exception {
         when(byteBuddyExtension.getTransformations()).thenReturn(Collections.singletonList(transformation));
         when(byteBuddyExtension.getInitialization()).thenReturn(initialization);
         when(parent.getDestinationDir()).thenReturn(target);
-        when(transformation.getClassPath(any(File.class), any(Iterable.class))).thenReturn(Collections.<File>emptySet());
+        when(transformation.getClassPath(any(File.class), any(Iterable.class))).thenReturn((Iterable) Collections.emptySet());
         when(parent.getClasspath()).thenReturn(fileCollection);
         when(fileCollection.iterator()).then(new Answer<Iterator<File>>() {
             @Override

File: byte-buddy-gradle-plugin/src/test/java/net/bytebuddy/build/gradle/TransformationActionTest.java
Patch:
@@ -86,7 +86,7 @@ public void setUp() throws Exception {
         when(byteBuddyExtension.getTransformations()).thenReturn(Collections.singletonList(transformation));
         when(byteBuddyExtension.getInitialization()).thenReturn(initialization);
         when(parent.getDestinationDir()).thenReturn(target);
-        when(transformation.getClassPath(any(File.class), any(Iterable.class))).thenReturn(Collections.emptySet());
+        when(transformation.getClassPath(any(File.class), any(Iterable.class))).thenReturn(Collections.<File>emptySet());
         when(parent.getClasspath()).thenReturn(fileCollection);
         when(fileCollection.iterator()).then(new Answer<Iterator<File>>() {
             @Override

File: byte-buddy-gradle-plugin/src/test/java/net/bytebuddy/build/gradle/ByteBuddyPluginTest.java
Patch:
@@ -93,7 +93,7 @@ public void testGradlePlugin() throws IOException {
     @IntegrationRule.Enforce
     public void testIncrementalCompilationFails() throws IOException {
         createSampleBuildFiles();
-        append("compileJava.options.incremental = true", new File(temporaryFolder.getRoot(), "build.gradle"));
+        append("compileJava.options.incremental = true\n", new File(temporaryFolder.getRoot(), "build.gradle"));
         BuildResult result = GradleRunner.create()
                 .withPluginClasspath()
                 .withProjectDir(temporaryFolder.getRoot()).withArguments("classes")

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/AbstractUserConfiguration.java
Patch:
@@ -1,8 +1,11 @@
 package net.bytebuddy.build.maven;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+
 /**
  * An abstract base class for a user configuration implying a Maven coordinate.
  */
+@SuppressFBWarnings(value = "UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD", justification = "Written to by Maven")
 public class AbstractUserConfiguration {
 
     /**

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/ByteBuddyMojo.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.build.maven;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.build.EntryPoint;
 import net.bytebuddy.build.Plugin;
@@ -171,6 +172,7 @@ public void execute() throws MojoExecutionException, MojoFailureException {
      * @throws MojoFailureException   If the plugin application raises an error.
      * @throws IOException            If an I/O exception occurs.
      */
+    @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Applies Maven exception wrapper")
     private void processOutputDirectory(File root, List<? extends String> classPath) throws MojoExecutionException, MojoFailureException, IOException {
         if (!root.isDirectory()) {
             throw new MojoExecutionException("Target location does not exist or is no directory: " + root);

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/Initialization.java
Patch:
@@ -1,11 +1,13 @@
 package net.bytebuddy.build.maven;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.build.EntryPoint;
 import org.apache.maven.plugin.MojoExecutionException;
 
 /**
  * Defines a configuration for a Maven build's type transformation.
  */
+@SuppressFBWarnings(value = "UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD", justification = "Written to by Maven")
 public class Initialization extends AbstractUserConfiguration {
 
     /**
@@ -34,6 +36,7 @@ public static Initialization makeDefault() {
      * @return The resolved entry point.
      * @throws MojoExecutionException If the entry point cannot be created.
      */
+    @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Applies Maven exception wrapper")
     public EntryPoint getEntryPoint(ClassLoaderResolver classLoaderResolver, String groupId, String artifactId, String version) throws MojoExecutionException {
         if (entryPoint == null || entryPoint.isEmpty()) {
             throw new MojoExecutionException("Entry point name is not defined");

File: byte-buddy-maven-plugin/src/main/java/net/bytebuddy/build/maven/Transformation.java
Patch:
@@ -1,10 +1,12 @@
 package net.bytebuddy.build.maven;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import org.apache.maven.plugin.MojoExecutionException;
 
 /**
  * A transformation specification to apply during the plugin's execution.
  */
+@SuppressFBWarnings(value = "UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD", justification = "Written to by Maven")
 public class Transformation extends AbstractUserConfiguration {
 
     /**

File: byte-buddy-maven-plugin/src/test/java/net/bytebuddy/build/maven/ClassLoaderResolverTest.java
Patch:
@@ -109,4 +109,4 @@ public void testClose() throws Exception {
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(ClassLoaderResolver.class).applyBasic();
     }
-}
\ No newline at end of file
+}

File: byte-buddy-maven-plugin/src/test/java/net/bytebuddy/build/maven/InitializationTest.java
Patch:
@@ -130,4 +130,4 @@ public DynamicType.Builder<?> transform(TypeDescription typeDescription, ByteBud
             throw new AssertionError();
         }
     }
-}
\ No newline at end of file
+}

File: byte-buddy-maven-plugin/src/test/java/net/bytebuddy/build/maven/MavenCoordinateTest.java
Patch:
@@ -4,8 +4,8 @@
 import org.eclipse.aether.artifact.Artifact;
 import org.junit.Test;
 
-import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class MavenCoordinateTest {
 
@@ -24,4 +24,4 @@ public void testAsArtifact() throws Exception {
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(MavenCoordinate.class).apply();
     }
-}
\ No newline at end of file
+}

File: byte-buddy-dep/src/main/java/net/bytebuddy/build/EntryPoint.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.build;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
@@ -39,6 +40,7 @@ DynamicType.Builder<?> transform(TypeDescription typeDescription,
     /**
      * Default implementations for an entry point.
      */
+    @SuppressFBWarnings(value = "SE_BAD_FIELD", justification = "An enumeration does not serialize fields")
     enum Default implements EntryPoint {
 
         /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -1193,14 +1193,15 @@ public void testDisabledBootstrapInjection() throws Exception {
     @SuppressWarnings("unchecked")
     public void testExecutingTransformerHandlesNullValue() throws Exception {
         assertThat(new AgentBuilder.Default.ExecutingTransformer(byteBuddy,
+                listener,
                 poolStrategy,
                 typeStrategy,
                 locationStrategy,
-                listener,
                 mock(AgentBuilder.Default.NativeMethodStrategy.class),
                 initializationStrategy,
                 mock(AgentBuilder.Default.BootstrapInjectionStrategy.class),
                 AgentBuilder.DescriptionStrategy.Default.HYBRID,
+                mock(AgentBuilder.FallbackStrategy.class),
                 mock(AgentBuilder.RawMatcher.class),
                 mock(AgentBuilder.Default.Transformation.class))
                 .transform(mock(ClassLoader.class),

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultComponentPoolStrategyTest.java
Patch:
@@ -12,7 +12,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-public class TypePoolDefaultComponentTypeLocatorTest {
+public class TypePoolDefaultComponentPoolStrategyTest {
 
     private static final String FOO = "foo", BAR = "bar", BAR_DESCRIPTOR = "L" + BAR + ";", QUX = "qux", BAZ = "baz";
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -758,7 +758,7 @@ public Class<? extends Annotation> annotationType() {
         }
     }
 
-    public static abstract class SumExample {
+    public abstract static class SumExample {
 
         public abstract int calculate();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/AbstractMethodListTest.java
Patch:
@@ -24,7 +24,7 @@ public void testAsDefined() throws Exception {
         assertThat(asList(getFirst()).asDefined(), is(Collections.singletonList(asElement(getFirst()).asDefined())));
     }
 
-    public static abstract class Foo {
+    public abstract static class Foo {
 
         abstract void foo();
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/GenericSignatureResolutionTest.java
Patch:
@@ -197,7 +197,7 @@ public void testInterfaceType() throws Exception {
         assertThat(createdType.getInterfaces(), is(originalType.getInterfaces()));
     }
 
-    public static abstract class GenericType<T extends ArrayList<T> & Callable<T>,
+    public abstract static class GenericType<T extends ArrayList<T> & Callable<T>,
             S extends Callable<?>,
             U extends Callable<? extends Callable<U>>,
             V extends ArrayList<? super ArrayList<V>>,
@@ -226,11 +226,11 @@ public static class TypeVariableClassBound<T extends ArrayList<T>> {
         /* empty */
     }
 
-    public static abstract class TypeVariableInterfaceBound<T extends Callable<T>> {
+    public abstract static class TypeVariableInterfaceBound<T extends Callable<T>> {
         /* empty */
     }
 
-    public static abstract class TypeVariableClassAndInterfaceBound<T extends ArrayList<T> & Callable<T>> {
+    public abstract static class TypeVariableClassAndInterfaceBound<T extends ArrayList<T> & Callable<T>> {
         /* empty */
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassFileLocatorForClassLoaderTest.java
Patch:
@@ -122,7 +122,7 @@ private static class Foo {
         /* empty */
     }
 
-    private static abstract class ClosableClassLoader extends ClassLoader implements Closeable {
+    private abstract static class ClosableClassLoader extends ClassLoader implements Closeable {
         /* empty */
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassFileLocatorForClassLoaderWeaklyReferencedTest.java
Patch:
@@ -85,7 +85,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(ClassFileLocator.ForClassLoader.WeaklyReferenced.class).apply();
     }
 
-    private static abstract class ClosableClassLoader extends ClassLoader implements Closeable {
+    private abstract static class ClosableClassLoader extends ClassLoader implements Closeable {
         /* empty */
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationSuperCallTest.java
Patch:
@@ -144,7 +144,7 @@ public static String bar(@SuperCall Callable<String> callable) throws Exception
         }
     }
 
-    public static abstract class Qux {
+    public abstract static class Qux {
 
         public abstract String bar();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationSuperTest.java
Patch:
@@ -132,7 +132,7 @@ public static String baz(@Super(strategy = Super.Instantiation.UNSAFE) Foo foo)
         }
     }
 
-    public static abstract class FooBarQuxBaz implements Qux {
+    public abstract static class FooBarQuxBaz implements Qux {
 
         @Override
         public abstract Object qux();

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -675,7 +675,7 @@ public S load() throws ClassNotFoundException {
                 for (Enum<?> anElement : element) {
                     enumerationDescription[index++] = new EnumerationDescription.ForLoadedEnumeration(anElement);
                 }
-                return AnnotationValue.ForComplexArray.of(new TypeDescription.ForLoadedType(type.getComponentType()), enumerationDescription);
+                return AnnotationValue.ForComplexArray.<Enum>of(new TypeDescription.ForLoadedType(type.getComponentType()), enumerationDescription);
             } else if (Annotation.class.isAssignableFrom(type)) {
                 return AnnotationValue.ForAnnotation.<Annotation>of(new TypeDescription.ForLoadedType(type), asValue((Annotation) value));
             } else if (Annotation[].class.isAssignableFrom(type)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -667,7 +667,7 @@ public S load() throws ClassNotFoundException {
         public static AnnotationValue<?, ?> asValue(Object value, Class<?> type) {
             // Because enums can implement annotation interfaces, the enum property needs to be checked first.
             if (Enum.class.isAssignableFrom(type)) {
-                return AnnotationValue.ForEnumeration.<Enum>of(new EnumerationDescription.ForLoadedEnumeration((Enum<?>) value));
+                return AnnotationValue.ForEnumeration.<Enum>of(new EnumerationDescription.ForLoadedEnumeration((Enum) value));
             } else if (Enum[].class.isAssignableFrom(type)) {
                 Enum<?>[] element = (Enum<?>[]) value;
                 EnumerationDescription[] enumerationDescription = new EnumerationDescription[element.length];

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1488,6 +1488,7 @@ interface ImplementationDefinition<U> {
                  *
                  * @param value The value to be defined as a default value.
                  * @param type  The type of the annotation property.
+                 * @param <W>   The type of the annotation property.
                  * @return A builder where the previously defined or matched method is implemented to return an annotation default value.
                  */
                 <W> MethodDefinition.ReceiverTypeDefinition<U> defaultValue(W value, Class<? extends W> type);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationAppender.java
Patch:
@@ -305,10 +305,9 @@ private static void handle(AnnotationVisitor annotationVisitor, AnnotationDescri
          * @param annotationVisitor The annotation visitor the write process is to be applied on.
          * @param valueType         The type of the annotation value.
          * @param name              The name of the annotation type.
-         * @param annotationValue             The annotation's value.
+         * @param value             The annotation's value.
          */
         public static void apply(AnnotationVisitor annotationVisitor, TypeDescription valueType, String name, Object value) {
-            // TODO: Improve, switch?
             if (valueType.isAnnotation()) {
                 handle(annotationVisitor.visitAnnotation(name, valueType.getDescriptor()), (AnnotationDescription) value, AnnotationValueFilter.Default.APPEND_DEFAULTS);
             } else if (valueType.isEnum()) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AnnotationDescriptionAbstractPreparedExceptionTest.java
Patch:
@@ -21,7 +21,7 @@ public Annotation load() throws ClassNotFoundException {
         }
 
         @Override
-        public AnnotationValue<?, ?> getValue(MethodDescription.InDefinedShape methodDescription) {
+        public AnnotationValue<?, ?> getValue(MethodDescription.InDefinedShape property) {
             throw new UnsupportedOperationException();
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -8051,7 +8051,7 @@ public Object resolve(MethodDescription.InDefinedShape instrumentedMethod,
                                   ParameterDescription.InDefinedShape target,
                                   AnnotationDescription.Loadable<T> annotation,
                                   boolean initialized) {
-                return annotation.getValue(annotationProperty);
+                return annotation.getValue(annotationProperty).resolve();
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/Transformer.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.dynamic;
 
+import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.annotation.AnnotationList;
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.method.MethodDescription;
@@ -431,7 +432,7 @@ public int getModifiers() {
             }
 
             @Override
-            public Object getDefaultValue() {
+            public AnnotationDescription.AnnotationValue<?, ?> getDefaultValue() {
                 return token.getDefaultValue();
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationAppender.java
Patch:
@@ -293,7 +293,7 @@ public Default(Target target) {
         private static void handle(AnnotationVisitor annotationVisitor, AnnotationDescription annotation, AnnotationValueFilter annotationValueFilter) {
             for (MethodDescription.InDefinedShape methodDescription : annotation.getAnnotationType().getDeclaredMethods()) {
                 if (annotationValueFilter.isRelevant(annotation, methodDescription)) {
-                    apply(annotationVisitor, methodDescription.getReturnType().asErasure(), methodDescription.getName(), annotation.getValue(methodDescription));
+                    apply(annotationVisitor, methodDescription.getReturnType().asErasure(), methodDescription.getName(), annotation.getValue(methodDescription).resolve());
                 }
             }
             annotationVisitor.visitEnd();
@@ -305,9 +305,10 @@ private static void handle(AnnotationVisitor annotationVisitor, AnnotationDescri
          * @param annotationVisitor The annotation visitor the write process is to be applied on.
          * @param valueType         The type of the annotation value.
          * @param name              The name of the annotation type.
-         * @param value             The annotation's value.
+         * @param annotationValue             The annotation's value.
          */
         public static void apply(AnnotationVisitor annotationVisitor, TypeDescription valueType, String name, Object value) {
+            // TODO: Improve, switch?
             if (valueType.isAnnotation()) {
                 handle(annotationVisitor.visitAnnotation(name, valueType.getDescriptor()), (AnnotationDescription) value, AnnotationValueFilter.Default.APPEND_DEFAULTS);
             } else if (valueType.isEnum()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Default.java
Patch:
@@ -86,7 +86,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            TypeDescription proxyType = TypeLocator.ForType.of(annotation.getValue(PROXY_TYPE, TypeDescription.class)).resolve(target.getType());
+            TypeDescription proxyType = TypeLocator.ForType.of(annotation.getValue(PROXY_TYPE).resolve(TypeDescription.class)).resolve(target.getType());
             if (!proxyType.isInterface()) {
                 throw new IllegalStateException(target + " uses the @Default annotation on an invalid type");
             }
@@ -95,7 +95,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             } else {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(new TypeProxy.ForDefaultMethod(proxyType,
                         implementationTarget,
-                        annotation.getValue(SERIALIZABLE_PROXY, Boolean.class)));
+                        annotation.getValue(SERIALIZABLE_PROXY).resolve(Boolean.class)));
             }
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultCall.java
Patch:
@@ -101,13 +101,13 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             } else if (source.isConstructor()) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             }
-            TypeDescription typeDescription = annotation.getValue(TARGET_TYPE, TypeDescription.class);
+            TypeDescription typeDescription = annotation.getValue(TARGET_TYPE).resolve(TypeDescription.class);
             Implementation.SpecialMethodInvocation specialMethodInvocation = (typeDescription.represents(void.class)
                     ? DefaultMethodLocator.Implicit.INSTANCE
                     : new DefaultMethodLocator.Explicit(typeDescription)).resolve(implementationTarget, source);
             return specialMethodInvocation.isValid()
                     ? new MethodDelegationBinder.ParameterBinding.Anonymous(new MethodCallProxy
-                    .AssignableSignatureCall(specialMethodInvocation, annotation.getValue(SERIALIZABLE_PROXY, Boolean.class)))
+                    .AssignableSignatureCall(specialMethodInvocation, annotation.getValue(SERIALIZABLE_PROXY).resolve(Boolean.class)))
                     : MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -259,12 +259,12 @@ public Class<FieldProxy> getHandledType() {
 
         @Override
         protected String fieldName(AnnotationDescription.Loadable<FieldProxy> annotation) {
-            return annotation.getValue(FIELD_NAME, String.class);
+            return annotation.getValue(FIELD_NAME).resolve(String.class);
         }
 
         @Override
         protected TypeDescription declaringType(AnnotationDescription.Loadable<FieldProxy> annotation) {
-            return annotation.getValue(DEFINING_TYPE, TypeDescription.class);
+            return annotation.getValue(DEFINING_TYPE).resolve(TypeDescription.class);
         }
 
         @Override
@@ -280,7 +280,7 @@ protected MethodDelegationBinder.ParameterBinding<?> bind(FieldDescription field
                         implementationTarget.getInstrumentedType(),
                         fieldResolver,
                         assigner,
-                        annotation.getValue(SERIALIZABLE_PROXY, Boolean.class)));
+                        annotation.getValue(SERIALIZABLE_PROXY).resolve(Boolean.class)));
             } else {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldValue.java
Patch:
@@ -147,12 +147,12 @@ protected MethodDelegationBinder.ParameterBinding<?> bind(FieldDescription field
 
             @Override
             protected String fieldName(AnnotationDescription.Loadable<FieldValue> annotation) {
-                return annotation.getValue(FIELD_NAME, String.class);
+                return annotation.getValue(FIELD_NAME).resolve(String.class);
             }
 
             @Override
             protected TypeDescription declaringType(AnnotationDescription.Loadable<FieldValue> annotation) {
-                return annotation.getValue(DEFINING_TYPE, TypeDescription.class);
+                return annotation.getValue(DEFINING_TYPE).resolve(TypeDescription.class);
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -189,8 +189,8 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                 throw new IllegalStateException("Illegal use of @Morph for " + target + " which was installed for " + forwardingMethod.getDeclaringType());
             }
             Implementation.SpecialMethodInvocation specialMethodInvocation;
-            TypeDescription typeDescription = annotation.getValue(DEFAULT_TARGET, TypeDescription.class);
-            if (typeDescription.represents(void.class) && !annotation.getValue(DEFAULT_METHOD, Boolean.class)) {
+            TypeDescription typeDescription = annotation.getValue(DEFAULT_TARGET).resolve(TypeDescription.class);
+            if (typeDescription.represents(void.class) && !annotation.getValue(DEFAULT_METHOD).resolve(Boolean.class)) {
                 specialMethodInvocation = implementationTarget.invokeSuper(source.asSignatureToken());
             } else {
                 specialMethodInvocation = (typeDescription.represents(void.class)
@@ -202,7 +202,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                     implementationTarget.getInstrumentedType(),
                     specialMethodInvocation,
                     assigner,
-                    annotation.getValue(SERIALIZABLE_PROXY, Boolean.class)))
+                    annotation.getValue(SERIALIZABLE_PROXY).resolve(Boolean.class)))
                     : MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AnnotationDescriptionAbstractPreparedExceptionTest.java
Patch:
@@ -21,7 +21,7 @@ public Annotation load() throws ClassNotFoundException {
         }
 
         @Override
-        public Object getValue(MethodDescription.InDefinedShape methodDescription) {
+        public AnnotationValue<?, ?> getValue(MethodDescription.InDefinedShape methodDescription) {
             throw new UnsupportedOperationException();
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AnnotationDescriptionForLoadedAnnotationTest.java
Patch:
@@ -24,16 +24,15 @@ protected AnnotationDescription describe(Annotation annotation, Class<?> declari
     @Test
     public void testAnnotationNonVisible() throws Exception {
         assertThat(describe(Carrier.class.getAnnotation(PrivateAnnotation.class), Carrier.class)
-                .getValue(new MethodDescription.ForLoadedMethod(PrivateAnnotation.class.getDeclaredMethod("value")),
-                        String.class), is(FOO));
+                .getValue(new MethodDescription.ForLoadedMethod(PrivateAnnotation.class.getDeclaredMethod("value"))).resolve(String.class), is(FOO));
     }
 
     @Test
     public void testAnnotationNonVisibleAccessible() throws Exception {
         Method method = PrivateAnnotation.class.getDeclaredMethod("value");
         method.setAccessible(true);
         assertThat(describe(Carrier.class.getAnnotation(PrivateAnnotation.class), Carrier.class)
-                .getValue(new MethodDescription.ForLoadedMethod(method), String.class), is(FOO));
+                .getValue(new MethodDescription.ForLoadedMethod(method)).resolve(String.class), is(FOO));
     }
 
     @Test(expected = IllegalStateException.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionTokenTest.java
Patch:
@@ -44,7 +44,7 @@ public class MethodDescriptionTokenTest {
     private AnnotationDescription annotation;
 
     @Mock
-    private Object defaultValue;
+    private AnnotationDescription.AnnotationValue<?, ?> defaultValue;
 
     @Mock
     private TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor;
@@ -64,6 +64,7 @@ public void setUp() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("unchecked")
     public void testProperties() throws Exception {
         MethodDescription.Token token = new MethodDescription.Token(FOO,
                 MODIFIERS,
@@ -81,7 +82,7 @@ public void testProperties() throws Exception {
         assertThat(token.getParameterTokens(), is(Collections.singletonList(parameterToken)));
         assertThat(token.getExceptionTypes(), is(Collections.singletonList(exceptionType)));
         assertThat(token.getAnnotations(), is(Collections.singletonList(annotation)));
-        assertThat(token.getDefaultValue(), is(defaultValue));
+        assertThat(token.getDefaultValue(), is((AnnotationDescription.AnnotationValue) defaultValue));
         assertThat(token.getReceiverType(), is(receiverType));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeDefaultTest.java
Patch:
@@ -1179,7 +1179,7 @@ public void testMethodIllegalDefaultValue() throws Exception {
                         Collections.<ParameterDescription.Token>emptyList(),
                         Collections.<TypeDescription.Generic>emptyList(),
                         Collections.<AnnotationDescription>emptyList(),
-                        FOO,
+                        new AnnotationDescription.AnnotationValue.Trivial<String>(FOO),
                         TypeDescription.Generic.UNDEFINED))
                 .validated();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodRegistryHandlerTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.dynamic.scaffold;
 
+import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.attribute.MethodAttributeAppender;
@@ -29,7 +30,7 @@ public class MethodRegistryHandlerTest {
     private Implementation implementation;
 
     @Mock
-    private Object annotationValue;
+    private AnnotationDescription.AnnotationValue<?, ?> annotationValue;
 
     @Mock
     private Implementation.Target implementationTarget;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultTest.java
Patch:
@@ -7,7 +7,6 @@
 import net.bytebuddy.description.field.FieldList;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.MethodList;
-import net.bytebuddy.description.modifier.ModifierConstributorObjectPropertiesTest;
 import net.bytebuddy.description.modifier.Ownership;
 import net.bytebuddy.description.modifier.TypeManifestation;
 import net.bytebuddy.description.modifier.Visibility;
@@ -241,7 +240,7 @@ public void testAnnotationDefaultValueOnClassAssertion() throws Exception {
                 .subclass(Object.class)
                 .merge(TypeManifestation.ABSTRACT)
                 .defineMethod(FOO, String.class)
-                .defaultValue(BAR)
+                .defaultValue(BAR, String.class)
                 .make();
     }
 
@@ -250,7 +249,7 @@ public void testAnnotationDefaultValueOnInterfaceClassAssertion() throws Excepti
         new ByteBuddy()
                 .makeInterface()
                 .defineMethod(FOO, String.class)
-                .defaultValue(BAR)
+                .defaultValue(BAR, String.class)
                 .make();
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategyDefaultTest.java
Patch:
@@ -57,7 +57,7 @@ public class ConstructorStrategyDefaultTest {
     private MethodDescription.Token token;
 
     @Mock
-    private Object defaultValue;
+    private AnnotationDescription.AnnotationValue<?, ?> defaultValue;
 
     private MethodDescription.Token stripped;
 
@@ -80,7 +80,7 @@ public void setUp() throws Exception {
         when(token.getParameterTokens()).thenReturn(new ByteCodeElement.Token.TokenList<ParameterDescription.Token>());
         when(token.getExceptionTypes()).thenReturn(new TypeList.Generic.Empty());
         when(token.getAnnotations()).thenReturn(new AnnotationList.Empty());
-        when(token.getDefaultValue()).thenReturn(defaultValue);
+        when(token.getDefaultValue()).thenReturn((AnnotationDescription.AnnotationValue) defaultValue);
         when(token.getReceiverType()).thenReturn(typeDescription);
         stripped = new MethodDescription.Token(FOO,
                 MODIFIERS,

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultEnumerationDescriptionTest.java
Patch:
@@ -30,7 +30,7 @@ protected EnumerationDescription describe(Enum<?> enumeration,
         TypeDescription typeDescription = typePool.describe(carrierType.getName()).resolve();
         for (AnnotationDescription annotationDescription : typeDescription.getDeclaredAnnotations()) {
             if (annotationDescription.getAnnotationType().equals(annotationDescription.getAnnotationType())) {
-                return annotationDescription.getValue(annotationMethod, EnumerationDescription.class);
+                return annotationDescription.getValue(annotationMethod).resolve(EnumerationDescription.class);
             }
         }
         throw new AssertionError();

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AbstractAnnotationDescriptionTest.java
Patch:
@@ -679,7 +679,7 @@ private static class OtherEnumerationCarrier {
 
     @Retention(RetentionPolicy.RUNTIME)
     @Target(ElementType.TYPE)
-    private @interface ExplicitTarget {
+    protected @interface ExplicitTarget {
 
         @ExplicitTarget
         class Carrier {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AnnotationDescriptionForLoadedAnnotationTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.lang.annotation.Annotation;
@@ -45,6 +46,7 @@ public void testInoperational() throws Exception {
     }
 
     @Test(expected = IllegalArgumentException.class)
+    @Ignore("Rewrite test to consider different class loader.")
     public void testLoadAnnotationWrongClassLoader() throws Exception {
         describe(Carrier.class.getAnnotation(PrivateAnnotation.class), Carrier.class).prepare(PrivateAnnotation.class).load(ClassLoadingStrategy.BOOTSTRAP_LOADER);
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -544,7 +544,9 @@ public static ClassFileLocator ofBootLayer() {
          * @return An appropriate class file locator.
          */
         public static ClassFileLocator of(JavaModule module) {
-            return new ForModule(module);
+            return module.isNamed()
+                    ? new ForModule(module)
+                    : ForClassLoader.of(module.getClassLoader());
         }
 
         @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassFileLocatorForJarFileTest.java
Patch:
@@ -85,7 +85,7 @@ public void testClassPath() throws Exception {
     }
 
     @Test
-    @JavaVersionRule.Enforce(value = 8, direction = JavaVersionRule.Sort.AT_MOST)
+    @JavaVersionRule.Enforce(value = 8, sort = JavaVersionRule.Sort.AT_MOST)
     public void testRuntimeJar() throws Exception {
         ClassFileLocator classFileLocator = ClassFileLocator.ForJarFile.ofRuntimeJar();
         try {

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/JavaVersionRule.java
Patch:
@@ -27,7 +27,7 @@ public JavaVersionRule() {
     public Statement apply(Statement base, FrameworkMethod method, Object target) {
         Enforce enforce = method.getAnnotation(Enforce.class);
         if (enforce != null) {
-            if (!enforce.direction().check(currentVersion, ClassFileVersion.ofJavaVersion(enforce.value()))) {
+            if (!enforce.sort().check(currentVersion, ClassFileVersion.ofJavaVersion(enforce.value()))) {
                 return new NoOpStatement(enforce.value());
             } else if (!hotSpot) {
                 for (int javaVersion : enforce.hotSpot()) {
@@ -46,7 +46,7 @@ public Statement apply(Statement base, FrameworkMethod method, Object target) {
 
         int value();
 
-        Sort direction() default Sort.AT_LEAST;
+        Sort sort() default Sort.AT_LEAST;
 
         int[] hotSpot() default {};
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -319,7 +319,7 @@ public static ClassFileLocator of(ClassLoader classLoader) {
         public static Resolution read(Class<?> type) {
             try {
                 JavaModule module = JavaModule.ofType(type);
-                if (module == null || !module.isNamed()) {
+                if (module != null && module.isNamed()) {
                     return ForModule.locate(module, TypeDescription.ForLoadedType.getName(type));
                 } else {
                     ClassLoader classLoader = type.getClassLoader();

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/JavaVersionRule.java
Patch:
@@ -91,7 +91,7 @@ protected boolean check(ClassFileVersion current, ClassFileVersion enforced) {
         AT_MOST {
             @Override
             protected boolean check(ClassFileVersion current, ClassFileVersion enforced) {
-                return current.isAtLeast(enforced);
+                return current.isLessThan(enforced) || current.equals(enforced);
             }
         };
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/TransformerForFieldTest.java
Patch:
@@ -6,7 +6,6 @@
 import net.bytebuddy.description.modifier.ModifierContributor;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.matcher.ElementMatchers;
 import net.bytebuddy.test.utility.MockitoRule;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Before;
@@ -18,6 +17,7 @@
 import java.util.Collections;
 
 import static net.bytebuddy.matcher.ElementMatchers.named;
+import static net.bytebuddy.matcher.ElementMatchers.none;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Matchers.any;
@@ -60,7 +60,7 @@ public class TransformerForFieldTest {
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
         when(fieldType.accept(any(TypeDescription.Generic.Visitor.class))).thenReturn(fieldType);
-        when(fieldDescription.asToken(ElementMatchers.is(instrumentedType))).thenReturn(fieldToken);
+        when(fieldDescription.asToken(none())).thenReturn(fieldToken);
         when(fieldDescription.getDeclaringType()).thenReturn(declaringType);
         when(fieldDescription.asDefined()).thenReturn(definedField);
         when(fieldToken.getName()).thenReturn(FOO);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/TransformerForMethodTest.java
Patch:
@@ -11,7 +11,6 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.description.type.TypeVariableToken;
-import net.bytebuddy.matcher.ElementMatchers;
 import net.bytebuddy.test.utility.MockitoRule;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Before;
@@ -23,6 +22,7 @@
 import java.util.Collections;
 
 import static net.bytebuddy.matcher.ElementMatchers.named;
+import static net.bytebuddy.matcher.ElementMatchers.none;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Matchers.any;
@@ -77,7 +77,7 @@ public void setUp() throws Exception {
         when(typeVariableBound.getSymbol()).thenReturn(QUX);
         when(typeVariableBound.getSort()).thenReturn(TypeDefinition.Sort.VARIABLE);
         when(typeVariableBound.asGenericType()).thenReturn(typeVariableBound);
-        when(methodDescription.asToken(ElementMatchers.is(instrumentedType))).thenReturn(methodToken);
+        when(methodDescription.asToken(none())).thenReturn(methodToken);
         when(methodDescription.getDeclaringType()).thenReturn(declaringType);
         when(methodDescription.asDefined()).thenReturn(definedMethod);
         when(methodToken.getName()).thenReturn(FOO);

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -649,7 +649,7 @@ private static boolean isAnnotationType(TypeDescription annotationType, Annotati
         public TypeVariableSource getEnclosingSource() {
             return isStatic()
                     ? TypeVariableSource.UNDEFINED
-                    : getDeclaringType();
+                    : getDeclaringType().asErasure();
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDefinition.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.ModifierReviewable;
 import net.bytebuddy.description.NamedElement;
-import net.bytebuddy.description.TypeVariableSource;
 import net.bytebuddy.description.field.FieldList;
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.implementation.bytecode.StackSize;
@@ -14,7 +13,7 @@
 /**
  * Implementations define a type, either as a {@link TypeDescription} or as a {@link TypeDescription.Generic}.
  */
-public interface TypeDefinition extends NamedElement, TypeVariableSource, ModifierReviewable.ForTypeDefinition, Iterable<TypeDefinition> {
+public interface TypeDefinition extends NamedElement, ModifierReviewable.ForTypeDefinition, Iterable<TypeDefinition> {
 
     /**
      * Returns this type definition as a generic type.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -605,7 +605,7 @@ public Generic getUpperBounds() {
                     }
 
                     @Override
-                    public TypeVariableSource getVariableSource() {
+                    public TypeVariableSource getTypeVariableSource() {
                         return typeVariableSource;
                     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericOfTypeVariableSymbolicTest.java
Patch:
@@ -13,7 +13,7 @@
 import static org.hamcrest.CoreMatchers.*;
 import static org.junit.Assert.assertThat;
 
-public class TypeDescriptionGenericOfTypeVariableSymbolic {
+public class TypeDescriptionGenericOfTypeVariableSymbolicTest {
 
     private static final String FOO = "foo", BAR = "bar";
 
@@ -76,7 +76,7 @@ public void testEquals() throws Exception {
     }
 
     @Test
-    public void testAnnotaitions() throws Exception {
+    public void testAnnotations() throws Exception {
         assertThat(typeVariable.getDeclaredAnnotations().size(), is(1));
         assertThat(typeVariable.getDeclaredAnnotations().contains(annotationDescription), is(true));
     }
@@ -128,7 +128,7 @@ public void testParametersThrowsException() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testVariableSourceThrowsException() throws Exception {
-        typeVariable.getVariableSource();
+        typeVariable.getTypeVariableSource();
     }
 
     @Test(expected = IllegalStateException.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorSubstitutorForDetachmentTest.java
Patch:
@@ -43,7 +43,7 @@ public void testDetachment() throws Exception {
     public void testDetachedNoSource() throws Exception {
         TypeDescription.Generic original = TypeDefinition.Sort.describe(Foo.Inner.class.getDeclaredField(FOO).getGenericType());
         TypeDescription.Generic detached = original.accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(ElementMatchers.is(Foo.Inner.class)));
-        detached.getTypeArguments().get(0).getVariableSource();
+        detached.getTypeArguments().get(0).getTypeVariableSource();
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorTypeVariableErasingTest.java
Patch:
@@ -90,12 +90,12 @@ public void testTypeVariableOnMethod() throws Exception {
         MethodDescription.InDefinedShape typeVariableSource = mock(MethodDescription.InDefinedShape.AbstractBase.class);
         when(typeVariableSource.accept(any(TypeVariableSource.Visitor.class))).thenCallRealMethod();
         when(typeVariableSource.asDefined()).thenCallRealMethod();
-        when(typeDescription.getVariableSource()).thenReturn(typeVariableSource);
+        when(typeDescription.getTypeVariableSource()).thenReturn(typeVariableSource);
         when(typeDescription.getSymbol()).thenReturn(FOO);
         TypeDescription.Generic typeVariable = TypeDescription.Generic.Visitor.TypeVariableErasing.INSTANCE.onTypeVariable(typeDescription);
         assertThat(typeVariable.getSymbol(), is(FOO));
         assertThat(typeVariable.getDeclaredAnnotations(), is(Collections.singletonList(annotationDescription)));
-        assertThat(typeVariable.getVariableSource(), is((TypeVariableSource) typeVariableSource));
+        assertThat(typeVariable.getTypeVariableSource(), is((TypeVariableSource) typeVariableSource));
     }
 
     @Test
@@ -105,7 +105,7 @@ public void testTypeVariableOnType() throws Exception {
         when(typeVariableSource.accept(any(TypeVariableSource.Visitor.class))).thenCallRealMethod();
         TypeDescription typeErasure = mock(TypeDescription.class);
         when(typeDescription.asErasure()).thenReturn(typeErasure);
-        when(typeDescription.getVariableSource()).thenReturn(typeVariableSource);
+        when(typeDescription.getTypeVariableSource()).thenReturn(typeVariableSource);
         TypeDescription.Generic erasure = TypeDescription.Generic.Visitor.TypeVariableErasing.INSTANCE.onTypeVariable(typeDescription);
         assertThat(erasure.getSort(), is(TypeDefinition.Sort.NON_GENERIC));
         assertThat(erasure.asErasure(), is(typeErasure));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/TransformerForMethodTest.java
Patch:
@@ -156,6 +156,7 @@ public void testNoChangesUnlessSpecified() throws Exception {
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(Transformer.ForMethod.class).apply();
         ObjectPropertyAssertion.of(Transformer.ForMethod.MethodModifierTransformer.class).apply();
+        ObjectPropertyAssertion.of(Transformer.ForMethod.TransformedMethod.AttachmentVisitor.class).apply();
     }
 
     private static class Foo<T> {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeDefaultTest.java
Patch:
@@ -88,7 +88,7 @@ public void testWithTypeVariable() throws Exception {
         assertThat(instrumentedType.getTypeVariables().size(), is(1));
         TypeDescription.Generic typeVariable = instrumentedType.getTypeVariables().get(0);
         assertThat(typeVariable.getTypeName(), is(BAR));
-        assertThat(typeVariable.getVariableSource(), sameInstance((TypeVariableSource) instrumentedType));
+        assertThat(typeVariable.getTypeVariableSource(), sameInstance((TypeVariableSource) instrumentedType));
         assertThat(typeVariable.getUpperBounds(), is(Collections.singletonList(boundType)));
     }
 
@@ -100,7 +100,7 @@ public void testWithTypeVariableWithInstrumentedType() throws Exception {
         assertThat(instrumentedType.getTypeVariables().size(), is(1));
         TypeDescription.Generic typeVariable = instrumentedType.getTypeVariables().get(0);
         assertThat(typeVariable.getTypeName(), is(BAR));
-        assertThat(typeVariable.getVariableSource(), sameInstance((TypeVariableSource) instrumentedType));
+        assertThat(typeVariable.getTypeVariableSource(), sameInstance((TypeVariableSource) instrumentedType));
         assertThat(typeVariable.getUpperBounds(), is(Collections.singletonList(instrumentedType.asGenericType())));
     }
 
@@ -128,7 +128,7 @@ public void testWithTypeVariableTransformed() throws Exception {
         assertThat(instrumentedType.getTypeVariables().size(), is(1));
         TypeDescription.Generic typeVariable = instrumentedType.getTypeVariables().get(0);
         assertThat(typeVariable.getTypeName(), is(QUX));
-        assertThat(typeVariable.getVariableSource(), sameInstance((TypeVariableSource) instrumentedType));
+        assertThat(typeVariable.getTypeVariableSource(), sameInstance((TypeVariableSource) instrumentedType));
         assertThat(typeVariable.getUpperBounds(), is(Collections.singletonList(otherBoundType)));
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -522,7 +522,7 @@ public int size() {
             /**
              * A list of attached type variables represented by a list of type variable tokens.
              */
-            protected static class OfTypeVariables extends Generic.AbstractBase {
+            public static class OfTypeVariables extends Generic.AbstractBase {
 
                 /**
                  * The type variable's source.
@@ -546,7 +546,7 @@ protected static class OfTypeVariables extends Generic.AbstractBase {
                  * @param detachedTypeVariables A token representing the type variable in its detached state.
                  * @param visitor               A visitor for attaching the type variable's bounds.
                  */
-                protected OfTypeVariables(TypeVariableSource typeVariableSource,
+                public OfTypeVariables(TypeVariableSource typeVariableSource,
                                           List<? extends TypeVariableToken> detachedTypeVariables,
                                           TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
                     this.typeVariableSource = typeVariableSource;

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -4707,7 +4707,8 @@ public Default(ByteBuddy byteBuddy) {
                     LambdaInstrumentationStrategy.DISABLED,
                     DescriptionStrategy.Default.HYBRID,
                     InstallationStrategy.Default.ESCALATING,
-                    new RawMatcher.Disjunction(new RawMatcher.ForElementMatchers(any(), isBootstrapClassLoader(), any()), new RawMatcher.ForElementMatchers(nameStartsWith("net.bytebuddy.").<TypeDescription>or(isSynthetic()), any(), any())),
+                    new RawMatcher.Disjunction(new RawMatcher.ForElementMatchers(any(), isBootstrapClassLoader(), any()),
+                            new RawMatcher.ForElementMatchers(nameStartsWith("net.bytebuddy.").or(nameStartsWith("sun.reflect.")).<TypeDescription>or(isSynthetic()), any(), any())),
                     Transformation.Ignored.INSTANCE);
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultApplicationRedefineTest.java
Patch:
@@ -33,8 +33,8 @@
 import static net.bytebuddy.matcher.ElementMatchers.named;
 import static net.bytebuddy.matcher.ElementMatchers.none;
 import static org.hamcrest.CoreMatchers.instanceOf;
+import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.core.Is.is;
 
 @RunWith(Parameterized.class)
 public class AgentBuilderDefaultApplicationRedefineTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/MethodOverrideMatcherTest.java
Patch:
@@ -11,7 +11,7 @@
 
 import java.util.Arrays;
 
-import static org.hamcrest.core.Is.is;
+import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.*;
 import static org.mockito.Mockito.*;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -72,15 +72,15 @@ public class ClassFileVersion implements Comparable<ClassFileVersion> {
     /**
      * A version locator for the executing JVM.
      */
-    private static final VersionLocator VERSION_LOCATOR = make();
+    private static final VersionLocator VERSION_LOCATOR = versionLocator();
 
     /**
      * Creates a version locator of the executing JVM.
      *
      * @return An appropriate version locator.
      */
     @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but trigger a fallback")
-    private static VersionLocator make() {
+    private static VersionLocator versionLocator() {
         try {
             return new VersionLocator.ForJava9CapableVm(Runtime.class.getDeclaredMethod("version"),
                     Class.forName("java.lang.Runtime$Version").getDeclaredMethod("major"));

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -6069,7 +6069,7 @@ protected static class ExecutingTransformer implements ClassFileTransformer {
             /**
              * A factory for creating a {@link ClassFileTransformer} that supports the features of the current VM.
              */
-            protected static final Factory FACTORY = AccessController.doPrivileged(InheritanceAction.INSTANCE);
+            protected static final Factory FACTORY = AccessController.doPrivileged(FactoryCreationOption.INSTANCE);
 
             /**
              * The Byte Buddy instance to be used.
@@ -6463,7 +6463,7 @@ public String toString() {
             /**
              * An action to create an implementation of {@link ExecutingTransformer} that support Java 9 modules.
              */
-            protected enum InheritanceAction implements PrivilegedAction<Factory> {
+            protected enum FactoryCreationOption implements PrivilegedAction<Factory> {
 
                 /**
                  * The singleton instance.

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -735,7 +735,7 @@ public TypeList getParameterTypes() {
          * @return The method descriptor of this method handle representation.
          */
         public String getDescriptor() {
-            StringBuilder stringBuilder = new StringBuilder("(");
+            StringBuilder stringBuilder = new StringBuilder().append('(');
             for (TypeDescription parameterType : parameterTypes) {
                 stringBuilder.append(parameterType.getDescriptor());
             }

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -1237,7 +1237,7 @@ public AccessControlContext create() {
                 return new AccessControlContext(new ProtectionDomain[]{mock(ProtectionDomain.class)});
             }
         }).apply();
-        ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.InheritanceAction.class);
+        ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.FactoryCreationOption.class);
         final Iterator<Class<?>> java9Dispatcher = Arrays.<Class<?>>asList(Object.class, String.class, Integer.class, Double.class, Float.class).iterator();
         ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.Java9CapableVmDispatcher.class).create(new ObjectPropertyAssertion.Creator<Class<?>>() {
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/PropertyDispatcher.java
Patch:
@@ -496,7 +496,7 @@ public String toString() {
      * A delegate for rendering a {@link Class} or {@link TypeDescription}. Starting with Java 9, such values are enclosed
      * in curly braces and are rendered as class literals to better match the source code.
      */
-    protected enum TypeRenderer {
+    public enum TypeRenderer {
 
         /**
          * A type renderer for a legacy VM prior to Java 8.
@@ -536,7 +536,7 @@ protected String render(TypeDescription typeDescription) {
         /**
          * The type renderer to be used on the current VM.
          */
-        protected static final TypeRenderer CURRENT = make();
+        public static final TypeRenderer CURRENT = make();
 
         /**
          * Finds the type renderer for the current VM.
@@ -569,7 +569,7 @@ private static TypeRenderer make() {
          * @param delimiter The delimiter being used.
          * @return The adjusted delimiter.
          */
-        protected char adjust(char delimiter) {
+        public char adjust(char delimiter) {
             return (char) (delimiter + offset);
         }
 

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/ClassByExtensionBenchmark.java
Patch:
@@ -93,7 +93,7 @@ public ExampleClass benchmarkByteBuddyWithAnnotations() throws Exception {
                 .make()
                 .load(newClassLoader(), ClassLoadingStrategy.Default.INJECTION)
                 .getLoaded()
-                .getConstructor()
+                .getDeclaredConstructor()
                 .newInstance();
     }
 
@@ -114,7 +114,7 @@ public ExampleClass benchmarkByteBuddySpecialized() throws Exception {
                 .make()
                 .load(newClassLoader(), ClassLoadingStrategy.Default.INJECTION)
                 .getLoaded()
-                .getConstructor()
+                .getDeclaredConstructor()
                 .newInstance();
     }
 
@@ -175,7 +175,7 @@ public boolean isHandled(Method method) {
             }
         });
         @SuppressWarnings("unchecked")
-        Object instance = proxyFactory.createClass().getConstructor().newInstance();
+        Object instance = proxyFactory.createClass().getDeclaredConstructor().newInstance();
         ((javassist.util.proxy.Proxy) instance).setHandler(new MethodHandler() {
             public Object invoke(Object self,
                                  Method thisMethod,

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/ClassByImplementationBenchmark.java
Patch:
@@ -274,7 +274,7 @@ public ExampleInterface benchmarkByteBuddy() throws Exception {
                 .make()
                 .load(newClassLoader(), ClassLoadingStrategy.Default.INJECTION)
                 .getLoaded()
-                .getConstructor()
+                .getDeclaredConstructor()
                 .newInstance();
     }
 
@@ -333,7 +333,7 @@ public boolean isHandled(Method method) {
             }
         });
         @SuppressWarnings("unchecked")
-        Object instance = proxyFactory.createClass().getConstructor().newInstance();
+        Object instance = proxyFactory.createClass().getDeclaredConstructor().newInstance();
         ((javassist.util.proxy.Proxy) instance).setHandler(new MethodHandler() {
             public Object invoke(Object self,
                                  Method thisMethod,

File: byte-buddy-benchmark/src/test/java/net/bytebuddy/benchmark/AbstractBlackHoleTest.java
Patch:
@@ -32,6 +32,6 @@ public void setUpBlackHole() throws Exception {
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         Method method = blackHoleGenerator.getDeclaredMethod(BLACK_HOLE_METHOD);
-        blackHole = (Blackhole) method.invoke(blackHoleGenerator.getConstructor().newInstance());
+        blackHole = (Blackhole) method.invoke(blackHoleGenerator.getDeclaredConstructor().newInstance());
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTest.java
Patch:
@@ -70,7 +70,7 @@ public void testTypeInitializerInstrumentation() throws Exception {
                 .make(TypeResolutionStrategy.Active.INSTANCE)
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(type.getConstructor().newInstance(), instanceOf(type));
+        assertThat(type.getDeclaredConstructor().newInstance(), instanceOf(type));
         assertThat(recorder.counter, is(1));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/ClassFileVersionKnownVersionsTest.java
Patch:
@@ -110,7 +110,7 @@ public void testSimpleClassCreation() throws Exception {
                     .make()
                     .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                     .getLoaded();
-            assertThat(type.getConstructor().newInstance(), notNullValue(Object.class));
+            assertThat(type.getDeclaredConstructor().newInstance(), notNullValue(Object.class));
         }
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceBoxedAssignmentTest.java
Patch:
@@ -53,7 +53,7 @@ public void testAssignment() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.getConstructor().newInstance()), is(expected));
+        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.getDeclaredConstructor().newInstance()), is(expected));
     }
 
     @SuppressWarnings("all")

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceDeadCodeTest.java
Patch:
@@ -58,7 +58,7 @@ public void testAdviceProcessesDeadCode() throws Exception {
                 .make()
                 .load(null, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(redefined.getDeclaredMethod(FOO).invoke(redefined.getConstructor().newInstance()), is((Object) FOO));
+        assertThat(redefined.getDeclaredMethod(FOO).invoke(redefined.getDeclaredConstructor().newInstance()), is((Object) FOO));
     }
 
     @Test
@@ -86,7 +86,7 @@ public void testAdviceContainsDeadCode() throws Exception {
                 .load(null, ClassLoadingStrategy.Default.CHILD_FIRST)
                 .getLoaded();
         assertThat(redefined, not(sameInstance((Object) foo)));
-        assertThat(redefined.getDeclaredMethod(FOO).invoke(redefined.getConstructor().newInstance()), is((Object) FOO));
+        assertThat(redefined.getDeclaredMethod(FOO).invoke(redefined.getDeclaredConstructor().newInstance()), is((Object) FOO));
     }
 
     @SuppressWarnings("all")

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceInconsistentStackSizeTest.java
Patch:
@@ -76,7 +76,7 @@ public void testInconsistentStackSize() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(adviced.getDeclaredMethod(FOO).invoke(adviced.getConstructor().newInstance()), is((Object) replaced));
+        assertThat(adviced.getDeclaredMethod(FOO).invoke(adviced.getDeclaredConstructor().newInstance()), is((Object) replaced));
     }
 
     @Test
@@ -104,7 +104,7 @@ public void testInconsistentStackSizeAdvice() throws Exception {
                 .load(null, ClassLoadingStrategy.Default.CHILD_FIRST)
                 .getLoaded();
         assertThat(redefined, not(sameInstance((Object) foo)));
-        assertThat(redefined.getDeclaredMethod(FOO).invoke(redefined.getConstructor().newInstance()), is((Object) FOO));
+        assertThat(redefined.getDeclaredMethod(FOO).invoke(redefined.getDeclaredConstructor().newInstance()), is((Object) FOO));
     }
 
     @SuppressWarnings("all")

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceJsrRetTest.java
Patch:
@@ -30,14 +30,14 @@ public void testJsrRetByteCodes() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER_PERSISTENT)
                 .getLoaded();
-        assertThat(type.getDeclaredMethod(FOO).invoke(type.getConstructor().newInstance()), is((Object) FOO));
+        assertThat(type.getDeclaredMethod(FOO).invoke(type.getDeclaredConstructor().newInstance()), is((Object) FOO));
         Class<?> advised = new ByteBuddy()
                 .redefine(type)
                 .visit(Advice.to(JsrAdvice.class).on(named(FOO)))
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(advised.getDeclaredMethod(FOO).invoke(advised.getConstructor().newInstance()), is((Object) BAR));
+        assertThat(advised.getDeclaredMethod(FOO).invoke(advised.getDeclaredConstructor().newInstance()), is((Object) BAR));
     }
 
     @SuppressWarnings("all")

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceNoRegularReturnTest.java
Patch:
@@ -51,7 +51,7 @@ public void testNoRegularReturnWithSkip() throws Exception {
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         try {
-            type.getDeclaredMethod(FOO).invoke(type.getConstructor().newInstance());
+            type.getDeclaredMethod(FOO).invoke(type.getDeclaredConstructor().newInstance());
             fail();
         } catch (InvocationTargetException exception) {
             assertThat(exception.getCause(), instanceOf(RuntimeException.class));
@@ -67,7 +67,7 @@ public void testNoRegularReturnWithoutHandler() throws Exception {
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         try {
-            type.getDeclaredMethod(FOO).invoke(type.getConstructor().newInstance());
+            type.getDeclaredMethod(FOO).invoke(type.getDeclaredConstructor().newInstance());
             fail();
         } catch (InvocationTargetException exception) {
             assertThat(exception.getCause(), instanceOf(RuntimeException.class));
@@ -83,7 +83,7 @@ public void testNoRegularReturnWithHandler() throws Exception {
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         try {
-            type.getDeclaredMethod(FOO).invoke(type.getConstructor().newInstance());
+            type.getDeclaredMethod(FOO).invoke(type.getDeclaredConstructor().newInstance());
             fail();
         } catch (InvocationTargetException exception) {
             assertThat(exception.getCause(), instanceOf(RuntimeException.class));

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceNoRegularReturnWithinAdviceTest.java
Patch:
@@ -72,7 +72,7 @@ public void testNoRegularReturn() throws Exception {
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         try {
-            type.getDeclaredMethod(FOO).invoke(type.getConstructor().newInstance());
+            type.getDeclaredMethod(FOO).invoke(type.getDeclaredConstructor().newInstance());
             fail();
         } catch (InvocationTargetException exception) {
             assertThat(exception.getCause(), instanceOf(RuntimeException.class));

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceSkipIfTrueTypeTest.java
Patch:
@@ -81,7 +81,7 @@ public void testAdvice() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(type.getDeclaredMethod(FOO).invoke(type.getConstructor().newInstance()), is(value));
+        assertThat(type.getDeclaredMethod(FOO).invoke(type.getDeclaredConstructor().newInstance()), is(value));
     }
 
     @SuppressWarnings("unused")

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceSuppressionTest.java
Patch:
@@ -78,7 +78,7 @@ public void testIllegalAssignment() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.getConstructor().newInstance()), nullValue(Object.class));
+        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.getDeclaredConstructor().newInstance()), nullValue(Object.class));
     }
 
     @SuppressWarnings("unused")

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTypeTest.java
Patch:
@@ -91,7 +91,7 @@ public void testAdvice() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(type.getDeclaredMethod(FOO, this.type, this.type).invoke(type.getConstructor().newInstance(), value, value), is((Object) value));
+        assertThat(type.getDeclaredMethod(FOO, this.type, this.type).invoke(type.getDeclaredConstructor().newInstance(), value, value), is((Object) value));
         assertThat(type.getDeclaredField(ENTER).get(null), is((Object) 1));
         assertThat(type.getDeclaredField(EXIT).get(null), is((Object) 1));
     }
@@ -110,7 +110,7 @@ public void testAdviceWithException() throws Exception {
                 .getLoaded();
         type.getDeclaredField(exception).set(null, true);
         try {
-            assertThat(type.getDeclaredMethod(BAR, this.type, this.type).invoke(type.getConstructor().newInstance(), value, value), is((Object) value));
+            assertThat(type.getDeclaredMethod(BAR, this.type, this.type).invoke(type.getDeclaredConstructor().newInstance(), value, value), is((Object) value));
             fail();
         } catch (InvocationTargetException exception) {
             assertThat(exception.getCause(), instanceOf(RuntimeException.class));
@@ -134,7 +134,7 @@ public void testAdviceWithProperty() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(type.getDeclaredMethod(FOO, this.type, this.type).invoke(type.getConstructor().newInstance(), value, value), is((Object) value));
+        assertThat(type.getDeclaredMethod(FOO, this.type, this.type).invoke(type.getDeclaredConstructor().newInstance(), value, value), is((Object) value));
         assertThat(type.getDeclaredField(ENTER).get(null), is((Object) 1));
         assertThat(type.getDeclaredField(EXIT).get(null), is((Object) 1));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassInjectorUsingReflectionTest.java
Patch:
@@ -79,7 +79,7 @@ public void testInjectionOrderNoPrematureAuxiliaryInjection() throws Exception {
                 .intercept(MethodDelegation.to(Interceptor.class)).make()
                 .load(classLoader, ClassLoadingStrategy.Default.INJECTION)
                 .getLoaded();
-        assertThat(type.getDeclaredMethod(BAR, String.class).invoke(type.getConstructor().newInstance(), FOO), is((Object) BAR));
+        assertThat(type.getDeclaredMethod(BAR, String.class).invoke(type.getDeclaredConstructor().newInstance(), FOO), is((Object) BAR));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategyTest.java
Patch:
@@ -212,7 +212,7 @@ public void testAnonymousType() throws Exception {
         Instrumentation instrumentation = ByteBuddyAgent.install();
         Class<?> factory = classLoader.loadClass(LAMBDA_SAMPLE_FACTORY);
         @SuppressWarnings("unchecked")
-        Callable<String> instance = (Callable<String>) factory.getDeclaredMethod("nonCapturing").invoke(factory.getConstructor().newInstance());
+        Callable<String> instance = (Callable<String>) factory.getDeclaredMethod("nonCapturing").invoke(factory.getDeclaredConstructor().newInstance());
         // Anonymous types can only be reset to their original format, if a retransformation is applied.
         ClassReloadingStrategy classReloadingStrategy = new ClassReloadingStrategy(instrumentation,
                 ClassReloadingStrategy.Strategy.RETRANSFORMATION).preregistered(instance.getClass());

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultTest.java
Patch:
@@ -390,7 +390,7 @@ public void testTypeInLegacyConstantPoolRemapped() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.getConstructor().newInstance()), is((Object) Object.class));
+        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.getDeclaredConstructor().newInstance()), is((Object) Object.class));
     }
 
     @Test
@@ -403,7 +403,7 @@ public void testArrayTypeInLegacyConstantPoolRemapped() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.getConstructor().newInstance()), is((Object) Object[].class));
+        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.getDeclaredConstructor().newInstance()), is((Object) Object[].class));
     }
 
     @Test
@@ -416,7 +416,7 @@ public void testPrimitiveTypeInLegacyConstantPoolRemapped() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.getConstructor().newInstance()), is((Object) int.class));
+        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.getDeclaredConstructor().newInstance()), is((Object) int.class));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilderTest.java
Patch:
@@ -161,7 +161,7 @@ public void testDefaultInterfaceSubInterface() throws Exception {
                 .make()
                 .load(dynamicInterfaceType.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(dynamicClassType.getMethod(FOO).invoke(dynamicClassType.getConstructor().newInstance()), is((Object) (FOO + BAR)));
+        assertThat(dynamicClassType.getMethod(FOO).invoke(dynamicClassType.getDeclaredConstructor().newInstance()), is((Object) (FOO + BAR)));
         assertThat(dynamicInterfaceType.getDeclaredMethods().length, is(3));
         assertThat(dynamicClassType.getDeclaredMethods().length, is(0));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilderTest.java
Patch:
@@ -130,7 +130,7 @@ public void testDefaultInterfaceSubInterface() throws Exception {
                 .make()
                 .load(dynamicInterfaceType.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(dynamicClassType.getMethod(FOO).invoke(dynamicClassType.getConstructor().newInstance()), is((Object) BAR));
+        assertThat(dynamicClassType.getMethod(FOO).invoke(dynamicClassType.getDeclaredConstructor().newInstance()), is((Object) BAR));
         assertThat(dynamicInterfaceType.getDeclaredMethods().length, is(1));
         assertThat(dynamicClassType.getDeclaredMethods().length, is(0));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ExceptionMethodTest.java
Patch:
@@ -23,7 +23,7 @@ public void testWithoutMessage() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(0));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
         try {
@@ -42,7 +42,7 @@ public void testWithMessage() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(0));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
         try {
@@ -61,7 +61,7 @@ public void testWithNonDeclaredCheckedException() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(0));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
         try {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/FieldAccessorNonBeanTest.java
Patch:
@@ -20,7 +20,7 @@ public class FieldAccessorNonBeanTest extends AbstractImplementationTest {
     @Test
     public void testExplicitNameSetter() throws Exception {
         DynamicType.Loaded<SampleSetter> loaded = implement(SampleSetter.class, FieldAccessor.ofField(FOO));
-        SampleSetter sampleSetter = loaded.getLoaded().getConstructor().newInstance();
+        SampleSetter sampleSetter = loaded.getLoaded().getDeclaredConstructor().newInstance();
         Field field = SampleSetter.class.getDeclaredField(FOO);
         field.setAccessible(true);
         assertThat(field.get(sampleSetter), is((Object) STRING_DEFAULT_VALUE));
@@ -32,7 +32,7 @@ public void testExplicitNameSetter() throws Exception {
     @Test
     public void testExplicitNameGetter() throws Exception {
         DynamicType.Loaded<SampleGetter> loaded = implement(SampleGetter.class, FieldAccessor.ofField(FOO));
-        SampleGetter sampleGetter = loaded.getLoaded().getConstructor().newInstance();
+        SampleGetter sampleGetter = loaded.getLoaded().getDeclaredConstructor().newInstance();
         Field field = SampleGetter.class.getDeclaredField(FOO);
         field.setAccessible(true);
         assertThat(field.get(sampleGetter), is((Object) STRING_VALUE));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/FieldAccessorTest.java
Patch:
@@ -193,7 +193,7 @@ private <Z extends CallTraceable> void testGetter(Class<Z> target,
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(definesField ? 1 : 0));
-        Z instance = loaded.getLoaded().getConstructor().newInstance();
+        Z instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         if (definesField) {
             initializeField(instance);
         }
@@ -214,7 +214,7 @@ private <Z extends CallTraceable> void testSetter(Class<Z> target,
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(definesField ? 1 : 0));
-        Z instance = loaded.getLoaded().getConstructor().newInstance();
+        Z instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(target)));
         assertThat(instance, instanceOf(target));
         Method setter = loaded.getLoaded()

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/FixedValueConstantPoolTypesTest.java
Patch:
@@ -86,7 +86,7 @@ public void testConstantPool() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(2));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(0));
-        T instance = loaded.getLoaded().getConstructor().newInstance();
+        T instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(StringTarget.class)));
         assertThat(instance, instanceOf(helperClass));
         assertThat(loaded.getLoaded().getDeclaredMethod(FOO).invoke(instance), is(fixedValue));
@@ -100,7 +100,7 @@ public void testStaticField() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(2));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(fixedValue == null ? 0 : 1));
-        T instance = loaded.getLoaded().getConstructor().newInstance();
+        T instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(StringTarget.class)));
         assertThat(instance, instanceOf(helperClass));
         assertThat(loaded.getLoaded().getDeclaredMethod(FOO).invoke(instance), is(fixedValue));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ForwardingTest.java
Patch:
@@ -23,7 +23,7 @@ public void testStaticInstanceForwarding() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(1));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.foo(), is(BAR));
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
@@ -35,7 +35,7 @@ public void testInstanceFieldForwarding() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(1));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         Field field = loaded.getLoaded().getDeclaredField(FOO);
         field.setAccessible(true);
         field.set(instance, new Bar());
@@ -50,7 +50,7 @@ public void testStaticFieldForwarding() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(1));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         Field field = loaded.getLoaded().getDeclaredField(FOO);
         field.setAccessible(true);
         field.set(null, new Bar());

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodCallTypeTest.java
Patch:
@@ -105,7 +105,7 @@ public void testFieldConstantPool() throws Exception {
         assertThat(loaded.getLoaded().getDeclaredMethod(FOO, Object.class), not(nullValue(Method.class)));
         assertThat(loaded.getLoaded().getDeclaredConstructors().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(definesFieldConstantPool ? 1 : 0));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
         assertThat(instance.foo(new Object()), is(value));
@@ -119,7 +119,7 @@ public void testFieldReference() throws Exception {
         assertThat(loaded.getLoaded().getDeclaredMethod(FOO, Object.class), not(nullValue(Method.class)));
         assertThat(loaded.getLoaded().getDeclaredConstructors().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(definesFieldReference ? 1 : 0));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
         assertThat(instance.foo(new Object()), sameInstance(value));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationAllArgumentsTest.java
Patch:
@@ -16,7 +16,7 @@ public class MethodDelegationAllArgumentsTest extends AbstractImplementationTest
     @Test
     public void testStrictBindable() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, MethodDelegation.to(Bar.class));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.foo(FOO, BAR), is((Object) (QUX + FOO + BAR)));
     }
 
@@ -28,14 +28,14 @@ public void testStrictNonBindableThrowsException() throws Exception {
     @Test
     public void testSlackNonBindable() throws Exception {
         DynamicType.Loaded<Qux> loaded = implement(Qux.class, MethodDelegation.to(BazSlack.class));
-        Qux instance = loaded.getLoaded().getConstructor().newInstance();
+        Qux instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.foo(FOOBAR, BAZ), is((Object) (QUX + BAZ)));
     }
 
     @Test
     public void testIncludeSelf() throws Exception {
         DynamicType.Loaded<Qux> loaded = implement(Qux.class, MethodDelegation.to(IncludeSelf.class));
-        Qux instance = loaded.getLoaded().getConstructor().newInstance();
+        Qux instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.foo(QUX, BAZ), is((Object) instance));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationArgumentTest.java
Patch:
@@ -19,7 +19,7 @@ public class MethodDelegationArgumentTest extends AbstractImplementationTest {
     @Test
     public void testArgument() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, MethodDelegation.to(Bar.class));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.foo(FOO, BAR), is((Object) (QUX + FOO + BAR)));
     }
 
@@ -32,7 +32,7 @@ public void testHierarchyDelegation() throws Exception {
                 .make()
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded()
-                .getConstructor()
+                .getDeclaredConstructor()
                 .newInstance()
                 .foo();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationBindingPriorityTest.java
Patch:
@@ -16,7 +16,7 @@ public class MethodDelegationBindingPriorityTest extends AbstractImplementationT
     @Test
     public void testBindingPriority() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, MethodDelegation.to(Bar.class));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.foo(), is(FOO));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationChainedTest.java
Patch:
@@ -19,7 +19,7 @@ public void testChainingVoid() throws Exception {
         DynamicType.Loaded<Foo> dynamicType = implement(Foo.class, MethodDelegation.to(voidInterceptor)
                 .filter(isDeclaredBy(VoidInterceptor.class))
                 .andThen(new Implementation.Simple(new TextConstant(FOO), MethodReturn.REFERENCE)));
-        assertThat(dynamicType.getLoaded().getConstructor().newInstance().foo(), is(FOO));
+        assertThat(dynamicType.getLoaded().getDeclaredConstructor().newInstance().foo(), is(FOO));
         assertThat(voidInterceptor.intercepted, is(true));
     }
 
@@ -29,7 +29,7 @@ public void testChainingNonVoid() throws Exception {
         DynamicType.Loaded<Foo> dynamicType = implement(Foo.class, MethodDelegation.to(nonVoidInterceptor)
                 .filter(isDeclaredBy(NonVoidInterceptor.class))
                 .andThen(new Implementation.Simple(new TextConstant(FOO), MethodReturn.REFERENCE)));
-        assertThat(dynamicType.getLoaded().getConstructor().newInstance().foo(), is(FOO));
+        assertThat(dynamicType.getLoaded().getDeclaredConstructor().newInstance().foo(), is(FOO));
         assertThat(nonVoidInterceptor.intercepted, is(true));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationCheckedExceptionTest.java
Patch:
@@ -8,7 +8,7 @@ public class MethodDelegationCheckedExceptionTest extends AbstractImplementation
     public void testUndeclaredCheckedException() throws Exception {
         implement(Foo.class, MethodDelegation.to(Foo.class))
                 .getLoaded()
-                .getConstructor()
+                .getDeclaredConstructor()
                 .newInstance()
                 .bar();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationConstructionTest.java
Patch:
@@ -96,7 +96,7 @@ public void testConstruction() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(0));
-        T instance = loaded.getLoaded().getConstructor().newInstance();
+        T instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(sourceType)));
         assertThat(instance, instanceOf(sourceType));
         Object value = loaded.getLoaded().getDeclaredMethod(FOO, parameterTypes).invoke(instance, arguments);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationIgnoreForBindingTest.java
Patch:
@@ -14,7 +14,7 @@ public class MethodDelegationIgnoreForBindingTest extends AbstractImplementation
     @Test
     public void testIgnoreForBinding() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, MethodDelegation.to(Bar.class));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.foo(), is(FOO));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationRuntimeTypeTest.java
Patch:
@@ -14,7 +14,7 @@ public class MethodDelegationRuntimeTypeTest extends AbstractImplementationTest
     @Test
     public void testRuntimeType() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, MethodDelegation.to(Bar.class));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.foo(FOO), is(FOO));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationThisTest.java
Patch:
@@ -12,7 +12,7 @@ public class MethodDelegationThisTest extends AbstractImplementationTest {
     @Test
     public void testThis() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, MethodDelegation.to(Bar.class));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.foo(), is((Object) instance));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/StubMethodTest.java
Patch:
@@ -118,7 +118,7 @@ public void testInstrumentedMethod() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, StubMethod.INSTANCE);
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(11));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
         assertThat(loaded.getLoaded().getDeclaredMethod(methodName, methodParameterTypes)

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/SuperMethodCallOtherTest.java
Patch:
@@ -133,7 +133,7 @@ public void testNoSuper() throws Exception {
     public void testAndThen() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, SuperMethodCall.INSTANCE
                 .andThen(new Implementation.Simple(new TextConstant(FOO), MethodReturn.REFERENCE)));
-        Foo foo = loaded.getLoaded().getConstructor().newInstance();
+        Foo foo = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(foo.foo(), is(FOO));
         foo.assertOnlyCall(FOO);
     }
@@ -148,7 +148,7 @@ public void testUnambiguousDirectDefaultMethod() throws Exception {
                 Class.forName(SINGLE_DEFAULT_METHOD));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         Method method = loaded.getLoaded().getDeclaredMethod(FOO);
-        Object instance = loaded.getLoaded().getConstructor().newInstance();
+        Object instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(method.invoke(instance), is((Object) FOO));
     }
 
@@ -161,7 +161,7 @@ public void testInheritedDefaultMethod() throws Exception {
                 isMethod().and(not(isDeclaredBy(Object.class))));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         Method method = loaded.getLoaded().getDeclaredMethod(FOO);
-        Object instance = loaded.getLoaded().getConstructor().newInstance();
+        Object instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(method.invoke(instance), is((Object) FOO));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/SuperMethodCallTest.java
Patch:
@@ -100,7 +100,7 @@ public void testInstrumentedMethod() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, SuperMethodCall.INSTANCE);
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(11));
-        Foo instance = loaded.getLoaded().getConstructor().newInstance();
+        Foo instance = loaded.getLoaded().getDeclaredConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
         assertThat(loaded.getLoaded().getDeclaredMethod(methodName, methodParameterTypes)

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/MethodCallProxySingleArgumentTest.java
Patch:
@@ -69,7 +69,7 @@ public void testRunMethod() throws Exception {
         Class<?> auxiliaryType = proxyOnlyDeclaredMethodOf(targetType);
         Constructor<?> constructor = auxiliaryType.getDeclaredConstructor(targetType, valueType);
         constructor.setAccessible(true);
-        T proxiedInstance = targetType.getConstructor().newInstance();
+        T proxiedInstance = targetType.getDeclaredConstructor().newInstance();
         ((Runnable) constructor.newInstance(proxiedInstance, value)).run();
         proxiedInstance.assertOnlyCall(FOO, value);
     }
@@ -79,7 +79,7 @@ public void testCallMethod() throws Exception {
         Class<?> auxiliaryType = proxyOnlyDeclaredMethodOf(targetType);
         Constructor<?> constructor = auxiliaryType.getDeclaredConstructor(targetType, valueType);
         constructor.setAccessible(true);
-        T proxiedInstance = targetType.getConstructor().newInstance();
+        T proxiedInstance = targetType.getDeclaredConstructor().newInstance();
         assertThat(((Callable<?>) constructor.newInstance(proxiedInstance, value)).call(), is(value));
         proxiedInstance.assertOnlyCall(FOO, value);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDriverBinderParameterBinderForFixedValueOfConstantTest.java
Patch:
@@ -56,7 +56,7 @@ public void testConstant() throws Exception {
                 .make()
                 .load(Foo.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded()
-                .getConstructor()
+                .getDeclaredConstructor()
                 .newInstance()
                 .foo(), is(value));
     }

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/ClassByImplementationBenchmark.java
Patch:
@@ -274,6 +274,7 @@ public ExampleInterface benchmarkByteBuddy() throws Exception {
                 .make()
                 .load(newClassLoader(), ClassLoadingStrategy.Default.INJECTION)
                 .getLoaded()
+                .getConstructor()
                 .newInstance();
     }
 
@@ -331,7 +332,8 @@ public boolean isHandled(Method method) {
                 return true;
             }
         });
-        Object instance = proxyFactory.createClass().newInstance();
+        @SuppressWarnings("unchecked")
+        Object instance = proxyFactory.createClass().getConstructor().newInstance();
         ((javassist.util.proxy.Proxy) instance).setHandler(new MethodHandler() {
             public Object invoke(Object self,
                                  Method thisMethod,

File: byte-buddy-benchmark/src/test/java/net/bytebuddy/benchmark/AbstractBlackHoleTest.java
Patch:
@@ -32,6 +32,6 @@ public void setUpBlackHole() throws Exception {
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         Method method = blackHoleGenerator.getDeclaredMethod(BLACK_HOLE_METHOD);
-        blackHole = (Blackhole) method.invoke(blackHoleGenerator.newInstance());
+        blackHole = (Blackhole) method.invoke(blackHoleGenerator.getConstructor().newInstance());
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTest.java
Patch:
@@ -70,7 +70,7 @@ public void testTypeInitializerInstrumentation() throws Exception {
                 .make(TypeResolutionStrategy.Active.INSTANCE)
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(type.newInstance(), instanceOf(type));
+        assertThat(type.getConstructor().newInstance(), instanceOf(type));
         assertThat(recorder.counter, is(1));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/ClassFileVersionKnownVersionsTest.java
Patch:
@@ -110,7 +110,7 @@ public void testSimpleClassCreation() throws Exception {
                     .make()
                     .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                     .getLoaded();
-            assertThat(type.newInstance(), notNullValue(Object.class));
+            assertThat(type.getConstructor().newInstance(), notNullValue(Object.class));
         }
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceBoxedAssignmentTest.java
Patch:
@@ -53,7 +53,7 @@ public void testAssignment() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.newInstance()), is(expected));
+        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.getConstructor().newInstance()), is(expected));
     }
 
     @SuppressWarnings("all")

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceDeadCodeTest.java
Patch:
@@ -58,7 +58,7 @@ public void testAdviceProcessesDeadCode() throws Exception {
                 .make()
                 .load(null, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(redefined.getDeclaredMethod(FOO).invoke(redefined.newInstance()), is((Object) FOO));
+        assertThat(redefined.getDeclaredMethod(FOO).invoke(redefined.getConstructor().newInstance()), is((Object) FOO));
     }
 
     @Test
@@ -86,7 +86,7 @@ public void testAdviceContainsDeadCode() throws Exception {
                 .load(null, ClassLoadingStrategy.Default.CHILD_FIRST)
                 .getLoaded();
         assertThat(redefined, not(sameInstance((Object) foo)));
-        assertThat(redefined.getDeclaredMethod(FOO).invoke(redefined.newInstance()), is((Object) FOO));
+        assertThat(redefined.getDeclaredMethod(FOO).invoke(redefined.getConstructor().newInstance()), is((Object) FOO));
     }
 
     @SuppressWarnings("all")

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceInconsistentStackSizeTest.java
Patch:
@@ -76,7 +76,7 @@ public void testInconsistentStackSize() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(adviced.getDeclaredMethod(FOO).invoke(adviced.newInstance()), is((Object) replaced));
+        assertThat(adviced.getDeclaredMethod(FOO).invoke(adviced.getConstructor().newInstance()), is((Object) replaced));
     }
 
     @Test
@@ -104,7 +104,7 @@ public void testInconsistentStackSizeAdvice() throws Exception {
                 .load(null, ClassLoadingStrategy.Default.CHILD_FIRST)
                 .getLoaded();
         assertThat(redefined, not(sameInstance((Object) foo)));
-        assertThat(redefined.getDeclaredMethod(FOO).invoke(redefined.newInstance()), is((Object) FOO));
+        assertThat(redefined.getDeclaredMethod(FOO).invoke(redefined.getConstructor().newInstance()), is((Object) FOO));
     }
 
     @SuppressWarnings("all")

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceJsrRetTest.java
Patch:
@@ -30,14 +30,14 @@ public void testJsrRetByteCodes() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER_PERSISTENT)
                 .getLoaded();
-        assertThat(type.getDeclaredMethod(FOO).invoke(type.newInstance()), is((Object) FOO));
+        assertThat(type.getDeclaredMethod(FOO).invoke(type.getConstructor().newInstance()), is((Object) FOO));
         Class<?> advised = new ByteBuddy()
                 .redefine(type)
                 .visit(Advice.to(JsrAdvice.class).on(named(FOO)))
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(advised.getDeclaredMethod(FOO).invoke(advised.newInstance()), is((Object) BAR));
+        assertThat(advised.getDeclaredMethod(FOO).invoke(advised.getConstructor().newInstance()), is((Object) BAR));
     }
 
     @SuppressWarnings("all")

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceNoRegularReturnTest.java
Patch:
@@ -51,7 +51,7 @@ public void testNoRegularReturnWithSkip() throws Exception {
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         try {
-            type.getDeclaredMethod(FOO).invoke(type.newInstance());
+            type.getDeclaredMethod(FOO).invoke(type.getConstructor().newInstance());
             fail();
         } catch (InvocationTargetException exception) {
             assertThat(exception.getCause(), instanceOf(RuntimeException.class));
@@ -67,7 +67,7 @@ public void testNoRegularReturnWithoutHandler() throws Exception {
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         try {
-            type.getDeclaredMethod(FOO).invoke(type.newInstance());
+            type.getDeclaredMethod(FOO).invoke(type.getConstructor().newInstance());
             fail();
         } catch (InvocationTargetException exception) {
             assertThat(exception.getCause(), instanceOf(RuntimeException.class));
@@ -83,7 +83,7 @@ public void testNoRegularReturnWithHandler() throws Exception {
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         try {
-            type.getDeclaredMethod(FOO).invoke(type.newInstance());
+            type.getDeclaredMethod(FOO).invoke(type.getConstructor().newInstance());
             fail();
         } catch (InvocationTargetException exception) {
             assertThat(exception.getCause(), instanceOf(RuntimeException.class));

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceNoRegularReturnWithinAdviceTest.java
Patch:
@@ -72,7 +72,7 @@ public void testNoRegularReturn() throws Exception {
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         try {
-            type.getDeclaredMethod(FOO).invoke(type.newInstance());
+            type.getDeclaredMethod(FOO).invoke(type.getConstructor().newInstance());
             fail();
         } catch (InvocationTargetException exception) {
             assertThat(exception.getCause(), instanceOf(RuntimeException.class));

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceSkipIfTrueTypeTest.java
Patch:
@@ -81,7 +81,7 @@ public void testAdvice() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(type.getDeclaredMethod(FOO).invoke(type.newInstance()), is(value));
+        assertThat(type.getDeclaredMethod(FOO).invoke(type.getConstructor().newInstance()), is(value));
     }
 
     @SuppressWarnings("unused")

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceSuppressionTest.java
Patch:
@@ -78,7 +78,7 @@ public void testIllegalAssignment() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.newInstance()), nullValue(Object.class));
+        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.getConstructor().newInstance()), nullValue(Object.class));
     }
 
     @SuppressWarnings("unused")

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTypeTest.java
Patch:
@@ -91,7 +91,7 @@ public void testAdvice() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(type.getDeclaredMethod(FOO, this.type, this.type).invoke(type.newInstance(), value, value), is((Object) value));
+        assertThat(type.getDeclaredMethod(FOO, this.type, this.type).invoke(type.getConstructor().newInstance(), value, value), is((Object) value));
         assertThat(type.getDeclaredField(ENTER).get(null), is((Object) 1));
         assertThat(type.getDeclaredField(EXIT).get(null), is((Object) 1));
     }
@@ -110,7 +110,7 @@ public void testAdviceWithException() throws Exception {
                 .getLoaded();
         type.getDeclaredField(exception).set(null, true);
         try {
-            assertThat(type.getDeclaredMethod(BAR, this.type, this.type).invoke(type.newInstance(), value, value), is((Object) value));
+            assertThat(type.getDeclaredMethod(BAR, this.type, this.type).invoke(type.getConstructor().newInstance(), value, value), is((Object) value));
             fail();
         } catch (InvocationTargetException exception) {
             assertThat(exception.getCause(), instanceOf(RuntimeException.class));
@@ -134,7 +134,7 @@ public void testAdviceWithProperty() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(type.getDeclaredMethod(FOO, this.type, this.type).invoke(type.newInstance(), value, value), is((Object) value));
+        assertThat(type.getDeclaredMethod(FOO, this.type, this.type).invoke(type.getConstructor().newInstance(), value, value), is((Object) value));
         assertThat(type.getDeclaredField(ENTER).get(null), is((Object) 1));
         assertThat(type.getDeclaredField(EXIT).get(null), is((Object) 1));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassInjectorUsingReflectionTest.java
Patch:
@@ -79,7 +79,7 @@ public void testInjectionOrderNoPrematureAuxiliaryInjection() throws Exception {
                 .intercept(MethodDelegation.to(Interceptor.class)).make()
                 .load(classLoader, ClassLoadingStrategy.Default.INJECTION)
                 .getLoaded();
-        assertThat(type.getDeclaredMethod(BAR, String.class).invoke(type.newInstance(), FOO), is((Object) BAR));
+        assertThat(type.getDeclaredMethod(BAR, String.class).invoke(type.getConstructor().newInstance(), FOO), is((Object) BAR));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategyTest.java
Patch:
@@ -212,7 +212,7 @@ public void testAnonymousType() throws Exception {
         Instrumentation instrumentation = ByteBuddyAgent.install();
         Class<?> factory = classLoader.loadClass(LAMBDA_SAMPLE_FACTORY);
         @SuppressWarnings("unchecked")
-        Callable<String> instance = (Callable<String>) factory.getDeclaredMethod("nonCapturing").invoke(factory.newInstance());
+        Callable<String> instance = (Callable<String>) factory.getDeclaredMethod("nonCapturing").invoke(factory.getConstructor().newInstance());
         // Anonymous types can only be reset to their original format, if a retransformation is applied.
         ClassReloadingStrategy classReloadingStrategy = new ClassReloadingStrategy(instrumentation,
                 ClassReloadingStrategy.Strategy.RETRANSFORMATION).preregistered(instance.getClass());

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultTest.java
Patch:
@@ -390,7 +390,7 @@ public void testTypeInLegacyConstantPoolRemapped() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.newInstance()), is((Object) Object.class));
+        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.getConstructor().newInstance()), is((Object) Object.class));
     }
 
     @Test
@@ -403,7 +403,7 @@ public void testArrayTypeInLegacyConstantPoolRemapped() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.newInstance()), is((Object) Object[].class));
+        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.getConstructor().newInstance()), is((Object) Object[].class));
     }
 
     @Test
@@ -416,7 +416,7 @@ public void testPrimitiveTypeInLegacyConstantPoolRemapped() throws Exception {
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.newInstance()), is((Object) int.class));
+        assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.getConstructor().newInstance()), is((Object) int.class));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilderTest.java
Patch:
@@ -161,7 +161,7 @@ public void testDefaultInterfaceSubInterface() throws Exception {
                 .make()
                 .load(dynamicInterfaceType.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(dynamicClassType.getMethod(FOO).invoke(dynamicClassType.newInstance()), is((Object) (FOO + BAR)));
+        assertThat(dynamicClassType.getMethod(FOO).invoke(dynamicClassType.getConstructor().newInstance()), is((Object) (FOO + BAR)));
         assertThat(dynamicInterfaceType.getDeclaredMethods().length, is(3));
         assertThat(dynamicClassType.getDeclaredMethods().length, is(0));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilderTest.java
Patch:
@@ -130,7 +130,7 @@ public void testDefaultInterfaceSubInterface() throws Exception {
                 .make()
                 .load(dynamicInterfaceType.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(dynamicClassType.getMethod(FOO).invoke(dynamicClassType.newInstance()), is((Object) BAR));
+        assertThat(dynamicClassType.getMethod(FOO).invoke(dynamicClassType.getConstructor().newInstance()), is((Object) BAR));
         assertThat(dynamicInterfaceType.getDeclaredMethods().length, is(1));
         assertThat(dynamicClassType.getDeclaredMethods().length, is(0));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ExceptionMethodTest.java
Patch:
@@ -23,7 +23,7 @@ public void testWithoutMessage() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(0));
-        Foo instance = loaded.getLoaded().newInstance();
+        Foo instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
         try {
@@ -42,7 +42,7 @@ public void testWithMessage() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(0));
-        Foo instance = loaded.getLoaded().newInstance();
+        Foo instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
         try {
@@ -61,7 +61,7 @@ public void testWithNonDeclaredCheckedException() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(0));
-        Foo instance = loaded.getLoaded().newInstance();
+        Foo instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
         try {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/FieldAccessorNonBeanTest.java
Patch:
@@ -20,7 +20,7 @@ public class FieldAccessorNonBeanTest extends AbstractImplementationTest {
     @Test
     public void testExplicitNameSetter() throws Exception {
         DynamicType.Loaded<SampleSetter> loaded = implement(SampleSetter.class, FieldAccessor.ofField(FOO));
-        SampleSetter sampleSetter = loaded.getLoaded().newInstance();
+        SampleSetter sampleSetter = loaded.getLoaded().getConstructor().newInstance();
         Field field = SampleSetter.class.getDeclaredField(FOO);
         field.setAccessible(true);
         assertThat(field.get(sampleSetter), is((Object) STRING_DEFAULT_VALUE));
@@ -32,7 +32,7 @@ public void testExplicitNameSetter() throws Exception {
     @Test
     public void testExplicitNameGetter() throws Exception {
         DynamicType.Loaded<SampleGetter> loaded = implement(SampleGetter.class, FieldAccessor.ofField(FOO));
-        SampleGetter sampleGetter = loaded.getLoaded().newInstance();
+        SampleGetter sampleGetter = loaded.getLoaded().getConstructor().newInstance();
         Field field = SampleGetter.class.getDeclaredField(FOO);
         field.setAccessible(true);
         assertThat(field.get(sampleGetter), is((Object) STRING_VALUE));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/FieldAccessorTest.java
Patch:
@@ -193,7 +193,7 @@ private <Z extends CallTraceable> void testGetter(Class<Z> target,
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(definesField ? 1 : 0));
-        Z instance = loaded.getLoaded().newInstance();
+        Z instance = loaded.getLoaded().getConstructor().newInstance();
         if (definesField) {
             initializeField(instance);
         }
@@ -214,7 +214,7 @@ private <Z extends CallTraceable> void testSetter(Class<Z> target,
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(definesField ? 1 : 0));
-        Z instance = loaded.getLoaded().newInstance();
+        Z instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(target)));
         assertThat(instance, instanceOf(target));
         Method setter = loaded.getLoaded()

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/FixedValueConstantPoolTypesTest.java
Patch:
@@ -86,7 +86,7 @@ public void testConstantPool() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(2));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(0));
-        T instance = loaded.getLoaded().newInstance();
+        T instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(StringTarget.class)));
         assertThat(instance, instanceOf(helperClass));
         assertThat(loaded.getLoaded().getDeclaredMethod(FOO).invoke(instance), is(fixedValue));
@@ -100,7 +100,7 @@ public void testStaticField() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(2));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(fixedValue == null ? 0 : 1));
-        T instance = loaded.getLoaded().newInstance();
+        T instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(StringTarget.class)));
         assertThat(instance, instanceOf(helperClass));
         assertThat(loaded.getLoaded().getDeclaredMethod(FOO).invoke(instance), is(fixedValue));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ForwardingTest.java
Patch:
@@ -23,7 +23,7 @@ public void testStaticInstanceForwarding() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(1));
-        Foo instance = loaded.getLoaded().newInstance();
+        Foo instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.foo(), is(BAR));
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
@@ -35,7 +35,7 @@ public void testInstanceFieldForwarding() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(1));
-        Foo instance = loaded.getLoaded().newInstance();
+        Foo instance = loaded.getLoaded().getConstructor().newInstance();
         Field field = loaded.getLoaded().getDeclaredField(FOO);
         field.setAccessible(true);
         field.set(instance, new Bar());
@@ -50,7 +50,7 @@ public void testStaticFieldForwarding() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(1));
-        Foo instance = loaded.getLoaded().newInstance();
+        Foo instance = loaded.getLoaded().getConstructor().newInstance();
         Field field = loaded.getLoaded().getDeclaredField(FOO);
         field.setAccessible(true);
         field.set(null, new Bar());

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodCallTypeTest.java
Patch:
@@ -105,7 +105,7 @@ public void testFieldConstantPool() throws Exception {
         assertThat(loaded.getLoaded().getDeclaredMethod(FOO, Object.class), not(nullValue(Method.class)));
         assertThat(loaded.getLoaded().getDeclaredConstructors().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(definesFieldConstantPool ? 1 : 0));
-        Foo instance = loaded.getLoaded().newInstance();
+        Foo instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
         assertThat(instance.foo(new Object()), is(value));
@@ -119,7 +119,7 @@ public void testFieldReference() throws Exception {
         assertThat(loaded.getLoaded().getDeclaredMethod(FOO, Object.class), not(nullValue(Method.class)));
         assertThat(loaded.getLoaded().getDeclaredConstructors().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(definesFieldReference ? 1 : 0));
-        Foo instance = loaded.getLoaded().newInstance();
+        Foo instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
         assertThat(instance.foo(new Object()), sameInstance(value));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationAllArgumentsTest.java
Patch:
@@ -16,7 +16,7 @@ public class MethodDelegationAllArgumentsTest extends AbstractImplementationTest
     @Test
     public void testStrictBindable() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, MethodDelegation.to(Bar.class));
-        Foo instance = loaded.getLoaded().newInstance();
+        Foo instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.foo(FOO, BAR), is((Object) (QUX + FOO + BAR)));
     }
 
@@ -28,14 +28,14 @@ public void testStrictNonBindableThrowsException() throws Exception {
     @Test
     public void testSlackNonBindable() throws Exception {
         DynamicType.Loaded<Qux> loaded = implement(Qux.class, MethodDelegation.to(BazSlack.class));
-        Qux instance = loaded.getLoaded().newInstance();
+        Qux instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.foo(FOOBAR, BAZ), is((Object) (QUX + BAZ)));
     }
 
     @Test
     public void testIncludeSelf() throws Exception {
         DynamicType.Loaded<Qux> loaded = implement(Qux.class, MethodDelegation.to(IncludeSelf.class));
-        Qux instance = loaded.getLoaded().newInstance();
+        Qux instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.foo(QUX, BAZ), is((Object) instance));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationBindingPriorityTest.java
Patch:
@@ -16,7 +16,7 @@ public class MethodDelegationBindingPriorityTest extends AbstractImplementationT
     @Test
     public void testBindingPriority() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, MethodDelegation.to(Bar.class));
-        Foo instance = loaded.getLoaded().newInstance();
+        Foo instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.foo(), is(FOO));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationChainedTest.java
Patch:
@@ -19,7 +19,7 @@ public void testChainingVoid() throws Exception {
         DynamicType.Loaded<Foo> dynamicType = implement(Foo.class, MethodDelegation.to(voidInterceptor)
                 .filter(isDeclaredBy(VoidInterceptor.class))
                 .andThen(new Implementation.Simple(new TextConstant(FOO), MethodReturn.REFERENCE)));
-        assertThat(dynamicType.getLoaded().newInstance().foo(), is(FOO));
+        assertThat(dynamicType.getLoaded().getConstructor().newInstance().foo(), is(FOO));
         assertThat(voidInterceptor.intercepted, is(true));
     }
 
@@ -29,7 +29,7 @@ public void testChainingNonVoid() throws Exception {
         DynamicType.Loaded<Foo> dynamicType = implement(Foo.class, MethodDelegation.to(nonVoidInterceptor)
                 .filter(isDeclaredBy(NonVoidInterceptor.class))
                 .andThen(new Implementation.Simple(new TextConstant(FOO), MethodReturn.REFERENCE)));
-        assertThat(dynamicType.getLoaded().newInstance().foo(), is(FOO));
+        assertThat(dynamicType.getLoaded().getConstructor().newInstance().foo(), is(FOO));
         assertThat(nonVoidInterceptor.intercepted, is(true));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationCheckedExceptionTest.java
Patch:
@@ -8,6 +8,7 @@ public class MethodDelegationCheckedExceptionTest extends AbstractImplementation
     public void testUndeclaredCheckedException() throws Exception {
         implement(Foo.class, MethodDelegation.to(Foo.class))
                 .getLoaded()
+                .getConstructor()
                 .newInstance()
                 .bar();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationConstructionTest.java
Patch:
@@ -96,7 +96,7 @@ public void testConstruction() throws Exception {
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(0));
-        T instance = loaded.getLoaded().newInstance();
+        T instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(sourceType)));
         assertThat(instance, instanceOf(sourceType));
         Object value = loaded.getLoaded().getDeclaredMethod(FOO, parameterTypes).invoke(instance, arguments);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationIgnoreForBindingTest.java
Patch:
@@ -14,7 +14,7 @@ public class MethodDelegationIgnoreForBindingTest extends AbstractImplementation
     @Test
     public void testIgnoreForBinding() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, MethodDelegation.to(Bar.class));
-        Foo instance = loaded.getLoaded().newInstance();
+        Foo instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.foo(), is(FOO));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationRuntimeTypeTest.java
Patch:
@@ -14,7 +14,7 @@ public class MethodDelegationRuntimeTypeTest extends AbstractImplementationTest
     @Test
     public void testRuntimeType() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, MethodDelegation.to(Bar.class));
-        Foo instance = loaded.getLoaded().newInstance();
+        Foo instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.foo(FOO), is(FOO));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationThisTest.java
Patch:
@@ -12,7 +12,7 @@ public class MethodDelegationThisTest extends AbstractImplementationTest {
     @Test
     public void testThis() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, MethodDelegation.to(Bar.class));
-        Foo instance = loaded.getLoaded().newInstance();
+        Foo instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.foo(), is((Object) instance));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/StubMethodTest.java
Patch:
@@ -118,7 +118,7 @@ public void testInstrumentedMethod() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, StubMethod.INSTANCE);
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(11));
-        Foo instance = loaded.getLoaded().newInstance();
+        Foo instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
         assertThat(loaded.getLoaded().getDeclaredMethod(methodName, methodParameterTypes)

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/SuperMethodCallOtherTest.java
Patch:
@@ -133,7 +133,7 @@ public void testNoSuper() throws Exception {
     public void testAndThen() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, SuperMethodCall.INSTANCE
                 .andThen(new Implementation.Simple(new TextConstant(FOO), MethodReturn.REFERENCE)));
-        Foo foo = loaded.getLoaded().newInstance();
+        Foo foo = loaded.getLoaded().getConstructor().newInstance();
         assertThat(foo.foo(), is(FOO));
         foo.assertOnlyCall(FOO);
     }
@@ -148,7 +148,7 @@ public void testUnambiguousDirectDefaultMethod() throws Exception {
                 Class.forName(SINGLE_DEFAULT_METHOD));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         Method method = loaded.getLoaded().getDeclaredMethod(FOO);
-        Object instance = loaded.getLoaded().newInstance();
+        Object instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(method.invoke(instance), is((Object) FOO));
     }
 
@@ -161,7 +161,7 @@ public void testInheritedDefaultMethod() throws Exception {
                 isMethod().and(not(isDeclaredBy(Object.class))));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         Method method = loaded.getLoaded().getDeclaredMethod(FOO);
-        Object instance = loaded.getLoaded().newInstance();
+        Object instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(method.invoke(instance), is((Object) FOO));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/SuperMethodCallTest.java
Patch:
@@ -100,7 +100,7 @@ public void testInstrumentedMethod() throws Exception {
         DynamicType.Loaded<Foo> loaded = implement(Foo.class, SuperMethodCall.INSTANCE);
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(11));
-        Foo instance = loaded.getLoaded().newInstance();
+        Foo instance = loaded.getLoaded().getConstructor().newInstance();
         assertThat(instance.getClass(), not(CoreMatchers.<Class<?>>is(Foo.class)));
         assertThat(instance, instanceOf(Foo.class));
         assertThat(loaded.getLoaded().getDeclaredMethod(methodName, methodParameterTypes)

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/MethodCallProxySingleArgumentTest.java
Patch:
@@ -69,7 +69,7 @@ public void testRunMethod() throws Exception {
         Class<?> auxiliaryType = proxyOnlyDeclaredMethodOf(targetType);
         Constructor<?> constructor = auxiliaryType.getDeclaredConstructor(targetType, valueType);
         constructor.setAccessible(true);
-        T proxiedInstance = targetType.newInstance();
+        T proxiedInstance = targetType.getConstructor().newInstance();
         ((Runnable) constructor.newInstance(proxiedInstance, value)).run();
         proxiedInstance.assertOnlyCall(FOO, value);
     }
@@ -79,7 +79,7 @@ public void testCallMethod() throws Exception {
         Class<?> auxiliaryType = proxyOnlyDeclaredMethodOf(targetType);
         Constructor<?> constructor = auxiliaryType.getDeclaredConstructor(targetType, valueType);
         constructor.setAccessible(true);
-        T proxiedInstance = targetType.newInstance();
+        T proxiedInstance = targetType.getConstructor().newInstance();
         assertThat(((Callable<?>) constructor.newInstance(proxiedInstance, value)).call(), is(value));
         proxiedInstance.assertOnlyCall(FOO, value);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDriverBinderParameterBinderForFixedValueOfConstantTest.java
Patch:
@@ -56,6 +56,7 @@ public void testConstant() throws Exception {
                 .make()
                 .load(Foo.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded()
+                .getConstructor()
                 .newInstance()
                 .foo(), is(value));
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -6146,7 +6146,7 @@ protected static class ExecutingTransformer implements ClassFileTransformer {
              * @param ignoredTypeMatcher         Identifies types that should not be instrumented.
              * @param transformation             The transformation object for handling type transformations.
              */
-            protected ExecutingTransformer(ByteBuddy byteBuddy,
+            public ExecutingTransformer(ByteBuddy byteBuddy,
                                            TypeLocator typeLocator,
                                            TypeStrategy typeStrategy,
                                            LocationStrategy locationStrategy,

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -7938,7 +7938,7 @@ public <T extends Annotation> WithCustomMapping bind(Class<? extends T> type, Se
          * @return A new builder for an advice that considers the supplied annotation during binding.
          */
         public <T extends Annotation> WithCustomMapping bindProperty(Class<? extends T> type, String property) {
-            return bind(type, DynamicValue.ForAnnotationProperty.of(type, property));
+            return bind(type, DynamicValue.ForAnnotationProperty.<T>of(type, property));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -305,17 +305,17 @@ public <T> DynamicType.Builder<T> subclass(TypeDefinition superType) {
     public <T> DynamicType.Builder<T> subclass(TypeDefinition superType, ConstructorStrategy constructorStrategy) {
         TypeDescription.Generic actualSuperType;
         TypeList.Generic interfaceTypes;
-        if (superType.isPrimitive() || superType.isArray() || superType.asErasure().isFinal()) {
+        if (superType.isPrimitive() || superType.isArray() || superType.isFinal()) {
             throw new IllegalArgumentException("Cannot subclass primitive, array or final types: " + superType);
-        } else if (superType.asErasure().isInterface()) {
+        } else if (superType.isInterface()) {
             interfaceTypes = new TypeList.Generic.Explicit(superType.asGenericType());
             actualSuperType = TypeDescription.Generic.OBJECT;
         } else {
             interfaceTypes = new TypeList.Generic.Empty();
             actualSuperType = superType.asGenericType();
         }
         return new SubclassDynamicTypeBuilder<T>(InstrumentedType.Default.subclass(namingStrategy.subclass(superType.asGenericType()),
-                ModifierContributor.Resolver.of(Visibility.PUBLIC, TypeManifestation.PLAIN).resolve(superType.asErasure().getModifiers()),
+                ModifierContributor.Resolver.of(Visibility.PUBLIC, TypeManifestation.PLAIN).resolve(superType.getModifiers()),
                 actualSuperType).withInterfaces(interfaceTypes),
                 classFileVersion,
                 auxiliaryTypeNamingStrategy,

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/ModifierReviewable.java
Patch:
@@ -112,7 +112,7 @@ interface OfEnumeration extends OfByteCodeElement {
     /**
      * A modifier reviewable for a {@link net.bytebuddy.description.type.TypeDescription}.
      */
-    interface ForTypeDescription extends OfAbstraction, OfEnumeration {
+    interface ForTypeDefinition extends OfAbstraction, OfEnumeration {
 
         /**
          * Specifies if the modifier described by this object represents the interface flag.
@@ -206,7 +206,7 @@ interface ForParameterDescription extends ModifierReviewable {
     /**
      * An abstract base implementation of a {@link ModifierReviewable} class.
      */
-    abstract class AbstractBase implements ForTypeDescription, ForFieldDescription, ForMethodDescription, ForParameterDescription {
+    abstract class AbstractBase implements ForTypeDefinition, ForFieldDescription, ForMethodDescription, ForParameterDescription {
 
         @Override
         public boolean isAbstract() {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -38,6 +38,7 @@
 public interface MethodDescription extends TypeVariableSource,
         ModifierReviewable.ForMethodDescription,
         NamedElement.WithGenericName,
+        ByteCodeElement,
         ByteCodeElement.TypeDependant<MethodDescription.InDefinedShape, MethodDescription.Token> {
 
     /**
@@ -458,7 +459,7 @@ public boolean isVirtual() {
 
         @Override
         public boolean isDefaultMethod() {
-            return !isAbstract() && !isBridge() && getDeclaringType().asErasure().isInterface();
+            return !isAbstract() && !isBridge() && getDeclaringType().isInterface();
         }
 
         @Override
@@ -648,7 +649,7 @@ private static boolean isAnnotationType(TypeDescription annotationType, Annotati
         public TypeVariableSource getEnclosingSource() {
             return isStatic()
                     ? TypeVariableSource.UNDEFINED
-                    : getDeclaringType().asErasure();
+                    : getDeclaringType();
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDefinition.java
Patch:
@@ -1,6 +1,8 @@
 package net.bytebuddy.description.type;
 
+import net.bytebuddy.description.ModifierReviewable;
 import net.bytebuddy.description.NamedElement;
+import net.bytebuddy.description.TypeVariableSource;
 import net.bytebuddy.description.field.FieldList;
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.implementation.bytecode.StackSize;
@@ -12,7 +14,7 @@
 /**
  * Implementations define a type, either as a {@link TypeDescription} or as a {@link TypeDescription.Generic}.
  */
-public interface TypeDefinition extends NamedElement, Iterable<TypeDefinition> {
+public interface TypeDefinition extends NamedElement, TypeVariableSource, ModifierReviewable.ForTypeDefinition, Iterable<TypeDefinition> {
 
     /**
      * Returns this type definition as a generic type.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -593,7 +593,7 @@ protected static class AttachedTypeVariable extends TypeDescription.Generic.OfTy
                      */
                     protected AttachedTypeVariable(TypeVariableSource typeVariableSource,
                                                    TypeVariableToken typeVariableToken,
-                                                   Visitor<? extends TypeDescription.Generic> visitor) {
+                                                   TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
                         this.typeVariableSource = typeVariableSource;
                         this.typeVariableToken = typeVariableToken;
                         this.visitor = visitor;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -757,7 +757,7 @@ public TypeDescription validated() {
                         throw new IllegalStateException("Illegal type annotations on type variable " + bound + " for " + this);
                     } else if (!bounds.add(bound)) {
                         throw new IllegalStateException("Duplicate bound " + bound + " of " + typeVariable + " for " + this);
-                    } else if (interfaceBound && (bound.getSort().isTypeVariable() || !bound.asErasure().isInterface())) {
+                    } else if (interfaceBound && (bound.getSort().isTypeVariable() || !bound.isInterface())) {
                         throw new IllegalStateException("Illegal interface bound " + bound + " of " + typeVariable + " for " + this);
                     }
                     interfaceBound = true;
@@ -829,7 +829,7 @@ public TypeDescription validated() {
                             throw new IllegalStateException("Illegal type annotations on bound " + bound + " of " + typeVariable + " for " + this);
                         } else if (!bounds.add(bound)) {
                             throw new IllegalStateException("Duplicate bound " + bound + " of " + typeVariable + " for " + methodDescription);
-                        } else if (interfaceBound && (bound.getSort().isTypeVariable() || !bound.asErasure().isInterface())) {
+                        } else if (interfaceBound && (bound.getSort().isTypeVariable() || !bound.isInterface())) {
                             throw new IllegalStateException("Illegal interface bound " + bound + " of " + typeVariable + " for " + methodDescription);
                         }
                         interfaceBound = true;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -1320,7 +1320,7 @@ protected Resolved(Harmonized<U> key, MethodDescription methodDescription, boole
                              */
                             private static <V> Entry<V> of(Harmonized<V> key, MethodDescription override, MethodDescription original) {
                                 return override.isBridge()
-                                        ? new Resolved<V>(key, original, (original.getDeclaringType().asErasure().getModifiers() & MADE_VISIBLE) == 0)
+                                        ? new Resolved<V>(key, original, (original.getDeclaringType().getModifiers() & MADE_VISIBLE) == 0)
                                         : new Resolved<V>(key, override, false);
                             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodRegistry.java
Patch:
@@ -510,7 +510,7 @@ public MethodRegistry.Prepared prepare(InstrumentedType instrumentedType,
                         && methodDescription.isPublic()
                         && !(methodDescription.isAbstract() || methodDescription.isFinal())
                         && !node.getSort().isMadeVisible()
-                        && methodDescription.getDeclaringType().asErasure().isPackagePrivate()) {
+                        && methodDescription.getDeclaringType().isPackagePrivate()) {
                     // Visibility bridges are required for public classes that inherit a public method from a package-private class.
                     implementations.put(methodDescription, Prepared.Entry.forVisibilityBridge(methodDescription));
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationAppender.java
Patch:
@@ -632,7 +632,7 @@ public static AnnotationAppender ofTypeVariable(AnnotationAppender annotationApp
                 for (AnnotationDescription annotationDescription : typeVariable.getDeclaredAnnotations()) {
                     annotationAppender = annotationAppender.append(annotationDescription, annotationValueFilter, typeReference, EMPTY_TYPE_PATH);
                 }
-                int boundIndex = !typeVariable.getUpperBounds().get(0).getSort().isTypeVariable() && typeVariable.getUpperBounds().get(0).asErasure().isInterface()
+                int boundIndex = !typeVariable.getUpperBounds().get(0).getSort().isTypeVariable() && typeVariable.getUpperBounds().get(0).isInterface()
                         ? 1
                         : 0;
                 for (TypeDescription.Generic typeBound : typeVariable.getUpperBounds()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
Patch:
@@ -1359,7 +1359,7 @@ protected static HandleType of(MethodDescription.InDefinedShape methodDescriptio
                     return INVOKE_SPECIAL;
                 } else if (methodDescription.isConstructor()) {
                     return INVOKE_SPECIAL_CONSTRUCTOR;
-                } else if (methodDescription.getDeclaringType().asErasure().isInterface()) {
+                } else if (methodDescription.getDeclaringType().isInterface()) {
                     return INVOKE_INTERFACE;
                 } else {
                     return INVOKE_VIRTUAL;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -21,6 +21,7 @@
  * {@code equal(Object)} and {@code hashCode()} implementations.
  */
 public interface FieldDescription extends ByteCodeElement,
+        ModifierReviewable.ForFieldDescription,
         NamedElement.WithGenericName,
         ByteCodeElement.TypeDependant<FieldDescription.InDefinedShape, FieldDescription.Token> {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.description.method;
 
 import net.bytebuddy.description.ByteCodeElement;
+import net.bytebuddy.description.ModifierReviewable;
 import net.bytebuddy.description.NamedElement;
 import net.bytebuddy.description.TypeVariableSource;
 import net.bytebuddy.description.annotation.AnnotationDescription;
@@ -35,6 +36,7 @@
  * interface must provide meaningful {@code equal(Object)} and {@code hashCode()} implementations.
  */
 public interface MethodDescription extends TypeVariableSource,
+        ModifierReviewable.ForMethodDescription,
         NamedElement.WithGenericName,
         ByteCodeElement.TypeDependant<MethodDescription.InDefinedShape, MethodDescription.Token> {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -25,7 +25,7 @@
 public interface ParameterDescription extends AnnotatedCodeElement,
         NamedElement.WithRuntimeName,
         NamedElement.WithOptionalName,
-        ModifierReviewable,
+        ModifierReviewable.ForParameterDescription,
         ByteCodeElement.TypeDependant<ParameterDescription.InDefinedShape, ParameterDescription.Token> {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.description.type;
 
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import net.bytebuddy.description.ModifierReviewable;
 import net.bytebuddy.description.TypeVariableSource;
 import net.bytebuddy.description.annotation.AnnotatedCodeElement;
 import net.bytebuddy.description.annotation.AnnotationDescription;
@@ -33,7 +34,7 @@
  * Implementations of this interface represent a Java type, i.e. a class or interface. Instances of this interface always
  * represent non-generic types of sort {@link Generic.Sort#NON_GENERIC}.
  */
-public interface TypeDescription extends TypeDefinition, TypeVariableSource {
+public interface TypeDescription extends TypeDefinition, TypeVariableSource, ModifierReviewable.ForTypeDescription {
 
     /**
      * A representation of the {@link java.lang.Object} type.

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ModifierReviewableTest.java
Patch:
@@ -22,7 +22,7 @@ public class ModifierReviewableTest {
 
     public ModifierReviewableTest(int modifiers, String methodName) throws Exception {
         simpleModifierReviewable = new SimpleModifierReviewable(modifiers);
-        method = ModifierReviewable.class.getDeclaredMethod(methodName);
+        method = ModifierReviewable.AbstractBase.class.getMethod(methodName);
     }
 
     @Parameterized.Parameters
@@ -42,13 +42,12 @@ public static Collection<Object[]> data() {
                 {Opcodes.ACC_PUBLIC, "isPublic"},
                 {Opcodes.ACC_STATIC, "isStatic"},
                 {Opcodes.ACC_STRICT, "isStrict"},
-                {Opcodes.ACC_SUPER, "isSuper"},
                 {Opcodes.ACC_SYNCHRONIZED, "isSynchronized"},
                 {Opcodes.ACC_SYNTHETIC, "isSynthetic"},
                 {Opcodes.ACC_TRANSIENT, "isTransient"},
                 {Opcodes.ACC_VARARGS, "isVarArgs"},
                 {Opcodes.ACC_VOLATILE, "isVolatile"},
-                {0, "isPackagePrivate"}
+                {ModifierReviewable.EMPTY_MASK, "isPackagePrivate"}
         });
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -1322,7 +1322,7 @@ public Entry<U> extendBy(MethodDescription methodDescription, Harmonizer<U> harm
 
                             @Override
                             public Entry<U> inject(Harmonized<U> key) {
-                                return new Resolved<U>(key.combineWith(key), methodDescription, madeVisible);
+                                return new Resolved<U>(this.key.combineWith(key), methodDescription, madeVisible);
                             }
 
                             @Override
@@ -1516,7 +1516,7 @@ public Entry<U> extendBy(MethodDescription methodDescription, Harmonizer<U> harm
 
                             @Override
                             public Entry<U> inject(Harmonized<U> key) {
-                                return new Ambiguous<U>(key.combineWith(key), methodDescriptions);
+                                return new Ambiguous<U>(this.key.combineWith(key), methodDescriptions);
                             }
 
                             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -14,6 +14,7 @@
 import org.objectweb.asm.MethodVisitor;
 
 import java.io.IOException;
+import java.io.Serializable;
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -1547,12 +1548,12 @@ public Object resolve(MethodDescription.InDefinedShape instrumentedMethod,
                                   boolean initialized) {
                 return null;
             }
-        }).bind(Custom.class, null);
+        }).bind(Custom.class, (Serializable) null);
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void testNotAnnotationType() throws Exception {
-        Advice.withCustomMapping().bind(Annotation.class, null);
+        Advice.withCustomMapping().bind(Annotation.class, (Serializable) null);
     }
 
     @Test(expected = IllegalStateException.class)

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -1792,7 +1792,7 @@ protected void onUserStart() {
 
                 @Override
                 protected void onUserReturn() {
-                    if (!instrumentedMethod.getReturnType().represents(void.class)) {
+                    if (!doesReturn || !instrumentedMethod.getReturnType().represents(void.class)) {
                         stackMapFrameHandler.injectCompletionFrame(methodVisitor, false);
                     }
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoader.java
Patch:
@@ -123,6 +123,7 @@ public ByteArrayClassLoader(ClassLoader parent,
      *                                  the {@code typeDefinitions}.
      * @return A corresponding class loader.
      */
+    @SuppressFBWarnings(value = "DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED", justification = "Privilege is explicit user responsibility")
     public static ClassLoader of(ClassLoader parent,
                                  Map<TypeDescription, byte[]> typeDefinitions,
                                  ProtectionDomain protectionDomain,

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -291,7 +291,7 @@ private static void install(AttachmentProvider attachmentProvider, String proces
      *
      * @return The Byte Buddy agent's {@link java.lang.instrument.Instrumentation} instance.
      */
-    @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Legal state where reflection communicates errors by exception")
+    @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Legal outcome where reflection communicates errors by throwing an exception")
     private static Instrumentation doGetInstrumentation() {
         try {
             return (Instrumentation) ClassLoader.getSystemClassLoader()
@@ -306,7 +306,7 @@ private static Instrumentation doGetInstrumentation() {
     /**
      * An attachment provider is responsible for making the Java attachment API available.
      */
-    @SuppressFBWarnings(value = "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION", justification = "No circularity, initialization is safe")
+    @SuppressFBWarnings(value = "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION", justification = "Safe initialization is implied")
     public interface AttachmentProvider {
 
         /**
@@ -558,7 +558,7 @@ enum ForToolsJarVm implements AttachmentProvider {
             }
 
             @Override
-            @SuppressFBWarnings(value = "DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED", justification = "Privilege should be provided by user")
+            @SuppressFBWarnings(value = "DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED", justification = "Privilege is explicit user responsibility")
             public Accessor attempt() {
                 File toolsJar = new File(System.getProperty(JAVA_HOME_PROPERTY).replace('\\', '/') + "/../" + toolsJarPath);
                 try {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -4155,7 +4155,7 @@ public int hashCode() {
             }
 
             @Override
-            @SuppressFBWarnings(value = "EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS", justification = "Type check is performed by erasure instance")
+            @SuppressFBWarnings(value = "EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS", justification = "Type check is performed by erasure implementation")
             public boolean equals(Object other) {
                 return asErasure().equals(other);
             }
@@ -4467,7 +4467,7 @@ public StackSize getStackSize() {
             }
 
             @Override
-            @SuppressFBWarnings(value = "EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS", justification = "Type check is performed by erasure instance")
+            @SuppressFBWarnings(value = "EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS", justification = "Type check is performed by erasure implementation")
             public boolean equals(Object other) {
                 if (getSort().isNonGeneric()) {
                     return asErasure().equals(other);

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -28,7 +28,7 @@ public interface TypeList extends FilterableList<TypeDescription, TypeList> {
     /**
      * Represents that a type list does not contain any values for ASM interoperability which is represented by {@code null}.
      */
-    @SuppressFBWarnings(value = {"MS_MUTABLE_ARRAY", "MS_OOI_PKGPROTECT"}, justification = "value is null and should be available to extensions")
+    @SuppressFBWarnings(value = {"MS_MUTABLE_ARRAY", "MS_OOI_PKGPROTECT"}, justification = "Value is null")
     String[] NO_INTERFACES = null;
 
     /**
@@ -178,7 +178,7 @@ public int getStackSize() {
     class Empty extends FilterableList.Empty<TypeDescription, TypeList> implements TypeList {
 
         @Override
-        @SuppressFBWarnings(value = "EI_EXPOSE_REP", justification = "Return value is always null")
+        @SuppressFBWarnings(value = "EI_EXPOSE_REP", justification = "Value is null")
         public String[] toInternalNames() {
             return NO_INTERFACES;
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -4259,7 +4259,7 @@ class Default implements DynamicType {
          * @param loadedTypeInitializer The loaded type initializer of this dynamic type.
          * @param auxiliaryTypes        The auxiliary type required for this dynamic type.
          */
-        @SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "The received value is never modified by contract")
+        @SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "The array is not to be modified by contract")
         public Default(TypeDescription typeDescription,
                        byte[] binaryRepresentation,
                        LoadedTypeInitializer loadedTypeInitializer,
@@ -4306,7 +4306,7 @@ public boolean hasAliveLoadedTypeInitializers() {
         }
 
         @Override
-        @SuppressFBWarnings(value = "EI_EXPOSE_REP", justification = "Return value must never be modified")
+        @SuppressFBWarnings(value = "EI_EXPOSE_REP", justification = "The array is not to be modified by contract")
         public byte[] getBytes() {
             return binaryRepresentation;
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -429,7 +429,7 @@ public Package definePackage(ClassLoader classLoader,
                 }
 
                 @Override
-                @SuppressFBWarnings(value = "DP_DO_INSIDE_DO_PRIVILEGED", justification = "Privileges should be provided by user")
+                @SuppressFBWarnings(value = "DP_DO_INSIDE_DO_PRIVILEGED", justification = "Privilege is explicit user responsibility")
                 public Dispatcher initialize() {
                     // This is safe even in a multi-threaded environment as all threads set the instances accessible before invoking any methods.
                     // By always setting accessability, the security manager is always triggered if this operation was illegal.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -447,7 +447,7 @@ protected ClassRedefinitionTransformer(Map<Class<?>, ClassDefinition> redefinedC
             }
 
             @Override
-            @SuppressFBWarnings(value = "EI_EXPOSE_REP", justification = "Return value is always null")
+            @SuppressFBWarnings(value = "EI_EXPOSE_REP", justification = "Value is always null")
             public byte[] transform(ClassLoader classLoader,
                                     String internalTypeName,
                                     Class<?> classBeingRedefined,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/MultipleParentClassLoader.java
Patch:
@@ -412,6 +412,7 @@ public Builder filter(ElementMatcher<? super ClassLoader> matcher) {
          *
          * @return A suitable class loader.
          */
+        @SuppressFBWarnings(value = "DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED", justification = "Privilege is explicit user responsibility")
         public ClassLoader build() {
             return classLoaders.size() == 1
                     ? classLoaders.get(ONLY)

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -387,7 +387,7 @@ public String toString() {
     /**
      * A compiler to produce a {@link MethodGraph} from a given type.
      */
-    @SuppressFBWarnings(value = "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION", justification = "No circularity, initialization is safe")
+    @SuppressFBWarnings(value = "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION", justification = "Safe initialization is implied")
     interface Compiler {
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/AuxiliaryType.java
Patch:
@@ -26,8 +26,7 @@ public interface AuxiliaryType {
     /**
      * The default type access of an auxiliary type. <b>This array must not be mutated</b>.
      */
-    @SuppressFBWarnings(value = {"MS_MUTABLE_ARRAY", "MS_OOI_PKGPROTECT"},
-            justification = "Favor simplicity with current API in overall immutable library layout - value should be accessible to extensions")
+    @SuppressFBWarnings(value = {"MS_MUTABLE_ARRAY", "MS_OOI_PKGPROTECT"}, justification = "The array is not to be modified by contract")
     ModifierContributor.ForType[] DEFAULT_TYPE_MODIFIER = {SyntheticState.SYNTHETIC};
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/MethodDelegationBinder.java
Patch:
@@ -599,7 +599,7 @@ public String toString() {
      * Implementations of this interface are able to attempt the resolution of two successful bindings of a method
      * to two different target methods in order to identify a dominating binding.
      */
-    @SuppressFBWarnings(value = "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION", justification = "No circularity, initialization is safe")
+    @SuppressFBWarnings(value = "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION", justification = "Safe initialization is implied")
     interface AmbiguityResolver {
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -358,7 +358,7 @@ public String toString() {
              * {@link net.bytebuddy.implementation.bind.annotation.Pipe.Binder.Redirection}'s
              * constructor.
              */
-            @SuppressFBWarnings(value = "SE_BAD_FIELD", justification = "Enumerations are not serialized by field")
+            @SuppressFBWarnings(value = "SE_BAD_FIELD", justification = "Fields of enumerations are never serialized")
             protected enum ConstructorCall implements Implementation {
 
                 /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -144,7 +144,7 @@ public String toString() {
      *
      * @param <T> The {@link java.lang.annotation.Annotation#annotationType()} handled by this parameter binder.
      */
-    @SuppressFBWarnings(value = "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION", justification = "No circularity, initialization is safe")
+    @SuppressFBWarnings(value = "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION", justification = "Safe initialization is implied")
     public interface ParameterBinder<T extends Annotation> {
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/Assigner.java
Patch:
@@ -13,7 +13,7 @@
  * An assigner is for example responsible for type casting, auto boxing or unboxing or for the widening of primitive
  * types.
  */
-@SuppressFBWarnings(value = "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION", justification = "No circularity, initialization is safe")
+@SuppressFBWarnings(value = "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION", justification = "Safe initialization is implied")
 public interface Assigner {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -7118,7 +7118,6 @@ private class LazyMethodDescription extends MethodDescription.InDefinedShape.Abs
                  *                                          class was corrupt.
                  * @param defaultValue                      The default value of this method or {@code null} if there is no
                  */
-                @SuppressFBWarnings(value = "URF_UNREAD_FIELD", justification = "To be removed once type annotations are in place")
                 private LazyMethodDescription(String internalName,
                                               int modifiers,
                                               String methodDescriptor,
@@ -7643,7 +7642,7 @@ protected TypeExtractor() {
             }
 
             @Override
-            @SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "The received value is never modified")
+            @SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "The array is not to be modified by contract")
             public void visit(int classFileVersion,
                               int modifiers,
                               String internalName,

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -742,12 +742,11 @@ protected ForJava9CapableVm(Method current, Method getPid) {
                  *
                  * @return A dispatcher for the current VM.
                  */
+                @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but trigger a fallback")
                 public static ProcessProvider make() {
                     try {
                         return new ForJava9CapableVm(Class.forName("java.lang.ProcessHandle").getDeclaredMethod("current"),
                                 Class.forName("java.lang.ProcessHandle").getDeclaredMethod("getPid"));
-                    } catch (RuntimeException exception) {
-                        throw exception;
                     } catch (Exception ignored) {
                         return ForLegacyVm.INSTANCE;
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -79,7 +79,7 @@ public class ClassFileVersion implements Comparable<ClassFileVersion> {
      *
      * @return An appropriate version locator.
      */
-    @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception not supposed to be rethrown")
+    @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but trigger a fallback")
     private static VersionLocator findVersionLocator() {
         try {
             return new VersionLocator.ForJava9CapableVm(Runtime.class.getDeclaredMethod("version"),
@@ -168,7 +168,7 @@ public static ClassFileVersion forCurrentJavaVersion() {
      * @param fallback The version to fallback to if locating a class file version is not possible.
      * @return The currently running Java process's class file version or the fallback if locating this version is impossible.
      */
-    @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception is not supposed to be rethrown")
+    @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but trigger a fallback")
     public static ClassFileVersion forCurrentJavaVersion(ClassFileVersion fallback) {
         try {
             return forCurrentJavaVersion();

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/NexusAccessor.java
Patch:
@@ -86,7 +86,7 @@ public enum NexusAccessor implements PrivilegedAction<NexusAccessor.Dispatcher>
     }
 
     @Override
-    @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Explicit delegation of the exception")
+    @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but trigger a fallback")
     public Dispatcher run() {
         try {
             TypeDescription nexusType = new TypeDescription.ForLoadedType(Nexus.class);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/MultipleParentClassLoader.java
Patch:
@@ -135,7 +135,7 @@ protected Active(Method loadClass) {
              *
              * @return A dispatcher for invoking the {@link ClassLoader#loadClass(String, boolean)} method.
              */
-            @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception is not meant to be rethrown")
+            @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Exception should not be rethrown but trigger a fallback")
             protected static Dispatcher make() {
                 try {
                     return AccessController.doPrivileged(new Active(ClassLoader.class.getDeclaredMethod("loadClass", String.class, boolean.class)));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1612,7 +1612,7 @@ public static <U> TypeWriter<U> forRebasing(MethodRegistry.Prepared methodRegist
         }
 
         @Override
-        @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Setting a debugging property should not change program outcome")
+        @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Setting a debugging property should never change the program outcome")
         public DynamicType.Unloaded<S> make(TypeResolutionStrategy.Resolved typeResolutionStrategy) {
             UnresolvedType unresolvedType = create(typeResolutionStrategy.injectedInto(typeInitializer));
             if (DUMP_FOLDER != null) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/LoadedTypeInitializer.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.implementation;
 
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import net.bytebuddy.utility.privilege.AccessAction;
+import net.bytebuddy.utility.privilege.SetAccessibleAction;
 
 import java.io.Serializable;
 import java.lang.reflect.Field;
@@ -100,7 +100,7 @@ public void onLoad(Class<?> type) {
             try {
                 Field field = type.getDeclaredField(fieldName);
                 if (!Modifier.isPublic(field.getModifiers()) || !Modifier.isPublic(field.getDeclaringClass().getModifiers())) {
-                    AccessAction.apply(field, AccessController.getContext());
+                    AccessController.doPrivileged(new SetAccessibleAction<Field>(field));
                 }
                 field.set(STATIC_FIELD, value);
             } catch (IllegalAccessException exception) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -1279,6 +1279,7 @@ public AccessControlContext create() {
                 return new AccessControlContext(new ProtectionDomain[]{mock(ProtectionDomain.class)});
             }
         }).apply();
+        ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.InheritanceAction.class);
         final Iterator<Class<?>> execution = Arrays.<Class<?>>asList(Object.class, String.class, Integer.class, Double.class, Float.class).iterator();
         ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.ExecutionDispatcher.class).create(new ObjectPropertyAssertion.Creator<AccessControlContext>() {
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaConstantMethodHandleDispatcherTest.java
Patch:
@@ -5,7 +5,6 @@
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
-import java.security.AccessController;
 import java.util.Arrays;
 import java.util.Iterator;
 
@@ -15,7 +14,7 @@ public class JavaConstantMethodHandleDispatcherTest {
 
     @Test(expected = IllegalStateException.class)
     public void testLegacyVmInitialization() throws Exception {
-        JavaConstant.MethodHandle.Dispatcher.ForLegacyVm.INSTANCE.initialize(AccessController.getContext());
+        JavaConstant.MethodHandle.Dispatcher.ForLegacyVm.INSTANCE.initialize();
     }
 
     @Test(expected = IllegalStateException.class)
@@ -38,7 +37,7 @@ public Method create() {
             }
         }).apply();
         final Iterator<Method> methods2 = Arrays.asList(Foo.class.getDeclaredMethods()).iterator();
-        final Iterator<Constructor<?>> constructors2 = Arrays.asList(Foo.class.getDeclaredConstructors()).iterator();
+        final Iterator<Constructor<?>> constructors2 = Arrays.<Constructor<?>>asList(Foo.class.getDeclaredConstructors()).iterator();
         ObjectPropertyAssertion.of(JavaConstant.MethodHandle.Dispatcher.ForJava7CapableVm.class).create(new ObjectPropertyAssertion.Creator<Method>() {
             @Override
             public Method create() {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3265,6 +3265,9 @@ public void visit(int classFileVersionNumber,
                             classFileVersion,
                             ForInlining.this.classFileVersion);
                     contextRegistry.setImplementationContext(implementationContext);
+                    if (!classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8) && instrumentedType.isInterface()) {
+                        implementationContext.prohibitTypeInitializer();
+                    }
                     super.visit(classFileVersionNumber,
                             instrumentedType.getActualModifiers((modifiers & Opcodes.ACC_SUPER) != 0 && !instrumentedType.isInterface()),
                             instrumentedType.getInternalName(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/CompoundList.java
Patch:
@@ -72,8 +72,8 @@ public static <S> List<S> of(List<? extends S> left, List<? extends S> right) {
     public T get(int index) {
         int leftSize = left.size();
         return leftSize - index > 0
-                ? left.get(index)
-                : right.get(index - leftSize);
+                ? (T) left.get(index)
+                : (T) right.get(index - leftSize);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDefaultTest.java
Patch:
@@ -267,7 +267,6 @@ public void setUp() throws Exception {
         when(firstSpecialType.asErasure()).thenReturn(firstSpecialType);
         when(secondSpecialMethod.getDeclaringType()).thenReturn(secondSpecialType);
         when(secondSpecialType.asErasure()).thenReturn(secondSpecialType);
-        when(classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8)).thenReturn(true);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDisabledTest.java
Patch:
@@ -78,8 +78,9 @@ public void testAuxiliaryTypes() throws Exception {
     }
 
     @Test
-    public void testIsRetainTypeInitializer() throws Exception {
+    public void testFreezeHasNoEffect() throws Exception {
         Implementation.Context.ExtractableView implementationContext = new Implementation.Context.Disabled(instrumentedType, classFileVersion);
+        implementationContext.prohibitTypeInitializer();
         assertThat(implementationContext.isRetainTypeInitializer(), is(true));
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3265,9 +3265,6 @@ public void visit(int classFileVersionNumber,
                             classFileVersion,
                             ForInlining.this.classFileVersion);
                     contextRegistry.setImplementationContext(implementationContext);
-                    if (!classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8) && instrumentedType.isInterface()) {
-                        implementationContext.prohibitTypeInitializer();
-                    }
                     super.visit(classFileVersionNumber,
                             instrumentedType.getActualModifiers((modifiers & Opcodes.ACC_SUPER) != 0 && !instrumentedType.isInterface()),
                             instrumentedType.getInternalName(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDefaultTest.java
Patch:
@@ -267,6 +267,7 @@ public void setUp() throws Exception {
         when(firstSpecialType.asErasure()).thenReturn(firstSpecialType);
         when(secondSpecialMethod.getDeclaringType()).thenReturn(secondSpecialType);
         when(secondSpecialType.asErasure()).thenReturn(secondSpecialType);
+        when(classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8)).thenReturn(true);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDisabledTest.java
Patch:
@@ -78,9 +78,8 @@ public void testAuxiliaryTypes() throws Exception {
     }
 
     @Test
-    public void testFreezeHasNoEffect() throws Exception {
+    public void testIsRetainTypeInitializer() throws Exception {
         Implementation.Context.ExtractableView implementationContext = new Implementation.Context.Disabled(instrumentedType, classFileVersion);
-        implementationContext.prohibitTypeInitializer();
         assertThat(implementationContext.isRetainTypeInitializer(), is(true));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultTest.java
Patch:
@@ -472,8 +472,9 @@ public void testBridgeNonLegacyType() throws Exception {
     @Test
     public void testNoBridgeLegacyType() throws Exception {
         Class<?> base = new ByteBuddy(ClassFileVersion.JAVA_V4)
-                .subclass(Object.class)
+                .subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS)
                 .modifiers(Visibility.PACKAGE_PRIVATE)
+                .defineConstructor(Visibility.PUBLIC).intercept(SuperMethodCall.INSTANCE)
                 .defineMethod("foo", void.class, Visibility.PUBLIC).intercept(StubMethod.INSTANCE)
                 .defineMethod("bar", Object.class).intercept(StubMethod.INSTANCE)
                 .defineMethod("bar", String.class).intercept(StubMethod.INSTANCE)

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterModifierPreservationTest.java
Patch:
@@ -3,6 +3,7 @@
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.asm.AsmVisitorWrapper;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.test.scope.EnclosingType;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -54,7 +55,7 @@ public TypeWriterModifierPreservationTest(Class<?> type) {
     @Test
     public void testModifiers() throws Exception {
         TypeModifierExtractor typeModifierExtractor = new TypeModifierExtractor();
-        new ClassReader(type.getName()).accept(typeModifierExtractor, 0);
+        new ClassReader(ClassFileLocator.ForClassLoader.read(type).resolve()).accept(typeModifierExtractor, 0);
         new ByteBuddy()
                 .redefine(type)
                 .visit(new TypeValidator.Wrapper(typeModifierExtractor))

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/CompoundListTest.java
Patch:
@@ -5,7 +5,6 @@
 import org.junit.Test;
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
-import org.omg.CORBA.Object;
 
 import java.util.Arrays;
 import java.util.List;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1736,10 +1736,11 @@ private Default getOuter() {
             }
 
             @Override
+            @SuppressWarnings("unchecked")
             public boolean equals(Object object) {
                 if (this == object) return true;
                 if (object == null || getClass() != object.getClass()) return false;
-                Default<?>.UnresolvedType that = (Default<?>.UnresolvedType) object;
+                UnresolvedType that = (UnresolvedType) object; // Java 6 compilers cannot cast to nested wildcard.
                 return Arrays.equals(binaryRepresentation, that.binaryRepresentation)
                         && Default.this.equals(that.getOuter())
                         && auxiliaryTypes.equals(that.auxiliaryTypes);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3090,6 +3090,7 @@ public void setImplementationContext(Implementation.Context.ExtractableView impl
                  *
                  * @return The auxiliary types that were registered during class creation
                  */
+                @SuppressFBWarnings(value = "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR", justification = "Lazy value definition is intended")
                 public List<DynamicType> getAuxiliaryTypes() {
                     return implementationContext.getAuxiliaryTypes();
                 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultApplicationTest.java
Patch:
@@ -64,7 +64,7 @@ public class AgentBuilderDefaultApplicationTest {
     @Parameterized.Parameters
     public static Collection<Object[]> data() {
         // Travis runs out of memory if all of these tests are run. This property serves as a protection (on some profiles).
-        if (Boolean.getBoolean("net.bytebuddy.travis")) {
+        if (Boolean.getBoolean("net.bytebuddy.test.travis")) {
             Logger.getLogger("net.bytebuddy").info("Only running agent application with a single type locator on Travis CI server");
             return Arrays.asList(new Object[][]{{AgentBuilder.TypeLocator.Default.FAST}});
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/IntegrationRule.java
Patch:
@@ -10,7 +10,7 @@
 
 public class IntegrationRule implements MethodRule {
 
-    private static final String PROPERTY_KEY = "net.bytebuddy.property.integration";
+    private static final String PROPERTY_KEY = "net.bytebuddy.test.integration";
 
     private final boolean integration;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -7796,7 +7796,7 @@ public <T extends Annotation> WithCustomMapping bind(Class<? extends T> type, Dy
             if (!type.isAnnotation()) {
                 throw new IllegalArgumentException("Not an annotation type: " + type);
             } else if (dynamicValues.put(type, dynamicValue) != null) {
-                throw new IllegalArgumentException("Annotation-type already mapped: " + type);
+                throw new IllegalArgumentException("Annotation type already mapped: " + type);
             }
             return new WithCustomMapping(dynamicValues);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/StackAwareMethodVisitor.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.utility;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.implementation.bytecode.StackSize;
 import org.objectweb.asm.*;
@@ -171,6 +172,7 @@ public void visitIntInsn(int opcode, int operand) {
     }
 
     @Override
+    @SuppressFBWarnings(value = "SF_SWITCH_NO_DEFAULT", justification = "No default behavior is applied")
     public void visitVarInsn(int opcode, int variable) {
         switch (opcode) {
             case Opcodes.ASTORE:

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3098,6 +3098,9 @@ public void visit(int classFileVersionNumber,
                 public void visitInnerClass(String internalName, String outerName, String innerName, int modifiers) {
                     if (internalName.equals(instrumentedType.getInternalName())) {
                         modifiers = instrumentedType.getModifiers();
+                        if (instrumentedType.isAnonymousClass()) {
+                            modifiers = modifiers | Opcodes.ACC_STATIC;
+                        }
                     }
                     super.visitInnerClass(internalName, outerName, innerName, modifiers);
                 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -2576,7 +2576,6 @@ private static void enter(@Advice.Origin("#t #m #d #r #s") String origin, @Advic
         @Advice.OnMethodExit
         private static void exit(@Advice.Origin("\\#\\#\\\\#m") String origin, @Advice.Origin Class<?> type) throws Exception {
             if (!origin.equals("##\\" + FOO)) {
-                System.out.println(origin);
                 throw new AssertionError();
             }
             if (type != Sample.class) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultLazyObjectPropertiesTest.java
Patch:
@@ -133,8 +133,8 @@ public void testGenericTypeTokenObjectPropertiesTest() throws Exception {
 
     @Test
     public void testDeclarationContextObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(TypePool.Default.LazyTypeDescription.DeclarationContext.DeclaredInType.class).apply();
-        ObjectPropertyAssertion.of(TypePool.Default.LazyTypeDescription.DeclarationContext.DeclaredInMethod.class).apply();
-        ObjectPropertyAssertion.of(TypePool.Default.LazyTypeDescription.DeclarationContext.SelfDeclared.class).apply();
+        ObjectPropertyAssertion.of(TypePool.Default.LazyTypeDescription.TypeContainment.WithinType.class).apply();
+        ObjectPropertyAssertion.of(TypePool.Default.LazyTypeDescription.TypeContainment.WithinMethod.class).apply();
+        ObjectPropertyAssertion.of(TypePool.Default.LazyTypeDescription.TypeContainment.SelfContained.class).apply();
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -7645,7 +7645,7 @@ public void visitOuterClass(String typeName, String methodName, String methodDes
             @Override
             public void visitInnerClass(String internalName, String outerName, String innerName, int modifiers) {
                 if (internalName.equals(this.internalName)) {
-                    this.modifiers = modifiers & REAL_MODIFIER_MASK;
+                    this.modifiers = (this.modifiers & ~Opcodes.ACC_PUBLIC) | (modifiers & REAL_MODIFIER_MASK);
                     if (innerName == null) {
                         anonymousType = true;
                     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -8,7 +8,6 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
-import net.bytebuddy.test.utility.DebuggingWrapper;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 import org.objectweb.asm.ClassReader;
@@ -1200,7 +1199,6 @@ public Object resolve(MethodDescription.InDefinedShape instrumentedMethod,
     public void testSkipInstrumentedMethod() throws Exception {
         Class<?> type = new ByteBuddy()
                 .redefine(SkipIfTrueAdvice.class)
-                .visit(DebuggingWrapper.makeDefault(true))
                 .visit(Advice.to(SkipIfTrueAdvice.class).on(named(FOO)))
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceSkipIfTrueTypeTest.java
Patch:
@@ -18,6 +18,8 @@ public class AdviceSkipIfTrueTypeTest {
 
     private static final String FOO = "foo";
 
+    // TODO: Reinstate!
+
     @Parameterized.Parameters
     public static Collection<Object[]> data() {
         return Arrays.asList(new Object[][]{

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -8,6 +8,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
+import net.bytebuddy.test.utility.DebuggingWrapper;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 import org.objectweb.asm.ClassReader;
@@ -1199,6 +1200,7 @@ public Object resolve(MethodDescription.InDefinedShape instrumentedMethod,
     public void testSkipInstrumentedMethod() throws Exception {
         Class<?> type = new ByteBuddy()
                 .redefine(SkipIfTrueAdvice.class)
+                .visit(DebuggingWrapper.makeDefault(true))
                 .visit(Advice.to(SkipIfTrueAdvice.class).on(named(FOO)))
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultApplicationTest.java
Patch:
@@ -341,7 +341,7 @@ public void testRedefinitionWithPoolLast() throws Exception {
     }
 
     @Test
-    @AgentAttachmentRule.Enforce(retransformsClasses = true)
+    @AgentAttachmentRule.Enforce(redefinesClasses = true)
     public void testRedefinitionWithPoolLastOptionalType() throws Exception {
         // Type descriptions with optional dependencies cannot be resolved eagerly.
         if (typeLocator instanceof AgentBuilder.TypeLocator.Eager) {
@@ -375,7 +375,7 @@ public void testRedefinitionWithPoolLastOptionalType() throws Exception {
     }
 
     @Test
-    @AgentAttachmentRule.Enforce(retransformsClasses = true)
+    @AgentAttachmentRule.Enforce(redefinesClasses = true)
     public void testRedefinitionWithPoolOnlyOptionalType() throws Exception {
         // Type descriptions with optional dependencies cannot be resolved eagerly.
         if (typeLocator instanceof AgentBuilder.TypeLocator.Eager) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodListForLoadedTypesTest.java
Patch:
@@ -18,7 +18,7 @@ protected Method getSecond() throws Exception {
 
     @Override
     protected MethodList<MethodDescription.InDefinedShape> asList(List<Method> elements) {
-        return new MethodList.ForLoadedType(new Constructor<?>[0], elements.toArray(new Method[elements.size()]));
+        return new MethodList.ForLoadedMethods(new Constructor<?>[0], elements.toArray(new Method[elements.size()]));
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ExceptionMethodTest.java
Patch:
@@ -80,13 +80,13 @@ public void testEqualsHashCode() throws Exception {
         ObjectPropertyAssertion.of(ExceptionMethod.ConstructionDelegate.ForDefaultConstructor.class).refine(new ObjectPropertyAssertion.Refinement<TypeDescription>() {
             @Override
             public void apply(TypeDescription mock) {
-                when(mock.getDeclaredMethods()).thenReturn(new MethodList.ForLoadedType(Object.class));
+                when(mock.getDeclaredMethods()).thenReturn(new MethodList.ForLoadedMethods(Object.class));
             }
         }).apply();
         ObjectPropertyAssertion.of(ExceptionMethod.ConstructionDelegate.ForStringConstructor.class).refine(new ObjectPropertyAssertion.Refinement<TypeDescription>() {
             @Override
             public void apply(TypeDescription mock) {
-                when(mock.getDeclaredMethods()).thenReturn(new MethodList.ForLoadedType(String.class));
+                when(mock.getDeclaredMethods()).thenReturn(new MethodList.ForLoadedMethods(String.class));
             }
         }).apply();
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -4616,7 +4616,7 @@ protected Factory(TypeDescription triggeringThrowable, boolean readOnly) {
                      * @param readOnly     {@code true} if the parameter is read-only.
                      * @return An appropriate offset mapping factory.
                      */
-                    @SuppressWarnings("all") // In absence of @SafeVarargs for Java 6
+                    @SuppressWarnings("unchecked") // In absence of @SafeVarargs for Java 6
                     protected static OffsetMapping.Factory of(MethodDescription.InDefinedShape adviceMethod, boolean readOnly) {
                         TypeDescription triggeringThrowable = adviceMethod.getDeclaredAnnotations()
                                 .ofType(OnMethodExit.class)
@@ -5805,7 +5805,7 @@ protected static class ForMethodEnter extends Inlining.Resolved implements Dispa
                      * @param userFactories A list of user-defined factories for offset mappings.
                      * @param classReader   A class reader to query for the class file of the advice method.
                      */
-                    @SuppressWarnings("all") // In absence of @SafeVarargs for Java 6
+                    @SuppressWarnings("unchecked") // In absence of @SafeVarargs for Java 6
                     protected ForMethodEnter(MethodDescription.InDefinedShape adviceMethod,
                                              List<? extends OffsetMapping.Factory> userFactories,
                                              ClassReader classReader) {
@@ -6967,7 +6967,7 @@ protected static class ForMethodEnter extends Delegating.Resolved<Bound.ForMetho
                      * @param adviceMethod  The represented advice method.
                      * @param userFactories A list of user-defined factories for offset mappings.
                      */
-                    @SuppressWarnings("all") // In absence of @SafeVarargs for Java 6
+                    @SuppressWarnings("unchecked") // In absence of @SafeVarargs for Java 6
                     protected ForMethodEnter(MethodDescription.InDefinedShape adviceMethod, List<? extends OffsetMapping.Factory> userFactories) {
                         super(adviceMethod,
                                 CompoundList.of(Arrays.asList(OffsetMapping.ForParameter.Factory.READ_ONLY,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1225,6 +1225,7 @@ public FieldDefinition.Optional<V> attribute(FieldAttributeAppender.Factory fiel
                             }
 
                             @Override
+                            @SuppressWarnings("unchecked") // In absence of @SafeVarargs for Java 6
                             public FieldDefinition.Optional<V> transform(Transformer<FieldDescription> transformer) {
                                 return materialize(fieldAttributeAppenderFactory, new Transformer.Compound<FieldDescription>(this.transformer, transformer), defaultValue);
                             }
@@ -2312,6 +2313,7 @@ public MethodDefinition<V> attribute(MethodAttributeAppender.Factory methodAttri
                     }
 
                     @Override
+                    @SuppressWarnings("unchecked") // In absence of @SafeVarargs for Java 6
                     public MethodDefinition<V> transform(Transformer<MethodDescription> transformer) {
                         return materialize(handler, methodAttributeAppenderFactory, new Transformer.Compound<MethodDescription>(this.transformer, transformer));
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/Transformer.java
Patch:
@@ -533,6 +533,7 @@ class Compound<S> implements Transformer<S> {
          *
          * @param transformer The list of transformers to apply in their application order.
          */
+        // @SafeVarargs
         public Compound(Transformer<S>... transformer) {
             this(Arrays.asList(transformer));
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/TransformerCompoundTest.java
Patch:
@@ -34,6 +34,7 @@ public void setUp() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("unchecked") // In absence of @SafeVarargs for Java 6
     public void testTransformation() throws Exception {
         assertThat(new Transformer.Compound<Object>(first, second).transform(typeDescription, firstTarget), is(finalTarget));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeDefaultTest.java
Patch:
@@ -582,8 +582,7 @@ public void testTypeTypeVariableMissingBound() throws Exception {
     @Test(expected = IllegalStateException.class)
     public void testTypeTypeVariableDuplicateBound() throws Exception {
         makePlainInstrumentedType()
-                .withTypeVariable(new TypeVariableToken(FOO, Arrays.asList(TypeDescription.Sort.describe(Serializable.class),
-                        TypeDefinition.Sort.describe(Serializable.class))))
+                .withTypeVariable(new TypeVariableToken(FOO, Arrays.asList(TypeDescription.Sort.describe(Serializable.class), TypeDefinition.Sort.describe(Serializable.class))))
                 .validated();
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -247,7 +247,7 @@ public void testMethodTransformation() throws Exception {
         Class<?> type = createPlain()
                 .method(named(TO_STRING))
                 .intercept(new Implementation.Simple(new TextConstant(FOO), MethodReturn.REFERENCE))
-                .transform(MethodTransformer.Simple.withModifiers(MethodManifestation.FINAL))
+                .transform(Transformer.ForMethod.withModifiers(MethodManifestation.FINAL))
                 .make()
                 .load(new URLClassLoader(new URL[0], null), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
@@ -260,7 +260,7 @@ public void testFieldTransformation() throws Exception {
         Class<?> type = createPlain()
                 .defineField(FOO, Void.class)
                 .field(named(FOO))
-                .transform(FieldTransformer.Simple.withModifiers(Visibility.PUBLIC))
+                .transform(Transformer.ForField.withModifiers(Visibility.PUBLIC))
                 .make()
                 .load(new URLClassLoader(new URL[0], null), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/AbstractInliningDynamicTypeBuilder.java
Patch:
@@ -6,7 +6,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.DynamicType;
-import net.bytebuddy.dynamic.TypeResolver;
+import net.bytebuddy.dynamic.TypeResolutionStrategy;
 import net.bytebuddy.dynamic.scaffold.*;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.attribute.AnnotationRetention;
@@ -86,8 +86,8 @@ protected AbstractInliningDynamicTypeBuilder(InstrumentedType.WithFlexibleName i
     }
 
     @Override
-    public DynamicType.Unloaded<T> make(TypeResolver typeResolver) {
-        return make(typeResolver, TypePool.Default.of(classFileLocator));
+    public DynamicType.Unloaded<T> make(TypeResolutionStrategy typeResolutionStrategy) {
+        return make(typeResolutionStrategy, TypePool.Default.of(classFileLocator));
     }
 
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -7,7 +7,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.DynamicType;
-import net.bytebuddy.dynamic.TypeResolver;
+import net.bytebuddy.dynamic.TypeResolutionStrategy;
 import net.bytebuddy.dynamic.scaffold.*;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.attribute.AnnotationRetention;
@@ -170,7 +170,7 @@ protected DynamicType.Builder<T> materialize(InstrumentedType.WithFlexibleName i
     }
 
     @Override
-    public DynamicType.Unloaded<T> make(TypeResolver typeResolver, TypePool typePool) {
+    public DynamicType.Unloaded<T> make(TypeResolutionStrategy typeResolutionStrategy, TypePool typePool) {
         MethodRegistry.Prepared preparedMethodRegistry = methodRegistry.prepare(instrumentedType,
                 methodGraphCompiler,
                 typeValidation,
@@ -196,7 +196,7 @@ public DynamicType.Unloaded<T> make(TypeResolver typeResolver, TypePool typePool
                 typePool,
                 originalType,
                 classFileLocator,
-                methodRebaseResolver).make(typeResolver.resolve());
+                methodRebaseResolver).make(typeResolutionStrategy.resolve());
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -6,7 +6,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.DynamicType;
-import net.bytebuddy.dynamic.TypeResolver;
+import net.bytebuddy.dynamic.TypeResolutionStrategy;
 import net.bytebuddy.dynamic.scaffold.*;
 import net.bytebuddy.dynamic.scaffold.subclass.SubclassImplementationTarget;
 import net.bytebuddy.implementation.Implementation;
@@ -152,7 +152,7 @@ protected DynamicType.Builder<T> materialize(InstrumentedType.WithFlexibleName i
     }
 
     @Override
-    public DynamicType.Unloaded<T> make(TypeResolver typeResolver, TypePool typePool) {
+    public DynamicType.Unloaded<T> make(TypeResolutionStrategy typeResolutionStrategy, TypePool typePool) {
         MethodRegistry.Compiled compiledMethodRegistry = methodRegistry.prepare(instrumentedType,
                 methodGraphCompiler,
                 typeValidation,
@@ -169,7 +169,7 @@ public DynamicType.Unloaded<T> make(TypeResolver typeResolver, TypePool typePool
                 typeValidation,
                 typePool,
                 originalType,
-                classFileLocator).make(typeResolver.resolve());
+                classFileLocator).make(typeResolutionStrategy.resolve());
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTest.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy;
 
-import net.bytebuddy.dynamic.TypeResolver;
+import net.bytebuddy.dynamic.TypeResolutionStrategy;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.implementation.MethodDelegation;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
@@ -10,9 +10,9 @@
 import java.net.URL;
 import java.net.URLClassLoader;
 
-import static org.hamcrest.CoreMatchers.notNullValue;
 import static net.bytebuddy.matcher.ElementMatchers.isTypeInitializer;
 import static org.hamcrest.CoreMatchers.instanceOf;
+import static org.hamcrest.CoreMatchers.notNullValue;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
 
@@ -69,7 +69,7 @@ public void testTypeInitializerInstrumentation() throws Exception {
                 .subclass(Object.class)
                 .invokable(isTypeInitializer())
                 .intercept(MethodDelegation.to(recorder))
-                .make(TypeResolver.Active.INSTANCE)
+                .make(TypeResolutionStrategy.Active.INSTANCE)
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         assertThat(type.newInstance(), instanceOf(type));

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -4,7 +4,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.DynamicType;
-import net.bytebuddy.dynamic.TypeResolver;
+import net.bytebuddy.dynamic.TypeResolutionStrategy;
 import net.bytebuddy.dynamic.loading.ClassInjector;
 import net.bytebuddy.dynamic.scaffold.inline.MethodNameTransformer;
 import net.bytebuddy.implementation.Implementation;
@@ -106,7 +106,7 @@ public class AgentBuilderDefaultTest {
     @Before
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
-        when(builder.make(TypeResolver.Disabled.INSTANCE, typePool)).thenReturn((DynamicType.Unloaded) dynamicType);
+        when(builder.make(TypeResolutionStrategy.Disabled.INSTANCE, typePool)).thenReturn((DynamicType.Unloaded) dynamicType);
         when(dynamicType.getTypeDescription()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
         when(typeStrategy.builder(any(TypeDescription.class),
                 eq(byteBuddy),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/TypeResolver.java
Patch:
@@ -175,6 +175,7 @@ enum Active implements TypeResolver {
         }
 
         @Override
+        @SuppressFBWarnings(value = "DMI_RANDOM_USED_ONLY_ONCE", justification = "Avoid thread-contention")
         public TypeResolver.Resolved resolve() {
             return new Resolved(new Random().nextInt());
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/DynamicTypeDefaultUnloadedTest.java
Patch:
@@ -67,6 +67,8 @@ public void setUp() throws Exception {
         when(auxiliaryType.getLoadedTypeInitializers()).thenReturn(Collections.singletonMap(auxiliaryTypeDescription, auxiliaryLoadedTypeInitializer));
         when(auxiliaryType.getAuxiliaryTypes()).thenReturn(Collections.<TypeDescription, byte[]>emptyMap());
         when(typeResolver.initialize(unloaded, classLoader, classLoadingStrategy)).thenReturn(loadedTypes);
+        when(typeDescription.getName()).thenReturn(MAIN_TYPE.getName());
+        when(auxiliaryTypeDescription.getName()).thenReturn(AUXILIARY_TYPE.getName());
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -64,6 +64,8 @@ public class ByteBuddyTutorialExamplesTest {
     @Rule
     public MethodRule agentAttachmentRule = new AgentAttachmentRule();
 
+    // Other than in the tutorial, the tests use a wrapper strategy for class loading to retain the test's repeatability.
+
     @SuppressWarnings("unused")
     private static void println(String s) {
         /* do nothing */

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/DynamicTypeDefaultUnloadedTest.java
Patch:
@@ -48,7 +48,6 @@ public class DynamicTypeDefaultUnloadedTest {
 
     private DynamicType.Unloaded<?> unloaded;
 
-
     @Before
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
@@ -66,6 +65,8 @@ public void setUp() throws Exception {
         when(auxiliaryType.getBytes()).thenReturn(auxiliaryTypeByte);
         when(auxiliaryType.getLoadedTypeInitializers()).thenReturn(Collections.singletonMap(auxiliaryTypeDescription, auxiliaryLoadedTypeInitializer));
         when(auxiliaryType.getAuxiliaryTypes()).thenReturn(Collections.<TypeDescription, byte[]>emptyMap());
+        when(typeDescription.getName()).thenReturn(MAIN_TYPE.getName());
+        when(auxiliaryTypeDescription.getName()).thenReturn(AUXILIARY_TYPE.getName());
     }
 
     @Test

File: byte-buddy-android/src/main/java/net/bytebuddy/android/AndroidClassLoadingStrategy.java
Patch:
@@ -135,7 +135,7 @@ public Map<TypeDescription, Class<?>> load(ClassLoader classLoader, Map<TypeDesc
             Map<TypeDescription, Class<?>> loadedTypes = new HashMap<TypeDescription, Class<?>>();
             for (TypeDescription typeDescription : types.keySet()) {
                 try {
-                    loadedTypes.put(typeDescription, dexClassLoader.loadClass(typeDescription.getName()));
+                    loadedTypes.put(typeDescription, Class.forName(typeDescription.getName(), false, dexClassLoader));
                 } catch (ClassNotFoundException exception) {
                     throw new IllegalStateException("Cannot load " + typeDescription, exception);
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -2030,7 +2030,7 @@ public void register(DynamicType dynamicType, ClassLoader classLoader, InjectorF
                             Map<TypeDescription, byte[]> independentTypes = new LinkedHashMap<TypeDescription, byte[]>(auxiliaryTypes);
                             Map<TypeDescription, byte[]> dependentTypes = new LinkedHashMap<TypeDescription, byte[]>(auxiliaryTypes);
                             for (TypeDescription auxiliaryType : auxiliaryTypes.keySet()) {
-                                (auxiliaryType.getDeclaredAnnotations().isAnnotationPresent(AuxiliaryType.SignatureRelevant.class) // TODO: Source?!
+                                (auxiliaryType.getDeclaredAnnotations().isAnnotationPresent(AuxiliaryType.SignatureRelevant.class)
                                         ? dependentTypes
                                         : independentTypes).remove(auxiliaryType);
                             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoader.java
Patch:
@@ -157,7 +157,7 @@ public static Map<TypeDescription, Class<?>> load(ClassLoader classLoader,
                 childFirst);
         for (TypeDescription typeDescription : types.keySet()) {
             try {
-                Class<?> type = classLoader.loadClass(typeDescription.getName());
+                Class<?> type = Class.forName(typeDescription.getName(), false, classLoader);
                 if (forbidExisting && type.getClassLoader() != classLoader) {
                     throw new IllegalStateException("Class already loaded: " + type);
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -611,9 +611,8 @@ public Map<TypeDescription, Class<?>> inject(Map<? extends TypeDescription, byte
                 }
                 target.inject(instrumentation, new JarFile(jarFile));
                 Map<TypeDescription, Class<?>> loaded = new HashMap<TypeDescription, Class<?>>();
-                ClassLoader classLoader = ClassLoader.getSystemClassLoader();
                 for (TypeDescription typeDescription : types.keySet()) {
-                    loaded.put(typeDescription, classLoader.loadClass(typeDescription.getName()));
+                    loaded.put(typeDescription, Class.forName(typeDescription.getName(), false, ClassLoader.getSystemClassLoader()));
                 }
                 return loaded;
             } catch (IOException exception) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/TypeResolverTest.java
Patch:
@@ -90,7 +90,7 @@ public void testActive() throws Exception {
             initializers.setAccessible(true);
             Constructor<Nexus> constructor = Nexus.class.getDeclaredConstructor(String.class, ClassLoader.class, int.class);
             constructor.setAccessible(true);
-            Object value = ((Map<?, ?>) initializers.get(null)).remove(constructor.newInstance(Foo.class.getName(), classLoader, identification));
+            Object value = ((Map<?, ?>) initializers.get(null)).remove(constructor.newInstance(Foo.class.getName(), Foo.class.getClassLoader(), identification));
             assertThat(value, CoreMatchers.is((Object) loadedTypeInitializer));
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/AuxiliaryType.java
Patch:
@@ -180,7 +180,7 @@ public String toString() {
      * A marker to indicate that an auxiliary type is part of the instrumented types signature. This information can be used to load a type before
      * the instrumented type such that reflection on the instrumented type does not cause a {@link NoClassDefFoundError}.
      */
-    @Retention(RetentionPolicy.SOURCE)
+    @Retention(RetentionPolicy.CLASS)
     @Target(ElementType.TYPE)
     @interface SignatureRelevant {
         /* empty */

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/DynamicTypeDefaultUnloadedTest.java
Patch:
@@ -40,7 +40,7 @@ public class DynamicTypeDefaultUnloadedTest {
     private ClassLoadingStrategy classLoadingStrategy;
 
     @Mock
-    private TypeResolver.Resolved typeResolver; // TODO
+    private TypeResolver.Resolved typeResolver;
 
     @Mock
     private TypeDescription typeDescription, auxiliaryTypeDescription;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/AuxiliaryTypeSignatureRelevantTest.java
Patch:
@@ -14,8 +14,8 @@
 public class AuxiliaryTypeSignatureRelevantTest {
 
     @Test
-    public void testSourceRentention() throws Exception {
-        assertThat(AuxiliaryType.SignatureRelevant.class.getAnnotation(Retention.class).value(), is(RetentionPolicy.SOURCE));
+    public void testClassRetention() throws Exception {
+        assertThat(AuxiliaryType.SignatureRelevant.class.getAnnotation(Retention.class).value(), is(RetentionPolicy.CLASS));
     }
 
     @Test
@@ -27,4 +27,4 @@ public void testTypeTarget() throws Exception {
     public void testModifiers() throws Exception {
         assertThat(Modifier.isPublic(AuxiliaryType.SignatureRelevant.class.getModifiers()), is(true));
     }
-}
\ No newline at end of file
+}

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -4,6 +4,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.DynamicType;
+import net.bytebuddy.dynamic.TypeResolver;
 import net.bytebuddy.dynamic.loading.ClassInjector;
 import net.bytebuddy.dynamic.scaffold.inline.MethodNameTransformer;
 import net.bytebuddy.implementation.Implementation;
@@ -105,7 +106,7 @@ public class AgentBuilderDefaultTest {
     @Before
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
-        when(builder.make(typePool)).thenReturn((DynamicType.Unloaded) dynamicType);
+        when(builder.make(TypeResolver.Disabled.INSTANCE, typePool)).thenReturn((DynamicType.Unloaded) dynamicType);
         when(dynamicType.getTypeDescription()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
         when(typeStrategy.builder(any(TypeDescription.class),
                 eq(byteBuddy),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/AbstractInliningDynamicTypeBuilder.java
Patch:
@@ -6,6 +6,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.DynamicType;
+import net.bytebuddy.dynamic.TypeResolver;
 import net.bytebuddy.dynamic.scaffold.*;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.attribute.AnnotationRetention;
@@ -85,8 +86,8 @@ protected AbstractInliningDynamicTypeBuilder(InstrumentedType.WithFlexibleName i
     }
 
     @Override
-    public DynamicType.Unloaded<T> make() {
-        return make(TypePool.Default.of(classFileLocator));
+    public DynamicType.Unloaded<T> make(TypeResolver typeResolver) {
+        return make(typeResolver, TypePool.Default.of(classFileLocator));
     }
 
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -7,6 +7,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.DynamicType;
+import net.bytebuddy.dynamic.TypeResolver;
 import net.bytebuddy.dynamic.scaffold.*;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.attribute.AnnotationRetention;
@@ -169,7 +170,7 @@ protected DynamicType.Builder<T> materialize(InstrumentedType.WithFlexibleName i
     }
 
     @Override
-    public DynamicType.Unloaded<T> make(TypePool typePool) {
+    public DynamicType.Unloaded<T> make(TypeResolver typeResolver, TypePool typePool) {
         MethodRegistry.Prepared preparedMethodRegistry = methodRegistry.prepare(instrumentedType,
                 methodGraphCompiler,
                 typeValidation,
@@ -195,7 +196,7 @@ public DynamicType.Unloaded<T> make(TypePool typePool) {
                 typePool,
                 originalType,
                 classFileLocator,
-                methodRebaseResolver).make();
+                methodRebaseResolver).make(typeResolver);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -6,6 +6,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.DynamicType;
+import net.bytebuddy.dynamic.TypeResolver;
 import net.bytebuddy.dynamic.scaffold.*;
 import net.bytebuddy.dynamic.scaffold.subclass.SubclassImplementationTarget;
 import net.bytebuddy.implementation.Implementation;
@@ -151,7 +152,7 @@ protected DynamicType.Builder<T> materialize(InstrumentedType.WithFlexibleName i
     }
 
     @Override
-    public DynamicType.Unloaded<T> make(TypePool typePool) {
+    public DynamicType.Unloaded<T> make(TypeResolver typeResolver, TypePool typePool) {
         MethodRegistry.Compiled compiledMethodRegistry = methodRegistry.prepare(instrumentedType,
                 methodGraphCompiler,
                 typeValidation,
@@ -168,7 +169,7 @@ public DynamicType.Unloaded<T> make(TypePool typePool) {
                 typeValidation,
                 typePool,
                 originalType,
-                classFileLocator).make();
+                classFileLocator).make(typeResolver);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultApplicationTest.java
Patch:
@@ -60,6 +60,8 @@ public static Collection<Object[]> data() {
         return Arrays.asList(new Object[][]{
                 {AgentBuilder.TypeLocator.Default.EXTENDED},
                 {AgentBuilder.TypeLocator.Default.FAST},
+                {AgentBuilder.TypeLocator.Eager.EXTENDED},
+                {AgentBuilder.TypeLocator.Eager.FAST},
                 {AgentBuilder.TypeLocator.ClassLoading.EXTENDED},
                 {AgentBuilder.TypeLocator.ClassLoading.FAST}
         });

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -394,7 +394,7 @@ public DynamicType.Builder<?> makeInterface(TypeDefinition... interfaceType) {
      * @return A type builder that creates a new interface type.
      */
     public DynamicType.Builder<?> makeInterface(Collection<? extends TypeDefinition> interfaceTypes) {
-        return subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS).implement(interfaceTypes).modifiers(TypeManifestation.INTERFACE);
+        return subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS).implement(interfaceTypes).modifiers(TypeManifestation.INTERFACE, Visibility.PUBLIC);
     }
 
     /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -105,7 +105,7 @@ public class AgentBuilderDefaultTest {
     @Before
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
-        when(builder.make()).thenReturn((DynamicType.Unloaded) dynamicType);
+        when(builder.make(typePool)).thenReturn((DynamicType.Unloaded) dynamicType);
         when(dynamicType.getTypeDescription()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
         when(typeStrategy.builder(any(TypeDescription.class),
                 eq(byteBuddy),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -459,6 +459,7 @@ interface ExtractableView extends Context {
              * @param methodPool                   A method pool which is queried for any user code to add to the type initializer.
              * @param injectedCode                 Potential code that is to be injected into the type initializer.
              * @param annotationValueFilterFactory The annotation value filter factory to apply when writing annotation.
+             * @param supportsBridges              {@code true} if the created class file supports bridge methods.
              */
             void drain(ClassVisitor classVisitor,
                        TypeWriter.MethodPool methodPool,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3040,7 +3040,7 @@ protected class RedefinitionClassVisitor extends ClassVisitor {
                  */
                 private Implementation.Context.ExtractableView.InjectedCode injectedCode;
 
-                private boolean supportsBridges;
+                private Boolean supportsBridges;
 
                 /**
                  * Creates a class visitor which is capable of redefining an existent class on the fly.
@@ -3214,6 +3214,7 @@ public String toString() {
                             ", declaredFields=" + declaredFields +
                             ", declarableMethods=" + declarableMethods +
                             ", injectedCode=" + injectedCode +
+                            ", supportsBridges=" + supportsBridges +
                             '}';
                 }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -6089,8 +6089,8 @@ protected static class ExecutingTransformer implements ClassFileTransformer {
                 try {
                     factory = new Factory.ForJava9CapableVm(new ByteBuddy()
                             .subclass(ExecutingTransformer.class)
-                            .name(ExecutingTransformer.class.getName() + "$ByteBuddy$Java9Support")
-                            .method(named("transform").and(takesArgument(0, JavaType.MODULE.getTypeStub())))
+                            .name(ExecutingTransformer.class.getName() + "$ByteBuddy$ModuleSupport")
+                            .method(named("transform").and(takesArgument(0, JavaType.MODULE.load())))
                             .intercept(MethodCall.invoke(ExecutingTransformer.class.getDeclaredMethod("transform",
                                     Object.class,
                                     String.class,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -368,7 +368,6 @@ public Set<MethodDescription.TypeToken> getMethodTypes() {
             public boolean equals(Object other) {
                 return this == other || !(other == null || getClass() != other.getClass())
                         && methodDescription.equals(((Simple) other).methodDescription);
-
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.dynamic;
 
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.utility.StreamDrainer;
 
 import java.io.*;
@@ -297,7 +298,7 @@ public static ClassFileLocator of(ClassLoader classLoader) {
          */
         public static Resolution read(Class<?> type) {
             try {
-                return locate(type.getClassLoader(), type.getName());
+                return locate(type.getClassLoader(), TypeDescription.ForLoadedType.getName(type));
             } catch (IOException exception) {
                 throw new IllegalStateException("Cannot read class file for " + type, exception);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1593,6 +1593,7 @@ public static <U> TypeWriter<U> forRebasing(MethodRegistry.Compiled methodRegist
         }
 
         @Override
+        @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Setting a debugging property should not change program outcome")
         public DynamicType.Unloaded<S> make() {
             Implementation.Context.ExtractableView implementationContext = implementationContextFactory.make(instrumentedType,
                     auxiliaryTypeNamingStrategy,

File: byte-buddy-agent/src/test/java/net/bytebuddy/test/utility/AgentAttachmentRule.java
Patch:
@@ -64,7 +64,7 @@ public NoOpStatement(String reason) {
 
         @Override
         public void evaluate() throws Throwable {
-            Logger.getAnonymousLogger().warning("Ignoring test case: " + reason);
+            Logger.getLogger("net.bytebuddy").warning("Ignoring test case: " + reason);
         }
     }
 }

File: byte-buddy-android/src/main/java/net/bytebuddy/android/AndroidClassLoadingStrategy.java
Patch:
@@ -145,7 +145,7 @@ public Map<TypeDescription, Class<?>> load(ClassLoader classLoader, Map<TypeDesc
             throw new IllegalStateException("Cannot write to zip file " + zipFile, exception);
         } finally {
             if (!zipFile.delete()) {
-                Logger.getAnonymousLogger().warning("Could not delete " + zipFile);
+                Logger.getLogger("net.bytebuddy").warning("Could not delete " + zipFile);
             }
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/Nexus.java
Patch:
@@ -117,7 +117,7 @@ public static void initialize(Class<?> type, int identification) throws Exceptio
      */
     public static void register(String name, ClassLoader classLoader, int identification, Object typeInitializer) {
         if (TYPE_INITIALIZERS.put(new Nexus(name, classLoader, identification), typeInitializer) != null) {
-            Logger.getAnonymousLogger().warning("Initializer with id " + identification + " is already registered for " + name);
+            Logger.getLogger("net.bytebuddy").warning("Initializer with id " + identification + " is already registered for " + name);
         }
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/AgentAttachmentRule.java
Patch:
@@ -64,7 +64,7 @@ public NoOpStatement(String reason) {
 
         @Override
         public void evaluate() throws Throwable {
-            Logger.getAnonymousLogger().warning("Ignoring test case: " + reason);
+            Logger.getLogger("net.bytebuddy").warning("Ignoring test case: " + reason);
         }
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/IntegrationRule.java
Patch:
@@ -34,7 +34,7 @@ private static class NoOpStatement extends Statement {
 
         @Override
         public void evaluate() throws Throwable {
-            Logger.getAnonymousLogger().warning("Ignored test case that is only to be run on the CI server due to long runtime");
+            Logger.getLogger("net.bytebuddy").warning("Ignored test case that is only to be run on the CI server due to long runtime");
         }
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/JavaVersionRule.java
Patch:
@@ -59,7 +59,7 @@ public NoOpStatement(int requiredVersion) {
 
         @Override
         public void evaluate() throws Throwable {
-            Logger.getAnonymousLogger().warning("Ignoring test case: Requires a Java version of at least " + requiredVersion);
+            Logger.getLogger("net.bytebuddy").warning("Ignoring test case: Requires a Java version of at least " + requiredVersion);
         }
     }
 
@@ -73,7 +73,7 @@ public NoOpHotSpotStatement(int restrictedVersion) {
 
         @Override
         public void evaluate() throws Throwable {
-            Logger.getAnonymousLogger().warning("Ignoring test case: Only works on HotSpot for Java version " + restrictedVersion);
+            Logger.getLogger("net.bytebuddy").warning("Ignoring test case: Only works on HotSpot for Java version " + restrictedVersion);
         }
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -1028,6 +1028,7 @@ public void testExecutingTransformerHandlesNullValue() throws Exception {
                 accessControlContext,
                 initializationStrategy,
                 mock(AgentBuilder.Default.BootstrapInjectionStrategy.class),
+                AgentBuilder.DescriptionStrategy.HYBRID,
                 mock(AgentBuilder.RawMatcher.class),
                 mock(AgentBuilder.Default.Transformation.class))
                 .transform(mock(ClassLoader.class),

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -6794,7 +6794,7 @@ public String toString() {
 
     /**
      * <p>
-     * Indicates that this method should be executed before calling the instrumented method. Any class must declare
+     * Indicates that this method should be executed before exiting the instrumented method. Any class must declare
      * at most one method with this annotation. The annotated method must be static.
      * </p>
      * <p>

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CachingMatcher.java
Patch:
@@ -1,5 +1,7 @@
 package net.bytebuddy.matcher;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+
 import java.util.Iterator;
 import java.util.concurrent.ConcurrentMap;
 
@@ -76,6 +78,7 @@ public String toString() {
      *
      * @param <S> The actual matched type of this matcher.
      */
+    @SuppressFBWarnings(value = "EQ_DOESNT_OVERRIDE_EQUALS", justification = "Caching mechanism is not supposed to decide on equality")
     public static class WithInlineEviction<S> extends CachingMatcher<S> {
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -1790,6 +1790,7 @@ public String toString() {
          * An initialization strategy that adds a code block to an instrumented type's type initializer which
          * then calls a specific class that is responsible for the explicit initialization.
          */
+        @SuppressFBWarnings(value = "DMI_RANDOM_USED_ONLY_ONCE", justification = "Avoiding synchronization without security concerns")
         enum SelfInjection implements InitializationStrategy {
 
             /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AnnotationTypeMatcher.java
Patch:
@@ -18,7 +18,7 @@ public class AnnotationTypeMatcher<T extends AnnotationDescription> extends Elem
     /**
      * Creates a new matcher for an annotation description's type.
      *
-     * @param typeMatcher The type matcher to apply to an annotation's type.
+     * @param matcher The type matcher to apply to an annotation's type.
      */
     public AnnotationTypeMatcher(ElementMatcher<? super TypeDescription> matcher) {
         this.matcher = matcher;

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -3893,7 +3893,7 @@ public Default(ByteBuddy byteBuddy) {
                     RedefinitionStrategy.DISABLED,
                     BootstrapInjectionStrategy.Disabled.INSTANCE,
                     LambdaInstrumentationStrategy.DISABLED,
-                    new RawMatcher.ForElementMatcherPair(isSynthetic(), none()),
+                    new RawMatcher.ForElementMatcherPair(isSynthetic(), any()),
                     Transformation.Ignored.INSTANCE);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -7199,7 +7199,7 @@ public boolean equals(Object other) {
 
         @Override
         public int hashCode() {
-            return getInternalName().hashCode();
+            return getName().hashCode();
         }
 
         @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeDefaultTest.java
Patch:
@@ -348,7 +348,7 @@ public void testGetStackSize() throws Exception {
     @Test
     public void testHashCode() throws Exception {
         InstrumentedType instrumentedType = makePlainInstrumentedType();
-        assertThat(instrumentedType.hashCode(), is(instrumentedType.getInternalName().hashCode()));
+        assertThat(instrumentedType.hashCode(), is(instrumentedType.getName().hashCode()));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -7194,7 +7194,7 @@ public Iterator<TypeDefinition> iterator() {
         public boolean equals(Object other) {
             return other == this || other instanceof TypeDefinition
                     && ((TypeDefinition) other).getSort().isNonGeneric()
-                    && getInternalName().equals(((TypeDefinition) other).asErasure().getInternalName());
+                    && getName().equals(((TypeDefinition) other).asErasure().getName());
         }
 
         @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -222,7 +222,7 @@ public void testEquals() throws Exception {
         TypeDescription equalFirst = mock(TypeDescription.class);
         when(equalFirst.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(equalFirst.asErasure()).thenReturn(equalFirst);
-        when(equalFirst.getInternalName()).thenReturn(Type.getInternalName(SampleClass.class));
+        when(equalFirst.getName()).thenReturn(SampleClass.class.getName());
         assertThat(describe(SampleClass.class), is(equalFirst));
         assertThat(describe(SampleClass.class), not(describe(SampleInterface.class)));
         assertThat(describe(SampleClass.class), not((TypeDescription) new TypeDescription.ForLoadedType(SampleInterface.class)));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeDefaultTest.java
Patch:
@@ -355,11 +355,11 @@ public void testHashCode() throws Exception {
     public void testEquals() throws Exception {
         InstrumentedType instrumentedType = makePlainInstrumentedType();
         TypeDescription other = mock(TypeDescription.class);
-        when(other.getInternalName()).thenReturn(instrumentedType.getInternalName());
+        when(other.getName()).thenReturn(instrumentedType.getName());
         when(other.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(other.asErasure()).thenReturn(other);
         assertThat(instrumentedType, is(other));
-        verify(other, atLeast(1)).getInternalName();
+        verify(other, atLeast(1)).getName();
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -7194,7 +7194,7 @@ public Iterator<TypeDefinition> iterator() {
         public boolean equals(Object other) {
             return other == this || other instanceof TypeDefinition
                     && ((TypeDefinition) other).getSort().isNonGeneric()
-                    && getInternalName().equals(((TypeDefinition) other).asErasure().getInternalName());
+                    && getName().equals(((TypeDefinition) other).asErasure().getName());
         }
 
         @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -222,7 +222,7 @@ public void testEquals() throws Exception {
         TypeDescription equalFirst = mock(TypeDescription.class);
         when(equalFirst.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(equalFirst.asErasure()).thenReturn(equalFirst);
-        when(equalFirst.getInternalName()).thenReturn(Type.getInternalName(SampleClass.class));
+        when(equalFirst.getName()).thenReturn(SampleClass.class.getName());
         assertThat(describe(SampleClass.class), is(equalFirst));
         assertThat(describe(SampleClass.class), not(describe(SampleInterface.class)));
         assertThat(describe(SampleClass.class), not((TypeDescription) new TypeDescription.ForLoadedType(SampleInterface.class)));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeDefaultTest.java
Patch:
@@ -355,11 +355,11 @@ public void testHashCode() throws Exception {
     public void testEquals() throws Exception {
         InstrumentedType instrumentedType = makePlainInstrumentedType();
         TypeDescription other = mock(TypeDescription.class);
-        when(other.getInternalName()).thenReturn(instrumentedType.getInternalName());
+        when(other.getName()).thenReturn(instrumentedType.getName());
         when(other.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(other.asErasure()).thenReturn(other);
         assertThat(instrumentedType, is(other));
-        verify(other, atLeast(1)).getInternalName();
+        verify(other, atLeast(1)).getName();
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -377,7 +377,7 @@ interface Generic extends TypeDefinition, AnnotatedCodeElement {
          * <p>
          * Returns the owner type of this type. A type's owner type describes a nested type's declaring type.
          * If it exists, the returned type can be a non-generic or parameterized type. If a class has no
-         * declaring class, {@code null} is returned.
+         * declaring type, {@code null} is returned.
          * </p>
          * <p>
          * An owner type is only well-defined for parameterized types ({@link Sort#PARAMETERIZED}),

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -5099,6 +5099,7 @@ public Resolution resolve(TypeDescription typeDescription,
                                 return current.asDecoratorOf(resolution);
                             case DECORATOR:
                                 current = current.asDecoratorOf(resolution);
+                                break;
                             case UNDEFINED:
                                 break;
                             default:

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -2610,6 +2610,7 @@ public String toString() {
             /**
              * Implements a lambda class's constructor.
              */
+            @SuppressFBWarnings(value = "SE_BAD_FIELD", justification = "An enumeration does not serialize fields")
             protected enum ConstructorImplementation implements Implementation {
 
                 /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -4467,8 +4467,8 @@ public boolean equals(Object object) {
                         if (this == object) return true;
                         if (object == null || getClass() != object.getClass()) return false;
                         Unresolved that = (Unresolved) object;
-                        if (!typeDescription.equals(that.typeDescription)) return false;
-                        return classLoader != null ? classLoader.equals(that.classLoader) : that.classLoader == null;
+                        return typeDescription.equals(that.typeDescription)
+                                && (classLoader != null ? classLoader.equals(that.classLoader) : that.classLoader == null);
                     }
 
                     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -1305,7 +1305,7 @@ public void testNonResolvedAdvice() throws Exception {
 
     @Test
     public void testCannotInstantiateSuppressionMarker() throws Exception {
-        Class<?> type = Class.forName(Advice.class.getName() + "$NoSuppression");
+        Class<?> type = Class.forName(Advice.class.getName() + "$NoExceptionHandler");
         assertThat(Modifier.isPrivate(type.getModifiers()), is(true));
         try {
             Constructor<?> constructor = type.getDeclaredConstructor();

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -6456,7 +6456,7 @@ public String toString() {
          *
          * @return {@code true} if the advice method should be invoked when a method terminates exceptionally.
          */
-        boolean onThrowable() default true;
+        boolean onThrowable() default false;
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -1182,7 +1182,7 @@ public void injectCompletionFrame(MethodVisitor methodVisitor, boolean secondary
 
                 @Override
                 public String toString() {
-                    return "Advice.StackMapFrameHandler.Default.TranslationMode.ForAdvice{" +
+                    return "Advice.StackMapFrameHandler.Default.ForAdvice{" +
                             "methodDescription=" + methodDescription +
                             ", requiredTypes=" + requiredTypes +
                             ", yieldedTypes=" + yieldedTypes +

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -7,7 +7,6 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
-import net.bytebuddy.test.utility.DebuggingWrapper;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 import org.objectweb.asm.ClassReader;
@@ -463,7 +462,6 @@ public void testAdviceWithReturnValue() throws Exception {
     public void testAdviceWithExceptionHandler() throws Exception {
         Class<?> type = new ByteBuddy()
                 .redefine(Sample.class)
-                .visit(DebuggingWrapper.makeDefault(false))
                 .visit(Advice.to(ExceptionHandlerAdvice.class).on(named(FOO)))
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -7,6 +7,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
+import net.bytebuddy.test.utility.DebuggingWrapper;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 import org.objectweb.asm.ClassReader;
@@ -462,6 +463,7 @@ public void testAdviceWithReturnValue() throws Exception {
     public void testAdviceWithExceptionHandler() throws Exception {
         Class<?> type = new ByteBuddy()
                 .redefine(Sample.class)
+                .visit(DebuggingWrapper.makeDefault(false))
                 .visit(Advice.to(ExceptionHandlerAdvice.class).on(named(FOO)))
                 .make()
                 .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -5682,7 +5682,7 @@ public Dispatcher.Resolved.ForMethodExit asMethodExitTo(List<? extends OffsetMap
 
             @Override
             public boolean equals(Object other) {
-                return this == other || !(other == null || getClass() != other.getClass()) && adviceMethod.equals(((Inlining) other).adviceMethod);
+                return this == other || !(other == null || getClass() != other.getClass()) && adviceMethod.equals(((Delegating) other).adviceMethod);
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -216,6 +216,7 @@ public interface AgentBuilder {
      * If this matcher is chained with additional subsequent matchers, this matcher is always executed first whereas the following matchers are
      * executed in the order of their execution. If any matcher indicates that a type is to be matched, none of the following matchers is still queried.
      * </p>
+     * <p>
      * <b>Note</b>: When applying a matcher, regard the performance implications by {@link AgentBuilder#ignore(ElementMatcher)}. The former
      * matcher is applied first such that it makes sense to ignore name spaces that are irrelevant to instrumentation. If possible, it is
      * also recommended, to exclude class loaders such as for example the bootstrap class loader by using

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -4399,10 +4399,9 @@ public void onEnd(MethodVisitor methodVisitor, MetaDataHandler.ForAdvice metaDat
 
                 @Override
                 public void onEndSkipped(MethodVisitor methodVisitor, MetaDataHandler.ForAdvice metaDataHandler, ReturnValueProducer returnValueProducer) {
-                    /* do nothing */
+                    metaDataHandler.injectCompletionFrame(methodVisitor, false);
                 }
 
-
                 @Override
                 public String toString() {
                     return "Advice.Dispatcher.SuppressionHandler.NoOp." + name();

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -4372,7 +4372,6 @@ public void onEndSkipped(MethodVisitor methodVisitor, MetaDataHandler.ForAdvice
                         Label endOfHandler = new Label();
                         methodVisitor.visitJumpInsn(Opcodes.GOTO, endOfHandler);
                         onEnd(methodVisitor, metaDataHandler, returnValueProducer, endOfHandler);
-                        methodVisitor.visitLabel(endOfHandler);
                         metaDataHandler.injectCompletionFrame(methodVisitor, false);
                     }
 
@@ -5702,7 +5701,7 @@ public void apply() {
                                 false);
                         onAfterCall();
                         suppressionHandler.onEndSkipped(methodVisitor, metaDataHandler, this);
-                        metaDataHandler.recordMaxima(maximumStackSize, EMPTY);
+                        metaDataHandler.recordMaxima(Math.max(maximumStackSize, adviceMethod.getReturnType().getStackSize().getSize()), EMPTY);
                     }
 
                     protected abstract void onAfterCall();

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -7257,7 +7257,7 @@ protected class TypeExtractor extends ClassVisitor {
             /**
              * A mask that cuts off pseudo flags beyond the second byte that are inserted by ASM.
              */
-            private static final int REAL_MODIFIER_MASK = Short.MAX_VALUE;
+            private static final int REAL_MODIFIER_MASK = 0xFFFF;
 
             /**
              * A mapping of the super types' type annotation tokens by their indices.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -51,7 +51,7 @@ public interface MethodDescription extends TypeVariableSource,
     /**
      * The type initializer of any representation of a type initializer.
      */
-    int TYPE_INITIALIZER_MODIFIER = Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE | Opcodes.ACC_SYNTHETIC;
+    int TYPE_INITIALIZER_MODIFIER = Opcodes.ACC_STATIC;
 
     /**
      * Represents a non-defined default value of an annotation property.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -150,6 +150,7 @@
  * </p>
  *
  * @see Forwarding
+ * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.ParameterBinder.ForFixedValue
  */
 public class MethodDelegation implements Implementation.Composable {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/AsmVisitorWrapper.java
Patch:
@@ -611,6 +611,7 @@ public String toString() {
                         "outer=" + getOuter() +
                         ", instrumentedType=" + instrumentedType +
                         ", methodsByName=" + methodsByName +
+                        ", classFileVersion=" + classFileVersion +
                         ", writerFlags=" + writerFlags +
                         ", readerFlags=" + readerFlags +
                         '}';

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -1500,8 +1500,9 @@ public Class<?> create() {
         ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.CodeCopier.ExceptionTabelSubstitutor.class).applyBasic();
         ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.CodeCopier.ExceptionTableCollector.class).applyBasic();
         ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.CodeCopier.ExceptionTableExtractor.class).applyBasic();
-        ObjectPropertyAssertion.of(Advice.Dispatcher.Active.CodeTranslationVisitor.SuppressionHandler.NoOp.class).apply();
-        ObjectPropertyAssertion.of(Advice.Dispatcher.Active.CodeTranslationVisitor.SuppressionHandler.Suppressing.class).apply();
+        ObjectPropertyAssertion.of(Advice.Dispatcher.Active.SuppressionHandler.NoOp.class).apply();
+        ObjectPropertyAssertion.of(Advice.Dispatcher.Active.SuppressionHandler.Suppressing.class).apply();
+        ObjectPropertyAssertion.of(Advice.Dispatcher.Active.SuppressionHandler.Suppressing.Bound.class).applyBasic();
         ObjectPropertyAssertion.of(Advice.Dispatcher.Active.CodeTranslationVisitor.ForMethodEnter.class).applyBasic();
         ObjectPropertyAssertion.of(Advice.Dispatcher.Active.CodeTranslationVisitor.ForMethodExit.class).refine(new ObjectPropertyAssertion.Refinement<MethodDescription.InDefinedShape>() {
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -1689,8 +1689,8 @@ public static <T extends AnnotationDescription> ElementMatcher.Junction<T> annot
      * @param <T>  The type of the matched object.
      * @return A matcher that matches the annotation's type for being equal to the given type.
      */
-    public static <T extends AnnotationDescription> ElementMatcher.Junction<T> annotationType(TypeDescription typeDescription) {
-        return annotationType(is(typeDescription));
+    public static <T extends AnnotationDescription> ElementMatcher.Junction<T> annotationType(TypeDescription type) {
+        return annotationType(is(type));
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategy.java
Patch:
@@ -14,6 +14,9 @@
  */
 public interface ClassLoadingStrategy {
 
+    /**
+     * A type-safe constant representing the bootstrap class loader which is represented by {@code null} within Java.
+     */
     ClassLoader BOOTSTRAP_LOADER = null;
 
     /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceSuppressionTest.java
Patch:
@@ -45,7 +45,7 @@ public void testIllegalAssignment() throws Exception {
                 .redefine(Sample.class)
                 .visit(Advice.to(type).on(named(FOO)))
                 .make()
-                .load(null, ClassLoadingStrategy.Default.WRAPPER)
+                .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         assertThat(dynamicType.getDeclaredMethod(FOO).invoke(dynamicType.newInstance()), is((Object) FOO));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTypeTest.java
Patch:
@@ -71,7 +71,7 @@ public void testAdvice() throws Exception {
                         .to(advice)
                         .on(named(FOO)))
                 .make()
-                .load(null, ClassLoadingStrategy.Default.WRAPPER)
+                .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         assertThat(type.getDeclaredMethod(FOO, this.type, this.type).invoke(type.newInstance(), value, value), is(value));
         assertThat(type.getDeclaredField(ENTER).get(null), is((Object) 1));
@@ -87,7 +87,7 @@ public void testAdviceWithException() throws Exception {
                         .to(advice)
                         .on(named(BAR)))
                 .make()
-                .load(null, ClassLoadingStrategy.Default.WRAPPER)
+                .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         type.getDeclaredField(exception).set(null, true);
         try {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AnnotationDescriptionForLoadedAnnotationTest.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.description.annotation;
 
 import net.bytebuddy.description.method.MethodDescription;
+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import org.junit.Test;
 
 import java.lang.annotation.Annotation;
@@ -45,7 +46,7 @@ public void testInoperational() throws Exception {
 
     @Test(expected = IllegalArgumentException.class)
     public void testLoadAnnotationWrongClassLoader() throws Exception {
-        describe(Carrier.class.getAnnotation(PrivateAnnotation.class), Carrier.class).prepare(PrivateAnnotation.class).load(null);
+        describe(Carrier.class.getAnnotation(PrivateAnnotation.class), Carrier.class).prepare(PrivateAnnotation.class).load(ClassLoadingStrategy.BOOTSTRAP_LOADER);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategyForBootstrapInjectionTest.java
Patch:
@@ -45,7 +45,7 @@ public void testBootstrapInjection() throws Exception {
         ClassLoadingStrategy bootstrapStrategy = new ClassLoadingStrategy.ForBootstrapInjection(ByteBuddyAgent.install(), file);
         String name = FOO + RandomString.make();
         DynamicType dynamicType = new ByteBuddy().subclass(Object.class).name(name).make();
-        Map<TypeDescription, Class<?>> loaded = bootstrapStrategy.load(null, Collections.singletonMap(dynamicType.getTypeDescription(), dynamicType.getBytes()));
+        Map<TypeDescription, Class<?>> loaded = bootstrapStrategy.load(ClassLoadingStrategy.BOOTSTRAP_LOADER, Collections.singletonMap(dynamicType.getTypeDescription(), dynamicType.getBytes()));
         assertThat(loaded.size(), is(1));
         assertThat(loaded.get(dynamicType.getTypeDescription()).getName(), is(name));
         assertThat(loaded.get(dynamicType.getTypeDescription()).getClassLoader(), nullValue(ClassLoader.class));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/AbstractDynamicTypeBuilderForInliningTest.java
Patch:
@@ -397,7 +397,7 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si
         Class<?> type = create(StackMapFrames.class)
                 .visit(asmVisitorWrapper)
                 .make()
-                .load(null, ClassLoadingStrategy.Default.WRAPPER)
+                .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         assertThat(type.getDeclaredMethod(FOO).invoke(type.newInstance()), is((Object) BAR));
         verify(asmVisitorWrapper).mergeWriter(0);

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -1115,7 +1115,7 @@ protected AdviceVisitor(MethodVisitor methodVisitor,
         }
 
         @Override
-        protected void onMethodStart() {
+        protected void onFirstCodeInstruction() {
             onAdviceStart();
             if (methodEnter.isAlive()) {
                 append(methodEnter);
@@ -4316,7 +4316,7 @@ public void visitCode() {
                 }
 
                 @Override
-                protected void onMethodStart() {
+                protected void onFirstCodeInstruction() {
                     suppressionHandler.onStart(mv, metaDataHandler);
                 }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceAnnotationTest.java
Patch:
@@ -24,6 +24,7 @@ public static Collection<Object[]> data() {
                 {Advice.Enter.class, ElementType.PARAMETER},
                 {Advice.Ignored.class, ElementType.PARAMETER},
                 {Advice.Origin.class, ElementType.PARAMETER},
+                {Advice.Origin.Type.class, ElementType.PARAMETER},
                 {Advice.Return.class, ElementType.PARAMETER},
                 {Advice.This.class, ElementType.PARAMETER},
                 {Advice.Thrown.class, ElementType.PARAMETER},

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceAnnotationTest.java
Patch:
@@ -24,7 +24,6 @@ public static Collection<Object[]> data() {
                 {Advice.Enter.class, ElementType.PARAMETER},
                 {Advice.Ignored.class, ElementType.PARAMETER},
                 {Advice.Origin.class, ElementType.PARAMETER},
-                {Advice.OriginType.class, ElementType.PARAMETER},
                 {Advice.Return.class, ElementType.PARAMETER},
                 {Advice.This.class, ElementType.PARAMETER},
                 {Advice.Thrown.class, ElementType.PARAMETER},

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceIllegalTypeTest.java
Patch:
@@ -11,9 +11,9 @@
 import static net.bytebuddy.matcher.ElementMatchers.named;
 
 @RunWith(Parameterized.class)
-public class AdviceParameterWriteTest {
+public class AdviceIllegalTypeTest {
 
-    private static final String FOO = "foo", BAR = "bar", ENTER = "enter", EXIT = "exit", exception = "exception";
+    private static final String FOO = "foo";
 
     private static final byte VALUE = 42;
 
@@ -36,7 +36,7 @@ public static Collection<Object[]> data() {
 
     private final Class<?> type;
 
-    public AdviceParameterWriteTest(Class<?> type) {
+    public AdviceIllegalTypeTest(Class<?> type) {
         this.type = type;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategy.java
Patch:
@@ -14,6 +14,8 @@
  */
 public interface ClassLoadingStrategy {
 
+    ClassLoader BOOTSTRAP_LOADER = null;
+
     /**
      * Loads a given collection of classes given their binary representation.
      *

File: byte-buddy-dep/src/test/java/net/bytebuddy/ClassFileVersionTest.java
Patch:
@@ -40,7 +40,7 @@ public void testVersionPropertyAction() throws Exception {
 
     @Test
     public void testVersionOfClass() throws Exception {
-        assertThat(ClassFileVersion.of(Foo.class), is(ClassFileVersion.forCurrentJavaVersion()));
+        assertThat(ClassFileVersion.of(Foo.class).compareTo(ClassFileVersion.forCurrentJavaVersion()) < 1, is(true));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceSuppressionTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
-import net.bytebuddy.test.utility.DebuggingWrapper;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -44,7 +43,6 @@ public AdviceSuppressionTest(Class<?> type) {
     public void testIllegalAssignment() throws Exception {
         Class<?> dynamicType = new ByteBuddy()
                 .redefine(Sample.class)
-                .visit(DebuggingWrapper.makeDefault())
                 .visit(Advice.to(type).on(named(FOO)))
                 .make()
                 .load(null, ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -9,7 +9,6 @@
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.implementation.bytecode.StackSize;
-import net.bytebuddy.test.utility.DebuggingWrapper;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 import org.objectweb.asm.ClassReader;
@@ -53,7 +52,6 @@ public void testTrivialAdvice() throws Exception {
     public void testEmptyAdviceEntryAndExit() throws Exception {
         Class<?> type = new ByteBuddy()
                 .redefine(EmptyMethod.class)
-                .visit(DebuggingWrapper.makeDefault())
                 .visit(Advice.to(EmptyAdvice.class).on(named(FOO)).readerFlags(ClassReader.SKIP_DEBUG))
                 .make()
                 .load(null, ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/TypeConstantAdjustment.java
Patch:
@@ -36,7 +36,7 @@ public int mergeReader(int flags) {
     }
 
     @Override
-    public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor) {
+    public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, int writerFlags, int readerFlags) {
         return new TypeConstantDissolvingClassVisitor(classVisitor);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AsmVisitorWrapperNoOpTest.java
Patch:
@@ -12,12 +12,12 @@
 
 public class AsmVisitorWrapperNoOpTest {
 
-    private static final int FOO = 42;
+    private static final int FOO = 42, IRRELEVANT = -1;
 
     @Test
     public void testWrapperChain() throws Exception {
         ClassVisitor classVisitor = mock(ClassVisitor.class);
-        assertThat(AsmVisitorWrapper.NoOp.INSTANCE.wrap(mock(TypeDescription.class), classVisitor), is(classVisitor));
+        assertThat(AsmVisitorWrapper.NoOp.INSTANCE.wrap(mock(TypeDescription.class), classVisitor, IRRELEVANT, IRRELEVANT), is(classVisitor));
         verifyZeroInteractions(classVisitor);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -351,7 +351,7 @@ public void testPreparedMethod() throws Exception {
     @Test
     public void testWriterHint() throws Exception {
         AsmVisitorWrapper asmVisitorWrapper = mock(AsmVisitorWrapper.class);
-        when(asmVisitorWrapper.wrap(any(TypeDescription.class), any(ClassVisitor.class))).then(new Answer<ClassVisitor>() {
+        when(asmVisitorWrapper.wrap(any(TypeDescription.class), any(ClassVisitor.class), anyInt(), anyInt())).then(new Answer<ClassVisitor>() {
             @Override
             public ClassVisitor answer(InvocationOnMock invocationOnMock) throws Throwable {
                 return new ClassVisitor(Opcodes.ASM5, (ClassVisitor) invocationOnMock.getArguments()[1]) {
@@ -376,7 +376,7 @@ public void visitEnd() {
         assertThat(type.getDeclaredMethod(FOO).invoke(type.newInstance()), is((Object) FOO));
         verify(asmVisitorWrapper).mergeWriter(0);
         verify(asmVisitorWrapper, atMost(1)).mergeReader(0);
-        verify(asmVisitorWrapper).wrap(any(TypeDescription.class), any(ClassVisitor.class));
+        verify(asmVisitorWrapper).wrap(any(TypeDescription.class), any(ClassVisitor.class), anyInt(), anyInt());
         verifyNoMoreInteractions(asmVisitorWrapper);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoaderChildFirstTest.java
Patch:
@@ -29,7 +29,7 @@
 @RunWith(Parameterized.class)
 public class ByteArrayClassLoaderChildFirstTest {
 
-    private static final String FOO = "foo", BAR = "bar", QUX = "qux", CLASS_FILE = ".class";
+    private static final String BAR = "bar", CLASS_FILE = ".class";
 
     private static final ProtectionDomain DEFAULT_PROTECTION_DOMAIN = null;
 
@@ -216,7 +216,7 @@ public int mergeReader(int flags) {
         }
 
         @Override
-        public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor) {
+        public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, int writerFlags, int readerFlags) {
             return new ClassRemapper(classVisitor, new SimpleRemapper(oldName, newName));
         }
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/AbstractDynamicTypeBuilderForInliningTest.java
Patch:
@@ -381,7 +381,7 @@ public void testFieldTransformationExistingField() throws Exception {
     @Test
     public void testReaderHint() throws Exception {
         AsmVisitorWrapper asmVisitorWrapper = mock(AsmVisitorWrapper.class);
-        when(asmVisitorWrapper.wrap(any(TypeDescription.class), any(ClassVisitor.class))).then(new Answer<ClassVisitor>() {
+        when(asmVisitorWrapper.wrap(any(TypeDescription.class), any(ClassVisitor.class), anyInt(), anyInt())).then(new Answer<ClassVisitor>() {
             @Override
             public ClassVisitor answer(InvocationOnMock invocationOnMock) throws Throwable {
                 return new ClassVisitor(Opcodes.ASM5, (ClassVisitor) invocationOnMock.getArguments()[1]) {
@@ -402,7 +402,7 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si
         assertThat(type.getDeclaredMethod(FOO).invoke(type.newInstance()), is((Object) BAR));
         verify(asmVisitorWrapper).mergeWriter(0);
         verify(asmVisitorWrapper).mergeReader(0);
-        verify(asmVisitorWrapper).wrap(any(TypeDescription.class), any(ClassVisitor.class));
+        verify(asmVisitorWrapper).wrap(any(TypeDescription.class), any(ClassVisitor.class), anyInt(), anyInt());
         verifyNoMoreInteractions(asmVisitorWrapper);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/DebuggingWrapper.java
Patch:
@@ -3,6 +3,7 @@
 import net.bytebuddy.asm.AsmVisitorWrapper;
 import net.bytebuddy.description.type.TypeDescription;
 import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.util.CheckClassAdapter;
 import org.objectweb.asm.util.Printer;
 import org.objectweb.asm.util.Textifier;
 import org.objectweb.asm.util.TraceClassVisitor;
@@ -43,7 +44,7 @@ public int mergeReader(int flags) {
     }
 
     @Override
-    public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor) {
-        return new TraceClassVisitor(classVisitor, printer, printWriter);
+    public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, int writerFlags, int readerFlags) {
+        return new CheckClassAdapter(new TraceClassVisitor(classVisitor, printer, printWriter));
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -333,7 +333,7 @@ protected int compoundLocalVariableSize(int localVariableLength) {
         }
 
         protected void injectEntranceFrame(MethodVisitor methodVisitor) {
-            injectFrame(methodVisitor, intermediateTypes, false);
+                injectFrame(methodVisitor, intermediateTypes, false);
         }
 
         /**
@@ -536,7 +536,7 @@ protected void injectHandlerFrame(MethodVisitor methodVisitor) {
              * @param methodVisitor The method visitor to write the frame to.
              */
             protected void injectCompletionFrame(MethodVisitor methodVisitor) {
-                injectFrame(methodVisitor, CompoundList.of(intermediateTypes, yieldedTypes), false);
+                    injectFrame(methodVisitor, CompoundList.of(intermediateTypes, yieldedTypes), false);
 //                Object[] local = new Object[yieldedTypes.size()];
 //                int index = 0;
 //                for (TypeDescription typeDescription : yieldedTypes) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -586,6 +586,7 @@ public void testFrameAdviceStaticMethodExpanded() throws Exception {
     public void testFrameAdviceFrameInjected() throws Exception {
         Class<?> type = new ByteBuddy()
                 .redefine(Sample.class)
+                .visit(DebuggingWrapper.makeDefault())
                 .visit(Advice.to(FrameExitAdvice.class).on(named(FOO)))
                 .make()
                 .load(null, ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceSuppressionTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
+import net.bytebuddy.test.utility.DebuggingWrapper;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -43,6 +44,7 @@ public AdviceSuppressionTest(Class<?> type) {
     public void testIllegalAssignment() throws Exception {
         Class<?> dynamicType = new ByteBuddy()
                 .redefine(Sample.class)
+                .visit(DebuggingWrapper.makeDefault())
                 .visit(Advice.to(type).on(named(FOO)))
                 .make()
                 .load(null, ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -527,6 +527,7 @@ public String toString() {
                         "frameTranslator=" + FrameTranslator.this +
                         ", methodDescription=" + methodDescription +
                         ", intermediateTypes=" + intermediateTypes +
+                        ", yieldedTypes=" + yieldedTypes +
                         '}';
             }
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -314,7 +314,7 @@ private void translateFrame(MethodVisitor methodVisitor,
                         index += insertFrame(typeDescription, translated, index);
                     }
                     System.arraycopy(localVariable,
-                            localVariableLength - methodDescription.getParameters().size() - (methodDescription.isStatic() ? 0 : 1),
+                            methodDescription.getParameters().size() + (methodDescription.isStatic() ? 0 : 1),
                             translated,
                             index,
                             translated.length - index);

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -502,7 +502,6 @@ public void testFrameAdvice() throws Exception {
         Class<?> type = new ByteBuddy()
                 .redefine(FrameSample.class)
                 .visit(Advice.to(FrameAdvice.class).on(named(FOO)))
-                .visit(DebuggingWrapper.makeDefault())
                 .make()
                 .load(null, ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -170,7 +170,7 @@ private static Dispatcher resolve(Class<? extends Annotation> annotation, Dispat
      * @return A suitable ASM visitor wrapper with the <i>compute frames</i> option enabled.
      */
     public AsmVisitorWrapper.ForDeclaredMethods on(ElementMatcher<? super MethodDescription.InDefinedShape> matcher) {
-        return new AsmVisitorWrapper.ForDeclaredMethods().writerFlags(ClassWriter.COMPUTE_MAXS).readerFlags(ClassReader.EXPAND_FRAMES).method(matcher, this);
+        return new AsmVisitorWrapper.ForDeclaredMethods().writerFlags(ClassWriter.COMPUTE_MAXS).method(matcher, this);
     }
 
     @Override
@@ -260,9 +260,9 @@ private void injectFrame(MethodVisitor methodVisitor, TypeList intermediateTypes
                                 ? new Object[]{Type.getInternalName(Throwable.class)}
                                 : EMPTY);
             } else if (throwableOnStack) {
-                methodVisitor.visitFrame(Opcodes.F_SAME, UNDEFINED, EMPTY, UNDEFINED, EMPTY);
-            } else {
                 methodVisitor.visitFrame(Opcodes.F_SAME1, UNDEFINED, EMPTY, StackSize.SINGLE.getSize(), new Object[]{Type.getInternalName(Throwable.class)});
+            } else {
+                methodVisitor.visitFrame(Opcodes.F_SAME, UNDEFINED, EMPTY, UNDEFINED, EMPTY);
             }
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/AdviceTest.java
Patch:
@@ -699,6 +699,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.OffsetMapping.Target.ForParameter.class).apply();
         ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.OffsetMapping.Target.ForField.class).apply();
         ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.OffsetMapping.Target.ForConstantPoolValue.class).apply();
+        ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.OffsetMapping.Target.ForDefaultValue.class).apply();
         final int[] value = new int[1];
         ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.OffsetMapping.ForParameter.class).refine(new ObjectPropertyAssertion.Refinement<Advice.Argument>() {
             @Override
@@ -719,6 +720,7 @@ public void apply(Advice.Argument mock) {
         ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.OffsetMapping.ForOrigin.Renderer.ForMethodName.class).apply();
         ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.OffsetMapping.ForOrigin.Renderer.ForStringRepresentation.class).apply();
         ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.OffsetMapping.ForOrigin.Renderer.ForTypeName.class).apply();
+        ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.OffsetMapping.ForIgnored.class).apply();
         ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.OffsetMapping.ForReturnValue.class).apply();
         ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.OffsetMapping.ForReturnValue.Factory.class).apply();
         ObjectPropertyAssertion.of(Advice.Dispatcher.Active.Resolved.OffsetMapping.ForThrowable.class).apply();

File: byte-buddy-dep/src/test/java/net/bytebuddy/ClassFileVersionTest.java
Patch:
@@ -35,7 +35,7 @@ public void testComparison() throws Exception {
 
     @Test
     public void testVersionPropertyAction() throws Exception {
-        assertThat(ClassFileVersion.VersionPropertyAction.INSTANCE.run(), is(System.getProperty("java.version")));
+        assertThat(ClassFileVersion.VersionLocator.ForLegacyVm.INSTANCE.run(), is(System.getProperty("java.version")));
     }
 
     @Test
@@ -49,6 +49,5 @@ public Method create() {
                 return methods.next();
             }
         }).apply();
-        ObjectPropertyAssertion.of(ClassFileVersion.VersionPropertyAction.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultTest.java
Patch:
@@ -389,6 +389,7 @@ public void testTypeInLegacyConstantPool() throws Exception {
     @Test
     public void testTypeInLegacyConstantPoolRemapped() throws Exception {
         Class<?> dynamicType = new ByteBuddy(ClassFileVersion.JAVA_V4)
+                .with(TypeValidation.DISABLED)
                 .subclass(Object.class)
                 .visit(TypeConstantAdjustment.INSTANCE)
                 .defineMethod(FOO, Object.class, Visibility.PUBLIC)
@@ -402,6 +403,7 @@ public void testTypeInLegacyConstantPoolRemapped() throws Exception {
     @Test
     public void testArrayTypeInLegacyConstantPoolRemapped() throws Exception {
         Class<?> dynamicType = new ByteBuddy(ClassFileVersion.JAVA_V4)
+                .with(TypeValidation.DISABLED)
                 .subclass(Object.class)
                 .visit(TypeConstantAdjustment.INSTANCE)
                 .defineMethod(FOO, Object.class, Visibility.PUBLIC)
@@ -415,6 +417,7 @@ public void testArrayTypeInLegacyConstantPoolRemapped() throws Exception {
     @Test
     public void testPrimitiveTypeInLegacyConstantPoolRemapped() throws Exception {
         Class<?> dynamicType = new ByteBuddy(ClassFileVersion.JAVA_V4)
+                .with(TypeValidation.DISABLED)
                 .subclass(Object.class)
                 .visit(TypeConstantAdjustment.INSTANCE)
                 .defineMethod(FOO, Object.class, Visibility.PUBLIC)

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/FieldRegistry.java
Patch:
@@ -209,8 +209,8 @@ protected FieldTransformer getTransformer() {
             }
 
             @Override
-            public ElementMatcher<? super FieldDescription> resolve(TypeDescription instrumentedType) {
-                return matcher.resolve(instrumentedType);
+            public ElementMatcher<? super FieldDescription> resolve(TypeDescription typeDescription) {
+                return matcher.resolve(typeDescription);
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodRegistry.java
Patch:
@@ -642,8 +642,8 @@ protected Handler getHandler() {
             }
 
             @Override
-            public ElementMatcher<? super MethodDescription> resolve(TypeDescription instrumentedType) {
-                return matcher.resolve(instrumentedType);
+            public ElementMatcher<? super MethodDescription> resolve(TypeDescription typeDescription) {
+                return matcher.resolve(typeDescription);
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/Advice.java
Patch:
@@ -143,9 +143,9 @@ public void visitInsn(int opcode) {
                         mv.visitInsn(Opcodes.ACONST_NULL);
                         topValue(Opcodes.ASTORE);
                     }
-                    topValue(Opcodes.ASTORE, 1);
+                    topValue(Opcodes.ASTORE, instrumentedMethod.getReturnType().getStackSize().getSize());
                     onMethodExit();
-                    topValue(Opcodes.ALOAD, 1);
+                    topValue(Opcodes.ALOAD, instrumentedMethod.getReturnType().getStackSize().getSize());
                     break;
                 case Opcodes.ARETURN:
                     onMethodExit(Opcodes.ASTORE, Opcodes.ALOAD);
@@ -157,7 +157,7 @@ public void visitInsn(int opcode) {
         private void onMethodExit(int store, int load) {
             topValue(store);
             mv.visitInsn(Opcodes.ACONST_NULL);
-            topValue(Opcodes.ASTORE, 1);
+            topValue(Opcodes.ASTORE, instrumentedMethod.getReturnType().getStackSize().getSize());
             onMethodExit();
             topValue(load);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/advice/Advice.java
Patch:
@@ -143,18 +143,18 @@ public MethodVisitor visitMethod(int modifiers, String internalName, String desc
                 MethodDescription methodDescription = methods.get(internalName + descriptor);
                 return methodDescription == null
                         ? IGNORE_METHOD
-                        : new TransferingVisitor(AsmAdvice.this.mv, methodDescription);
+                        : new TransferringVisitor(AsmAdvice.this.mv, methodDescription);
             }
 
-            protected class TransferingVisitor extends MethodVisitor {
+            protected class TransferringVisitor extends MethodVisitor {
 
                 private final Map<Integer, ParameterDescription> parameters;
 
                 private final int offsetCorrection;
 
                 private final Label endOfMethod;
 
-                protected TransferingVisitor(MethodVisitor methodVisitor, MethodDescription inlinedMethod) {
+                protected TransferringVisitor(MethodVisitor methodVisitor, MethodDescription inlinedMethod) {
                     super(Opcodes.ASM5, methodVisitor);
                     parameters = new HashMap<Integer, ParameterDescription>();
                     for (ParameterDescription parameter : inlinedMethod.getParameters()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -2855,7 +2855,7 @@ public Builder<U> visit(AsmVisitorWrapper asmVisitorWrapper) {
                             fieldRegistry,
                             methodRegistry,
                             typeAttributeAppender,
-                            asmVisitorWrapper,
+                            new AsmVisitorWrapper.Compound(asmVisitorWrapper),
                             classFileVersion,
                             auxiliaryTypeNamingStrategy,
                             annotationValueFilterFactory,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1076,6 +1076,9 @@ public FieldDefinition.Optional<U> value(double value) {
 
                         @Override
                         public FieldDefinition.Optional<U> value(String value) {
+                            if (value == null) {
+                                throw new IllegalArgumentException("Cannot set null as a default value");
+                            }
                             return defaultValue(value);
                         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/AbstractImplementationTest.java
Patch:
@@ -12,8 +12,6 @@
 
 public abstract class AbstractImplementationTest {
 
-    private static final String SUFFIX = "foo";
-
     protected <T> DynamicType.Loaded<T> implement(Class<T> target, Implementation implementation) {
         return implement(target, implementation, target.getClassLoader(), isDeclaredBy(target));
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -880,7 +880,7 @@ public TypeDescription validated() {
                 } else if (methodDescription.isConstructor()) {
                     TypeDescription enclosingType = getEnclosingType();
                     if (receiverType == null || !receiverType.asErasure().equals(enclosingType == null ? this : enclosingType)) {
-//                        throw new IllegalStateException("Constructor " + methodDescription + " defines an illegal receiver " + receiverType);
+                        throw new IllegalStateException("Constructor " + methodDescription + " defines an illegal receiver " + receiverType);
                     }
                 } else if (/* methodDescription.isMethod() */ receiverType == null || !equals(receiverType.asErasure())) {
                     throw new IllegalStateException("Method " + methodDescription + " defines an illegal receiver " + receiverType);

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -704,7 +704,7 @@ public TypeDescription asErasure() {
 
                 @Override
                 protected AnnotationReader getAnnotationReader() {
-                    return AnnotationReader.DISPATCHER.resolveInterface(type, index);
+                    return AnnotationReader.DISPATCHER.resolveInterfaceType(type, index);
                 }
             }
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AbstractAnnotationDescriptionTest.java
Patch:
@@ -415,7 +415,8 @@ private void assertValue(Annotation annotation, String methodName, Object rawVal
                 Collections.<ParameterDescription.Token>emptyList(),
                 Collections.<TypeDescription.Generic>emptyList(),
                 Collections.<AnnotationDescription>emptyList(),
-                MethodDescription.NO_DEFAULT_VALUE)), is(rawValue));
+                MethodDescription.NO_DEFAULT_VALUE,
+                TypeDescription.Generic.UNDEFINED)), is(rawValue));
         assertThat(annotation.annotationType().getDeclaredMethod(methodName)
                 .invoke(describe(annotation).prepare(annotation.annotationType()).load()), is(loadedValue));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionArrayProjectionTest.java
Patch:
@@ -17,7 +17,7 @@ protected TypeDescription describe(Class<?> type) {
 
     @Override
     protected TypeDescription.Generic describeType(Field field) {
-        return TypeDefinition.Sort.describe(field.getGenericType(), TypeDescription.Generic.AnnotationReader.DISPATCHER.resolve(field));
+        return TypeDefinition.Sort.describe(field.getGenericType(), TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveFieldType(field));
     }
 
     @Override
@@ -39,12 +39,12 @@ protected TypeDescription.Generic describeExceptionType(Method method, int index
 
     @Override
     protected TypeDescription.Generic describeSuperClass(Class<?> type) {
-        return TypeDefinition.Sort.describe(type.getGenericSuperclass(), TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveSuperClass(type));
+        return TypeDefinition.Sort.describe(type.getGenericSuperclass(), TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveSuperClassType(type));
     }
 
     @Override
     protected TypeDescription.Generic describeInterfaceType(Class<?> type, int index) {
-        return TypeDefinition.Sort.describe(type.getGenericInterfaces()[index], TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveInterface(type, index));
+        return TypeDefinition.Sort.describe(type.getGenericInterfaces()[index], TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveInterfaceType(type, index));
     }
 
     @Test(expected = IllegalArgumentException.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericBuilderTest.java
Patch:
@@ -23,7 +23,7 @@ public class TypeDescriptionGenericBuilderTest extends AbstractTypeDescriptionGe
 
     @Override
     protected TypeDescription.Generic describeType(Field field) {
-        return describe(field.getGenericType(), TypeDescription.Generic.AnnotationReader.DISPATCHER.resolve(field))
+        return describe(field.getGenericType(), TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveFieldType(field))
                 .accept(TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(new FieldDescription.ForLoadedField(field)));
     }
 
@@ -47,13 +47,13 @@ protected TypeDescription.Generic describeExceptionType(Method method, int index
 
     @Override
     protected TypeDescription.Generic describeSuperClass(Class<?> type) {
-        return describe(type.getGenericSuperclass(), TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveSuperClass(type))
+        return describe(type.getGenericSuperclass(), TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveSuperClassType(type))
                 .accept(TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(new TypeDescription.ForLoadedType(type)));
     }
 
     @Override
     protected TypeDescription.Generic describeInterfaceType(Class<?> type, int index) {
-        return describe(type.getGenericInterfaces()[index], TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveInterface(type, index))
+        return describe(type.getGenericInterfaces()[index], TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveInterfaceType(type, index))
                 .accept(TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(new TypeDescription.ForLoadedType(type)));
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3197,7 +3197,7 @@ public AnnotationVisitor visitAnnotationDefault() {
 
                     @Override
                     public AnnotationVisitor visitTypeAnnotation(int typeReference, TypePath typePath, String descriptor, boolean visible) {
-                        return annotationRetention.isEnabled() || TypeReference.newTypeReference(TypeReference.METHOD_RECEIVER).getValue() == typeReference
+                        return annotationRetention.isEnabled()
                                 ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible)
                                 : IGNORE_ANNOTATION;
                     }
@@ -3282,7 +3282,7 @@ public AnnotationVisitor visitAnnotationDefault() {
 
                     @Override
                     public AnnotationVisitor visitTypeAnnotation(int typeReference, TypePath typePath, String descriptor, boolean visible) {
-                        return annotationRetention.isEnabled() || TypeReference.newTypeReference(TypeReference.METHOD_RECEIVER).getValue() == typeReference
+                        return annotationRetention.isEnabled()
                                 ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible)
                                 : IGNORE_ANNOTATION;
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -410,7 +410,7 @@ class Token implements ByteCodeElement.Token<Token> {
         private final List<? extends AnnotationDescription> annotations;
 
         /**
-         * Creates a new field token without annotations.
+         * Creates a new field token without annotations. The field type must be represented in its detached form.
          *
          * @param name      The name of the represented field.
          * @param modifiers The modifiers of the represented field.
@@ -421,7 +421,7 @@ public Token(String name, int modifiers, TypeDescription.Generic type) {
         }
 
         /**
-         * Creates a new field token.
+         * Creates a new field token. The field type must be represented in its detached form.
          *
          * @param name        The name of the represented field.
          * @param modifiers   The modifiers of the represented field.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/MethodTransformer.java
Patch:
@@ -147,7 +147,8 @@ public MethodDescription.Token transform(MethodDescription.Token token) {
                             token.getParameterTokens(),
                             token.getExceptionTypes(),
                             token.getAnnotations(),
-                            token.getDefaultValue());
+                            token.getDefaultValue(),
+                            token.getReceiverType());
                 }
 
                 @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -1056,7 +1056,8 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
                             Collections.singletonList(AnnotationDescription.Builder.ofType(SampleAnnotation.class).define(FOO, QUX).build()))),
                     Collections.singletonList(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Exception.class)),
                     Collections.singletonList(AnnotationDescription.Builder.ofType(SampleAnnotation.class).define(FOO, BAR).build()),
-                    MethodDescription.NO_DEFAULT_VALUE));
+                    MethodDescription.NO_DEFAULT_VALUE,
+                    TypeDescription.Generic.UNDEFINED));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/TargetType.java
Patch:
@@ -19,7 +19,7 @@ public final class TargetType {
      *
      * @param typeDescription The type description that might represent the {@link TargetType} placeholder.
      * @param targetType      The actual target type.
-     * @return The resolved type description.
+     * @return A description of the resolved type.
      */
     public static TypeDescription resolve(TypeDescription typeDescription, TypeDescription targetType) {
         int arity = 0;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -1086,7 +1086,7 @@ protected static FieldLocator consider(MethodDescription methodDescription) {
                 protected LookupStrategy lookup(TypeDescription typeDescription, TypeDescription instrumentedType) {
                     return typeDescription.represents(void.class)
                             ? new LookupStrategy.ForHierarchy(fieldName)
-                            : new LookupStrategy.ForExplicitType(fieldName, typeDescription.represents(TargetType.class) ? instrumentedType : typeDescription);
+                            : new LookupStrategy.ForExplicitType(fieldName, TargetType.resolve(typeDescription, instrumentedType));
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -201,7 +201,7 @@ private static MethodDescription onlyMethod(TypeDescription typeDescription) {
             }
             MethodList<?> methodCandidates = typeDescription.getDeclaredMethods().filter(isAbstract());
             if (methodCandidates.size() != 1) {
-                throw new IllegalArgumentException(typeDescription + " must declare exactly one non-static method");
+                throw new IllegalArgumentException(typeDescription + " must declare exactly one abstract method");
             }
             return methodCandidates.getOnly();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -163,7 +163,7 @@ private static MethodDescription onlyMethod(TypeDescription typeDescription) {
             }
             MethodList<?> methodCandidates = typeDescription.getDeclaredMethods().filter(isAbstract());
             if (methodCandidates.size() != 1) {
-                throw new IllegalArgumentException(typeDescription + " must declare exactly one non-static method");
+                throw new IllegalArgumentException(typeDescription + " must declare exactly one abstract method");
             }
             MethodDescription methodDescription = methodCandidates.getOnly();
             if (!methodDescription.getReturnType().asErasure().represents(Object.class)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -161,7 +161,7 @@ private static MethodDescription onlyMethod(TypeDescription typeDescription) {
             }
             MethodList<?> methodCandidates = typeDescription.getDeclaredMethods().filter(isAbstract());
             if (methodCandidates.size() != 1) {
-                throw new IllegalArgumentException(typeDescription + " must declare exactly one non-static method");
+                throw new IllegalArgumentException(typeDescription + " must declare exactly one abstract method");
             }
             MethodDescription methodDescription = methodCandidates.getOnly();
             if (!methodDescription.getReturnType().asErasure().represents(Object.class)) {

File: byte-buddy-android/src/main/java/net/bytebuddy/android/AndroidClassLoadingStrategy.java
Patch:
@@ -96,7 +96,8 @@ public AndroidClassLoadingStrategy(File privateDirectory) {
     }
 
     /**
-     * Creates a new Android class loading strategy that uses the given folder for storing classes.
+     * Creates a new Android class loading strategy that uses the given folder for storing classes. The directory is not cleared
+     * by Byte Buddy after the application terminates. This remains the responsibility of the user.
      *
      * @param privateDirectory A directory that is <b>not shared with other applications</b> to be used for storing
      *                         generated classes and their processed forms.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -199,7 +199,7 @@ private static MethodDescription onlyMethod(TypeDescription typeDescription) {
             } else if (!typeDescription.isPublic()) {
                 throw new IllegalArgumentException(typeDescription + " is mot public");
             }
-            MethodList<?> methodCandidates = typeDescription.getDeclaredMethods().filter(not(isStatic()));
+            MethodList<?> methodCandidates = typeDescription.getDeclaredMethods().filter(isAbstract());
             if (methodCandidates.size() != 1) {
                 throw new IllegalArgumentException(typeDescription + " must declare exactly one non-static method");
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -161,7 +161,7 @@ private static MethodDescription onlyMethod(TypeDescription typeDescription) {
             } else if (!typeDescription.isPublic()) {
                 throw new IllegalArgumentException(typeDescription + " is mot public");
             }
-            MethodList<?> methodCandidates = typeDescription.getDeclaredMethods().filter(not(isStatic()));
+            MethodList<?> methodCandidates = typeDescription.getDeclaredMethods().filter(isAbstract());
             if (methodCandidates.size() != 1) {
                 throw new IllegalArgumentException(typeDescription + " must declare exactly one non-static method");
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -159,7 +159,7 @@ private static MethodDescription onlyMethod(TypeDescription typeDescription) {
             } else if (!typeDescription.isPublic()) {
                 throw new IllegalArgumentException(typeDescription + " is mot public");
             }
-            MethodList<?> methodCandidates = typeDescription.getDeclaredMethods().filter(not(isStatic()));
+            MethodList<?> methodCandidates = typeDescription.getDeclaredMethods().filter(isAbstract());
             if (methodCandidates.size() != 1) {
                 throw new IllegalArgumentException(typeDescription + " must declare exactly one non-static method");
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.implementation.auxiliary;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.description.annotation.AnnotationDescription;
@@ -192,6 +193,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
         /**
          * Creates the precomputed method graph.
          */
+        @SuppressFBWarnings(value = "SE_BAD_FIELD_STORE", justification = "Precomputed method graph is not intended for serialization")
         PrecomputedMethodGraph() {
             LinkedHashMap<MethodDescription.SignatureToken, MethodGraph.Node> nodes = new LinkedHashMap<MethodDescription.SignatureToken, MethodGraph.Node>();
             MethodDescription callMethod = new MethodDescription.Latent(new TypeDescription.ForLoadedType(Callable.class),

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldProxyBinderTest.java
Patch:
@@ -237,9 +237,9 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(FieldProxy.Binder.StaticFieldConstructor.class).apply();
         ObjectPropertyAssertion.of(FieldProxy.Binder.FieldLocator.Legal.class).apply();
         ObjectPropertyAssertion.of(FieldProxy.Binder.FieldLocator.Illegal.class).apply();
-        ObjectPropertyAssertion.of(FieldProxy.Binder.FieldLocator.LookupEngine.ForHierarchy.class).apply();
-        ObjectPropertyAssertion.of(FieldProxy.Binder.FieldLocator.LookupEngine.ForExplicitType.class).apply();
-        ObjectPropertyAssertion.of(FieldProxy.Binder.FieldLocator.LookupEngine.Illegal.class).apply();
+        ObjectPropertyAssertion.of(FieldProxy.Binder.FieldLocator.LookupStrategy.ForHierarchy.class).apply();
+        ObjectPropertyAssertion.of(FieldProxy.Binder.FieldLocator.LookupStrategy.ForExplicitType.class).apply();
+        ObjectPropertyAssertion.of(FieldProxy.Binder.FieldLocator.LookupStrategy.Illegal.class).apply();
         ObjectPropertyAssertion.of(FieldProxy.Binder.FieldLocator.Resolution.Resolved.class).apply();
         ObjectPropertyAssertion.of(FieldProxy.Binder.FieldLocator.Resolution.Unresolved.class).apply();
         ObjectPropertyAssertion.of(FieldProxy.Binder.InstanceFieldConstructor.class).apply();

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -5,7 +5,6 @@
 
 import java.io.*;
 import java.lang.instrument.ClassFileTransformer;
-import java.lang.instrument.IllegalClassFormatException;
 import java.lang.instrument.Instrumentation;
 import java.lang.reflect.Field;
 import java.security.AccessControlContext;
@@ -1035,9 +1034,9 @@ public byte[] transform(ClassLoader classLoader,
                                     String internalName,
                                     Class<?> redefinedType,
                                     ProtectionDomain protectionDomain,
-                                    byte[] classFile) throws IllegalClassFormatException {
+                                    byte[] binaryRepresentation) {
                 if (internalName != null && isChild(classLoader) && typeName.equals(internalName.replace('/', '.'))) {
-                    this.binaryRepresentation = classFile;
+                    this.binaryRepresentation = binaryRepresentation;
                 }
                 return DO_NOT_TRANSFORM;
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -1093,7 +1093,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                 for (String value : values) {
                     FieldDescription fieldDescription = instrumentedType.getDeclaredFields().filter(named(value)).getOnly();
                     stackManipulation = new StackManipulation.Compound(stackManipulation,
-                            TypeCreation.forType(instrumentedType),
+                            TypeCreation.of(instrumentedType),
                             Duplication.SINGLE,
                             new TextConstant(value),
                             IntegerConstant.forValue(ordinal++),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -520,8 +520,8 @@ public static ClassFileLocator of(Instrumentation instrumentation, Class<?> type
         public Resolution locate(String typeName) {
             try {
                 ExtractionClassFileTransformer classFileTransformer = new ExtractionClassFileTransformer(classLoadingDelegate.getClassLoader(), typeName);
-                try {
                     instrumentation.addTransformer(classFileTransformer, true);
+                try {
                     instrumentation.retransformClasses(classLoadingDelegate.locate(typeName));
                     byte[] binaryRepresentation = classFileTransformer.getBinaryRepresentation();
                     return binaryRepresentation == null

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/ExceptionMethod.java
Patch:
@@ -180,7 +180,7 @@ public ForDefaultConstructor(TypeDescription exceptionType) {
             @Override
             public StackManipulation make() {
                 return new StackManipulation.Compound(
-                        TypeCreation.forType(exceptionType),
+                        TypeCreation.of(exceptionType),
                         Duplication.SINGLE,
                         MethodInvocation.invoke(targetConstructor));
             }
@@ -241,7 +241,7 @@ public ForStringConstructor(TypeDescription exceptionType, String message) {
             @Override
             public StackManipulation make() {
                 return new StackManipulation.Compound(
-                        TypeCreation.forType(exceptionType),
+                        TypeCreation.of(exceptionType),
                         Duplication.SINGLE,
                         new TextConstant(message),
                         MethodInvocation.invoke(targetConstructor));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -687,7 +687,7 @@ enum ForConstructingInvocation implements TargetHandler {
 
             @Override
             public StackManipulation resolve(MethodDescription invokedMethod, MethodDescription instrumentedMethod, TypeDescription instrumentedType, Assigner assigner, Assigner.Typing typing) {
-                return new StackManipulation.Compound(TypeCreation.forType(invokedMethod.getDeclaringType().asErasure()), Duplication.SINGLE);
+                return new StackManipulation.Compound(TypeCreation.of(invokedMethod.getDeclaringType().asErasure()), Duplication.SINGLE);
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -964,7 +964,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
             @Override
             public StackManipulation getPreparingStackAssignment(TypeDescription instrumentedType) {
                 return new StackManipulation.Compound(
-                        TypeCreation.forType(typeDescription),
+                        TypeCreation.of(typeDescription),
                         Duplication.SINGLE);
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -501,7 +501,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
             TypeDescription auxiliaryType = implementationContext
                     .register(new MethodCallProxy(specialMethodInvocation, serializable));
             return new Compound(
-                    TypeCreation.forType(auxiliaryType),
+                    TypeCreation.of(auxiliaryType),
                     Duplication.SINGLE,
                     MethodVariableAccess.allArgumentsOf(specialMethodInvocation.getMethodDescription()).prependThisReference(),
                     MethodInvocation.invoke(auxiliaryType.getDeclaredMethods().filter(isConstructor()).getOnly())

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TypeProxy.java
Patch:
@@ -161,7 +161,7 @@ protected enum AbstractMethodErrorThrow implements StackManipulation {
             TypeDescription abstractMethodError = new TypeDescription.ForLoadedType(AbstractMethodError.class);
             MethodDescription constructor = abstractMethodError.getDeclaredMethods()
                     .filter(isConstructor().and(takesArguments(0))).getOnly();
-            implementation = new Compound(TypeCreation.forType(abstractMethodError),
+            implementation = new Compound(TypeCreation.of(abstractMethodError),
                     Duplication.SINGLE,
                     MethodInvocation.invoke(constructor),
                     Throw.INSTANCE);
@@ -477,7 +477,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                 constructorValue[index++] = DefaultValue.of(parameterType);
             }
             return new Compound(
-                    TypeCreation.forType(proxyType),
+                    TypeCreation.of(proxyType),
                     Duplication.SINGLE,
                     new Compound(constructorValue),
                     MethodInvocation.invoke(proxyType.getDeclaredMethods().filter(isConstructor().and(takesArguments(constructorParameters))).getOnly()),
@@ -671,7 +671,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                             true,
                             serializableProxy));
             return new Compound(
-                    TypeCreation.forType(proxyType),
+                    TypeCreation.of(proxyType),
                     Duplication.SINGLE,
                     MethodInvocation.invoke(proxyType.getDeclaredMethods().filter(isConstructor()).getOnly()),
                     Duplication.SINGLE,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -1218,7 +1218,7 @@ public boolean isValid() {
             public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                 TypeDescription auxiliaryType = implementationContext.register(this);
                 return new Compound(
-                        TypeCreation.forType(auxiliaryType),
+                        TypeCreation.of(auxiliaryType),
                         Duplication.SINGLE,
                         accessedField.isStatic()
                                 ? Trivial.INSTANCE

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -405,7 +405,7 @@ public boolean isValid() {
             public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                 TypeDescription forwardingType = implementationContext.register(this);
                 return new Compound(
-                        TypeCreation.forType(forwardingType),
+                        TypeCreation.of(forwardingType),
                         Duplication.SINGLE,
                         specialMethodInvocation.getMethodDescription().isStatic()
                                 ? Trivial.INSTANCE

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -315,7 +315,7 @@ public boolean isValid() {
             public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                 TypeDescription forwardingType = implementationContext.register(this);
                 return new Compound(
-                        TypeCreation.forType(forwardingType),
+                        TypeCreation.of(forwardingType),
                         Duplication.SINGLE,
                         MethodVariableAccess.allArgumentsOf(sourceMethod),
                         MethodInvocation.invoke(forwardingType.getDeclaredMethods().filter(isConstructor()).getOnly())

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/TypeCreation.java
Patch:
@@ -30,7 +30,7 @@ protected TypeCreation(TypeDescription typeDescription) {
      * @param typeDescription The type to be create.
      * @return A stack manipulation that represents the creation of the given type.
      */
-    public static StackManipulation forType(TypeDescription typeDescription) {
+    public static StackManipulation of(TypeDescription typeDescription) {
         if (typeDescription.isArray() || typeDescription.isPrimitive() || typeDescription.isAbstract()) {
             throw new IllegalArgumentException(typeDescription + " is not instantiable");
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -2734,7 +2734,7 @@ protected LazyTypeDescription(TypePool typePool,
                                           List<FieldToken> fieldTokens,
                                           List<MethodToken> methodTokens) {
                 this.typePool = typePool;
-                this.modifiers = modifiers & ~Opcodes.ACC_SUPER;
+                this.modifiers = modifiers & ~(Opcodes.ACC_SUPER | Opcodes.ACC_DEPRECATED);
                 this.name = Type.getObjectType(name).getClassName();
                 this.superClassDescriptor = superClassInternalName == null
                         ? NO_SUPER_CLASS
@@ -6579,7 +6579,7 @@ private LazyFieldDescription(String name,
                                              GenericTypeToken.Resolution.ForField signatureResolution,
                                              Map<String, List<AnnotationToken>> typeAnnotationTokens,
                                              List<AnnotationToken> annotationTokens) {
-                    this.modifiers = modifiers;
+                    this.modifiers = modifiers & ~Opcodes.ACC_DEPRECATED;
                     this.name = name;
                     this.descriptor = descriptor;
                     this.signatureResolution = signatureResolution;
@@ -6745,7 +6745,7 @@ private LazyMethodDescription(String internalName,
                                               Map<Integer, List<AnnotationToken>> parameterAnnotationTokens,
                                               List<MethodToken.ParameterToken> parameterTokens,
                                               AnnotationDescription.AnnotationValue<?, ?> defaultValue) {
-                    this.modifiers = modifiers;
+                    this.modifiers = modifiers & ~Opcodes.ACC_DEPRECATED;
                     this.internalName = internalName;
                     Type methodType = Type.getMethodType(methodDescriptor);
                     Type returnType = methodType.getReturnType();

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterFieldPoolRecordTest.java
Patch:
@@ -67,7 +67,7 @@ public class TypeWriterFieldPoolRecordTest {
     @Before
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
-        when(fieldDescription.getModifiers()).thenReturn(MODIFIER);
+        when(fieldDescription.getActualModifiers()).thenReturn(MODIFIER);
         when(fieldDescription.getInternalName()).thenReturn(FOO);
         when(fieldDescription.getDescriptor()).thenReturn(BAR);
         when(fieldDescription.getGenericSignature()).thenReturn(QUX);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterMethodPoolRecordTest.java
Patch:
@@ -91,7 +91,7 @@ public void setUp() throws Exception {
         when(methodDescription.getDescriptor()).thenReturn(BAR);
         when(methodDescription.getGenericSignature()).thenReturn(QUX);
         when(methodDescription.getExceptionTypes()).thenReturn(exceptionTypes);
-        when(methodDescription.getAdjustedModifiers(anyBoolean())).thenReturn(MODIFIERS);
+        when(methodDescription.getActualModifiers(anyBoolean())).thenReturn(MODIFIERS);
         when(exceptionTypes.asErasures()).thenReturn(rawExceptionTypes);
         when(rawExceptionTypes.toInternalNames()).thenReturn(new String[]{BAZ});
         when(classVisitor.visitMethod(MODIFIERS, FOO, BAR, QUX, new String[]{BAZ})).thenReturn(methodVisitor);

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaInstanceMethodHandleTest.java
Patch:
@@ -35,6 +35,7 @@ public void testMethodHandleOfMethod() throws Exception {
         assertThat(methodHandle.getOwnerType(), is((TypeDescription) new TypeDescription.ForLoadedType(Foo.class)));
         assertThat(methodHandle.getReturnType(), is(TypeDescription.VOID));
         assertThat(methodHandle.getParameterTypes(), is((List<TypeDescription>) new TypeList.ForLoadedTypes(Void.class)));
+        assertThat(methodHandle.getDescriptor(), is(new MethodDescription.ForLoadedMethod(Foo.class.getDeclaredMethod(BAR, Void.class)).getDescriptor()));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaInstanceMethodTypeTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.utility;
 
+import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.test.utility.JavaVersionRule;
@@ -35,6 +36,7 @@ public void testMethodTypeOfMethod() throws Exception {
         JavaInstance.MethodType methodType = JavaInstance.MethodType.of(Foo.class.getDeclaredMethod(BAR, Void.class));
         assertThat(methodType.getReturnType(), is(TypeDescription.VOID));
         assertThat(methodType.getParameterTypes(), is((List<TypeDescription>) new TypeList.ForLoadedTypes(Void.class)));
+        assertThat(methodType.getDescriptor(), is(new MethodDescription.ForLoadedMethod(Foo.class.getDeclaredMethod(BAR, Void.class)).getDescriptor()));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -2734,7 +2734,7 @@ protected LazyTypeDescription(TypePool typePool,
                                           List<FieldToken> fieldTokens,
                                           List<MethodToken> methodTokens) {
                 this.typePool = typePool;
-                this.modifiers = modifiers & ~Opcodes.ACC_SUPER;
+                this.modifiers = modifiers & ~(Opcodes.ACC_SUPER | Opcodes.ACC_DEPRECATED);
                 this.name = Type.getObjectType(name).getClassName();
                 this.superClassDescriptor = superClassInternalName == null
                         ? NO_SUPER_CLASS
@@ -6579,7 +6579,7 @@ private LazyFieldDescription(String name,
                                              GenericTypeToken.Resolution.ForField signatureResolution,
                                              Map<String, List<AnnotationToken>> typeAnnotationTokens,
                                              List<AnnotationToken> annotationTokens) {
-                    this.modifiers = modifiers;
+                    this.modifiers = modifiers & ~Opcodes.ACC_DEPRECATED;
                     this.name = name;
                     this.descriptor = descriptor;
                     this.signatureResolution = signatureResolution;
@@ -6745,7 +6745,7 @@ private LazyMethodDescription(String internalName,
                                               Map<Integer, List<AnnotationToken>> parameterAnnotationTokens,
                                               List<MethodToken.ParameterToken> parameterTokens,
                                               AnnotationDescription.AnnotationValue<?, ?> defaultValue) {
-                    this.modifiers = modifiers;
+                    this.modifiers = modifiers & ~Opcodes.ACC_DEPRECATED;
                     this.internalName = internalName;
                     Type methodType = Type.getMethodType(methodDescriptor);
                     Type returnType = methodType.getReturnType();

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/ModifierContributor.java
Patch:
@@ -52,7 +52,7 @@ interface ForType extends ModifierContributor {
          */
         int MASK = Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED | Opcodes.ACC_PRIVATE | Opcodes.ACC_SYNTHETIC
                 | Opcodes.ACC_ABSTRACT | Opcodes.ACC_INTERFACE | Opcodes.ACC_ANNOTATION | Opcodes.ACC_DEPRECATED
-                | Opcodes.ACC_ENUM | Opcodes.ACC_FINAL | Opcodes.ACC_STATIC;
+                | Opcodes.ACC_ENUM | Opcodes.ACC_FINAL | Opcodes.ACC_STATIC | Opcodes.ACC_DEPRECATED;
     }
 
     /**
@@ -65,7 +65,7 @@ interface ForField extends ModifierContributor {
          */
         int MASK = Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED | Opcodes.ACC_PRIVATE | Opcodes.ACC_SYNTHETIC
                 | Opcodes.ACC_DEPRECATED | Opcodes.ACC_ENUM | Opcodes.ACC_FINAL | Opcodes.ACC_STATIC
-                | Opcodes.ACC_SYNTHETIC | Opcodes.ACC_TRANSIENT | Opcodes.ACC_VOLATILE;
+                | Opcodes.ACC_SYNTHETIC | Opcodes.ACC_TRANSIENT | Opcodes.ACC_VOLATILE | Opcodes.ACC_DEPRECATED;
     }
 
     /**
@@ -79,7 +79,7 @@ interface ForMethod extends ModifierContributor {
         int MASK = Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED | Opcodes.ACC_PRIVATE | Opcodes.ACC_SYNTHETIC
                 | Opcodes.ACC_BRIDGE | Opcodes.ACC_FINAL | Opcodes.ACC_NATIVE | Opcodes.ACC_ABSTRACT
                 | Opcodes.ACC_STATIC | Opcodes.ACC_STRICT | Opcodes.ACC_SYNCHRONIZED | Opcodes.ACC_SYNTHETIC
-                | Opcodes.ACC_VARARGS;
+                | Opcodes.ACC_VARARGS | Opcodes.ACC_DEPRECATED;
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/LambdaCreator.java
Patch:
@@ -122,7 +122,7 @@ public byte[] make(Object targetTypeLookup,
                     .withParameters(additionalBridge.getParameterTypes())
                     .intercept(new BridgeMethodImplementation(lambdaMethodName, lambdaMethod));
         }
-        byte[] classFile = builder.visit(DebuggingWrapper.makeDefault()).make().getBytes();
+        byte[] classFile = builder.make().getBytes();
         for (ClassFileTransformer classFileTransformer : classFileTransformers) {
             byte[] transformedClassFile = classFileTransformer.transform(targetType.getClassLoader(),
                     lambdaClassName.replace('.', '/'),

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/LambdaFactory.java
Patch:
@@ -38,7 +38,7 @@ public static boolean register(ClassFileTransformer classFileTransformer, Object
                             Object.class,
                             boolean.class,
                             List.class,
-                            List.class
+                            List.class,
                             Collection.class)));
                 }
             }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategyTest.java
Patch:
@@ -66,7 +66,7 @@ public void testFromAgentClassWithAuxiliaryReloadingStrategy() throws Exception
         Foo foo = new Foo();
         assertThat(foo.foo(), is(FOO));
         ClassReloadingStrategy classReloadingStrategy = ClassReloadingStrategy.fromInstalledAgent();
-        String randomName = RandomString.make();
+        String randomName = FOO + RandomString.make();
         new ByteBuddy()
                 .redefine(Foo.class)
                 .method(named(FOO))

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -563,7 +563,7 @@ public static Dispatcher make() {
                         @Override
                         public Accessor resolve(Class<?> virtualMachineType) {
                             try {
-                                return new Simple(virtualMachineType, (String) getPid.invoke(current.invoke(STATIC_MEMBER)));
+                                return new Simple(virtualMachineType, getPid.invoke(current.invoke(STATIC_MEMBER)).toString());
                             } catch (IllegalAccessException exception) {
                                 throw new UnsupportedOperationException("Not yet implemented");
                             } catch (InvocationTargetException exception) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -377,7 +377,7 @@ public String getName(AccessibleObject executable, int index) {
                  * @param index      The index of the parameter.
                  * @return The parameter for the given index.
                  */
-                private Object getParameter(Object executable, int index) {
+                private Object getParameter(AccessibleObject executable, int index) {
                     try {
                         return Array.get(getParameters.invoke(executable), index);
                     } catch (IllegalAccessException exception) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderParentMatcher.java
Patch:
@@ -3,7 +3,7 @@
 /**
  * An element matcher that matches a class loader for being a parent of the given class loader.
  *
- * @param <T>The exact type of the class loader that is matched.
+ * @param <T> The exact type of the class loader that is matched.
  */
 public class ClassLoaderParentMatcher<T extends ClassLoader> implements ElementMatcher<T> {
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericAnnotationReaderTest.java
Patch:
@@ -77,6 +77,7 @@ public void testAnnotationReaderNoOpTest() throws Exception {
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(TypeDescription.Generic.AnnotationReader.NoOp.class).apply();
         ObjectPropertyAssertion.of(TypeDescription.Generic.AnnotationReader.ForComponentType.class).apply();
+        ObjectPropertyAssertion.of(TypeDescription.Generic.AnnotationReader.ForOwnerType.class).apply();
         ObjectPropertyAssertion.of(TypeDescription.Generic.AnnotationReader.ForTypeArgument.class).apply();
         ObjectPropertyAssertion.of(TypeDescription.Generic.AnnotationReader.ForTypeVariableBoundType.class).apply();
         ObjectPropertyAssertion.of(TypeDescription.Generic.AnnotationReader.ForWildcardLowerBoundType.class).apply();

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -5950,7 +5950,7 @@ public static Builder rawType(TypeDescription type, Generic ownerType) {
                 TypeDescription declaringType = type.getDeclaringType();
                 if (declaringType == null && ownerType != null) {
                     throw new IllegalArgumentException(type + " does not have a declaring type: " + ownerType);
-                } else if (declaringType != null && (ownerType == null || !declaringType.equals(type))) {
+                } else if (declaringType != null && (ownerType == null || !declaringType.equals(ownerType.asErasure()))) {
                     throw new IllegalArgumentException(ownerType + " is not the declaring type of " + type);
                 }
                 return new Builder.OfNonGenericType(type, ownerType);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultCall.java
Patch:
@@ -98,6 +98,8 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             TypeDescription targetType = target.getType().asErasure();
             if (!targetType.represents(Runnable.class) && !targetType.represents(Callable.class) && !targetType.represents(Object.class)) {
                 throw new IllegalStateException("A default method call proxy can only be assigned to Runnable or Callable types: " + target);
+            } else if (source.isConstructor()) {
+                return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             }
             TypeDescription typeDescription = annotation.getValue(TARGET_TYPE, TypeDescription.class);
             Implementation.SpecialMethodInvocation specialMethodInvocation = (typeDescription.represents(void.class)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperCall.java
Patch:
@@ -72,6 +72,8 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             TypeDescription targetType = target.getType().asErasure();
             if (!targetType.represents(Runnable.class) && !targetType.represents(Callable.class) && !targetType.represents(Object.class)) {
                 throw new IllegalStateException("A super method call proxy can only be assigned to Runnable or Callable types: " + target);
+            } else if (source.isConstructor()) {
+                return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             }
             Implementation.SpecialMethodInvocation specialMethodInvocation = annotation.loadSilent().fallbackToDefault()
                     ? implementationTarget.invokeDominant(source.asSignatureToken())

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -3368,7 +3368,7 @@ public TypeDescription asErasure() {
 
                         @Override
                         public Generic getOwnerType() {
-                            return UNDEFINED; // TODO: Test
+                            return UNDEFINED;
                         }
 
                         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -4966,7 +4966,7 @@ public boolean isPrimaryBound(TypePool typePool) {
 
                     @Override
                     public String getPathPrefix() {
-                        return EMPTY_TYPE_PATH;
+                        return String.valueOf(OWNER_TYPE_PATH);
                     }
 
                     @Override
@@ -6346,7 +6346,7 @@ public TypeDescription asErasure() {
 
                 @Override
                 public AnnotationList getDeclaredAnnotations() {
-                    return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(GenericTypeToken.EMPTY_TYPE_PATH));
+                    return resolve().getDeclaredAnnotations();
                 }
 
                 /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -3472,7 +3472,7 @@ protected class AnnotationAdapter extends MethodDefinition.AbstractBase.Adapter<
                          * @param handler The handler that determines how a method is implemented.
                          */
                         protected AnnotationAdapter(MethodRegistry.Handler handler) {
-                            this(handler, MethodAttributeAppender.ForInstrumentedMethod.INSTANCE, MethodTransformer.NoOp.INSTANCE);
+                            this(handler, MethodAttributeAppender.ForInstrumentedMethod.EXCLUDING_RECEIVER, MethodTransformer.NoOp.INSTANCE);
                         }
 
                         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategy.java
Patch:
@@ -111,7 +111,7 @@ public List<MethodDescription.Token> extractConstructors(TypeDescription instrum
             public MethodRegistry inject(MethodRegistry methodRegistry) {
                 return methodRegistry.append(new LatentMatcher.Resolved<MethodDescription>(isConstructor()),
                         new MethodRegistry.Handler.ForImplementation(SuperMethodCall.INSTANCE),
-                        MethodAttributeAppender.ForInstrumentedMethod.INSTANCE,
+                        MethodAttributeAppender.ForInstrumentedMethod.EXCLUDING_RECEIVER,
                         MethodTransformer.NoOp.INSTANCE);
             }
         },
@@ -134,7 +134,7 @@ public List<MethodDescription.Token> extractConstructors(TypeDescription instrum
             public MethodRegistry inject(MethodRegistry methodRegistry) {
                 return methodRegistry.append(new LatentMatcher.Resolved<MethodDescription>(isConstructor()),
                         new MethodRegistry.Handler.ForImplementation(SuperMethodCall.INSTANCE),
-                        MethodAttributeAppender.ForInstrumentedMethod.INSTANCE,
+                        MethodAttributeAppender.ForInstrumentedMethod.EXCLUDING_RECEIVER,
                         MethodTransformer.NoOp.INSTANCE);
             }
         };

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategyDefaultTest.java
Patch:
@@ -75,7 +75,7 @@ public void testImitateSuperClassStrategy() throws Exception {
         assertThat(ConstructorStrategy.Default.IMITATE_SUPER_CLASS.inject(methodRegistry), is(methodRegistry));
         verify(methodRegistry).append(any(LatentMatcher.class),
                 any(MethodRegistry.Handler.class),
-                eq(MethodAttributeAppender.ForInstrumentedMethod.INSTANCE),
+                eq(MethodAttributeAppender.ForInstrumentedMethod.EXCLUDING_RECEIVER),
                 eq(MethodTransformer.NoOp.INSTANCE));
         verifyNoMoreInteractions(methodRegistry);
         verify(instrumentedType, atLeastOnce()).getSuperClass();
@@ -91,7 +91,7 @@ public void testImitateSuperClassPublicStrategy() throws Exception {
         assertThat(ConstructorStrategy.Default.IMITATE_SUPER_CLASS_PUBLIC.inject(methodRegistry), is(methodRegistry));
         verify(methodRegistry).append(any(LatentMatcher.class),
                 any(MethodRegistry.Handler.class),
-                eq(MethodAttributeAppender.ForInstrumentedMethod.INSTANCE),
+                eq(MethodAttributeAppender.ForInstrumentedMethod.EXCLUDING_RECEIVER),
                 eq(MethodTransformer.NoOp.INSTANCE));
         verifyNoMoreInteractions(methodRegistry);
         verify(instrumentedType, atLeastOnce()).getSuperClass();

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -6837,7 +6837,7 @@ public Generic getReceiverType() {
                                 ? new LazyParameterizedReceiverType(receiverType)
                                 : new LazyNonGenericReceiverType(receiverType);
                     } else {
-                        return isGenericDeclaration()
+                        return LazyTypeDescription.this.isGenericDeclaration()
                                 ? new LazyParameterizedReceiverType()
                                 : new LazyNonGenericReceiverType();
                     }
@@ -7045,7 +7045,7 @@ protected LazyNonGenericReceiverType() {
                     }
 
                     protected LazyNonGenericReceiverType(TypeDescription typeDescription) {
-                        this(LazyTypeDescription.this, GenericTypeToken.EMPTY_TYPE_PATH);
+                        this(typeDescription, GenericTypeToken.EMPTY_TYPE_PATH);
                     }
 
                     protected LazyNonGenericReceiverType(TypeDescription typeDescription, String typePath) {
@@ -7060,7 +7060,7 @@ public Generic getComponentType() {
 
                     @Override
                     public AnnotationList getDeclaredAnnotations() {
-                        return LazyAnnotationDescription.asListOfNullable(typePool, receiverTypeAnnotationTokens.get(typePath + GenericTypeToken.OWNER_TYPE_PATH));
+                        return LazyAnnotationDescription.asListOfNullable(typePool, receiverTypeAnnotationTokens.get(typePath));
                     }
 
                     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionGenericTest.java
Patch:
@@ -1520,7 +1520,8 @@ public void testTypeAnnotationOwnerType() throws Exception {
         assertThat(fieldType.getOwnerType().getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
         assertThat(fieldType.getOwnerType().getDeclaredAnnotations().size(), is(1));
         assertThat(fieldType.getOwnerType().getDeclaredAnnotations().isAnnotationPresent(typeAnnotation), is(true));
-        assertThat(fieldType.getOwnerType().getDeclaredAnnotations().ofType(typeAnnotation).getValue(value, Integer.class), is(3));;
+        assertThat(fieldType.getOwnerType().getDeclaredAnnotations().ofType(typeAnnotation).getValue(value, Integer.class), is(3));
+        ;
         assertThat(fieldType.getOwnerType().getTypeArguments().getOnly().getSort(), is(TypeDefinition.Sort.NON_GENERIC));
         assertThat(fieldType.getOwnerType().getTypeArguments().getOnly().getDeclaredAnnotations().size(), is(1));
         assertThat(fieldType.getOwnerType().getTypeArguments().getOnly().getDeclaredAnnotations().isAnnotationPresent(typeAnnotation), is(true));

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -5850,7 +5850,7 @@ public static Builder parameterizedType(TypeDescription rawType, Generic ownerTy
                 }
                 if (!rawType.isGenericDeclaration()) {
                     throw new IllegalArgumentException(rawType + " is not a parameterized type");
-                } if (ownerType == null && declaringType != null && !rawType.isStatic()) {
+                } else if (ownerType == null && declaringType != null && !rawType.isStatic()) {
                     throw new IllegalArgumentException(rawType + " requires an owner type");
                 } else if (ownerType != null && !ownerType.asErasure().equals(declaringType)) {
                     throw new IllegalArgumentException(ownerType + " does not represent required owner for " + rawType);

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -6221,7 +6221,9 @@ protected Builder doAnnotate(List<? extends AnnotationDescription> annotations)
 
                 @Override
                 protected Generic doBuild() {
-                    return new Generic.OfParameterizedType.Latent(rawType, ownerType, parameterTypes, annotations);
+                    return ownerType == null && parameterTypes.isEmpty()
+                            ? new Generic.OfNonGenericType.Latent(rawType, annotations)
+                            : new Generic.OfParameterizedType.Latent(rawType, ownerType, parameterTypes, annotations);
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -6663,6 +6663,7 @@ public boolean isAnnotationValue() {
         }
 
         @Override
+        @SuppressFBWarnings(value = "EC_UNRELATED_CLASS_AND_INTERFACE", justification = "Fits equality contract for type definitions")
         public boolean represents(java.lang.reflect.Type type) {
             return equals(Sort.describe(type));
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -6719,6 +6719,7 @@ private class LazyMethodDescription extends MethodDescription.InDefinedShape.Abs
                  *                                          class was corrupt.
                  * @param defaultValue                      The default value of this method or {@code null} if there is no
                  */
+                @SuppressFBWarnings(value = "URF_UNREAD_FIELD", justification = "To be removed once type annotations are in place")
                 private LazyMethodDescription(String internalName,
                                               int modifiers,
                                               String methodDescriptor,

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericAnnotationReaderTest.java
Patch:
@@ -10,6 +10,7 @@
 import java.util.Iterator;
 
 import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.CoreMatchers.nullValue;
 import static org.junit.Assert.assertThat;
 
 public class TypeDescriptionGenericAnnotationReaderTest {
@@ -30,6 +31,8 @@ public void testLegacyVmReturnsNoOpReaders() throws Exception {
                 is((TypeDescription.Generic.AnnotationReader) TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE));
         assertThat(TypeDescription.Generic.AnnotationReader.Dispatcher.ForLegacyVm.INSTANCE.resolveTypeVariable(null),
                 is((TypeDescription.Generic.AnnotationReader) TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE));
+        assertThat(TypeDescription.Generic.AnnotationReader.Dispatcher.ForLegacyVm.INSTANCE.resolveReceiverType(null),
+                nullValue(TypeDescription.Generic.class));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericAnnotationReaderTest.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.description.type;
 
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
+import net.bytebuddy.utility.CompoundList;
 import org.junit.Test;
 
 import java.lang.reflect.Field;
@@ -60,7 +61,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(TypeDescription.Generic.AnnotationReader.ForWildcardLowerBoundType.class).apply();
         ObjectPropertyAssertion.of(TypeDescription.Generic.AnnotationReader.ForWildcardUpperBoundType.class).apply();
         ObjectPropertyAssertion.of(TypeDescription.Generic.AnnotationReader.Dispatcher.ForLegacyVm.class).apply();
-        final Iterator<Method> methods = Arrays.asList(Object.class.getDeclaredMethods()).iterator();
+        final Iterator<Method> methods = CompoundList.of(Arrays.asList(Object.class.getDeclaredMethods()), Arrays.asList(String.class.getDeclaredMethods())).iterator();
         ObjectPropertyAssertion.of(TypeDescription.Generic.AnnotationReader.Dispatcher.ForModernVm.class)
                 .create(new ObjectPropertyAssertion.Creator<Method>() {
                     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -344,9 +344,9 @@ public static InstrumentedType.WithFlexibleName subclass(String name, int modifi
                     Collections.<AnnotationDescription>emptyList(),
                     TypeInitializer.None.INSTANCE,
                     LoadedTypeInitializer.NoOp.INSTANCE,
-                    UNDEFINED,
+                    TypeDescription.UNDEFINED,
                     MethodDescription.UNDEFINED,
-                    UNDEFINED,
+                    TypeDescription.UNDEFINED,
                     Collections.<TypeDescription>emptyList(),
                     false,
                     false,

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -1,6 +1,5 @@
 package net.bytebuddy;
 
-import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.modifier.*;
@@ -981,12 +980,12 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
             for (String value : values) {
                 instrumentedType = instrumentedType.withField(new FieldDescription.Token(value,
                         ENUM_FIELD_MODIFIERS | Opcodes.ACC_ENUM,
-                        TargetType.GENERIC_DESCRIPTION));
+                        TargetType.DESCRIPTION.asGenericType()));
             }
             return instrumentedType
                     .withField(new FieldDescription.Token(ENUM_VALUES,
                             ENUM_FIELD_MODIFIERS | Opcodes.ACC_SYNTHETIC,
-                            new TypeDescription.Generic.OfGenericArray.Latent(TargetType.GENERIC_DESCRIPTION, Collections.<AnnotationDescription>emptyList())))
+                            TypeDescription.ArrayProjection.of(TargetType.DESCRIPTION).asGenericType()))
                     .withInitializer(new InitializationAppender(values));
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorSubstitutorForTokenNormalizationTest.java
Patch:
@@ -39,7 +39,7 @@ public void setUp() throws Exception {
 
     @Test
     public void testTargetType() throws Exception {
-        assertThat(new TypeDescription.Generic.Visitor.Substitutor.ForTokenNormalization(target).onSimpleType(TargetType.GENERIC_DESCRIPTION), is(target));
+        assertThat(new TypeDescription.Generic.Visitor.Substitutor.ForTokenNormalization(target).onSimpleType(TargetType.DESCRIPTION.asGenericType()), is(target));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -1086,7 +1086,7 @@ protected static FieldLocator consider(MethodDescription methodDescription) {
                 protected LookupEngine lookup(TypeDescription typeDescription, TypeDescription instrumentedType) {
                     return typeDescription.represents(void.class)
                             ? new LookupEngine.ForHierarchy(fieldName)
-                            : new LookupEngine.ForExplicitType(fieldName, typeDescription.equals(TargetType.DESCRIPTION) ? instrumentedType : typeDescription);
+                            : new LookupEngine.ForExplicitType(fieldName, typeDescription.represents(TargetType.class) ? instrumentedType : typeDescription);
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -568,7 +568,7 @@ public TypeDescription.Generic findVariable(String symbol) {
 
         @Override
         public <T> T accept(TypeVariableSource.Visitor<T> visitor) {
-            return visitor.onMethod(this.asDefined()); // TODO!
+            return visitor.onMethod(this.asDefined());
         }
 
         @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorTypeVariableErasingTest.java
Patch:
@@ -9,5 +9,6 @@ public class TypeDescriptionGenericVisitorTypeVariableErasingTest {
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(TypeDescription.Generic.Visitor.TypeVariableErasing.class).apply();
         ObjectPropertyAssertion.of(TypeDescription.Generic.Visitor.TypeVariableErasing.PartialErasureReviser.class).apply();
+        ObjectPropertyAssertion.of(TypeDescription.Generic.Visitor.TypeVariableErasing.TypeVariableReviser.class).apply();
     }
 }
\ No newline at end of file

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/TypeVariableSource.java
Patch:
@@ -61,7 +61,7 @@ interface Visitor<T> {
          * @param methodDescription The method onto which this visitor is applied.
          * @return The visitor's return value.
          */
-        T onMethod(MethodDescription methodDescription);
+        T onMethod(MethodDescription.InDefinedShape methodDescription);
 
         /**
          * A none-operational implementation of a type variable visitor that simply returns the visited source.
@@ -79,7 +79,7 @@ public TypeVariableSource onType(TypeDescription typeDescription) {
             }
 
             @Override
-            public TypeVariableSource onMethod(MethodDescription methodDescription) {
+            public TypeVariableSource onMethod(MethodDescription.InDefinedShape methodDescription) {
                 return methodDescription;
             }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/TypeVariableSourceVisitorNoOpTest.java
Patch:
@@ -20,7 +20,7 @@ public void testVisitType() throws Exception {
 
     @Test
     public void testVisitMethod() throws Exception {
-        MethodDescription methodDescription = mock(MethodDescription.class);
+        MethodDescription.InDefinedShape methodDescription = mock(MethodDescription.InDefinedShape.class);
         assertThat(TypeVariableSource.Visitor.NoOp.INSTANCE.onMethod(methodDescription), is((TypeVariableSource) methodDescription));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionGenericTest.java
Patch:
@@ -1077,7 +1077,7 @@ public void testMethodTypeVariableIsRetained() throws Exception {
         MethodDescription methodDescription = typeDescription.getDeclaredMethods().filter(named(FOO)).getOnly();
         assertThat(methodDescription.getReturnType().getSort(), is(TypeDefinition.Sort.VARIABLE));
         assertThat(methodDescription.getReturnType().getSymbol(), is("S"));
-        assertThat(methodDescription.getReturnType().getVariableSource(), is((TypeVariableSource) methodDescription));
+        assertThat(methodDescription.getReturnType().getVariableSource(), is((TypeVariableSource) methodDescription.asDefined()));
     }
 
     @Test
@@ -1092,7 +1092,7 @@ public void testShadowedMethodTypeVariableIsRetained() throws Exception {
         MethodDescription methodDescription = typeDescription.getDeclaredMethods().filter(named(BAR)).getOnly();
         assertThat(methodDescription.getReturnType().getSort(), is(TypeDefinition.Sort.VARIABLE));
         assertThat(methodDescription.getReturnType().getSymbol(), is("T"));
-        assertThat(methodDescription.getReturnType().getVariableSource(), is((TypeVariableSource) methodDescription));
+        assertThat(methodDescription.getReturnType().getVariableSource(), is((TypeVariableSource) methodDescription.asDefined()));
     }
 
     @Test
@@ -1107,7 +1107,7 @@ public void testMethodTypeVariableWithExtensionIsRetained() throws Exception {
         MethodDescription methodDescription = typeDescription.getDeclaredMethods().filter(named(QUX)).getOnly();
         assertThat(methodDescription.getReturnType().getSort(), is(TypeDefinition.Sort.VARIABLE));
         assertThat(methodDescription.getReturnType().getSymbol(), is("S"));
-        assertThat(methodDescription.getReturnType().getVariableSource(), is((TypeVariableSource) methodDescription));
+        assertThat(methodDescription.getReturnType().getVariableSource(), is((TypeVariableSource) methodDescription.asDefined()));
         assertThat(methodDescription.getReturnType().getUpperBounds().size(), is(1));
         assertThat(methodDescription.getReturnType().getUpperBounds().getOnly().getSort(), is(TypeDefinition.Sort.NON_GENERIC));
         assertThat(methodDescription.getReturnType().getUpperBounds().getOnly().asErasure().represents(Number.class), is(true));

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -86,7 +86,7 @@ public void testExtensiveExample() throws Exception {
         Class<? extends Function> dynamicType = new ByteBuddy()
             .subclass(Function.class)
             .method(named("apply"))
-            .intercept(MethodDelegation.to(new FunctionInterceptor()))
+            .intercept(MethodDelegation.to(new GreetingInterceptor()))
             .make()
             .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
             .getLoaded();
@@ -558,9 +558,9 @@ public interface Function {
         Object apply(Object arg);
     }
 
-    public static class FunctionInterceptor {
+    public static class GreetingInterceptor {
 
-        public Object intercept(Object argument) {
+        public Object greet(Object argument) {
             return "Hello from " + argument;
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/collection/ArrayFactory.java
Patch:
@@ -37,7 +37,7 @@ public class ArrayFactory implements CollectionFactory {
      * Creates a new array factory with a given
      * {@link net.bytebuddy.implementation.bytecode.collection.ArrayFactory.ArrayCreator}
      * without inferring the type from the component type. Normally,
-     * {@link net.bytebuddy.implementation.bytecode.collection.ArrayFactory#forType(TypeDescription)}
+     * {@link net.bytebuddy.implementation.bytecode.collection.ArrayFactory#forType(net.bytebuddy.description.type.TypeDescription.Generic)}
      * should be used.
      *
      * @param componentType The component type of the array factory.

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/ClassByExtensionBenchmark.java
Patch:
@@ -6,6 +6,7 @@
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.benchmark.specimen.ExampleClass;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
+import net.bytebuddy.dynamic.scaffold.TypeValidation;
 import net.bytebuddy.implementation.MethodDelegation;
 import net.bytebuddy.implementation.SuperMethodCall;
 import net.bytebuddy.implementation.bind.annotation.RuntimeType;
@@ -75,6 +76,7 @@ private ClassLoader newClassLoader() {
     @Benchmark
     public ExampleClass benchmarkByteBuddyWithAnnotations() throws Exception {
         return new ByteBuddy()
+                .with(TypeValidation.DISABLED)
                 .ignore(none())
                 .subclass(baseClass)
                 .method(isDeclaredBy(ExampleClass.class)).intercept(MethodDelegation.to(ByteBuddyInterceptor.class))
@@ -94,6 +96,7 @@ public ExampleClass benchmarkByteBuddyWithAnnotations() throws Exception {
     @Benchmark
     public ExampleClass benchmarkByteBuddySpecialized() throws Exception {
         return new ByteBuddy()
+                .with(TypeValidation.DISABLED)
                 .ignore(none())
                 .subclass(baseClass)
                 .method(isDeclaredBy(ExampleClass.class)).intercept(SuperMethodCall.INSTANCE)

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/ClassByImplementationBenchmark.java
Patch:
@@ -6,6 +6,7 @@
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.benchmark.specimen.ExampleInterface;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
+import net.bytebuddy.dynamic.scaffold.TypeValidation;
 import net.bytebuddy.implementation.StubMethod;
 import net.sf.cglib.proxy.CallbackHelper;
 import net.sf.cglib.proxy.Enhancer;
@@ -166,6 +167,7 @@ private ClassLoader newClassLoader() {
     @Benchmark
     public ExampleInterface benchmarkByteBuddy() throws Exception {
         return new ByteBuddy()
+                .with(TypeValidation.DISABLED)
                 .ignore(none())
                 .subclass(baseClass)
                 .method(isDeclaredBy(baseClass)).intercept(StubMethod.INSTANCE)

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/TrivialClassCreationBenchmark.java
Patch:
@@ -4,6 +4,7 @@
 import javassist.util.proxy.ProxyFactory;
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
+import net.bytebuddy.dynamic.scaffold.TypeValidation;
 import net.sf.cglib.proxy.Enhancer;
 import net.sf.cglib.proxy.NoOp;
 import org.openjdk.jmh.annotations.*;
@@ -65,6 +66,7 @@ private ClassLoader newClassLoader() {
     @Benchmark
     public Class<?> benchmarkByteBuddy() {
         return new ByteBuddy()
+                .with(TypeValidation.DISABLED)
                 .ignore(any())
                 .subclass(baseClass)
                 .make()

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -1435,7 +1435,7 @@ abstract class AbstractBase implements AnnotationDescription {
          */
         private static final ElementType[] DEFAULT_TARGET = new ElementType[]{ElementType.ANNOTATION_TYPE,
                 ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.LOCAL_VARIABLE, ElementType.METHOD,
-                ElementType.PACKAGE, ElementType.PARAMETER, ElementType.TYPE, ElementType.TYPE_PARAMETER};
+                ElementType.PACKAGE, ElementType.PARAMETER, ElementType.TYPE};
 
         @Override
         public RetentionPolicy getRetention() {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -5348,7 +5348,7 @@ public static class OfConstructorParameter extends LazyProjection.OfAnnotatedEle
                  * @param index       The parameter's index.
                  * @param erasure     The erasure of the parameter type.
                  */
-                @SuppressFBWarnings(value = "I2 - EI_EXPOSE_REP2", justification = "The array is never exposed outside of the class")
+                @SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "The array is never exposed outside of the class")
                 public OfConstructorParameter(Constructor<?> constructor, int index, Class<?>[] erasure) {
                     this.constructor = constructor;
                     this.index = index;
@@ -5401,7 +5401,7 @@ public static class OfMethodParameter extends LazyProjection.OfAnnotatedElement
                  * @param index   The parameter's index.
                  * @param erasure The erasures of the method's parameter types.
                  */
-                @SuppressFBWarnings(value = "I2 - EI_EXPOSE_REP2", justification = "The array is never exposed outside of the class")
+                @SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "The array is never exposed outside of the class")
                 public OfMethodParameter(Method method, int index, Class<?>[] erasure) {
                     this.method = method;
                     this.index = index;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3194,7 +3194,7 @@ public AnnotationVisitor visitAnnotationDefault() {
 
                     @Override
                     public AnnotationVisitor visitTypeAnnotation(int typeReference, TypePath typePath, String descriptor, boolean visible) {
-                        return annotationRetention.isEnabled()
+                        return annotationRetention.isEnabled() || TypeReference.newTypeReference(TypeReference.METHOD_RECEIVER).getValue() == typeReference
                                 ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible)
                                 : IGNORE_ANNOTATION;
                     }
@@ -3279,7 +3279,7 @@ public AnnotationVisitor visitAnnotationDefault() {
 
                     @Override
                     public AnnotationVisitor visitTypeAnnotation(int typeReference, TypePath typePath, String descriptor, boolean visible) {
-                        return annotationRetention.isEnabled()
+                        return annotationRetention.isEnabled() || TypeReference.newTypeReference(TypeReference.METHOD_RECEIVER).getValue() == typeReference
                                 ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible)
                                 : IGNORE_ANNOTATION;
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -5348,6 +5348,7 @@ public static class OfConstructorParameter extends LazyProjection.OfAnnotatedEle
                  * @param index       The parameter's index.
                  * @param erasure     The erasure of the parameter type.
                  */
+                @SuppressFBWarnings(value = "I2 - EI_EXPOSE_REP2", justification = "The array is never exposed outside of the class")
                 public OfConstructorParameter(Constructor<?> constructor, int index, Class<?>[] erasure) {
                     this.constructor = constructor;
                     this.index = index;
@@ -5400,6 +5401,7 @@ public static class OfMethodParameter extends LazyProjection.OfAnnotatedElement
                  * @param index   The parameter's index.
                  * @param erasure The erasures of the method's parameter types.
                  */
+                @SuppressFBWarnings(value = "I2 - EI_EXPOSE_REP2", justification = "The array is never exposed outside of the class")
                 public OfMethodParameter(Method method, int index, Class<?>[] erasure) {
                     this.method = method;
                     this.index = index;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -1487,7 +1487,7 @@ public enum ForTypeAnnotations implements Visitor<Boolean> {
                     public static boolean ofFormalTypeVariable(Generic typeVariable) {
                         Set<TypeDescription> annotationTypes = new HashSet<TypeDescription>();
                         for (AnnotationDescription annotationDescription : typeVariable.getDeclaredAnnotations()) {
-                            if (!annotationDescription.getElementTypes().contains(INSTANCE.typeUse) || !annotationTypes.add(annotationDescription.getAnnotationType())) {
+                            if (!annotationDescription.getElementTypes().contains(INSTANCE.typeParameter) || !annotationTypes.add(annotationDescription.getAnnotationType())) {
                                 return false;
                             }
                         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -289,7 +289,7 @@ public <T> DynamicType.Builder<T> subclass(Type superType, ConstructorStrategy c
      * @return A type builder for creating a new class extending the provided class or interface.
      */
     public <T> DynamicType.Builder<T> subclass(TypeDefinition superType) {
-        return subclass(superType, ConstructorStrategy.Default.IMITATE_SUPER_TYPE);
+        return subclass(superType, ConstructorStrategy.Default.IMITATE_SUPER_CLASS);
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTarget.java
Patch:
@@ -57,7 +57,7 @@ protected static Implementation.Target of(TypeDescription instrumentedType, Meth
     public Implementation.SpecialMethodInvocation invokeSuper(MethodDescription.SignatureToken token) {
         MethodRebaseResolver.Resolution resolution = rebaseableMethods.get(token);
         return resolution == null
-                ? invokeSuper(methodGraph.getSuperGraph().locate(token))
+                ? invokeSuper(methodGraph.getSuperClassGraph().locate(token))
                 : invokeSuper(resolution);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -151,7 +151,7 @@ public DynamicType.Unloaded<T> make() {
         MethodRegistry.Compiled compiledMethodRegistry = constructorStrategy
                 .inject(methodRegistry)
                 .prepare(applyConstructorStrategy(instrumentedType), methodGraphCompiler, typeValidation, new InstrumentableMatcher(ignoredMethods))
-                .compile(SubclassImplementationTarget.Factory.SUPER_TYPE);
+                .compile(SubclassImplementationTarget.Factory.SUPER_CLASS);
         return TypeWriter.Default.<T>forCreation(compiledMethodRegistry,
                 fieldRegistry.compile(compiledMethodRegistry.getInstrumentedType()),
                 typeAttributeAppender,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveTypeAwareAssigner.java
Patch:
@@ -41,11 +41,11 @@ public PrimitiveTypeAwareAssigner(Assigner referenceTypeAwareAssigner) {
     public StackManipulation assign(TypeDescription.Generic source, TypeDescription.Generic target, Typing typing) {
         if (source.isPrimitive() && target.isPrimitive()) {
             return PrimitiveWideningDelegate.forPrimitive(source).widenTo(target);
-        } else if (source.isPrimitive() /* && !subType.isPrimitive() */) {
+        } else if (source.isPrimitive() /* && !target.isPrimitive() */) {
             return PrimitiveBoxingDelegate.forPrimitive(source).assignBoxedTo(target, referenceTypeAwareAssigner, typing);
-        } else if (/* !superType.isPrimitive() && */ target.isPrimitive()) {
+        } else if (/* !source.isPrimitive() && */ target.isPrimitive()) {
             return PrimitiveUnboxingDelegate.forReferenceType(source).assignUnboxedTo(target, referenceTypeAwareAssigner, typing);
-        } else /* !superType.isPrimitive() && !subType.isPrimitive()) */ {
+        } else /* !source.isPrimitive() && !target.isPrimitive()) */ {
             return referenceTypeAwareAssigner.assign(source, target, typing);
         }
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -271,7 +271,7 @@ public void testActualModifiers() throws Exception {
     }
 
     @Test
-    public void testSuperType() throws Exception {
+    public void testSuperClass() throws Exception {
         assertThat(describe(Object.class).getSuperClass(), nullValue(TypeDescription.Generic.class));
         assertThat(describe(SampleInterface.class).getSuperClass(), nullValue(TypeDescription.Generic.class));
         assertThat(describe(SampleAnnotation.class).getSuperClass(), nullValue(TypeDescription.Generic.class));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/GenericSignatureResolutionTest.java
Patch:
@@ -76,7 +76,7 @@ public void testGenericMethodWithoutGenericExceptionTypes() throws Exception {
     }
 
     @Test
-    public void testNoSuperType() throws Exception {
+    public void testNoSuperClass() throws Exception {
         assertThat(new ByteBuddy().redefine(Object.class).make(), notNullValue(DynamicType.class));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionArrayProjectionTest.java
Patch:
@@ -38,7 +38,7 @@ protected TypeDescription.Generic describeExceptionType(Method method, int index
     }
 
     @Override
-    protected TypeDescription.Generic describeSuperType(Class<?> type) {
+    protected TypeDescription.Generic describeSuperClass(Class<?> type) {
         return TypeDefinition.Sort.describe(type.getGenericSuperclass(), TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveSuperClass(type));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionForLoadedTypeTest.java
Patch:
@@ -36,7 +36,7 @@ protected TypeDescription.Generic describeExceptionType(Method method, int index
     }
 
     @Override
-    protected TypeDescription.Generic describeSuperType(Class<?> type) {
+    protected TypeDescription.Generic describeSuperClass(Class<?> type) {
         return new TypeDescription.ForLoadedType(type).getSuperClass();
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionForPackageDescriptionTest.java
Patch:
@@ -74,7 +74,7 @@ public void testPackage() throws Exception {
     }
 
     @Test
-    public void testSuperType() throws Exception {
+    public void testSuperClass() throws Exception {
         assertThat(typeDescription.getSuperClass(), is(TypeDescription.Generic.OBJECT));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericAnnotationReaderTest.java
Patch:
@@ -95,7 +95,7 @@ public Method create() {
                     }
                 }).apply();
         final Iterator<Class<?>> types2 = Arrays.<Class<?>>asList(Object.class, String.class, Integer.class, Number.class).iterator();
-        ObjectPropertyAssertion.of(TypeDescription.Generic.AnnotationReader.Dispatcher.ForModernVm.AnnotatedSuperType.class)
+        ObjectPropertyAssertion.of(TypeDescription.Generic.AnnotationReader.Dispatcher.ForModernVm.AnnotatedSuperClass.class)
                 .create(new ObjectPropertyAssertion.Creator<Class<?>>() {
                     @Override
                     public Class<?> create() {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericBuilderTest.java
Patch:
@@ -41,7 +41,7 @@ protected TypeDescription.Generic describeExceptionType(Method method, int index
     }
 
     @Override
-    protected TypeDescription.Generic describeSuperType(Class<?> type) {
+    protected TypeDescription.Generic describeSuperClass(Class<?> type) {
         return describe(type.getGenericSuperclass(), TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveSuperClass(type))
                 .accept(TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(new TypeDescription.ForLoadedType(type)));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericOfTypeVariableSymbolic.java
Patch:
@@ -137,7 +137,7 @@ public void getOwnerTypeThrowsException() throws Exception {
     }
 
     @Test(expected = IllegalStateException.class)
-    public void testSuperTypeThrowsException() throws Exception {
+    public void testSuperClassThrowsException() throws Exception {
         typeVariable.getSuperClass();
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeDefaultTest.java
Patch:
@@ -391,7 +391,7 @@ public void testRepresents() {
     }
 
     @Test
-    public void testSuperType() {
+    public void testSuperClass() {
         assertThat(makePlainInstrumentedType().getSuperClass(), is(TypeDescription.Generic.OBJECT));
         assertThat(makePlainInstrumentedType().getSuperClass(), not((TypeDescription.Generic) new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Integer.class)));
         assertThat(makePlainInstrumentedType().getSuperClass(), not((TypeDescription.Generic) new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Serializable.class)));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphEmptyTest.java
Patch:
@@ -23,7 +23,7 @@ public void testListNode() throws Exception {
 
     @Test
     public void testSuperGraph() throws Exception {
-        assertThat(MethodGraph.Empty.INSTANCE.getSuperGraph(), is((MethodGraph) MethodGraph.Empty.INSTANCE));
+        assertThat(MethodGraph.Empty.INSTANCE.getSuperClassGraph(), is((MethodGraph) MethodGraph.Empty.INSTANCE));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphLinkedDelegationTest.java
Patch:
@@ -58,7 +58,7 @@ public void testNodeList() throws Exception {
 
     @Test
     public void testSuperGraph() throws Exception {
-        assertThat(linkedMethodGraph.getSuperGraph(), is(superGraph));
+        assertThat(linkedMethodGraph.getSuperClassGraph(), is(superGraph));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodRegistryDefaultTest.java
Patch:
@@ -329,8 +329,8 @@ public void testVisibilityBridgeIfNotMatchedAndVisible() throws Exception {
         when(instrumentedMethod.isPublic()).thenReturn(true);
         when(declaringType.isPackagePrivate()).thenReturn(true);
         TypeDescription.Generic superClass = mock(TypeDescription.Generic.class);
-        TypeDescription rawSuperType = mock(TypeDescription.class);
-        when(superClass.asErasure()).thenReturn(rawSuperType);
+        TypeDescription rawSuperClass = mock(TypeDescription.class);
+        when(superClass.asErasure()).thenReturn(rawSuperClass);
         when(typeDescription.getSuperClass()).thenReturn(superClass);
         MethodDescription.Token methodToken = mock(MethodDescription.Token.class);
         when(instrumentedMethod.asToken(ElementMatchers.is(typeDescription))).thenReturn(methodToken);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultFrameComputingClassWriterTest.java
Patch:
@@ -81,7 +81,7 @@ public void testRightIsInterface() throws Exception {
     }
 
     @Test
-    public void testSuperTypeIteration() throws Exception {
+    public void testSuperClassIteration() throws Exception {
         when(superClass.isAssignableFrom(rightType)).thenReturn(true);
         assertThat(frameComputingClassWriter.getCommonSuperClass(FOO, BAR), is(FOOBAR));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderTest.java
Patch:
@@ -508,7 +508,7 @@ public void testNoVisibilityBridgeForAbstractMethod() throws Exception {
     @Test
     @JavaVersionRule.Enforce(8)
     @SuppressWarnings("unchecked")
-    public void testAnnotationTypeOnSuperType() throws Exception {
+    public void testAnnotationTypeOnSuperClass() throws Exception {
         Class<? extends Annotation> typeAnnotationType = (Class<? extends Annotation>) Class.forName(TYPE_VARIABLE_NAME);
         MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotationType).getDeclaredMethods().filter(named(VALUE)).getOnly();
         Class<?> type = new ByteBuddy()

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/AbstractImplementationTargetTest.java
Patch:
@@ -48,7 +48,7 @@ public abstract class AbstractImplementationTargetTest {
     public void setUp() throws Exception {
         when(instrumentedType.asErasure()).thenReturn(instrumentedType);
         when(instrumentedType.getInternalName()).thenReturn(BAZ);
-        when(methodGraph.getSuperGraph()).thenReturn(superGraph);
+        when(methodGraph.getSuperClassGraph()).thenReturn(superGraph);
         when(superGraph.locate(Mockito.any(MethodDescription.SignatureToken.class))).thenReturn(MethodGraph.Node.Unresolved.INSTANCE);
         when(superGraph.locate(invokableToken)).thenReturn(new MethodGraph.Node.Simple(invokableMethod));
         when(methodGraph.getInterfaceGraph(defaultMethodDeclaringType)).thenReturn(defaultGraph);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/TypeAttributeAppenderForInstrumentedTypeTest.java
Patch:
@@ -56,7 +56,7 @@ public void testAnnotationClassFileRetention() throws Exception {
     }
 
     @Test
-    public void testSuperTypeTypeAnnotationNoRetention() throws Exception {
+    public void testSuperClassTypeAnnotationNoRetention() throws Exception {
         when(instrumentedType.getTypeVariables()).thenReturn(new TypeList.Generic.Empty());
         when(instrumentedType.getInterfaces()).thenReturn(new TypeList.Generic.Empty());
         when(simpleAnnotatedType.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(new Qux.Instance()));
@@ -72,7 +72,7 @@ public void testSuperTypeTypeAnnotationNoRetention() throws Exception {
     }
 
     @Test
-    public void testSuperTypeTypeAnnotationByteCodeRetention() throws Exception {
+    public void testSuperClassTypeAnnotationByteCodeRetention() throws Exception {
         when(instrumentedType.getTypeVariables()).thenReturn(new TypeList.Generic.Empty());
         when(instrumentedType.getInterfaces()).thenReturn(new TypeList.Generic.Empty());
         when(simpleAnnotatedType.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(new Baz.Instance()));
@@ -88,7 +88,7 @@ public void testSuperTypeTypeAnnotationByteCodeRetention() throws Exception {
     }
 
     @Test
-    public void testSuperTypeTypeAnnotationClassFileRetention() throws Exception {
+    public void testSuperClassTypeAnnotationClassFileRetention() throws Exception {
         when(instrumentedType.getTypeVariables()).thenReturn(new TypeList.Generic.Empty());
         when(instrumentedType.getInterfaces()).thenReturn(new TypeList.Generic.Empty());
         when(simpleAnnotatedType.getDeclaredAnnotations())

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultTypeDescriptionTest.java
Patch:
@@ -44,7 +44,7 @@ protected TypeDescription.Generic describeExceptionType(Method method, int index
     }
 
     @Override
-    protected TypeDescription.Generic describeSuperType(Class<?> type) {
+    protected TypeDescription.Generic describeSuperClass(Class<?> type) {
         return describe(type).getSuperClass();
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyFacadeTypeDescriptionTest.java
Patch:
@@ -44,7 +44,7 @@ protected TypeDescription.Generic describeExceptionType(Method method, int index
     }
 
     @Override
-    protected TypeDescription.Generic describeSuperType(Class<?> type) {
+    protected TypeDescription.Generic describeSuperClass(Class<?> type) {
         return describe(type).getSuperClass();
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -1448,7 +1448,7 @@ public RetentionPolicy getRetention() {
         @Override
         public Set<ElementType> getElementTypes() {
             AnnotationDescription.Loadable<Target> target = getAnnotationType().getDeclaredAnnotations().ofType(Target.class);
-            return EnumSet.copyOf(Arrays.asList(target == null
+            return new HashSet<ElementType>(Arrays.asList(target == null
                     ? DEFAULT_TARGET
                     : target.loadSilent().value()));
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/AnnotationAppenderForTypeAnnotationsTest.java
Patch:
@@ -10,6 +10,8 @@
 
 public class AnnotationAppenderForTypeAnnotationsTest {
 
+    // TODO
+
     @Test
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(AnnotationAppender.ForTypeAnnotations.class).refine(new ObjectPropertyAssertion.Refinement<TypeReference>() {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterList.java
Patch:
@@ -362,7 +362,7 @@ public OfLegacyVmConstructor(Constructor<?> constructor) {
 
             @Override
             public ParameterDescription.InDefinedShape get(int index) {
-                return new ParameterDescription.ForLoadedParameter.OfLegacyVmConstructor(constructor, index, parameterType[index], parameterAnnotation[index]);
+                return new ParameterDescription.ForLoadedParameter.OfLegacyVmConstructor(constructor, index, parameterType, parameterAnnotation);
             }
 
             @Override
@@ -405,7 +405,7 @@ protected OfLegacyVmMethod(Method method) {
 
             @Override
             public ParameterDescription.InDefinedShape get(int index) {
-                return new ParameterDescription.ForLoadedParameter.OfLegacyVmMethod(method, index, parameterType[index], parameterAnnotation[index]);
+                return new ParameterDescription.ForLoadedParameter.OfLegacyVmMethod(method, index, parameterType, parameterAnnotation);
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -6343,7 +6343,7 @@ private TokenList(TypePool typePool,
 
                     @Override
                     public Generic get(int index) {
-                        return index < genericTypeTokens.size()
+                        return rawTypeDescriptors.size() == genericTypeTokens.size()
                                 ? TokenizedGenericType.of(typePool, genericTypeTokens.get(index), rawTypeDescriptors.get(index), annotationTokens.get(index), typeVariableSource)
                                 : TokenizedGenericType.toErasure(typePool, rawTypeDescriptors.get(index)).asGenericType();
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -74,7 +74,9 @@ public RebaseDynamicTypeBuilder(InstrumentedType.WithFlexibleName instrumentedTy
         this(instrumentedType,
                 new FieldRegistry.Default(),
                 new MethodRegistry.Default(),
-                new TypeAttributeAppender.ForInstrumentedType.Differentiating(originalType),
+                annotationRetention.isEnabled()
+                        ? new TypeAttributeAppender.ForInstrumentedType.Differentiating(originalType)
+                        : TypeAttributeAppender.ForInstrumentedType.INSTANCE,
                 AsmVisitorWrapper.NoOp.INSTANCE,
                 classFileVersion,
                 auxiliaryTypeNamingStrategy,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -61,7 +61,9 @@ public RedefinitionDynamicTypeBuilder(InstrumentedType.WithFlexibleName instrume
         this(instrumentedType,
                 new FieldRegistry.Default(),
                 new MethodRegistry.Default(),
-                new TypeAttributeAppender.ForInstrumentedType.Differentiating(originalType),
+                annotationRetention.isEnabled()
+                        ? new TypeAttributeAppender.ForInstrumentedType.Differentiating(originalType)
+                        : TypeAttributeAppender.ForInstrumentedType.INSTANCE,
                 AsmVisitorWrapper.NoOp.INSTANCE,
                 classFileVersion,
                 auxiliaryTypeNamingStrategy,

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterFieldPoolRecordTest.java
Patch:
@@ -72,6 +72,7 @@ public void setUp() throws Exception {
         when(fieldDescription.getDescriptor()).thenReturn(BAR);
         when(fieldDescription.getGenericSignature()).thenReturn(QUX);
         when(fieldDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList.Explicit(annotationDescription));
+        when(fieldDescription.getType()).thenReturn(TypeDescription.Generic.OBJECT);
         when(classVisitor.visitField(MODIFIER, FOO, BAR, QUX, defaultValue)).thenReturn(fieldVisitor);
         when(classVisitor.visitField(MODIFIER, FOO, BAR, QUX, FieldDescription.NO_DEFAULT_VALUE)).thenReturn(fieldVisitor);
         when(annotationValueFilterFactory.on(fieldDescription)).thenReturn(valueFilter);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilderTest.java
Patch:
@@ -181,6 +181,7 @@ public TypeDescription create() {
                 TypeDescription rawTypeDescription = mock(TypeDescription.class);
                 when(rawTypeDescription.asErasure()).thenReturn(rawTypeDescription);
                 when(rawTypeDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
+                when(rawTypeDescription.getTypeVariables()).thenReturn(new TypeList.Generic.Empty());
                 TypeDescription.Generic typeDescription = mock(TypeDescription.Generic.class);
                 when(typeDescription.asGenericType()).thenReturn(typeDescription);
                 when(typeDescription.asErasure()).thenReturn(rawTypeDescription);

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -21,6 +21,7 @@
 import net.bytebuddy.dynamic.scaffold.subclass.SubclassDynamicTypeBuilder;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.MethodCall;
+import net.bytebuddy.implementation.SuperMethodCall;
 import net.bytebuddy.implementation.attribute.AnnotationRetention;
 import net.bytebuddy.implementation.attribute.AnnotationValueFilter;
 import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
@@ -475,9 +476,7 @@ public DynamicType.Builder<? extends Enum<?>> makeEnumeration(Collection<? exten
                 ignoredMethods,
                 ConstructorStrategy.Default.NO_CONSTRUCTORS)
                 .defineConstructor(Visibility.PRIVATE).withParameters(String.class, int.class)
-                .intercept(MethodCall.invoke(enumType.getDeclaredMethods()
-                        .filter(isConstructor().and(takesArguments(String.class, int.class))).getOnly())
-                        .withArgument(0, 1))
+                .intercept(SuperMethodCall.INSTANCE)
                 .defineMethod(EnumerationImplementation.ENUM_VALUE_OF_METHOD_NAME,
                         TargetType.class,
                         Visibility.PUBLIC, Ownership.STATIC).withParameters(String.class)

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1510,7 +1510,7 @@ abstract class AbstractBase<V> extends ImplementationDefinition.AbstractBase<V>
 
                     @Override
                     public Annotatable<V> typeVariable(String symbol) {
-                        return typeVariable(symbol, Collections.<TypeDefinition>emptyList());
+                        return typeVariable(symbol, Collections.singletonList(Object.class));
                     }
 
                     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -2961,7 +2961,7 @@ public void visit(int classFileVersionNumber,
                                     TypeDescription.OBJECT :
                                     instrumentedType.getSuperClass().asErasure()).getInternalName(),
                             instrumentedType.getInterfaces().asErasures().toInternalNames());
-                    typeAttributeAppender.apply(this, instrumentedType, annotationValueFilterFactory.on(instrumentedType));
+                    typeAttributeAppender.apply(cv, instrumentedType, annotationValueFilterFactory.on(instrumentedType));
                     if (!ClassFileVersion.ofMinorMajor(classFileVersionNumber).isAtLeast(ClassFileVersion.JAVA_V8) && instrumentedType.isInterface()) {
                         implementationContext.prohibitTypeInitializer();
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -74,7 +74,7 @@ public RebaseDynamicTypeBuilder(InstrumentedType.WithFlexibleName instrumentedTy
         this(instrumentedType,
                 new FieldRegistry.Default(),
                 new MethodRegistry.Default(),
-                new TypeAttributeAppender.ForInstrumentedType.Excluding(originalType),
+                new TypeAttributeAppender.ForInstrumentedType.Differentiating(originalType),
                 AsmVisitorWrapper.NoOp.INSTANCE,
                 classFileVersion,
                 auxiliaryTypeNamingStrategy,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -61,7 +61,7 @@ public RedefinitionDynamicTypeBuilder(InstrumentedType.WithFlexibleName instrume
         this(instrumentedType,
                 new FieldRegistry.Default(),
                 new MethodRegistry.Default(),
-                new TypeAttributeAppender.ForInstrumentedType.Excluding(originalType),
+                new TypeAttributeAppender.ForInstrumentedType.Differentiating(originalType),
                 AsmVisitorWrapper.NoOp.INSTANCE,
                 classFileVersion,
                 auxiliaryTypeNamingStrategy,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TrivialType.java
Patch:
@@ -47,7 +47,7 @@ public DynamicType make(String auxiliaryTypeName,
                 .with(MethodGraph.Empty.INSTANCE) // avoid parsing the graph
                 .subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS)
                 .annotateType(eager
-                        ? Collections.singletonList(AnnotationDescription.Builder.forType(SignatureRelevant.class).make())
+                        ? Collections.singletonList(AnnotationDescription.Builder.ofType(SignatureRelevant.class).build())
                         : Collections.<AnnotationDescription>emptyList())
                 .name(auxiliaryTypeName)
                 .modifiers(DEFAULT_TYPE_MODIFIER)

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AnnotationDescriptionLatentTest.java
Patch:
@@ -7,7 +7,7 @@ public class AnnotationDescriptionLatentTest extends AbstractAnnotationDescripti
 
     @SuppressWarnings("unchecked")
     private static AnnotationDescription build(Annotation annotation) throws Exception {
-        AnnotationDescription.Builder builder = AnnotationDescription.Builder.forType(annotation.annotationType());
+        AnnotationDescription.Builder builder = AnnotationDescription.Builder.ofType(annotation.annotationType());
         for (Method method : annotation.annotationType().getDeclaredMethods()) {
             Object value = method.invoke(annotation);
             if (value instanceof Annotation) {
@@ -62,7 +62,7 @@ private static AnnotationDescription build(Annotation annotation) throws Excepti
                 throw new IllegalArgumentException("Cannot handle: " + method);
             }
         }
-        return builder.make();
+        return builder.build();
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionArrayProjectionTest.java
Patch:
@@ -39,7 +39,7 @@ protected TypeDescription.Generic describeExceptionType(Method method, int index
 
     @Override
     protected TypeDescription.Generic describeSuperType(Class<?> type) {
-        return TypeDefinition.Sort.describe(type.getGenericSuperclass(), TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveSuperType(type));
+        return TypeDefinition.Sort.describe(type.getGenericSuperclass(), TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveSuperClass(type));
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericAnnotationReaderTest.java
Patch:
@@ -17,7 +17,7 @@ public class TypeDescriptionGenericAnnotationReaderTest {
     public void testLegacyVmReturnsNoOpReaders() throws Exception {
         assertThat(TypeDescription.Generic.AnnotationReader.Dispatcher.ForLegacyVm.INSTANCE.resolve(null),
                 is((TypeDescription.Generic.AnnotationReader) TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE));
-        assertThat(TypeDescription.Generic.AnnotationReader.Dispatcher.ForLegacyVm.INSTANCE.resolveSuperType(null),
+        assertThat(TypeDescription.Generic.AnnotationReader.Dispatcher.ForLegacyVm.INSTANCE.resolveSuperClass(null),
                 is((TypeDescription.Generic.AnnotationReader) TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE));
         assertThat(TypeDescription.Generic.AnnotationReader.Dispatcher.ForLegacyVm.INSTANCE.resolveInterface(null, 0),
                 is((TypeDescription.Generic.AnnotationReader) TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericBuilderTest.java
Patch:
@@ -42,7 +42,7 @@ protected TypeDescription.Generic describeExceptionType(Method method, int index
 
     @Override
     protected TypeDescription.Generic describeSuperType(Class<?> type) {
-        return describe(type.getGenericSuperclass(), TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveSuperType(type))
+        return describe(type.getGenericSuperclass(), TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveSuperClass(type))
                 .accept(TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(new TypeDescription.ForLoadedType(type)));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultTest.java
Patch:
@@ -273,7 +273,7 @@ public void testAnnotationPreJava5TypeAssertion() throws Exception {
     public void testAnnotationOnTypePreJava5TypeAssertion() throws Exception {
         new ByteBuddy(ClassFileVersion.JAVA_V4)
                 .subclass(Object.class)
-                .annotateType(AnnotationDescription.Builder.forType(Foo.class).make())
+                .annotateType(AnnotationDescription.Builder.ofType(Foo.class).build())
                 .make();
     }
 
@@ -282,7 +282,7 @@ public void testAnnotationOnFieldPreJava5TypeAssertion() throws Exception {
         new ByteBuddy(ClassFileVersion.JAVA_V4)
                 .subclass(Object.class)
                 .defineField(FOO, Void.class)
-                .annotateField(AnnotationDescription.Builder.forType(Foo.class).make())
+                .annotateField(AnnotationDescription.Builder.ofType(Foo.class).build())
                 .make();
     }
 
@@ -292,7 +292,7 @@ public void testAnnotationOnMethodPreJava5TypeAssertion() throws Exception {
                 .subclass(Object.class)
                 .defineMethod(FOO, void.class)
                 .intercept(StubMethod.INSTANCE)
-                .annotateMethod(AnnotationDescription.Builder.forType(Foo.class).make())
+                .annotateMethod(AnnotationDescription.Builder.ofType(Foo.class).build())
                 .make();
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilderTest.java
Patch:
@@ -124,7 +124,7 @@ public void testMethodRebase() throws Exception {
     public void testPackageRebasement() throws Exception {
         Class<?> packageType = new ByteBuddy()
                 .rebase(Sample.class.getPackage(), ClassFileLocator.ForClassLoader.of(getClass().getClassLoader()))
-                .annotateType(AnnotationDescription.Builder.forType(Baz.class).make())
+                .annotateType(AnnotationDescription.Builder.ofType(Baz.class).build())
                 .make()
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.CHILD_FIRST)
                 .getLoaded();

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -500,7 +500,7 @@ public static Compiler forJVMHierarchy() {
             public MethodGraph.Linked compile(TypeDefinition typeDefinition, TypeDescription viewPoint) {
                 Map<TypeDefinition, Key.Store<T>> snapshots = new HashMap<TypeDefinition, Key.Store<T>>();
                 Key.Store<?> rootStore = doAnalyze(typeDefinition, snapshots, isVirtual().and(isVisibleTo(viewPoint)));
-                TypeDescription.Generic superType = typeDefinition.getSuperType();
+                TypeDescription.Generic superType = typeDefinition.getSuperClass();
                 List<TypeDescription.Generic> interfaceTypes = typeDefinition.getInterfaces();
                 Map<TypeDescription, MethodGraph> interfaceGraphs = new HashMap<TypeDescription, MethodGraph>();
                 for (TypeDescription.Generic interfaceType : interfaceTypes) {
@@ -559,7 +559,7 @@ protected Key.Store<T> analyzeNullable(TypeDefinition typeDefinition,
             protected Key.Store<T> doAnalyze(TypeDefinition typeDefinition,
                                              Map<TypeDefinition, Key.Store<T>> snapshots,
                                              ElementMatcher<? super MethodDescription> relevanceMatcher) {
-                Key.Store<T> store = analyzeNullable(typeDefinition.getSuperType(), snapshots, relevanceMatcher);
+                Key.Store<T> store = analyzeNullable(typeDefinition.getSuperClass(), snapshots, relevanceMatcher);
                 Key.Store<T> interfaceStore = new Key.Store<T>();
                 for (TypeDescription.Generic interfaceType : typeDefinition.getInterfaces()) {
                     interfaceStore = interfaceStore.combineWith(analyze(interfaceType, snapshots, relevanceMatcher));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTarget.java
Patch:
@@ -69,7 +69,7 @@ public Implementation.SpecialMethodInvocation invokeSuper(MethodDescription.Sign
      */
     private Implementation.SpecialMethodInvocation invokeSuper(MethodGraph.Node node) {
         return node.getSort().isResolved()
-                ? Implementation.SpecialMethodInvocation.Simple.of(node.getRepresentative(), instrumentedType.getSuperType().asErasure())
+                ? Implementation.SpecialMethodInvocation.Simple.of(node.getRepresentative(), instrumentedType.getSuperClass().asErasure())
                 : Implementation.SpecialMethodInvocation.Illegal.INSTANCE;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -2089,7 +2089,7 @@ enum ForSuperMethodInvocation implements MethodInvoker {
 
             @Override
             public StackManipulation invoke(MethodDescription methodDescription, Target implementationTarget) {
-                if (implementationTarget.getInstrumentedType().getSuperType() == null) {
+                if (implementationTarget.getInstrumentedType().getSuperClass() == null) {
                     throw new IllegalStateException("Cannot invoke super method for " + implementationTarget.getInstrumentedType());
                 } else if (!methodDescription.isInvokableOn(implementationTarget.getOriginType().asErasure())) {
                     throw new IllegalStateException("Cannot invoke " + methodDescription + " as super method of " + implementationTarget.getInstrumentedType());

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/TypeAttributeAppender.java
Patch:
@@ -63,7 +63,7 @@ public void apply(ClassVisitor classVisitor, TypeDescription instrumentedType, A
                     annotationValueFilter,
                     AnnotationAppender.ForTypeAnnotations.VARIABLE_ON_TYPE,
                     instrumentedType.getTypeVariables());
-            TypeDescription.Generic superType = instrumentedType.getSuperType();
+            TypeDescription.Generic superType = instrumentedType.getSuperClass();
             if (superType != null) {
                 annotationAppender = superType.accept(AnnotationAppender.ForTypeAnnotations.ofSuperClass(annotationAppender, annotationValueFilter));
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -2760,7 +2760,7 @@ protected LazyTypeDescription(TypePool typePool,
             }
 
             @Override
-            public Generic getSuperType() {
+            public Generic getSuperClass() {
                 return superTypeDescriptor == null || isInterface()
                         ? Generic.UNDEFINED
                         : signatureResolution.resolveSuperType(superTypeDescriptor, typePool, superTypeAnnotationTokens.get(SUPER_TYPE_INDEX), this);
@@ -8023,8 +8023,8 @@ private TypeDescription resolve() {
                 }
 
                 @Override
-                public Generic getSuperType() {
-                    return resolve().getSuperType();
+                public Generic getSuperClass() {
+                    return resolve().getSuperClass();
                 }
 
                 @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDefinitionSuperTypeIteratorTest.java
Patch:
@@ -28,7 +28,7 @@ public class TypeDefinitionSuperTypeIteratorTest {
 
     @Before
     public void setUp() throws Exception {
-        when(typeDescription.getSuperType()).thenReturn(superType);
+        when(typeDescription.getSuperClass()).thenReturn(superType);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionForLoadedTypeTest.java
Patch:
@@ -37,7 +37,7 @@ protected TypeDescription.Generic describeExceptionType(Method method, int index
 
     @Override
     protected TypeDescription.Generic describeSuperType(Class<?> type) {
-        return new TypeDescription.ForLoadedType(type).getSuperType();
+        return new TypeDescription.ForLoadedType(type).getSuperClass();
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionForPackageDescriptionTest.java
Patch:
@@ -75,6 +75,6 @@ public void testPackage() throws Exception {
 
     @Test
     public void testSuperType() throws Exception {
-        assertThat(typeDescription.getSuperType(), is(TypeDescription.Generic.OBJECT));
+        assertThat(typeDescription.getSuperClass(), is(TypeDescription.Generic.OBJECT));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericOfTypeVariableSymbolic.java
Patch:
@@ -138,7 +138,7 @@ public void getOwnerTypeThrowsException() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testSuperTypeThrowsException() throws Exception {
-        typeVariable.getSuperType();
+        typeVariable.getSuperClass();
     }
 
     @Test(expected = IllegalStateException.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionLatentTest.java
Patch:
@@ -42,7 +42,7 @@ public void testModifiers() throws Exception {
 
     @Test
     public void testSuperType() throws Exception {
-        assertThat(new TypeDescription.Latent(FOO, MODIFIERS, superType, Collections.singletonList(interfaceType)).getSuperType(), is(superType));
+        assertThat(new TypeDescription.Latent(FOO, MODIFIERS, superType, Collections.singletonList(interfaceType)).getSuperClass(), is(superType));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeDefaultTest.java
Patch:
@@ -394,9 +394,9 @@ public void testRepresents() {
 
     @Test
     public void testSuperType() {
-        assertThat(makePlainInstrumentedType().getSuperType(), is(TypeDescription.Generic.OBJECT));
-        assertThat(makePlainInstrumentedType().getSuperType(), not((TypeDescription.Generic) new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Integer.class)));
-        assertThat(makePlainInstrumentedType().getSuperType(), not((TypeDescription.Generic) new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Serializable.class)));
+        assertThat(makePlainInstrumentedType().getSuperClass(), is(TypeDescription.Generic.OBJECT));
+        assertThat(makePlainInstrumentedType().getSuperClass(), not((TypeDescription.Generic) new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Integer.class)));
+        assertThat(makePlainInstrumentedType().getSuperClass(), not((TypeDescription.Generic) new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Serializable.class)));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodRegistryDefaultTest.java
Patch:
@@ -331,7 +331,7 @@ public void testVisibilityBridgeIfNotMatchedAndVisible() throws Exception {
         TypeDescription.Generic superType = mock(TypeDescription.Generic.class);
         TypeDescription rawSuperType = mock(TypeDescription.class);
         when(superType.asErasure()).thenReturn(rawSuperType);
-        when(typeDescription.getSuperType()).thenReturn(superType);
+        when(typeDescription.getSuperClass()).thenReturn(superType);
         MethodDescription.Token methodToken = mock(MethodDescription.Token.class);
         when(instrumentedMethod.asToken(ElementMatchers.is(typeDescription))).thenReturn(methodToken);
         when(methodToken.accept(any(TypeDescription.Generic.Visitor.class))).thenReturn(methodToken);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultFrameComputingClassWriterTest.java
Patch:
@@ -43,7 +43,7 @@ public void setUp() throws Exception {
         when(typePool.describe(BAR.replace('/', '.'))).thenReturn(new TypePool.Resolution.Simple(rightType));
         when(leftType.getInternalName()).thenReturn(QUX);
         when(rightType.getInternalName()).thenReturn(BAZ);
-        when(leftType.getSuperType()).thenReturn(genericSuperType);
+        when(leftType.getSuperClass()).thenReturn(genericSuperType);
         when(genericSuperType.asErasure()).thenReturn(superType);
         when(superType.getInternalName()).thenReturn(FOOBAR);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTargetFactoryTest.java
Patch:
@@ -39,7 +39,7 @@ public class RebaseImplementationTargetFactoryTest {
     @Before
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
-        when(instrumentedType.getSuperType()).thenReturn(superType);
+        when(instrumentedType.getSuperClass()).thenReturn(superType);
         when(superType.getDeclaredMethods()).thenReturn(new MethodList.Empty<MethodDescription.InGenericShape>());
         factory = new RebaseImplementationTarget.Factory(methodRebaseResolver);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTargetTest.java
Patch:
@@ -54,7 +54,7 @@ public class RebaseImplementationTargetTest extends AbstractImplementationTarget
     @Before
     public void setUp() throws Exception {
         when(methodGraph.locate(Mockito.any(MethodDescription.SignatureToken.class))).thenReturn(MethodGraph.Node.Unresolved.INSTANCE);
-        when(instrumentedType.getSuperType()).thenReturn(genericSuperType);
+        when(instrumentedType.getSuperClass()).thenReturn(genericSuperType);
         when(genericSuperType.asErasure()).thenReturn(superType);
         when(superType.getInternalName()).thenReturn(BAR);
         when(rebasedMethod.getInternalName()).thenReturn(QUX);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTargetTest.java
Patch:
@@ -17,8 +17,6 @@
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
-import java.util.Collections;
-
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.*;
@@ -47,7 +45,7 @@ public class SubclassImplementationTargetTest extends AbstractImplementationTarg
     public void setUp() throws Exception {
         when(superGraph.locate(Mockito.any(MethodDescription.SignatureToken.class))).thenReturn(MethodGraph.Node.Unresolved.INSTANCE);
         when(superGraph.locate(invokableToken)).thenReturn(new MethodGraph.Node.Simple(invokableMethod));
-        when(instrumentedType.getSuperType()).thenReturn(superType);
+        when(instrumentedType.getSuperClass()).thenReturn(superType);
         when(superType.asErasure()).thenReturn(rawSuperType);
         when(superType.asGenericType()).thenReturn(superType);
         when(rawSuperType.asGenericType()).thenReturn(superType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/SuperMethodCallOtherTest.java
Patch:
@@ -92,7 +92,7 @@ public void testPreparation() throws Exception {
     @Test(expected = IllegalStateException.class)
     @SuppressWarnings("unchecked")
     public void testConstructor() throws Exception {
-        when(typeDescription.getSuperType()).thenReturn(genericSuperType);
+        when(typeDescription.getSuperClass()).thenReturn(genericSuperType);
         when(methodDescription.isConstructor()).thenReturn(true);
         when(superType.getDeclaredMethods()).thenReturn(superTypeMethods);
         when(superTypeMethods.filter(any(ElementMatcher.class))).thenReturn(superTypeMethods);
@@ -103,7 +103,7 @@ public void testConstructor() throws Exception {
     @Test(expected = IllegalStateException.class)
     @SuppressWarnings("unchecked")
     public void testStaticMethod() throws Exception {
-        when(typeDescription.getSuperType()).thenReturn(genericSuperType);
+        when(typeDescription.getSuperClass()).thenReturn(genericSuperType);
         when(methodDescription.isStatic()).thenReturn(true);
         when(methodDescription.getParameters()).thenReturn((ParameterList) new ParameterList.Empty<ParameterDescription>());
         when(methodDescription.getReturnType()).thenReturn(genericReturnType);
@@ -117,7 +117,7 @@ public void testStaticMethod() throws Exception {
     @Test(expected = IllegalStateException.class)
     @SuppressWarnings("unchecked")
     public void testNoSuper() throws Exception {
-        when(typeDescription.getSuperType()).thenReturn(genericSuperType);
+        when(typeDescription.getSuperClass()).thenReturn(genericSuperType);
         when(methodDescription.getParameters()).thenReturn((ParameterList) new ParameterList.Empty<ParameterDescription>());
         when(methodDescription.getReturnType()).thenReturn(genericReturnType);
         when(methodDescription.getDeclaringType()).thenReturn(declaringType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultTypeDescriptionTest.java
Patch:
@@ -45,7 +45,7 @@ protected TypeDescription.Generic describeExceptionType(Method method, int index
 
     @Override
     protected TypeDescription.Generic describeSuperType(Class<?> type) {
-        return describe(type).getSuperType();
+        return describe(type).getSuperClass();
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyFacadeTypeDescriptionTest.java
Patch:
@@ -45,7 +45,7 @@ protected TypeDescription.Generic describeExceptionType(Method method, int index
 
     @Override
     protected TypeDescription.Generic describeSuperType(Class<?> type) {
-        return describe(type).getSuperType();
+        return describe(type).getSuperClass();
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/FieldAttributeAppender.java
Patch:
@@ -131,7 +131,7 @@ enum ForInstrumentedField implements FieldAttributeAppender, Factory {
         @Override
         public void apply(FieldVisitor fieldVisitor, FieldDescription fieldDescription, AnnotationValueFilter annotationValueFilter) {
             AnnotationAppender appender = new AnnotationAppender.Default(new AnnotationAppender.Target.OnField(fieldVisitor));
-            //appender = fieldDescription.getType().accept(AnnotationAppender.ForTypeAnnotations.ofFieldType(appender, annotationValueFilter));
+            appender = fieldDescription.getType().accept(AnnotationAppender.ForTypeAnnotations.ofFieldType(appender, annotationValueFilter));
             for (AnnotationDescription annotation : fieldDescription.getDeclaredAnnotations()) {
                 appender = appender.append(annotation, annotationValueFilter);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -1212,8 +1212,8 @@ protected class VariableRetainingDelegator extends TypeDescription.Generic.Visit
 
             @Override
             public TypeDescription.Generic onParameterizedType(TypeDescription.Generic parameterizedType) {
-                List<TypeDescription.Generic> parameters = new ArrayList<TypeDescription.Generic>(parameterizedType.getParameters().size());
-                for (TypeDescription.Generic parameter : parameterizedType.getParameters()) {
+                List<TypeDescription.Generic> parameters = new ArrayList<TypeDescription.Generic>(parameterizedType.getTypeArguments().size());
+                for (TypeDescription.Generic parameter : parameterizedType.getTypeArguments()) {
                     if (parameter.getSort().isTypeVariable() && !methodDescription.getTypeVariables().contains(parameter)) {
                         return visitor.onParameterizedType(parameterizedType);
                     } else if (parameter.getSort().isWildcard()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -325,7 +325,7 @@ class ForModernVm implements Dispatcher {
                 /**
                  * Creates a new dispatcher for a modern VM.
                  *
-                 * @param getParameters A reference to {@code java.lang.reflect.Executable#getParameters}.
+                 * @param getParameters A reference to {@code java.lang.reflect.Executable#getTypeArguments}.
                  * @param getName       A reference to {@code java.lang.reflect.Parameter#getName}.
                  * @param isNamePresent A reference to {@code java.lang.reflect.Parameter#isNamePresent}.
                  * @param getModifiers  A reference to {@code java.lang.reflect.Parameter#getModifiers}.

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -5093,7 +5093,7 @@ public TypeDescription asErasure() {
                             }
 
                             @Override
-                            public TypeList.Generic getParameters() {
+                            public TypeList.Generic getTypeArguments() {
                                 return new LazyTokenList(typePool, typeVariableSource, typePath, annotationTokens, parameterTypeTokens);
                             }
 
@@ -5174,7 +5174,7 @@ public TypeDescription asErasure() {
                         }
 
                         @Override
-                        public TypeList.Generic getParameters() {
+                        public TypeList.Generic getTypeArguments() {
                             return new LazyTokenList(typePool, typeVariableSource, typePath, annotationTokens, parameterTypeTokens);
                         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericOfTypeVariableSymbolic.java
Patch:
@@ -123,7 +123,7 @@ public void testUpperBoundsThrowsException() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testParametersThrowsException() throws Exception {
-        typeVariable.getParameters();
+        typeVariable.getTypeArguments();
     }
 
     @Test(expected = IllegalStateException.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorSubstitutorForTypeVariableBindingTest.java
Patch:
@@ -55,7 +55,7 @@ public void testTypeVariableUnknown() throws Exception {
     @Test
     public void testUnequalVariablesAndParameters() throws Exception {
         TypeDescription.Generic typeDescription = mock(TypeDescription.Generic.class);
-        when(typeDescription.getParameters()).thenReturn(new TypeList.Generic.Explicit(mock(TypeDescription.Generic.class)));
+        when(typeDescription.getTypeArguments()).thenReturn(new TypeList.Generic.Explicit(mock(TypeDescription.Generic.class)));
         TypeDescription rawTypeDescription = mock(TypeDescription.class);
         when(typeDescription.asErasure()).thenReturn(rawTypeDescription);
         when(rawTypeDescription.getTypeVariables()).thenReturn(new TypeList.Generic.Empty());

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericBuilderTest.java
Patch:
@@ -143,7 +143,7 @@ private TypeDescription.Generic.Builder builder(Type type, TypeDescription.Gener
             return builder(((GenericArrayType) type).getGenericComponentType(), annotationReader.ofComponentType()).asArray().annotate(annotationReader.asList());
         } else if (type instanceof ParameterizedType) {
             ParameterizedType parameterizedType = (ParameterizedType) type;
-            List<TypeDescription.Generic> parameters = new ArrayList<>(parameterizedType.getActualTypeArguments().length);
+            List<TypeDescription.Generic> parameters = new ArrayList<TypeDescription.Generic>(parameterizedType.getActualTypeArguments().length);
             int index = 0;
             for (Type parameter : parameterizedType.getActualTypeArguments()) {
                 parameters.add(describe(parameter, annotationReader.ofTypeArgument(index++)));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericOfTypeVariableSymbolic.java
Patch:
@@ -68,8 +68,8 @@ public void testPrimitive() throws Exception {
     public void testEquals() throws Exception {
         assertThat(typeVariable, is(typeVariable));
         assertThat(typeVariable, is((TypeDescription.Generic) new TypeDescription.Generic.OfTypeVariable.Symbolic(FOO, Collections.singletonList(annotationDescription))));
-        assertThat(typeVariable, is((TypeDescription.Generic) new TypeDescription.Generic.OfTypeVariable.Symbolic(FOO, Collections.emptyList())));
-        assertThat(typeVariable, not((TypeDescription.Generic) new TypeDescription.Generic.OfTypeVariable.Symbolic(BAR, Collections.emptyList())));
+        assertThat(typeVariable, is((TypeDescription.Generic) new TypeDescription.Generic.OfTypeVariable.Symbolic(FOO, Collections.<AnnotationDescription>emptyList())));
+        assertThat(typeVariable, not((TypeDescription.Generic) new TypeDescription.Generic.OfTypeVariable.Symbolic(BAR, Collections.<AnnotationDescription>emptyList())));
         assertThat(typeVariable, not(TypeDescription.Generic.OBJECT));
         assertThat(typeVariable, not(new Object()));
         assertThat(typeVariable, not(equalTo(null)));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorSubstitutorForTokenNormalizationTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.description.type;
 
+import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.dynamic.TargetType;
 import net.bytebuddy.test.utility.MockitoRule;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
@@ -44,7 +45,7 @@ public void testNotTargetType() throws Exception {
     @Test
     public void testTypeVariable() throws Exception {
         assertThat(new TypeDescription.Generic.Visitor.Substitutor.ForTokenNormalization(target).onTypeVariable(source),
-                is((TypeDescription.Generic) new TypeDescription.Generic.OfTypeVariable.Symbolic(FOO, Collections.emptyList()))); // TODO: Variables
+                is((TypeDescription.Generic) new TypeDescription.Generic.OfTypeVariable.Symbolic(FOO, Collections.<AnnotationDescription>emptyList()))); // TODO: Variables
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -2732,7 +2732,7 @@ public Builder<U> merge(Collection<? extends ModifierContributor.ForType> modifi
 
                 @Override
                 public TypeVariableDefinition<U> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
-                    return new TypeVariableDefinitionAdapter(new TypeVariableToken(symbol, new TypeList.Generic.Explicit(new ArrayList<>(bounds))));
+                    return new TypeVariableDefinitionAdapter(new TypeVariableToken(symbol, new TypeList.Generic.Explicit(new ArrayList<TypeDefinition>(bounds))));
                 }
 
                 @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultComponentTypeLocatorTest.java
Patch:
@@ -5,7 +5,6 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.RandomString;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.hamcrest.CoreMatchers.is;
@@ -46,7 +45,6 @@ public void testForArrayType() throws Exception {
     }
 
     @Test
-    @Ignore("Java 8 tests")
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(TypePool.Default.ComponentTypeLocator.ForAnnotationProperty.class).apply();
         ObjectPropertyAssertion.of(TypePool.Default.ComponentTypeLocator.ForAnnotationProperty.Bound.class).skipSynthetic().apply();

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultGenericTypeListTest.java
Patch:
@@ -12,7 +12,7 @@
 
 import static net.bytebuddy.matcher.ElementMatchers.anyOf;
 
-public class TypePoolGenericTypeListTest extends AbstractTypeListGenericTest<Type> {
+public class TypePoolDefaultGenericTypeListTest extends AbstractTypeListGenericTest<Type> {
 
     private TypePool typePool;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultLazyAnnotationListTest.java
Patch:
@@ -11,7 +11,7 @@
 
 import static net.bytebuddy.matcher.ElementMatchers.anyOf;
 
-public class TypePoolLazyAnnotationListTest extends AbstractAnnotationListTest<Annotation> {
+public class TypePoolDefaultLazyAnnotationListTest extends AbstractAnnotationListTest<Annotation> {
 
     private TypePool typePool;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultLazyFieldListTest.java
Patch:
@@ -11,7 +11,7 @@
 
 import static net.bytebuddy.matcher.ElementMatchers.anyOf;
 
-public class TypePoolLazyFieldListTest extends AbstractFieldListTest<Field, FieldDescription.InDefinedShape> {
+public class TypePoolDefaultLazyFieldListTest extends AbstractFieldListTest<Field, FieldDescription.InDefinedShape> {
 
     private TypePool typePool;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultLazyMethodListTest.java
Patch:
@@ -11,7 +11,7 @@
 
 import static net.bytebuddy.matcher.ElementMatchers.anyOf;
 
-public class TypePoolLazyMethodListTest extends AbstractMethodListTest<Method, MethodDescription.InDefinedShape> {
+public class TypePoolDefaultLazyMethodListTest extends AbstractMethodListTest<Method, MethodDescription.InDefinedShape> {
 
     private TypePool typePool;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultLazyParameterListTest.java
Patch:
@@ -12,7 +12,7 @@
 
 import static net.bytebuddy.matcher.ElementMatchers.is;
 
-public class TypePoolLazyParameterListTest extends AbstractParameterListTest<ParameterDescription.InDefinedShape, ParameterDescription> {
+public class TypePoolDefaultLazyParameterListTest extends AbstractParameterListTest<ParameterDescription.InDefinedShape, ParameterDescription> {
 
     private TypePool typePool;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultLazyTypeListTest.java
Patch:
@@ -10,7 +10,7 @@
 
 import static net.bytebuddy.matcher.ElementMatchers.anyOf;
 
-public class TypePoolLazyTypeListTest extends AbstractTypeListTest<Class<?>> {
+public class TypePoolDefaultLazyTypeListTest extends AbstractTypeListTest<Class<?>> {
 
     private TypePool typePool;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyObjectPropertiesTest.java
Patch:
@@ -40,7 +40,6 @@ public void testIllegalResolutionIsNotResolved() throws Exception {
     }
 
     @Test
-    @Ignore("Java 8 tests")
     public void testGenericTypeTokenObjectPropertiesTest() throws Exception {
         ObjectPropertyAssertion.of(TypePool.LazyTypeDescription.GenericTypeToken.ForPrimitiveType.class).apply();
         ObjectPropertyAssertion.of(TypePool.LazyTypeDescription.GenericTypeToken.ForRawType.class).apply();

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionGenericTest.java
Patch:
@@ -1322,15 +1322,15 @@ public void testTypeAnnotationsInterfaceType() throws Exception {
         Class<? extends Annotation> typeAnnotation = (Class<? extends Annotation>) Class.forName(TYPE_ANNOTATION);
         MethodDescription.InDefinedShape value = new TypeDescription.ForLoadedType(typeAnnotation).getDeclaredMethods().getOnly();
         Class<?> samples = Class.forName(TYPE_ANNOTATION_SAMPLES);
-        TypeDescription.Generic firstInterfaceType = describeInterfaceType(samples, 0);
+        /*TypeDescription.Generic firstInterfaceType = describeInterfaceType(samples, 0);
         assertThat(firstInterfaceType.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
         assertThat(firstInterfaceType.getDeclaredAnnotations().size(), is(1));
         assertThat(firstInterfaceType.getDeclaredAnnotations().isAnnotationPresent(typeAnnotation), is(true));
         assertThat(firstInterfaceType.getDeclaredAnnotations().ofType(typeAnnotation).getValue(value, Integer.class), is(19));
         assertThat(firstInterfaceType.getParameters().getOnly().getSort(), is(TypeDefinition.Sort.NON_GENERIC));
         assertThat(firstInterfaceType.getParameters().getOnly().getDeclaredAnnotations().size(), is(1));
         assertThat(firstInterfaceType.getParameters().getOnly().getDeclaredAnnotations().isAnnotationPresent(typeAnnotation), is(true));
-        assertThat(firstInterfaceType.getParameters().getOnly().getDeclaredAnnotations().ofType(typeAnnotation).getValue(value, Integer.class), is(20));
+        assertThat(firstInterfaceType.getParameters().getOnly().getDeclaredAnnotations().ofType(typeAnnotation).getValue(value, Integer.class), is(20));*/
         TypeDescription.Generic secondInterfaceType = describeInterfaceType(samples, 1);
         assertThat(secondInterfaceType.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
         assertThat(secondInterfaceType.getDeclaredAnnotations().size(), is(0));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericBuilderTest.java
Patch:
@@ -126,7 +126,7 @@ private TypeDescription.Generic.Builder builder(Type type, TypeDescription.Gener
             List<TypeDescription.Generic> parameters = new ArrayList<>(parameterizedType.getActualTypeArguments().length);
             int index = 0;
             for (Type parameter : parameterizedType.getActualTypeArguments()) {
-                parameters.add(describe(parameter, annotationReader.ofParameterType(index)));
+                parameters.add(describe(parameter, annotationReader.ofParameterType(index++)));
             }
             return TypeDescription.Generic.Builder.parameterizedType(new TypeDescription.ForLoadedType((Class<?>) parameterizedType.getRawType()),
                     parameterizedType.getOwnerType() == null

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -3003,12 +3003,12 @@ protected MethodExtractor(int modifiers,
                     this.descriptor = descriptor;
                     this.genericSignature = genericSignature;
                     this.exceptionName = exceptionName;
-                    annotationTokens = new ArrayList<LazyTypeDescription.AnnotationToken>();
                     typeVariableAnnotationTokens = new HashMap<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>();
                     typeVariableBoundAnnotationTokens = new HashMap<Integer, Map<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>>();
                     returnTypeAnnotationTokens = new HashMap<String, List<LazyTypeDescription.AnnotationToken>>();
                     parameterTypeAnnotationTokens = new HashMap<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>();
                     exceptionTypeAnnotationTokens = new HashMap<Integer, Map<String, List<LazyTypeDescription.AnnotationToken>>>();
+                    annotationTokens = new ArrayList<LazyTypeDescription.AnnotationToken>();
                     parameterAnnotationTokens = new HashMap<Integer, List<LazyTypeDescription.AnnotationToken>>();
                     parameterTokens = new ArrayList<LazyTypeDescription.MethodToken.ParameterToken>();
                     legacyParameterBag = new ParameterBag(Type.getMethodType(descriptor).getArgumentTypes());
@@ -3058,7 +3058,7 @@ public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, TypePath type
                 }
 
                 @Override
-                public AnnotationVisitor visitAnnotation(String descriptorcoo, boolean visible) {
+                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
                     return new AnnotationExtractor(descriptor, annotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
                 }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -987,7 +987,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
             return instrumentedType
                     .withField(new FieldDescription.Token(ENUM_VALUES,
                             ENUM_FIELD_MODIFIERS | Opcodes.ACC_SYNTHETIC,
-                            new TypeDescription.Generic.OfGenericArray.Latent(TargetType.GENERIC_DESCRIPTION, Collections.<AnnotationDescription>emptyList()))) // TODO
+                            new TypeDescription.Generic.OfGenericArray.Latent(TargetType.GENERIC_DESCRIPTION, Collections.<AnnotationDescription>emptyList())))
                     .withInitializer(new InitializationAppender(values));
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericBuilderTest.java
Patch:
@@ -103,9 +103,9 @@ private TypeDescription.Generic describe(Type type, TypeDescription.Generic.Anno
         } else if (type instanceof WildcardType) {
             WildcardType wildcardType = (WildcardType) type;
             if (wildcardType.getLowerBounds().length > 0) {
-                return builder(wildcardType.getLowerBounds()[0], annotationReader.ofWildcardLowerBound(0)).asWildcardLowerBound(annotationReader.asList());
+                return builder(wildcardType.getLowerBounds()[0], annotationReader.ofWildcardLowerBoundType(0)).asWildcardLowerBound(annotationReader.asList());
             } else if (wildcardType.getUpperBounds().length > 0) {
-                return builder(wildcardType.getUpperBounds()[0], annotationReader.ofWildcardUpperBound(0)).asWildcardUpperBound(annotationReader.asList());
+                return builder(wildcardType.getUpperBounds()[0], annotationReader.ofWildcardUpperBoundType(0)).asWildcardUpperBound(annotationReader.asList());
             } else {
                 return TypeDescription.Generic.Builder.unboundWildcard(annotationReader.asList()); // TODO: Remove?
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -3838,7 +3838,7 @@ public TypeVariableBoundList(java.lang.reflect.Type[] bound, AnnotationReader an
 
                     @Override
                     public Generic get(int index) {
-                        return Sort.describe(bound[index], annotationReader.ofParameter(index));
+                        return Sort.describe(bound[index], annotationReader.ofTypeVariableBound(index));
                     }
 
                     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -783,7 +783,7 @@ public AnnotationList getDeclaredAnnotations() {
 
         @Override
         public TypeList.Generic getTypeVariables() {
-            return new TypeList.Generic.ForLoadedTypes(constructor.getTypeParameters());
+            return TypeList.Generic.ForLoadedTypes.OfTypeVariables.of(constructor);
         }
     }
 
@@ -900,7 +900,7 @@ public Object getDefaultValue() {
 
         @Override
         public TypeList.Generic getTypeVariables() {
-            return new TypeList.Generic.ForLoadedTypes(method.getTypeParameters());
+            return TypeList.Generic.ForLoadedTypes.OfTypeVariables.of(method);
         }
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericBuilderTest.java
Patch:
@@ -3,6 +3,7 @@
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.lang.reflect.*;
@@ -83,6 +84,7 @@ public void testIncompatibleParameterTypeNumber() throws Exception {
     }
 
     @Test
+    @Ignore("Refactoring")
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(TypeDescription.Generic.Builder.class).apply();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionForLoadedTypeTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.description.type;
 
+import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.method.MethodDescription;
 
 import java.lang.reflect.Field;
@@ -14,7 +15,7 @@ protected TypeDescription describe(Class<?> type) {
 
     @Override
     protected TypeDescription.Generic describeType(Field field) {
-        return TypeDefinition.Sort.describe(field.getGenericType());
+        return new FieldDescription.ForLoadedField(field).getType();
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -2574,7 +2574,7 @@ public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, TypePath type
                     case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
                         annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex.DoubleIndexed(descriptor,
                                 typePath,
-                                typeReference.getTypeParameterBoundIndex() - 1,
+                                typeReference.getTypeParameterBoundIndex(),
                                 typeReference.getTypeParameterIndex(),
                                 typeVariableBoundsAnnotationTokens);
                         break;
@@ -5239,7 +5239,7 @@ protected LazyLowerBoundWildcard(TypePool typePool,
 
                     @Override
                     public TypeList.Generic getUpperBounds() {
-                        return new TypeList.Generic.Empty();
+                        return new TypeList.Generic.Explicit(Generic.OBJECT);
                     }
 
                     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionGenericTest.java
Patch:
@@ -10,7 +10,6 @@
 import net.bytebuddy.test.utility.JavaVersionRule;
 import org.hamcrest.CoreMatchers;
 import org.hamcrest.MatcherAssert;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.objectweb.asm.*;
 
@@ -213,7 +212,6 @@ public void testUpperBoundsWildcardParameterizedTypeNoIterator() throws Exceptio
     }
 
     @Test
-    @Ignore("Java 8 tests")
     public void testLowerBoundWildcardParameterizedType() throws Exception {
         TypeDescription.Generic typeDescription = describeType(LowerBoundWildcardParameterizedType.class.getDeclaredField(FOO));
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/precompiled/TypeAnnotationSamples.java
Patch:
@@ -6,7 +6,7 @@
 
 public abstract class TypeAnnotationSamples<@TypeAnnotation(0) T,
         S,
-        @TypeAnnotation(2) U extends @TypeAnnotation(3) Callable<@TypeAnnotation(4) ?> & @TypeAnnotation(5) List<@TypeAnnotation(6) ?>,
+        @TypeAnnotation(2) U extends String & @TypeAnnotation(3) Callable<@TypeAnnotation(4) ?> & @TypeAnnotation(5) List<@TypeAnnotation(6) ?>,
         @TypeAnnotation(7) V extends Map<@TypeAnnotation(8) ? extends @TypeAnnotation(9) String, @TypeAnnotation(10) Callable<@TypeAnnotation(11) ? super @TypeAnnotation(12) U>>>
         extends @TypeAnnotation(12) Object
         implements @TypeAnnotation(13) Callable<@TypeAnnotation(14) Object>, Map<@TypeAnnotation(15) String, Object> {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -29,7 +29,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-public abstract class AbstractTypeDescriptionTest extends AbstractTypeDescriptionGenericTest {
+public abstract class AbstractTypeDescriptionTest extends AbstractTypeDescriptionGenericVariableDefiningTest {
 
     private static final String FOO = "foo", BAR = "bar";
 
@@ -61,8 +61,6 @@ class MemberType {
                 }.getClass());
     }
 
-    protected abstract TypeDescription describe(Class<?> type);
-
     @Test
     public void testPrecondition() throws Exception {
         assertThat(describe(SampleClass.class), not(describe(SampleInterface.class)));

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -461,7 +461,7 @@ public DynamicType.Builder<? extends Enum<?>> makeEnumeration(Collection<? exten
         if (values.isEmpty()) {
             throw new IllegalArgumentException("Require at least one enumeration constant");
         }
-        TypeDescription.Generic enumType = TypeDescription.Generic.Builder.parameterizedType(Enum.class, TargetType.class).asType();
+        TypeDescription.Generic enumType = TypeDescription.Generic.Builder.parameterizedType(Enum.class, TargetType.class).build();
         return new SubclassDynamicTypeBuilder<Enum<?>>(InstrumentedType.Default.subclass(namingStrategy.subclass(enumType),
                 ModifierContributor.Resolver.of(Visibility.PUBLIC, TypeManifestation.FINAL, EnumerationState.ENUMERATION).resolve(),
                 enumType),

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -1587,7 +1587,7 @@ public static Object describe(Object value, TypeDescription typeDescription) {
             } else if (typeDescription.isAssignableTo(Annotation.class)) {
                 value = ForLoadedAnnotation.of((Annotation) value);
             } else if (typeDescription.isAssignableTo(Annotation[].class)) {
-                value = new AnnotationList.ForLoadedAnnotation((Annotation[]) value).toArray(new AnnotationDescription[((Annotation[]) value).length]);
+                value = new AnnotationList.ForLoadedAnnotations((Annotation[]) value).toArray(new AnnotationDescription[((Annotation[]) value).length]);
             }
             return value;
         }
@@ -1970,7 +1970,7 @@ public Builder defineEnumerationArray(String property, TypeDescription enumerati
         public <T extends Annotation> Builder defineAnnotationArray(String property, Class<T> annotationType, T... annotation) {
             return defineAnnotationArray(property,
                     new TypeDescription.ForLoadedType(annotationType),
-                    new AnnotationList.ForLoadedAnnotation(annotation).toArray(new AnnotationDescription[annotation.length]));
+                    new AnnotationList.ForLoadedAnnotations(annotation).toArray(new AnnotationDescription[annotation.length]));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -174,7 +174,7 @@ public TypeDescription.Generic getType() {
 
         @Override
         public AnnotationList getDeclaredAnnotations() {
-            return new AnnotationList.ForLoadedAnnotation(field.getDeclaredAnnotations());
+            return new AnnotationList.ForLoadedAnnotations(field.getDeclaredAnnotations());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -778,7 +778,7 @@ public Object getDefaultValue() {
 
         @Override
         public AnnotationList getDeclaredAnnotations() {
-            return new AnnotationList.ForLoadedAnnotation(constructor.getDeclaredAnnotations());
+            return new AnnotationList.ForLoadedAnnotations(constructor.getDeclaredAnnotations());
         }
 
         @Override
@@ -887,7 +887,7 @@ public Method getLoadedMethod() {
 
         @Override
         public AnnotationList getDeclaredAnnotations() {
-            return new AnnotationList.ForLoadedAnnotation(method.getDeclaredAnnotations());
+            return new AnnotationList.ForLoadedAnnotations(method.getDeclaredAnnotations());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/PackageDescription.java
Patch:
@@ -123,7 +123,7 @@ public ForLoadedPackage(Package aPackage) {
 
         @Override
         public AnnotationList getDeclaredAnnotations() {
-            return new AnnotationList.ForLoadedAnnotation(aPackage.getDeclaredAnnotations());
+            return new AnnotationList.ForLoadedAnnotations(aPackage.getDeclaredAnnotations());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -294,7 +294,7 @@ public static <T extends FieldDescription> ElementMatcher.Junction<T> anyOf(Fiel
      * @return A matcher that checks for the equality with any of the given objects.
      */
     public static <T extends AnnotationDescription> ElementMatcher.Junction<T> anyOf(Annotation... value) {
-        return anyOf(new AnnotationList.ForLoadedAnnotation(value));
+        return anyOf(new AnnotationList.ForLoadedAnnotations(value));
     }
 
     /**
@@ -382,7 +382,7 @@ public static <T extends FieldDescription> ElementMatcher.Junction<T> noneOf(Fie
      * @return A matcher that checks for the equality with any of the given objects.
      */
     public static <T extends AnnotationDescription> ElementMatcher.Junction<T> noneOf(Annotation... value) {
-        return noneOf(new AnnotationList.ForLoadedAnnotation(value));
+        return noneOf(new AnnotationList.ForLoadedAnnotations(value));
     }
 
     /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderInitializationStrategySelfInjectionDispatcherTest.java
Patch:
@@ -89,7 +89,7 @@ public Map<TypeDescription, Class<?>> answer(InvocationOnMock invocationOnMock)
         });
         Annotation eagerAnnotation = mock(AuxiliaryType.SignatureRelevant.class);
         when(eagerAnnotation.annotationType()).thenReturn((Class) AuxiliaryType.SignatureRelevant.class);
-        when(independent.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotation(eagerAnnotation));
+        when(independent.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(eagerAnnotation));
         when(dependent.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
         when(instrumentedInitializer.isAlive()).thenReturn(true);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderInitializationStrategyTest.java
Patch:
@@ -91,7 +91,7 @@ public void testMinimalRegistrationIndependentType() throws Exception {
         Annotation eagerAnnotation = mock(AuxiliaryType.SignatureRelevant.class);
         when(eagerAnnotation.annotationType()).thenReturn((Class) AuxiliaryType.SignatureRelevant.class);
         TypeDescription independent = mock(TypeDescription.class), dependent = mock(TypeDescription.class);
-        when(independent.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotation(eagerAnnotation));
+        when(independent.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(eagerAnnotation));
         when(dependent.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
         Map<TypeDescription, byte[]> map = new HashMap<TypeDescription, byte[]>();
         map.put(independent, QUX);

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AnnotationListForLoadedAnnotationsTest.java
Patch:
@@ -3,7 +3,7 @@
 import java.lang.annotation.Annotation;
 import java.util.List;
 
-public class AnnotationListForLoadedAnnotationTest extends AbstractAnnotationListTest<Annotation> {
+public class AnnotationListForLoadedAnnotationsTest extends AbstractAnnotationListTest<Annotation> {
 
     @Override
     protected Annotation getFirst() throws Exception {
@@ -17,7 +17,7 @@ protected Annotation getSecond() throws Exception {
 
     @Override
     protected AnnotationList asList(List<Annotation> elements) {
-        return new AnnotationList.ForLoadedAnnotation(elements);
+        return new AnnotationList.ForLoadedAnnotations(elements);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/AbstractFieldDescriptionTest.java
Patch:
@@ -170,7 +170,7 @@ public void testIsVisibleTo() throws Exception {
     public void testAnnotations() throws Exception {
         assertThat(describe(first).getDeclaredAnnotations(), is((AnnotationList) new AnnotationList.Empty()));
         assertThat(describe(second).getDeclaredAnnotations(),
-                is((AnnotationList) new AnnotationList.ForLoadedAnnotation(second.getDeclaredAnnotations())));
+                is((AnnotationList) new AnnotationList.ForLoadedAnnotations(second.getDeclaredAnnotations())));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/FieldDescriptionLatentTest.java
Patch:
@@ -14,6 +14,6 @@ protected FieldDescription.InDefinedShape describe(Field field) {
                 field.getName(),
                 field.getModifiers(),
                 TypeDefinition.Sort.describe(field.getGenericType()),
-                new AnnotationList.ForLoadedAnnotation(field.getDeclaredAnnotations()));
+                new AnnotationList.ForLoadedAnnotations(field.getDeclaredAnnotations()));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractPackageDescriptionTest.java
Patch:
@@ -22,7 +22,7 @@ public void testTrivialPackage() throws Exception {
     public void testNonTrivialPackage() throws Exception {
         assertThat(describe(Sample.class).getName(), is(Sample.class.getPackage().getName()));
         assertThat(describe(Sample.class).getDeclaredAnnotations(),
-                is((AnnotationList) new AnnotationList.ForLoadedAnnotation(Sample.class.getPackage().getDeclaredAnnotations())));
+                is((AnnotationList) new AnnotationList.ForLoadedAnnotations(Sample.class.getPackage().getDeclaredAnnotations())));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -384,11 +384,11 @@ public void testAnnotations() throws Exception {
 
     private void assertAnnotations(Class<?> type) {
         assertThat(describe(type).getDeclaredAnnotations(),
-                hasItems(new AnnotationList.ForLoadedAnnotation(type.getDeclaredAnnotations())
+                hasItems(new AnnotationList.ForLoadedAnnotations(type.getDeclaredAnnotations())
                         .toArray(new AnnotationDescription[type.getDeclaredAnnotations().length])));
         assertThat(describe(type).getDeclaredAnnotations().size(), is(type.getDeclaredAnnotations().length));
         assertThat(describe(type).getInheritedAnnotations(),
-                hasItems(new AnnotationList.ForLoadedAnnotation(type.getAnnotations())
+                hasItems(new AnnotationList.ForLoadedAnnotations(type.getAnnotations())
                         .toArray(new AnnotationDescription[type.getAnnotations().length])));
         assertThat(describe(type).getInheritedAnnotations().size(), is(type.getAnnotations().length));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterFieldPoolRecordTest.java
Patch:
@@ -83,7 +83,7 @@ public void setUp() throws Exception {
         when(annotationDescription.getAnnotationType()).thenReturn(annotationType);
         when(annotationType.getDescriptor()).thenReturn(BAZ);
         when(annotationType.getDeclaredMethods()).thenReturn(new MethodList.Empty<MethodDescription.InDefinedShape>());
-        when(annotationType.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotation(retention));
+        when(annotationType.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(retention));
         when(retention.value()).thenReturn(RetentionPolicy.RUNTIME);
         when(retention.annotationType()).thenReturn((Class) Retention.class);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/FieldAttributeAppenderForInstrumentedFieldTest.java
Patch:
@@ -18,7 +18,7 @@ public void testFactory() throws Exception {
 
     @Test
     public void testAnnotationAppenderNoRetention() throws Exception {
-        when(fieldDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotation(new Qux.Instance()));
+        when(fieldDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(new Qux.Instance()));
         FieldAttributeAppender.ForInstrumentedField.INSTANCE.apply(fieldVisitor, fieldDescription, annotationValueFilter);
         verifyZeroInteractions(fieldVisitor);
         verify(fieldDescription).getDeclaredAnnotations();
@@ -27,7 +27,7 @@ public void testAnnotationAppenderNoRetention() throws Exception {
 
     @Test
     public void testAnnotationAppenderRuntimeRetention() throws Exception {
-        when(fieldDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotation(new Baz.Instance()));
+        when(fieldDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(new Baz.Instance()));
         FieldAttributeAppender.ForInstrumentedField.INSTANCE.apply(fieldVisitor, fieldDescription, annotationValueFilter);
         verify(fieldVisitor).visitAnnotation(Type.getDescriptor(Baz.class), true);
         verifyNoMoreInteractions(fieldVisitor);
@@ -37,7 +37,7 @@ public void testAnnotationAppenderRuntimeRetention() throws Exception {
 
     @Test
     public void testAnnotationAppenderByteCodeRetention() throws Exception {
-        when(fieldDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotation(new QuxBaz.Instance()));
+        when(fieldDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(new QuxBaz.Instance()));
         FieldAttributeAppender.ForInstrumentedField.INSTANCE.apply(fieldVisitor, fieldDescription, annotationValueFilter);
         verify(fieldVisitor).visitAnnotation(Type.getDescriptor(QuxBaz.class), false);
         verifyNoMoreInteractions(fieldVisitor);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/MethodAttributeAppenderForInstrumentedMethodTest.java
Patch:
@@ -20,8 +20,7 @@ public class MethodAttributeAppenderForInstrumentedMethodTest extends AbstractMe
     @SuppressWarnings("unchecked")
     public void testMethodAnnotations() throws Exception {
         when(annotationValueFilter.isRelevant(any(AnnotationDescription.class), any(MethodDescription.InDefinedShape.class))).thenReturn(true);
-        when(methodDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList
-                .ForLoadedAnnotation(new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()));
+        when(methodDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()));
         when(methodDescription.getParameters()).thenReturn((ParameterList) new ParameterList.Empty<ParameterDescription>());
         when(methodDescription.getDeclaringType()).thenReturn(mock(TypeDescription.Generic.class));
         MethodAttributeAppender.ForInstrumentedMethod.INSTANCE.apply(methodVisitor, methodDescription, annotationValueFilter);
@@ -40,7 +39,7 @@ public void testMethodParameterAnnotations() throws Exception {
         when(methodDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
         ParameterDescription parameterDescription = mock(ParameterDescription.class);
         when(parameterDescription.getDeclaredAnnotations())
-                .thenReturn(new AnnotationList.ForLoadedAnnotation(new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()));
+                .thenReturn(new AnnotationList.ForLoadedAnnotations(new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()));
         when(methodDescription.getParameters()).thenReturn((ParameterList) new ParameterList.Explicit<ParameterDescription>(parameterDescription));
         when(methodDescription.getDeclaringType()).thenReturn(mock(TypeDescription.Generic.class));
         MethodAttributeAppender.ForInstrumentedMethod.INSTANCE.apply(methodVisitor, methodDescription, annotationValueFilter);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/TypeAttributeAppenderExplicitTest.java
Patch:
@@ -13,15 +13,15 @@ public class TypeAttributeAppenderExplicitTest extends AbstractTypeAttributeAppe
 
     @Test
     public void testAnnotationAppenderNoRetention() throws Exception {
-        new TypeAttributeAppender.Explicit(new AnnotationList.ForLoadedAnnotation(new Qux.Instance()))
+        new TypeAttributeAppender.Explicit(new AnnotationList.ForLoadedAnnotations(new Qux.Instance()))
                 .apply(classVisitor, instrumentedType, annotationValueFilter);
         verifyZeroInteractions(classVisitor);
         verifyZeroInteractions(instrumentedType);
     }
 
     @Test
     public void testAnnotationAppenderRuntimeRetention() throws Exception {
-        new TypeAttributeAppender.Explicit(new AnnotationList.ForLoadedAnnotation(new Baz.Instance()))
+        new TypeAttributeAppender.Explicit(new AnnotationList.ForLoadedAnnotations(new Baz.Instance()))
                 .apply(classVisitor, instrumentedType, annotationValueFilter);
         verify(classVisitor).visitAnnotation(Type.getDescriptor(Baz.class), true);
         verifyZeroInteractions(classVisitor);
@@ -30,7 +30,7 @@ public void testAnnotationAppenderRuntimeRetention() throws Exception {
 
     @Test
     public void testAnnotationAppenderByteCodeRetention() throws Exception {
-        new TypeAttributeAppender.Explicit(new AnnotationList.ForLoadedAnnotation(new QuxBaz.Instance()))
+        new TypeAttributeAppender.Explicit(new AnnotationList.ForLoadedAnnotations(new QuxBaz.Instance()))
                 .apply(classVisitor, instrumentedType, annotationValueFilter);
         verify(classVisitor).visitAnnotation(Type.getDescriptor(QuxBaz.class), false);
         verifyNoMoreInteractions(classVisitor);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/TypeAttributeAppenderForInstrumentedMethodExcludingTest.java
Patch:
@@ -16,7 +16,7 @@ public class TypeAttributeAppenderForInstrumentedMethodExcludingTest extends Abs
     @Test
     public void testApplicationExcludedAnnotation() throws Exception {
         when(instrumentedType.getDeclaredAnnotations())
-                .thenReturn(new AnnotationList.ForLoadedAnnotation(new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()));
+                .thenReturn(new AnnotationList.ForLoadedAnnotations(new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()));
         new TypeAttributeAppender.ForInstrumentedType.Excluding(Collections.singleton(AnnotationDescription.ForLoadedAnnotation.of(new Baz.Instance())))
                 .apply(classVisitor, instrumentedType, annotationValueFilter);
         verify(classVisitor).visitAnnotation(Type.getDescriptor(QuxBaz.class), false);
@@ -27,7 +27,7 @@ public void testApplicationExcludedAnnotation() throws Exception {
     @Test
     public void testApplicationNoExcludedAnnotation() throws Exception {
         when(instrumentedType.getDeclaredAnnotations())
-                .thenReturn(new AnnotationList.ForLoadedAnnotation(new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()));
+                .thenReturn(new AnnotationList.ForLoadedAnnotations(new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()));
         new TypeAttributeAppender.ForInstrumentedType.Excluding(Collections.<AnnotationDescription>emptySet())
                 .apply(classVisitor, instrumentedType, annotationValueFilter);
         verify(classVisitor).visitAnnotation(Type.getDescriptor(Baz.class), true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/TypeAttributeAppenderForInstrumentedTypeTest.java
Patch:
@@ -11,8 +11,7 @@ public class TypeAttributeAppenderForInstrumentedTypeTest extends AbstractTypeAt
 
     @Test
     public void testApplication() throws Exception {
-        when(instrumentedType.getDeclaredAnnotations()).thenReturn(new AnnotationList
-                .ForLoadedAnnotation(new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()));
+        when(instrumentedType.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()));
         TypeAttributeAppender.ForInstrumentedType.INSTANCE.apply(classVisitor, instrumentedType, annotationValueFilter);
         verify(classVisitor).visitAnnotation(Type.getDescriptor(Baz.class), true);
         verify(classVisitor).visitAnnotation(Type.getDescriptor(QuxBaz.class), false);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/AllArgumentsBinderTest.java
Patch:
@@ -70,7 +70,7 @@ public void testLegalStrictBindingNoRuntimeType() throws Exception {
         when(target.getIndex()).thenReturn(1);
         RuntimeType runtimeType = mock(RuntimeType.class);
         doReturn(RuntimeType.class).when(runtimeType).annotationType();
-        when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotation(runtimeType));
+        when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(runtimeType));
         testLegalStrictBinding(true, runtimeType);
     }
 
@@ -83,7 +83,7 @@ private void testLegalStrictBinding(boolean dynamicallyTyped, Annotation... targ
         when(targetType.getComponentType()).thenReturn(componentType);
         when(componentType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(target.getType()).thenReturn(targetType);
-        when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotation(targetAnnotation));
+        when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(targetAnnotation));
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = AllArguments.Binder.INSTANCE
                 .bind(annotationDescription, source, target, implementationTarget, assigner);
         assertThat(parameterBinding.isValid(), is(true));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ArgumentBinderTest.java
Patch:
@@ -94,7 +94,7 @@ private void assertBinding(boolean dynamicallyTyped,
         when(source.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(source, typeDescriptions));
         when(source.isStatic()).thenReturn(false);
         when(target.getType()).thenReturn(genericTargetType);
-        when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotation(annotations));
+        when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(annotations));
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = Argument.Binder.INSTANCE
                 .bind(annotationDescription, source, target, implementationTarget, assigner);
         assertThat(parameterBinding.isValid(), is(true));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/RuntimeTypeVerifierTest.java
Patch:
@@ -41,15 +41,15 @@ public void setUp() throws Exception {
 
     @Test
     public void testCheckElementValid() throws Exception {
-        when(annotatedCodeElement.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotation(runtimeType));
+        when(annotatedCodeElement.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(runtimeType));
         assertThat(RuntimeType.Verifier.check(annotatedCodeElement), is(Assigner.Typing.DYNAMIC));
         verify(annotatedCodeElement).getDeclaredAnnotations();
         verifyNoMoreInteractions(annotatedCodeElement);
     }
 
     @Test
     public void testCheckElementInvalid() throws Exception {
-        when(annotatedCodeElement.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotation());
+        when(annotatedCodeElement.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations());
         assertThat(RuntimeType.Verifier.check(annotatedCodeElement), is(Assigner.Typing.STATIC));
         verify(annotatedCodeElement).getDeclaredAnnotations();
         verifyNoMoreInteractions(annotatedCodeElement);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ThisBinderTest.java
Patch:
@@ -56,7 +56,7 @@ public void testLegalBindingRuntimeType() throws Exception {
         when(target.getType()).thenReturn(parameterType);
         RuntimeType runtimeType = mock(RuntimeType.class);
         doReturn(RuntimeType.class).when(runtimeType).annotationType();
-        when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotation(runtimeType));
+        when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotations(runtimeType));
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = This.Binder.INSTANCE
                 .bind(annotationDescription, source, target, implementationTarget, assigner);
         assertThat(parameterBinding.isValid(), is(true));

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -987,7 +987,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
             return instrumentedType
                     .withField(new FieldDescription.Token(ENUM_VALUES,
                             ENUM_FIELD_MODIFIERS | Opcodes.ACC_SYNTHETIC,
-                            TypeDescription.Generic.OfGenericArray.Latent.of(TargetType.GENERIC_DESCRIPTION, Collections.<AnnotationDescription>emptyList()))) // TODO
+                            new TypeDescription.Generic.OfGenericArray.Latent(TargetType.GENERIC_DESCRIPTION, Collections.<AnnotationDescription>emptyList()))) // TODO
                     .withInitializer(new InitializationAppender(values));
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorSubstitutorForTokenNormalizationTest.java
Patch:
@@ -10,6 +10,8 @@
 import org.mockito.Mock;
 import org.mockito.Mockito;
 
+import java.util.Collections;
+
 import static org.hamcrest.core.Is.is;
 import static org.junit.Assert.assertThat;
 import static org.mockito.Mockito.when;
@@ -42,7 +44,7 @@ public void testNotTargetType() throws Exception {
     @Test
     public void testTypeVariable() throws Exception {
         assertThat(new TypeDescription.Generic.Visitor.Substitutor.ForTokenNormalization(target).onTypeVariable(source),
-                is((TypeDescription.Generic) new TypeDescription.Generic.OfTypeVariable.Symbolic(FOO, declaredAnnotations)));
+                is((TypeDescription.Generic) new TypeDescription.Generic.OfTypeVariable.Symbolic(FOO, Collections.emptyList()))); // TODO
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyObjectPropertiesTest.java
Patch:
@@ -13,6 +13,7 @@
 public class TypePoolLazyObjectPropertiesTest {
 
     @Test
+    @Ignore("Refactoring")
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(TypePool.LazyTypeDescription.FieldToken.class).apply();
         ObjectPropertyAssertion.of(TypePool.LazyTypeDescription.MethodToken.class).apply();

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy;
 
+import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.modifier.*;
@@ -986,7 +987,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
             return instrumentedType
                     .withField(new FieldDescription.Token(ENUM_VALUES,
                             ENUM_FIELD_MODIFIERS | Opcodes.ACC_SYNTHETIC,
-                            TypeDescription.Generic.OfGenericArray.Latent.of(TargetType.GENERIC_DESCRIPTION, 1)))
+                            TypeDescription.Generic.OfGenericArray.Latent.of(TargetType.GENERIC_DESCRIPTION, Collections.<AnnotationDescription>emptyList()))) // TODO
                     .withInitializer(new InitializationAppender(values));
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -1230,7 +1230,7 @@ public TypeDescription.Generic onParameterizedType(TypeDescription.Generic param
                         ownerType == null
                                 ? TypeDescription.Generic.UNDEFINED
                                 : ownerType.accept(this),
-                        parameters);
+                        parameters, declaredAnnotations);
             }
 
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorSubstitutorForTokenNormalizationTest.java
Patch:
@@ -42,7 +42,7 @@ public void testNotTargetType() throws Exception {
     @Test
     public void testTypeVariable() throws Exception {
         assertThat(new TypeDescription.Generic.Visitor.Substitutor.ForTokenNormalization(target).onTypeVariable(source),
-                is((TypeDescription.Generic) new TypeDescription.Generic.OfTypeVariable.Symbolic(FOO)));
+                is((TypeDescription.Generic) new TypeDescription.Generic.OfTypeVariable.Symbolic(FOO, declaredAnnotations)));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionGenericTest.java
Patch:
@@ -9,6 +9,7 @@
 import net.bytebuddy.implementation.bytecode.StackSize;
 import org.hamcrest.CoreMatchers;
 import org.hamcrest.MatcherAssert;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.objectweb.asm.*;
 
@@ -198,6 +199,7 @@ public void testUpperBoundsWildcardParameterizedTypeNoIterator() throws Exceptio
     }
 
     @Test
+    @Ignore("Java 8 tests")
     public void testLowerBoundWildcardParameterizedType() throws Exception {
         TypeDescription.Generic typeDescription = describe(LowerBoundWildcardParameterizedType.class.getDeclaredField(FOO));
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultComponentTypeLocatorTest.java
Patch:
@@ -5,6 +5,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.RandomString;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.hamcrest.CoreMatchers.is;
@@ -45,6 +46,7 @@ public void testForArrayType() throws Exception {
     }
 
     @Test
+    @Ignore("Java 8 tests")
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(TypePool.Default.ComponentTypeLocator.ForAnnotationProperty.class).apply();
         ObjectPropertyAssertion.of(TypePool.Default.ComponentTypeLocator.ForAnnotationProperty.Bound.class).skipSynthetic().apply();

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyObjectPropertiesTest.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.pool;
 
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.util.Arrays;
@@ -38,6 +39,7 @@ public void testIllegalResolutionIsNotResolved() throws Exception {
     }
 
     @Test
+    @Ignore("Java 8 tests")
     public void testGenericTypeTokenObjectPropertiesTest() throws Exception {
         ObjectPropertyAssertion.of(TypePool.LazyTypeDescription.GenericTypeToken.ForPrimitiveType.class).apply();
         ObjectPropertyAssertion.of(TypePool.LazyTypeDescription.GenericTypeToken.ForRawType.class).apply();

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/LatentMatcher.java
Patch:
@@ -301,10 +301,9 @@ public Compound(List<? extends LatentMatcher<? super S>> matchers) {
 
         @Override
         public ElementMatcher<? super S> resolve(TypeDescription instrumentedType) {
-            ElementMatcher.Junction<? super S> matcher = none();
+            ElementMatcher.Junction<S> matcher = none();
             for (LatentMatcher<? super S> latentMatcher : matchers) {
-                // Casting required for Java 6 compiler.
-                matcher = matcher.or((ElementMatcher<? super S>) latentMatcher.resolve(instrumentedType));
+                matcher = matcher.or(latentMatcher.resolve(instrumentedType));
             }
             return matcher;
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveBoxingDelegate.java
Patch:
@@ -124,7 +124,7 @@ public static PrimitiveBoxingDelegate forPrimitive(TypeDefinition typeDefinition
      * Creates a stack manipulation that boxes the represented primitive type and applies a chained assignment
      * to the result of this boxing operation.
      *
-     * @param targetType      The type that is target of the assignment operation.
+     * @param target      The type that is target of the assignment operation.
      * @param chainedAssigner The assigner that is to be used to perform the chained assignment.
      * @param typing          Determines if an assignment to an incompatible type should be enforced by a casting.
      * @return A stack manipulation that represents the described assignment operation.

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/PackageTypeStrategyManifestReadingTest.java
Patch:
@@ -234,6 +234,7 @@ public void testSealBaseLocatorForTypeResourceUrlJarUrl() throws Exception {
 
     @Test
     @IntegrationRule.Enforce
+    @JavaVersionRule.Enforce(9)
     @Ignore("Cannot yet determine tests specific to Java 9")
     public void testSealBaseLocatorForTypeResourceUrlJavaRuntimeImageUrl() throws Exception {
         URL url = new URL("jrt:/foo/bar");
@@ -245,6 +246,7 @@ public void testSealBaseLocatorForTypeResourceUrlJavaRuntimeImageUrl() throws Ex
 
     @Test
     @IntegrationRule.Enforce
+    @JavaVersionRule.Enforce(9)
     @Ignore("Cannot yet determine tests specific to Java 9")
     public void testSealBaseLocatorForTypeResourceUrlJavaRuntimeImageUrlRawModule() throws Exception {
         URL url = new URL("jrt:/foo");

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedMethodTest.java
Patch:
@@ -22,7 +22,6 @@
 
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -87,7 +86,7 @@ public void setUp() throws Exception {
         when(methodNameTransformer.transform(methodDescription)).thenReturn(QUX);
         when(otherMethodNameTransformer.transform(methodDescription)).thenReturn(FOO + BAR);
         when(parameterType.getStackSize()).thenReturn(StackSize.ZERO);
-        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(methodDescription, Collections.singletonList(genericParameterType)));
+        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(methodDescription, genericParameterType));
         when(genericReturnType.asErasure()).thenReturn(returnType);
         when(genericReturnType.asRawType()).thenReturn(genericReturnType);
         when(genericReturnType.accept(any(TypeDescription.Generic.Visitor.class))).thenReturn(genericReturnType);
@@ -107,7 +106,7 @@ public void testPreservation() throws Exception {
         assertThat(resolution.getResolvedMethod().getModifiers(), is(rebasedMethodModifiers));
         assertThat(resolution.getResolvedMethod().getReturnType(), is(genericReturnType));
         assertThat(resolution.getResolvedMethod().getParameters(), is((ParameterList<ParameterDescription.InDefinedShape>) new ParameterList.Explicit
-                .ForTypes(resolution.getResolvedMethod(), Collections.singletonList(parameterType))));
+                .ForTypes(resolution.getResolvedMethod(), parameterType)));
         StackManipulation.Size size = resolution.getAdditionalArguments().apply(methodVisitor, implementationContext);
         assertThat(size.getSizeImpact(), is(0));
         assertThat(size.getMaximalSize(), is(0));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TypeProxyCreationTest.java
Patch:
@@ -24,7 +24,6 @@
 import org.objectweb.asm.Opcodes;
 
 import java.io.Serializable;
-import java.util.Arrays;
 import java.util.Collections;
 
 import static net.bytebuddy.matcher.ElementMatchers.*;
@@ -71,7 +70,7 @@ public void setUp() throws Exception {
                 .listNodes()
                 .asMethodList()
                 .filter(isVirtual().and(not(isFinal())).and(not(isDefaultFinalizer())));
-        when(proxyMethod.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(proxyMethod, Arrays.asList(foo, foo, foo)));
+        when(proxyMethod.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(proxyMethod, foo, foo, foo));
         when(proxyMethod.getDeclaringType()).thenReturn(foo);
         when(proxyMethod.getInternalName()).thenReturn(FOO);
         when(proxyMethod.getDescriptor()).thenReturn(FOO);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ArgumentBinderTest.java
Patch:
@@ -25,7 +25,7 @@
 public class ArgumentBinderTest extends AbstractAnnotationBinderTest<Argument> {
 
     @Mock
-    private TypeDescription sourceType, targetType; // TODO: Remove?
+    private TypeDescription sourceType, targetType;
 
     @Mock
     private TypeDescription.Generic genericSourceType, genericTargetType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ArgumentNextUnboundAsDefaultBinderTest.java
Patch:
@@ -16,7 +16,6 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 
-import java.util.Arrays;
 import java.util.Iterator;
 
 import static org.hamcrest.CoreMatchers.is;
@@ -46,7 +45,7 @@ public class ArgumentNextUnboundAsDefaultBinderTest {
     public void setUp() throws Exception {
         when(firstParameter.getStackSize()).thenReturn(StackSize.ZERO);
         when(secondParameter.getStackSize()).thenReturn(StackSize.ZERO);
-        sourceParameters = new ParameterList.Explicit.ForTypes(source, Arrays.asList(firstParameter, secondParameter));
+        sourceParameters = new ParameterList.Explicit.ForTypes(source, firstParameter, secondParameter);
         ParameterList<ParameterDescription.InDefinedShape> targetParameters =
                 new ParameterList.Explicit<ParameterDescription.InDefinedShape>(firstTargetParameter, secondTargetParameter);
         when(source.getParameters()).thenReturn(sourceParameters);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinderTerminationHandlerReturningTest.java
Patch:
@@ -48,7 +48,7 @@ public void setUp() throws Exception {
         when(source.getReturnType()).thenReturn(genericSourceType);
         when(target.getReturnType()).thenReturn(genericTargetType);
         when(genericSourceType.asErasure()).thenReturn(sourceType);
-        when(genericTargetType.asErasure()).thenReturn(targetType); // TODO: remove?
+        when(genericTargetType.asErasure()).thenReturn(targetType);
         when(assigner.assign(eq(genericTargetType), eq(genericSourceType), any(Assigner.Typing.class))).thenReturn(stackManipulation);
         when(target.getDeclaredAnnotations()).thenReturn(annotationList);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationDynamicTest.java
Patch:
@@ -59,7 +59,7 @@ public void setUp() throws Exception {
         when(methodDescription.getInternalName()).thenReturn(QUX);
         when(methodDescription.getDescriptor()).thenReturn(BAZ);
         when(declaringType.getInternalName()).thenReturn(BAR);
-        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(methodDescription, Arrays.asList(firstType, secondType)));
+        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(methodDescription, firstType, secondType));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccessOfMethodArgumentsTest.java
Patch:
@@ -57,8 +57,7 @@ public void setUp() throws Exception {
         when(secondParameterType.asErasure()).thenReturn(secondRawParameterType);
         when(secondParameterType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(secondParameterType.asGenericType()).thenReturn(secondParameterType);
-        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(methodDescription,
-                Arrays.asList(firstParameterType, secondParameterType)));
+        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(methodDescription, firstParameterType, secondParameterType));
         when(bridgeMethod.getDeclaringType()).thenReturn(declaringType);
         when(secondRawParameterType.getInternalName()).thenReturn(FOO);
         when(firstParameterType.accept(any(TypeDescription.Generic.Visitor.class))).thenReturn(firstParameterType);
@@ -138,7 +137,7 @@ public void testBridgeMethodWithoutCasting() throws Exception {
     @Test
     public void testBridgeMethodWithCasting() throws Exception {
         when(secondRawParameterType.asErasure()).thenReturn(secondRawParameterType);
-        when(bridgeMethod.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(bridgeMethod, Arrays.asList(secondParameterType, secondParameterType)));
+        when(bridgeMethod.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(bridgeMethod, secondParameterType, secondParameterType));
         StackManipulation stackManipulation = MethodVariableAccess.allArgumentsOf(methodDescription).asBridgeOf(bridgeMethod);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/VoidAwareAssigner.java
Patch:
@@ -43,7 +43,7 @@ public StackManipulation assign(TypeDescription.Generic source, TypeDescription.
                     ? DefaultValue.of(target)
                     : StackManipulation.Illegal.INSTANCE;
         } else if (/* superType != void.class && */ target.represents(void.class)) {
-            return Removal.pop(source.asErasure());
+            return Removal.pop(source);
         } else /* superType != void.class && subType != void.class */ {
             return chained.assign(source, target, typing);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/collection/ArrayFactory.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.implementation.bytecode.collection;
 
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
@@ -65,7 +66,7 @@ public static ArrayFactory forType(TypeDescription.Generic componentType) {
      * @param componentType The component type of the array to be created.
      * @return A suitable array creator.
      */
-    private static ArrayCreator makeArrayCreatorFor(TypeDescription.Generic componentType) {
+    private static ArrayCreator makeArrayCreatorFor(TypeDefinition componentType) {
         if (componentType.isPrimitive()) {
             if (componentType.represents(boolean.class)) {
                 return ArrayCreator.ForPrimitiveType.BOOLEAN;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/VoidAwareAssignerNonVoidToVoidTest.java
Patch:
@@ -72,14 +72,14 @@ public static Collection<Object[]> data() {
     public void setUp() throws Exception {
         when(source.represents(sourceType)).thenReturn(true);
         when(source.getStackSize()).thenReturn(StackSize.of(sourceType));
+        when(source.asErasure()).thenReturn(rawSource);
+        when(rawSource.represents(sourceType)).thenReturn(true);
+        when(rawSource.asErasure()).thenReturn(rawSource);
         if (sourceType.isPrimitive()) {
             when(source.isPrimitive()).thenReturn(true);
         }
         when(target.represents(void.class)).thenReturn(true);
         when(target.isPrimitive()).thenReturn(true);
-        when(source.asErasure()).thenReturn(rawSource);
-        when(rawSource.represents(sourceType)).thenReturn(true);
-        when(rawSource.asErasure()).thenReturn(rawSource);
     }
 
     @After

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/FieldAccessOtherTest.java
Patch:
@@ -104,12 +104,12 @@ public void testEnumerationDescriptionNonEnumeration() throws Exception {
     @Test
     public void testGenericFieldAccessGetter() throws Exception {
         TypeDescription genericErasure = mock(TypeDescription.class), declaredErasure = mock(TypeDescription.class);
+        when(genericErasure.asErasure()).thenReturn(genericErasure);
         when(genericType.asErasure()).thenReturn(genericErasure);
         when(declaredType.asErasure()).thenReturn(declaredErasure);
         StackManipulation stackManipulation = FieldAccess.forField(genericField).getter();
         assertThat(stackManipulation.isValid(), is(true));
-        assertThat(stackManipulation, is((StackManipulation) new StackManipulation.Compound(FieldAccess.forField(fieldDescription).getter(),
-                TypeCasting.to(genericErasure))));
+        assertThat(stackManipulation, is((StackManipulation) new StackManipulation.Compound(FieldAccess.forField(fieldDescription).getter(), TypeCasting.to(genericErasure))));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccessOfMethodArgumentsTest.java
Patch:
@@ -137,8 +137,8 @@ public void testBridgeMethodWithoutCasting() throws Exception {
 
     @Test
     public void testBridgeMethodWithCasting() throws Exception {
-        when(bridgeMethod.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(bridgeMethod,
-                Arrays.asList(secondParameterType, secondParameterType)));
+        when(secondRawParameterType.asErasure()).thenReturn(secondRawParameterType);
+        when(bridgeMethod.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(bridgeMethod, Arrays.asList(secondParameterType, secondParameterType)));
         StackManipulation stackManipulation = MethodVariableAccess.allArgumentsOf(methodDescription).asBridgeOf(bridgeMethod);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -1060,7 +1060,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                 }
                 stackManipulation = new StackManipulation.Compound(
                         stackManipulation,
-                        ArrayFactory.forType(instrumentedType).withValues(fieldGetters),
+                        ArrayFactory.forType(instrumentedType.asGenericType()).withValues(fieldGetters),
                         FieldAccess.forField(instrumentedType.getDeclaredFields().filter(named(ENUM_VALUES)).getOnly()).putter()
                 );
                 return new Size(stackManipulation.apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -1431,13 +1431,13 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                                 new TextConstant(Nexus.class.getName()),
                                 MethodInvocation.invoke(NexusAccessor.INSTANCE.loadClass),
                                 new TextConstant("initialize"),
-                                ArrayFactory.forType(TypeDescription.CLASS)
+                                ArrayFactory.forType(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Class.class))
                                         .withValues(Arrays.asList(
                                                 ClassConstant.of(TypeDescription.CLASS),
                                                 ClassConstant.of(new TypeDescription.ForLoadedType(int.class)))),
                                 MethodInvocation.invoke(NexusAccessor.INSTANCE.getDeclaredMethod),
                                 NullConstant.INSTANCE,
-                                ArrayFactory.forType(TypeDescription.OBJECT)
+                                ArrayFactory.forType(TypeDescription.Generic.OBJECT)
                                         .withValues(Arrays.asList(
                                                 ClassConstant.of(instrumentedMethod.getDeclaringType().asErasure()),
                                                 new StackManipulation.Compound(

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -217,7 +217,7 @@ protected ByteCodeAppender.Size apply(MethodVisitor methodVisitor,
                                           MethodDescription instrumentedMethod,
                                           TypeDescription.Generic fixedValueType,
                                           StackManipulation valueLoadingInstruction) {
-        StackManipulation assignment = assigner.assign(fixedValueType.asErasure(), instrumentedMethod.getReturnType().asErasure(), typing);
+        StackManipulation assignment = assigner.assign(fixedValueType, instrumentedMethod.getReturnType(), typing);
         if (!assignment.isValid()) {
             throw new IllegalArgumentException("Cannot return value of type " + fixedValueType + " for " + instrumentedMethod);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -421,9 +421,7 @@ public Size apply(MethodVisitor methodVisitor,
                 StackManipulation.Size stackSize = new StackManipulation.Compound(
                         new StackManipulation.Compound(fieldLoading),
                         MethodInvocation.invoke(accessorMethod),
-                        assigner.assign(accessorMethod.getReturnType().asErasure(),
-                                instrumentedMethod.getReturnType().asErasure(),
-                                Assigner.Typing.DYNAMIC),
+                        assigner.assign(accessorMethod.getReturnType(), instrumentedMethod.getReturnType(), Assigner.Typing.DYNAMIC),
                         MethodReturn.returning(instrumentedMethod.getReturnType().asErasure())
                 ).apply(methodVisitor, implementationContext);
                 return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldValue.java
Patch:
@@ -98,9 +98,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                 ? StackManipulation.Trivial.INSTANCE
                                 : MethodVariableAccess.REFERENCE.loadOffset(0),
                         FieldAccess.forField(resolution.getFieldDescription()).getter(),
-                        assigner.assign(resolution.getFieldDescription().getType().asErasure(),
-                                target.getType().asErasure(),
-                                RuntimeType.Verifier.check(target))
+                        assigner.assign(resolution.getFieldDescription().getType(), target.getType(), RuntimeType.Verifier.check(target))
                 );
                 return stackManipulation.isValid()
                         ? new MethodDelegationBinder.ParameterBinding.Anonymous(stackManipulation)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/StubValue.java
Patch:
@@ -56,7 +56,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             StackManipulation stackManipulation = source.getReturnType().represents(void.class)
                     ? NullConstant.INSTANCE
                     : new StackManipulation.Compound(DefaultValue.of(source.getReturnType().asErasure()),
-                    assigner.assign(source.getReturnType().asErasure(), TypeDescription.OBJECT, Assigner.Typing.STATIC));
+                    assigner.assign(source.getReturnType(), TypeDescription.Generic.OBJECT, Assigner.Typing.STATIC));
             return stackManipulation.isValid()
                     ? new MethodDelegationBinder.ParameterBinding.Anonymous(stackManipulation)
                     : MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -286,9 +286,9 @@ enum Returning implements TerminationHandler {
             @Override
             public StackManipulation resolve(Assigner assigner, MethodDescription source, MethodDescription target) {
                 return new StackManipulation.Compound(assigner.assign(target.isConstructor()
-                                ? target.getDeclaringType().asErasure()
-                                : target.getReturnType().asErasure(),
-                        source.getReturnType().asErasure(),
+                                ? target.getDeclaringType().asGenericType()
+                                : target.getReturnType(),
+                        source.getReturnType(),
                         RuntimeType.Verifier.check(target)), MethodReturn.returning(source.getReturnType().asErasure()));
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/This.java
Patch:
@@ -72,7 +72,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             StackManipulation assignment = source.isStatic()
                     ? NullConstant.INSTANCE
                     : new StackManipulation.Compound(MethodVariableAccess.REFERENCE.loadOffset(THIS_REFERENCE_INDEX),
-                    assigner.assign(implementationTarget.getInstrumentedType(), target.getType().asErasure(), RuntimeType.Verifier.check(target)));
+                    assigner.assign(implementationTarget.getInstrumentedType().asGenericType(), target.getType(), RuntimeType.Verifier.check(target)));
             return assignment.isValid()
                     ? new MethodDelegationBinder.ParameterBinding.Anonymous(assignment)
                     : MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/collection/CollectionFactory.java
Patch:
@@ -16,7 +16,7 @@ public interface CollectionFactory {
      *
      * @return A type description of this factory's component type.
      */
-    TypeDescription getComponentType();
+    TypeDescription.Generic getComponentType();
 
     /**
      * Applies this collection factory in order to build a new collection where each element is represented by

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodConstant.java
Patch:
@@ -83,7 +83,8 @@ public boolean isValid() {
     public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
         return new Compound(
                 preparation(),
-                ArrayFactory.forType(TypeDescription.CLASS).withValues(typeConstantsFor(methodDescription.getParameters().asTypeList().asErasures())),
+                ArrayFactory.forType(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Class.class))
+                        .withValues(typeConstantsFor(methodDescription.getParameters().asTypeList().asErasures())),
                 MethodInvocation.invoke(accessorMethod())
         ).apply(methodVisitor, implementationContext);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -468,12 +468,12 @@ public enum ToStringAssigner implements Assigner {
         INSTANCE;
 
         @Override
-        public StackManipulation assign(TypeDescription sourceType, TypeDescription targetType, Typing typing) {
-            if (!sourceType.isPrimitive() && targetType.represents(String.class)) {
+        public StackManipulation assign(TypeDescription.Generic source, TypeDescription.Generic target, Typing typing) {
+            if (!source.isPrimitive() && target.represents(String.class)) {
                 MethodDescription toStringMethod = TypeDescription.OBJECT.getDeclaredMethods()
                         .filter(named("toString"))
                         .getOnly();
-                return MethodInvocation.invoke(toStringMethod).virtual(sourceType);
+                return MethodInvocation.invoke(toStringMethod).virtual(source.asErasure()); // TODO: Update tutorial
             } else {
                 return StackManipulation.Illegal.INSTANCE;
             }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodCallTest.java
Patch:
@@ -63,7 +63,7 @@ private static Object makeMethodHandle() throws Exception {
 
     @Before
     public void setUp() throws Exception {
-        when(nonAssigner.assign(Mockito.any(TypeDescription.class), Mockito.any(TypeDescription.class), Mockito.any(Assigner.Typing.class)))
+        when(nonAssigner.assign(Mockito.any(TypeDescription.Generic.class), Mockito.any(TypeDescription.Generic.class), Mockito.any(Assigner.Typing.class)))
                 .thenReturn(StackManipulation.Illegal.INSTANCE);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodCallTypeTest.java
Patch:
@@ -93,7 +93,7 @@ public static Collection<Object[]> data() {
 
     @Before
     public void setUp() throws Exception {
-        when(nonAssigner.assign(Mockito.any(TypeDescription.class), Mockito.any(TypeDescription.class), Mockito.any(Assigner.Typing.class)))
+        when(nonAssigner.assign(Mockito.any(TypeDescription.Generic.class), Mockito.any(TypeDescription.Generic.class), Mockito.any(Assigner.Typing.class)))
                 .thenReturn(StackManipulation.Illegal.INSTANCE);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ArgumentBinderTest.java
Patch:
@@ -25,7 +25,7 @@
 public class ArgumentBinderTest extends AbstractAnnotationBinderTest<Argument> {
 
     @Mock
-    private TypeDescription sourceType, targetType;
+    private TypeDescription sourceType, targetType; // TODO: Remove?
 
     @Mock
     private TypeDescription.Generic genericSourceType, genericTargetType;
@@ -110,7 +110,7 @@ private void assertBinding(boolean dynamicallyTyped,
         verify(source, atLeast(1)).getParameters();
         verify(target, atLeast(1)).getType();
         verify(target, atLeast(1)).getDeclaredAnnotations();
-        verify(assigner).assign(sourceType, targetType, Assigner.Typing.of(dynamicallyTyped));
+        verify(assigner).assign(genericSourceType, genericTargetType, Assigner.Typing.of(dynamicallyTyped));
         verifyNoMoreInteractions(assigner);
     }
 
@@ -152,6 +152,7 @@ public void testObjectProperties() throws Exception {
 
     }
 
+    @SuppressWarnings("unused")
     private static class Carrier {
 
         private void method(@Argument(0) Void parameter) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldValueBinderTest.java
Patch:
@@ -10,8 +10,6 @@
 import org.junit.Test;
 import org.mockito.Mock;
 
-import java.util.Collections;
-
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.doReturn;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinderTerminationHandlerReturningTest.java
Patch:
@@ -48,8 +48,8 @@ public void setUp() throws Exception {
         when(source.getReturnType()).thenReturn(genericSourceType);
         when(target.getReturnType()).thenReturn(genericTargetType);
         when(genericSourceType.asErasure()).thenReturn(sourceType);
-        when(genericTargetType.asErasure()).thenReturn(targetType);
-        when(assigner.assign(eq(targetType), eq(sourceType), any(Assigner.Typing.class))).thenReturn(stackManipulation);
+        when(genericTargetType.asErasure()).thenReturn(targetType); // TODO: remove?
+        when(assigner.assign(eq(genericTargetType), eq(genericSourceType), any(Assigner.Typing.class))).thenReturn(stackManipulation);
         when(target.getDeclaredAnnotations()).thenReturn(annotationList);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinderTest.java
Patch:
@@ -121,7 +121,7 @@ private static Iterator<AnnotationDescription> prepareDefaultProvider(TargetMeth
     public void setUp() throws Exception {
         when(assignmentBinding.apply(any(MethodVisitor.class), any(Implementation.Context.class)))
                 .thenReturn(new StackManipulation.Size(0, 0));
-        when(assigner.assign(any(TypeDescription.class), any(TypeDescription.class), any(Assigner.Typing.class)))
+        when(assigner.assign(any(TypeDescription.Generic.class), any(TypeDescription.Generic.class), any(Assigner.Typing.class)))
                 .thenReturn(assignmentBinding);
         when(methodInvoker.invoke(any(MethodDescription.class))).thenReturn(methodInvocation);
         when(methodInvocation.apply(any(MethodVisitor.class), any(Implementation.Context.class)))

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/AssignerRefusingTest.java
Patch:
@@ -29,7 +29,7 @@ public class AssignerRefusingTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private TypeDescription first, second;
+    private TypeDescription.Generic first, second;
 
     @Mock
     private MethodVisitor methodVisitor;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveBoxingDelegateTest.java
Patch:
@@ -43,7 +43,7 @@ public class PrimitiveBoxingDelegateTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private TypeDescription targetType;
+    private TypeDescription.Generic targetType;
 
     @Mock
     private Assigner chainedAssigner;
@@ -85,7 +85,7 @@ public static Collection<Object[]> data() {
 
     @Before
     public void setUp() throws Exception {
-        when(chainedAssigner.assign(any(TypeDescription.class), any(TypeDescription.class), any(Assigner.Typing.class)))
+        when(chainedAssigner.assign(any(TypeDescription.Generic.class), any(TypeDescription.Generic.class), any(Assigner.Typing.class)))
                 .thenReturn(stackManipulation);
         when(stackManipulation.isValid())
                 .thenReturn(true);
@@ -110,7 +110,7 @@ public void testBoxing() throws Exception {
         verify(primitiveTypeDescription).represents(primitiveType);
         verify(primitiveTypeDescription, atLeast(1)).represents(any(Class.class));
         verifyNoMoreInteractions(primitiveTypeDescription);
-        verify(chainedAssigner).assign(referenceTypeDescription, targetType, Assigner.Typing.STATIC);
+        verify(chainedAssigner).assign(referenceTypeDescription.asGenericType(), targetType, Assigner.Typing.STATIC);
         verifyNoMoreInteractions(chainedAssigner);
         verify(methodVisitor).visitMethodInsn(Opcodes.INVOKESTATIC,
                 referenceTypeDescription.getInternalName(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveTypeAwareAssignerBoxingTest.java
Patch:
@@ -32,7 +32,7 @@ public class PrimitiveTypeAwareAssignerBoxingTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private TypeDescription sourceTypeDescription, targetTypeDescription;
+    private TypeDescription.Generic sourceTypeDescription, targetTypeDescription;
 
     @Mock
     private Assigner chainedAssigner;
@@ -71,7 +71,7 @@ public void setUp() throws Exception {
         when(targetTypeDescription.represents(targetType)).thenReturn(true);
         when(targetTypeDescription.isPrimitive()).thenReturn(false);
         when(chainedStackManipulation.isValid()).thenReturn(true);
-        when(chainedAssigner.assign(any(TypeDescription.class), any(TypeDescription.class), any(Assigner.Typing.class)))
+        when(chainedAssigner.assign(any(TypeDescription.Generic.class), any(TypeDescription.Generic.class), any(Assigner.Typing.class)))
                 .thenReturn(chainedStackManipulation);
         primitiveAssigner = new PrimitiveTypeAwareAssigner(chainedAssigner);
     }
@@ -88,7 +88,7 @@ public void testBoxingAssignment() {
         verifyNoMoreInteractions(sourceTypeDescription);
         verify(targetTypeDescription, atLeast(1)).isPrimitive();
         verifyNoMoreInteractions(targetTypeDescription);
-        verify(chainedAssigner).assign(new TypeDescription.ForLoadedType(targetType), targetTypeDescription, Assigner.Typing.STATIC);
+        verify(chainedAssigner).assign(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(targetType), targetTypeDescription, Assigner.Typing.STATIC);
         verifyNoMoreInteractions(chainedAssigner);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveTypeAwareAssignerPrimitiveTest.java
Patch:
@@ -32,7 +32,7 @@ public class PrimitiveTypeAwareAssignerPrimitiveTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private TypeDescription sourceTypeDescription, targetTypeDescription;
+    private TypeDescription.Generic sourceTypeDescription, targetTypeDescription;
 
     @Mock
     private Assigner chainedAssigner;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveTypeAwareAssignerUnboxingTest.java
Patch:
@@ -32,7 +32,7 @@ public class PrimitiveTypeAwareAssignerUnboxingTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private TypeDescription sourceTypeDescription, targetTypeDescription;
+    private TypeDescription.Generic sourceTypeDescription, targetTypeDescription;
 
     @Mock
     private Assigner chainedAssigner;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveUnboxingDelegateOtherTest.java
Patch:
@@ -8,12 +8,12 @@ public class PrimitiveUnboxingDelegateOtherTest {
 
     @Test(expected = IllegalArgumentException.class)
     public void testIllegalSourceTypeThrowsException() throws Exception {
-        PrimitiveUnboxingDelegate.forReferenceType(new TypeDescription.ForLoadedType(int.class));
+        PrimitiveUnboxingDelegate.forReferenceType(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(int.class));
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void testVoidIllegal() throws Exception {
-        PrimitiveUnboxingDelegate.forPrimitive(TypeDescription.VOID);
+        PrimitiveUnboxingDelegate.forPrimitive(TypeDescription.Generic.VOID);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveUnboxingDelegateWideningTest.java
Patch:
@@ -45,7 +45,7 @@ public class PrimitiveUnboxingDelegateWideningTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private TypeDescription referenceTypeDescription, primitiveTypeDescription;
+    private TypeDescription.Generic referenceTypeDescription, primitiveTypeDescription;
 
     @Mock
     private Assigner chainedAssigner;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/VoidAwareAssignerTest.java
Patch:
@@ -23,7 +23,7 @@ public class VoidAwareAssignerTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private TypeDescription sourceTypeDescription, targetTypeDescription;
+    private TypeDescription.Generic sourceTypeDescription, targetTypeDescription;
 
     @Mock
     private Assigner chainedAssigner;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationGenericTest.java
Patch:
@@ -73,6 +73,7 @@ public void testGenericMethodErasureEqual() throws Exception {
     public void testGenericMethodVirtual() throws Exception {
         TypeDescription genericErasure = mock(TypeDescription.class);
         when(methodReturnType.asErasure()).thenReturn(genericErasure);
+        when(genericErasure.asErasure()).thenReturn(genericErasure);
         StackManipulation stackManipulation = MethodInvocation.invoke(methodDescription).virtual(targetType);
         assertThat(stackManipulation.isValid(), is(true));
         assertThat(stackManipulation, is((StackManipulation) new StackManipulation.Compound(MethodInvocation.invoke(declaredMethod).virtual(targetType),
@@ -91,6 +92,7 @@ public void testGenericMethodVirtualErasureEqual() throws Exception {
     public void testGenericMethodSpecial() throws Exception {
         TypeDescription genericErasure = mock(TypeDescription.class);
         when(methodReturnType.asErasure()).thenReturn(genericErasure);
+        when(genericErasure.asErasure()).thenReturn(genericErasure);
         StackManipulation stackManipulation = MethodInvocation.invoke(methodDescription).special(targetType);
         assertThat(stackManipulation.isValid(), is(true));
         assertThat(stackManipulation, is((StackManipulation) new StackManipulation.Compound(MethodInvocation.invoke(declaredMethod).special(targetType),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -72,9 +72,7 @@ public RebaseDynamicTypeBuilder(InstrumentedType.WithFlexibleName instrumentedTy
         this(instrumentedType,
                 new FieldRegistry.Default(),
                 new MethodRegistry.Default(),
-                annotationRetention.isEnabled()
-                        ? new TypeAttributeAppender.ForInstrumentedType.Excluding(originalType)
-                        : TypeAttributeAppender.ForInstrumentedType.INSTANCE,
+                new TypeAttributeAppender.ForInstrumentedType.Excluding(originalType),
                 AsmVisitorWrapper.NoOp.INSTANCE,
                 classFileVersion,
                 auxiliaryTypeNamingStrategy,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -59,9 +59,7 @@ public RedefinitionDynamicTypeBuilder(InstrumentedType.WithFlexibleName instrume
         this(instrumentedType,
                 new FieldRegistry.Default(),
                 new MethodRegistry.Default(),
-                annotationRetention.isEnabled()
-                        ? new TypeAttributeAppender.ForInstrumentedType.Excluding(originalType)
-                        : TypeAttributeAppender.ForInstrumentedType.INSTANCE,
+                new TypeAttributeAppender.ForInstrumentedType.Excluding(originalType),
                 AsmVisitorWrapper.NoOp.INSTANCE,
                 classFileVersion,
                 auxiliaryTypeNamingStrategy,

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -1665,7 +1665,7 @@ public int hashCode() {
                                 @Override
                                 public String toString() {
                                     return "TypeDescription.Generic.Visitor.Assigner.Dispatcher.ForParameterizedType.ParameterAssigner.ContravariantBinding{" +
-                                            "typeDescription=" + lowerBound +
+                                            "lowerBound=" + lowerBound +
                                             '}';
                                 }
                             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -868,7 +868,7 @@ public TypeDescription validated() {
                     }
                 } else if (!methodDescription.getReturnType().accept(Generic.Visitor.Validator.METHOD_RETURN)) {
                     throw new IllegalStateException("Illegal return type " + methodDescription.getReturnType() + " for " + methodDescription);
-                } else if (isValidIdentifier(methodDescription.getInternalName())) {
+                } else if (!isValidIdentifier(methodDescription.getInternalName())) {
                     throw new IllegalStateException("Illegal method name for: " + methodDescription);
                 }
                 Set<String> parameterNames = new HashSet<String>();
@@ -918,6 +918,8 @@ private static boolean isValidIdentifier(String[] name) {
         private static boolean isValidIdentifier(String name) {
             if (name.isEmpty() || !Character.isJavaIdentifierStart(name.charAt(0))) {
                 return false;
+            } else if (name.equals(PackageDescription.PACKAGE_CLASS_NAME)) {
+                return true;
             }
             for (int index = 1; index < name.length(); index++) {
                 if (!Character.isJavaIdentifierPart(name.charAt(index))) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/AbstractDynamicTypeBuilderForInliningTest.java
Patch:
@@ -66,6 +66,7 @@ public abstract class AbstractDynamicTypeBuilderForInliningTest extends Abstract
 
     @Before
     public void setUp() throws Exception {
+        super.setUp();
         typePool = TypePool.Default.ofClassPath();
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -1624,14 +1624,14 @@ public String toString() {
                             protected static class ContravariantBinding implements Dispatcher {
 
                                 /**
-                                 * The lower bound type of a contracariant parameter.
+                                 * The lower bound type of a contravariant parameter.
                                  */
                                 private final Generic lowerBound;
 
                                 /**
-                                 * Creates a new dispatcher for contracariant parameter of a parameterized type.
+                                 * Creates a new dispatcher for contravariant parameter of a parameterized type.
                                  *
-                                 * @param lowerBound The lower bound type of a contracariant parameter.
+                                 * @param lowerBound The lower bound type of a contravariant parameter.
                                  */
                                 protected ContravariantBinding(Generic lowerBound) {
                                     this.lowerBound = lowerBound;

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorAssignerTest.java
Patch:
@@ -348,7 +348,7 @@ public void testAssignParameterizedWildcardTypeFromNonAssignableParameterizedTyp
     @Test
     public void testAssignParameterizedWildcardTypeFromNonAssignableGenericArrayType() throws Exception {
         assertThat(collectionWildcard.accept(TypeDescription.Generic.Visitor.Assigner.INSTANCE)
-                .isAssignableFrom(arrayListWildcard), is(false));
+                .isAssignableFrom(tArray), is(false));
     }
 
     @Test
@@ -386,7 +386,6 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(TypeDescription.Generic.Visitor.Assigner.Dispatcher.ForParameterizedType.class).apply();
         ObjectPropertyAssertion.of(TypeDescription.Generic.Visitor.Assigner.Dispatcher.ForParameterizedType.ParameterAssigner.class).apply();
         ObjectPropertyAssertion.of(TypeDescription.Generic.Visitor.Assigner.Dispatcher.ForParameterizedType.ParameterAssigner.InvariantBinding.class).apply();
-        ObjectPropertyAssertion.of(TypeDescription.Generic.Visitor.Assigner.Dispatcher.ForParameterizedType.ParameterAssigner.CovariantBinding.class).apply();
         ObjectPropertyAssertion.of(TypeDescription.Generic.Visitor.Assigner.Dispatcher.ForParameterizedType.ParameterAssigner.ContravariantBinding.class).apply();
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -1207,7 +1207,7 @@ public String toString() {
                 }
 
                 /**
-                 * A dispatcher that allows if a type is assignable
+                 * A dispatcher that allows to check if the visited generic type is assignable to the supplied type.
                  */
                 public interface Dispatcher {
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericVisitorSubstitutorForDetachmentTest.java
Patch:
@@ -48,7 +48,7 @@ public void testDetachedNoSource() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(TypeDescription.Generic.Visitor.Substitutor.ForDetachment.class).applyBasic();
+        ObjectPropertyAssertion.of(TypeDescription.Generic.Visitor.Substitutor.ForDetachment.class).apply();
     }
 
     @SuppressWarnings("unused")

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDefinition.java
Patch:
@@ -154,7 +154,8 @@ enum Sort {
         VARIABLE,
 
         /**
-         * Represents a type variable that is merely symbolic and is not attached to a {@link TypeVariableSource} and does not defined bounds.
+         * Represents a type variable that is merely symbolic and is not attached to a {@link net.bytebuddy.description.TypeVariableSource}
+         * and does not defined bounds.
          */
         VARIABLE_SYMBOLIC;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -928,7 +928,7 @@ public Generic onTypeVariable(Generic typeVariable) {
 
                     @Override
                     protected Generic onSimpleType(Generic typeDescription) {
-                        return typeDescription.equals(TargetType.DESCRIPTION)
+                        return typeDescription.represents(TargetType.class)
                                 ? declaringType
                                 : typeDescription;
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -46,7 +46,6 @@
 import static net.bytebuddy.matcher.ElementMatchers.*;
 
 /**
- * <p>
  * Instances of this class serve as a focus point for configuration of the library's behavior and as an entry point
  * to any form of code generation using the library. For this purpose, Byte Buddy offers a fluent API which allows
  * for the step-wise generation of a new Java type. A type is generated either by:
@@ -71,7 +70,6 @@
  * Instead, the following method chain is corrent use of the API:
  * <pre>
  * ByteBuddy byteBuddy = new ByteBuddy().foo();</pre>
- * </p>
  * <p>
  * For the creation of Java agents, Byte Buddy offers a convenience API implemented by the
  * {@link net.bytebuddy.agent.builder.AgentBuilder}. The API wraps a {@link ByteBuddy} instance and offers agent-specific

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterList.java
Patch:
@@ -33,7 +33,7 @@ public interface ParameterList<T extends ParameterDescription> extends Filterabl
      * Transforms the list of parameter descriptions into a list of detached tokens. All types that are matched by the provided
      * target type matcher are substituted by {@link net.bytebuddy.dynamic.TargetType}.
      *
-     * @param targetTypeMatcher A matcher that indicates type substitution.
+     * @param matcher A matcher that indicates type substitution.
      * @return The transformed token list.
      */
     ByteCodeElement.Token.TokenList<ParameterDescription.Token> asTokenList(ElementMatcher<? super TypeDescription> matcher);

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -220,7 +220,7 @@ interface Generic extends FilterableList<TypeDescription.Generic, Generic> {
          * @param visitor The visitor to apply to each type.
          * @return A list of the types returned by the supplied visitor.
          */
-        Generic accept(TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> matcher);
+        Generic accept(TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor);
 
         /**
          * Returns the sum of the size of all types contained in this list.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeVariableToken.java
Patch:
@@ -46,7 +46,7 @@ public TypeVariableToken(String symbol, List<? extends TypeDescription.Generic>
      * Transforms a type variable into a type variable token with its bounds detached.
      *
      * @param typeVariable A type variable in its attached state.
-     * @param visitor      A visitor for detaching the type variable's upper bounds.
+     * @param matcher      A matcher that identifies types to detach from the upper bound types.
      * @return A token representing the detached type variable.
      */
     public static TypeVariableToken of(TypeDescription.Generic typeVariable, ElementMatcher<? super TypeDescription> matcher) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodRegistry.java
Patch:
@@ -521,7 +521,7 @@ public MethodRegistry.Prepared prepare(InstrumentedType instrumentedType,
             return new Prepared(implementations,
                     instrumentedType.getLoadedTypeInitializer(),
                     instrumentedType.getTypeInitializer(),
-                    instrumentedType.asErasure(),
+                    instrumentedType.validated(),
                     methodGraph);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTarget.java
Patch:
@@ -46,7 +46,6 @@ protected RebaseImplementationTarget(TypeDescription instrumentedType,
      *
      * @param instrumentedType     The instrumented type.
      * @param methodGraph          A method graph of the instrumented type.
-     * @param rebaseableMethods    A list of methods that can be considered for rebasing.
      * @param methodRebaseResolver A method rebase resolver to be used when calling a rebased method.
      * @return An implementation target for the given input.
      */

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTargetTest.java
Patch:
@@ -19,6 +19,8 @@
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
+import java.util.Collections;
+
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.*;
@@ -63,7 +65,7 @@ public void setUp() throws Exception {
         when(rebasedMethod.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
         when(rebasedMethod.getDeclaringType()).thenReturn(instrumentedType);
         when(rebasedMethod.asSignatureToken()).thenReturn(rebasedSignatureToken);
-        when(methodRebaseResolver.resolve(rebasedMethod)).thenReturn(resolution);
+        when(methodRebaseResolver.asTokenMap()).thenReturn(Collections.singletonMap(rebasedSignatureToken, resolution));
         super.setUp();
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolver.java
Patch:
@@ -474,7 +474,7 @@ public static MethodRebaseResolver make(TypeDescription instrumentedType,
             DynamicType placeholderType = null;
             Map<MethodDescription.InDefinedShape, Resolution> resolutions = new HashMap<MethodDescription.InDefinedShape, Resolution>();
             for (MethodDescription.InDefinedShape instrumentedMethod : instrumentedType.getDeclaredMethods()) {
-                if (rebaseableMethods.contains(instrumentedMethod.asToken(is(instrumentedMethod)))) {
+                if (rebaseableMethods.contains(instrumentedMethod.asToken(is(instrumentedType)))) {
                     Resolution resolution;
                     if (instrumentedMethod.isConstructor()) {
                         if (placeholderType == null) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -16,7 +16,6 @@
 import net.bytebuddy.matcher.LatentMatcher;
 
 import static net.bytebuddy.matcher.ElementMatchers.anyOf;
-import static net.bytebuddy.matcher.ElementMatchers.methodRepresentedBy;
 
 /**
  * A type builder that rebases an instrumented type.
@@ -171,7 +170,7 @@ public DynamicType.Unloaded<T> make() {
                 InliningImplementationMatcher.of(ignoredMethods, originalType));
         MethodList<MethodDescription.InDefinedShape> rebaseableMethods = preparedMethodRegistry.getInstrumentedMethods()
                 .asDefined()
-                .filter(methodRepresentedBy(anyOf(originalType.getDeclaredMethods().asTokenList())));
+                .filter(anyOf(originalType.getDeclaredMethods()));
         MethodRebaseResolver methodRebaseResolver = MethodRebaseResolver.Default.make(preparedMethodRegistry.getInstrumentedType(),
                 rebaseableMethods,
                 classFileVersion,

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/ByteCodeElement.java
Patch:
@@ -83,7 +83,7 @@ interface TypeDependant<T extends TypeDependant<?, S>, S extends ByteCodeElement
          * @param targetTypeMatcher A matcher to identify types to be replaced by {@link net.bytebuddy.dynamic.TargetType} descriptions.
          * @return A token representative of this type dependant.
          */
-        S asToken(ElementMatcher<? super TypeDescription> targetTypeMatcher);
+        S asToken(ElementMatcher<? super TypeDescription.Generic> targetTypeMatcher);
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -113,10 +113,10 @@ public FieldDescription.Token asToken() {
         }
 
         @Override
-        public FieldDescription.Token asToken(ElementMatcher<? super TypeDescription> targetTypeMatcher) {
+        public FieldDescription.Token asToken(ElementMatcher<? super TypeDescription.Generic> matcher) {
             return new FieldDescription.Token(getName(),
                     getModifiers(),
-                    getType().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(targetTypeMatcher)),
+                    getType().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)),
                     getDeclaredAnnotations());
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -151,8 +151,8 @@ public Token asToken() {
         }
 
         @Override
-        public Token asToken(ElementMatcher<? super TypeDescription> targetTypeMatcher) {
-            return new Token(getType().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(targetTypeMatcher)),
+        public Token asToken(ElementMatcher<? super TypeDescription.Generic> matcher) {
+            return new Token(getType().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)),
                     getDeclaredAnnotations(),
                     isNamed()
                             ? getName()

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeInitializer.java
Patch:
@@ -67,7 +67,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
 
         @Override
         public String toString() {
-            return "InstrumentedType.TypeInitializer.None." + name();
+            return "TypeInitializer.None." + name();
         }
     }
 
@@ -123,7 +123,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return "InstrumentedType.TypeInitializer.Simple{" +
+            return "TypeInitializer.Simple{" +
                     "byteCodeAppender=" + byteCodeAppender +
                     '}';
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeInitializerTest.java
Patch:
@@ -58,8 +58,7 @@ public void testNoneThrowsExceptionOnTermination() throws Exception {
     @Test
     public void testSimpleExpansion() throws Exception {
         assertThat(new TypeInitializer.Simple(byteCodeAppender).expandWith(byteCodeAppender),
-                is((TypeInitializer) new TypeInitializer
-                        .Simple(new ByteCodeAppender.Compound(byteCodeAppender, byteCodeAppender))));
+                is((TypeInitializer) new TypeInitializer.Simple(new ByteCodeAppender.Compound(byteCodeAppender, byteCodeAppender))));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/LatentMatcherCompoundTest.java
Patch:
@@ -39,7 +39,7 @@ public void setUp() throws Exception {
     @SuppressWarnings("unchecked")
     public void testManifestation() throws Exception {
         assertThat(new LatentMatcher.Compound(left, right).resolve(instrumentedType),
-                is((ElementMatcher) none().and((ElementMatcher) leftMatcher).and((ElementMatcher) rightMatcher)));
+                is((ElementMatcher) none().or((ElementMatcher) leftMatcher).or((ElementMatcher) rightMatcher)));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/MethodTransformer.java
Patch:
@@ -15,12 +15,13 @@
 /**
  * A method transformer allows to transform a method prior to its definition. This way, previously defined methods
  * can be substituted by a different method description. It is the responsibility of the method transformer that
- * the substitute method remains signature compatible to the substituted method.
+ * the substitute method remains compatible to the substituted method.
  */
 public interface MethodTransformer {
 
     /**
-     * Transforms a method.
+     * Transforms a method. The transformed method is <b>not</b> validated by Byte Buddy and it is the responsibility
+     * of the transformer to assure the validity of the transformation.
      *
      * @param instrumentedType  The instrumented type.
      * @param methodDescription The method to be transformed.

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/MethodTransformerSimpleTest.java
Patch:
@@ -113,13 +113,15 @@ public void testSimpleTransformation() throws Exception {
         assertThat(transformed.getTypeVariables().getOnly().getSymbol(), is(QUX));
         assertThat(transformed.getExceptionTypes().size(), is(1));
         assertThat(transformed.getExceptionTypes().getOnly(), is(exceptionType));
+        assertThat(transformed.getDeclaredAnnotations(), is(Collections.singletonList(methodAnnotation)));
         assertThat(transformed.getParameters().size(), is(1));
         assertThat(transformed.getParameters().getOnly().getType(), is(parameterType));
         assertThat(transformed.getParameters().getOnly().getName(), is(BAR));
         assertThat(transformed.getParameters().getOnly().getModifiers(), is(MODIFIERS * 2));
         assertThat(transformed.getParameters().getOnly().getDeclaredAnnotations().size(), is(1));
         assertThat(transformed.getParameters().getOnly().getDeclaredAnnotations().getOnly(), is(parameterAnnotation));
         assertThat(transformed.getParameters().getOnly().asDefined(), is(definedParameter));
+        assertThat(transformed.getParameters().getOnly().getDeclaredAnnotations(), is(Collections.singletonList(parameterAnnotation)));
         assertThat(transformed.getParameters().getOnly().getDeclaringMethod(), is(transformed));
         assertThat(transformed.asDefined(), is(definedMethod));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/AbstractDynamicTypeBuilderForInliningTest.java
Patch:
@@ -82,7 +82,7 @@ public void tearDown() throws Exception {
 
     protected abstract DynamicType.Builder<?> createDisabledContext();
 
-    protected abstract DynamicType.Builder createDisabledRetention(Class<?> annotatedClass);
+    protected abstract DynamicType.Builder<?> createDisabledRetention(Class<?> annotatedClass);
 
     @Test
     public void testTypeInitializerRetention() throws Exception {
@@ -416,7 +416,6 @@ public void testDisabledAnnotationRetention() throws Exception {
     }
 
     @Test
-    @SuppressWarnings("unchecked")
     public void testEnabledAnnotationRetention() throws Exception {
         Class<?> type = create(Annotated.class)
                 .field(ElementMatchers.any()).annotateField(new Annotation[0])
@@ -429,12 +428,13 @@ public void testEnabledAnnotationRetention() throws Exception {
                         ByteArrayClassLoader.PersistenceHandler.LATENT,
                         PackageDefinitionStrategy.NoOp.INSTANCE), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
+        @SuppressWarnings("unchecked")
         Class<? extends Annotation> sampleAnnotation = (Class<? extends Annotation>) type.getClassLoader().loadClass(SampleAnnotation.class.getName());
         assertThat(type.isAnnotationPresent(sampleAnnotation), is(true));
         assertThat(type.getDeclaredField(FOO).isAnnotationPresent(sampleAnnotation), is(true));
         assertThat(type.getDeclaredMethod(FOO, Void.class).isAnnotationPresent(sampleAnnotation), is(true));
         assertThat(type.getDeclaredMethod(FOO, Void.class).getParameterAnnotations()[0].length, is(1));
-        assertThat(type.getDeclaredMethod(FOO, Void.class).getParameterAnnotations()[0][0].annotationType(), equalTo((Class) sampleAnnotation));
+        assertThat(type.getDeclaredMethod(FOO, Void.class).getParameterAnnotations()[0][0].annotationType(), is((Object) sampleAnnotation));
     }
 
     public @interface Baz {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldList.java
Patch:
@@ -8,7 +8,6 @@
 import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 
 import static net.bytebuddy.matcher.ElementMatchers.none;
@@ -262,12 +261,12 @@ class Empty<S extends FieldDescription> extends FilterableList.Empty<S, FieldLis
 
         @Override
         public ByteCodeElement.Token.TokenList<FieldDescription.Token> asTokenList() {
-            return new ByteCodeElement.Token.TokenList<FieldDescription.Token>(Collections.<FieldDescription.Token>emptyList());
+            return new ByteCodeElement.Token.TokenList<FieldDescription.Token>();
         }
 
         @Override
         public ByteCodeElement.Token.TokenList<FieldDescription.Token> asTokenList(ElementMatcher<? super TypeDescription> targetTypeMatcher) {
-            return new ByteCodeElement.Token.TokenList<FieldDescription.Token>(Collections.<FieldDescription.Token>emptyList());
+            return new ByteCodeElement.Token.TokenList<FieldDescription.Token>();
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodList.java
Patch:
@@ -9,7 +9,6 @@
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 
 import static net.bytebuddy.matcher.ElementMatchers.none;
@@ -286,12 +285,12 @@ class Empty<S extends MethodDescription> extends FilterableList.Empty<S, MethodL
 
         @Override
         public ByteCodeElement.Token.TokenList<MethodDescription.Token> asTokenList() {
-            return new ByteCodeElement.Token.TokenList<MethodDescription.Token>(Collections.<MethodDescription.Token>emptyList());
+            return new ByteCodeElement.Token.TokenList<MethodDescription.Token>();
         }
 
         @Override
         public ByteCodeElement.Token.TokenList<MethodDescription.Token> asTokenList(ElementMatcher<? super TypeDescription> targetTypeMatcher) {
-            return new ByteCodeElement.Token.TokenList<MethodDescription.Token>(Collections.<MethodDescription.Token>emptyList());
+            return new ByteCodeElement.Token.TokenList<MethodDescription.Token>();
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterList.java
Patch:
@@ -13,7 +13,6 @@
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 
 import static net.bytebuddy.matcher.ElementMatchers.none;
@@ -619,12 +618,12 @@ public TypeList.Generic asTypeList() {
 
         @Override
         public ByteCodeElement.Token.TokenList<ParameterDescription.Token> asTokenList() {
-            return new ByteCodeElement.Token.TokenList<ParameterDescription.Token>(Collections.<ParameterDescription.Token>emptyList());
+            return new ByteCodeElement.Token.TokenList<ParameterDescription.Token>();
         }
 
         @Override
         public ByteCodeElement.Token.TokenList<ParameterDescription.Token> asTokenList(ElementMatcher<? super TypeDescription> targetTypeMatcher) {
-            return new ByteCodeElement.Token.TokenList<ParameterDescription.Token>(Collections.<ParameterDescription.Token>emptyList());
+            return new ByteCodeElement.Token.TokenList<ParameterDescription.Token>();
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -3860,4 +3860,5 @@ public String getName() {
             return packageDescription.getName() + "." + PackageDescription.PACKAGE_CLASS_NAME;
         }
     }
+
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/MethodTransformer.java
Patch:
@@ -203,7 +203,7 @@ protected TransformedMethod(TypeDefinition declaringType,
 
             @Override
             public TypeList.Generic getTypeVariables() {
-                return TypeList.Generic.ForDetachedTypes.attach(this, token.getTypeVariables());
+                return TypeList.Generic.ForDetachedTypes.attachVariables(this, token.getTypeVariables());
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -10,7 +10,7 @@
 import net.bytebuddy.description.modifier.Visibility;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.TypeVariableToken;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
@@ -197,7 +197,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
             MethodDescription callMethod = new MethodDescription.Latent(new TypeDescription.ForLoadedType(Callable.class),
                     "call",
                     Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
-                    Collections.<String, TypeList.Generic>emptyMap(),
+                    Collections.<TypeVariableToken>emptyList(),
                     TypeDescription.Generic.OBJECT,
                     Collections.<ParameterDescription.Token>emptyList(),
                     Collections.singletonList(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Exception.class)),
@@ -207,7 +207,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
             MethodDescription runMethod = new MethodDescription.Latent(new TypeDescription.ForLoadedType(Runnable.class),
                     "run",
                     Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
-                    Collections.<String, TypeList.Generic>emptyMap(),
+                    Collections.<TypeVariableToken>emptyList(),
                     TypeDescription.Generic.VOID,
                     Collections.<ParameterDescription.Token>emptyList(),
                     Collections.<TypeDescription.Generic>emptyList(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AbstractAnnotationDescriptionTest.java
Patch:
@@ -4,7 +4,7 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.TypeVariableToken;
 import net.bytebuddy.utility.PropertyDispatcher;
 import org.hamcrest.CoreMatchers;
 import org.junit.Before;
@@ -396,7 +396,7 @@ private void assertValue(Annotation annotation, String methodName, Object rawVal
         assertThat(describe(annotation).getValue(new MethodDescription.Latent(new TypeDescription.ForLoadedType(annotation.annotationType()),
                 methodName,
                 Opcodes.ACC_PUBLIC,
-                Collections.<String, TypeList.Generic>emptyMap(),
+                Collections.<TypeVariableToken>emptyList(),
                 new TypeDescription.Generic.OfNonGenericType.ForLoadedType(annotation.annotationType().getDeclaredMethod(methodName).getReturnType()),
                 Collections.<ParameterDescription.Token>emptyList(),
                 Collections.<TypeDescription.Generic>emptyList(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -10,7 +10,7 @@
 import net.bytebuddy.description.modifier.TypeManifestation;
 import net.bytebuddy.description.modifier.Visibility;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.TypeVariableToken;
 import net.bytebuddy.dynamic.loading.ByteArrayClassLoader;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.dynamic.loading.PackageDefinitionStrategy;
@@ -431,7 +431,7 @@ private static class PreparedMethod implements Implementation {
         public InstrumentedType prepare(InstrumentedType instrumentedType) {
             return instrumentedType.withMethod(new MethodDescription.Token(FOO,
                     MODIFIERS,
-                    Collections.<String, TypeList.Generic>emptyMap(),
+                    Collections.<TypeVariableToken>emptyList(),
                     TypeDescription.Generic.OBJECT,
                     Collections.singletonList(new ParameterDescription.Token(TypeDescription.Generic.OBJECT,
                             Collections.singletonList(AnnotationDescription.Builder.forType(SampleAnnotation.class).define(FOO, QUX).make()))),

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeTest.java
Patch:
@@ -5,7 +5,7 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.TypeVariableToken;
 import net.bytebuddy.dynamic.TargetType;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.LoadedTypeInitializer;
@@ -44,7 +44,7 @@ protected static InstrumentedType makePlainInstrumentedType() {
         return new InstrumentedType.Default(FOO + "." + BAZ,
                 Opcodes.ACC_PUBLIC,
                 TypeDescription.Generic.OBJECT,
-                Collections.<String, TypeList.Generic>emptyMap(),
+                Collections.<TypeVariableToken>emptyList(),
                 Collections.<TypeDescription.Generic>singletonList(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Serializable.class)),
                 Collections.<FieldDescription.Token>emptyList(),
                 Collections.<MethodDescription.Token>emptyList(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultTest.java
Patch:
@@ -4,7 +4,7 @@
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.TypeVariableToken;
 import net.bytebuddy.implementation.LoadedTypeInitializer;
 import net.bytebuddy.matcher.ElementMatchers;
 import net.bytebuddy.test.utility.JavaVersionRule;
@@ -912,7 +912,7 @@ public void testOrphanedBridge() throws Exception {
         TypeDescription typeDescription = new InstrumentedType.Default("foo",
                 Opcodes.ACC_PUBLIC,
                 TypeDescription.Generic.OBJECT,
-                Collections.<String, TypeList.Generic>emptyMap(),
+                Collections.<TypeVariableToken>emptyList(),
                 Collections.<TypeDescription.Generic>emptyList(),
                 Collections.<FieldDescription.Token>emptyList(),
                 Collections.singletonList(new MethodDescription.Token("foo",

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterFieldPoolRecordTest.java
Patch:
@@ -120,8 +120,6 @@ public void testExplicitFieldEntryWritesFieldPartialApplication() throws Excepti
     @Test
     public void testImplicitFieldEntryProperties() throws Exception {
         TypeWriter.FieldPool.Record record = new TypeWriter.FieldPool.Record.ForImplicitField(fieldDescription);
-        assertThat(record.getFieldAppender(), is((FieldAttributeAppender) FieldAttributeAppender.ForInstrumentedField.INSTANCE));
-        assertThat(record.resolveDefault(defaultValue), is(defaultValue));
         assertThat(record.isImplicit(), is(true));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderInitializationStrategySelfInjectionDispatcherTest.java
Patch:
@@ -197,6 +197,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(AgentBuilder.InitializationStrategy.SelfInjection.Dispatcher.Lazy.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.InitializationStrategy.SelfInjection.Dispatcher.Eager.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.InitializationStrategy.SelfInjection.Dispatcher.Split.class).apply();
+        ObjectPropertyAssertion.of(AgentBuilder.InitializationStrategy.SelfInjection.Dispatcher.InjectingInitializer.class).apply();
     }
 
     private static class Foo {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/AuxiliaryType.java
Patch:
@@ -176,7 +176,7 @@ public String toString() {
         }
     }
 
-    @Retention(RetentionPolicy.RUNTIME)
+    @Retention(RetentionPolicy.SOURCE)
     @Target(ElementType.TYPE)
     @interface Eager {
         /* empty */

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TypeProxy.java
Patch:
@@ -3,6 +3,7 @@
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.ClassFileVersion;
+import net.bytebuddy.asm.AsmVisitorWrapper;
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.modifier.Ownership;
@@ -18,6 +19,7 @@
 import net.bytebuddy.implementation.bytecode.member.MethodReturn;
 import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
 import net.bytebuddy.matcher.ElementMatchers;
+import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
@@ -101,7 +103,7 @@ public DynamicType make(String auxiliaryTypeName,
                 .modifiers(DEFAULT_TYPE_MODIFIER)
                 .implement(serializableProxy ? new Class<?>[]{Serializable.class} : new Class<?>[0])
                 .method(any()).intercept(new MethodCall(methodAccessorFactory))
-                .defineMethod(REFLECTION_METHOD, TargetType.DESCRIPTION, Ownership.STATIC).intercept(SilentConstruction.INSTANCE)
+                .defineMethod(REFLECTION_METHOD, TargetType.class, Ownership.STATIC).intercept(SilentConstruction.INSTANCE)
                 .make();
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -238,7 +238,7 @@ public void testMethodTransformation() throws Exception {
     @Test
     public void testIgnoredMethod() throws Exception {
         Class<?> type = createPlain()
-                .ignore(named(TO_STRING))
+                .ignoreAlso(named(TO_STRING))
                 .method(named(TO_STRING)).intercept(new Implementation.Simple(new TextConstant(FOO), MethodReturn.REFERENCE))
                 .make()
                 .load(new URLClassLoader(new URL[0], null), ClassLoadingStrategy.Default.WRAPPER)
@@ -249,7 +249,7 @@ public void testIgnoredMethod() throws Exception {
     @Test
     public void testIgnoredMethodDoesNotApplyForDefined() throws Exception {
         Class<?> type = createPlain()
-                .ignore(named(FOO))
+                .ignoreAlso(named(FOO))
                 .defineMethod(FOO, String.class, Visibility.PUBLIC)
                 .intercept(new Implementation.Simple(new TextConstant(FOO), MethodReturn.REFERENCE))
                 .make()

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolver.java
Patch:
@@ -602,7 +602,7 @@ public static MethodRebaseResolver make(TypeDescription instrumentedType,
                 Resolution resolution;
                 if (instrumentedMethod.isConstructor()) {
                     if (placeholderType == null) {
-                        placeholderType = TrivialType.INSTANCE.make(auxiliaryTypeNamingStrategy.name(instrumentedType),
+                        placeholderType = TrivialType.EAGER.make(auxiliaryTypeNamingStrategy.name(instrumentedType),
                                 classFileVersion,
                                 AuxiliaryType.MethodAccessorFactory.Illegal.INSTANCE);
                     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TrivialTypeTest.java
Patch:
@@ -30,7 +30,7 @@ public class TrivialTypeTest {
     @Test
     public void testCreation() throws Exception {
         when(classFileVersion.getMinorMajorVersion()).thenReturn(ClassFileVersion.JAVA_V5.getMinorMajorVersion());
-        DynamicType dynamicType = TrivialType.INSTANCE.make(FOO, classFileVersion, methodAccessorFactory);
+        DynamicType dynamicType = TrivialType.PLAIN.make(FOO, classFileVersion, methodAccessorFactory); // TODO: Test eager with annotation
         assertThat(dynamicType.getTypeDescription().getName(), is(FOO));
         assertThat(dynamicType.getTypeDescription().getModifiers(), is(Opcodes.ACC_SYNTHETIC));
         assertThat(dynamicType.getAuxiliaryTypes().size(), is(0));

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -1915,6 +1915,7 @@ public Builder define(String property, TypeDescription typeDescription) {
          * @param <T>             The enumeration type.
          * @return A builder with the additional class property.
          */
+        @SuppressWarnings("unchecked")
         public <T extends Enum<?>> Builder defineEnumerationArray(String property, Class<T> enumerationType, T... value) {
             EnumerationDescription[] enumerationDescription = new EnumerationDescription[value.length];
             int index = 0;
@@ -1965,6 +1966,7 @@ public Builder defineEnumerationArray(String property, TypeDescription enumerati
          * @param <T>            The annotation type.
          * @return A builder with the additional annotation property.
          */
+        @SuppressWarnings("unchecked")
         public <T extends Annotation> Builder defineAnnotationArray(String property, Class<T> annotationType, T... annotation) {
             return defineAnnotationArray(property,
                     new TypeDescription.ForLoadedType(annotationType),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1740,7 +1740,7 @@ public MethodDefinition<U> annotateMethod(Collection<? extends AnnotationDescrip
                                     token.getReturnType(),
                                     token.getParameterTokens(),
                                     token.getExceptionTypes(),
-                                    token.getAnnotations(),
+                                    CompoundList.of(token.getAnnotations(), new ArrayList<AnnotationDescription>(annotations)),
                                     token.getDefaultValue())).new AnnotationAdapter(handler, methodAttributeAppenderFactory, methodTransformer);
                         }
 

File: byte-buddy-benchmark/src/test/java/net/bytebuddy/benchmark/AbstractBlackHoleTest.java
Patch:
@@ -9,7 +9,6 @@
 import org.openjdk.jmh.infra.Blackhole;
 
 import java.lang.reflect.Method;
-import java.util.Collections;
 
 /**
  * Unfortunately, the JMH is not very test friendly. Thus, we need to do some tricks to run test cases. Fortunately,
@@ -27,7 +26,7 @@ public void setUpBlackHole() throws Exception {
         Class<?> blackHoleGenerator = new ByteBuddy()
                 .subclass(Object.class)
                 .name(String.format("C%s$generated", RandomString.make()))
-                .defineMethod(BLACK_HOLE_METHOD, Blackhole.class, Collections.<Class<?>>emptyList(), Visibility.PUBLIC)
+                .defineMethod(BLACK_HOLE_METHOD, Blackhole.class, Visibility.PUBLIC)
                 .intercept(MethodDelegation.toConstructor(Blackhole.class))
                 .make()
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/FieldRegistry.java
Patch:
@@ -21,7 +21,7 @@
  */
 public interface FieldRegistry {
 
-    FieldRegistry include(LatentMatcher<? super FieldDescription> matcher,
+    FieldRegistry prepend(LatentMatcher<? super FieldDescription> matcher,
                           FieldAttributeAppender.Factory attributeAppenderFactory,
                           Object defaultValue,
                           FieldTransformer fieldTransformer);
@@ -74,7 +74,7 @@ private Default(List<Entry> entries) {
         }
 
         @Override
-        public FieldRegistry include(LatentMatcher<? super FieldDescription> matcher,
+        public FieldRegistry prepend(LatentMatcher<? super FieldDescription> matcher,
                                      FieldAttributeAppender.Factory attributeAppenderFactory,
                                      Object defaultValue,
                                      FieldTransformer fieldTransformer) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationValueFilter.java
Patch:
@@ -59,7 +59,7 @@ public AnnotationValueFilter on(MethodDescription methodDescription) {
 
         @Override
         public String toString() {
-            return "AnnotationAppender.ValueFilter.Default." + name();
+            return "AnnotationValueFilter.Default." + name();
         }
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodInvocation.java
Patch:
@@ -320,8 +320,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                     methodDescription.getInternalName(),
                     methodDescription.getDescriptor(),
                     typeDescription.isInterface());
-            int parameterSize = methodDescription.getStackSize();
-            int returnValueSize = methodDescription.getReturnType().getStackSize().getSize();
+            int parameterSize = methodDescription.getStackSize(), returnValueSize = methodDescription.getReturnType().getStackSize().getSize();
             return new Size(returnValueSize - parameterSize, Math.max(0, returnValueSize - parameterSize));
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/FieldRegistryDefaultTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.dynamic.FieldTransformer;
-import net.bytebuddy.implementation.attribute.AnnotationAppender;
 import net.bytebuddy.implementation.attribute.FieldAttributeAppender;
 import net.bytebuddy.matcher.ElementMatcher;
 import net.bytebuddy.matcher.LatentMatcher;
@@ -68,7 +67,7 @@ public void testNoFieldsRegistered() throws Exception {
     @Test
     public void testKnownFieldRegistered() throws Exception {
         TypeWriter.FieldPool fieldPool = new FieldRegistry.Default()
-                .include(latentMatcher, distinctFactory, defaultValue, fieldTransformer)
+                .prepend(latentMatcher, distinctFactory, defaultValue, fieldTransformer)
                 .compile(instrumentedType);
         assertThat(fieldPool.target(knownField).getField(), is(instrumentedField));
         assertThat(fieldPool.target(knownField).getFieldAppender(), is(distinct));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterMethodPoolRecordTest.java
Patch:
@@ -6,7 +6,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.implementation.Implementation;
-import net.bytebuddy.implementation.attribute.AnnotationAppender;
+import net.bytebuddy.implementation.attribute.AnnotationValueFilter;
 import net.bytebuddy.implementation.attribute.MethodAttributeAppender;
 import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
 import net.bytebuddy.test.utility.MockitoRule;
@@ -79,10 +79,10 @@ public class TypeWriterMethodPoolRecordTest {
     private MethodDescription.TypeToken typeToken;
 
     @Mock
-    private AnnotationAppender.ValueFilter valueFilter;
+    private AnnotationValueFilter valueFilter;
 
     @Mock
-    private AnnotationAppender.ValueFilter.Factory annotationValueFilterFactory;
+    private AnnotationValueFilter.Factory annotationValueFilterFactory;
 
     @Before
     @SuppressWarnings("unchecked")

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDefaultOtherTest.java
Patch:
@@ -5,7 +5,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.dynamic.scaffold.TypeWriter;
-import net.bytebuddy.implementation.attribute.AnnotationAppender;
+import net.bytebuddy.implementation.attribute.AnnotationValueFilter;
 import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Test;
@@ -60,7 +60,7 @@ public void testFrozenTypeInitializerFrozenThrowsExceptionOnDrain() throws Excep
         implementationContext.drain(mock(ClassVisitor.class),
                 methodPool,
                 mock(Implementation.Context.ExtractableView.InjectedCode.class),
-                mock(AnnotationAppender.ValueFilter.Factory.class));
+                mock(AnnotationValueFilter.Factory.class));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDefaultTest.java
Patch:
@@ -11,7 +11,7 @@
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.dynamic.scaffold.TypeWriter;
-import net.bytebuddy.implementation.attribute.AnnotationAppender;
+import net.bytebuddy.implementation.attribute.AnnotationValueFilter;
 import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
 import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
@@ -154,7 +154,7 @@ public ImplementationContextDefaultTest(boolean interfaceType, int accessorMetho
     private TypeList.Generic firstSpecialExceptionTypes, secondSpecialExceptionTypes;
 
     @Mock
-    private AnnotationAppender.ValueFilter.Factory annotationValueFilterFactory;
+    private AnnotationValueFilter.Factory annotationValueFilterFactory;
 
     @Before
     @SuppressWarnings("unchecked")

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDisabledTest.java
Patch:
@@ -5,7 +5,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.dynamic.scaffold.TypeWriter;
-import net.bytebuddy.implementation.attribute.AnnotationAppender;
+import net.bytebuddy.implementation.attribute.AnnotationValueFilter;
 import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.test.utility.MockitoRule;
@@ -96,7 +96,7 @@ public void testDrainWithInjectedCode() throws Exception {
         new Implementation.Context.Disabled(instrumentedType).drain(mock(ClassVisitor.class),
                 methodPool,
                 injectedCode,
-                mock(AnnotationAppender.ValueFilter.Factory.class));
+                mock(AnnotationValueFilter.Factory.class));
     }
 
     @Test(expected = IllegalStateException.class)
@@ -105,7 +105,7 @@ public void testDrainWithMatchedCode() throws Exception {
         new Implementation.Context.Disabled(instrumentedType).drain(mock(ClassVisitor.class),
                 methodPool,
                 injectedCode,
-                mock(AnnotationAppender.ValueFilter.Factory.class));
+                mock(AnnotationValueFilter.Factory.class));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/AbstractAttributeAppenderTest.java
Patch:
@@ -25,7 +25,7 @@ public abstract class AbstractAttributeAppenderTest {
     protected TypeDescription instrumentedType;
 
     @Mock
-    protected AnnotationAppender.ValueFilter valueFilter;
+    protected AnnotationValueFilter valueFilter;
 
     @Before
     public void setUp() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/AnnotationAppenderDefaultTest.java
Patch:
@@ -49,7 +49,7 @@ public class AnnotationAppenderDefaultTest {
     private AnnotationAppender.Target target;
 
     @Mock
-    private AnnotationAppender.ValueFilter valueFilter;
+    private AnnotationValueFilter valueFilter;
 
     private AnnotationAppender annotationAppender;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/Builder.java
Patch:
@@ -1110,7 +1110,7 @@ public Optional<U> annotateField(Collection<? extends AnnotationDescription> ann
                 @Override
                 protected Builder<U> materialize() {
                     return Builder.AbstractBase.Adapter.this.materialize(instrumentedType.withField(token),
-                            fieldRegistry.include(new LatentMatcher.ForFieldToken(token), fieldAttributeAppenderFactory, defaultValue),
+                            fieldRegistry.include(new LatentMatcher.ForFieldToken(token), fieldAttributeAppenderFactory, defaultValue, FieldTransformer.NoOp.INSTANCE),
                             methodRegistry,
                             ignored,
                             typeAttributeAppender,
@@ -1150,7 +1150,7 @@ public Optional<U> annotateField(Collection<? extends AnnotationDescription> ann
                 @Override
                 protected Builder<U> materialize() {
                     return Builder.AbstractBase.Adapter.this.materialize(instrumentedType,
-                            fieldRegistry.include(matcher, fieldAttributeAppenderFactory, defaultValue),
+                            fieldRegistry.include(matcher, fieldAttributeAppenderFactory, defaultValue, FieldTransformer.NoOp.INSTANCE),
                             methodRegistry,
                             ignored,
                             typeAttributeAppender,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -2228,7 +2228,7 @@ protected DynamicType.Builder<S> materialize() {
                             attributeAppender,
                             ignoredMethods,
                             asmVisitorWrapper,
-                            fieldRegistry.include(new LatentMatcher.ForFieldToken(token), attributeAppenderFactory, defaultValue),
+                            fieldRegistry.include(new LatentMatcher.ForFieldToken(token), attributeAppenderFactory, defaultValue, FieldTransformer.NoOp.INSTANCE),
                             methodRegistry,
                             methodGraphCompiler,
                             defaultFieldAttributeAppenderFactory,

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/TypeConstantAdjustment.java
Patch:
@@ -18,7 +18,7 @@
  * or {@link ClassReader}, i.e. does not set any flags.
  * </p>
  */
-public enum TypeConstantAdjustment implements ClassVisitorWrapper {
+public enum TypeConstantAdjustment implements AsmVisitorWrapper {
 
     /**
      * The singleton instance.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/TypeAttributeAppender.java
Patch:
@@ -53,7 +53,7 @@ enum ForInstrumentedType implements TypeAttributeAppender {
         @Override
         public void apply(ClassVisitor classVisitor, TypeDescription instrumentedType, AnnotationAppender.ValueFilter valueFilter) {
             AnnotationAppender appender = new AnnotationAppender.Default(new AnnotationAppender.Target.OnType(classVisitor));
-            for (AnnotationDescription annotation : instrumentedType.asErasure().getDeclaredAnnotations()) {
+            for (AnnotationDescription annotation : instrumentedType.getDeclaredAnnotations()) {
                 appender = appender.append(annotation, AnnotationAppender.AnnotationVisibility.of(annotation), valueFilter);
             }
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoaderChildFirstTest.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.dynamic.loading;
 
-import net.bytebuddy.asm.ClassVisitorWrapper;
+import net.bytebuddy.asm.AsmVisitorWrapper;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.test.utility.ClassFileExtraction;
 import net.bytebuddy.test.utility.MockitoRule;
@@ -196,7 +196,7 @@ public static class Bar {
         /* empty */
     }
 
-    private static class RenamingWrapper implements ClassVisitorWrapper {
+    private static class RenamingWrapper implements AsmVisitorWrapper {
 
         private final String oldName, newName;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/FieldRegistryCompiledNoOpTest.java
Patch:
@@ -34,7 +34,7 @@ public void testReturnsNullDefaultValue() throws Exception {
     @Test
     public void testReturnsFieldAttributeAppender() throws Exception {
         TypeWriter.FieldPool.Record record = FieldRegistry.Compiled.NoOp.INSTANCE.target(fieldDescription);
-        assertThat(record.getFieldAppender(), is((FieldAttributeAppender) new FieldAttributeAppender.ForInstrumentedField(AnnotationAppender.ValueFilter.Default.APPEND_DEFAULTS)));
+        assertThat(record.getFieldAppender(), is((FieldAttributeAppender) FieldAttributeAppender.ForInstrumentedField.INSTANCE));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/FieldRegistryDefaultTest.java
Patch:
@@ -57,7 +57,7 @@ public void testNoFieldsRegistered() throws Exception {
                 .compile(instrumentedType)
                 .target(unknownField);
         assertThat(record.resolveDefault(defaultValue), is(defaultValue));
-        assertThat(record.getFieldAppender(), is((FieldAttributeAppender) new FieldAttributeAppender.ForInstrumentedField(AnnotationAppender.ValueFilter.Default.APPEND_DEFAULTS)));
+        assertThat(record.getFieldAppender(), is((FieldAttributeAppender) FieldAttributeAppender.ForInstrumentedField.INSTANCE));
     }
 
     @Test
@@ -68,7 +68,7 @@ public void testKnownFieldRegistered() throws Exception {
         assertThat(fieldPool.target(knownField).getFieldAppender(), is(distinct));
         assertThat(fieldPool.target(knownField).resolveDefault(otherDefaultValue), is(defaultValue));
         assertThat(fieldPool.target(unknownField).resolveDefault(otherDefaultValue), is(otherDefaultValue));
-        assertThat(fieldPool.target(unknownField).getFieldAppender(), is((FieldAttributeAppender) new FieldAttributeAppender.ForInstrumentedField(AnnotationAppender.ValueFilter.Default.APPEND_DEFAULTS)));
+        assertThat(fieldPool.target(unknownField).getFieldAppender(), is((FieldAttributeAppender) FieldAttributeAppender.ForInstrumentedField.INSTANCE));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodRegistryDefaultTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.dynamic.scaffold;
 
+import net.bytebuddy.description.annotation.AnnotationList;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.method.ParameterDescription;
@@ -311,6 +312,8 @@ public void testSkipEntryIfNotMatchedAndVisible() throws Exception {
     @Test
     @SuppressWarnings("unchecked")
     public void testVisibilityBridgeIfNotMatchedAndVisible() throws Exception {
+        when(instrumentedMethod.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
+        when(parameterDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
         when(resolvedMethodFilter.matches(instrumentedMethod)).thenReturn(true);
         when(firstFilter.matches(instrumentedMethod)).thenReturn(false);
         when(secondFilter.matches(instrumentedMethod)).thenReturn(false);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/AbstractImplementationTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.NamingStrategy;
-import net.bytebuddy.asm.ClassVisitorWrapper;
+import net.bytebuddy.asm.AsmVisitorWrapper;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
@@ -53,7 +53,7 @@ protected <T> DynamicType.Loaded<T> implement(Class<T> target,
                 Opcodes.ACC_PUBLIC,
                 TypeAttributeAppender.NoOp.INSTANCE,
                 isSynthetic(),
-                new ClassVisitorWrapper.Compound(),
+                new AsmVisitorWrapper.Compound(),
                 new FieldRegistry.Default(),
                 new MethodRegistry.Default(),
                 MethodGraph.Compiler.DEFAULT,

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/AbstractFieldAttributeAppenderTest.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.implementation.attribute;
 
 import net.bytebuddy.description.field.FieldDescription;
+import net.bytebuddy.description.type.TypeDescription;
 import org.mockito.Answers;
 import org.mockito.Mock;
 import org.objectweb.asm.FieldVisitor;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/AnnotationAppenderDefaultTest.java
Patch:
@@ -55,7 +55,7 @@ public class AnnotationAppenderDefaultTest {
 
     @Before
     public void setUp() throws Exception {
-        annotationAppender = new AnnotationAppender.Default(target, valueFilter);
+        annotationAppender = new AnnotationAppender.Default(target);
     }
 
     @Test
@@ -117,7 +117,7 @@ private Class<?> makeTypeWithAnnotation(Annotation annotation) throws Exception
         when(target.visit(any(String.class), anyBoolean())).thenReturn(annotationVisitor);
         AnnotationDescription annotationDescription = AnnotationDescription.ForLoadedAnnotation.of(annotation);
         AnnotationAppender.AnnotationVisibility annotationVisibility = AnnotationAppender.AnnotationVisibility.of(annotationDescription);
-        annotationAppender.append(annotationDescription, annotationVisibility);
+        annotationAppender.append(annotationDescription, annotationVisibility, valueFilter);
         switch (annotationVisibility) {
             case RUNTIME:
             case CLASS_FILE:
@@ -158,7 +158,7 @@ public void testSkipValues() throws Exception {
         when(annotationDescription.getAnnotationType()).thenReturn(annotationType);
         AnnotationVisitor annotationVisitor = mock(AnnotationVisitor.class);
         when(target.visit(anyString(), anyBoolean())).thenReturn(annotationVisitor);
-        annotationAppender.append(annotationDescription, AnnotationAppender.AnnotationVisibility.RUNTIME);
+        annotationAppender.append(annotationDescription, AnnotationAppender.AnnotationVisibility.RUNTIME, valueFilter);
         verify(valueFilter).isRelevant(annotationDescription, methodDescription);
         verifyNoMoreInteractions(valueFilter);
         verify(annotationVisitor).visitEnd();

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/DebuggingWrapper.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.test.utility;
 
-import net.bytebuddy.asm.ClassVisitorWrapper;
+import net.bytebuddy.asm.AsmVisitorWrapper;
 import net.bytebuddy.description.type.TypeDescription;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.util.Printer;
@@ -12,7 +12,7 @@
 import java.io.Writer;
 
 @SuppressWarnings("unused")
-public class DebuggingWrapper implements ClassVisitorWrapper {
+public class DebuggingWrapper implements AsmVisitorWrapper {
 
     private final PrintWriter printWriter;
 
@@ -28,7 +28,7 @@ public DebuggingWrapper(OutputStream outputStream, Printer printer) {
         this.printer = printer;
     }
 
-    public static ClassVisitorWrapper makeDefault() {
+    public static AsmVisitorWrapper makeDefault() {
         return new DebuggingWrapper(System.out, new Textifier());
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/AbstractGenericTypeDescriptionTest.java
Patch:
@@ -8,7 +8,6 @@
 import net.bytebuddy.dynamic.loading.PackageDefinitionStrategy;
 import net.bytebuddy.implementation.bytecode.StackSize;
 import org.hamcrest.CoreMatchers;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.objectweb.asm.*;
 
@@ -1143,7 +1142,6 @@ public void testGenericParameterEquality() throws Exception {
     }
 
     @Test
-    @Ignore("Still a problem when using loaded types that rely on java.lang.reflect.Parameters")
     public void testGenericTypeInconsistency() throws Exception {
         GenericTypeDescription typeDescription = describe(GenericDisintegrator.make());
         assertThat(typeDescription.getInterfaces().size(), is(2));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionArrayProjectionTest.java
Patch:
@@ -16,12 +16,12 @@ protected TypeDescription describe(Class<?> type) {
 
     @Override
     protected TypeDescription.Generic describe(Field field) {
-        return TypeDescription.Generic.OfGenericArray.Latent.of(TypeDefinition.Sort.describe(field.getGenericType()), 0);
+        return TypeDefinition.Sort.describe(field.getGenericType());
     }
 
     @Override
     protected TypeDescription.Generic describe(Method method) {
-        return TypeDescription.Generic.OfGenericArray.Latent.of(TypeDefinition.Sort.describe(method.getGenericReturnType()), 0);
+        return TypeDefinition.Sort.describe(method.getGenericReturnType());
     }
 
     @Test(expected = IllegalArgumentException.class)

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/MethodTransformer.java
Patch:
@@ -207,7 +207,7 @@ protected TransformedMethod(TypeDefinition declaringType,
 
             @Override
             public TypeList.Generic getTypeVariables() {
-                return TypeList.Generic.ForDetachedTypes.OfTypeVariable.attach(this, token.getTypeVariables());
+                return TypeList.Generic.ForDetachedTypes.attach(this, token.getTypeVariables());
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -220,7 +220,7 @@ public DynamicType.Unloaded<T> make() {
         MethodRegistry.Prepared preparedMethodRegistry = methodRegistry.prepare(new InstrumentedType.Default(namingStrategy.name(new NamingStrategy
                         .UnnamedType.Default(originalType.getSuperType(), interfaceTypes, modifiers, classFileVersion)),
                         modifiers,
-                        originalType.getTypeVariables().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(is(originalType))),
+                        originalType.getTypeVariables().asSymbols(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(is(originalType))),
                         originalType.getSuperType(),
                         interfaceTypes,
                         fieldTokens,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -207,7 +207,7 @@ public DynamicType.Unloaded<T> make() {
         MethodRegistry.Compiled compiledMethodRegistry = methodRegistry.prepare(new InstrumentedType.Default(namingStrategy
                         .name(new NamingStrategy.UnnamedType.Default(originalType.getSuperType(), interfaceTypes, modifiers, classFileVersion)),
                         modifiers,
-                        originalType.getTypeVariables().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(is(originalType))),
+                        originalType.getTypeVariables().asSymbols(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(is(originalType))),
                         originalType.getSuperType(),
                         interfaceTypes,
                         fieldTokens,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -7,6 +7,7 @@
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.scaffold.*;
 import net.bytebuddy.implementation.Implementation;
@@ -214,7 +215,7 @@ public DynamicType.Unloaded<T> make() {
                                 modifiers,
                                 classFileVersion)),
                                 modifiers,
-                                Collections.<TypeDescription.Generic>emptyList(),
+                                Collections.<String, TypeList.Generic>emptyMap(),
                                 superType,
                                 interfaceTypes,
                                 fieldTokens,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -10,6 +10,7 @@
 import net.bytebuddy.description.modifier.Visibility;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
@@ -197,7 +198,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
             MethodDescription callMethod = new MethodDescription.Latent(new TypeDescription.ForLoadedType(Callable.class),
                     "call",
                     Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
-                    Collections.<TypeDescription.Generic>emptyList(),
+                    Collections.<String, TypeList.Generic>emptyMap(),
                     TypeDescription.Generic.OBJECT,
                     Collections.<ParameterDescription.Token>emptyList(),
                     Collections.singletonList(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Exception.class)),
@@ -207,7 +208,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
             MethodDescription runMethod = new MethodDescription.Latent(new TypeDescription.ForLoadedType(Runnable.class),
                     "run",
                     Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
-                    Collections.<TypeDescription.Generic>emptyList(),
+                    Collections.<String, TypeList.Generic>emptyMap(),
                     TypeDescription.Generic.VOID,
                     Collections.<ParameterDescription.Token>emptyList(),
                     Collections.<TypeDescription.Generic>emptyList(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AbstractAnnotationDescriptionTest.java
Patch:
@@ -4,6 +4,7 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.utility.PropertyDispatcher;
 import org.hamcrest.CoreMatchers;
 import org.junit.Before;
@@ -395,7 +396,7 @@ private void assertValue(Annotation annotation, String methodName, Object rawVal
         assertThat(describe(annotation).getValue(new MethodDescription.Latent(new TypeDescription.ForLoadedType(annotation.annotationType()),
                 methodName,
                 Opcodes.ACC_PUBLIC,
-                Collections.<TypeDescription.Generic>emptyList(),
+                Collections.<String, TypeList.Generic>emptyMap(),
                 new TypeDescription.Generic.OfNonGenericType.ForLoadedType(annotation.annotationType().getDeclaredMethod(methodName).getReturnType()),
                 Collections.<ParameterDescription.Token>emptyList(),
                 Collections.<TypeDescription.Generic>emptyList(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/AbstractDynamicTypeBuilderTest.java
Patch:
@@ -10,6 +10,7 @@
 import net.bytebuddy.description.modifier.TypeManifestation;
 import net.bytebuddy.description.modifier.Visibility;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.dynamic.loading.ByteArrayClassLoader;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.dynamic.loading.PackageDefinitionStrategy;
@@ -430,7 +431,7 @@ private static class PreparedMethod implements Implementation {
         public InstrumentedType prepare(InstrumentedType instrumentedType) {
             return instrumentedType.withMethod(new MethodDescription.Token(FOO,
                     MODIFIERS,
-                    Collections.<TypeDescription.Generic>emptyList(),
+                    Collections.<String, TypeList.Generic>emptyMap(),
                     TypeDescription.Generic.OBJECT,
                     Collections.singletonList(new ParameterDescription.Token(TypeDescription.Generic.OBJECT,
                             Collections.singletonList(AnnotationDescription.Builder.forType(SampleAnnotation.class).define(FOO, QUX).make()))),

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/MethodTransformerSimpleTest.java
Patch:
@@ -80,7 +80,7 @@ public void setUp() throws Exception {
         when(methodToken.getName()).thenReturn(FOO);
         when(methodToken.getModifiers()).thenReturn(MODIFIERS);
         when(methodToken.getReturnType()).thenReturn(returnType);
-        when(methodToken.getTypeVariables()).thenReturn(new TypeList.Generic.Explicit(typeVariable));
+        when(methodToken.getTypeVariables()).thenReturn(Collections.<String, TypeList.Generic>singletonMap(QUX, new TypeList.Generic.Explicit(typeVariable)));
         when(methodToken.getExceptionTypes()).thenReturn(new TypeList.Generic.Explicit(exceptionType));
         when(methodToken.getParameterTokens())
                 .thenReturn(new ByteCodeElement.Token.TokenList<ParameterDescription.Token>(Collections.singletonList(parameterToken)));
@@ -130,7 +130,8 @@ public void testModifierTransformation() throws Exception {
         assertThat(transformed.getModifiers(), is((MODIFIERS & ~RANGE) | MASK));
         assertThat(transformed.getReturnType(), is(returnType));
         assertThat(transformed.getTypeVariables().size(), is(1));
-        assertThat(transformed.getTypeVariables().getOnly(), is(typeVariable));
+        assertThat(transformed.getTypeVariables().containsKey(QUX), is(true));
+        assertThat(transformed.getTypeVariables().get(QUX).size(), is(1)); // TODO
         assertThat(transformed.getExceptionTypes().size(), is(1));
         assertThat(transformed.getExceptionTypes().getOnly(), is(exceptionType));
         assertThat(transformed.getParameterTokens().size(), is(1));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeTest.java
Patch:
@@ -5,6 +5,7 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.dynamic.TargetType;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.LoadedTypeInitializer;
@@ -42,7 +43,7 @@ public class InstrumentedTypeTest {
     protected static InstrumentedType makePlainInstrumentedType() {
         return new InstrumentedType.Default(FOO + "." + BAZ,
                 Opcodes.ACC_PUBLIC,
-                Collections.<TypeDescription.Generic>emptyList(),
+                Collections.<String, TypeList.Generic>emptyMap(),
                 TypeDescription.Generic.OBJECT,
                 Collections.<TypeDescription.Generic>singletonList(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Serializable.class)),
                 Collections.<FieldDescription.Token>emptyList(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultTest.java
Patch:
@@ -4,6 +4,7 @@
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.implementation.LoadedTypeInitializer;
 import net.bytebuddy.matcher.ElementMatchers;
 import net.bytebuddy.test.utility.JavaVersionRule;
@@ -910,7 +911,7 @@ public void testOrphanedBridge() throws Exception {
                 Collections.<TypeDescription>emptyList());
         TypeDescription typeDescription = new InstrumentedType.Default("foo",
                 Opcodes.ACC_PUBLIC,
-                Collections.<TypeDescription.Generic>emptyList(),
+                Collections.<String, TypeList.Generic>emptyMap(),
                 TypeDescription.Generic.OBJECT,
                 Collections.<TypeDescription.Generic>emptyList(),
                 Collections.<FieldDescription.Token>emptyList(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -579,9 +579,7 @@ public static <T extends TypeDefinition> ElementMatcher<T> isVariable(String sym
      * @return A matcher that matches type variables with the given name.
      */
     public static <T extends TypeDefinition> ElementMatcher<T> isVariable(ElementMatcher<? super NamedElement> matcher) {
-        return new TypeSortMatcher<T>(anyOf(TypeDefinition.Sort.VARIABLE,
-                TypeDefinition.Sort.VARIABLE_DETACHED,
-                TypeDefinition.Sort.VARIABLE_SYMBOLIC)).and(matcher);
+        return new TypeSortMatcher<T>(anyOf(TypeDefinition.Sort.VARIABLE, TypeDefinition.Sort.VARIABLE_SYMBOLIC)).and(matcher);
     }
 
     /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDefinitionSortTest.java
Patch:
@@ -19,7 +19,6 @@ public static Collection<Object[]> data() {
                 {TypeDefinition.Sort.NON_GENERIC, true, false, false, false, false},
                 {TypeDefinition.Sort.PARAMETERIZED, false, true, false, false, false},
                 {TypeDefinition.Sort.VARIABLE, false, false, true, false, false},
-                {TypeDefinition.Sort.VARIABLE_DETACHED, false, false, true, false, false},
                 {TypeDefinition.Sort.VARIABLE_SYMBOLIC, false, false, true, false, false},
                 {TypeDefinition.Sort.GENERIC_ARRAY, false, false, false, true, false},
                 {TypeDefinition.Sort.WILDCARD, false, false, false, false, true}

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -244,8 +244,8 @@ private InstrumentedType applyConstructorStrategy(InstrumentedType instrumentedT
         if (instrumentedType.isInterface()) {
             return instrumentedType;
         }
-        for (MethodDescription.Token methodToken : constructorStrategy.extractConstructors(instrumentedType)) {
-            instrumentedType = instrumentedType.withMethod(methodToken);
+        for (MethodDescription.Token token : constructorStrategy.extractConstructors(instrumentedType)) {
+            instrumentedType = instrumentedType.withMethod(token);
         }
         return instrumentedType;
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/DefaultMethodCall.java
Patch:
@@ -223,7 +223,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
          * given method.
          */
         private StackManipulation locateDefault(MethodDescription methodDescription) {
-            MethodDescription.Token methodToken = methodDescription.asToken();
+            MethodDescription.SignatureToken methodToken = methodDescription.asSignatureToken();
             SpecialMethodInvocation specialMethodInvocation = SpecialMethodInvocation.Illegal.INSTANCE;
             for (TypeDescription typeDescription : prioritizedInterfaces) {
                 specialMethodInvocation = implementationTarget.invokeDefault(typeDescription, methodToken);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -2093,7 +2093,7 @@ public StackManipulation invoke(MethodDescription methodDescription, Target impl
                 } else if (!methodDescription.isInvokableOn(implementationTarget.getOriginType().asErasure())) {
                     throw new IllegalStateException("Cannot invoke " + methodDescription + " as super method of " + implementationTarget.getInstrumentedType());
                 }
-                StackManipulation stackManipulation = implementationTarget.invokeDominant(methodDescription.asToken());
+                StackManipulation stackManipulation = implementationTarget.invokeDominant(methodDescription.asSignatureToken());
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot invoke " + methodDescription + " as a super method");
                 }
@@ -2121,7 +2121,7 @@ public StackManipulation invoke(MethodDescription methodDescription, Target impl
                 if (!methodDescription.isInvokableOn(implementationTarget.getInstrumentedType())) {
                     throw new IllegalStateException("Cannot invoke " + methodDescription + " as default method of " + implementationTarget.getInstrumentedType());
                 }
-                StackManipulation stackManipulation = implementationTarget.invokeDefault(methodDescription.getDeclaringType().asErasure(), methodDescription.asToken());
+                StackManipulation stackManipulation = implementationTarget.invokeDefault(methodDescription.getDeclaringType().asErasure(), methodDescription.asSignatureToken());
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot invoke " + methodDescription + " on " + implementationTarget.getInstrumentedType());
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/SuperMethodCall.java
Patch:
@@ -100,7 +100,7 @@ protected Appender(Target implementationTarget, TerminationHandler terminationHa
 
         @Override
         public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
-            StackManipulation superMethodCall = implementationTarget.invokeDominant(instrumentedMethod.asToken());
+            StackManipulation superMethodCall = implementationTarget.invokeDominant(instrumentedMethod.asSignatureToken());
             if (!superMethodCall.isValid()) {
                 throw new IllegalStateException("Cannot call super (or default) method for " + instrumentedMethod);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -193,7 +193,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
          * Creates the precomputed method graph.
          */
         PrecomputedMethodGraph() {
-            LinkedHashMap<MethodDescription.Token, MethodGraph.Node> nodes = new LinkedHashMap<MethodDescription.Token, MethodGraph.Node>();
+            LinkedHashMap<MethodDescription.SignatureToken, MethodGraph.Node> nodes = new LinkedHashMap<MethodDescription.SignatureToken, MethodGraph.Node>();
             MethodDescription callMethod = new MethodDescription.Latent(new TypeDescription.ForLoadedType(Callable.class),
                     "call",
                     Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
@@ -203,7 +203,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
                     Collections.singletonList(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(Exception.class)),
                     Collections.<AnnotationDescription>emptyList(),
                     MethodDescription.NO_DEFAULT_VALUE);
-            nodes.put(callMethod.asToken(), new MethodGraph.Node.Simple(callMethod));
+            nodes.put(callMethod.asSignatureToken(), new MethodGraph.Node.Simple(callMethod));
             MethodDescription runMethod = new MethodDescription.Latent(new TypeDescription.ForLoadedType(Runnable.class),
                     "run",
                     Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
@@ -213,7 +213,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
                     Collections.<TypeDescription.Generic>emptyList(),
                     Collections.<AnnotationDescription>emptyList(),
                     MethodDescription.NO_DEFAULT_VALUE);
-            nodes.put(runMethod.asToken(), new MethodGraph.Node.Simple(runMethod));
+            nodes.put(runMethod.asSignatureToken(), new MethodGraph.Node.Simple(runMethod));
             MethodGraph methodGraph = new MethodGraph.Simple(nodes);
             this.methodGraph = new MethodGraph.Linked.Delegation(methodGraph, methodGraph, Collections.<TypeDescription, MethodGraph>emptyMap());
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TypeProxy.java
Patch:
@@ -385,7 +385,7 @@ enum Default implements InvocationFactory {
                 public Implementation.SpecialMethodInvocation invoke(Implementation.Target implementationTarget,
                                                                      TypeDescription proxiedType,
                                                                      MethodDescription instrumentedMethod) {
-                    return implementationTarget.invokeDominant(instrumentedMethod.asToken());
+                    return implementationTarget.invokeDominant(instrumentedMethod.asSignatureToken());
                 }
             },
 
@@ -397,7 +397,7 @@ public Implementation.SpecialMethodInvocation invoke(Implementation.Target imple
                 public Implementation.SpecialMethodInvocation invoke(Implementation.Target implementationTarget,
                                                                      TypeDescription proxiedType,
                                                                      MethodDescription instrumentedMethod) {
-                    return implementationTarget.invokeDefault(proxiedType, instrumentedMethod.asToken());
+                    return implementationTarget.invokeDefault(proxiedType, instrumentedMethod.asSignatureToken());
                 }
             };
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultCall.java
Patch:
@@ -150,7 +150,7 @@ public Implementation.SpecialMethodInvocation resolve(Implementation.Target impl
                             if (specialMethodInvocation != null) {
                                 return Implementation.SpecialMethodInvocation.Illegal.INSTANCE;
                             }
-                            specialMethodInvocation = implementationTarget.invokeDefault(candidate, source.asToken());
+                            specialMethodInvocation = implementationTarget.invokeDefault(candidate, source.asSignatureToken());
                         }
                     }
                     return specialMethodInvocation != null
@@ -190,7 +190,7 @@ public Implementation.SpecialMethodInvocation resolve(Implementation.Target impl
                     if (!typeDescription.isInterface()) {
                         throw new IllegalStateException(source + " method carries default method call parameter on non-interface type");
                     }
-                    return implementationTarget.invokeDefault(typeDescription, source.asToken());
+                    return implementationTarget.invokeDefault(typeDescription, source.asSignatureToken());
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -191,7 +191,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             Implementation.SpecialMethodInvocation specialMethodInvocation;
             TypeDescription typeDescription = annotation.getValue(DEFAULT_TARGET, TypeDescription.class);
             if (typeDescription.represents(void.class) && !annotation.getValue(DEFAULT_METHOD, Boolean.class)) {
-                specialMethodInvocation = implementationTarget.invokeSuper(source.asToken());
+                specialMethodInvocation = implementationTarget.invokeSuper(source.asSignatureToken());
             } else {
                 specialMethodInvocation = (typeDescription.represents(void.class)
                         ? DefaultMethodLocator.Implicit.INSTANCE
@@ -257,7 +257,7 @@ public Implementation.SpecialMethodInvocation resolve(Implementation.Target impl
                             if (specialMethodInvocation != null) {
                                 return Implementation.SpecialMethodInvocation.Illegal.INSTANCE;
                             }
-                            specialMethodInvocation = implementationTarget.invokeDefault(candidate, source.asToken());
+                            specialMethodInvocation = implementationTarget.invokeDefault(candidate, source.asSignatureToken());
                         }
                     }
                     return specialMethodInvocation != null
@@ -297,7 +297,7 @@ public Implementation.SpecialMethodInvocation resolve(Implementation.Target impl
                     if (!typeDescription.isInterface()) {
                         throw new IllegalStateException(source + " method carries default method call parameter on non-interface type");
                     }
-                    return implementationTarget.invokeDefault(typeDescription, source.asToken());
+                    return implementationTarget.invokeDefault(typeDescription, source.asSignatureToken());
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperCall.java
Patch:
@@ -74,8 +74,8 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                 throw new IllegalStateException("A super method call proxy can only be assigned to Runnable or Callable types: " + target);
             }
             Implementation.SpecialMethodInvocation specialMethodInvocation = annotation.loadSilent().fallbackToDefault()
-                    ? implementationTarget.invokeDominant(source.asToken())
-                    : implementationTarget.invokeSuper(source.asToken());
+                    ? implementationTarget.invokeDominant(source.asSignatureToken())
+                    : implementationTarget.invokeSuper(source.asSignatureToken());
             return specialMethodInvocation.isValid()
                     ? new MethodDelegationBinder.ParameterBinding.Anonymous(new MethodCallProxy
                     .AssignableSignatureCall(specialMethodInvocation, annotation.loadSilent().serializableProxy()))

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodInvocation.java
Patch:
@@ -369,15 +369,15 @@ public boolean equals(Object other) {
             if (other == null || getClass() != other.getClass()) return false;
             Invocation that = (Invocation) other;
             return MethodInvocation.this.equals(((Invocation) other).getOuterInstance())
-                    && methodDescription.asToken().equals(that.methodDescription.asToken())
+                    && methodDescription.asSignatureToken().equals(that.methodDescription.asSignatureToken())
                     && typeDescription.equals(that.typeDescription);
         }
 
         @Override
         public int hashCode() {
             int result = typeDescription.hashCode();
             result = 31 * result + MethodInvocation.this.hashCode();
-            result = 31 * result + methodDescription.asToken().hashCode();
+            result = 31 * result + methodDescription.asSignatureToken().hashCode();
             return result;
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphCompilerDefaultMergerStrictTest.java
Patch:
@@ -32,13 +32,11 @@ public void setUp() throws Exception {
 
     @Test
     public void testIdentical() throws Exception {
-        when(leftToken.isIdenticalTo(rightToken)).thenReturn(true);
-        assertThat(MethodGraph.Compiler.Default.Merger.Strict.INSTANCE.merge(left, right), is(left));
+        assertThat(MethodGraph.Compiler.Default.Merger.Strict.INSTANCE.merge(left, left), is(left));
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void testNonIdentical() throws Exception {
-        when(leftToken.isIdenticalTo(rightToken)).thenReturn(false);
         MethodGraph.Compiler.Default.Merger.Strict.INSTANCE.merge(left, right);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphEmptyTest.java
Patch:
@@ -13,7 +13,7 @@ public class MethodGraphEmptyTest {
 
     @Test
     public void testNode() throws Exception {
-        assertThat(MethodGraph.Empty.INSTANCE.locate(mock(MethodDescription.Token.class)).getSort(), is(MethodGraph.Node.Sort.UNRESOLVED));
+        assertThat(MethodGraph.Empty.INSTANCE.locate(mock(MethodDescription.SignatureToken.class)).getSort(), is(MethodGraph.Node.Sort.UNRESOLVED));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphLinkedDelegationTest.java
Patch:
@@ -29,7 +29,7 @@ public class MethodGraphLinkedDelegationTest {
     private MethodGraph methodGraph, superGraph, interfaceGraph;
 
     @Mock
-    private MethodDescription.Token methodToken;
+    private MethodDescription.SignatureToken token;
 
     @Mock
     private MethodGraph.Node node;
@@ -41,14 +41,14 @@ public class MethodGraphLinkedDelegationTest {
 
     @Before
     public void setUp() throws Exception {
-        when(methodGraph.locate(methodToken)).thenReturn(node);
+        when(methodGraph.locate(token)).thenReturn(node);
         when(methodGraph.listNodes()).thenReturn(nodeList);
         linkedMethodGraph = new MethodGraph.Linked.Delegation(methodGraph, superGraph, Collections.singletonMap(typeDescription, interfaceGraph));
     }
 
     @Test
     public void testLocateNode() throws Exception {
-        assertThat(linkedMethodGraph.locate(methodToken), is(node));
+        assertThat(linkedMethodGraph.locate(token), is(node));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphSimpleTest.java
Patch:
@@ -24,11 +24,11 @@ public class MethodGraphSimpleTest {
     private MethodDescription methodDescription;
 
     @Mock
-    private MethodDescription.Token methodToken;
+    private MethodDescription.SignatureToken token;
 
     @Before
     public void setUp() throws Exception {
-        when(methodDescription.asToken()).thenReturn(methodToken);
+        when(methodDescription.asSignatureToken()).thenReturn(token);
     }
 
     @Test
@@ -39,7 +39,7 @@ public void testNodeList() throws Exception {
 
     @Test
     public void testNodeLocation() throws Exception {
-        assertThat(MethodGraph.Simple.of(Collections.singletonList(methodDescription)).locate(methodToken),
+        assertThat(MethodGraph.Simple.of(Collections.singletonList(methodDescription)).locate(token),
                 is((MethodGraph.Node) new MethodGraph.Node.Simple(methodDescription)));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTargetSpecialMethodInvocationTest.java
Patch:
@@ -23,7 +23,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(RebaseImplementationTarget.RebasedMethodInvocation.class).refine(new ObjectPropertyAssertion.Refinement<MethodDescription>() {
             @Override
             public void apply(MethodDescription mock) {
-                when(mock.asToken()).thenReturn(mock(MethodDescription.Token.class));
+                when(mock.asSignatureToken()).thenReturn(mock(MethodDescription.SignatureToken.class));
             }
         }).applyBasic();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTargetTest.java
Patch:
@@ -36,7 +36,7 @@ public class RebaseImplementationTargetTest extends AbstractImplementationTarget
     private MethodDescription.InDefinedShape rebasedMethod;
 
     @Mock
-    private MethodDescription.Token rebasedToken;
+    private MethodDescription.SignatureToken rebasedToken;
 
     @Mock
     private MethodRebaseResolver.Resolution resolution;
@@ -50,7 +50,7 @@ public class RebaseImplementationTargetTest extends AbstractImplementationTarget
     @Override
     @Before
     public void setUp() throws Exception {
-        when(methodGraph.locate(Mockito.any(MethodDescription.Token.class))).thenReturn(MethodGraph.Node.Unresolved.INSTANCE);
+        when(methodGraph.locate(Mockito.any(MethodDescription.SignatureToken.class))).thenReturn(MethodGraph.Node.Unresolved.INSTANCE);
         when(instrumentedType.getSuperType()).thenReturn(genericSuperType);
         when(genericSuperType.asErasure()).thenReturn(superType);
         when(superType.getInternalName()).thenReturn(BAR);
@@ -60,7 +60,7 @@ public void setUp() throws Exception {
         when(rebasedMethod.getReturnType()).thenReturn(genericReturnType);
         when(rebasedMethod.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
         when(rebasedMethod.getDeclaringType()).thenReturn(instrumentedType);
-        when(rebasedMethod.asToken()).thenReturn(rebasedToken);
+        when(rebasedMethod.asSignatureToken()).thenReturn(rebasedToken);
         when(methodRebaseResolver.resolve(rebasedMethod)).thenReturn(resolution);
         super.setUp();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/AbstractSpecialMethodInvocationTest.java
Patch:
@@ -24,7 +24,7 @@ public abstract class AbstractSpecialMethodInvocationTest {
     private MethodDescription methodDescription, otherMethod;
 
     @Mock
-    private MethodDescription.Token methodToken, otherToken;
+    private MethodDescription.SignatureToken token, otherToken;
 
     @Mock
     private TypeDescription typeDescription, otherType;
@@ -34,8 +34,8 @@ public abstract class AbstractSpecialMethodInvocationTest {
 
     @Before
     public void setUp() throws Exception {
-        when(methodDescription.asToken()).thenReturn(methodToken);
-        when(otherMethod.asToken()).thenReturn(otherToken);
+        when(methodDescription.asSignatureToken()).thenReturn(token);
+        when(otherMethod.asSignatureToken()).thenReturn(otherToken);
     }
 
     protected abstract Implementation.SpecialMethodInvocation make(MethodDescription methodDescription, TypeDescription typeDescription);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/SuperCallBinderTest.java
Patch:
@@ -25,7 +25,7 @@ public class SuperCallBinderTest extends AbstractAnnotationBinderTest<SuperCall>
     private Implementation.SpecialMethodInvocation specialMethodInvocation;
 
     @Mock
-    private MethodDescription.Token sourceToken;
+    private MethodDescription.SignatureToken sourceToken;
 
     public SuperCallBinderTest() {
         super(SuperCall.class);
@@ -37,8 +37,8 @@ public void setUp() throws Exception {
         super.setUp();
         when(target.getType()).thenReturn(genericTargetParameterType);
         when(genericTargetParameterType.asErasure()).thenReturn(targetParameterType);
+        when(source.asSignatureToken()).thenReturn(sourceToken);
         when(implementationTarget.invokeSuper(sourceToken)).thenReturn(specialMethodInvocation);
-        when(source.asToken()).thenReturn(sourceToken);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationGenericTest.java
Patch:
@@ -38,7 +38,7 @@ public class MethodInvocationGenericTest {
     private TypeDescription declaredErasure, declaringType, targetType, otherType;
 
     @Mock
-    private MethodDescription.Token methodToken;
+    private MethodDescription.SignatureToken token;
 
     @Before
     public void setUp() throws Exception {
@@ -48,7 +48,7 @@ public void setUp() throws Exception {
         when(declaredReturnType.asErasure()).thenReturn(declaredErasure);
         when(declaredMethod.getDeclaringType()).thenReturn(declaringType);
         when(declaringType.asErasure()).thenReturn(declaringType);
-        when(declaredMethod.asToken()).thenReturn(methodToken);
+        when(declaredMethod.asSignatureToken()).thenReturn(token);
         when(declaredMethod.isSpecializableFor(targetType)).thenReturn(true);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationOtherTest.java
Patch:
@@ -41,7 +41,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(MethodInvocation.Invocation.class).refine(new ObjectPropertyAssertion.Refinement<MethodDescription>() {
             @Override
             public void apply(MethodDescription mock) {
-                when(mock.asToken()).thenReturn(mock(MethodDescription.Token.class));
+                when(mock.asSignatureToken()).thenReturn(mock(MethodDescription.SignatureToken.class));
                 TypeDescription declaringType = mock(TypeDescription.class);
                 when(declaringType.asErasure()).thenReturn(declaringType);
                 when(mock.getDeclaringType()).thenReturn(declaringType);

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -404,7 +404,7 @@ public boolean isDefaultMethod() {
         public boolean isSpecializableFor(TypeDescription targetType) {
             if (isStatic()) { // Static private methods are never specializable, check static property first
                 return false;
-            } else if (isPrivate() || isConstructor() || isDefaultMethod()) {
+            } else if (isPrivate() || isConstructor()) {
                 return getDeclaringType().equals(targetType);
             } else {
                 return !isAbstract() && getDeclaringType().asErasure().isAssignableFrom(targetType);

File: byte-buddy-dep/src/main/java/net/bytebuddy/NamingStrategy.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.modifier.*;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.utility.ByteBuddyCommons;
 import net.bytebuddy.utility.RandomString;
 import org.objectweb.asm.Opcodes;
 
@@ -139,7 +138,7 @@ public List<TypeDescription.Generic> getDeclaredInterfaces() {
 
             @Override
             public Visibility getVisibility() {
-                switch (modifiers & ByteBuddyCommons.VISIBILITY_MODIFIER_MASK) {
+                switch (modifiers & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED | Opcodes.ACC_PRIVATE)) {
                     case Opcodes.ACC_PUBLIC:
                         return Visibility.PUBLIC;
                     case Opcodes.ACC_PROTECTED:

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -16,8 +16,6 @@
 import java.util.jar.JarFile;
 import java.util.zip.ZipEntry;
 
-import static net.bytebuddy.utility.ByteBuddyCommons.nonNull;
-
 /**
  * Locates a class file or its byte array representation when it is given its type description.
  */
@@ -480,7 +478,7 @@ public AgentBased(Instrumentation instrumentation, ClassLoadingDelegate classLoa
                 throw new IllegalArgumentException(instrumentation + " does not support retransformation");
             }
             this.instrumentation = instrumentation;
-            this.classLoadingDelegate = nonNull(classLoadingDelegate);
+            this.classLoadingDelegate = classLoadingDelegate;
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/MethodTransformer.java
Patch:
@@ -12,8 +12,6 @@
 import java.util.Arrays;
 import java.util.List;
 
-import static net.bytebuddy.utility.ByteBuddyCommons.nonNull;
-
 /**
  * A method transformer allows to transform a method prior to its definition. This way, previously defined methods
  * can be substituted by a different method description. It is the responsibility of the method transformer that
@@ -78,7 +76,7 @@ public Simple(Transformer transformer) {
          * @return A method transformer where each method's modifiers are adapted to the given modifiers.
          */
         public static MethodTransformer withModifiers(ModifierContributor.ForMethod... modifierTransformer) {
-            return new Simple(new Transformer.ForModifierTransformation(Arrays.asList(nonNull(modifierTransformer))));
+            return new Simple(new Transformer.ForModifierTransformation(Arrays.asList(modifierTransformer)));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -27,6 +27,7 @@
 import net.bytebuddy.implementation.bytecode.member.MethodReturn;
 import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
 import net.bytebuddy.pool.TypePool;
+import net.bytebuddy.utility.CompoundList;
 import net.bytebuddy.utility.RandomString;
 import org.objectweb.asm.*;
 import org.objectweb.asm.commons.Remapper;
@@ -37,8 +38,6 @@
 import java.io.IOException;
 import java.util.*;
 
-import static net.bytebuddy.utility.ByteBuddyCommons.join;
-
 /**
  * A type writer is a utility for writing an actual class file using the ASM library.
  *
@@ -1479,7 +1478,7 @@ public DynamicType.Unloaded<S> make() {
             return new DynamicType.Default.Unloaded<S>(instrumentedType,
                     create(implementationContext),
                     loadedTypeInitializer,
-                    join(explicitAuxiliaryTypes, implementationContext.getRegisteredAuxiliaryTypes()));
+                    CompoundList.of(explicitAuxiliaryTypes, implementationContext.getRegisteredAuxiliaryTypes()));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolver.java
Patch:
@@ -13,6 +13,7 @@
 import net.bytebuddy.implementation.auxiliary.TrivialType;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.constant.NullConstant;
+import net.bytebuddy.utility.CompoundList;
 import net.bytebuddy.utility.RandomString;
 import org.objectweb.asm.Opcodes;
 
@@ -21,8 +22,6 @@
 import java.util.List;
 import java.util.Map;
 
-import static net.bytebuddy.utility.ByteBuddyCommons.join;
-
 /**
  * A method rebase resolver is responsible for mapping methods of an instrumented type to an alternative signature.
  * This way a method can exist in two versions within a class:
@@ -515,7 +514,7 @@ public TypeDescription.Generic getReturnType() {
 
                 @Override
                 public ParameterList<ParameterDescription.InDefinedShape> getParameters() {
-                    return new ParameterList.Explicit.ForTypes(this, join(methodDescription.getParameters().asTypeList().asErasures(), placeholderType));
+                    return new ParameterList.Explicit.ForTypes(this, CompoundList.of(methodDescription.getParameters().asTypeList().asErasures(), placeholderType));
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -17,11 +17,11 @@
 import net.bytebuddy.implementation.attribute.TypeAttributeAppender;
 import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
 import net.bytebuddy.matcher.ElementMatcher;
+import net.bytebuddy.utility.CompoundList;
 
 import java.util.List;
 
 import static net.bytebuddy.matcher.ElementMatchers.*;
-import static net.bytebuddy.utility.ByteBuddyCommons.joinUniqueRaw;
 
 /**
  * A dynamic type builder that rebases a given type, i.e. it behaves like if a subclass was defined where any methods
@@ -88,7 +88,7 @@ public RebaseDynamicTypeBuilder(ClassFileVersion classFileVersion,
                 auxiliaryTypeNamingStrategy,
                 implementationContextFactory,
                 InstrumentedType.TypeInitializer.None.INSTANCE,
-                joinUniqueRaw(interfaceTypes, originalType.getInterfaces()),
+                CompoundList.of(interfaceTypes, originalType.getInterfaces()),
                 modifiers,
                 attributeAppender,
                 ignoredMethods,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -17,11 +17,11 @@
 import net.bytebuddy.implementation.attribute.TypeAttributeAppender;
 import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
 import net.bytebuddy.matcher.ElementMatcher;
+import net.bytebuddy.utility.CompoundList;
 
 import java.util.List;
 
 import static net.bytebuddy.matcher.ElementMatchers.is;
-import static net.bytebuddy.utility.ByteBuddyCommons.joinUniqueRaw;
 
 /**
  * A dynamic type builder that redefines a given type, i.e. it replaces any redefined method with another implementation.
@@ -80,7 +80,7 @@ public RedefinitionDynamicTypeBuilder(ClassFileVersion classFileVersion,
                 auxiliaryTypeNamingStrategy,
                 implementationContextFactory,
                 InstrumentedType.TypeInitializer.None.INSTANCE,
-                joinUniqueRaw(interfaceTypes, originalType.getInterfaces()),
+                CompoundList.of(interfaceTypes, originalType.getInterfaces()),
                 modifiers,
                 attributeAppender,
                 ignoredMethods,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/SuperMethodCall.java
Patch:
@@ -9,8 +9,6 @@
 import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
 import org.objectweb.asm.MethodVisitor;
 
-import static net.bytebuddy.utility.ByteBuddyCommons.nonNull;
-
 /**
  * This implementation will create a new method which simply calls its super method. If no such method is defined,
  * an exception will be thrown. Constructors are considered to have a super method if the direct super class defines
@@ -40,7 +38,7 @@ public ByteCodeAppender appender(Target implementationTarget) {
 
     @Override
     public Implementation andThen(Implementation implementation) {
-        return new Compound(WithoutReturn.INSTANCE, nonNull(implementation));
+        return new Compound(WithoutReturn.INSTANCE, implementation);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/AllArguments.java
Patch:
@@ -10,13 +10,12 @@
 import net.bytebuddy.implementation.bytecode.assign.Assigner;
 import net.bytebuddy.implementation.bytecode.collection.ArrayFactory;
 import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
+import net.bytebuddy.utility.CompoundList;
 
 import java.lang.annotation.*;
 import java.util.ArrayList;
 import java.util.List;
 
-import static net.bytebuddy.utility.ByteBuddyCommons.join;
-
 /**
  * Parameters that are annotated with this annotation will be assigned a collection (or an array) containing
  * all arguments of the source method. Currently, this annotation supports the following collection types:
@@ -140,7 +139,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(source.getParameters().size() + (includeThis ? 1 : 0));
             int offset = source.isStatic() || includeThis ? 0 : 1;
             for (TypeDescription sourceParameter : includeThis
-                    ? join(implementationTarget.getInstrumentedType(), source.getParameters().asTypeList().asErasures())
+                    ? CompoundList.of(implementationTarget.getInstrumentedType(), source.getParameters().asTypeList().asErasures())
                     : source.getParameters().asTypeList().asErasures()) {
                 StackManipulation stackManipulation = new StackManipulation.Compound(
                         MethodVariableAccess.of(sourceParameter).loadOffset(offset),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -33,7 +33,6 @@
 import java.util.Collections;
 
 import static net.bytebuddy.matcher.ElementMatchers.*;
-import static net.bytebuddy.utility.ByteBuddyCommons.nonNull;
 
 /**
  * This annotation instructs Byte Buddy to inject a proxy class that calls a method's super method with
@@ -131,7 +130,7 @@ protected Binder(MethodDescription forwardingMethod) {
          * annotation.
          */
         public static TargetMethodAnnotationDrivenBinder.ParameterBinder<Morph> install(Class<?> type) {
-            return install(new TypeDescription.ForLoadedType(nonNull(type)));
+            return install(new TypeDescription.ForLoadedType(type));
         }
 
         /**
@@ -145,7 +144,7 @@ public static TargetMethodAnnotationDrivenBinder.ParameterBinder<Morph> install(
          * annotation.
          */
         public static TargetMethodAnnotationDrivenBinder.ParameterBinder<Morph> install(TypeDescription typeDescription) {
-            return new Binder(onlyMethod(nonNull(typeDescription)));
+            return new Binder(onlyMethod(typeDescription));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -35,7 +35,6 @@
 import java.util.Map;
 
 import static net.bytebuddy.matcher.ElementMatchers.*;
-import static net.bytebuddy.utility.ByteBuddyCommons.nonNull;
 
 /**
  * A target method parameter that is annotated with this annotation allows to forward an intercepted method
@@ -130,7 +129,7 @@ protected Binder(MethodDescription forwardingMethod) {
          * annotation.
          */
         public static TargetMethodAnnotationDrivenBinder.ParameterBinder<Pipe> install(Class<?> type) {
-            return install(new TypeDescription.ForLoadedType(nonNull(type)));
+            return install(new TypeDescription.ForLoadedType(type));
         }
 
         /**
@@ -144,7 +143,7 @@ public static TargetMethodAnnotationDrivenBinder.ParameterBinder<Pipe> install(C
          * annotation.
          */
         public static TargetMethodAnnotationDrivenBinder.ParameterBinder<Pipe> install(TypeDescription typeDescription) {
-            return new Binder(onlyMethod(nonNull(typeDescription)));
+            return new Binder(onlyMethod(typeDescription));
         }
 
         /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/TargetTypeTest.java
Patch:
@@ -1,6 +1,5 @@
 package net.bytebuddy.dynamic;
 
-import net.bytebuddy.utility.ByteBuddyCommons;
 import org.hamcrest.CoreMatchers;
 import org.junit.Test;
 
@@ -30,6 +29,6 @@ public void testConstructorIsHidden() throws Exception {
 
     @Test
     public void testTypeIsFinal() throws Exception {
-        assertThat(Modifier.isFinal(ByteBuddyCommons.class.getModifiers()), is(true));
+        assertThat(Modifier.isFinal(TargetType.class.getModifiers()), is(true));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionGenericOtherTest.java
Patch:
@@ -11,7 +11,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-public class TypeDefinitionTest {
+public class TypeDescriptionGenericOtherTest {
 
     @Test(expected = IllegalArgumentException.class)
     public void testUnknownType() throws Exception {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/ByteCodeElement.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.annotation.AnnotatedCodeElement;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.matcher.ElementMatcher;
 import net.bytebuddy.matcher.FilterableList;
 
@@ -122,7 +121,7 @@ interface Token<T extends Token<T>> {
          * @param visitor The visitor to transform all types that are represented by this token.
          * @return This token with all of its represented types transformed by the supplied visitor.
          */
-        T accept(GenericTypeDescription.Visitor<? extends GenericTypeDescription> visitor);
+        T accept(TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor);
 
         /**
          * A list of tokens.
@@ -151,7 +150,7 @@ public TokenList(List<? extends S> tokens) {
              * @param visitor The visitor to apply to all tokens.
              * @return A list containing the transformed tokens.
              */
-            public TokenList<S> accept(GenericTypeDescription.Visitor<? extends GenericTypeDescription> visitor) {
+            public TokenList<S> accept(TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
                 List<S> tokens = new ArrayList<S>(this.tokens.size());
                 for (S token : this.tokens) {
                     tokens.add(token.accept(visitor));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/TargetType.java
Patch:
@@ -1,7 +1,6 @@
 package net.bytebuddy.dynamic;
 
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 /**
  * This type is used as a place holder for creating methods or fields that refer to the type that currently subject
@@ -14,7 +13,7 @@ public final class TargetType {
      */
     public static final TypeDescription DESCRIPTION = new TypeDescription.ForLoadedType(TargetType.class);
 
-    public static final GenericTypeDescription GENERIC_DESCRIPTION = new GenericTypeDescription.ForNonGenericType.OfLoadedType(TargetType.class);
+    public static final TypeDescription.Generic GENERIC_DESCRIPTION = new TypeDescription.Generic.ForNonGenericType.OfLoadedType(TargetType.class);
 
     /**
      * An unusable constructor to avoid instance creation.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTarget.java
Patch:
@@ -3,7 +3,6 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bytecode.StackManipulation;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTarget.java
Patch:
@@ -4,7 +4,6 @@
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
 import net.bytebuddy.implementation.Implementation;
 
@@ -38,7 +37,7 @@ public class SubclassImplementationTarget extends Implementation.Target.Abstract
      */
     protected SubclassImplementationTarget(TypeDescription instrumentedType, MethodGraph.Linked methodGraph, OriginTypeResolver originTypeResolver) {
         super(instrumentedType, methodGraph);
-        GenericTypeDescription superType = instrumentedType.getSuperType();
+        TypeDescription.Generic superType = instrumentedType.getSuperType();
         MethodList<?> superConstructors = superType == null
                 ? new MethodList.Empty<MethodDescription.InGenericShape>()
                 : superType.getDeclaredMethods().filter(isConstructor().and(isVisibleTo(instrumentedType)));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -4,7 +4,6 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
@@ -50,7 +49,7 @@ public abstract class InvocationHandlerAdapter implements Implementation {
     /**
      * A type description of the {@link InvocationHandler}.
      */
-    private static final GenericTypeDescription INVOCATION_HANDLER_TYPE = new GenericTypeDescription.ForNonGenericType.OfLoadedType(InvocationHandler.class);
+    private static final TypeDescription.Generic INVOCATION_HANDLER_TYPE = new TypeDescription.Generic.ForNonGenericType.OfLoadedType(InvocationHandler.class);
 
     /**
      * The name of the field for storing an invocation handler.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionRawTypeMatcher.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 import java.util.LinkedList;
 import java.util.List;

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringFieldMatcher.java
Patch:
@@ -3,7 +3,6 @@
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.field.FieldList;
 import net.bytebuddy.description.type.TypeDefinition;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 /**
  * An element matcher that checks if a type description declares fields of a given property.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringMethodMatcher.java
Patch:
@@ -3,7 +3,6 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.type.TypeDefinition;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 /**
  * An element matcher that checks if a type description declares methods of a given property.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringTypeMatcher.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.description.DeclaredByType;
 import net.bytebuddy.description.type.TypeDefinition;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.TypeDescription;
 
 /**
  * An element matcher that matches the declaring type of another element, only if this element is actually declared
@@ -15,14 +15,14 @@ public class DeclaringTypeMatcher<T extends DeclaredByType> extends ElementMatch
     /**
      * The type matcher to be applied if the target element is declared in a type.
      */
-    private final ElementMatcher<? super GenericTypeDescription> typeMatcher;
+    private final ElementMatcher<? super TypeDescription.Generic> typeMatcher;
 
     /**
      * Creates a new matcher for the declaring type of an element.
      *
      * @param typeMatcher The type matcher to be applied if the target element is declared in a type.
      */
-    public DeclaringTypeMatcher(ElementMatcher<? super GenericTypeDescription> typeMatcher) {
+    public DeclaringTypeMatcher(ElementMatcher<? super TypeDescription.Generic> typeMatcher) {
         this.typeMatcher = typeMatcher;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/FieldTypeMatcher.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.field.FieldDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.TypeDescription;
 
 /**
  * An element matcher that matches a field's type.
@@ -13,14 +13,14 @@ public class FieldTypeMatcher<T extends FieldDescription> extends ElementMatcher
     /**
      * The type matcher to apply to the field's type.
      */
-    private final ElementMatcher<? super GenericTypeDescription> typeMatcher;
+    private final ElementMatcher<? super TypeDescription.Generic> typeMatcher;
 
     /**
      * Creates a new matcher for a matched field's type.
      *
      * @param typeMatcher The type matcher to apply to the matched field's type.
      */
-    public FieldTypeMatcher(ElementMatcher<? super GenericTypeDescription> typeMatcher) {
+    public FieldTypeMatcher(ElementMatcher<? super TypeDescription.Generic> typeMatcher) {
         this.typeMatcher = typeMatcher;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/LatentMethodMatcher.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 import static net.bytebuddy.matcher.ElementMatchers.representedBy;
 
@@ -85,7 +84,7 @@ public ForToken(MethodDescription.Token methodToken) {
         public ElementMatcher<? super MethodDescription> resolve(TypeDescription instrumentedType) {
             // Casting required for JDK 6.
             return (ElementMatcher<? super MethodDescription>) representedBy(methodToken
-                    .accept(GenericTypeDescription.Visitor.Substitutor.ForAttachment.of(instrumentedType)));
+                    .accept(TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(instrumentedType)));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodExceptionTypeMatcher.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.method.MethodDescription;
-import net.bytebuddy.description.type.generic.GenericTypeList;
+import net.bytebuddy.description.type.TypeList;
 
 /**
  * An element matcher that matches the exceptions that are declared by a method.
@@ -13,14 +13,14 @@ public class MethodExceptionTypeMatcher<T extends MethodDescription> extends Ele
     /**
      * The matcher to apply to the matched method's exceptions.
      */
-    private final ElementMatcher<? super GenericTypeList> exceptionMatcher;
+    private final ElementMatcher<? super TypeList.Generic> exceptionMatcher;
 
     /**
      * Creates a new matcher for a method's exceptions.
      *
      * @param exceptionMatcher The matcher to apply to the matched method's exceptions.
      */
-    public MethodExceptionTypeMatcher(ElementMatcher<? super GenericTypeList> exceptionMatcher) {
+    public MethodExceptionTypeMatcher(ElementMatcher<? super TypeList.Generic> exceptionMatcher) {
         this.exceptionMatcher = exceptionMatcher;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypeMatcher.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.method.ParameterDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.TypeDescription;
 
 /**
  * An element matcher that matches a method's parameter's type.
@@ -13,14 +13,14 @@ public class MethodParameterTypeMatcher<T extends ParameterDescription> extends
     /**
      * The matcher to apply to the type of the parameter.
      */
-    private final ElementMatcher<? super GenericTypeDescription> matcher;
+    private final ElementMatcher<? super TypeDescription.Generic> matcher;
 
     /**
      * Creates a new matcher for a method's parameter's type.
      *
      * @param matcher The matcher to apply to the type of the parameter.
      */
-    public MethodParameterTypeMatcher(ElementMatcher<? super GenericTypeDescription> matcher) {
+    public MethodParameterTypeMatcher(ElementMatcher<? super TypeDescription.Generic> matcher) {
         this.matcher = matcher;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypesMatcher.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.method.ParameterList;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.TypeDescription;
 
 import java.util.List;
 
@@ -15,14 +15,14 @@ public class MethodParameterTypesMatcher<T extends ParameterList<?>> extends Ele
     /**
      * The matcher to apply to the type of the parameter.
      */
-    private final ElementMatcher<? super List<? extends GenericTypeDescription>> matcher;
+    private final ElementMatcher<? super List<? extends TypeDescription.Generic>> matcher;
 
     /**
      * Creates a new matcher for a method's parameter types.
      *
      * @param matcher The matcher to apply to the type of the parameter.
      */
-    public MethodParameterTypesMatcher(ElementMatcher<? super List<? extends GenericTypeDescription>> matcher) {
+    public MethodParameterTypesMatcher(ElementMatcher<? super List<? extends TypeDescription.Generic>> matcher) {
         this.matcher = matcher;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodReturnTypeMatcher.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.method.MethodDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.TypeDescription;
 
 /**
  * An element matcher that matches its argument's return type against a given type matcher.
@@ -13,14 +13,14 @@ public class MethodReturnTypeMatcher<T extends MethodDescription> extends Elemen
     /**
      * The type matcher to apply to the matched element's return type.
      */
-    private final ElementMatcher<? super GenericTypeDescription> typeMatcher;
+    private final ElementMatcher<? super TypeDescription.Generic> typeMatcher;
 
     /**
      * Creates a new matcher for a matched element's return type.
      *
      * @param typeMatcher The type matcher to apply to the matched element's return type.
      */
-    public MethodReturnTypeMatcher(ElementMatcher<? super GenericTypeDescription> typeMatcher) {
+    public MethodReturnTypeMatcher(ElementMatcher<? super TypeDescription.Generic> typeMatcher) {
         this.typeMatcher = typeMatcher;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/RawTypeMatcher.java
Patch:
@@ -2,10 +2,9 @@
 
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 /**
- * An element matcher that matches its argument's {@link GenericTypeDescription} raw type against the
+ * An element matcher that matches its argument's {@link TypeDescription.Generic} raw type against the
  * given matcher for a {@link TypeDescription}. A wildcard is not matched but returns a negative result.
  *
  * @param <T> The type of the matched entity.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/TypeSortMatcher.java
Patch:
@@ -1,7 +1,6 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.type.TypeDefinition;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 /**
  * An element matcher that validates that a given generic type description represents a type of a given name.

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTest.java
Patch:
@@ -5,7 +5,6 @@
 import net.bytebuddy.description.modifier.ModifierContributor;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.attribute.FieldAttributeAppender;
@@ -53,7 +52,7 @@ public class ByteBuddyTest {
     private ElementMatcher<? super MethodDescription> methodMatcher;
 
     @Mock
-    private GenericTypeDescription interfaceType;
+    private TypeDescription.Generic interfaceType;
 
     @Mock
     private TypeDescription rawInterfaceType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/NamingStrategyTest.java
Patch:
@@ -1,7 +1,6 @@
 package net.bytebuddy;
 
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.test.utility.MockitoRule;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Before;
@@ -29,7 +28,7 @@ public class NamingStrategyTest {
     private NamingStrategy.SuffixingRandom.BaseNameResolver baseNameResolver;
 
     @Mock
-    private GenericTypeDescription genericSuperType;
+    private TypeDescription.Generic genericSuperType;
 
     @Mock
     private TypeDescription rawSuperType;
@@ -90,7 +89,7 @@ public void testFixedObjectProperties() throws Exception {
 
     @Test
     public void testPrefixingRandom() throws Exception {
-        when(unnamedType.getSuperClass()).thenReturn(GenericTypeDescription.OBJECT);
+        when(unnamedType.getSuperClass()).thenReturn(TypeDescription.Generic.OBJECT);
         NamingStrategy namingStrategy = new NamingStrategy.PrefixingRandom(FOO);
         assertThat(namingStrategy.name(unnamedType), startsWith(FOO + "." + Object.class.getName()));
         verify(unnamedType).getSuperClass();

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/ByteCodeElementTokenListTest.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.description;
 
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.test.utility.MockitoRule;
 import org.junit.Rule;
 import org.junit.Test;
@@ -22,7 +22,7 @@ public class ByteCodeElementTokenListTest {
     private ByteCodeElement.Token<?> original, transformed;
 
     @Mock
-    private GenericTypeDescription.Visitor<? extends GenericTypeDescription> visitor;
+    private TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor;
 
     @Test
     @SuppressWarnings("unchecked")

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/TypeVariableSourceVisitorNoOpTest.java
Patch:
@@ -1,8 +1,9 @@
-package net.bytebuddy.description.type.generic;
+package net.bytebuddy.description;
 
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
+import org.hamcrest.MatcherAssert;
 import org.junit.Test;
 
 import static org.hamcrest.CoreMatchers.is;
@@ -14,7 +15,7 @@ public class TypeVariableSourceVisitorNoOpTest {
     @Test
     public void testVisitType() throws Exception {
         TypeDescription typeDescription = mock(TypeDescription.class);
-        assertThat(TypeVariableSource.Visitor.NoOp.INSTANCE.onType(typeDescription), is((TypeVariableSource) typeDescription));
+        MatcherAssert.assertThat(TypeVariableSource.Visitor.NoOp.INSTANCE.onType(typeDescription), is((TypeVariableSource) typeDescription));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/AbstractFieldDescriptionTest.java
Patch:
@@ -3,7 +3,6 @@
 import net.bytebuddy.description.annotation.AnnotationList;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.test.packaging.VisibilityFieldTestHelper;
 import org.junit.Before;
 import org.junit.Test;

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/FieldDescriptionLatentTest.java
Patch:
@@ -3,7 +3,6 @@
 import net.bytebuddy.description.annotation.AnnotationList;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 import java.lang.reflect.Field;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/AbstractParameterListTest.java
Patch:
@@ -1,7 +1,6 @@
 package net.bytebuddy.description.method;
 
 import net.bytebuddy.description.type.TypeDefinition;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.matcher.AbstractFilterableListTest;
 import org.junit.Test;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTypeInitializerTest.java
Patch:
@@ -1,7 +1,6 @@
 package net.bytebuddy.description.method;
 
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.test.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -59,6 +58,6 @@ public void testParameters() throws Exception {
 
     @Test
     public void testReturnType() throws Exception {
-        assertThat(typeInitializer.getReturnType(), is(GenericTypeDescription.VOID));
+        assertThat(typeInitializer.getReturnType(), is(TypeDescription.Generic.VOID));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractGenericTypeListTest.java
Patch:
@@ -1,4 +1,4 @@
-package net.bytebuddy.description.type.generic;
+package net.bytebuddy.description.type;
 
 import net.bytebuddy.matcher.AbstractFilterableListTest;
 import org.junit.Test;
@@ -9,7 +9,7 @@
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 
-public abstract class AbstractGenericTypeListTest<U> extends AbstractFilterableListTest<GenericTypeDescription, GenericTypeList, U> {
+public abstract class AbstractGenericTypeListTest<U> extends AbstractFilterableListTest<TypeDescription.Generic, TypeList.Generic, U> {
 
     @Test
     public void testRawTypes() throws Exception {
@@ -19,7 +19,7 @@ public void testRawTypes() throws Exception {
 
     @Test
     public void testVisitor() throws Exception {
-        assertThat(asList(Collections.singletonList(getFirst())).accept(GenericTypeDescription.Visitor.NoOp.INSTANCE),
+        assertThat(asList(Collections.singletonList(getFirst())).accept(TypeDescription.Generic.Visitor.NoOp.INSTANCE),
                 is(asList(Collections.singletonList(getFirst()))));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeListTest.java
Patch:
@@ -1,7 +1,5 @@
 package net.bytebuddy.description.type;
 
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeList;
 import net.bytebuddy.matcher.AbstractFilterableListTest;
 import org.junit.Test;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/GenericSignatureResolutionTest.java
Patch:
@@ -1,9 +1,8 @@
-package net.bytebuddy.description.type.generic;
+package net.bytebuddy.description.type;
 
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.method.MethodDescription;
-import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.implementation.FixedValue;
@@ -194,7 +193,7 @@ public void testInterfaceType() throws Exception {
         TypeDescription createdType = new TypeDescription.ForLoadedType(type);
         TypeDescription originalType = new TypeDescription.ForLoadedType(InterfaceType.class);
         assertThat(createdType.getTypeVariables(), is(originalType.getTypeVariables()));
-        assertThat(createdType.getSuperType(), nullValue(GenericTypeDescription.class));
+        assertThat(createdType.getSuperType(), nullValue(TypeDescription.Generic.class));
         assertThat(createdType.getInterfaces(), is(originalType.getInterfaces()));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDefinitionSortTest.java
Patch:
@@ -19,6 +19,7 @@ public static Collection<Object[]> data() {
                 {TypeDefinition.Sort.NON_GENERIC, true, false, false, false, false},
                 {TypeDefinition.Sort.PARAMETERIZED, false, true, false, false, false},
                 {TypeDefinition.Sort.VARIABLE, false, false, true, false, false},
+                {TypeDefinition.Sort.VARIABLE_DETACHED, false, false, true, false, false},
                 {TypeDefinition.Sort.VARIABLE_SYMBOLIC, false, false, true, false, false},
                 {TypeDefinition.Sort.GENERIC_ARRAY, false, false, false, true, false},
                 {TypeDefinition.Sort.WILDCARD, false, false, false, false, true}

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionForLoadedTypeTest.java
Patch:
@@ -1,7 +1,6 @@
 package net.bytebuddy.description.type;
 
 import net.bytebuddy.description.method.MethodDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
@@ -14,12 +13,12 @@ protected TypeDescription describe(Class<?> type) {
     }
 
     @Override
-    protected GenericTypeDescription describe(Field field) {
+    protected TypeDescription.Generic describe(Field field) {
         return TypeDefinition.Sort.describe(field.getGenericType());
     }
 
     @Override
-    protected GenericTypeDescription describe(Method method) {
+    protected TypeDescription.Generic describe(Method method) {
         return new MethodDescription.ForLoadedMethod(method).getReturnType();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionForPackageDescriptionTest.java
Patch:
@@ -1,7 +1,6 @@
 package net.bytebuddy.description.type;
 
 import net.bytebuddy.description.annotation.AnnotationList;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.test.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -76,6 +75,6 @@ public void testPackage() throws Exception {
 
     @Test
     public void testSuperType() throws Exception {
-        assertThat(typeDescription.getSuperType(), is(GenericTypeDescription.OBJECT));
+        assertThat(typeDescription.getSuperType(), is(TypeDescription.Generic.OBJECT));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionLatentTest.java
Patch:
@@ -1,6 +1,5 @@
 package net.bytebuddy.description.type;
 
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.test.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -11,7 +10,6 @@
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.when;
 
 public class TypeDescriptionLatentTest {
@@ -24,7 +22,7 @@ public class TypeDescriptionLatentTest {
     public MockitoRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private GenericTypeDescription superType, interfaceType;
+    private TypeDescription.Generic superType, interfaceType;
 
     @Before
     public void setUp() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeListEmptyTest.java
Patch:
@@ -1,6 +1,5 @@
 package net.bytebuddy.description.type;
 
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import org.junit.Test;
 
 import static org.hamcrest.CoreMatchers.is;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultFrameComputingClassWriterTest.java
Patch:
@@ -1,7 +1,6 @@
 package net.bytebuddy.dynamic.scaffold;
 
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.pool.TypePool;
 import net.bytebuddy.test.utility.MockitoRule;
@@ -33,7 +32,7 @@ public class TypeWriterDefaultFrameComputingClassWriterTest {
     private TypeDescription leftType, rightType, superType;
 
     @Mock
-    private GenericTypeDescription genericSuperType;
+    private TypeDescription.Generic genericSuperType;
 
     private TypeWriter.Default.FrameComputingClassWriter frameComputingClassWriter;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverDefaultTest.java
Patch:
@@ -6,7 +6,6 @@
 import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
 import net.bytebuddy.test.utility.MockitoRule;
@@ -57,7 +56,7 @@ public class MethodRebaseResolverDefaultTest {
     public void setUp() throws Exception {
         when(methodDescription.asDefined()).thenReturn(methodDescription);
         when(methodDescription.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
-        when(methodDescription.getReturnType()).thenReturn(GenericTypeDescription.VOID);
+        when(methodDescription.getReturnType()).thenReturn(TypeDescription.Generic.VOID);
         when(methodDescription.getInternalName()).thenReturn(FOO);
         when(methodNameTransformer.transform(methodDescription)).thenReturn(BAR);
         when(auxiliaryTypeNamingStrategy.name(instrumentedType)).thenReturn(QUX);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTargetFactoryTest.java
Patch:
@@ -3,7 +3,6 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.test.utility.MockitoRule;
@@ -33,7 +32,7 @@ public class RebaseImplementationTargetFactoryTest {
     private TypeDescription instrumentedType;
 
     @Mock
-    private GenericTypeDescription superType;
+    private TypeDescription.Generic superType;
 
     private Implementation.Target.Factory factory;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTargetTest.java
Patch:
@@ -6,7 +6,6 @@
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
 import net.bytebuddy.implementation.AbstractImplementationTargetTest;
 import net.bytebuddy.implementation.Implementation;
@@ -46,7 +45,7 @@ public class RebaseImplementationTargetTest extends AbstractImplementationTarget
     private TypeDescription superType;
 
     @Mock
-    private GenericTypeDescription genericSuperType;
+    private TypeDescription.Generic genericSuperType;
 
     @Override
     @Before

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategyDefaultTest.java
Patch:
@@ -3,7 +3,7 @@
 import net.bytebuddy.description.ByteCodeElement;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.MethodList;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.MethodTransformer;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.dynamic.scaffold.MethodRegistry;
@@ -40,7 +40,7 @@ public class ConstructorStrategyDefaultTest {
     private InstrumentedType instrumentedType;
 
     @Mock
-    private GenericTypeDescription superType;
+    private TypeDescription.Generic superType;
 
     @Mock
     private MethodList<?> methodList, filteredMethodList;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTargetFactoryTest.java
Patch:
@@ -4,7 +4,6 @@
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.test.utility.MockitoRule;
@@ -31,7 +30,7 @@ public class SubclassImplementationTargetFactoryTest {
     private TypeDescription instrumentedType, superType;
 
     @Mock
-    private GenericTypeDescription genericSuperType;
+    private TypeDescription.Generic genericSuperType;
 
     private Implementation.Target.Factory factory;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/AbstractImplementationTargetTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.StackSize;
@@ -34,7 +33,7 @@ public abstract class AbstractImplementationTargetTest {
     protected TypeDescription instrumentedType, methodDeclaringType, returnType, defaultMethodDeclaringType;
 
     @Mock
-    protected GenericTypeDescription genericInstrumentedType, genericReturnType;
+    protected TypeDescription.Generic genericInstrumentedType, genericReturnType;
 
     @Mock
     protected MethodDescription.InDefinedShape invokableMethod, defaultMethod;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/FieldAccessorPreparationTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.test.utility.MockitoRule;
 import org.junit.Before;
@@ -37,7 +36,7 @@ public void setUp() throws Exception {
     @Test
     public void testPreparationDefineField() throws Exception {
         assertThat(FieldAccessor.ofField(FOO).defineAs(TYPE).prepare(instrumentedType), is(instrumentedType));
-        verify(instrumentedType).withField(new FieldDescription.Token(FOO, NO_MODIFIERS, new GenericTypeDescription.ForNonGenericType.OfLoadedType(TYPE)));
+        verify(instrumentedType).withField(new FieldDescription.Token(FOO, NO_MODIFIERS, new TypeDescription.Generic.ForNonGenericType.OfLoadedType(TYPE)));
         verify(instrumentedType).isInterface();
         verifyNoMoreInteractions(instrumentedType);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/SuperMethodCallOtherTest.java
Patch:
@@ -5,7 +5,6 @@
 import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.implementation.bytecode.StackSize;
@@ -56,7 +55,7 @@ public class SuperMethodCallOtherTest extends AbstractImplementationTest {
     private TypeDescription typeDescription, superType, returnType, declaringType;
 
     @Mock
-    private GenericTypeDescription genericSuperType, genericReturnType;
+    private TypeDescription.Generic genericSuperType, genericReturnType;
 
     @Mock
     private Implementation.Target implementationTarget;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/MethodAttributeAppenderForInstrumentedMethodTest.java
Patch:
@@ -6,7 +6,6 @@
 import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -28,7 +27,7 @@ public void testMethodAnnotations() throws Exception {
         when(methodDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList
                 .ForLoadedAnnotation(new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()));
         when(methodDescription.getParameters()).thenReturn((ParameterList) new ParameterList.Empty<ParameterDescription>());
-        when(methodDescription.getDeclaringType()).thenReturn(mock(GenericTypeDescription.class));
+        when(methodDescription.getDeclaringType()).thenReturn(mock(TypeDescription.Generic.class));
         MethodAttributeAppender methodAttributeAppender = new MethodAttributeAppender.ForInstrumentedMethod(valueFilter).make(instrumentedType);
         methodAttributeAppender.apply(methodVisitor, methodDescription);
         verify(methodVisitor).visitAnnotation(Type.getDescriptor(Baz.class), true);
@@ -50,7 +49,7 @@ public void testMethodParameterAnnotations() throws Exception {
                 .thenReturn(new AnnotationList.ForLoadedAnnotation(new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()));
         when(methodDescription.getParameters())
                 .thenReturn((ParameterList) new ParameterList.Explicit<ParameterDescription>(Collections.singletonList(parameterDescription)));
-        when(methodDescription.getDeclaringType()).thenReturn(mock(GenericTypeDescription.class));
+        when(methodDescription.getDeclaringType()).thenReturn(mock(TypeDescription.Generic.class));
         MethodAttributeAppender methodAttributeAppender = new MethodAttributeAppender.ForInstrumentedMethod(valueFilter).make(instrumentedType);
         methodAttributeAppender.apply(methodVisitor, methodDescription);
         verify(methodVisitor).visitParameterAnnotation(0, Type.getDescriptor(Baz.class), true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/TypeAttributeAppenderCompoundTest.java
Patch:
@@ -15,10 +15,10 @@ public class TypeAttributeAppenderCompoundTest extends AbstractTypeAttributeAppe
     @Test
     public void testApplication() throws Exception {
         TypeAttributeAppender typeAttributeAppender = new TypeAttributeAppender.Compound(first, second);
-        typeAttributeAppender.apply(classVisitor, typeDescription, targetType);
-        verify(first).apply(classVisitor, typeDescription, targetType);
+        typeAttributeAppender.apply(classVisitor, rawTypeDescription, targetType);
+        verify(first).apply(classVisitor, rawTypeDescription, targetType);
         verifyNoMoreInteractions(first);
-        verify(second).apply(classVisitor, typeDescription, targetType);
+        verify(second).apply(classVisitor, rawTypeDescription, targetType);
         verifyNoMoreInteractions(second);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/TypeAttributeAppenderForTypeTest.java
Patch:
@@ -14,10 +14,10 @@ public class TypeAttributeAppenderForTypeTest extends AbstractTypeAttributeAppen
     @Test
     public void testTypeAnnotation() throws Exception {
         TypeAttributeAppender fieldAttributeAppender = new TypeAttributeAppender.ForType(FooBar.class, valueFilter);
-        fieldAttributeAppender.apply(classVisitor, typeDescription, targetType);
+        fieldAttributeAppender.apply(classVisitor, rawTypeDescription, targetType);
         verify(classVisitor).visitAnnotation(Type.getDescriptor(Baz.class), true);
         verifyNoMoreInteractions(classVisitor);
-        verifyZeroInteractions(typeDescription);
+        verifyZeroInteractions(rawTypeDescription);
         verifyZeroInteractions(targetType);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/AbstractArgumentTypeResolverTest.java
Patch:
@@ -3,7 +3,6 @@
 import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import org.hamcrest.BaseMatcher;
 import org.hamcrest.CoreMatchers;
 import org.hamcrest.Description;
@@ -30,7 +29,7 @@ public class AbstractArgumentTypeResolverTest extends AbstractAmbiguityResolverT
     protected TypeDescription sourceType;
 
     @Mock
-    protected GenericTypeDescription genericSourceType;
+    protected TypeDescription.Generic genericSourceType;
 
     @Mock
     private ParameterDescription sourceParameter;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/ArgumentTypeResolverReferenceTest.java
Patch:
@@ -3,7 +3,6 @@
 import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Before;
 import org.junit.Test;
@@ -20,7 +19,7 @@ public class ArgumentTypeResolverReferenceTest extends AbstractArgumentTypeResol
     private TypeDescription weakTargetType, dominantTargetType;
 
     @Mock
-    private GenericTypeDescription genericWeakTargetType, genericDominantTargetType;
+    private TypeDescription.Generic genericWeakTargetType, genericDominantTargetType;
 
     @Mock
     private ParameterDescription weakTargetParameter, dominantTargetParameter;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/MethodBindingBuilderTest.java
Patch:
@@ -3,7 +3,6 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
@@ -47,7 +46,7 @@ public class MethodBindingBuilderTest {
     private MethodVisitor methodVisitor;
 
     @Mock
-    private GenericTypeDescription returnType;
+    private TypeDescription.Generic returnType;
 
     @Mock(answer = Answers.RETURNS_MOCKS)
     private StackManipulation legalStackManipulation, illegalStackManipulation;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/AbstractAnnotationBinderTest.java
Patch:
@@ -7,8 +7,6 @@
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeList;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.assign.Assigner;
@@ -60,7 +58,7 @@ public abstract class AbstractAnnotationBinderTest<T extends Annotation> extends
     protected ParameterList<?> sourceParameterList;
 
     @Mock
-    protected GenericTypeList sourceTypeList;
+    protected TypeList.Generic sourceTypeList;
 
     @Mock
     protected TypeList rawSourceTypeList;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/AllArgumentsBinderTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.annotation.AnnotationList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bind.MethodDelegationBinder;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
@@ -33,7 +32,7 @@ public class AllArgumentsBinderTest extends AbstractAnnotationBinderTest<AllArgu
     private TypeDescription targetType, componentType;
 
     @Mock
-    private GenericTypeDescription genericTargetType;
+    private TypeDescription.Generic genericTargetType;
 
     public AllArgumentsBinderTest() {
         super(AllArguments.class);
@@ -150,7 +149,7 @@ public void testLegalSlackBinding() throws Exception {
     @Test(expected = IllegalStateException.class)
     public void testNonArrayTypeBinding() throws Exception {
         when(target.getIndex()).thenReturn(0);
-        GenericTypeDescription targetType = mock(GenericTypeDescription.class);
+        TypeDescription.Generic targetType = mock(TypeDescription.Generic.class);
         TypeDescription rawTargetType = mock(TypeDescription.class);
         when(targetType.asErasure()).thenReturn(rawTargetType);
         when(targetType.isArray()).thenReturn(false);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/EmptyBinderTest.java
Patch:
@@ -1,7 +1,6 @@
 package net.bytebuddy.implementation.bind.annotation;
 
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import org.junit.Test;
@@ -21,7 +20,7 @@
 @RunWith(Parameterized.class)
 public class EmptyBinderTest extends AbstractAnnotationBinderTest<Empty> {
 
-    private final GenericTypeDescription typeDescription;
+    private final TypeDescription.Generic typeDescription;
 
     private final int opcode;
 
@@ -33,7 +32,7 @@ public class EmptyBinderTest extends AbstractAnnotationBinderTest<Empty> {
 
     public EmptyBinderTest(Class<?> type, int opcode) {
         super(Empty.class);
-        typeDescription = new GenericTypeDescription.ForNonGenericType.OfLoadedType(type);
+        typeDescription = new TypeDescription.Generic.ForNonGenericType.OfLoadedType(type);
         this.opcode = opcode;
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldValueBinderTest.java
Patch:
@@ -4,7 +4,6 @@
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.field.FieldList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.bind.MethodDelegationBinder;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Before;
@@ -26,7 +25,7 @@ public class FieldValueBinderTest extends AbstractAnnotationBinderTest<FieldValu
     private FieldDescription.InDefinedShape fieldDescription;
 
     @Mock
-    private GenericTypeDescription fieldType, targetType;
+    private TypeDescription.Generic fieldType, targetType;
 
     @Mock
     private TypeDescription rawFieldType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/OriginBinderTest.java
Patch:
@@ -3,7 +3,6 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.bind.MethodDelegationBinder;
 import net.bytebuddy.test.utility.JavaVersionRule;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
@@ -32,7 +31,7 @@ public class OriginBinderTest extends AbstractAnnotationBinderTest<Origin> {
     private TypeDescription targetType;
 
     @Mock
-    private GenericTypeDescription genericTargetType;
+    private TypeDescription.Generic genericTargetType;
 
     @Mock
     private MethodDescription.InDefinedShape methodDescription;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/PipeBinderTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.bind.MethodDelegationBinder;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Before;
@@ -25,7 +24,7 @@ public class PipeBinderTest extends AbstractAnnotationBinderTest<Pipe> {
     private TypeDescription targetMethodType;
 
     @Mock
-    private GenericTypeDescription genericTargetMethodType;
+    private TypeDescription.Generic genericTargetMethodType;
 
     public PipeBinderTest() {
         super(Pipe.class);
@@ -70,7 +69,7 @@ public void testCannotPipeStaticMethod() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testParameterBindingOnIllegalTargetTypeThrowsException() throws Exception {
-        GenericTypeDescription targetType = mock(GenericTypeDescription.class);
+        TypeDescription.Generic targetType = mock(TypeDescription.Generic.class);
         TypeDescription rawTargetType = mock(TypeDescription.class);
         when(targetType.asErasure()).thenReturn(rawTargetType);
         when(target.getType()).thenReturn(targetType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/SuperBinderTest.java
Patch:
@@ -1,7 +1,6 @@
 package net.bytebuddy.implementation.bind.annotation;
 
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.bind.MethodDelegationBinder;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Before;
@@ -18,7 +17,7 @@ public class SuperBinderTest extends AbstractAnnotationBinderTest<Super> {
     private TypeDescription targetType;
 
     @Mock
-    private GenericTypeDescription genericTargetType;
+    private TypeDescription.Generic genericTargetType;
 
     @Mock
     private Super.Instantiation instantiation;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/SuperCallBinderTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bind.MethodDelegationBinder;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
@@ -20,7 +19,7 @@ public class SuperCallBinderTest extends AbstractAnnotationBinderTest<SuperCall>
     private TypeDescription targetParameterType;
 
     @Mock
-    private GenericTypeDescription genericTargetParameterType;
+    private TypeDescription.Generic genericTargetParameterType;
 
     @Mock
     private Implementation.SpecialMethodInvocation specialMethodInvocation;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinderTerminationHandlerDroppingTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.bytecode.Removal;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.StackSize;
@@ -33,7 +32,7 @@ public class TargetMethodAnnotationDrivenBinderTerminationHandlerDroppingTest {
     private TypeDescription targetType;
 
     @Mock
-    private GenericTypeDescription genericTargetType;
+    private TypeDescription.Generic genericTargetType;
 
     @Before
     public void setUp() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinderTerminationHandlerReturningTest.java
Patch:
@@ -3,7 +3,6 @@
 import net.bytebuddy.description.annotation.AnnotationList;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.assign.Assigner;
 import net.bytebuddy.implementation.bytecode.member.MethodReturn;
@@ -36,7 +35,7 @@ public class TargetMethodAnnotationDrivenBinderTerminationHandlerReturningTest {
     private TypeDescription sourceType, targetType;
 
     @Mock
-    private GenericTypeDescription genericSourceType, genericTargetType;
+    private TypeDescription.Generic genericSourceType, genericTargetType;
 
     @Mock
     private StackManipulation stackManipulation;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinderTest.java
Patch:
@@ -6,7 +6,6 @@
 import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bind.MethodDelegationBinder;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
@@ -62,7 +61,7 @@ public class TargetMethodAnnotationDrivenBinderTest {
     private MethodDescription sourceMethod, targetMethod;
 
     @Mock
-    private GenericTypeDescription sourceTypeDescription, targetTypeDescription;
+    private TypeDescription.Generic sourceTypeDescription, targetTypeDescription;
 
     @Mock
     private AnnotationDescription.ForLoadedAnnotation<FirstPseudoAnnotation> firstPseudoAnnotation;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ThisBinderTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.annotation.AnnotationList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.bind.MethodDelegationBinder;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.assign.Assigner;
@@ -21,7 +20,7 @@ public class ThisBinderTest extends AbstractAnnotationBinderTest<This> {
     private TypeDescription parameterType;
 
     @Mock
-    private GenericTypeDescription genericParameterType;
+    private TypeDescription.Generic genericParameterType;
 
     public ThisBinderTest() {
         super(This.class);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/FieldConstantTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.StackSize;
@@ -37,7 +36,7 @@ public class FieldConstantTest {
     private TypeDescription declaringType, cacheDeclaringType, cacheFieldType;
 
     @Mock
-    private GenericTypeDescription genericCacheFieldType;
+    private TypeDescription.Generic genericCacheFieldType;
 
     @Mock
     private MethodVisitor methodVisitor;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/FieldAccessOtherTest.java
Patch:
@@ -4,7 +4,6 @@
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.field.FieldList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.assign.TypeCasting;
 import net.bytebuddy.test.utility.MockitoRule;
@@ -33,7 +32,7 @@ public class FieldAccessOtherTest {
     private EnumerationDescription enumerationDescription;
 
     @Mock
-    private GenericTypeDescription genericType, declaredType;
+    private TypeDescription.Generic genericType, declaredType;
 
     @Mock
     private TypeDescription enumerationType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/FieldAccessTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.StackSize;
@@ -48,7 +47,7 @@ public class FieldAccessTest {
     private TypeDescription declaringType, fieldType;
 
     @Mock
-    private GenericTypeDescription genericFieldType;
+    private TypeDescription.Generic genericFieldType;
 
     @Mock
     private MethodVisitor methodVisitor;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationGenericTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.assign.TypeCasting;
 import net.bytebuddy.test.utility.MockitoRule;
@@ -33,7 +32,7 @@ public class MethodInvocationGenericTest {
     private MethodDescription methodDescription;
 
     @Mock
-    private GenericTypeDescription methodReturnType, declaredReturnType;
+    private TypeDescription.Generic methodReturnType, declaredReturnType;
 
     @Mock
     private TypeDescription declaredErasure, declaringType, targetType, otherType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.StackSize;
@@ -43,7 +42,7 @@ public class MethodInvocationTest {
     private MethodDescription.InDefinedShape methodDescription;
 
     @Mock
-    private GenericTypeDescription returnType, otherType;
+    private TypeDescription.Generic returnType, otherType;
 
     @Mock
     private TypeDescription declaringType, rawOtherType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/CollectionRawTypeMatcherTest.java
Patch:
@@ -3,7 +3,6 @@
 
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/DeclaringTypeMatcherTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.DeclaredByType;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -14,13 +13,13 @@
 public class DeclaringTypeMatcherTest extends AbstractElementMatcherTest<DeclaringTypeMatcher<?>> {
 
     @Mock
-    private ElementMatcher<? super GenericTypeDescription> typeMatcher;
+    private ElementMatcher<? super TypeDescription.Generic> typeMatcher;
 
     @Mock
     private DeclaredByType declaredByType;
 
     @Mock
-    private GenericTypeDescription typeDescription;
+    private TypeDescription.Generic typeDescription;
 
     @SuppressWarnings("unchecked")
     public DeclaringTypeMatcherTest() {

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/FieldTypeMatcherTest.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.field.FieldDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.TypeDescription;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -13,10 +13,10 @@
 public class FieldTypeMatcherTest extends AbstractElementMatcherTest<FieldTypeMatcher<?>> {
 
     @Mock
-    private ElementMatcher<? super GenericTypeDescription> typeMatcher;
+    private ElementMatcher<? super TypeDescription.Generic> typeMatcher;
 
     @Mock
-    private GenericTypeDescription fieldType;
+    private TypeDescription.Generic fieldType;
 
     @Mock
     private FieldDescription fieldDescription;

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/LatentMethodMatcherForTokenTest.java
Patch:
@@ -3,7 +3,6 @@
 
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.test.utility.MockitoRule;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Before;
@@ -34,7 +33,7 @@ public class LatentMethodMatcherForTokenTest {
     @Before
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
-        when(methodToken.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(methodToken);
+        when(methodToken.accept(any(TypeDescription.Generic.Visitor.class))).thenReturn(methodToken);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/MethodParameterTypeMatcherTest.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.method.ParameterDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.TypeDescription;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -13,10 +13,10 @@
 public class MethodParameterTypeMatcherTest extends AbstractElementMatcherTest<MethodParameterTypeMatcher<?>> {
 
     @Mock
-    private ElementMatcher<? super GenericTypeDescription> parameterMatcher;
+    private ElementMatcher<? super TypeDescription.Generic> parameterMatcher;
 
     @Mock
-    private GenericTypeDescription typeDescription;
+    private TypeDescription.Generic typeDescription;
 
     @Mock
     private ParameterDescription parameterDescription;

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/MethodReturnTypeMatcherTest.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.method.MethodDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.TypeDescription;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -13,10 +13,10 @@
 public class MethodReturnTypeMatcherTest extends AbstractElementMatcherTest<MethodReturnTypeMatcher<?>> {
 
     @Mock
-    private ElementMatcher<? super GenericTypeDescription> typeMatcher;
+    private ElementMatcher<? super TypeDescription.Generic> typeMatcher;
 
     @Mock
-    private GenericTypeDescription returnType;
+    private TypeDescription.Generic returnType;
 
     @Mock
     private MethodDescription methodDescription;

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/RawTypeMatcherTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultComponentTypeLocatorTest.java
Patch:
@@ -3,7 +3,6 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.RandomString;
 import org.junit.Test;
@@ -33,7 +32,7 @@ public void testForAnnotationProperty() throws Exception {
         when(typeDescription.getDeclaredMethods())
                 .thenReturn(new MethodList.Explicit<MethodDescription.InDefinedShape>(Collections.singletonList(methodDescription)));
         when(methodDescription.getSourceCodeName()).thenReturn(FOO);
-        GenericTypeDescription returnType = mock(GenericTypeDescription.class);
+        TypeDescription.Generic returnType = mock(TypeDescription.Generic.class);
         TypeDescription rawReturnType = mock(TypeDescription.class);
         when(returnType.asErasure()).thenReturn(rawReturnType);
         when(methodDescription.getReturnType()).thenReturn(returnType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultTypeDescriptionTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.type.AbstractTypeDescriptionTest;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 
 import java.lang.reflect.Field;
@@ -25,12 +24,12 @@ protected TypeDescription describe(Class<?> type) {
     }
 
     @Override
-    protected GenericTypeDescription describe(Field field) {
+    protected TypeDescription.Generic describe(Field field) {
         return describe(field.getDeclaringClass()).getDeclaredFields().filter(is(field)).getOnly().getType();
     }
 
     @Override
-    protected GenericTypeDescription describe(Method method) {
+    protected TypeDescription.Generic describe(Method method) {
         return describe(method.getDeclaringClass()).getDeclaredMethods().filter(is(method)).getOnly().getReturnType();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyFacadeTypeDescriptionTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.bytebuddy.description.type.AbstractTypeDescriptionTest;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 
 import java.lang.reflect.Field;
@@ -25,12 +24,12 @@ protected TypeDescription describe(Class<?> type) {
     }
 
     @Override
-    protected GenericTypeDescription describe(Field field) {
+    protected TypeDescription.Generic describe(Field field) {
         return describe(field.getDeclaringClass()).getDeclaredFields().filter(is(field)).getOnly().getType();
     }
 
     @Override
-    protected GenericTypeDescription describe(Method method) {
+    protected TypeDescription.Generic describe(Method method) {
         return describe(method.getDeclaringClass()).getDeclaredMethods().filter(is(method)).getOnly().getReturnType();
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -245,7 +245,7 @@ interface InGenericShape extends MethodDescription {
         GenericTypeDescription getDeclaringType();
 
         @Override
-        ParameterList<? extends ParameterDescription.InGenericShape> getParameters();
+        ParameterList<ParameterDescription.InGenericShape> getParameters();
     }
 
     /**
@@ -1160,7 +1160,7 @@ public GenericTypeDescription getReturnType() {
         }
 
         @Override
-        public ParameterList<? extends ParameterDescription.InGenericShape> getParameters() {
+        public ParameterList<ParameterDescription.InGenericShape> getParameters() {
             return new ParameterList.TypeSubstituting(this, methodDescription.getParameters(), new VariableRetainingDelegator());
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTargetFactoryTest.java
Patch:
@@ -39,7 +39,7 @@ public class SubclassImplementationTargetFactoryTest {
     public void setUp() throws Exception {
         when(instrumentedType.getSuperType()).thenReturn(genericSuperType);
         when(genericSuperType.asErasure()).thenReturn(superType); // TODO
-        when(superType.getDeclaredMethods()).thenReturn(new MethodList.Empty<MethodDescription.InDefinedShape>());
+        when(genericSuperType.getDeclaredMethods()).thenReturn(new MethodList.Empty<MethodDescription.InGenericShape>());
         factory = new SubclassImplementationTarget.Factory(SubclassImplementationTarget.OriginTypeResolver.SUPER_TYPE);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDefaultTest.java
Patch:
@@ -179,12 +179,14 @@ public void setUp() throws Exception {
         when(firstFieldType.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(firstFieldType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(firstFieldType);
         when(firstFieldType.asErasure()).thenReturn(firstRawFieldType);
+        when(firstFieldType.asRawType()).thenReturn(firstFieldType);
         when(firstRawFieldType.asGenericType()).thenReturn(firstFieldType);
         when(firstRawFieldType.getDescriptor()).thenReturn(BAR);
         when(secondFieldType.getStackSize()).thenReturn(StackSize.ZERO);
         when(secondFieldType.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(secondFieldType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(secondFieldType);
         when(secondFieldType.asErasure()).thenReturn(secondRawFieldType);
+        when(secondFieldType.asRawType()).thenReturn(secondFieldType);
         when(secondRawFieldType.asGenericType()).thenReturn(secondFieldType);
         when(secondRawFieldType.getDescriptor()).thenReturn(QUX);
         when(injectedCode.getByteCodeAppender()).thenReturn(injectedCodeAppender);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategy.java
Patch:
@@ -130,7 +130,7 @@ public List<MethodDescription.Token> extractConstructors(TypeDescription instrum
                 GenericTypeDescription superType = instrumentedType.getSuperType();
                 return (superType == null
                         ? new MethodList.Empty<MethodDescription.InGenericShape>()
-                        : superType.asErasure().getDeclaredMethods().filter(isPublic().and(isConstructor()))).asTokenList();
+                        : superType.getDeclaredMethods().filter(isPublic().and(isConstructor()))).asTokenList();
             }
 
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/MethodTransformerSimpleTest.java
Patch:
@@ -81,8 +81,8 @@ public void setUp() throws Exception {
         when(methodToken.getInternalName()).thenReturn(FOO);
         when(methodToken.getModifiers()).thenReturn(MODIFIERS);
         when(methodToken.getReturnType()).thenReturn(returnType);
-        when(methodToken.getTypeVariables()).thenReturn(new GenericTypeList.Explicit(Collections.singletonList(typeVariable)));
-        when(methodToken.getExceptionTypes()).thenReturn(new GenericTypeList.Explicit(Collections.singletonList(exceptionType)));
+        when(methodToken.getTypeVariables()).thenReturn(new GenericTypeList.Explicit(typeVariable));
+        when(methodToken.getExceptionTypes()).thenReturn(new GenericTypeList.Explicit(exceptionType));
         when(methodToken.getParameterTokens())
                 .thenReturn(new ByteCodeElement.Token.TokenList<ParameterDescription.Token>(Collections.singletonList(parameterToken)));
         when(methodToken.getAnnotations()).thenReturn(new AnnotationList.Explicit(Collections.singletonList(methodAnnotation)));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilderTest.java
Patch:
@@ -161,7 +161,7 @@ public List<?> create() {
             public TypeDescription create() {
                 TypeDescription typeDescription = mock(TypeDescription.class);
                 when(typeDescription.asErasure()).thenReturn(typeDescription);
-                when(typeDescription.getInterfaces()).thenReturn(new GenericTypeList.Explicit(Collections.singletonList(typeDescription)));
+                when(typeDescription.getInterfaces()).thenReturn(new GenericTypeList.Explicit(typeDescription));
                 when(typeDescription.getDeclaredFields()).thenReturn(new FieldList.Empty<FieldDescription.InDefinedShape>());
                 when(typeDescription.getDeclaredMethods()).thenReturn(new MethodList.Empty<MethodDescription.InDefinedShape>());
                 return typeDescription;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilderTest.java
Patch:
@@ -134,7 +134,7 @@ public List<?> create() {
             public TypeDescription create() {
                 TypeDescription typeDescription = mock(TypeDescription.class);
                 when(typeDescription.asErasure()).thenReturn(typeDescription);
-                when(typeDescription.getInterfaces()).thenReturn(new GenericTypeList.Explicit(Collections.singletonList(typeDescription)));
+                when(typeDescription.getInterfaces()).thenReturn(new GenericTypeList.Explicit(typeDescription));
                 when(typeDescription.getDeclaredFields()).thenReturn(new FieldList.Empty<FieldDescription.InDefinedShape>());
                 when(typeDescription.getDeclaredMethods()).thenReturn(new MethodList.Empty<MethodDescription.InDefinedShape>());
                 return typeDescription;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDefaultTest.java
Patch:
@@ -157,8 +157,8 @@ public ImplementationContextDefaultTest(boolean interfaceType, int accessorMetho
     @Before
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
-        firstSpecialExceptionTypes = new GenericTypeList.Explicit(Collections.singletonList(firstSpecialExceptionType));
-        secondSpecialExceptionTypes = new GenericTypeList.Explicit(Collections.singletonList(secondSpecialExceptionType));
+        firstSpecialExceptionTypes = new GenericTypeList.Explicit(firstSpecialExceptionType);
+        secondSpecialExceptionTypes = new GenericTypeList.Explicit(secondSpecialExceptionType);
         when(instrumentedType.getInternalName()).thenReturn(BAZ);
         when(instrumentedType.asErasure()).thenReturn(instrumentedType);
         when(instrumentedType.isInterface()).thenReturn(interfaceType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/DefaultCallBinderTest.java
Patch:
@@ -12,7 +12,6 @@
 import org.mockito.Mock;
 
 import java.io.Serializable;
-import java.util.Arrays;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -63,7 +62,7 @@ public void testImplicitLookupIsUnique() throws Exception {
         doReturn(VOID_TYPE).when(annotation).targetType();
         when(source.asToken()).thenReturn(methodToken);
         when(source.isSpecializableFor(firstInterface)).thenReturn(true);
-        when(instrumentedType.getInterfaces()).thenReturn(new GenericTypeList.Explicit(Arrays.asList(firstInterface, secondInterface)));
+        when(instrumentedType.getInterfaces()).thenReturn(new GenericTypeList.Explicit(firstInterface, secondInterface));
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = DefaultCall.Binder.INSTANCE
                 .bind(annotationDescription, source, target, implementationTarget, assigner);
         assertThat(parameterBinding.isValid(), is(true));
@@ -80,7 +79,7 @@ public void testImplicitLookupIsAmbiguous() throws Exception {
         when(source.asToken()).thenReturn(methodToken);
         when(source.isSpecializableFor(firstInterface)).thenReturn(true);
         when(source.isSpecializableFor(secondInterface)).thenReturn(true);
-        when(instrumentedType.getInterfaces()).thenReturn(new GenericTypeList.Explicit(Arrays.asList(firstInterface, secondInterface)));
+        when(instrumentedType.getInterfaces()).thenReturn(new GenericTypeList.Explicit(firstInterface, secondInterface));
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = DefaultCall.Binder.INSTANCE
                 .bind(annotationDescription, source, target, implementationTarget, assigner);
         assertThat(parameterBinding.isValid(), is(false));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/AllArgumentsBinderTest.java
Patch:
@@ -73,7 +73,7 @@ private void testLegalStrictBinding(boolean dynamicallyTyped, Annotation... targ
         when(stackManipulation.isValid()).thenReturn(true);
         when(rawSourceTypeList.iterator()).thenReturn(Arrays.asList(firstSourceType, secondSourceType).iterator());
         when(source.isStatic()).thenReturn(false);
-        when(targetType.isArray()).thenReturn(true);
+        when(genericTargetType.isArray()).thenReturn(true);
         when(targetType.getComponentType()).thenReturn(componentType);
         when(componentType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(target.getType()).thenReturn(genericTargetType);
@@ -97,7 +97,7 @@ public void testIllegalBinding() throws Exception {
         when(stackManipulation.isValid()).thenReturn(false);
         when(rawSourceTypeList.iterator()).thenReturn(Arrays.asList(firstSourceType, secondSourceType).iterator());
         when(source.isStatic()).thenReturn(false);
-        when(targetType.isArray()).thenReturn(true);
+        when(genericTargetType.isArray()).thenReturn(true);
         when(targetType.getComponentType()).thenReturn(componentType);
         when(componentType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(target.getType()).thenReturn(genericTargetType);
@@ -120,7 +120,7 @@ public void testLegalSlackBinding() throws Exception {
         when(stackManipulation.isValid()).thenReturn(false);
         when(rawSourceTypeList.iterator()).thenReturn(Arrays.asList(firstSourceType, secondSourceType).iterator());
         when(source.isStatic()).thenReturn(false);
-        when(targetType.isArray()).thenReturn(true);
+        when(genericTargetType.isArray()).thenReturn(true);
         when(targetType.getComponentType()).thenReturn(componentType);
         when(componentType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(target.getType()).thenReturn(genericTargetType);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -142,7 +142,7 @@ protected ByteCodeAppender.Size applySetter(MethodVisitor methodVisitor,
                 fieldDescription,
                 methodDescription,
                 new StackManipulation.Compound(
-                        MethodVariableAccess.forType(fieldDescription.getType().asErasure())
+                        MethodVariableAccess.of(fieldDescription.getType().asErasure())
                                 .loadOffset(methodDescription.getParameters().get(0).getOffset()),
                         stackManipulation,
                         FieldAccess.forField(fieldDescription).putter()

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -131,7 +131,7 @@ private List<StackManipulation> argumentValuesOf(MethodDescription instrumentedM
         int currentIndex = 1;
         for (TypeDescription parameterType : parameterTypes) {
             instruction.add(new StackManipulation.Compound(
-                    MethodVariableAccess.forType(parameterType).loadOffset(currentIndex),
+                    MethodVariableAccess.of(parameterType).loadOffset(currentIndex),
                     assigner.assign(parameterType, TypeDescription.OBJECT, Assigner.Typing.STATIC)));
             currentIndex += parameterType.getStackSize().getSize();
         }
@@ -418,7 +418,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                         implementationContext,
                         instrumentedMethod,
                         instrumentedType,
-                        MethodVariableAccess.forType(instrumentedType).loadOffset(0));
+                        MethodVariableAccess.of(instrumentedType).loadOffset(0));
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -1765,7 +1765,7 @@ public Resolved resolve(TypeDescription instrumentedType, MethodDescription inst
                     if (index >= parameters.size()) {
                         throw new IllegalStateException("No parameter " + index + " for " + instrumentedMethod);
                     }
-                    return new Resolved.Simple(MethodVariableAccess.forType(parameters.get(index).getType().asErasure())
+                    return new Resolved.Simple(MethodVariableAccess.of(parameters.get(index).getType().asErasure())
                             .loadOffset(instrumentedMethod.getParameters().get(index).getOffset()), parameters.get(index).getType().asErasure());
                 }
 
@@ -1829,7 +1829,7 @@ public Resolved resolve(TypeDescription instrumentedType, MethodDescription inst
                     if (!stackManipulation.isValid()) {
                         throw new IllegalArgumentException("Cannot assign " + parameters.get(index) + " to " + typeDescription);
                     }
-                    return new Resolved.Simple(new StackManipulation.Compound(MethodVariableAccess.forType(parameters.get(index)
+                    return new Resolved.Simple(new StackManipulation.Compound(MethodVariableAccess.of(parameters.get(index)
                             .getType().asErasure()).loadOffset(parameters.get(index).getOffset()), stackManipulation), typeDescription);
                 }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -994,7 +994,7 @@ public StackManipulation resolve(TypeDescription instrumentedType,
                 }
                 ParameterDescription parameterDescription = interceptedMethod.getParameters().get(index);
                 StackManipulation stackManipulation = new StackManipulation.Compound(
-                        MethodVariableAccess.forType(parameterDescription.getType().asErasure()).loadOffset(parameterDescription.getOffset()),
+                        MethodVariableAccess.of(parameterDescription.getType().asErasure()).loadOffset(parameterDescription.getOffset()),
                         assigner.assign(parameterDescription.getType().asErasure(), targetType, typing));
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot assign " + parameterDescription + " to " + targetType + " for " + interceptedMethod);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -300,7 +300,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                 for (FieldDescription fieldDescription : fieldList) {
                     fieldLoading[index] = new StackManipulation.Compound(
                             thisReference,
-                            MethodVariableAccess.forType(fieldDescription.getType().asErasure())
+                            MethodVariableAccess.of(fieldDescription.getType().asErasure())
                                     .loadOffset(instrumentedMethod.getParameters().get(index).getOffset()),
                             FieldAccess.forField(fieldDescription).putter()
                     );
@@ -412,7 +412,7 @@ private Appender(TypeDescription instrumentedType) {
             public Size apply(MethodVisitor methodVisitor,
                               Context implementationContext,
                               MethodDescription instrumentedMethod) {
-                StackManipulation thisReference = MethodVariableAccess.forType(instrumentedType).loadOffset(0);
+                StackManipulation thisReference = MethodVariableAccess.of(instrumentedType).loadOffset(0);
                 FieldList<?> fieldList = instrumentedType.getDeclaredFields();
                 StackManipulation[] fieldLoading = new StackManipulation[fieldList.size()];
                 int index = 0;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TypeProxy.java
Patch:
@@ -486,7 +486,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                     MethodInvocation.invoke(proxyType.getDeclaredMethods()
                             .filter(isConstructor().and(takesArguments(constructorParameters))).getOnly()),
                     Duplication.SINGLE,
-                    MethodVariableAccess.forType(implementationTarget.getInstrumentedType()).loadOffset(0),
+                    MethodVariableAccess.of(implementationTarget.getInstrumentedType()).loadOffset(0),
                     FieldAccess.forField(proxyType.getDeclaredFields()
                             .filter((ElementMatchers.named(INSTANCE_FIELD))).getOnly()).putter()
             ).apply(methodVisitor, implementationContext);
@@ -589,7 +589,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                     MethodInvocation.invoke(proxyType.getDeclaredMethods()
                             .filter(named(REFLECTION_METHOD).and(takesArguments(0))).getOnly()),
                     Duplication.SINGLE,
-                    MethodVariableAccess.forType(implementationTarget.getInstrumentedType()).loadOffset(0),
+                    MethodVariableAccess.of(implementationTarget.getInstrumentedType()).loadOffset(0),
                     FieldAccess.forField(proxyType.getDeclaredFields()
                             .filter((named(INSTANCE_FIELD))).getOnly()).putter()
             ).apply(methodVisitor, implementationContext);
@@ -680,7 +680,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                     Duplication.SINGLE,
                     MethodInvocation.invoke(proxyType.getDeclaredMethods().filter(isConstructor()).getOnly()),
                     Duplication.SINGLE,
-                    MethodVariableAccess.forType(implementationTarget.getInstrumentedType()).loadOffset(0),
+                    MethodVariableAccess.of(implementationTarget.getInstrumentedType()).loadOffset(0),
                     FieldAccess.forField(proxyType.getDeclaredFields()
                             .filter((named(INSTANCE_FIELD))).getOnly()).putter()
             ).apply(methodVisitor, implementationContext);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/AllArguments.java
Patch:
@@ -143,7 +143,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                     ? join(implementationTarget.getInstrumentedType(), source.getParameters().asTypeList().asErasures())
                     : source.getParameters().asTypeList().asErasures()) {
                 StackManipulation stackManipulation = new StackManipulation.Compound(
-                        MethodVariableAccess.forType(sourceParameter).loadOffset(offset),
+                        MethodVariableAccess.of(sourceParameter).loadOffset(offset),
                         assigner.assign(sourceParameter, arrayFactory.getComponentType(), RuntimeType.Verifier.check(target)));
                 if (stackManipulation.isValid()) {
                     stackManipulations.add(stackManipulation);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Argument.java
Patch:
@@ -80,7 +80,7 @@ protected MethodDelegationBinder.ParameterBinding<?> makeBinding(TypeDescription
                                                                              int parameterOffset) {
                 return MethodDelegationBinder.ParameterBinding.Unique.of(
                         new StackManipulation.Compound(
-                                MethodVariableAccess.forType(sourceType).loadOffset(parameterOffset),
+                                MethodVariableAccess.of(sourceType).loadOffset(parameterOffset),
                                 assigner.assign(sourceType, targetType, typing)),
                         new ArgumentTypeResolver.ParameterIndexToken(sourceParameterIndex)
                 );
@@ -100,7 +100,7 @@ protected MethodDelegationBinder.ParameterBinding<?> makeBinding(TypeDescription
                                                                              int parameterOffset) {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(
                         new StackManipulation.Compound(
-                                MethodVariableAccess.forType(sourceType).loadOffset(parameterOffset),
+                                MethodVariableAccess.of(sourceType).loadOffset(parameterOffset),
                                 assigner.assign(sourceType, targetType, typing))
                 );
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -617,7 +617,7 @@ public Size apply(MethodVisitor methodVisitor,
                                         MethodVariableAccess.REFERENCE.loadOffset(0),
                                         FieldAccess.forField(typeDescription.getDeclaredFields()
                                                 .filter((named(AccessorProxy.FIELD_NAME))).getOnly()).getter()),
-                                MethodVariableAccess.forType(parameterType).loadOffset(1),
+                                MethodVariableAccess.of(parameterType).loadOffset(1),
                                 assigner.assign(parameterType, setterMethod.getParameters().get(0).getType().asErasure(), Assigner.Typing.DYNAMIC),
                                 MethodInvocation.invoke(setterMethod),
                                 MethodReturn.VOID

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -424,7 +424,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                         for (FieldDescription fieldDescription : fieldList) {
                             fieldLoading[index] = new StackManipulation.Compound(
                                     thisReference,
-                                    MethodVariableAccess.forType(fieldDescription.getType().asErasure())
+                                    MethodVariableAccess.of(fieldDescription.getType().asErasure())
                                             .loadOffset(instrumentedMethod.getParameters().get(index).getOffset()),
                                     FieldAccess.forField(fieldDescription).putter()
                             );
@@ -539,7 +539,7 @@ private Appender(TypeDescription instrumentedType) {
                     public Size apply(MethodVisitor methodVisitor,
                                       Context implementationContext,
                                       MethodDescription instrumentedMethod) {
-                        StackManipulation thisReference = MethodVariableAccess.forType(instrumentedType).loadOffset(0);
+                        StackManipulation thisReference = MethodVariableAccess.of(instrumentedType).loadOffset(0);
                         FieldList<?> fieldList = instrumentedType.getDeclaredFields();
                         StackManipulation[] fieldLoading = new StackManipulation[fieldList.size()];
                         int index = 0;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccess.java
Patch:
@@ -70,7 +70,7 @@ public enum MethodVariableAccess {
      * @param typeDescription The type of the variable to be loaded.
      * @return An accessor for the given type.
      */
-    public static MethodVariableAccess forType(TypeDescription typeDescription) {
+    public static MethodVariableAccess of(TypeDescription typeDescription) {
         if (typeDescription.isPrimitive()) {
             if (typeDescription.represents(long.class)) {
                 return LONG;
@@ -149,10 +149,10 @@ public boolean isValid() {
 
         @Override
         public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
-            List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(methodDescription.getParameters().size() * 2);
+            List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>();
             for (ParameterDescription parameterDescription : methodDescription.getParameters()) {
                 TypeDescription parameterType = parameterDescription.getType().asErasure();
-                stackManipulations.add(forType(parameterType).loadOffset(parameterDescription.getOffset()));
+                stackManipulations.add(of(parameterType).loadOffset(parameterDescription.getOffset()));
                 stackManipulations.add(typeCastingHandler.ofIndex(parameterType, parameterDescription.getIndex()));
             }
             return new Compound(stackManipulations).apply(methodVisitor, implementationContext);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/SuperBinderTest.java
Patch:
@@ -74,13 +74,13 @@ public void testIllegalBindingStaticMethod() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testPrimitiveParameterType() throws Exception {
-        when(targetType.isPrimitive()).thenReturn(true);
+        when(genericTargetType.isPrimitive()).thenReturn(true);
         Super.Binder.INSTANCE.bind(annotationDescription, source, target, implementationTarget, assigner);
     }
 
     @Test(expected = IllegalStateException.class)
     public void testArrayParameterType() throws Exception {
-        when(targetType.isArray()).thenReturn(true);
+        when(genericTargetType.isArray()).thenReturn(true);
         Super.Binder.INSTANCE.bind(annotationDescription, source, target, implementationTarget, assigner);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ThisBinderTest.java
Patch:
@@ -112,14 +112,14 @@ public void testStaticMethodIllegal() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testPrimitiveType() throws Exception {
-        when(parameterType.isPrimitive()).thenReturn(true);
+        when(genericParameterType.isPrimitive()).thenReturn(true);
         when(target.getType()).thenReturn(genericParameterType);
         This.Binder.INSTANCE.bind(annotationDescription, source, target, implementationTarget, assigner);
     }
 
     @Test(expected = IllegalStateException.class)
     public void testArrayType() throws Exception {
-        when(parameterType.isArray()).thenReturn(true);
+        when(genericParameterType.isArray()).thenReturn(true);
         when(target.getType()).thenReturn(genericParameterType);
         This.Binder.INSTANCE.bind(annotationDescription, source, target, implementationTarget, assigner);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/MethodConstantTest.java
Patch:
@@ -77,8 +77,8 @@ public void setUp() throws Exception {
         when(parameterType.getDescriptor()).thenReturn(QUX);
         when(fieldDescription.getType()).thenReturn(genericFieldType);
         when(fieldDescription.isStatic()).thenReturn(true);
-        when(fieldType.getStackSize()).thenReturn(StackSize.SINGLE);
-        when(genericFieldType.asErasure()).thenReturn(fieldType); // TODO
+        when(genericFieldType.asErasure()).thenReturn(fieldType);
+        when(genericFieldType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(fieldDescription.getDeclaringType()).thenReturn(declaringType);
         when(declaringType.getInternalName()).thenReturn(BAZ);
         when(fieldDescription.getInternalName()).thenReturn(FOO);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/FieldAccessTest.java
Patch:
@@ -89,11 +89,11 @@ public void setUp() throws Exception {
         when(declaringType.asErasure()).thenReturn(declaringType);
         when(fieldDescription.getDeclaringType()).thenReturn(declaringType);
         when(fieldDescription.getType()).thenReturn(genericFieldType);
-        when(genericFieldType.asErasure()).thenReturn(fieldType); // TODO
+        when(genericFieldType.asErasure()).thenReturn(fieldType);
+        when(genericFieldType.getStackSize()).thenReturn(fieldSize);
         when(declaringType.getInternalName()).thenReturn(FOO);
         when(fieldDescription.getInternalName()).thenReturn(BAR);
         when(fieldDescription.getDescriptor()).thenReturn(QUX);
-        when(fieldType.getStackSize()).thenReturn(fieldSize);
         when(fieldDescription.isStatic()).thenReturn(isStatic);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccessOtherTest.java
Patch:
@@ -17,7 +17,7 @@ public void testVoidArgument() throws Exception {
         TypeDescription voidTypeDescription = mock(TypeDescription.class);
         when(voidTypeDescription.isPrimitive()).thenReturn(true);
         when(voidTypeDescription.represents(void.class)).thenReturn(true);
-        MethodVariableAccess.forType(voidTypeDescription);
+        MethodVariableAccess.of(voidTypeDescription);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccessTest.java
Patch:
@@ -69,7 +69,7 @@ public void setUp() throws Exception {
 
     @Test
     public void testLoading() throws Exception {
-        StackManipulation stackManipulation = MethodVariableAccess.forType(typeDescription).loadOffset(4);
+        StackManipulation stackManipulation = MethodVariableAccess.of(typeDescription).loadOffset(4);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, implementationContext);
         assertThat(size.getSizeImpact(), is(this.size));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -1520,10 +1520,10 @@ public Set<MethodDescription> getCandidates() {
                             public Entry<U> extendBy(MethodDescription methodDescription, Harmonizer<U> harmonizer) {
                                 Harmonized<U> key = this.key.extend(methodDescription.asDefined(), harmonizer);
                                 LinkedHashSet<MethodDescription> methodDescriptions = new LinkedHashSet<MethodDescription>(this.methodDescriptions.size() + 1);
-                                TypeDefinition declaringType = methodDescription.getDeclaringType();
+                                TypeDescription declaringType = methodDescription.getDeclaringType().asErasure();
                                 boolean bridge = methodDescription.isBridge();
                                 for (MethodDescription extendedMethod : this.methodDescriptions) {
-                                    if (extendedMethod.getDeclaringType().equals(declaringType)) {
+                                    if (extendedMethod.getDeclaringType().asErasure().equals(declaringType)) {
                                         if (extendedMethod.isBridge() ^ bridge) {
                                             methodDescriptions.add(bridge ? extendedMethod : methodDescription);
                                         } else {

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTest.java
Patch:
@@ -79,6 +79,7 @@ public class ByteBuddyTest {
     @Before
     public void setUp() throws Exception {
         when(modifierContributorForType.getMask()).thenReturn(MASK);
+        when(interfaceType.asGenericType()).thenReturn(interfaceType);
         when(interfaceType.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(interfaceType.asErasure()).thenReturn(rawInterfaceType);
         when(rawInterfaceType.isInterface()).thenReturn(true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionTokenTest.java
Patch:
@@ -45,9 +45,11 @@ public class MethodDescriptionTokenTest {
 
     @Before
     public void setUp() throws Exception {
+        when(first.asGenericType()).thenReturn(first);
         when(first.asErasure()).thenReturn(firstRaw);
-        when(second.asErasure()).thenReturn(secondRaw);
         when(firstParameter.getType()).thenReturn(first);
+        when(second.asGenericType()).thenReturn(second);
+        when(second.asErasure()).thenReturn(secondRaw);
         when(secondParameter.getType()).thenReturn(second);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionLatentTest.java
Patch:
@@ -27,10 +27,9 @@ public class TypeDescriptionLatentTest {
     private GenericTypeDescription superType, interfaceType;
 
     @Before
-    @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
-        when(superType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(superType);
-        when(interfaceType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(interfaceType);
+        when(superType.asGenericType()).thenReturn(superType);
+        when(interfaceType.asGenericType()).thenReturn(interfaceType);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinderTerminationHandlerDroppingTest.java
Patch:
@@ -38,7 +38,7 @@ public class TargetMethodAnnotationDrivenBinderTerminationHandlerDroppingTest {
     @Before
     public void setUp() throws Exception {
         when(target.getReturnType()).thenReturn(genericTargetType);
-        when(genericTargetType.asErasure()).thenReturn(targetType); // TODO
+        when(genericTargetType.asErasure()).thenReturn(targetType);
         when(targetType.getStackSize()).thenReturn(StackSize.SINGLE);
     }
 
@@ -47,7 +47,8 @@ public void testApplication() throws Exception {
         StackManipulation stackManipulation = TargetMethodAnnotationDrivenBinder.TerminationHandler.Dropping.INSTANCE.resolve(assigner, source, target);
         assertThat(stackManipulation, is((StackManipulation) Removal.SINGLE));
         verify(targetType).getStackSize();
-        verify(targetType).asErasure();
         verifyNoMoreInteractions(targetType);
+        verify(genericTargetType).asErasure();
+        verifyNoMoreInteractions(genericTargetType);
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/GenericTypeDescription.java
Patch:
@@ -945,7 +945,7 @@ public Sort getSort() {
 
         @Override
         public GenericTypeList getParameters() {
-            throw new IllegalStateException("A non-generic type does not imply type parameters: " + this);
+            return new GenericTypeList.Empty();
         }
 
         @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/AbstractFieldDescriptionTest.java
Patch:
@@ -43,8 +43,8 @@ public void testPrecondition() throws Exception {
 
     @Test
     public void testFieldType() throws Exception {
-        assertThat(describe(first).getType(), is((GenericTypeDescription) new GenericTypeDescription.ForNonGenericType.OfLoadedType(first.getType())));
-        assertThat(describe(second).getType(), is((GenericTypeDescription) new GenericTypeDescription.ForNonGenericType.OfLoadedType(second.getType())));
+        assertThat(describe(first).getType(), is((TypeDefinition) new TypeDescription.ForLoadedType(first.getType())));
+        assertThat(describe(second).getType(), is((TypeDefinition) new TypeDescription.ForLoadedType(second.getType())));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -283,7 +283,7 @@ public void testSuperType() throws Exception {
         assertThat(describe(void.class).getSuperType(), nullValue(GenericTypeDescription.class));
         assertThat(describe(SampleClass.class).getSuperType(), is(GenericTypeDescription.OBJECT));
         assertThat(describe(SampleIndirectInterfaceImplementation.class).getSuperType(),
-                is((GenericTypeDescription) new GenericTypeDescription.ForNonGenericType.OfLoadedType(SampleInterfaceImplementation.class)));
+                is((TypeDefinition) new TypeDescription.ForLoadedType(SampleInterfaceImplementation.class)));
         assertThat(describe(Object[].class).getSuperType(), is(GenericTypeDescription.OBJECT));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeTest.java
Patch:
@@ -316,14 +316,14 @@ public void testRepresents() {
     @Test
     public void testSuperType() {
         assertThat(makePlainInstrumentedType().getSuperType(), is(GenericTypeDescription.OBJECT));
-        assertThat(makePlainInstrumentedType().getSuperType(), not((GenericTypeDescription) new TypeDescription.ForLoadedType(Integer.class)));
-        assertThat(makePlainInstrumentedType().getSuperType(), not((GenericTypeDescription) new TypeDescription.ForLoadedType(Serializable.class)));
+        assertThat(makePlainInstrumentedType().getSuperType(), not((GenericTypeDescription) new GenericTypeDescription.ForNonGenericType.OfLoadedType(Integer.class)));
+        assertThat(makePlainInstrumentedType().getSuperType(), not((GenericTypeDescription) new GenericTypeDescription.ForNonGenericType.OfLoadedType(Serializable.class)));
     }
 
     @Test
     public void testInterfaces() {
         assertThat(makePlainInstrumentedType().getInterfaces().size(), is(1));
-        assertThat(makePlainInstrumentedType().getInterfaces().getOnly(), is((GenericTypeDescription) new TypeDescription.ForLoadedType(Serializable.class)));
+        assertThat(makePlainInstrumentedType().getInterfaces().getOnly(), is((TypeDefinition) new TypeDescription.ForLoadedType(Serializable.class)));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaTypeTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.utility;
 
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.test.utility.JavaVersionRule;
@@ -60,7 +61,7 @@ public void testCallSite() throws Exception {
     public void testExecutable() throws Exception {
         assertThat(JavaType.EXECUTABLE.getTypeStub().getName(), is("java.lang.reflect.Executable"));
         assertThat(JavaType.EXECUTABLE.getTypeStub().getModifiers(), is(Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT));
-        assertThat(JavaType.EXECUTABLE.getTypeStub().getSuperType(), is((GenericTypeDescription) new TypeDescription.ForLoadedType(AccessibleObject.class)));
+        assertThat(JavaType.EXECUTABLE.getTypeStub().getSuperType(), is((TypeDefinition) new TypeDescription.ForLoadedType(AccessibleObject.class)));
         assertThat(JavaType.EXECUTABLE.getTypeStub().getInterfaces().size(), is(2));
         assertThat(JavaType.EXECUTABLE.getTypeStub().getInterfaces().contains(new GenericTypeDescription.ForNonGenericType.OfLoadedType(Member.class)), is(true));
         assertThat(JavaType.EXECUTABLE.getTypeStub().getInterfaces().contains(new GenericTypeDescription.ForNonGenericType.OfLoadedType(GenericDeclaration.class)), is(true));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderInstrumentableMatcherTest.java
Patch:
@@ -39,10 +39,8 @@ public class SubclassDynamicTypeBuilderInstrumentableMatcherTest {
     public void setUp() throws Exception {
         latentMethodMatcher = new SubclassDynamicTypeBuilder.InstrumentableMatcher(ignoredMethods);
         when(typeDescription.asErasure()).thenReturn(typeDescription);
-        when(typeDescription.asGenericType()).thenReturn(typeDescription);
         when(typeDescription.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(otherType.asErasure()).thenReturn(otherType);
-        when(otherType.asGenericType()).thenReturn(otherType);
         when(otherType.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinderTest.java
Patch:
@@ -6,6 +6,7 @@
 import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bind.MethodDelegationBinder;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
@@ -61,7 +62,7 @@ public class TargetMethodAnnotationDrivenBinderTest {
     private MethodDescription sourceMethod, targetMethod;
 
     @Mock
-    private TypeDescription sourceTypeDescription, targetTypeDescription;
+    private GenericTypeDescription sourceTypeDescription, targetTypeDescription;
 
     @Mock
     private AnnotationDescription.ForLoadedAnnotation<FirstPseudoAnnotation> firstPseudoAnnotation;

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionRawTypeMatcher.java
Patch:
@@ -17,14 +17,14 @@ public class CollectionRawTypeMatcher<T extends Iterable<? extends TypeDefinitio
     /**
      * The matcher to be applied to the raw types.
      */
-    private final ElementMatcher<? super Iterable<? extends TypeDefinition>> matcher;
+    private final ElementMatcher<? super Iterable<? extends TypeDescription>> matcher;
 
     /**
      * Creates a new raw type matcher.
      *
      * @param matcher The matcher to be applied to the raw types.
      */
-    public CollectionRawTypeMatcher(ElementMatcher<? super Iterable<? extends TypeDefinition>> matcher) {
+    public CollectionRawTypeMatcher(ElementMatcher<? super Iterable<? extends TypeDescription>> matcher) {
         this.matcher = matcher;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -321,7 +321,7 @@ public static <T> ElementMatcher.Junction<T> anyOf(Iterable<?> values) {
      * @param <T>   The type of the matched object.
      * @return A matcher that checks for the equality with any of the given objects.
      */
-    public static <T extends GenericTypeDescription> ElementMatcher.Junction<T> anyOf(Type... value) {
+    public static <T extends TypeDefinition> ElementMatcher.Junction<T> anyOf(Type... value) {
         return anyOf(new GenericTypeList.ForLoadedTypes(nonNull(value)));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AbstractAnnotationDescriptionTest.java
Patch:
@@ -397,7 +397,7 @@ private void assertValue(Annotation annotation, String methodName, Object rawVal
                 methodName,
                 Opcodes.ACC_PUBLIC,
                 Collections.<GenericTypeDescription>emptyList(),
-                new TypeDescription.ForLoadedType(annotation.annotationType().getDeclaredMethod(methodName).getReturnType()),
+                new GenericTypeDescription.ForNonGenericType.OfLoadedType(annotation.annotationType().getDeclaredMethod(methodName).getReturnType()),
                 Collections.<ParameterDescription.Token>emptyList(),
                 Collections.<GenericTypeDescription>emptyList(),
                 Collections.<AnnotationDescription>emptyList(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/FieldDescriptionLatentTest.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.description.field;
 
 import net.bytebuddy.description.annotation.AnnotationList;
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/AbstractParameterListTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.description.method;
 
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.matcher.AbstractFilterableListTest;
 import org.junit.Test;

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTest.java
Patch:
@@ -32,8 +32,8 @@ protected MethodDescription.InDefinedShape describe(Constructor<?> constructor)
     public void testTypeInitializer() throws Exception {
         TypeDescription typeDescription = mock(TypeDescription.class);
         MethodDescription.InDefinedShape typeInitializer = new MethodDescription.Latent.TypeInitializer(typeDescription);
-        assertThat(typeInitializer.getDeclaringType(), is((GenericTypeDescription) typeDescription));
-        assertThat(typeInitializer.getReturnType(), is((GenericTypeDescription) new TypeDescription.ForLoadedType(void.class)));
+        assertThat(typeInitializer.getDeclaringType(), is(typeDescription));
+        assertThat(typeInitializer.getReturnType(), is((GenericTypeDescription) TypeDescription.VOID));
         assertThat(typeInitializer.getParameters(), is((ParameterList) new ParameterList.Empty()));
         assertThat(typeInitializer.getExceptionTypes(), is((GenericTypeList) new GenericTypeList.Empty()));
         assertThat(typeInitializer.getDeclaredAnnotations(), is((AnnotationList) new AnnotationList.Empty()));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericTypeDescriptionVisitorForAttachmentTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.description.type.generic;
 
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.matcher.ElementMatchers;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
@@ -20,7 +21,7 @@ public void testAttachment() throws Exception {
         GenericTypeDescription original = TypeDefinition.Sort.describe(Foo.Inner.class.getDeclaredField(FOO).getGenericType());
         GenericTypeDescription detached = original.accept(new GenericTypeDescription.Visitor.Substitutor.ForDetachment(ElementMatchers.is(Foo.Inner.class)));
         TypeDescription target = new TypeDescription.ForLoadedType(Bar.class);
-        GenericTypeDescription attached = detached.accept(new GenericTypeDescription.Visitor.Substitutor.ForAttachment(target, target));
+        GenericTypeDescription attached = detached.accept(new GenericTypeDescription.Visitor.Substitutor.ForAttachment(target.asGenericType(), target));
         assertThat(attached.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
         assertThat(attached.asErasure(), sameInstance(target));
         assertThat(attached.getParameters().size(), is(4));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeTest.java
Patch:
@@ -281,7 +281,7 @@ public void testIsAssignableFrom() {
         assertThat(makePlainInstrumentedType().isAssignableFrom(Object.class), is(false));
         assertThat(makePlainInstrumentedType().isAssignableFrom(Serializable.class), is(false));
         assertThat(makePlainInstrumentedType().isAssignableFrom(Integer.class), is(false));
-        TypeDescription objectTypeDescription = new TypeDescription.ForLoadedType(Object.class);
+        TypeDescription objectTypeDescription = TypeDescription.OBJECT;
         assertThat(makePlainInstrumentedType().isAssignableFrom(objectTypeDescription), is(false));
         TypeDescription serializableTypeDescription = new TypeDescription.ForLoadedType(Serializable.class);
         assertThat(makePlainInstrumentedType().isAssignableFrom(serializableTypeDescription), is(false));
@@ -309,7 +309,7 @@ public void testRepresents() {
 
     @Test
     public void testSuperType() {
-        assertThat(makePlainInstrumentedType().getSuperType(), is((GenericTypeDescription) new TypeDescription.ForLoadedType(Object.class)));
+        assertThat(makePlainInstrumentedType().getSuperType(), is((GenericTypeDescription) TypeDescription.OBJECT));
         assertThat(makePlainInstrumentedType().getSuperType(), not((GenericTypeDescription) new TypeDescription.ForLoadedType(Integer.class)));
         assertThat(makePlainInstrumentedType().getSuperType(), not((GenericTypeDescription) new TypeDescription.ForLoadedType(Serializable.class)));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/FieldAccessorPreparationTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.test.utility.MockitoRule;
 import org.junit.Before;
@@ -36,7 +37,7 @@ public void setUp() throws Exception {
     @Test
     public void testPreparationDefineField() throws Exception {
         assertThat(FieldAccessor.ofField(FOO).defineAs(TYPE).prepare(instrumentedType), is(instrumentedType));
-        verify(instrumentedType).withField(new FieldDescription.Token(FOO, NO_MODIFIERS, new TypeDescription.ForLoadedType(TYPE)));
+        verify(instrumentedType).withField(new FieldDescription.Token(FOO, NO_MODIFIERS, new GenericTypeDescription.ForNonGenericType.OfLoadedType(TYPE)));
         verify(instrumentedType).isInterface();
         verifyNoMoreInteractions(instrumentedType);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/FixedValueTest.java
Patch:
@@ -41,7 +41,7 @@ public void setUp() throws Exception {
 
     @Test
     public void testTypeDescriptionConstantPool() throws Exception {
-        Class<? extends Qux> qux = implement(Qux.class, FixedValue.value(new TypeDescription.ForLoadedType(Object.class))).getLoaded();
+        Class<? extends Qux> qux = implement(Qux.class, FixedValue.value(TypeDescription.OBJECT)).getLoaded();
         assertThat(qux.getDeclaredFields().length, is(0));
         assertThat(qux.newInstance().bar(), is((Object) Object.class));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodCallTest.java
Patch:
@@ -389,7 +389,7 @@ public void testWithFieldTarget() throws Exception {
     public void testUnloadedType() throws Exception {
         DynamicType.Loaded<SimpleMethod> loaded = implement(SimpleMethod.class,
                 MethodCall.invoke(Foo.class.getDeclaredMethod(BAR, Object.class, Object.class))
-                        .with(new TypeDescription.ForLoadedType(Object.class), new TypeDescription.ForLoadedType(String.class)),
+                        .with(TypeDescription.OBJECT, TypeDescription.STRING),
                 SimpleMethod.class.getClassLoader(),
                 named(FOO));
         assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TypeProxyCreationTest.java
Patch:
@@ -76,7 +76,7 @@ public void setUp() throws Exception {
         when(proxyMethod.getDeclaringType()).thenReturn(foo);
         when(proxyMethod.getInternalName()).thenReturn(FOO);
         when(proxyMethod.getDescriptor()).thenReturn(FOO);
-        when(proxyMethod.getReturnType()).thenReturn(new TypeDescription.ForLoadedType(Object.class));
+        when(proxyMethod.getReturnType()).thenReturn(TypeDescription.OBJECT);
         when(proxyMethod.asDefined()).thenReturn(proxyMethod);
     }
 
@@ -213,7 +213,7 @@ public void testForConstructorConstruction() throws Exception {
         when(methodAccessorFactory.registerAccessorFor(specialMethodInvocation)).thenReturn(proxyMethod);
         StackManipulation stackManipulation = new TypeProxy.ForSuperMethodByConstructor(foo,
                 implementationTarget,
-                Collections.<TypeDescription>singletonList(new TypeDescription.ForLoadedType(Void.class)),
+                Collections.<TypeDescription>singletonList(TypeDescription.VOID),
                 true,
                 false);
         MethodVisitor methodVisitor = mock(MethodVisitor.class);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveBoxingDelegateTestWithReferenceTest.java
Patch:
@@ -7,6 +7,6 @@ public class PrimitiveBoxingDelegateTestWithReferenceTest {
 
     @Test(expected = IllegalArgumentException.class)
     public void testThrowsException() throws Exception {
-        PrimitiveBoxingDelegate.forPrimitive(new TypeDescription.ForLoadedType(Object.class));
+        PrimitiveBoxingDelegate.forPrimitive(TypeDescription.OBJECT);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveUnboxingDelegateOtherTest.java
Patch:
@@ -13,7 +13,7 @@ public void testIllegalSourceTypeThrowsException() throws Exception {
 
     @Test(expected = IllegalArgumentException.class)
     public void testVoidIllegal() throws Exception {
-        PrimitiveUnboxingDelegate.forPrimitive(new TypeDescription.ForLoadedType(void.class));
+        PrimitiveUnboxingDelegate.forPrimitive(TypeDescription.VOID);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveWideningDelegateOtherTest.java
Patch:
@@ -8,12 +8,12 @@ public class PrimitiveWideningDelegateOtherTest {
 
     @Test(expected = IllegalArgumentException.class)
     public void testIllegalSourceTypeThrowsException() throws Exception {
-        PrimitiveWideningDelegate.forPrimitive(new TypeDescription.ForLoadedType(Object.class));
+        PrimitiveWideningDelegate.forPrimitive(TypeDescription.OBJECT);
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void testIllegalTargetTypeThrowsException() throws Exception {
-        PrimitiveWideningDelegate.forPrimitive(new TypeDescription.ForLoadedType(int.class)).widenTo(new TypeDescription.ForLoadedType(Object.class));
+        PrimitiveWideningDelegate.forPrimitive(new TypeDescription.ForLoadedType(int.class)).widenTo(TypeDescription.OBJECT);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/collection/ArrayAccessOtherTest.java
Patch:
@@ -8,7 +8,7 @@ public class ArrayAccessOtherTest {
 
     @Test(expected = IllegalArgumentException.class)
     public void testVoidThrowsException() throws Exception {
-        ArrayAccess.of(new TypeDescription.ForLoadedType(void.class));
+        ArrayAccess.of(TypeDescription.VOID);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/collection/ArrayFactoryObjectPropertiesTest.java
Patch:
@@ -26,12 +26,12 @@ public class ArrayFactoryObjectPropertiesTest {
 
     @Test(expected = IllegalArgumentException.class)
     public void testVoidIsIllegal() throws Exception {
-        ArrayFactory.forType(new TypeDescription.ForLoadedType(void.class));
+        ArrayFactory.forType(TypeDescription.VOID);
     }
 
     @Test
     public void testIllegalArrayStackManipulation() throws Exception {
-        assertThat(ArrayFactory.forType(new TypeDescription.ForLoadedType(Object.class))
+        assertThat(ArrayFactory.forType(TypeDescription.OBJECT)
                 .new ArrayStackManipulation(Collections.<StackManipulation>singletonList(StackManipulation.Illegal.INSTANCE))
                 .isValid(), is(false));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/TypeSortMatcherTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.matcher;
 
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.test.utility.MockitoRule;
 import org.junit.Rule;

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -2077,12 +2077,12 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
             for (String value : values) {
                 instrumentedType = instrumentedType.withField(new FieldDescription.Token(value,
                         ENUM_FIELD_MODIFIERS | Opcodes.ACC_ENUM,
-                        TargetType.DESCRIPTION));
+                        TargetType.GENERIC_DESCRIPTION));
             }
             return instrumentedType
                     .withField(new FieldDescription.Token(ENUM_VALUES,
                             ENUM_FIELD_MODIFIERS | Opcodes.ACC_SYNTHETIC,
-                            TypeDescription.ArrayProjection.of(TargetType.DESCRIPTION, 1)))
+                            GenericTypeDescription.ForGenericArray.Latent.of(TargetType.GENERIC_DESCRIPTION, 1)))
                     .withInitializer(new InitializationAppender(values));
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -6,6 +6,7 @@
 import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.annotation.AnnotationList;
 import net.bytebuddy.description.enumeration.EnumerationDescription;
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
@@ -369,7 +370,7 @@ public String getGenericSignature() {
                 returnType.accept(new GenericTypeDescription.Visitor.ForSignatureVisitor(signatureWriter.visitReturnType()));
                 generic = generic || !returnType.getSort().isNonGeneric();
                 GenericTypeList exceptionTypes = getExceptionTypes();
-                if (!exceptionTypes.filter(not(ofSort(GenericTypeDescription.Sort.NON_GENERIC))).isEmpty()) {
+                if (!exceptionTypes.filter(not(ofSort(TypeDefinition.Sort.NON_GENERIC))).isEmpty()) {
                     for (GenericTypeDescription exceptionType : exceptionTypes) {
                         exceptionType.accept(new GenericTypeDescription.Visitor.ForSignatureVisitor(signatureWriter.visitExceptionType()));
                         generic = generic || !exceptionType.getSort().isNonGeneric();

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -13,6 +13,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeList;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.dynamic.scaffold.FieldRegistry;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
@@ -2525,7 +2526,7 @@ public MatchedMethodInterception<S> throwing(Collection<? extends TypeDescriptio
                             Collections.<GenericTypeDescription>emptyList(),
                             methodToken.getReturnType(),
                             methodToken.getParameterTokens(),
-                            unique(isThrowable(new ArrayList<TypeDescription>(exceptionTypes))),
+                            unique(isThrowable(new GenericTypeList.ForTypeDefinitions(toList(exceptionTypes)))),
                             Collections.<AnnotationDescription>emptyList(),
                             null));
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -71,7 +71,7 @@ public RebaseDynamicTypeBuilder(ClassFileVersion classFileVersion,
                                     NamingStrategy namingStrategy,
                                     AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
                                     Implementation.Context.Factory implementationContextFactory,
-                                    List<TypeDescription> interfaceTypes,
+                                    List<GenericTypeDescription> interfaceTypes,
                                     int modifiers,
                                     TypeAttributeAppender attributeAppender,
                                     ElementMatcher<? super MethodDescription> ignoredMethods,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -64,7 +64,7 @@ public RedefinitionDynamicTypeBuilder(ClassFileVersion classFileVersion,
                                           NamingStrategy namingStrategy,
                                           AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
                                           Implementation.Context.Factory implementationContextFactory,
-                                          List<TypeDescription> interfaceTypes,
+                                          List<GenericTypeDescription> interfaceTypes,
                                           int modifiers,
                                           TypeAttributeAppender attributeAppender,
                                           ElementMatcher<? super MethodDescription> ignoredMethods,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategy.java
Patch:
@@ -106,7 +106,7 @@ public MethodRegistry inject(MethodRegistry methodRegistry, MethodAttributeAppen
             public List<MethodDescription.Token> extractConstructors(TypeDescription instrumentedType) {
                 GenericTypeDescription superType = instrumentedType.getSuperType();
                 return (superType == null
-                        ? new MethodList.Empty()
+                        ? new MethodList.Empty<MethodDescription.InGenericShape>()
                         : superType.getDeclaredMethods().filter(isConstructor().<MethodDescription>and(isVisibleTo(instrumentedType)))).asTokenList();
             }
 
@@ -129,7 +129,7 @@ public MethodRegistry inject(MethodRegistry methodRegistry, MethodAttributeAppen
             public List<MethodDescription.Token> extractConstructors(TypeDescription instrumentedType) {
                 GenericTypeDescription superType = instrumentedType.getSuperType();
                 return (superType == null
-                        ? new MethodList.Empty()
+                        ? new MethodList.Empty<MethodDescription.InGenericShape>()
                         : superType.asErasure().getDeclaredMethods().filter(isPublic().and(isConstructor()))).asTokenList();
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -4,6 +4,7 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
@@ -49,7 +50,7 @@ public abstract class InvocationHandlerAdapter implements Implementation {
     /**
      * A type description of the {@link InvocationHandler}.
      */
-    private static final TypeDescription INVOCATION_HANDLER_TYPE = new TypeDescription.ForLoadedType(InvocationHandler.class);
+    private static final GenericTypeDescription INVOCATION_HANDLER_TYPE = new GenericTypeDescription.ForNonGenericType.OfLoadedType(InvocationHandler.class);
 
     /**
      * The name of the field for storing an invocation handler.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -8,6 +8,7 @@
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.implementation.bytecode.*;
 import net.bytebuddy.implementation.bytecode.assign.Assigner;
@@ -732,7 +733,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
                 return instrumentedType
                         .withField(new FieldDescription.Token(fieldName,
                                 Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
-                                new TypeDescription.ForLoadedType(target.getClass())))
+                                new GenericTypeDescription.ForNonGenericType.OfLoadedType(target.getClass())))
                         .withInitializer(new LoadedTypeInitializer.ForStaticField(fieldName, target));
             }
 
@@ -1114,7 +1115,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
                 return instrumentedType
                         .withField(new FieldDescription.Token(fieldName,
                                 Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
-                                new TypeDescription.ForLoadedType(value.getClass())))
+                                new GenericTypeDescription.ForNonGenericType.OfLoadedType(value.getClass())))
                         .withInitializer(new LoadedTypeInitializer.ForStaticField(fieldName, value));
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -4,6 +4,7 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
 import net.bytebuddy.implementation.bind.MethodDelegationBinder;
@@ -832,7 +833,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
                 return instrumentedType
                         .withField(new FieldDescription.Token(fieldName,
                                 Opcodes.ACC_SYNTHETIC | Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC,
-                                new TypeDescription.ForLoadedType(delegate.getClass())))
+                                new GenericTypeDescription.ForNonGenericType.OfLoadedType(delegate.getClass())))
                         .withInitializer(new LoadedTypeInitializer.ForStaticField(fieldName, delegate));
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/TypeSortMatcher.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.matcher;
 
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 /**
@@ -12,14 +13,14 @@ public class TypeSortMatcher<T extends GenericTypeDescription> extends ElementMa
     /**
      * An element matcher to be applied to the type's sort.
      */
-    private final ElementMatcher<? super GenericTypeDescription.Sort> matcher;
+    private final ElementMatcher<? super TypeDefinition.Sort> matcher;
 
     /**
      * Creates a new type sort matcher.
      *
      * @param matcher An element matcher to be applied to the type's sort.
      */
-    public TypeSortMatcher(ElementMatcher<? super GenericTypeDescription.Sort> matcher) {
+    public TypeSortMatcher(ElementMatcher<? super TypeDefinition.Sort> matcher) {
         this.matcher = matcher;
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTest.java
Patch:
@@ -77,7 +77,7 @@ public void setUp() throws Exception {
         when(modifierContributorForType.getMask()).thenReturn(MASK);
         when(interfaceTypes.isInterface()).thenReturn(true);
         when(interfaceTypes.asErasure()).thenReturn(interfaceTypes);
-        when(interfaceTypes.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(interfaceTypes.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/AbstractFieldDescriptionTest.java
Patch:
@@ -175,7 +175,7 @@ public void testAnnotations() throws Exception {
 
     @Test
     public void testGenericTypes() throws Exception {
-        assertThat(describe(genericField).getType(), is(GenericTypeDescription.Sort.describe(genericField.getGenericType())));
+        assertThat(describe(genericField).getType(), is(TypeDefinition.Sort.describe(genericField.getGenericType())));
         assertThat(describe(genericField).getType().asErasure(), is((TypeDescription) new TypeDescription.ForLoadedType(genericField.getType())));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/FieldDescriptionLatentTest.java
Patch:
@@ -13,7 +13,7 @@ protected FieldDescription.InDefinedShape describe(Field field) {
         return new FieldDescription.Latent(new TypeDescription.ForLoadedType(field.getDeclaringClass()),
                 field.getName(),
                 field.getModifiers(),
-                GenericTypeDescription.Sort.describe(field.getGenericType()),
+                TypeDefinition.Sort.describe(field.getGenericType()),
                 new AnnotationList.ForLoadedAnnotation(field.getDeclaredAnnotations()));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/AbstractMethodDescriptionTest.java
Patch:
@@ -670,7 +670,7 @@ public void testInvokable() throws Exception {
 
     @Test
     public void testGenericTypes() throws Exception {
-        assertThat(describe(genericMethod).getReturnType(), is(GenericTypeDescription.Sort.describe(genericMethod.getGenericReturnType())));
+        assertThat(describe(genericMethod).getReturnType(), is(TypeDefinition.Sort.describe(genericMethod.getGenericReturnType())));
         assertThat(describe(genericMethod).getParameters().asTypeList(),
                 is((GenericTypeList) new GenericTypeList.ForLoadedTypes(genericMethod.getGenericParameterTypes())));
         assertThat(describe(genericMethod).getExceptionTypes(),
@@ -680,7 +680,7 @@ public void testGenericTypes() throws Exception {
     @Test
     public void testGenericTypesOfMethodWithoutException() throws Exception {
         assertThat(describe(genericMethodWithRawException).getReturnType(),
-                is(GenericTypeDescription.Sort.describe(genericMethodWithRawException.getGenericReturnType())));
+                is(TypeDefinition.Sort.describe(genericMethodWithRawException.getGenericReturnType())));
         assertThat(describe(genericMethodWithRawException).getParameters().asTypeList(),
                 is((GenericTypeList) new GenericTypeList.ForLoadedTypes(genericMethodWithRawException.getGenericParameterTypes())));
         assertThat(describe(genericMethodWithRawException).getExceptionTypes(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/AbstractParameterListTest.java
Patch:
@@ -16,14 +16,14 @@ public abstract class AbstractParameterListTest<U extends ParameterDescription,
     @SuppressWarnings("unchecked")
     public void testTokenWithoutMatcher() throws Exception {
         assertThat(asList(Collections.singletonList(getFirst())).asTokenList().size(), is(1));
-        assertThat(asList(Collections.singletonList(getFirst())).asTokenList().getOnly().getType(), is(GenericTypeDescription.Sort.describe(Void.class)));
+        assertThat(asList(Collections.singletonList(getFirst())).asTokenList().getOnly().getType(), is(TypeDefinition.Sort.describe(Void.class)));
     }
 
     @Test
     @SuppressWarnings("unchecked")
     public void testTokenWithMatcher() throws Exception {
         assertThat(asList(Collections.singletonList(getFirst())).asTokenList(none()).size(), is(1));
-        assertThat(asList(Collections.singletonList(getFirst())).asTokenList(none()).getOnly().getType(), is(GenericTypeDescription.Sort.describe(Void.class)));
+        assertThat(asList(Collections.singletonList(getFirst())).asTokenList(none()).getOnly().getType(), is(TypeDefinition.Sort.describe(Void.class)));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -245,14 +245,14 @@ public void testEquals() throws Exception {
         TypeDescription identical = describe(SampleClass.class);
         assertThat(identical, is(identical));
         TypeDescription equalFirst = mock(TypeDescription.class);
-        when(equalFirst.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(equalFirst.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(equalFirst.asErasure()).thenReturn(equalFirst);
         when(equalFirst.getInternalName()).thenReturn(Type.getInternalName(SampleClass.class));
         assertThat(describe(SampleClass.class), is(equalFirst));
         assertThat(describe(SampleClass.class), not(describe(SampleInterface.class)));
         assertThat(describe(SampleClass.class), not((TypeDescription) new TypeDescription.ForLoadedType(SampleInterface.class)));
         GenericTypeDescription nonRawType = mock(GenericTypeDescription.class);
-        when(nonRawType.getSort()).thenReturn(GenericTypeDescription.Sort.VARIABLE);
+        when(nonRawType.getSort()).thenReturn(TypeDefinition.Sort.VARIABLE);
         assertThat(describe(SampleClass.class), not(nonRawType));
         assertThat(describe(SampleClass.class), not(new Object()));
         assertThat(describe(SampleClass.class), not(equalTo(null)));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionAbstractBaseRawTypeWrapperTest.java
Patch:
@@ -13,8 +13,8 @@ public class TypeDescriptionAbstractBaseRawTypeWrapperTest {
     @Test
     public void testRawType() throws Exception {
         GenericTypeDescription rawType = new TypeDescription.ForLoadedType(Foo.class).accept(TypeDescription.AbstractBase.RawTypeWrapper.INSTANCE);
-        assertThat(rawType.getSort(), is(GenericTypeDescription.Sort.NON_GENERIC));
-        assertThat(rawType.getDeclaredMethods().filter(isMethod()).getOnly().getReturnType().getSort(), is(GenericTypeDescription.Sort.NON_GENERIC));
+        assertThat(rawType.getSort(), is(TypeDefinition.Sort.NON_GENERIC));
+        assertThat(rawType.getDeclaredMethods().filter(isMethod()).getOnly().getReturnType().getSort(), is(TypeDefinition.Sort.NON_GENERIC));
         assertThat(rawType.getDeclaredMethods().filter(isMethod()).getOnly().getReturnType(), is((GenericTypeDescription) TypeDescription.OBJECT));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionArrayProjectionTest.java
Patch:
@@ -17,12 +17,12 @@ protected TypeDescription describe(Class<?> type) {
 
     @Override
     protected GenericTypeDescription describe(Field field) {
-        return GenericTypeDescription.ForGenericArray.Latent.of(GenericTypeDescription.Sort.describe(field.getGenericType()), 0);
+        return GenericTypeDescription.ForGenericArray.Latent.of(TypeDefinition.Sort.describe(field.getGenericType()), 0);
     }
 
     @Override
     protected GenericTypeDescription describe(Method method) {
-        return GenericTypeDescription.ForGenericArray.Latent.of(GenericTypeDescription.Sort.describe(method.getGenericReturnType()), 0);
+        return GenericTypeDescription.ForGenericArray.Latent.of(TypeDefinition.Sort.describe(method.getGenericReturnType()), 0);
     }
 
     @Test(expected = IllegalArgumentException.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionForLoadedTypeTest.java
Patch:
@@ -15,7 +15,7 @@ protected TypeDescription describe(Class<?> type) {
 
     @Override
     protected GenericTypeDescription describe(Field field) {
-        return GenericTypeDescription.Sort.describe(field.getGenericType());
+        return TypeDefinition.Sort.describe(field.getGenericType());
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericTypeListExplicitTest.java
Patch:
@@ -6,12 +6,12 @@ public class GenericTypeListExplicitTest extends AbstractGenericTypeListTest<Gen
 
     @Override
     protected GenericTypeDescription getFirst() throws Exception {
-        return GenericTypeDescription.Sort.describe(Holder.class.getGenericInterfaces()[0]);
+        return TypeDefinition.Sort.describe(Holder.class.getGenericInterfaces()[0]);
     }
 
     @Override
     protected GenericTypeDescription getSecond() throws Exception {
-        return GenericTypeDescription.Sort.describe(Holder.class.getGenericInterfaces()[1]);
+        return TypeDefinition.Sort.describe(Holder.class.getGenericInterfaces()[1]);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericTypeListForLoadedTypesTest.java
Patch:
@@ -22,6 +22,6 @@ protected GenericTypeList asList(List<Type> elements) {
 
     @Override
     protected GenericTypeDescription asElement(Type element) {
-        return GenericTypeDescription.Sort.describe(element);
+        return TypeDefinition.Sort.describe(element);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/MethodTransformerSimpleTest.java
Patch:
@@ -73,7 +73,7 @@ public void setUp() throws Exception {
         when(parameterType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(parameterType);
         when(exceptionType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(exceptionType);
         when(typeVariable.getSymbol()).thenReturn(QUX);
-        when(typeVariable.getSort()).thenReturn(GenericTypeDescription.Sort.VARIABLE);
+        when(typeVariable.getSort()).thenReturn(TypeDefinition.Sort.VARIABLE);
         when(methodDescription.asToken()).thenReturn(methodToken);
         when(methodDescription.getDeclaringType()).thenReturn(declaringType);
         when(methodDescription.asDefined()).thenReturn(definedMethod);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/InstrumentedTypeTest.java
Patch:
@@ -91,7 +91,7 @@ public void testWithFieldOfInstrumentedTypeAsArray() throws Exception {
                 TypeDescription.ArrayProjection.of(TargetType.DESCRIPTION, 1)));
         assertThat(instrumentedType.getDeclaredFields().size(), is(1));
         FieldDescription.InDefinedShape fieldDescription = instrumentedType.getDeclaredFields().get(0);
-        assertThat(fieldDescription.getType().getSort(), is(GenericTypeDescription.Sort.NON_GENERIC));
+        assertThat(fieldDescription.getType().getSort(), is(TypeDefinition.Sort.NON_GENERIC));
         assertThat(fieldDescription.getType().asErasure().isArray(), is(true));
         assertThat(fieldDescription.getType().asErasure().getComponentType(), sameInstance((TypeDescription) instrumentedType));
         assertThat(fieldDescription.getModifiers(), is(Opcodes.ACC_PUBLIC));
@@ -270,7 +270,7 @@ public void testEquals() throws Exception {
         InstrumentedType instrumentedType = makePlainInstrumentedType();
         TypeDescription other = mock(TypeDescription.class);
         when(other.getInternalName()).thenReturn(instrumentedType.getInternalName());
-        when(other.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(other.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(other.asErasure()).thenReturn(other);
         assertThat(instrumentedType, is(other));
         verify(other, atLeast(1)).getInternalName();

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodRegistryDefaultTest.java
Patch:
@@ -112,10 +112,10 @@ public void setUp() throws Exception {
         when(implementationTarget.getInstrumentedType()).thenReturn(typeDescription);
         when(methodTransformer.transform(typeDescription, instrumentedMethod)).thenReturn(instrumentedMethod);
         when(returnType.asErasure()).thenReturn(returnType);
-        when(returnType.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(returnType.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(returnType.isVisibleTo(typeDescription)).thenReturn(true);
         when(parameterType.asErasure()).thenReturn(parameterType);
-        when(parameterType.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(parameterType.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(parameterType.isVisibleTo(typeDescription)).thenReturn(true);
         when(instrumentedMethod.getReturnType()).thenReturn(returnType);
         when(instrumentedMethod.getParameters()).thenReturn(new ParameterList.Explicit(Collections.singletonList(parameterDescription)));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/InlineImplementationMatcherTest.java
Patch:
@@ -37,10 +37,10 @@ public class InlineImplementationMatcherTest {
     @Before
     public void setUp() throws Exception {
         latentMethodMatcher = new InliningImplementationMatcher(ignoredMethods, predefinedMethods);
-        when(typeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(typeDescription.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(typeDescription.asGenericType()).thenReturn(typeDescription);
         when(typeDescription.asErasure()).thenReturn(typeDescription);
-        when(otherType.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(otherType.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(otherType.asGenericType()).thenReturn(otherType);
         when(otherType.asErasure()).thenReturn(otherType);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderInstrumentableMatcherTest.java
Patch:
@@ -39,10 +39,10 @@ public void setUp() throws Exception {
         latentMethodMatcher = new SubclassDynamicTypeBuilder.InstrumentableMatcher(ignoredMethods);
         when(typeDescription.asErasure()).thenReturn(typeDescription);
         when(typeDescription.asGenericType()).thenReturn(typeDescription);
-        when(typeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(typeDescription.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(otherType.asErasure()).thenReturn(otherType);
         when(otherType.asGenericType()).thenReturn(otherType);
-        when(otherType.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(otherType.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/DefaultMethodCallTest.java
Patch:
@@ -162,7 +162,7 @@ public List<?> create() {
                 TypeDescription typeDescription = mock(TypeDescription.class);
                 when(typeDescription.isInterface()).thenReturn(true);
                 when(typeDescription.asErasure()).thenReturn(typeDescription);
-                when(typeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+                when(typeDescription.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
                 return Collections.singletonList(typeDescription);
             }
         }).apply();

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldProxyBinderTest.java
Patch:
@@ -48,7 +48,7 @@ public void setUp() throws Exception {
                 .thenReturn(new FieldList.Explicit<FieldDescription.InDefinedShape>(Collections.singletonList(fieldDescription)));
         when(fieldDescription.getType()).thenReturn(fieldType);
         when(fieldType.getStackSize()).thenReturn(StackSize.ZERO);
-        when(fieldType.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(fieldType.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         when(fieldType.asErasure()).thenReturn(fieldType);
         when(setterType.asErasure()).thenReturn(setterType);
         when(getterType.asErasure()).thenReturn(getterType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/OriginBinderTest.java
Patch:
@@ -103,7 +103,7 @@ public void testConstructorBindingForNonConstructor() throws Exception {
     public void testStringBinding() throws Exception {
         when(targetType.getInternalName()).thenReturn(FOO);
         when(targetType.represents(String.class)).thenReturn(true);
-        when(targetType.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(targetType.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = Origin.Binder.INSTANCE
                 .bind(annotationDescription, source, target, implementationTarget, assigner);
         assertThat(parameterBinding.isValid(), is(true));
@@ -113,7 +113,7 @@ public void testStringBinding() throws Exception {
     public void testModifierBinding() throws Exception {
         when(targetType.getInternalName()).thenReturn(FOO);
         when(targetType.represents(int.class)).thenReturn(true);
-        when(targetType.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(targetType.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = Origin.Binder.INSTANCE
                 .bind(annotationDescription, source, target, implementationTarget, assigner);
         assertThat(parameterBinding.isValid(), is(true));
@@ -146,7 +146,7 @@ public void testMethodTypeBinding() throws Exception {
     @Test(expected = IllegalStateException.class)
     public void testIllegalBinding() throws Exception {
         when(targetType.getName()).thenReturn(FOO);
-        when(targetType.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(targetType.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         Origin.Binder.INSTANCE.bind(annotationDescription, source, target, implementationTarget, assigner);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/RawTypeMatcherTest.java
Patch:
@@ -34,7 +34,7 @@ public void setUp() throws Exception {
     @Test
     public void testMatch() throws Exception {
         when(elementMatcher.matches(typeDescription)).thenReturn(true);
-        when(genericTypeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(genericTypeDescription.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         assertThat(new RawTypeMatcher<GenericTypeDescription>(elementMatcher).matches(genericTypeDescription), is(true));
         verify(genericTypeDescription).getSort();
         verify(genericTypeDescription).asErasure();
@@ -46,7 +46,7 @@ public void testMatch() throws Exception {
 
     @Test
     public void testNoMatchWildcard() throws Exception {
-        when(genericTypeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.WILDCARD);
+        when(genericTypeDescription.getSort()).thenReturn(TypeDefinition.Sort.WILDCARD);
         assertThat(new RawTypeMatcher<GenericTypeDescription>(elementMatcher).matches(genericTypeDescription), is(false));
         verify(genericTypeDescription).getSort();
         verifyNoMoreInteractions(genericTypeDescription);
@@ -57,7 +57,7 @@ public void testNoMatchWildcard() throws Exception {
     @Test
     public void testNoMatch() throws Exception {
         when(elementMatcher.matches(typeDescription)).thenReturn(false);
-        when(genericTypeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(genericTypeDescription.getSort()).thenReturn(TypeDefinition.Sort.NON_GENERIC);
         assertThat(new RawTypeMatcher<GenericTypeDescription>(elementMatcher).matches(genericTypeDescription), is(false));
         verify(genericTypeDescription).getSort();
         verify(genericTypeDescription).asErasure();

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolGenericTypeListTest.java
Patch:
@@ -42,6 +42,6 @@ protected GenericTypeList asList(List<Type> elements) {
 
     @Override
     protected GenericTypeDescription asElement(Type element) {
-        return GenericTypeDescription.Sort.describe(element);
+        return TypeDefinition.Sort.describe(element);
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTarget.java
Patch:
@@ -3,6 +3,7 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
@@ -96,8 +97,8 @@ private Implementation.SpecialMethodInvocation invokeSuper(MethodRebaseResolver.
     }
 
     @Override
-    public TypeDescription getOriginType() {
-        return instrumentedType;
+    public GenericTypeDescription getOriginType() {
+        return instrumentedType.asGenericType();
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -201,7 +201,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
                     Collections.<GenericTypeDescription>emptyList(),
                     GenericTypeDescription.OBJECT,
                     Collections.<ParameterDescription.Token>emptyList(),
-                    Collections.singletonList(new TypeDescription.ForLoadedType(Exception.class)),
+                    Collections.singletonList(new GenericTypeDescription.ForNonGenericType.OfLoadedType(Exception.class)),
                     Collections.<AnnotationDescription>emptyList(),
                     MethodDescription.NO_DEFAULT_VALUE);
             nodes.put(callMethod.asToken(), new MethodGraph.Node.Simple(callMethod));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TypeProxy.java
Patch:
@@ -737,7 +737,7 @@ protected MethodCall(MethodAccessorFactory methodAccessorFactory) {
         public InstrumentedType prepare(InstrumentedType instrumentedType) {
             return instrumentedType.withField(new FieldDescription.Token(INSTANCE_FIELD,
                     Opcodes.ACC_SYNTHETIC,
-                    TypeProxy.this.implementationTarget.getInstrumentedType()));
+                    implementationTarget.getInstrumentedType().asGenericType()));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -681,7 +681,7 @@ protected InstanceFieldConstructor(TypeDescription instrumentedType) {
             public InstrumentedType prepare(InstrumentedType instrumentedType) {
                 return instrumentedType.withField(new FieldDescription.Token(AccessorProxy.FIELD_NAME,
                         Opcodes.ACC_FINAL | Opcodes.ACC_PRIVATE,
-                        this.instrumentedType));
+                        this.instrumentedType.asGenericType()));
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -513,7 +513,7 @@ protected InstanceFieldConstructor(TypeDescription instrumentedType) {
                 public InstrumentedType prepare(InstrumentedType instrumentedType) {
                     return instrumentedType.withField(new FieldDescription.Token(RedirectionProxy.FIELD_NAME,
                             Opcodes.ACC_FINAL | Opcodes.ACC_PRIVATE,
-                            this.instrumentedType));
+                            this.instrumentedType.asGenericType()));
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/ByteCodeElement.java
Patch:
@@ -83,7 +83,7 @@ interface TypeDependant<T extends TypeDependant<?, S>, S extends ByteCodeElement
          * @param targetTypeMatcher A matcher to identify types to be replaced by {@link net.bytebuddy.dynamic.TargetType} descriptions.
          * @return A token representative of this type dependant.
          */
-        S asToken(ElementMatcher<? super GenericTypeDescription> targetTypeMatcher);
+        S asToken(ElementMatcher<? super TypeDescription> targetTypeMatcher);
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -44,11 +44,10 @@ interface InGenericShape extends FieldDescription {
         GenericTypeDescription getDeclaringType();
     }
 
-    // TODO: Remove extends InGenericShape
     /**
      * Represents a field in its defined shape, i.e. in the form it is defined by a class without its type variables being resolved.
      */
-    interface InDefinedShape extends FieldDescription, ByteCodeElement.Accessible, InGenericShape {
+    interface InDefinedShape extends FieldDescription, ByteCodeElement.Accessible {
 
         @Override
         TypeDescription getDeclaringType();
@@ -117,7 +116,7 @@ public FieldDescription.Token asToken() {
         }
 
         @Override
-        public FieldDescription.Token asToken(ElementMatcher<? super GenericTypeDescription> targetTypeMatcher) {
+        public FieldDescription.Token asToken(ElementMatcher<? super TypeDescription> targetTypeMatcher) {
             return new FieldDescription.Token(getName(),
                     getModifiers(),
                     getType().accept(new GenericTypeDescription.Visitor.Substitutor.ForDetachment(targetTypeMatcher)),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/TargetType.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.dynamic;
 
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 /**
  * This type is used as a place holder for creating methods or fields that refer to the type that currently subject
@@ -13,6 +14,8 @@ public final class TargetType {
      */
     public static final TypeDescription DESCRIPTION = new TypeDescription.ForLoadedType(TargetType.class);
 
+    public static final GenericTypeDescription GENERIC_DESCRIPTION = new GenericTypeDescription.ForNonGenericType.OfLoadedType(TargetType.class);
+
     /**
      * An unusable constructor to avoid instance creation.
      */

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -2088,7 +2088,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
 
         @Override
         public ByteCodeAppender appender(Target implementationTarget) {
-            return new ValuesMethodAppender(implementationTarget.getTypeDescription());
+            return new ValuesMethodAppender(implementationTarget.getInstrumentedType());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodRegistry.java
Patch:
@@ -129,7 +129,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
 
             @Override
             public Compiled compile(Implementation.Target implementationTarget) {
-                return new Compiled(implementationTarget.getTypeDescription());
+                return new Compiled(implementationTarget.getInstrumentedType());
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/DefaultMethodCall.java
Patch:
@@ -129,7 +129,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
 
     @Override
     public ByteCodeAppender appender(Target implementationTarget) {
-        return new Appender(implementationTarget, filterRelevant(implementationTarget.getTypeDescription()));
+        return new Appender(implementationTarget, filterRelevant(implementationTarget.getInstrumentedType()));
     }
 
     /**
@@ -195,7 +195,7 @@ protected static class Appender implements ByteCodeAppender {
         protected Appender(Target implementationTarget, List<TypeDescription> prioritizedInterfaces) {
             this.implementationTarget = implementationTarget;
             this.prioritizedInterfaces = prioritizedInterfaces;
-            this.nonPrioritizedInterfaces = new HashSet<TypeDescription>(implementationTarget.getTypeDescription().getInterfaces().asErasures());
+            this.nonPrioritizedInterfaces = new HashSet<TypeDescription>(implementationTarget.getInstrumentedType().getInterfaces().asErasures());
             nonPrioritizedInterfaces.removeAll(prioritizedInterfaces);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -6,7 +6,6 @@
 import net.bytebuddy.description.modifier.ModifierContributor;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.TargetType;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
@@ -613,7 +612,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
 
         @Override
         public ByteCodeAppender appender(Target implementationTarget) {
-            return new Appender(fieldLocatorFactory.make(implementationTarget.getTypeDescription()));
+            return new Appender(fieldLocatorFactory.make(implementationTarget.getInstrumentedType()));
         }
 
         @Override
@@ -751,7 +750,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
 
         @Override
         public ByteCodeAppender appender(Target implementationTarget) {
-            return new Appender(fieldLocatorFactory.make(implementationTarget.getTypeDescription()));
+            return new Appender(fieldLocatorFactory.make(implementationTarget.getInstrumentedType()));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -424,7 +424,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
 
         @Override
         public ByteCodeAppender appender(Target implementationTarget) {
-            return new StaticFieldByteCodeAppender(implementationTarget.getTypeDescription());
+            return new StaticFieldByteCodeAppender(implementationTarget.getInstrumentedType());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Forwarding.java
Patch:
@@ -137,7 +137,7 @@ public static Implementation toInstanceField(String fieldName, TypeDescription f
 
     @Override
     public ByteCodeAppender appender(Target implementationTarget) {
-        return new Appender(loadDelegate(implementationTarget.getTypeDescription()));
+        return new Appender(loadDelegate(implementationTarget.getInstrumentedType()));
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -255,7 +255,7 @@ interface Target {
          *
          * @return A description of the instrumented type.
          */
-        TypeDescription getTypeDescription();
+        TypeDescription getInstrumentedType();
 
         /**
          * Identifies the origin type of an implementation. The origin type describes the type that is subject to
@@ -265,7 +265,7 @@ interface Target {
          *
          * @return The origin type of this implementation.
          */
-        TypeDescription getOriginType();
+        GenericTypeDescription getOriginType();
 
         /**
          * Creates a special method invocation for invoking the super method of the given method.
@@ -338,7 +338,7 @@ protected AbstractBase(TypeDescription instrumentedType, MethodGraph.Linked meth
             }
 
             @Override
-            public TypeDescription getTypeDescription() {
+            public TypeDescription getInstrumentedType() {
                 return instrumentedType;
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -262,7 +262,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
 
         @Override
         public ByteCodeAppender appender(Target implementationTarget) {
-            return new Appender(implementationTarget.getTypeDescription());
+            return new Appender(implementationTarget.getInstrumentedType());
         }
 
         @Override
@@ -381,7 +381,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
 
         @Override
         public ByteCodeAppender appender(Target implementationTarget) {
-            return new Appender(implementationTarget.getTypeDescription());
+            return new Appender(implementationTarget.getInstrumentedType());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -746,7 +746,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
 
     @Override
     public ByteCodeAppender appender(Target implementationTarget) {
-        return new Appender(implementationTarget.getTypeDescription());
+        return new Appender(implementationTarget.getInstrumentedType());
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -684,15 +684,15 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
 
     @Override
     public ByteCodeAppender appender(Target implementationTarget) {
-        return new Appender(implementationDelegate.getPreparingStackAssignment(implementationTarget.getTypeDescription()),
+        return new Appender(implementationDelegate.getPreparingStackAssignment(implementationTarget.getInstrumentedType()),
                 implementationTarget,
-                methodContainer.resolve(implementationTarget.getTypeDescription()),
+                methodContainer.resolve(implementationTarget.getInstrumentedType()),
                 new MethodDelegationBinder.Processor(new TargetMethodAnnotationDrivenBinder(
                         parameterBinders,
                         defaultsProvider,
                         terminationHandler,
                         assigner,
-                        implementationDelegate.getMethodInvoker(implementationTarget.getTypeDescription())
+                        implementationDelegate.getMethodInvoker(implementationTarget.getInstrumentedType())
                 ), ambiguityResolver)
         );
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -264,7 +264,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
 
         @Override
         public ByteCodeAppender appender(Target implementationTarget) {
-            return new Appender(implementationTarget.getTypeDescription());
+            return new Appender(implementationTarget.getInstrumentedType());
         }
 
         @Override
@@ -366,7 +366,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
 
         @Override
         public ByteCodeAppender appender(Target implementationTarget) {
-            return new Appender(implementationTarget.getTypeDescription());
+            return new Appender(implementationTarget.getInstrumentedType());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/MethodDelegationBinder.java
Patch:
@@ -893,7 +893,7 @@ public MethodBinding process(Implementation.Target implementationTarget, MethodD
          */
         private List<MethodBinding> bind(Implementation.Target implementationTarget, MethodDescription source, MethodList<?> targetCandidates) {
             List<MethodBinding> possibleDelegations = new LinkedList<MethodBinding>();
-            for (MethodDescription targetCandidate : targetCandidates.filter(isVisibleTo(implementationTarget.getTypeDescription()))) {
+            for (MethodDescription targetCandidate : targetCandidates.filter(isVisibleTo(implementationTarget.getInstrumentedType()))) {
                 MethodBinding methodBinding = methodDelegationBinder.bind(implementationTarget, source, targetCandidate);
                 if (methodBinding.isValid()) {
                     possibleDelegations.add(methodBinding);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/AllArguments.java
Patch:
@@ -140,7 +140,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(source.getParameters().size() + (includeThis ? 1 : 0));
             int offset = source.isStatic() || includeThis ? 0 : 1;
             for (TypeDescription sourceParameter : includeThis
-                    ? join(implementationTarget.getTypeDescription(), source.getParameters().asTypeList().asErasures())
+                    ? join(implementationTarget.getInstrumentedType(), source.getParameters().asTypeList().asErasures())
                     : source.getParameters().asTypeList().asErasures()) {
                 StackManipulation stackManipulation = new StackManipulation.Compound(
                         MethodVariableAccess.forType(sourceParameter).loadOffset(offset),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Default.java
Patch:
@@ -91,7 +91,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             if (!proxyType.isInterface()) {
                 throw new IllegalStateException(target + " uses the @Default annotation on an invalid type");
             }
-            if (source.isStatic() || !implementationTarget.getTypeDescription().getInterfaces().asErasures().contains(proxyType)) {
+            if (source.isStatic() || !implementationTarget.getInstrumentedType().getInterfaces().asErasures().contains(proxyType)) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             } else {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(new TypeProxy.ForDefaultMethod(proxyType,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultCall.java
Patch:
@@ -145,7 +145,7 @@ enum Implicit implements DefaultMethodLocator {
                 public Implementation.SpecialMethodInvocation resolve(Implementation.Target implementationTarget,
                                                                       MethodDescription source) {
                     Implementation.SpecialMethodInvocation specialMethodInvocation = null;
-                    for (TypeDescription candidate : implementationTarget.getTypeDescription().getInterfaces().asErasures()) {
+                    for (TypeDescription candidate : implementationTarget.getInstrumentedType().getInterfaces().asErasures()) {
                         if (source.isSpecializableFor(candidate)) {
                             if (specialMethodInvocation != null) {
                                 return Implementation.SpecialMethodInvocation.Illegal.INSTANCE;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldValue.java
Patch:
@@ -8,7 +8,6 @@
 import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bind.MethodDelegationBinder;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
@@ -91,7 +90,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
             FieldLocator.Resolution resolution = FieldLocator
-                    .of(annotation.getValue(DEFINING_TYPE, TypeDescription.class), implementationTarget.getTypeDescription())
+                    .of(annotation.getValue(DEFINING_TYPE, TypeDescription.class), implementationTarget.getInstrumentedType())
                     .resolve(annotation.getValue(FIELD_NAME, String.class), source.isStatic());
             if (resolution.isResolved()) {
                 StackManipulation stackManipulation = new StackManipulation.Compound(

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Origin.java
Patch:
@@ -80,7 +80,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                Assigner assigner) {
             TypeDescription parameterType = target.getType().asErasure();
             if (parameterType.represents(Class.class)) {
-                return new MethodDelegationBinder.ParameterBinding.Anonymous(ClassConstant.of(implementationTarget.getOriginType()));
+                return new MethodDelegationBinder.ParameterBinding.Anonymous(ClassConstant.of(implementationTarget.getOriginType().asErasure()));
             } else if (parameterType.represents(Method.class)) {
                 return source.isMethod()
                         ? new MethodDelegationBinder.ParameterBinding.Anonymous(

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -387,7 +387,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
 
                 @Override
                 public ByteCodeAppender appender(Target implementationTarget) {
-                    return new Appender(implementationTarget.getTypeDescription());
+                    return new Appender(implementationTarget.getInstrumentedType());
                 }
 
                 @Override
@@ -492,7 +492,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
 
                 @Override
                 public ByteCodeAppender appender(Target implementationTarget) {
-                    return new Appender(implementationTarget.getTypeDescription());
+                    return new Appender(implementationTarget.getInstrumentedType());
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Super.java
Patch:
@@ -230,10 +230,10 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             }
             TypeDescription proxyType = TypeLocator.ForType
                     .of(annotation.getValue(PROXY_TYPE, TypeDescription.class))
-                    .resolve(implementationTarget.getTypeDescription(), target.getType());
+                    .resolve(implementationTarget.getInstrumentedType(), target.getType());
             if (proxyType.isFinal()) {
                 throw new IllegalStateException("Cannot extend final type as @Super proxy: " + proxyType);
-            } else if (source.isStatic() || !implementationTarget.getTypeDescription().isAssignableTo(proxyType)) {
+            } else if (source.isStatic() || !implementationTarget.getInstrumentedType().isAssignableTo(proxyType)) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             } else {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(annotation

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/This.java
Patch:
@@ -72,7 +72,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             StackManipulation assignment = source.isStatic()
                     ? NullConstant.INSTANCE
                     : new StackManipulation.Compound(MethodVariableAccess.REFERENCE.loadOffset(THIS_REFERENCE_INDEX),
-                    assigner.assign(implementationTarget.getTypeDescription(), target.getType().asErasure(), RuntimeType.Verifier.check(target)));
+                    assigner.assign(implementationTarget.getInstrumentedType(), target.getType().asErasure(), RuntimeType.Verifier.check(target)));
             return assignment.isValid()
                     ? new MethodDelegationBinder.ParameterBinding.Anonymous(assignment)
                     : MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodRegistryDefaultTest.java
Patch:
@@ -109,7 +109,7 @@ public void setUp() throws Exception {
         when(firstCompiledHandler.assemble(instrumentedMethod, firstAppender)).thenReturn(firstRecord);
         when(secondCompiledHandler.assemble(instrumentedMethod, secondAppender)).thenReturn(secondRecord);
         when(typeDescription.asErasure()).thenReturn(typeDescription);
-        when(implementationTarget.getTypeDescription()).thenReturn(typeDescription);
+        when(implementationTarget.getInstrumentedType()).thenReturn(typeDescription);
         when(methodTransformer.transform(typeDescription, instrumentedMethod)).thenReturn(instrumentedMethod);
         when(returnType.asErasure()).thenReturn(returnType);
         when(returnType.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTargetTest.java
Patch:
@@ -4,6 +4,7 @@
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
 import net.bytebuddy.implementation.AbstractImplementationTargetTest;
 import net.bytebuddy.implementation.Implementation;
@@ -178,7 +179,7 @@ public void testNonSpecializableSuperTypeMethodIsNotInvokable() throws Exception
 
     @Test
     public void testOriginType() throws Exception {
-        assertThat(implementationTarget.getOriginType(), is(instrumentedType));
+        assertThat(implementationTarget.getOriginType(), is((GenericTypeDescription) instrumentedType));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTargetFactoryTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.test.utility.MockitoRule;
@@ -45,13 +46,13 @@ public void testReturnsSubclassimplementationTarget() throws Exception {
     @Test
     public void testOriginTypeSuperType() throws Exception {
         assertThat(new SubclassImplementationTarget.Factory(SubclassImplementationTarget.OriginTypeResolver.SUPER_TYPE)
-                .make(instrumentedType, methodGraph).getOriginType(), is(superType));
+                .make(instrumentedType, methodGraph).getOriginType(), is((GenericTypeDescription) superType));
     }
 
     @Test
     public void testOriginTypeLevelType() throws Exception {
         assertThat(new SubclassImplementationTarget.Factory(SubclassImplementationTarget.OriginTypeResolver.LEVEL_TYPE)
-                .make(instrumentedType, methodGraph).getOriginType(), is(instrumentedType));
+                .make(instrumentedType, methodGraph).getOriginType(), is((GenericTypeDescription) instrumentedType));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/DefaultMethodCallTest.java
Patch:
@@ -172,7 +172,7 @@ public List<?> create() {
             public void apply(Implementation.Target mock) {
                 TypeDescription typeDescription = mock(TypeDescription.class);
                 when(typeDescription.getInterfaces()).thenReturn(new GenericTypeList.Explicit(Arrays.asList(removalType, mock(TypeDescription.class))));
-                when(mock.getTypeDescription()).thenReturn(typeDescription);
+                when(mock.getInstrumentedType()).thenReturn(typeDescription);
             }
         }).create(new ObjectPropertyAssertion.Creator<List<?>>() {
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/SuperMethodCallOtherTest.java
Patch:
@@ -73,7 +73,7 @@ public class SuperMethodCallOtherTest extends AbstractImplementationTest {
 
     @Before
     public void setUp() throws Exception {
-        when(implementationTarget.getTypeDescription()).thenReturn(typeDescription);
+        when(implementationTarget.getInstrumentedType()).thenReturn(typeDescription);
         when(methodDescription.asToken()).thenReturn(methodToken);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/MethodDelegationBinderProcessorTest.java
Patch:
@@ -65,7 +65,7 @@ public void setUp() throws Exception {
                 .thenReturn(MethodDelegationBinder.AmbiguityResolver.Resolution.RIGHT);
         when(ambiguityResolver.resolve(source, boundDelegation, boundDelegation))
                 .thenReturn(MethodDelegationBinder.AmbiguityResolver.Resolution.AMBIGUOUS);
-        when(implementationTarget.getTypeDescription()).thenReturn(instrumentedType);
+        when(implementationTarget.getInstrumentedType()).thenReturn(instrumentedType);
         when(unbindableTarget.isVisibleTo(instrumentedType)).thenReturn(true);
         when(bindableTarget.isVisibleTo(instrumentedType)).thenReturn(true);
         when(dominantBindableTarget.isVisibleTo(instrumentedType)).thenReturn(true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/AbstractAnnotationBinderTest.java
Patch:
@@ -90,7 +90,7 @@ public void setUp() throws Exception {
         when(sourceParameterList.asTypeList()).thenReturn(sourceTypeList);
         when(sourceTypeList.asErasures()).thenReturn(rawSourceTypeList);
         when(assigner.assign(any(TypeDescription.class), any(TypeDescription.class), any(Assigner.Typing.class))).thenReturn(stackManipulation);
-        when(implementationTarget.getTypeDescription()).thenReturn(instrumentedType);
+        when(implementationTarget.getInstrumentedType()).thenReturn(instrumentedType);
         when(implementationTarget.getOriginType()).thenReturn(instrumentedType);
         when(instrumentedType.asErasure()).thenReturn(instrumentedType);
         when(instrumentedType.iterator()).then(new Answer<Iterator<GenericTypeDescription>>() {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/DefaultCallBinderTest.java
Patch:
@@ -61,7 +61,7 @@ public void testImplicitLookupIsUnique() throws Exception {
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = DefaultCall.Binder.INSTANCE
                 .bind(annotationDescription, source, target, implementationTarget, assigner);
         assertThat(parameterBinding.isValid(), is(true));
-        verify(implementationTarget).getTypeDescription();
+        verify(implementationTarget).getInstrumentedType();
         verify(implementationTarget).invokeDefault(firstInterface, methodToken);
         verifyNoMoreInteractions(implementationTarget);
     }
@@ -78,7 +78,7 @@ public void testImplicitLookupIsAmbiguous() throws Exception {
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = DefaultCall.Binder.INSTANCE
                 .bind(annotationDescription, source, target, implementationTarget, assigner);
         assertThat(parameterBinding.isValid(), is(false));
-        verify(implementationTarget).getTypeDescription();
+        verify(implementationTarget).getInstrumentedType();
         verify(implementationTarget).invokeDefault(firstInterface, methodToken);
         verifyNoMoreInteractions(implementationTarget);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldProxyBinderTest.java
Patch:
@@ -243,7 +243,7 @@ public void testObjectProperties() throws Exception {
             @SuppressWarnings("unchecked")
             public void apply(Implementation.Target mock) {
                 TypeDescription typeDescription = mock(TypeDescription.class);
-                when(mock.getTypeDescription()).thenReturn(typeDescription);
+                when(mock.getInstrumentedType()).thenReturn(typeDescription);
                 FieldList fieldList = mock(FieldList.class);
                 FieldList filteredFieldList = mock(FieldList.class);
                 when(typeDescription.getDeclaredFields()).thenReturn(fieldList);
@@ -256,14 +256,14 @@ public void apply(Implementation.Target mock) {
         ObjectPropertyAssertion.of(FieldProxy.Binder.AccessType.Getter.Appender.class).refine(new ObjectPropertyAssertion.Refinement<Implementation.Target>() {
             @Override
             public void apply(Implementation.Target mock) {
-                when(mock.getTypeDescription()).thenReturn(mock(TypeDescription.class));
+                when(mock.getInstrumentedType()).thenReturn(mock(TypeDescription.class));
             }
         }).skipSynthetic().apply();
         ObjectPropertyAssertion.of(FieldProxy.Binder.AccessType.Setter.class).apply();
         ObjectPropertyAssertion.of(FieldProxy.Binder.AccessType.Setter.Appender.class).refine(new ObjectPropertyAssertion.Refinement<Implementation.Target>() {
             @Override
             public void apply(Implementation.Target mock) {
-                when(mock.getTypeDescription()).thenReturn(mock(TypeDescription.class));
+                when(mock.getInstrumentedType()).thenReturn(mock(TypeDescription.class));
             }
         }).skipSynthetic().apply();
         ObjectPropertyAssertion.of(FieldProxy.Binder.AccessorProxy.class).apply();

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/MorphBinderTest.java
Patch:
@@ -161,7 +161,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(Morph.Binder.RedirectionProxy.MethodCall.Appender.class).refine(new ObjectPropertyAssertion.Refinement<Implementation.Target>() {
             @Override
             public void apply(Implementation.Target mock) {
-                when(mock.getTypeDescription()).thenReturn(mock(TypeDescription.class));
+                when(mock.getInstrumentedType()).thenReturn(mock(TypeDescription.class));
             }
         }).apply();
         ObjectPropertyAssertion.of(Morph.Binder.RedirectionProxy.StaticFieldConstructor.class).apply();
@@ -175,7 +175,7 @@ public void apply(Implementation.Target mock) {
                 when(fieldList.filter(named(Morph.Binder.RedirectionProxy.FIELD_NAME))).thenReturn((FieldList) filteredFieldList);
                 when(filteredFieldList.getOnly()).thenReturn(mock(FieldDescription.class));
                 when(typeDescription.getDeclaredFields()).thenReturn((FieldList) fieldList);
-                when(mock.getTypeDescription()).thenReturn(typeDescription);
+                when(mock.getInstrumentedType()).thenReturn(typeDescription);
             }
         }).apply();
         ObjectPropertyAssertion.of(Morph.Binder.DefaultMethodLocator.Implicit.class).apply();

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTest.java
Patch:
@@ -31,7 +31,7 @@ protected MethodDescription.InDefinedShape describe(Constructor<?> constructor)
     @Test
     public void testTypeInitializer() throws Exception {
         TypeDescription typeDescription = mock(TypeDescription.class);
-        MethodDescription typeInitializer = new MethodDescription.Latent.TypeInitializer(typeDescription);
+        MethodDescription.InDefinedShape typeInitializer = new MethodDescription.Latent.TypeInitializer(typeDescription);
         assertThat(typeInitializer.getDeclaringType(), is((GenericTypeDescription) typeDescription));
         assertThat(typeInitializer.getReturnType(), is((GenericTypeDescription) new TypeDescription.ForLoadedType(void.class)));
         assertThat(typeInitializer.getParameters(), is((ParameterList) new ParameterList.Empty()));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/MethodTransformerSimpleTest.java
Patch:
@@ -7,6 +7,7 @@
 import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.modifier.ModifierContributor;
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.description.type.generic.GenericTypeList;
@@ -101,7 +102,7 @@ public void setUp() throws Exception {
     public void testSimpleTransformation() throws Exception {
         when(transformer.transform(methodToken)).thenReturn(methodToken);
         MethodDescription transformed = new MethodTransformer.Simple(transformer).transform(instrumentedType, methodDescription);
-        assertThat(transformed.getDeclaringType(), is(declaringType));
+        assertThat(transformed.getDeclaringType(), is((TypeDefinition) declaringType));
         assertThat(transformed.getInternalName(), is(FOO));
         assertThat(transformed.getModifiers(), is(MODIFIERS));
         assertThat(transformed.getReturnType(), is(returnType));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/InlineImplementationMatcherTest.java
Patch:
@@ -38,8 +38,10 @@ public class InlineImplementationMatcherTest {
     public void setUp() throws Exception {
         latentMethodMatcher = new InliningImplementationMatcher(ignoredMethods, predefinedMethods);
         when(typeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(typeDescription.asGenericType()).thenReturn(typeDescription);
         when(typeDescription.asErasure()).thenReturn(typeDescription);
         when(otherType.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(otherType.asGenericType()).thenReturn(otherType);
         when(otherType.asErasure()).thenReturn(otherType);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderInstrumentableMatcherTest.java
Patch:
@@ -38,8 +38,10 @@ public class SubclassDynamicTypeBuilderInstrumentableMatcherTest {
     public void setUp() throws Exception {
         latentMethodMatcher = new SubclassDynamicTypeBuilder.InstrumentableMatcher(ignoredMethods);
         when(typeDescription.asErasure()).thenReturn(typeDescription);
+        when(typeDescription.asGenericType()).thenReturn(typeDescription);
         when(typeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
         when(otherType.asErasure()).thenReturn(otherType);
+        when(otherType.asGenericType()).thenReturn(otherType);
         when(otherType.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -44,10 +44,11 @@ interface InGenericShape extends FieldDescription {
         GenericTypeDescription getDeclaringType();
     }
 
+    // TODO: Remove extends InGenericShape
     /**
      * Represents a field in its defined shape, i.e. in the form it is defined by a class without its type variables being resolved.
      */
-    interface InDefinedShape extends FieldDescription, ByteCodeElement.Accessible {
+    interface InDefinedShape extends FieldDescription, ByteCodeElement.Accessible, InGenericShape {
 
         @Override
         TypeDescription getDeclaringType();
@@ -303,7 +304,7 @@ public int getModifiers() {
     /**
      * A field description that represents a given field but with a substituted field type.
      */
-    class TypeSubstituting extends AbstractBase {
+    class TypeSubstituting extends AbstractBase implements InGenericShape {
 
         /**
          * The declaring type of the field.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldList.java
Patch:
@@ -191,7 +191,7 @@ public int size() {
     /**
      * A list of field descriptions that yields {@link net.bytebuddy.description.field.FieldDescription.TypeSubstituting}.
      */
-    class TypeSubstituting extends AbstractBase<FieldDescription> {
+    class TypeSubstituting extends AbstractBase<FieldDescription.InGenericShape> {
 
         /**
          * The field's actual declaring type.
@@ -224,7 +224,7 @@ public TypeSubstituting(GenericTypeDescription declaringType,
         }
 
         @Override
-        public FieldDescription get(int index) {
+        public FieldDescription.InGenericShape get(int index) {
             return new FieldDescription.TypeSubstituting(declaringType, fieldDescriptions.get(index), visitor);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodList.java
Patch:
@@ -215,7 +215,7 @@ public int size() {
     /**
      * A list of method descriptions that yields {@link net.bytebuddy.description.method.MethodDescription.TypeSubstituting}.
      */
-    class TypeSubstituting extends AbstractBase<MethodDescription> {
+    class TypeSubstituting extends AbstractBase<MethodDescription.InGenericShape> {
 
         /**
          * The methods' declaring type.
@@ -248,7 +248,7 @@ public TypeSubstituting(GenericTypeDescription declaringType,
         }
 
         @Override
-        public MethodDescription get(int index) {
+        public MethodDescription.InGenericShape get(int index) {
             return new MethodDescription.TypeSubstituting(declaringType, methodDescriptions.get(index), visitor);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/DeclaredByType.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.description;
 
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.TypeDefinition;
 
 /**
  * This interface represents all elements that can be declared within a type, i.e. other types and type members.
@@ -12,5 +12,5 @@ public interface DeclaredByType {
      *
      * @return The declaring type or {@code null} if no such type exists.
      */
-    GenericTypeDescription getDeclaringType();
+    TypeDefinition getDeclaringType();
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -1520,10 +1520,10 @@ public Set<MethodDescription> getCandidates() {
                             public Entry<U> extendBy(MethodDescription methodDescription, Harmonizer<U> harmonizer) {
                                 Harmonized<U> key = this.key.extend(methodDescription.asDefined(), harmonizer);
                                 LinkedHashSet<MethodDescription> methodDescriptions = new LinkedHashSet<MethodDescription>(this.methodDescriptions.size() + 1);
-                                GenericTypeDescription declaringType = methodDescription.getDeclaringType();
+                                TypeDescription declaringType = methodDescription.getDeclaringType().asErasure();
                                 boolean bridge = methodDescription.isBridge();
                                 for (MethodDescription extendedMethod : this.methodDescriptions) {
-                                    if (extendedMethod.getDeclaringType().equals(declaringType)) {
+                                    if (extendedMethod.getDeclaringType().asErasure().equals(declaringType)) {
                                         if (extendedMethod.isBridge() ^ bridge) {
                                             methodDescriptions.add(bridge ? extendedMethod : methodDescription);
                                         } else {

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringTypeMatcher.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.DeclaredByType;
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 /**
@@ -27,8 +28,8 @@ public DeclaringTypeMatcher(ElementMatcher<? super GenericTypeDescription> typeM
 
     @Override
     public boolean matches(T target) {
-        GenericTypeDescription typeDescription = target.getDeclaringType();
-        return typeDescription != null && typeMatcher.matches(typeDescription);
+        TypeDefinition declaringType = target.getDeclaringType();
+        return declaringType != null && typeMatcher.matches(declaringType.asGenericType());
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -700,7 +700,7 @@ public TypeDescription getDeclaringType() {
 
         @Override
         public GenericTypeDescription getReturnType() {
-            return TypeDescription.VOID;
+            return GenericTypeDescription.VOID;
         }
 
         @Override
@@ -1059,7 +1059,7 @@ public TypeInitializer(TypeDescription typeDescription) {
 
             @Override
             public GenericTypeDescription getReturnType() {
-                return TypeDescription.VOID;
+                return GenericTypeDescription.VOID;
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1780,7 +1780,7 @@ public ExceptionDeclarableMethodInterception<S> defineConstructor(List<? extends
                 return new DefaultExceptionDeclarableMethodInterception(new MethodDescription.Token(MethodDescription.CONSTRUCTOR_INTERNAL_NAME,
                         modifiers,
                         Collections.<GenericTypeDescription>emptyList(),
-                        TypeDescription.VOID,
+                        GenericTypeDescription.VOID,
                         new ParameterDescription.Token.TypeList(isActualType(parameterTypes)),
                         Collections.<TypeDescription>emptyList(),
                         Collections.<AnnotationDescription>emptyList(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -2642,7 +2642,7 @@ public ParameterList<ParameterDescription.InDefinedShape> getParameters() {
 
                 @Override
                 public GenericTypeDescription getReturnType() {
-                    return TypeDescription.VOID;
+                    return GenericTypeDescription.VOID;
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolver.java
Patch:
@@ -511,7 +511,7 @@ protected RebasedConstructor(InDefinedShape methodDescription, TypeDescription p
 
                 @Override
                 public GenericTypeDescription getReturnType() {
-                    return TypeDescription.VOID;
+                    return GenericTypeDescription.VOID;
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -1217,7 +1217,7 @@ protected FieldSetter(TypeDescription instrumentedType, FieldDescription fieldDe
 
                 @Override
                 public GenericTypeDescription getReturnType() {
-                    return TypeDescription.VOID;
+                    return GenericTypeDescription.VOID;
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -127,12 +127,11 @@ public static InvocationHandlerAdapter toInstanceField(String fieldName) {
     private List<StackManipulation> argumentValuesOf(MethodDescription instrumentedMethod) {
         TypeList parameterTypes = instrumentedMethod.getParameters().asTypeList().asErasures();
         List<StackManipulation> instruction = new ArrayList<StackManipulation>(parameterTypes.size());
-        TypeDescription objectType = TypeDescription.OBJECT;
         int currentIndex = 1;
         for (TypeDescription parameterType : parameterTypes) {
             instruction.add(new StackManipulation.Compound(
                     MethodVariableAccess.forType(parameterType).loadOffset(currentIndex),
-                    assigner.assign(parameterType, objectType, Assigner.Typing.STATIC)));
+                    assigner.assign(parameterType, TypeDescription.OBJECT, Assigner.Typing.STATIC)));
             currentIndex += parameterType.getStackSize().getSize();
         }
         return instruction;
@@ -173,7 +172,7 @@ protected ByteCodeAppender.Size apply(MethodVisitor methodVisitor,
                 preparingManipulation,
                 FieldAccess.forField(instrumentedType.getDeclaredFields()
                         .filter((named(fieldName))).getOnly()).getter(),
-                MethodVariableAccess.forType(TypeDescription.OBJECT).loadOffset(0),
+                MethodVariableAccess.REFERENCE.loadOffset(0),
                 cacheMethods
                         ? MethodConstant.forMethod(instrumentedMethod.asDefined()).cached()
                         : MethodConstant.forMethod(instrumentedMethod.asDefined()),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -199,7 +199,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
                     "call",
                     Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
                     Collections.<GenericTypeDescription>emptyList(),
-                    TypeDescription.OBJECT,
+                    GenericTypeDescription.OBJECT,
                     Collections.<ParameterDescription.Token>emptyList(),
                     Collections.singletonList(new TypeDescription.ForLoadedType(Exception.class)),
                     Collections.<AnnotationDescription>emptyList(),
@@ -209,7 +209,7 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
                     "run",
                     Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
                     Collections.<GenericTypeDescription>emptyList(),
-                    TypeDescription.VOID,
+                    GenericTypeDescription.VOID,
                     Collections.<ParameterDescription.Token>emptyList(),
                     Collections.<GenericTypeDescription>emptyList(),
                     Collections.<AnnotationDescription>emptyList(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/InliningImplementationMatcher.java
Patch:
@@ -41,12 +41,12 @@ protected InliningImplementationMatcher(ElementMatcher<? super MethodDescription
      * target type are always matched.
      *
      * @param ignoredMethods A method matcher that matches any ignored method.
-     * @param targetType     The target type of the instrumentation before adding any user methods.
+     * @param originalType   The original type of the instrumentation before adding any user methods.
      * @return A latent method matcher that identifies any method to instrument for a rebasement or redefinition.
      */
-    protected static LatentMethodMatcher of(ElementMatcher<? super MethodDescription> ignoredMethods, TypeDescription targetType) {
+    protected static LatentMethodMatcher of(ElementMatcher<? super MethodDescription> ignoredMethods, TypeDescription originalType) {
         ElementMatcher.Junction<MethodDescription> predefinedMethodSignatures = none();
-        for (MethodDescription methodDescription : targetType.getDeclaredMethods()) {
+        for (MethodDescription methodDescription : originalType.getDeclaredMethods()) {
             ElementMatcher.Junction<MethodDescription> signature = methodDescription.isConstructor()
                     ? isConstructor()
                     : ElementMatchers.<MethodDescription>named(methodDescription.getName());

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/AbstractImplementationTest.java
Patch:
@@ -49,7 +49,6 @@ protected <T> DynamicType.Loaded<T> implement(Class<T> target,
                 new NamingStrategy.SuffixingRandom(SUFFIX),
                 new AuxiliaryType.NamingStrategy.SuffixingRandom(SUFFIX),
                 Implementation.Context.Default.Factory.INSTANCE,
-                new TypeDescription.ForLoadedType(target),
                 new TypeList.ForLoadedType(Arrays.asList(interfaces)),
                 Opcodes.ACC_PUBLIC,
                 TypeAttributeAppender.NoOp.INSTANCE,
@@ -60,6 +59,7 @@ protected <T> DynamicType.Loaded<T> implement(Class<T> target,
                 MethodGraph.Compiler.DEFAULT,
                 FieldAttributeAppender.NoOp.INSTANCE,
                 MethodAttributeAppender.NoOp.INSTANCE,
+                new TypeDescription.ForLoadedType(target),
                 ConstructorStrategy.Default.IMITATE_SUPER_TYPE)
                 .invokable(targetMethods).intercept(implementation)
                 .make()

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -770,7 +770,7 @@ public AnnotationList getDeclaredAnnotations() {
 
         @Override
         public GenericTypeList getTypeVariables() {
-            return new GenericTypeList.ForLoadedType(constructor.getTypeParameters());
+            return new GenericTypeList.ForLoadedTypes(constructor.getTypeParameters());
         }
     }
 
@@ -887,7 +887,7 @@ public Object getDefaultValue() {
 
         @Override
         public GenericTypeList getTypeVariables() {
-            return new GenericTypeList.ForLoadedType(method.getTypeParameters());
+            return new GenericTypeList.ForLoadedTypes(method.getTypeParameters());
         }
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -66,7 +66,7 @@ public interface TypeDescription extends GenericTypeDescription, TypeVariableSou
     /**
      * A list of interfaces that are implicitly implemented by any array type.
      */
-    GenericTypeList ARRAY_INTERFACES = new GenericTypeList.ForLoadedType(Cloneable.class, Serializable.class);
+    GenericTypeList ARRAY_INTERFACES = new GenericTypeList.ForLoadedTypes(Cloneable.class, Serializable.class);
 
     /**
      * Represents any undefined property of a type description that is instead represented as {@code null} in order
@@ -1048,7 +1048,7 @@ public int getModifiers() {
 
         @Override
         public GenericTypeList getTypeVariables() {
-            return new GenericTypeList.ForLoadedType(type.getTypeParameters());
+            return new GenericTypeList.ForLoadedTypes(type.getTypeParameters());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -129,7 +129,7 @@ public int getStackSize() {
 
         @Override
         public GenericTypeList asGenericTypes() {
-            return new GenericTypeList.ForLoadedType(types);
+            return new GenericTypeList.ForLoadedTypes(types);
         }
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -317,7 +317,7 @@ public static <T> ElementMatcher.Junction<T> anyOf(Iterable<?> values) {
      * @return A matcher that checks for the equality with any of the given objects.
      */
     public static <T extends GenericTypeDescription> ElementMatcher.Junction<T> anyOf(Type... value) {
-        return anyOf(new GenericTypeList.ForLoadedType(nonNull(value)));
+        return anyOf(new GenericTypeList.ForLoadedTypes(nonNull(value)));
     }
 
     /**
@@ -405,7 +405,7 @@ public static <T> ElementMatcher.Junction<T> noneOf(Iterable<?> values) {
      * @return A matcher that checks for the equality with none of the given objects.
      */
     public static <T extends GenericTypeDescription> ElementMatcher.Junction<T> noneOf(Type... value) {
-        return noneOf(new GenericTypeList.ForLoadedType(nonNull(value)));
+        return noneOf(new GenericTypeList.ForLoadedTypes(nonNull(value)));
     }
 
     /**
@@ -1056,7 +1056,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> returnsGe
      * @return A method matcher that matches a method's generic parameter types against the supplied arguments.
      */
     public static <T extends MethodDescription> ElementMatcher.Junction<T> takesGenericArguments(Type... type) {
-        return takesGenericArguments(new GenericTypeList.ForLoadedType(nonNull(type)));
+        return takesGenericArguments(new GenericTypeList.ForLoadedTypes(nonNull(type)));
     }
 
     /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericTypeListForLoadedTypesTest.java
Patch:
@@ -3,7 +3,7 @@
 import java.lang.reflect.Type;
 import java.util.List;
 
-public class GenericTypeListForLoadedTypeTest extends AbstractGenericTypeListTest<Type> {
+public class GenericTypeListForLoadedTypesTest extends AbstractGenericTypeListTest<Type> {
 
     @Override
     protected Type getFirst() throws Exception {
@@ -17,7 +17,7 @@ protected Type getSecond() throws Exception {
 
     @Override
     protected GenericTypeList asList(List<Type> elements) {
-        return new GenericTypeList.ForLoadedType(elements);
+        return new GenericTypeList.ForLoadedTypes(elements);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TypeProxyCreationTest.java
Patch:
@@ -156,7 +156,7 @@ public void testAllLegalSerializable() throws Exception {
                 .getTypeDescription();
         assertThat(dynamicType.getModifiers(), is(modifiers));
         assertThat(dynamicType.getSuperType(), is((GenericTypeDescription) foo));
-        assertThat(dynamicType.getInterfaces(), is((GenericTypeList) new GenericTypeList.ForLoadedType(Serializable.class)));
+        assertThat(dynamicType.getInterfaces(), is((GenericTypeList) new GenericTypeList.ForLoadedTypes(Serializable.class)));
         assertThat(dynamicType.getName(), is(BAR));
         assertThat(dynamicType.getDeclaredMethods().size(), is(2));
         assertThat(dynamicType.isAssignableTo(Serializable.class), is(true));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -8,6 +8,7 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.description.modifier.Visibility;
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.DynamicType;
@@ -224,7 +225,7 @@ public MethodGraph.Linked compile(TypeDescription typeDescription) {
         }
 
         @Override
-        public MethodGraph.Linked compile(TypeDescription typeDescription, TypeDescription viewPoint) {
+        public MethodGraph.Linked compile(TypeDefinition typeDefinition, TypeDescription viewPoint) {
             return methodGraph;
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -4,6 +4,7 @@
 import net.bytebuddy.description.field.FieldList;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.modifier.ModifierContributor;
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.TargetType;
@@ -269,7 +270,7 @@ public ForInstrumentedTypeHierarchy(TypeDescription instrumentedType) {
 
             @Override
             public FieldDescription locate(String name, boolean staticMethod) {
-                for (GenericTypeDescription currentType : instrumentedType) {
+                for (TypeDefinition currentType : instrumentedType) {
                     FieldList<?> fieldList = currentType.getDeclaredFields().filter(named(name).and(isVisibleTo(instrumentedType)));
                     if (!fieldList.isEmpty() && (!staticMethod || fieldList.getOnly().isStatic())) {
                         return fieldList.getOnly();

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -6,9 +6,9 @@
 import net.bytebuddy.description.field.FieldList;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.ParameterList;
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
 import net.bytebuddy.implementation.bytecode.Removal;
@@ -1706,8 +1706,8 @@ public Resolved resolve(TypeDescription instrumentedType, MethodDescription inst
                  * @return The located field.
                  */
                 private FieldDescription locate(TypeDescription instrumentedType) {
-                    for (GenericTypeDescription currentType : instrumentedType) {
-                        FieldList<?> fieldList = currentType.asErasure().getDeclaredFields().filter(named(fieldName).and(isVisibleTo(instrumentedType)));
+                    for (TypeDefinition currentType : instrumentedType) {
+                        FieldList<?> fieldList = currentType.getDeclaredFields().filter(named(fieldName).and(isVisibleTo(instrumentedType)));
                         if (fieldList.size() != 0) {
                             return fieldList.getOnly();
                         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -5,9 +5,9 @@
 import net.bytebuddy.description.field.FieldList;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.ParameterDescription;
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
-import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.implementation.bytecode.*;
 import net.bytebuddy.implementation.bytecode.assign.Assigner;
@@ -1264,8 +1264,8 @@ public StackManipulation resolve(TypeDescription instrumentedType,
              * @return The located field.
              */
             private FieldDescription locate(TypeDescription instrumentedType) {
-                for (GenericTypeDescription currentType : instrumentedType) {
-                    FieldList<?> fieldList = currentType.asErasure().getDeclaredFields().filter(named(fieldName).and(isVisibleTo(instrumentedType)));
+                for (TypeDefinition currentType : instrumentedType) {
+                    FieldList<?> fieldList = currentType.getDeclaredFields().filter(named(fieldName).and(isVisibleTo(instrumentedType)));
                     if (fieldList.size() != 0) {
                         return fieldList.getOnly();
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -8,6 +8,7 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.method.ParameterDescription;
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.DynamicType;
@@ -956,7 +957,7 @@ protected ForHierarchy(String fieldName) {
 
                     @Override
                     protected Resolution resolve(TypeDescription instrumentedType, boolean staticMethod) {
-                        for (GenericTypeDescription currentType : instrumentedType) {
+                        for (TypeDefinition currentType : instrumentedType) {
                             FieldList<?> fieldList = currentType.getDeclaredFields().filter(named(fieldName).and(isVisibleTo(instrumentedType)));
                             if (!fieldList.isEmpty() && (!staticMethod || fieldList.getOnly().isStatic())) {
                                 return new Resolution.Resolved(fieldList.getOnly());

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldValue.java
Patch:
@@ -6,6 +6,7 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.method.ParameterDescription;
+import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.Implementation;
@@ -261,7 +262,7 @@ protected ForFieldInHierarchy(TypeDescription instrumentedType) {
 
                 @Override
                 protected Resolution resolve(String fieldName, boolean staticMethod) {
-                    for (GenericTypeDescription currentType : instrumentedType) {
+                    for (TypeDefinition currentType : instrumentedType) {
                         FieldList<?> fieldList = currentType.getDeclaredFields().filter(named(fieldName));
                         if (!fieldList.isEmpty() && fieldList.getOnly().isVisibleTo(instrumentedType) && (!staticMethod || fieldList.getOnly().isStatic())) {
                             return new Resolution.Resolved(fieldList.getOnly());

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -1038,7 +1038,7 @@ public byte[] transform(ClassLoader classLoader,
                                     Class<?> redefinedType,
                                     ProtectionDomain protectionDomain,
                                     byte[] classFile) throws IllegalClassFormatException {
-                if (typeName != null && isChild(classLoader) && typeName.equals(internalName.replace('/', '.'))) {
+                if (internalName != null && isChild(classLoader) && typeName.equals(internalName.replace('/', '.'))) {
                     this.binaryRepresentation = classFile;
                 }
                 return DO_NOT_TRANSFORM;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.dynamic.loading;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 
@@ -414,6 +415,7 @@ protected ClassRedefinitionTransformer(Map<Class<?>, ClassDefinition> redefinedC
             }
 
             @Override
+            @SuppressFBWarnings(value = "EI_EXPOSE_REP", justification = "Return value is always null")
             public byte[] transform(ClassLoader classLoader,
                                     String internalTypeName,
                                     Class<?> classBeingRedefined,

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -2984,6 +2984,9 @@ public byte[] transform(ClassLoader classLoader,
                                     Class<?> classBeingRedefined,
                                     ProtectionDomain protectionDomain,
                                     byte[] binaryRepresentation) {
+                if (internalTypeName == null) {
+                    return NO_TRANSFORMATION;
+                }
                 String binaryTypeName = internalTypeName.replace('/', '.');
                 try {
                     ClassFileLocator classFileLocator = ClassFileLocator.Simple.of(binaryTypeName,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -1038,7 +1038,7 @@ public byte[] transform(ClassLoader classLoader,
                                     Class<?> redefinedType,
                                     ProtectionDomain protectionDomain,
                                     byte[] classFile) throws IllegalClassFormatException {
-                if (isChild(classLoader) && typeName.equals(internalName.replace('/', '.'))) {
+                if (typeName != null && isChild(classLoader) && typeName.equals(internalName.replace('/', '.'))) {
                     this.binaryRepresentation = classFile;
                 }
                 return DO_NOT_TRANSFORM;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -419,6 +419,9 @@ public byte[] transform(ClassLoader classLoader,
                                     Class<?> classBeingRedefined,
                                     ProtectionDomain protectionDomain,
                                     byte[] classfileBuffer) throws IllegalClassFormatException {
+                if (internalTypeName == null) {
+                    return NO_REDEFINITION;
+                }
                 ClassDefinition redefinedClass = redefinedClasses.remove(classBeingRedefined);
                 return redefinedClass == null
                         ? NO_REDEFINITION

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodConstant.java
Patch:
@@ -114,8 +114,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
     protected abstract String getDescriptor();
 
     /**
-     * Returns a cached version of this method constant as specified by
-     * {@link net.bytebuddy.implementation.bytecode.constant.MethodConstant.Cached}.
+     * Returns a cached version of this method constant as specified by {@link CachedMethod} and {@link CachedConstructor}.
      *
      * @return A cached version of this method constant.
      */

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategyTest.java
Patch:
@@ -161,6 +161,7 @@ public void testObjectProperties() throws Exception {
             @Override
             public void apply(Instrumentation mock) {
                 when(mock.isRedefineClassesSupported()).thenReturn(true);
+                when(mock.isRetransformClassesSupported()).thenReturn(true);
             }
         }).apply();
         ObjectPropertyAssertion.of(ClassReloadingStrategy.BootstrapInjection.Enabled.class).apply();

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -547,7 +547,7 @@ public ClassFileLocator classFileLocator(ClassLoader classLoader) {
 
             @Override
             public TypePool typePool(ClassFileLocator classFileLocator, ClassLoader classLoader) {
-                return new TypePool.LazyFacade(new TypePool.Default.Precomputed(new TypePool.CacheProvider.Simple(), classFileLocator, readerMode));
+                return new TypePool.LazyFacade(TypePool.Default.Precomputed.withObjectType(new TypePool.CacheProvider.Simple(), classFileLocator, readerMode));
             }
 
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultPrecomputedTest.java
Patch:
@@ -16,7 +16,7 @@ public class TypePoolDefaultPrecomputedTest {
 
     @Before
     public void setUp() throws Exception {
-        typePool = new TypePool.Default.Precomputed(new TypePool.CacheProvider.Simple(),
+        typePool = TypePool.Default.Precomputed.withObjectType(new TypePool.CacheProvider.Simple(),
                 ClassFileLocator.ForClassLoader.ofClassPath(),
                 TypePool.Default.ReaderMode.FAST);
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -547,7 +547,7 @@ public ClassFileLocator classFileLocator(ClassLoader classLoader) {
 
             @Override
             public TypePool typePool(ClassFileLocator classFileLocator, ClassLoader classLoader) {
-                return new TypePool.LazyFacade(new TypePool.Default(new TypePool.CacheProvider.Simple(), classFileLocator, readerMode));
+                return new TypePool.LazyFacade(new TypePool.Default.Precomputed(new TypePool.CacheProvider.Simple(), classFileLocator, readerMode));
             }
 
             @Override
@@ -583,7 +583,7 @@ public ClassFileLocator classFileLocator(ClassLoader classLoader) {
 
             @Override
             public TypePool typePool(ClassFileLocator classFileLocator, ClassLoader classLoader) {
-                return new TypePool.LazyFacade(TypePool.ClassLoading.of(classFileLocator, classLoader));
+                return new TypePool.LazyFacade(TypePool.Default.ClassLoading.of(classFileLocator, classLoader));
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Super.java
Patch:
@@ -231,7 +231,9 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             TypeDescription proxyType = TypeLocator.ForType
                     .of(annotation.getValue(PROXY_TYPE, TypeDescription.class))
                     .resolve(implementationTarget.getTypeDescription(), target.getType());
-            if (source.isStatic() || !implementationTarget.getTypeDescription().isAssignableTo(proxyType)) {
+            if (proxyType.isFinal()) {
+                throw new IllegalStateException("Cannot extend final type as @Super proxy: " + proxyType);
+            } else if (source.isStatic() || !implementationTarget.getTypeDescription().isAssignableTo(proxyType)) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             } else {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(annotation

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -286,6 +286,7 @@ public static Instrumentation getInstrumentation() {
      *
      * @return The Byte Buddy agent's {@link java.lang.instrument.Instrumentation} instance.
      */
+    @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Legal state where reflection communicates errors by exception")
     private static Instrumentation doGetInstrumentation() {
         try {
             return (Instrumentation) ClassLoader.getSystemClassLoader()

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.agent.builder;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
@@ -998,6 +999,7 @@ protected enum NexusAccessor {
                 /**
                  * Creates the singleton accessor.
                  */
+                @SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Explicit delegation of the exception")
                 NexusAccessor() {
                     Dispatcher dispatcher;
                     try {

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/TypeConstantAdjustment.java
Patch:
@@ -122,7 +122,7 @@ public void visitLdcInsn(Object constant) {
                     switch (type.getSort()) {
                         case Type.OBJECT:
                         case Type.ARRAY:
-                            super.visitLdcInsn(type.getClassName());
+                            super.visitLdcInsn(type.getInternalName().replace('/', '.'));
                             super.visitMethodInsn(Opcodes.INVOKESTATIC, JAVA_LANG_CLASS, FOR_NAME, DESCRIPTOR, false);
                             return;
                     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/TypeConstantAdjustmentTest.java
Patch:
@@ -91,7 +91,7 @@ public void testInstrumentationLegacyClassFileArrayType() throws Exception {
         verify(this.classVisitor).visit(ClassFileVersion.JAVA_V4.getMinorMajorVersion(), FOOBAR, FOO, BAR, QUX, new String[]{BAZ});
         verify(this.classVisitor).visitMethod(FOOBAR, FOO, BAR, QUX, new String[]{BAZ});
         verifyNoMoreInteractions(this.classVisitor);
-        verify(this.methodVisitor).visitLdcInsn(Type.getType(Object[].class).getClassName());
+        verify(this.methodVisitor).visitLdcInsn(Type.getType(Object[].class).getInternalName().replace('/', '.'));
         verify(this.methodVisitor).visitMethodInsn(Opcodes.INVOKESTATIC,
                 Type.getType(Class.class).getInternalName(),
                 "forName",

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/AbstractImplementationTest.java
Patch:
@@ -31,8 +31,7 @@ public abstract class AbstractImplementationTest {
 
     private static final String SUFFIX = "foo";
 
-    protected <T> DynamicType.Loaded<T> implement(Class<T> target,
-                                                  Implementation implementation) {
+    protected <T> DynamicType.Loaded<T> implement(Class<T> target, Implementation implementation) {
         return implement(target, implementation, target.getClassLoader(), isDeclaredBy(target));
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/TypeConstantAdjustment.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.asm;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.ClassFileVersion;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.MethodVisitor;
@@ -116,6 +117,7 @@ protected TypeConstantDissolvingMethodVisitor(MethodVisitor methodVisitor) {
             }
 
             @Override
+            @SuppressFBWarnings(value = "SF_SWITCH_NO_DEFAULT", justification = "Fall through to default case is intentional")
             public void visitLdcInsn(Object constant) {
                 if (constant instanceof Type) {
                     Type type = (Type) constant;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.dynamic.scaffold;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.asm.ClassVisitorWrapper;
 import net.bytebuddy.description.annotation.AnnotationList;
@@ -2335,6 +2336,7 @@ public AnnotationVisitor visitAnnotationDefault() {
                 }
 
                 @Override
+                @SuppressFBWarnings(value = "SF_SWITCH_NO_DEFAULT", justification = "Fall through to default case is intentional")
                 public void visitLdcInsn(Object constant) {
                     if (constant instanceof Type) {
                         Type type = (Type) constant;

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -146,7 +146,7 @@ public static ClassFileVersion forCurrentJavaVersion() {
      *
      * @return The minor-major release number of this class file version.
      */
-    public int getVersion() {
+    public int getMinorMajorVersion() {
         return versionNumber;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -3167,7 +3167,7 @@ protected ForCreation(TypeDescription instrumentedType,
             public byte[] create(Implementation.Context.ExtractableView implementationContext) {
                 ClassWriter classWriter = new ClassWriter(classVisitorWrapper.mergeWriter(ASM_NO_FLAGS));
                 ClassVisitor classVisitor = classVisitorWrapper.wrap(new ValidatingClassVisitor(classWriter));
-                classVisitor.visit(classFileVersion.getVersion(),
+                classVisitor.visit(classFileVersion.getMinorMajorVersion(),
                         instrumentedType.getActualModifiers(!instrumentedType.isInterface()),
                         instrumentedType.getInternalName(),
                         instrumentedType.getGenericSignature(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/ClassFileVersionKnownVersionsTest.java
Patch:
@@ -63,7 +63,7 @@ public static Collection<Object[]> data() {
 
     @Test
     public void testVersion() throws Exception {
-        assertThat(ClassFileVersion.ofJavaVersion(javaVersion).getVersion(), is(minorMajorVersion));
+        assertThat(ClassFileVersion.ofJavaVersion(javaVersion).getMinorMajorVersion(), is(minorMajorVersion));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/ClassFileVersionTest.java
Patch:
@@ -14,12 +14,12 @@ public class ClassFileVersionTest {
     public void testCurrentJavaVersionWasManuallyEvaluated() throws Exception {
         // This test is supposed to fail if ByteBuddy was not yet manually considered for
         // a new major release targeting Java.
-        assertTrue(ClassFileVersion.forCurrentJavaVersion().getVersion() <= Opcodes.V1_8);
+        assertTrue(ClassFileVersion.forCurrentJavaVersion().getMinorMajorVersion() <= Opcodes.V1_8);
     }
 
     @Test
     public void testExplicitConstructionOfUnknownVersion() throws Exception {
-        assertThat(ClassFileVersion.ofMinorMajor(Opcodes.V1_8 + 1).getVersion(), is(Opcodes.V1_8 + 1));
+        assertThat(ClassFileVersion.ofMinorMajor(Opcodes.V1_8 + 1).getMinorMajorVersion(), is(Opcodes.V1_8 + 1));
     }
 
     @Test(expected = IllegalArgumentException.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -135,7 +135,7 @@ public void testSuccessfulWithoutExistingClass() throws Exception {
         verify(dispatcher).apply(builder);
         verify(dispatcher).register(REDEFINED.getName(),
                 REDEFINED.getClassLoader(),
-                new AgentBuilder.InitializationStrategy.Dispatcher.InitializerConstructor.Simple(loadedTypeInitializer));
+                new AgentBuilder.InitializationStrategy.Dispatcher.LazyInitializer.Simple(loadedTypeInitializer));
         verifyNoMoreInteractions(dispatcher);
     }
 
@@ -164,7 +164,7 @@ public void testSuccessfulWithExistingClass() throws Exception {
         verify(dispatcher).apply(builder);
         verify(dispatcher).register(REDEFINED.getName(),
                 REDEFINED.getClassLoader(),
-                new AgentBuilder.InitializationStrategy.Dispatcher.InitializerConstructor.Simple(loadedTypeInitializer));
+                new AgentBuilder.InitializationStrategy.Dispatcher.LazyInitializer.Simple(loadedTypeInitializer));
         verifyNoMoreInteractions(dispatcher);
     }
 
@@ -490,7 +490,7 @@ public void testSuccessfulWithRedefinitionMatched() throws Exception {
         verify(dispatcher).apply(builder);
         verify(dispatcher).register(REDEFINED.getName(),
                 REDEFINED.getClassLoader(),
-                new AgentBuilder.InitializationStrategy.Dispatcher.InitializerConstructor.Simple(loadedTypeInitializer));
+                new AgentBuilder.InitializationStrategy.Dispatcher.LazyInitializer.Simple(loadedTypeInitializer));
         verifyNoMoreInteractions(dispatcher);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTransformationSimpleResolutionAuxiliaryTypeInitializerTest.java
Patch:
@@ -70,7 +70,7 @@ public void testCreationWithAuxiliaryTypes() throws Exception {
                 dynamicType,
                 classLoader,
                 protectionDomain,
-                accessControlContext), is((AgentBuilder.InitializationStrategy.Dispatcher.InitializerConstructor)
+                accessControlContext), is((AgentBuilder.InitializationStrategy.Dispatcher.LazyInitializer)
                 new AgentBuilder.Default.Transformation.Simple.Resolution.AuxiliaryTypeInitializer(bootstrapInjectionStrategy,
                         instrumentedType,
                         classLoader,
@@ -90,8 +90,8 @@ public void testCreationWithoutAuxiliaryTypes() throws Exception {
                 classLoader,
                 protectionDomain,
                 accessControlContext),
-                is((AgentBuilder.InitializationStrategy.Dispatcher.InitializerConstructor)
-                        new AgentBuilder.InitializationStrategy.Dispatcher.InitializerConstructor.Simple(loadedTypeInitializer)));
+                is((AgentBuilder.InitializationStrategy.Dispatcher.LazyInitializer)
+                        new AgentBuilder.InitializationStrategy.Dispatcher.LazyInitializer.Simple(loadedTypeInitializer)));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverDefaultTest.java
Patch:
@@ -59,7 +59,7 @@ public void setUp() throws Exception {
         when(methodDescription.getInternalName()).thenReturn(FOO);
         when(methodNameTransformer.transform(methodDescription)).thenReturn(BAR);
         when(auxiliaryTypeNamingStrategy.name(instrumentedType)).thenReturn(QUX);
-        when(classFileVersion.getVersion()).thenReturn(Opcodes.V1_6);
+        when(classFileVersion.getMinorMajorVersion()).thenReturn(Opcodes.V1_6);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/AnnotationAppenderDefaultTest.java
Patch:
@@ -107,7 +107,7 @@ public void testMultipleArgumentAnnotation() throws Exception {
     private Class<?> makeTypeWithAnnotation(Annotation annotation) throws Exception {
         when(valueFilter.isRelevant(any(AnnotationDescription.class), any(MethodDescription.InDefinedShape.class))).thenReturn(true);
         ClassWriter classWriter = new ClassWriter(ASM_MANUAL);
-        classWriter.visit(ClassFileVersion.forCurrentJavaVersion().getVersion(),
+        classWriter.visit(ClassFileVersion.forCurrentJavaVersion().getMinorMajorVersion(),
                 Opcodes.ACC_PUBLIC,
                 BAR.replace('.', '/'),
                 null,

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TrivialTypeTest.java
Patch:
@@ -29,7 +29,7 @@ public class TrivialTypeTest {
 
     @Test
     public void testCreation() throws Exception {
-        when(classFileVersion.getVersion()).thenReturn(ClassFileVersion.JAVA_V5.getVersion());
+        when(classFileVersion.getMinorMajorVersion()).thenReturn(ClassFileVersion.JAVA_V5.getMinorMajorVersion());
         DynamicType dynamicType = TrivialType.INSTANCE.make(FOO, classFileVersion, methodAccessorFactory);
         assertThat(dynamicType.getTypeDescription().getName(), is(FOO));
         assertThat(dynamicType.getTypeDescription().getModifiers(), is(Opcodes.ACC_SYNTHETIC));

File: byte-buddy-dep/src/test/java/net/bytebuddy/ClassFileVersionKnownVersionsTest.java
Patch:
@@ -78,17 +78,17 @@ public void testMajorVersion() throws Exception {
 
     @Test
     public void testAtLeastJava5() throws Exception {
-        assertThat(ClassFileVersion.ofJavaVersion(javaVersion).isAtLeastJava5(), is(atLeastJava5));
+        assertThat(ClassFileVersion.ofJavaVersion(javaVersion).isAtLeast(ClassFileVersion.JAVA_V5), is(atLeastJava5));
     }
 
     @Test
     public void testAtLeastJava7() throws Exception {
-        assertThat(ClassFileVersion.ofJavaVersion(javaVersion).isAtLeastJava7(), is(atLeastJava7));
+        assertThat(ClassFileVersion.ofJavaVersion(javaVersion).isAtLeast(ClassFileVersion.JAVA_V7), is(atLeastJava7));
     }
 
     @Test
     public void testAtLeastJava8() throws Exception {
-        assertThat(ClassFileVersion.ofJavaVersion(javaVersion).isAtLeastJava8(), is(atLeastJava8));
+        assertThat(ClassFileVersion.ofJavaVersion(javaVersion).isAtLeast(ClassFileVersion.JAVA_V8), is(atLeastJava8));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -569,12 +569,12 @@ enum ClassLoading implements BinaryLocator {
 
             @Override
             public ClassFileLocator classFileLocator(ClassLoader classLoader) {
-                return ClassFileLocator.ForClassLoader.of(classLoader);
+                return ClassFileLocator.NoOp.INSTANCE;
             }
 
             @Override
             public TypePool typePool(ClassFileLocator classFileLocator, ClassLoader classLoader) {
-                return new TypePool.ClassLoading(classLoader);
+                return new TypePool.LazyFacade(TypePool.ClassLoading.of(classFileLocator, classLoader));
             }
 
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderBinaryLocatorTest.java
Patch:
@@ -39,7 +39,7 @@ public void testExtendedClassFileLocator() throws Exception {
     @Test
     public void testLoadingClassFileLocator() throws Exception {
         assertThat(AgentBuilder.BinaryLocator.ClassLoading.INSTANCE.classFileLocator(classLoader),
-                is(ClassFileLocator.ForClassLoader.of(classLoader)));
+                is((ClassFileLocator) ClassFileLocator.NoOp.INSTANCE));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -84,10 +84,11 @@ protected ClassFileVersion(int versionNumber) {
      * @return A representation of the version number.
      */
     public static ClassFileVersion ofMinorMajor(int versionNumber) {
-        if (versionNumber <= BASE_VERSION) {
+        ClassFileVersion classFileVersion = new ClassFileVersion(versionNumber);
+        if (classFileVersion.getMajorVersion() <= BASE_VERSION) {
             throw new IllegalArgumentException("Class version " + versionNumber + " is not valid");
         }
-        return new ClassFileVersion(versionNumber);
+        return classFileVersion;
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -1046,7 +1046,7 @@ public ByteCodeAppender identifiedBy(int identification) {
 
                 @Override
                 public String toString() {
-                    return "AgentBuilder.InitializationStrategy.SelfInjection.Nexus.Accessor." + name();
+                    return "AgentBuilder.InitializationStrategy.SelfInjection.NexusAccessor." + name();
                 }
 
                 /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TrivialTypeTest.java
Patch:
@@ -29,7 +29,7 @@ public class TrivialTypeTest {
 
     @Test
     public void testCreation() throws Exception {
-        when(classFileVersion.getVersion()).thenReturn(ClassFileVersion.JAVA_V5.getJavaVersion());
+        when(classFileVersion.getVersion()).thenReturn(ClassFileVersion.JAVA_V5.getVersion());
         DynamicType dynamicType = TrivialType.INSTANCE.make(FOO, classFileVersion, methodAccessorFactory);
         assertThat(dynamicType.getTypeDescription().getName(), is(FOO));
         assertThat(dynamicType.getTypeDescription().getModifiers(), is(Opcodes.ACC_SYNTHETIC));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Forwarding.java
Patch:
@@ -66,7 +66,7 @@ protected Forwarding(String fieldName, TypeDescription fieldType, PreparationHan
      * @return A corresponding implementation.
      */
     public static Implementation to(Object delegate) {
-        return to(delegate, String.format("%s$%d", FIELD_PREFIX, delegate.hashCode()));
+        return to(delegate, String.format("%s$%d", FIELD_PREFIX, Math.abs(delegate.hashCode() % Integer.MAX_VALUE)));
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -367,7 +367,7 @@ public static MethodDelegation to(Object delegate, Class<?> type) {
      * @return A method delegation implementation to the given instance methods.
      */
     public static MethodDelegation to(Object delegate, Class<?> type, MethodGraph.Compiler methodGraphCompiler) {
-        return to(delegate, type, String.format("%s$%d", ImplementationDelegate.ForStaticField.PREFIX, delegate.hashCode()), methodGraphCompiler);
+        return to(delegate, type, String.format("%s$%d", ImplementationDelegate.ForStaticField.PREFIX,  Math.abs(delegate.hashCode() % Integer.MAX_VALUE)), methodGraphCompiler);
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -231,6 +231,7 @@ public DynamicType.Unloaded<T> make() {
                         targetType.getDeclaringType(),
                         targetType.getEnclosingMethod(),
                         targetType.getEnclosingType(),
+                        targetType.getDeclaredTypes(),
                         targetType.isMemberClass(),
                         targetType.isAnonymousClass(),
                         targetType.isLocalClass()),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -218,6 +218,7 @@ public DynamicType.Unloaded<T> make() {
                         targetType.getDeclaringType(),
                         targetType.getEnclosingMethod(),
                         targetType.getEnclosingType(),
+                        targetType.getDeclaredTypes(),
                         targetType.isMemberClass(),
                         targetType.isAnonymousClass(),
                         targetType.isLocalClass()),

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -99,7 +99,7 @@ public void setUp() throws Exception {
         when(unloaded.getBytes()).thenReturn(BAZ);
         when(transformer.transform(builder, new TypeDescription.ForLoadedType(REDEFINED))).thenReturn((DynamicType.Builder) builder);
         when(binaryLocator.classFileLocator(REDEFINED.getClassLoader())).thenReturn(classFileLocator);
-        when(binaryLocator.typePool(any(ClassFileLocator.class))).thenReturn(typePool);
+        when(binaryLocator.typePool(any(ClassFileLocator.class), any(ClassLoader.class))).thenReturn(typePool);
         when(typePool.describe(REDEFINED.getName())).thenReturn(resolution);
         when(instrumentation.getAllLoadedClasses()).thenReturn(new Class<?>[]{REDEFINED});
         when(initializationStrategy.dispatcher()).thenReturn(dispatcher);

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -19,7 +19,7 @@ public interface TypeList extends FilterableList<TypeDescription, TypeList> {
     /**
      * Represents that a type list does not contain any values for ASM interoperability which is represented by {@code null}.
      */
-    @SuppressFBWarnings(value = "MS_MUTABLE_ARRAY", justification = "Value is null")
+    @SuppressFBWarnings(value = {"MS_MUTABLE_ARRAY", "MS_OOI_PKGPROTECT"}, justification = "value is null and should be available to extensions")
     String[] NO_INTERFACES = null;
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/AuxiliaryType.java
Patch:
@@ -21,7 +21,8 @@ public interface AuxiliaryType {
     /**
      * The default type access of an auxiliary type. <b>This array must not be mutated</b>.
      */
-    @SuppressFBWarnings(value = "MS_MUTABLE_ARRAY", justification = "Favor simplicity with current API in overall immutable library layout")
+    @SuppressFBWarnings(value = {"MS_MUTABLE_ARRAY", "MS_OOI_PKGPROTECT"},
+            justification = "Favor simplicity with current API in overall immutable library layout - value should be accessible to extensions")
     ModifierContributor.ForType[] DEFAULT_TYPE_MODIFIER = {SyntheticState.SYNTHETIC};
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/LoadedTypeInitializer.java
Patch:
@@ -1,5 +1,7 @@
 package net.bytebuddy.implementation;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+
 import java.io.Serializable;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
@@ -192,6 +194,7 @@ public String toString() {
     /**
      * A compound loaded type initializer that combines several type initializers.
      */
+    @SuppressFBWarnings(value = "SE_BAD_FIELD", justification = "Serialization is considered opt-in for a rare use case")
     class Compound implements LoadedTypeInitializer, Serializable {
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -793,7 +793,7 @@ public FieldDescription cache(StackManipulation fieldValue, TypeDescription fiel
                     return fieldCache;
                 }
                 if (!fieldCacheCanAppendEntries) {
-                    throw new IllegalStateException("Cached values cannot be registered after defining the type initiailizer for " + instrumentedType);
+                    throw new IllegalStateException("Cached values cannot be registered after defining the type initializer for " + instrumentedType);
                 }
                 fieldCache = new CacheValueField(instrumentedType, fieldType, suffix, fieldValue.hashCode());
                 registeredFieldCacheEntries.put(fieldCacheEntry, fieldCache);

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -971,6 +971,7 @@ public static TypePool ofClassPath() {
          * Creates a default {@link net.bytebuddy.pool.TypePool} that looks up data by querying the supplied class
          * file locator. The returned instance is configured to use a fast reading mode and a simple cache.
          *
+         * @param classFileLocator The class file locator to use.
          * @return A type pool that reads its data from the system class path.
          */
         public static TypePool of(ClassFileLocator classFileLocator) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -3071,11 +3071,11 @@ public TypeDescription getTypeDescription() {
 
         @Override
         public Map<TypeDescription, byte[]> getAllTypes() {
-            Map<TypeDescription, byte[]> allTypes = new HashMap<TypeDescription, byte[]>(auxiliaryTypes.size() + 1);
+            Map<TypeDescription, byte[]> allTypes = new LinkedHashMap<TypeDescription, byte[]>(auxiliaryTypes.size() + 1);
+            allTypes.put(typeDescription, binaryRepresentation);
             for (DynamicType auxiliaryType : auxiliaryTypes) {
                 allTypes.putAll(auxiliaryType.getAllTypes());
             }
-            allTypes.put(typeDescription, binaryRepresentation);
             return allTypes;
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -124,7 +124,7 @@ class UsingReflection implements ClassInjector {
          * @param classLoader The {@link java.lang.ClassLoader} into which new class definitions are to be injected.
          */
         public UsingReflection(ClassLoader classLoader) {
-            this(classLoader, DEFAULT_PROTECTION_DOMAIN,  AccessController.getContext());
+            this(classLoader, DEFAULT_PROTECTION_DOMAIN, AccessController.getContext());
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -1056,7 +1056,9 @@ private static <W> Entry<W> combine(Entry<W> left, Entry<W> right) {
                             TypeDescription leftType = leftMethod.getDeclaringType().asErasure();
                             for (MethodDescription rightMethod : rightMethods) {
                                 TypeDescription rightType = rightMethod.getDeclaringType().asErasure();
-                                if (leftType.isAssignableTo(rightType)) {
+                                if (leftType.equals(rightType)) {
+                                    break;
+                                } else if (leftType.isAssignableTo(rightType)) {
                                     combined.remove(rightMethod);
                                     break;
                                 } else if (leftType.isAssignableFrom(rightType)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -192,6 +192,9 @@ protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {
          */
         private final MethodGraph.Linked methodGraph;
 
+        /**
+         * Creates the precomputed method graph.
+         */
         PrecomputedMethodGraph() {
             LinkedHashMap<MethodDescription.Token, MethodGraph.Node> nodes = new LinkedHashMap<MethodDescription.Token, MethodGraph.Node>(2);
             MethodDescription callMethod = new TypeDescription.ForLoadedType(Callable.class).getDeclaredMethods().filter(named("call")).getOnly();

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderInitializationStrategyTest.java
Patch:
@@ -42,6 +42,7 @@ public void testNexusIsPublic() throws Exception {
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(AgentBuilder.Default.InitializationStrategy.NoOp.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.Default.InitializationStrategy.SelfInjection.class).apply();
+        ObjectPropertyAssertion.of(AgentBuilder.Default.InitializationStrategy.SelfInjection.Dispatcher.class).apply();
         final Iterator<Class<?>> iterator = Arrays.<Class<?>>asList(Object.class, String.class).iterator();
         ObjectPropertyAssertion.of(AgentBuilder.Default.InitializationStrategy.SelfInjection.Nexus.class).create(new ObjectPropertyAssertion.Creator<Class<?>>() {
             @Override
@@ -50,5 +51,6 @@ public Class<?> create() {
             }
         }).apply();
         ObjectPropertyAssertion.of(AgentBuilder.Default.InitializationStrategy.SelfInjection.Nexus.Accessor.class).apply();
+        ObjectPropertyAssertion.of(AgentBuilder.Default.InitializationStrategy.SelfInjection.Nexus.Accessor.InitializationAppender.class).apply();
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -1620,7 +1620,7 @@ public Object getValue(MethodDescription.InDefinedShape methodDescription) {
                 throw new IllegalArgumentException(methodDescription + " does not represent " + annotation.annotationType());
             }
             try {
-                boolean accessible = methodDescription.isAccessibleTo(new TypeDescription.ForLoadedType(getClass()));
+                boolean accessible = Modifier.isPublic(methodDescription.getDeclaringType().getModifiers()); // method is required to be public
                 Method method = methodDescription instanceof MethodDescription.ForLoadedMethod
                         ? ((MethodDescription.ForLoadedMethod) methodDescription).getLoadedMethod()
                         : null;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -419,7 +419,7 @@ public Implementation withAssigner(Assigner assigner, Assigner.Typing typing) {
         public InstrumentedType prepare(InstrumentedType instrumentedType) {
             return instrumentedType
                     .withField(new FieldDescription.Token(fieldName, Opcodes.ACC_SYNTHETIC | Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, fieldType))
-                    .withInitializer(LoadedTypeInitializer.ForStaticField.accessible(fieldName, fixedValue));
+                    .withInitializer(new LoadedTypeInitializer.ForStaticField(fieldName, fixedValue));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Forwarding.java
Patch:
@@ -285,7 +285,7 @@ public ForStaticInstance(Object target) {
             public InstrumentedType prepare(InstrumentedType instrumentedType, String fieldName, TypeDescription fieldType) {
                 return instrumentedType
                         .withField(new FieldDescription.Token(fieldName, Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, fieldType))
-                        .withInitializer(LoadedTypeInitializer.ForStaticField.accessible(fieldName, target));
+                        .withInitializer(new LoadedTypeInitializer.ForStaticField(fieldName, target));
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -258,7 +258,7 @@ public Implementation withAssigner(Assigner assigner) {
         public InstrumentedType prepare(InstrumentedType instrumentedType) {
             return instrumentedType
                     .withField(new FieldDescription.Token(fieldName, Opcodes.ACC_SYNTHETIC | Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, INVOCATION_HANDLER_TYPE))
-                    .withInitializer(LoadedTypeInitializer.ForStaticField.accessible(fieldName, invocationHandler));
+                    .withInitializer(new LoadedTypeInitializer.ForStaticField(fieldName, invocationHandler));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -1577,7 +1577,7 @@ public Resolved resolve(TypeDescription instrumentedType, MethodDescription inst
                 public InstrumentedType prepare(InstrumentedType instrumentedType) {
                     return instrumentedType
                             .withField(new FieldDescription.Token(name, Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, typeDescription))
-                            .withInitializer(LoadedTypeInitializer.ForStaticField.accessible(name, value));
+                            .withInitializer(new LoadedTypeInitializer.ForStaticField(name, value));
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -689,7 +689,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
                         .withField(new FieldDescription.Token(fieldName,
                                 Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
                                 new TypeDescription.ForLoadedType(target.getClass())))
-                        .withInitializer(LoadedTypeInitializer.ForStaticField.accessible(fieldName, target));
+                        .withInitializer(new LoadedTypeInitializer.ForStaticField(fieldName, target));
             }
 
             @Override
@@ -1071,7 +1071,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
                         .withField(new FieldDescription.Token(fieldName,
                                 Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
                                 new TypeDescription.ForLoadedType(value.getClass())))
-                        .withInitializer(new LoadedTypeInitializer.ForStaticField<Object>(fieldName, value, true));
+                        .withInitializer(new LoadedTypeInitializer.ForStaticField(fieldName, value));
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -829,7 +829,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
                         .withField(new FieldDescription.Token(fieldName,
                                 Opcodes.ACC_SYNTHETIC | Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC,
                                 new TypeDescription.ForLoadedType(delegate.getClass())))
-                        .withInitializer(LoadedTypeInitializer.ForStaticField.accessible(fieldName, delegate));
+                        .withInitializer(new LoadedTypeInitializer.ForStaticField(fieldName, delegate));
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -119,7 +119,7 @@ class UsingReflection implements ClassInjector {
 
         /**
          * Creates a new injector for the given {@link java.lang.ClassLoader} and a default {@link java.security.ProtectionDomain},
-         * {@link PackageDefinitionStrategy}, {@link AccessControlContext} which triggers a failure when discovering existent classes.
+         * {@link PackageDefinitionStrategy}, {@link AccessControlContext} which does not trigger an error when discovering existent classes.
          *
          * @param classLoader The {@link java.lang.ClassLoader} into which new class definitions are to be injected.
          */
@@ -129,7 +129,7 @@ public UsingReflection(ClassLoader classLoader) {
 
         /**
          * Creates a new injector for the given {@link java.lang.ClassLoader} and a default {@link PackageDefinitionStrategy} where the
-         * injection of existent classes triggers an error.
+         * injection of existent classes does not trigger an error.
          *
          * @param classLoader          The {@link java.lang.ClassLoader} into which new class definitions are to be injected.
          * @param protectionDomain     The protection domain to apply during class definition.

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -7,7 +7,6 @@
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.loading.ClassInjector;
-import net.bytebuddy.dynamic.loading.PackageDefinitionStrategy;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.dynamic.scaffold.inline.MethodRebaseResolver;
 import net.bytebuddy.implementation.Implementation;
@@ -2276,10 +2275,10 @@ public byte[] apply(InitializationStrategy initializationStrategy,
                         DynamicType.Unloaded<?> dynamicType = initializationStrategy.apply(transformer.transform(typeStrategy.builder(typeDescription,
                                 byteBuddy, classFileLocator, methodNameTransformer), typeDescription)).make();
                         Map<TypeDescription, LoadedTypeInitializer> loadedTypeInitializers = dynamicType.getLoadedTypeInitializers();
-                        if (!loadedTypeInitializers.isEmpty()) {
+                        if (loadedTypeInitializers.size() > 1) { // There exist auxiliary classes.
                             ClassInjector classInjector = classLoader == null
                                     ? bootstrapInjectionStrategy.make(protectionDomain)
-                                    : new ClassInjector.UsingReflection(classLoader, protectionDomain, accessControlContext, PackageDefinitionStrategy.NoOp.INSTANCE, true);
+                                    : new ClassInjector.UsingReflection(classLoader, protectionDomain, accessControlContext);
                             for (Map.Entry<TypeDescription, Class<?>> auxiliary : classInjector.inject(dynamicType.getRawAuxiliaryTypes()).entrySet()) {
                                 initializationStrategy.initialize(auxiliary.getValue(), loadedTypeInitializers.get(auxiliary.getKey()));
                             }

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultApplicationTest.java
Patch:
@@ -131,6 +131,7 @@ public void testRedefinition() throws Exception {
                 .withTypeStrategy(AgentBuilder.TypeStrategy.REDEFINE)
                 .withRedefinitionStrategy(AgentBuilder.RedefinitionStrategy.REDEFINITION)
                 .type(isAnnotatedWith(ShouldRebase.class), ElementMatchers.is(classLoader)).transform(new FooTransformer())
+                .withListener(AgentBuilder.Listener.NoOp.INSTANCE)
                 .installOnByteBuddyAgent();
         try {
             Class<?> type = classLoader.loadClass(Foo.class.getName());

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -197,7 +197,7 @@ public void testSuccessfulWithRetransformationMatched() throws Exception {
         verifyNoMoreInteractions(rawMatcher);
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test(expected = IllegalArgumentException.class)
     public void testRetransformationNotSupported() throws Exception {
         new AgentBuilder.Default(byteBuddy)
                 .withInitialization(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)
@@ -292,7 +292,7 @@ public void testSuccessfulWithRedefinitionMatched() throws Exception {
         verifyNoMoreInteractions(rawMatcher);
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test(expected = IllegalArgumentException.class)
     public void testRedefinitionNotSupported() throws Exception {
         new AgentBuilder.Default(byteBuddy)
                 .withInitialization(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/PackageDefinitionStrategyTypeSimpleTest.java
Patch:
@@ -19,7 +19,7 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
 
-public class PackageDefinitionStrategyDefinitionSimpleTest {
+public class PackageDefinitionStrategyTypeSimpleTest {
 
     private static final String FOO = "foo", BAR = "bar", QUX = "qux", BAZ = "baz";
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/PackageDefinitionStrategyTypeTrivialTest.java
Patch:
@@ -9,7 +9,7 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
 
-public class PackageDefinitionStrategyDefinitionTrivialTest {
+public class PackageDefinitionStrategyTypeTrivialTest {
 
     @Test
     public void testIsDefined() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/PackageDefinitionStrategyTypeUndefinedTest.java
Patch:
@@ -6,7 +6,7 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
 
-public class PackageDefinitionStrategyDefinitionUndefinedTest {
+public class PackageDefinitionStrategyTypeUndefinedTest {
 
     @Test
     public void testIsUndefined() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/PackageTypeStrategyManifestReadingTest.java
Patch:
@@ -28,7 +28,7 @@
 import static org.junit.Assert.assertThat;
 import static org.mockito.Mockito.*;
 
-public class PackageDefinitionStrategyManifestReadingTest {
+public class PackageTypeStrategyManifestReadingTest {
 
     private static final String FOO = "foo", BAR = "bar", QUX = "qux", BAZ = "baz";
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/PackageTypeStrategyNoOpTest.java
Patch:
@@ -6,7 +6,7 @@
 import static org.hamcrest.core.Is.is;
 import static org.junit.Assert.assertThat;
 
-public class PackageDefinitionStrategyNoOpTest {
+public class PackageTypeStrategyNoOpTest {
 
     private static final String FOO = "foo", BAR = "bar";
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/AbstractMethodDescriptionTest.java
Patch:
@@ -30,9 +30,9 @@ public abstract class AbstractMethodDescriptionTest {
     @Rule
     public MethodRule javaVersionRule = new JavaVersionRule();
 
-    private Method firstMethod, secondMethod, thirdMethod, genericMethod, genericMethodWithRawException;
+    protected Method firstMethod, secondMethod, thirdMethod, genericMethod, genericMethodWithRawException;
 
-    private Constructor<?> firstConstructor, secondConstructor;
+    protected Constructor<?> firstConstructor, secondConstructor;
 
     private static int hashCode(Method method) {
         int hashCode = new TypeDescription.ForLoadedType(method.getDeclaringClass()).hashCode();

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultTypeDescriptionTest.java
Patch:
@@ -14,7 +14,9 @@ public class TypePoolDefaultTypeDescriptionTest extends AbstractTypeDescriptionT
 
     @Override
     protected TypeDescription describe(Class<?> type) {
-        TypePool typePool = new TypePool.Default(TypePool.CacheProvider.NoOp.INSTANCE, ClassFileLocator.ForClassLoader.of(type.getClassLoader()));
+        TypePool typePool = new TypePool.Default(TypePool.CacheProvider.NoOp.INSTANCE,
+                ClassFileLocator.ForClassLoader.of(type.getClassLoader()),
+                TypePool.Default.ReaderMode.EXTENDED);
         try {
             return typePool.describe(type.getName()).resolve();
         } finally {

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyFacadeTypeDescriptionTest.java
Patch:
@@ -10,12 +10,13 @@
 
 import static net.bytebuddy.matcher.ElementMatchers.is;
 
-public class TypePoolLazyFacadeTypeDescriptionTest  extends AbstractTypeDescriptionTest {
+public class TypePoolLazyFacadeTypeDescriptionTest extends AbstractTypeDescriptionTest {
 
     @Override
     protected TypeDescription describe(Class<?> type) {
         TypePool typePool = new TypePool.LazyFacade(new TypePool.Default(TypePool.CacheProvider.NoOp.INSTANCE,
-                ClassFileLocator.ForClassLoader.of(type.getClassLoader())));
+                ClassFileLocator.ForClassLoader.of(type.getClassLoader()),
+                TypePool.Default.ReaderMode.EXTENDED));
         try {
             return typePool.describe(type.getName()).resolve();
         } finally {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationAppender.java
Patch:
@@ -343,7 +343,7 @@ enum SkipDefaults implements ValueFilter {
             @Override
             public boolean isRelevant(AnnotationDescription annotationDescription, MethodDescription.InDefinedShape methodDescription) {
                 Object defaultValue = methodDescription.getDefaultValue();
-                return defaultValue != null && defaultValue.equals(annotationDescription.getValue(methodDescription));
+                return defaultValue == null || !defaultValue.equals(annotationDescription.getValue(methodDescription));
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationAppender.java
Patch:
@@ -343,7 +343,7 @@ enum SkipDefaults implements ValueFilter {
             @Override
             public boolean isRelevant(AnnotationDescription annotationDescription, MethodDescription.InDefinedShape methodDescription) {
                 Object defaultValue = methodDescription.getDefaultValue();
-                return defaultValue != null && defaultValue.equals(annotationDescription.getValue(methodDescription));
+                return defaultValue == null || !defaultValue.equals(annotationDescription.getValue(methodDescription));
             }
 
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/AbstractImplementationTest.java
Patch:
@@ -49,6 +49,7 @@ protected <T> DynamicType.Loaded<T> implement(Class<T> target,
                 ClassFileVersion.forCurrentJavaVersion(),
                 new NamingStrategy.SuffixingRandom(SUFFIX),
                 new AuxiliaryType.NamingStrategy.SuffixingRandom(SUFFIX),
+                Implementation.Context.Default.Factory.INSTANCE,
                 new TypeDescription.ForLoadedType(target),
                 new TypeList.ForLoadedType(Arrays.asList(interfaces)),
                 Opcodes.ACC_PUBLIC,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -2452,7 +2452,9 @@ public AnnotationList getDeclaredAnnotations() {
 
                 @Override
                 public int getModifiers() {
-                    return Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE | Opcodes.ACC_SYNTHETIC;
+                    return Opcodes.ACC_SYNTHETIC | Opcodes.ACC_STATIC | (instrumentedType.isClassType()
+                            ? Opcodes.ACC_PRIVATE
+                            : Opcodes.ACC_PUBLIC);
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1839,9 +1839,8 @@ public void assertMethod(String name,
                             throw new IllegalStateException("Cannot define non-public or non-virtual method '" + name + "' for interface type");
                         } else if (classic && isStatic) {
                             throw new IllegalStateException("Cannot define static method '" + name + "' for a pre-Java 8 interface type");
-                        } else if (!isAbstract && (classic || isDefaultValueIncompatible)) {
-                            throw new IllegalStateException("Cannot define default method '" + name + "' for "
-                                    + (isDefaultValueIncompatible ? "method sort" : "pre-Java 8 interface type"));
+                        } else if (classic && !isAbstract) {
+                            throw new IllegalStateException("Cannot define default method '" + name + "' for pre-Java 8 interface type");
                         }
                     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionLatentTest.java
Patch:
@@ -27,6 +27,7 @@ public class TypeDescriptionLatentTest {
     private GenericTypeDescription superType, interfaceType;
 
     @Before
+    @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
         when(superType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(superType);
         when(interfaceType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(interfaceType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoaderChildFirstTest.java
Patch:
@@ -207,12 +207,12 @@ private RenamingWrapper(String oldName, String newName) {
         }
 
         @Override
-        public int wrapWriter(int hint) {
+        public int mergeWriter(int hint) {
             return hint;
         }
 
         @Override
-        public int wrapReader(int hint) {
+        public int mergeReader(int hint) {
             return hint;
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -252,7 +252,7 @@ interface RawMatcher {
          * @param typeDescription     A description of the type to be instrumented.
          * @param classLoader         The class loader of the instrumented type. Might be {@code null} if this class
          *                            loader represents the bootstrap class loader.
-         * @param classBeingRedefined The class being redefined which is only not {@code null} if a retransofmration
+         * @param classBeingRedefined The class being redefined which is only not {@code null} if a retransformation
          *                            is applied.
          * @param protectionDomain    The protection domain of the type being transformed.
          * @return {@code true} if the entailed {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s should
@@ -1248,7 +1248,6 @@ private Nexus(String name, ClassLoader classLoader) {
                      * @param type The loaded type to initialize.
                      * @throws Exception If an exception occurs.
                      */
-                    @SuppressWarnings("unused")
                     public static void initialize(Class<?> type) throws Exception {
                         Object typeInitializer = TYPE_INITIALIZERS.remove(new Nexus(type));
                         if (typeInitializer != null) {
@@ -1263,7 +1262,6 @@ public static void initialize(Class<?> type) throws Exception {
                      *                        of {@link net.bytebuddy.implementation.LoadedTypeInitializer} where
                      *                        it does however not matter which class loader loaded this latter type.
                      */
-                    @SuppressWarnings("unused")
                     public static void register(String name, ClassLoader classLoader, Object typeInitializer) {
                         TYPE_INITIALIZERS.put(new Nexus(name, classLoader), typeInitializer);
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -252,7 +252,7 @@ interface RawMatcher {
          * @param typeDescription     A description of the type to be instrumented.
          * @param classLoader         The class loader of the instrumented type. Might be {@code null} if this class
          *                            loader represents the bootstrap class loader.
-         * @param classBeingRedefined The class being redefined which is only not {@code null} if a retransofmration
+         * @param classBeingRedefined The class being redefined which is only not {@code null} if a retransformation
          *                            is applied.
          * @param protectionDomain    The protection domain of the type being transformed.
          * @return {@code true} if the entailed {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s should
@@ -1248,7 +1248,6 @@ private Nexus(String name, ClassLoader classLoader) {
                      * @param type The loaded type to initialize.
                      * @throws Exception If an exception occurs.
                      */
-                    @SuppressWarnings("unused")
                     public static void initialize(Class<?> type) throws Exception {
                         Object typeInitializer = TYPE_INITIALIZERS.remove(new Nexus(type));
                         if (typeInitializer != null) {
@@ -1263,7 +1262,6 @@ public static void initialize(Class<?> type) throws Exception {
                      *                        of {@link net.bytebuddy.implementation.LoadedTypeInitializer} where
                      *                        it does however not matter which class loader loaded this latter type.
                      */
-                    @SuppressWarnings("unused")
                     public static void register(String name, ClassLoader classLoader, Object typeInitializer) {
                         TYPE_INITIALIZERS.put(new Nexus(name, classLoader), typeInitializer);
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -761,7 +761,7 @@ public <T> DynamicType.Builder<T> rebase(Class<T> levelType,
      * @return A dynamic type builder for this configuration that creates a rebased version of the given type.
      */
     public <T> DynamicType.Builder<T> rebase(TypeDescription levelType, ClassFileLocator classFileLocator) {
-        return rebase(levelType, classFileLocator, new MethodRebaseResolver.MethodNameTransformer.Suffixing());
+        return rebase(levelType, classFileLocator, MethodRebaseResolver.MethodNameTransformer.Suffixing.withRandomSuffix());
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -1473,7 +1473,7 @@ public Enabled(File folder, Instrumentation instrumentation) {
 
                 @Override
                 public ClassInjector make(ProtectionDomain protectionDomain) {
-                    return new ClassInjector.UsingInstrumentation(folder, ClassInjector.UsingInstrumentation.Target.BOOTSTRAP, instrumentation);
+                    return ClassInjector.UsingInstrumentation.of(folder, ClassInjector.UsingInstrumentation.Target.BOOTSTRAP, instrumentation);
                 }
 
                 @Override
@@ -1586,7 +1586,7 @@ protected class ExecutingTransformer implements ClassFileTransformer {
              */
             public ExecutingTransformer() {
                 methodNameTransformer = NO_NATIVE_PREFIX.equals(nativeMethodPrefix)
-                        ? new MethodRebaseResolver.MethodNameTransformer.Suffixing()
+                        ? MethodRebaseResolver.MethodNameTransformer.Suffixing.withRandomSuffix()
                         : new MethodRebaseResolver.MethodNameTransformer.Prefixing(nativeMethodPrefix);
                 initializationStrategy = disableSelfInitialization
                         ? InitializationStrategy.NoOp.INSTANCE
@@ -1613,7 +1613,7 @@ public byte[] transform(ClassLoader classLoader,
                             if (loadedTypeInitializers.size() > 1) {
                                 ClassInjector classInjector = classLoader == null
                                         ? bootstrapInjectionStrategy.make(protectionDomain)
-                                        : new ClassInjector.UsingReflection(classLoader, protectionDomain, accessControlContext, PackageDefinitionStrategy.NoOp.INSTANCE);
+                                        : new ClassInjector.UsingReflection(classLoader, protectionDomain, accessControlContext, PackageDefinitionStrategy.NoOp.INSTANCE, true);
                                 for (Map.Entry<TypeDescription, Class<?>> auxiliary : classInjector.inject(dynamicType.getRawAuxiliaryTypes()).entrySet()) {
                                     initializationStrategy.initialize(auxiliary.getValue(), loadedTypeInitializers.get(auxiliary.getKey()));
                                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -415,7 +415,7 @@ protected Enabled(File folder) {
 
             @Override
             public ClassInjector make(Instrumentation instrumentation) {
-                return new ClassInjector.UsingInstrumentation(folder, ClassInjector.UsingInstrumentation.Target.BOOTSTRAP, instrumentation);
+                return ClassInjector.UsingInstrumentation.of(folder, ClassInjector.UsingInstrumentation.Target.BOOTSTRAP, instrumentation);
             }
 
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassInjectorUsingInstrumentationTest.java
Patch:
@@ -20,7 +20,7 @@
 import static org.hamcrest.CoreMatchers.nullValue;
 import static org.hamcrest.MatcherAssert.assertThat;
 
-public class ClassInjectorUsingImplementationTest {
+public class ClassInjectorUsingInstrumentationTest {
 
     private static final String FOO = "foo", BAR = "bar";
 
@@ -40,7 +40,7 @@ public void setUp() throws Exception {
     @Test
     @AgentAttachmentRule.Enforce
     public void testBootstrapInjection() throws Exception {
-        ClassInjector classInjector = new ClassInjector.UsingInstrumentation(folder,
+        ClassInjector classInjector = ClassInjector.UsingInstrumentation.of(folder,
                 ClassInjector.UsingInstrumentation.Target.BOOTSTRAP,
                 ByteBuddyAgent.install());
         String name = FOO + RandomString.make();
@@ -54,7 +54,7 @@ public void testBootstrapInjection() throws Exception {
     @Test
     @AgentAttachmentRule.Enforce
     public void testSystemInjection() throws Exception {
-        ClassInjector classInjector = new ClassInjector.UsingInstrumentation(folder,
+        ClassInjector classInjector = ClassInjector.UsingInstrumentation.of(folder,
                 ClassInjector.UsingInstrumentation.Target.SYSTEM,
                 ByteBuddyAgent.install());
         String name = BAR + RandomString.make();

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/AbstractMethodCallProxyTest.java
Patch:
@@ -43,7 +43,7 @@ protected Class<?> proxyOnlyDeclaredMethodOf(Class<?> proxyTarget) throws Except
                 ClassFileVersion.forCurrentJavaVersion(),
                 methodAccessorFactory);
         DynamicType.Unloaded<?> unloaded = (DynamicType.Unloaded<?>) dynamicType;
-        Class<?> auxiliaryType = unloaded.load(getClass().getClassLoader(), ClassLoadingStrategy.Default.INJECTION).getLoaded();
+        Class<?> auxiliaryType = unloaded.load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER).getLoaded();
         assertThat(auxiliaryType.getName(), is(auxiliaryTypeName));
         verify(methodAccessorFactory).registerAccessorFor(specialMethodInvocation);
         verifyNoMoreInteractions(methodAccessorFactory);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/MethodDelegationBinder.java
Patch:
@@ -878,7 +878,7 @@ public Processor(MethodDelegationBinder methodDelegationBinder, AmbiguityResolve
         public MethodBinding process(Implementation.Target implementationTarget, MethodDescription source, MethodList<?> targetCandidates) {
             List<MethodBinding> possibleDelegations = bind(implementationTarget, source, targetCandidates);
             if (possibleDelegations.isEmpty()) {
-                throw new IllegalArgumentException("No delegator method can be bound to " + source);
+                throw new IllegalArgumentException("None of " + targetCandidates + " allows for delegation from " + source);
             }
             return resolve(source, possibleDelegations);
         }
@@ -909,8 +909,7 @@ private List<MethodBinding> bind(Implementation.Target implementationTarget, Met
          * @param targets A list of possible binding targets.
          * @return The most specific method binding that was located from the given list of candidate targets.
          */
-        private MethodBinding resolve(MethodDescription source,
-                                      List<MethodBinding> targets) {
+        private MethodBinding resolve(MethodDescription source, List<MethodBinding> targets) {
             switch (targets.size()) {
                 case 1:
                     return targets.get(ONLY);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1836,7 +1836,7 @@ public void assertMethod(String name,
                                              boolean isNonStaticNonVirtual,
                                              boolean isGeneric) {
                         if (!isPublic || isNonStaticNonVirtual) {
-                            throw new IllegalStateException("Cannot define non-public or non-virtual method '" + name + "' for annotation type");
+                            throw new IllegalStateException("Cannot define non-public or non-virtual method '" + name + "' for interface type");
                         } else if (classic && isStatic) {
                             throw new IllegalStateException("Cannot define static method '" + name + "' for a pre-Java 8 interface type");
                         } else if (!isAbstract && (classic || isDefaultValueIncompatible)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -218,14 +218,16 @@ public DynamicType.Unloaded<T> make() {
                 classFileVersion).make();
     }
 
-
     /**
      * Applies this builder's constructor strategy to the given instrumented type.
      *
      * @param instrumentedType The instrumented type to apply the constructor onto.
      * @return The instrumented type with the constructor strategy applied onto.
      */
     private InstrumentedType applyConstructorStrategy(InstrumentedType instrumentedType) {
+        if (!instrumentedType.isClassType()) {
+            return instrumentedType;
+        }
         for (MethodDescription.Token methodToken : constructorStrategy.extractConstructors(instrumentedType)) {
             instrumentedType = instrumentedType.withMethod(methodToken);
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedConstructorTest.java
Patch:
@@ -54,6 +54,7 @@ public class MethodRebaseResolverResolutionForRebasedConstructorTest {
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
         when(genericTypeDescription.asErasure()).thenReturn(typeDescription);
+        when(typeDescription.isClassType()).thenReturn(true);
         when(methodDescription.isConstructor()).thenReturn(true);
         when(methodDescription.getDeclaringType()).thenReturn(typeDescription);
         when(methodDescription.getReturnType()).thenReturn(returnType);
@@ -77,7 +78,7 @@ public void testPreservation() throws Exception {
         assertThat(resolution.isRebased(), is(true));
         assertThat(resolution.getResolvedMethod().getDeclaringType(), is((GenericTypeDescription) typeDescription));
         assertThat(resolution.getResolvedMethod().getInternalName(), is(MethodDescription.CONSTRUCTOR_INTERNAL_NAME));
-        assertThat(resolution.getResolvedMethod().getModifiers(), is(MethodRebaseResolver.REBASED_METHOD_MODIFIER));
+        assertThat(resolution.getResolvedMethod().getModifiers(), is(Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PRIVATE));
         assertThat(resolution.getResolvedMethod().getReturnType(), is((GenericTypeDescription) TypeDescription.VOID));
         assertThat(resolution.getResolvedMethod().getParameters(), is((ParameterList) new ParameterList.Explicit.ForTypes(resolution.getResolvedMethod(),
                 Arrays.asList(parameterType, placeholderType))));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedMethodTest.java
Patch:
@@ -16,6 +16,7 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
 
 import java.util.Collections;
 
@@ -57,6 +58,7 @@ public void setUp() throws Exception {
         when(methodDescription.getDescriptor()).thenReturn(BAZ);
         when(typeDescription.getInternalName()).thenReturn(BAR);
         when(typeDescription.getDescriptor()).thenReturn(BAR);
+        when(typeDescription.isClassType()).thenReturn(true);
         when(methodNameTransformer.transform(methodDescription)).thenReturn(QUX);
         when(otherMethodNameTransformer.transform(methodDescription)).thenReturn(FOO + BAR);
         when(parameterType.getStackSize()).thenReturn(StackSize.ZERO);
@@ -73,7 +75,7 @@ public void testPreservation() throws Exception {
         assertThat(resolution.isRebased(), is(true));
         assertThat(resolution.getResolvedMethod().getDeclaringType(), is((GenericTypeDescription) typeDescription));
         assertThat(resolution.getResolvedMethod().getInternalName(), is(QUX));
-        assertThat(resolution.getResolvedMethod().getModifiers(), is(MethodRebaseResolver.REBASED_METHOD_MODIFIER));
+        assertThat(resolution.getResolvedMethod().getModifiers(), is(Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PRIVATE));
         assertThat(resolution.getResolvedMethod().getReturnType(), is((GenericTypeDescription) returnType));
         assertThat(resolution.getResolvedMethod().getParameters(), is((ParameterList) new ParameterList.Explicit.ForTypes(resolution.getResolvedMethod(),
                 Collections.singletonList(parameterType))));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ModifierReviewableTest.java
Patch:
@@ -48,6 +48,7 @@ public static Collection<Object[]> data() {
                 {Opcodes.ACC_TRANSIENT, "isTransient"},
                 {Opcodes.ACC_VARARGS, "isVarArgs"},
                 {Opcodes.ACC_VOLATILE, "isVolatile"},
+                {0, "isClassType"},
                 {0, "isPackagePrivate"}
         });
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericTypeDescriptionVisitorNoOpTest.java
Patch:
@@ -26,7 +26,7 @@ public void testVisitGenericArray() throws Exception {
 
     @Test
     public void testVisitWildcard() throws Exception {
-        assertThat(GenericTypeDescription.Visitor.NoOp.INSTANCE.onWildcardType(typeDescription), is((GenericTypeDescription) typeDescription));
+        assertThat(GenericTypeDescription.Visitor.NoOp.INSTANCE.onWildcard(typeDescription), is((GenericTypeDescription) typeDescription));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericTypeDescriptionVisitorTypeErasingTest.java
Patch:
@@ -36,7 +36,7 @@ public void testGenericArray() throws Exception {
 
     @Test(expected = IllegalArgumentException.class)
     public void testWildcard() throws Exception {
-        GenericTypeDescription.Visitor.TypeErasing.INSTANCE.onWildcardType(genericTypeDescription);
+        GenericTypeDescription.Visitor.TypeErasing.INSTANCE.onWildcard(genericTypeDescription);
     }
 
     @Test

File: byte-buddy-agent/src/test/java/net/bytebuddy/agent/ByteBuddyAgentAttachmentProviderTest.java
Patch:
@@ -41,6 +41,8 @@ public void testUnavailableAccessorThrowsExceptionForProcessId() throws Exceptio
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(ByteBuddyAgent.AttachmentProvider.ForJigsawVm.class).apply();
         ObjectPropertyAssertion.of(ByteBuddyAgent.AttachmentProvider.ForToolsJarVm.class).apply();
+        ObjectPropertyAssertion.of(ByteBuddyAgent.AttachmentProvider.ForToolsJarVm.ClassLoaderCreationAction.class).apply();
+        ObjectPropertyAssertion.of(ByteBuddyAgent.AttachmentProvider.Compound.class).apply();
         final Iterator<Class<?>> types = Arrays.<Class<?>>asList(Void.class, Object.class).iterator();
         ObjectPropertyAssertion.of(ByteBuddyAgent.AttachmentProvider.Accessor.Simple.class).create(new ObjectPropertyAssertion.Creator<Class<?>>() {
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -170,10 +170,10 @@ public interface AgentBuilder {
     AgentBuilder disableSelfInitialization();
 
     /**
-     * Enables retransformation when this agent is installed. Note that retransformation on does not currently allow
-     * for adding or removing fields or methods on the Hot Spot Virtual machine.
+     * Enables retransformation when this agent is installed. Note that retransformation does not currently allow
+     * for adding or removing fields or methods on the HotSpot Virtual machine.
      *
-     * @return A new instance of this agent builder which does not apply self initialization.
+     * @return A new instance of this agent builder which allows for retransformation.
      */
     AgentBuilder allowRetransformation();
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -2062,7 +2062,7 @@ enum ForSuperMethodInvocation implements MethodInvoker {
             public StackManipulation invoke(MethodDescription methodDescription, Target implementationTarget) {
                 if (implementationTarget.getTypeDescription().getSuperType() == null) {
                     throw new IllegalStateException("Cannot invoke super method for " + implementationTarget.getTypeDescription());
-                } else if (!methodDescription.isInvokableOn(implementationTarget.getTypeDescription().getSuperType().asErasure())) {
+                } else if (!methodDescription.isInvokableOn(implementationTarget.getOriginType())) {
                     throw new IllegalStateException("Cannot invoke " + methodDescription + " as super method of " + implementationTarget.getTypeDescription());
                 }
                 StackManipulation stackManipulation = implementationTarget.invokeDominant(methodDescription.asToken());

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -1063,6 +1063,9 @@ public MethodContainer filter(ElementMatcher<? super MethodDescription> matcher)
 
             @Override
             public MethodList<?> resolve(TypeDescription instrumentedType) {
+                if (!targetType.isVisibleTo(instrumentedType)) {
+                    throw new IllegalStateException(instrumentedType + " cannot access " + targetType);
+                }
                 return methodGraphCompiler.compile(targetType, instrumentedType).listNodes().asMethodList().filter(matcher);
             }
 

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -139,13 +139,15 @@ private ByteBuddyAgent() {
      * <p>
      * Installs an agent on the currently running Java virtual machine. Unfortunately, this does
      * not always work. The runtime installation of a Java agent is supported for:
+     * </p>
      * <ul>
      * <li><b>JVM version 9+</b>: For Java VM of at least version 9, the attachment API was merged
      * into a Jigsaw module and the runtime installation is always possible.</li>
      * <li><b>OpenJDK / Oracle JDK / IBM J9 versions 8-</b>: The installation for HotSpot is only
      * possible when bundled with a JDK up until Java version 8. It is not possible for runtime-only
      * installations of HotSpot or J9 for these versions.</li>
      * </ul>
+     * <p>
      * If an agent cannot be installed, a {@link IllegalStateException} is thrown.
      * </p>
      * <p>

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TypeProxy.java
Patch:
@@ -383,7 +383,7 @@ enum Default implements InvocationFactory {
                 public Implementation.SpecialMethodInvocation invoke(Implementation.Target implementationTarget,
                                                                      TypeDescription proxiedType,
                                                                      MethodDescription instrumentedMethod) {
-                    return implementationTarget.invokeSuper(instrumentedMethod.asToken());
+                    return implementationTarget.invokeDominant(instrumentedMethod.asToken());
                 }
             },
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TypeProxyInvocationFactoryDefaultTest.java
Patch:
@@ -41,10 +41,10 @@ public void setUp() throws Exception {
 
     @Test
     public void testSuperMethod() throws Exception {
-        when(implementationTarget.invokeSuper(methodToken)).thenReturn(specialMethodInvocation);
+        when(implementationTarget.invokeDominant(methodToken)).thenReturn(specialMethodInvocation);
         assertThat(TypeProxy.InvocationFactory.Default.SUPER_METHOD.invoke(implementationTarget, typeDescription, methodDescription),
                 is(specialMethodInvocation));
-        verify(implementationTarget).invokeSuper(methodToken);
+        verify(implementationTarget).invokeDominant(methodToken);
         verifyNoMoreInteractions(implementationTarget);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/JavaVersionRule.java
Patch:
@@ -22,7 +22,7 @@ public JavaVersionRule() {
     @Override
     public Statement apply(Statement base, FrameworkMethod method, Object target) {
         Enforce enforce = method.getAnnotation(Enforce.class);
-        return enforce == null || ClassFileVersion.forKnownJavaVersion(enforce.value()).compareTo(supportedVersion) < 0
+        return enforce == null || ClassFileVersion.forKnownJavaVersion(enforce.value()).compareTo(supportedVersion) <= 0
                 ? base
                 : new NoOpStatement(enforce.value());
     }

File: byte-buddy-agent/src/test/java/net/bytebuddy/agent/ByteBuddyAgentInstallationTest.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.agent;
 
-import net.bytebuddy.test.utility.ToolsJarRule;
+import net.bytebuddy.test.utility.AgentAttachmentRule;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.MethodRule;
@@ -13,10 +13,10 @@
 public class ByteBuddyAgentInstallationTest {
 
     @Rule
-    public MethodRule toolsJarRule = new ToolsJarRule();
+    public MethodRule agentAttachmentRule = new AgentAttachmentRule();
 
     @Test
-    @ToolsJarRule.Enforce
+    @AgentAttachmentRule.Enforce
     public void testAgentInstallation() throws Exception {
         assertThat(ByteBuddyAgent.install(), instanceOf(Instrumentation.class));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -25,8 +25,8 @@
 import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
 import net.bytebuddy.implementation.bytecode.member.MethodReturn;
 import net.bytebuddy.pool.TypePool;
+import net.bytebuddy.test.utility.AgentAttachmentRule;
 import net.bytebuddy.test.utility.JavaVersionRule;
-import net.bytebuddy.test.utility.ToolsJarRule;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.MethodRule;
@@ -64,7 +64,7 @@ public class ByteBuddyTutorialExamplesTest {
     public MethodRule javaVersionRule = new JavaVersionRule();
 
     @Rule
-    public MethodRule toolsJarRule = new ToolsJarRule();
+    public MethodRule agentAttachmentRule = new AgentAttachmentRule();
 
     @SuppressWarnings("unused")
     private static void println(String s) {
@@ -133,7 +133,7 @@ public void testTutorialGettingStartedClassLoading() throws Exception {
     }
 
     @Test
-    @ToolsJarRule.Enforce
+    @AgentAttachmentRule.Enforce
     public void testTutorialGettingStartedClassReloading() throws Exception {
         ByteBuddyAgent.install();
         FooReloading foo = new FooReloading();

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypeMatcher.java
Patch:
@@ -4,7 +4,7 @@
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 /**
- * An element matcher that matches a method's parameter types.
+ * An element matcher that matches a method's parameter's type.
  *
  * @param <T> The type of the matched entity.
  */
@@ -16,7 +16,7 @@ public class MethodParameterTypeMatcher<T extends ParameterDescription> extends
     private final ElementMatcher<? super GenericTypeDescription> matcher;
 
     /**
-     * Creates a new matcher for a method's parameter types.
+     * Creates a new matcher for a method's parameter's type.
      *
      * @param matcher The matcher to apply to the type of the parameter.
      */

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodRegistry.java
Patch:
@@ -493,6 +493,8 @@ public MethodRegistry.Prepared prepare(InstrumentedType instrumentedType,
             MethodGraph.Linked methodGraph = methodGraphCompiler.compile(instrumentedType);
             // Casting required for Java 6 compiler.
             ElementMatcher<? super MethodDescription> relevanceMatcher = (ElementMatcher<? super MethodDescription>) not(anyOf(implementations.keySet()))
+                    .and(returns(isVisibleTo(instrumentedType)))
+                    .and(not(hasParameter(hasType(not(isVisibleTo(instrumentedType))))))
                     .and(methodFilter.resolve(instrumentedType));
             for (MethodGraph.Node node : methodGraph.listNodes()) {
                 MethodDescription methodDescription = node.getRepresentative();
@@ -511,8 +513,7 @@ public MethodRegistry.Prepared prepare(InstrumentedType instrumentedType,
                         && !(methodDescription.isAbstract() || methodDescription.isFinal())
                         && !node.getSort().isMadeVisible()
                         && methodDescription.getDeclaringType().asErasure().isPackagePrivate()) {
-                    // Visibility bridges are required for public types that inherit a public method from a package-private type.
-                    // Checking the last condition contradicts any method that is defined by the instrumented type itself.
+                    // Visibility bridges are required for public classes that inherit a public method from a package-private class.
                     implementations.put(methodDescription, Prepared.Entry.forVisibilityBridge(methodDescription));
                 }
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultCall.java
Patch:
@@ -68,18 +68,18 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<Defaul
         /**
          * A reference to the target type method of the default call annotation.
          */
-        private static final MethodDescription TARGET_TYPE;
+        private static final MethodDescription.InDefinedShape TARGET_TYPE;
 
         /**
          * A reference to the serializable proxy method of the default call annotation.
          */
-        private static final MethodDescription SERIALIZABLE_PROXY;
+        private static final MethodDescription.InDefinedShape SERIALIZABLE_PROXY;
 
         /*
          * Finds references to the methods of the default call annotation.
          */
         static {
-            MethodList<?> annotationProperties = new TypeDescription.ForLoadedType(DefaultCall.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> annotationProperties = new TypeDescription.ForLoadedType(DefaultCall.class).getDeclaredMethods();
             TARGET_TYPE = annotationProperties.filter(named("targetType")).getOnly();
             SERIALIZABLE_PROXY = annotationProperties.filter(named("serializableProxy")).getOnly();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldValue.java
Patch:
@@ -62,18 +62,18 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<FieldV
         /**
          * The annotation method that for the defining type.
          */
-        private static final MethodDescription DEFINING_TYPE;
+        private static final MethodDescription.InDefinedShape DEFINING_TYPE;
 
         /**
          * The annotation method for the field's name.
          */
-        private static final MethodDescription FIELD_NAME;
+        private static final MethodDescription.InDefinedShape FIELD_NAME;
 
         /*
          * Initializes the methods of the annotation that is read by this binder.
          */
         static {
-            MethodList<?> methodList = new TypeDescription.ForLoadedType(FieldValue.class).getDeclaredMethods();
+            MethodList<MethodDescription.InDefinedShape> methodList = new TypeDescription.ForLoadedType(FieldValue.class).getDeclaredMethods();
             DEFINING_TYPE = methodList.filter(named("definingType")).getOnly();
             FIELD_NAME = methodList.filter(named("value")).getOnly();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParametersMatcher.java
Patch:
@@ -9,7 +9,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-public class MethodParameterMatcher<T extends MethodDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class MethodParametersMatcher<T extends MethodDescription> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**
      * The matcher to apply to the parameters.
@@ -21,7 +21,7 @@ public class MethodParameterMatcher<T extends MethodDescription> extends Element
      *
      * @param parameterMatcher The matcher to apply to the parameters.
      */
-    public MethodParameterMatcher(ElementMatcher<? super ParameterList<? extends ParameterDescription>> parameterMatcher) {
+    public MethodParametersMatcher(ElementMatcher<? super ParameterList<? extends ParameterDescription>> parameterMatcher) {
         this.parameterMatcher = parameterMatcher;
     }
 
@@ -33,7 +33,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && parameterMatcher.equals(((MethodParameterMatcher<?>) other).parameterMatcher);
+                && parameterMatcher.equals(((MethodParametersMatcher<?>) other).parameterMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -5178,7 +5178,7 @@ private LazyAnnotationDescription(TypePool typePool,
             }
 
             @Override
-            public Object getValue(MethodDescription methodDescription) {
+            public Object getValue(MethodDescription.InDefinedShape methodDescription) {
                 if (!methodDescription.getDeclaringType().asErasure().getDescriptor().equals(descriptor)) {
                     throw new IllegalArgumentException(methodDescription + " is not declared by " + getAnnotationType());
                 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AnnotationDescriptionAbstractPreparedExceptionTest.java
Patch:
@@ -31,7 +31,7 @@ public Annotation load(ClassLoader classLoader) throws ClassNotFoundException {
         }
 
         @Override
-        public Object getValue(MethodDescription methodDescription) {
+        public Object getValue(MethodDescription.InDefinedShape methodDescription) {
             throw new UnsupportedOperationException();
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/enumeration/AbstractEnumerationDescriptionTest.java
Patch:
@@ -26,7 +26,7 @@ private EnumerationDescription describe(Enum<?> enumeration) {
 
     protected abstract EnumerationDescription describe(Enum<?> enumeration,
                                                        Class<?> carrierType,
-                                                       MethodDescription annotationMethod);
+                                                       MethodDescription.InDefinedShape annotationMethod);
 
     @Before
     public void setUp() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/enumeration/EnumerationDescriptionForLoadedEnumerationTest.java
Patch:
@@ -7,7 +7,7 @@ public class EnumerationDescriptionForLoadedEnumerationTest extends AbstractEnum
     @Override
     protected EnumerationDescription describe(Enum<?> enumeration,
                                               Class<?> carrierType,
-                                              MethodDescription annotationMethod) {
+                                              MethodDescription.InDefinedShape annotationMethod) {
         return new EnumerationDescription.ForLoadedEnumeration(enumeration);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/enumeration/EnumerationDescriptionLatentTest.java
Patch:
@@ -6,7 +6,9 @@
 public class EnumerationDescriptionLatentTest extends AbstractEnumerationDescriptionTest {
 
     @Override
-    protected EnumerationDescription describe(Enum<?> enumeration, Class<?> carrierType, MethodDescription annotationMethod) {
+    protected EnumerationDescription describe(Enum<?> enumeration,
+                                              Class<?> carrierType,
+                                              MethodDescription.InDefinedShape annotationMethod) {
         return new EnumerationDescription.Latent(new TypeDescription.ForLoadedType(enumeration.getDeclaringClass()), enumeration.name());
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/AbstractFieldDescriptionTest.java
Patch:
@@ -163,7 +163,7 @@ public void testIsVisibleTo() throws Exception {
         assertThat(describe(PackagePrivateFieldType.class.getDeclaredField("packagePrivateType"))
                 .isVisibleTo(new TypeDescription.ForLoadedType(PackagePrivateFieldType.class)), is(true));
         assertThat(describe(PackagePrivateFieldType.class.getDeclaredField("packagePrivateType"))
-                .isVisibleTo(new TypeDescription.ForLoadedType(Object.class)), is(false));
+                .isVisibleTo(new TypeDescription.ForLoadedType(Object.class)), is(true));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/AbstractAttributeAppenderTest.java
Patch:
@@ -25,7 +25,7 @@ public abstract class AbstractAttributeAppenderTest {
 
     @Before
     public void setUp() throws Exception {
-        when(valueFilter.isRelevant(any(AnnotationDescription.class), any(MethodDescription.class))).thenReturn(true);
+        when(valueFilter.isRelevant(any(AnnotationDescription.class), any(MethodDescription.InDefinedShape.class))).thenReturn(true);
     }
 
     protected @interface Qux {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/AnnotationAppenderValueFilterAppendDefaultsTest.java
Patch:
@@ -15,7 +15,7 @@ public class AnnotationAppenderValueFilterAppendDefaultsTest {
     @Test
     public void testFiltering() throws Exception {
         AnnotationDescription annotationDescription = mock(AnnotationDescription.class);
-        MethodDescription methodDescription = mock(MethodDescription.class);
+        MethodDescription.InDefinedShape methodDescription = mock(MethodDescription.InDefinedShape.class);
         assertThat(AnnotationAppender.ValueFilter.AppendDefaults.INSTANCE.isRelevant(annotationDescription, methodDescription), is(true));
         verifyZeroInteractions(annotationDescription);
         verifyZeroInteractions(methodDescription);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/AnnotationAppenderValueFilterSkipDefaultsTest.java
Patch:
@@ -22,7 +22,7 @@ public class AnnotationAppenderValueFilterSkipDefaultsTest {
     private AnnotationDescription annotationDescription;
 
     @Mock
-    private MethodDescription methodDescription;
+    private MethodDescription.InDefinedShape methodDescription;
 
     @Test
     public void testFilteringNoDefault() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/MethodAttributeAppenderForAnnotationTest.java
Patch:
@@ -24,7 +24,7 @@ public void setUp() throws Exception {
         ParameterList<?> parameterList = mock(ParameterList.class);
         when(parameterList.size()).thenReturn(PARAMETER_INDEX + 1);
         when(methodDescription.getParameters()).thenReturn((ParameterList) parameterList);
-        when(valueFilter.isRelevant(any(AnnotationDescription.class), any(MethodDescription.class))).thenReturn(true);
+        when(valueFilter.isRelevant(any(AnnotationDescription.class), any(MethodDescription.InDefinedShape.class))).thenReturn(true);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/MethodAttributeAppenderForInstrumentedMethodTest.java
Patch:
@@ -24,7 +24,7 @@ public class MethodAttributeAppenderForInstrumentedMethodTest extends AbstractMe
     @Test
     @SuppressWarnings("unchecked")
     public void testMethodAnnotations() throws Exception {
-        when(valueFilter.isRelevant(any(AnnotationDescription.class), any(MethodDescription.class))).thenReturn(true);
+        when(valueFilter.isRelevant(any(AnnotationDescription.class), any(MethodDescription.InDefinedShape.class))).thenReturn(true);
         when(methodDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList
                 .ForLoadedAnnotation(new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()));
         when(methodDescription.getParameters()).thenReturn((ParameterList) new ParameterList.Empty());
@@ -43,7 +43,7 @@ public void testMethodAnnotations() throws Exception {
     @Test
     @SuppressWarnings("unchecked")
     public void testMethodParameterAnnotations() throws Exception {
-        when(valueFilter.isRelevant(any(AnnotationDescription.class), any(MethodDescription.class))).thenReturn(true);
+        when(valueFilter.isRelevant(any(AnnotationDescription.class), any(MethodDescription.InDefinedShape.class))).thenReturn(true);
         when(methodDescription.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
         ParameterDescription parameterDescription = mock(ParameterDescription.class);
         when(parameterDescription.getDeclaredAnnotations())

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/MethodParameterTypeMatcherTest.java
Patch:
@@ -26,7 +26,7 @@ public class MethodParameterTypeMatcherTest extends AbstractElementMatcherTest<M
 
     @SuppressWarnings("unchecked")
     public MethodParameterTypeMatcherTest() {
-        super((Class<MethodParameterTypeMatcher<?>>) (Object) MethodParameterTypeMatcher.class, "types");
+        super((Class<MethodParameterTypeMatcher<?>>) (Object) MethodParameterTypeMatcher.class, "hasType");
     }
 
     @Before
@@ -37,15 +37,15 @@ public void setUp() throws Exception {
     @Test
     public void testMatch() throws Exception {
         when(parameterMatcher.matches(typeList)).thenReturn(true);
-        assertThat(new MethodParameterTypeMatcher<ParameterList>(parameterMatcher).matches(parameterList), is(true));
+        assertThat(new MethodParameterTypesMatcher<ParameterList<?>>(parameterMatcher).matches(parameterList), is(true));
         verify(parameterMatcher).matches(typeList);
         verifyNoMoreInteractions(parameterMatcher);
     }
 
     @Test
     public void testNoMatch() throws Exception {
         when(parameterMatcher.matches(typeList)).thenReturn(false);
-        assertThat(new MethodParameterTypeMatcher<ParameterList>(parameterMatcher).matches(parameterList), is(false));
+        assertThat(new MethodParameterTypesMatcher<ParameterList<?>>(parameterMatcher).matches(parameterList), is(false));
         verify(parameterMatcher).matches(typeList);
         verifyNoMoreInteractions(parameterMatcher);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultEnumerationDescriptionTest.java
Patch:
@@ -26,7 +26,7 @@ public void tearDown() throws Exception {
     @Override
     protected EnumerationDescription describe(Enum<?> enumeration,
                                               Class<?> carrierType,
-                                              MethodDescription annotationMethod) {
+                                              MethodDescription.InDefinedShape annotationMethod) {
         TypeDescription typeDescription = typePool.describe(carrierType.getName()).resolve();
         for (AnnotationDescription annotationDescription : typeDescription.getDeclaredAnnotations()) {
             if (annotationDescription.getAnnotationType().equals(annotationDescription.getAnnotationType())) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/StackManipulation.java
Patch:
@@ -75,7 +75,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
 
         @Override
         public String toString() {
-            return "StackManipulation.LegalTrivial." + name();
+            return "StackManipulation.Trivial." + name();
         }
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -2184,7 +2184,7 @@ public FieldAnnotationTarget<S> value(String value) {
                  * @return The given default value.
                  */
                 private Object isValid(Object defaultValue, Class<?> legalType) {
-                    if (!fieldToken.getType().asErasure().represents(legalType)) {
+                    if (!fieldToken.getType().represents(legalType)) {
                         throw new IllegalStateException(defaultValue + " is not of the required type " + legalType);
                     }
                     return defaultValue;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/StubValue.java
Patch:
@@ -50,10 +50,10 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            if (!target.getType().asErasure().represents(Object.class)) {
+            if (!target.getType().represents(Object.class)) {
                 throw new IllegalStateException(target + " uses StubValue annotation on non-Object type");
             }
-            StackManipulation stackManipulation = source.getReturnType().asErasure().represents(void.class)
+            StackManipulation stackManipulation = source.getReturnType().represents(void.class)
                     ? NullConstant.INSTANCE
                     : new StackManipulation.Compound(DefaultValue.of(source.getReturnType().asErasure()),
                     assigner.assign(source.getReturnType().asErasure(), TypeDescription.OBJECT, Assigner.Typing.STATIC));

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/ByteBuddyCommons.java
Patch:
@@ -219,7 +219,7 @@ public static <T extends Collection<? extends GenericTypeDescription>> T isImple
      * @return The input value.
      */
     public static <T extends GenericTypeDescription> T isActualType(T typeDescription) {
-        if (isActualTypeOrVoid(typeDescription).asErasure().represents(void.class)) {
+        if (isActualTypeOrVoid(typeDescription).represents(void.class)) {
             throw new IllegalArgumentException("The void non-type cannot be assigned a value");
         }
         return typeDescription;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -202,7 +202,7 @@ public String toString() {
     /**
      * A default implementation of an instrumented type.
      */
-    class Default extends AbstractTypeDescription.OfSimpleType implements InstrumentedType {
+    class Default extends AbstractBase.OfSimpleType implements InstrumentedType {
 
         /**
          * The binary name of the instrumented type.

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -3029,7 +3029,7 @@ public String toString() {
      * A type description that looks up any referenced {@link net.bytebuddy.description.ByteCodeElement} or
      * {@link AnnotationDescription} by querying a type pool at lookup time.
      */
-    class LazyTypeDescription extends TypeDescription.AbstractTypeDescription.OfSimpleType {
+    class LazyTypeDescription extends TypeDescription.AbstractBase.OfSimpleType {
 
         /**
          * The type pool to be used for looking up linked types.

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -482,7 +482,7 @@ public void testMalformedMethodSignature() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(TypeDescription.AbstractTypeDescription.SuperTypeIterator.class).applyBasic();
+        ObjectPropertyAssertion.of(TypeDescription.AbstractBase.SuperTypeIterator.class).applyBasic();
     }
 
     protected interface SampleInterface {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericTypeDescriptionSuperTypeIteratorTest.java
Patch:
@@ -34,7 +34,7 @@ public void setUp() throws Exception {
 
     @Test
     public void testHasNext() throws Exception {
-        Iterator<GenericTypeDescription> iterator = new TypeDescription.AbstractTypeDescription.SuperTypeIterator(typeDescription);
+        Iterator<GenericTypeDescription> iterator = new TypeDescription.AbstractBase.SuperTypeIterator(typeDescription);
         assertThat(iterator.hasNext(), is(true));
         assertThat(iterator.hasNext(), is(true));
         assertThat(iterator.next(), is((GenericTypeDescription) typeDescription));
@@ -47,15 +47,15 @@ public void testHasNext() throws Exception {
 
     @Test(expected = NoSuchElementException.class)
     public void testHasNotNext() throws Exception {
-        Iterator<GenericTypeDescription> iterator = new TypeDescription.AbstractTypeDescription.SuperTypeIterator(typeDescription);
+        Iterator<GenericTypeDescription> iterator = new TypeDescription.AbstractBase.SuperTypeIterator(typeDescription);
         assertThat(iterator.next(), is((GenericTypeDescription) typeDescription));
         assertThat(iterator.next(), is(superType));
         iterator.next();
     }
 
     @Test(expected = UnsupportedOperationException.class)
     public void testNoRemoval() throws Exception {
-        new TypeDescription.AbstractTypeDescription.SuperTypeIterator(typeDescription).remove();
+        new TypeDescription.AbstractBase.SuperTypeIterator(typeDescription).remove();
     }
 
     @Test

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -279,6 +279,8 @@ private static Instrumentation doGetInstrumentation() {
                     .getDeclaredField(INSTRUMENTATION_FIELD_NAME);
             field.setAccessible(true);
             return (Instrumentation) field.get(STATIC_MEMBER);
+        } catch (RuntimeException exception) {
+            throw exception;
         } catch (Exception exception) {
             throw new IllegalStateException("The Byte Buddy agent is not properly initialized", exception);
         }

File: byte-buddy-android/src/main/java/net/bytebuddy/android/AndroidClassLoadingStrategy.java
Patch:
@@ -7,6 +7,7 @@
 import com.android.dx.dex.cf.CfTranslator;
 import com.android.dx.dex.file.DexFile;
 import dalvik.system.DexClassLoader;
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.utility.RandomString;
@@ -267,8 +268,8 @@ public DexProcessor.Conversion create() {
             }
 
             @Override
+            @SuppressFBWarnings(value = "DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED", justification = "Android discourages the use access controllers")
             public ClassLoader makeClassLoader(File zipFile, File privateDirectory, ClassLoader parentClassLoader) {
-                // Note: Android discourages privileged actions but runs its own security model.
                 return new DexClassLoader(zipFile.getAbsolutePath(), privateDirectory.getAbsolutePath(), EMPTY_LIBRARY_PATH, parentClassLoader);
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -867,8 +867,7 @@ public Identified rebase(ElementMatcher<? super TypeDescription> typeMatcher) {
         }
 
         @Override
-        public Identified rebase(ElementMatcher<? super TypeDescription> typeMatcher,
-                                 ElementMatcher<? super ClassLoader> classLoaderMatcher) {
+        public Identified rebase(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher) {
             return rebase(new RawMatcher.ForElementMatcherPair(nonNull(typeMatcher), nonNull(classLoaderMatcher)));
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -1,6 +1,5 @@
 package net.bytebuddy.description.method;
 
-import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.description.ByteCodeElement;
 import net.bytebuddy.description.ModifierReviewable;
 import net.bytebuddy.description.NamedElement;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/GenericTypeDescription.java
Patch:
@@ -2435,6 +2435,8 @@ public static class OfLoadedParameter extends LazyProjection {
                 try {
                     Class<?> parameterType = Class.forName("java.lang.reflect.Parameter");
                     dispatcher = new Dispatcher.ForModernVm(parameterType.getDeclaredMethod("getType"), parameterType.getDeclaredMethod("getParameterizedType"));
+                } catch (RuntimeException exception) {
+                    throw exception;
                 } catch (Exception ignored) {
                     dispatcher = Dispatcher.ForLegacyVm.INSTANCE;
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -1632,6 +1632,8 @@ public Object getValue(MethodDescription methodDescription) {
                     }
                 }
                 return describe(method.invoke(annotation), methodDescription.getReturnType().asErasure());
+            } catch (RuntimeException exception) {
+                throw exception;
             } catch (Exception exception) {
                 throw new IllegalStateException("Cannot access annotation property " + methodDescription, exception);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.description.method;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.description.ByteCodeElement;
 import net.bytebuddy.description.ModifierReviewable;
 import net.bytebuddy.description.NamedElement;
@@ -209,6 +210,8 @@ class ForLoadedParameter extends InDefinedShape.AbstractBase {
                         parameterType.getDeclaredMethod("isNamePresent"),
                         parameterType.getDeclaredMethod("getModifiers"),
                         parameterType.getDeclaredMethod("getDeclaredAnnotations"));
+            } catch (RuntimeException exception) {
+                throw exception;
             } catch (Exception ignored) {
                 dispatcher = Dispatcher.ForLegacyVm.INSTANCE;
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterList.java
Patch:
@@ -133,6 +133,8 @@ class ForLoadedExecutable extends AbstractBase<ParameterDescription.InDefinedSha
             Dispatcher dispatcher;
             try {
                 dispatcher = new Dispatcher.ForModernVm(Class.forName("java.lang.reflect.Executable").getDeclaredMethod("getParameters"));
+            } catch (RuntimeException exception) {
+                throw exception;
             } catch (Exception ignored) {
                 dispatcher = Dispatcher.ForLegacyVm.INSTANCE;
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -79,6 +79,8 @@ class UsingReflection implements ClassInjector {
                                 String.class,
                                 String.class,
                                 URL.class));
+            } catch (RuntimeException exception) {
+                throw exception;
             } catch (Exception exception) {
                 dispatcher = new Dispatcher.Faulty(exception);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -131,6 +131,8 @@ public static ClassReloadingStrategy fromInstalledAgent() {
                     .loadClass(BYTE_BUDDY_AGENT_TYPE)
                     .getDeclaredMethod(GET_INSTRUMENTATION_METHOD)
                     .invoke(STATIC_METHOD));
+        } catch (RuntimeException exception) {
+            throw exception;
         } catch (Exception exception) {
             throw new IllegalStateException("The Byte Buddy agent is not installed or not accessible", exception);
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassFileLocatorAgentBasedTest.java
Patch:
@@ -93,15 +93,15 @@ public void apply(Instrumentation mock) {
         ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.ClassLoadingDelegate.Default.class).apply();
         ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.ClassLoadingDelegate.ForDelegatingClassLoader.class).apply();
         final Iterator<Field> iterator = Arrays.asList(Foo.class.getDeclaredFields()).iterator();
-        ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.ClassLoadingDelegate.ForDelegatingClassLoader.JavaField.ForResolvedField.class)
+        ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.ClassLoadingDelegate.ForDelegatingClassLoader.Dispatcher.Resolved.class)
                 .create(new ObjectPropertyAssertion.Creator<Field>() {
                     @Override
                     public Field create() {
                         return iterator.next();
                     }
                 })
                 .apply();
-        ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.ClassLoadingDelegate.ForDelegatingClassLoader.JavaField.ForNonResolvedField.class).apply();
+        ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.ClassLoadingDelegate.ForDelegatingClassLoader.Dispatcher.Unresolved.class).apply();
         final Iterator<Class<?>> otherIterator = Arrays.<Class<?>>asList(Integer.class, String.class, Object.class, Byte.class).iterator();
         ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.ClassLoadingDelegate.Explicit.class).create(new ObjectPropertyAssertion.Creator<Collection<Class<?>>>() {
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -1292,7 +1292,7 @@ public boolean isDefined() {
 
             @Override
             public boolean equals(Object other) {
-                return other != null && other.getClass() == Undefined.class;
+                return other != null && other.getClass() == getClass();
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.agent.builder;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
@@ -486,10 +487,11 @@ protected static class Initialized implements BinaryLocator.Initialized, ClassFi
                  * Creates a new initialized form of a default binary locator.
                  *
                  * @param typeName             The binary name of the type that is being instrumented.
-                 * @param binaryRepresentation The binary representation of the instrumented type.
+                 * @param binaryRepresentation The binary representation of the instrumented type. The provided array must not be modified.
                  * @param cacheProvider        The cache provider to use.
                  * @param classFileLocator     The class file locator to use.
                  */
+                @SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "The received array must be immutable by contract")
                 public Initialized(String typeName,
                                    byte[] binaryRepresentation,
                                    TypePool.CacheProvider cacheProvider,

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeList.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.description.type;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.description.type.generic.GenericTypeList;
 import net.bytebuddy.implementation.bytecode.StackSize;
@@ -18,6 +19,7 @@ public interface TypeList extends FilterableList<TypeDescription, TypeList> {
     /**
      * Represents that a type list does not contain any values for ASM interoperability which is represented by {@code null}.
      */
+    @SuppressFBWarnings(value = "MS_MUTABLE_ARRAY", justification = "Value is null")
     String[] NO_INTERFACES = null;
 
     /**
@@ -193,6 +195,7 @@ public GenericTypeList asGenericTypes() {
     class Empty extends FilterableList.Empty<TypeDescription, TypeList> implements TypeList {
 
         @Override
+        @SuppressFBWarnings(value = "EI_EXPOSE_REP", justification = "Return value is always null")
         public String[] toInternalNames() {
             return NO_INTERFACES;
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/MultipleParentClassLoader.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.dynamic.loading;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.matcher.ElementMatcher;
 
 import java.io.IOException;
@@ -131,6 +132,7 @@ public boolean hasMoreElements() {
         }
 
         @Override
+        @SuppressFBWarnings(value = "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR", justification = "Null reference is impossible due to element check")
         public URL nextElement() {
             if (hasMoreElements()) {
                 return currentEnumeration.nextElement();

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.dynamic.scaffold;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.type.TypeDescription;
@@ -381,6 +382,7 @@ public String toString() {
     /**
      * A compiler to produce a {@link MethodGraph} from a given type.
      */
+    @SuppressFBWarnings(value = "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION", justification = "No circularity, initialization is safe")
     interface Compiler {
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -391,7 +391,7 @@ protected static class ForStaticField extends FixedValue implements AssignerConf
          * @param typing     Indicates if dynamic type castings should be attempted for incompatible assignments.
          */
         protected ForStaticField(Object fixedValue, Assigner assigner, Assigner.Typing typing) {
-            this(String.format("%s$%d", PREFIX, Math.abs(fixedValue.hashCode())), fixedValue, assigner, typing);
+            this(String.format("%s$%d", PREFIX, Math.abs(fixedValue.hashCode() % Integer.MAX_VALUE)), fixedValue, assigner, typing);
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -85,7 +85,7 @@ protected InvocationHandlerAdapter(String fieldName, boolean cacheMethods, Assig
      * @return An implementation that delegates all method interceptions to the given invocation handler.
      */
     public static InvocationHandlerAdapter of(InvocationHandler invocationHandler) {
-        return of(invocationHandler, String.format("%s$%d", PREFIX, Math.abs(invocationHandler.hashCode())));
+        return of(invocationHandler, String.format("%s$%d", PREFIX, Math.abs(invocationHandler.hashCode() % Integer.MAX_VALUE)));
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/AuxiliaryType.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.implementation.auxiliary;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.method.MethodDescription;
@@ -21,6 +22,7 @@ public interface AuxiliaryType {
     /**
      * The default type access of an auxiliary type. <b>This array must not be mutated</b>.
      */
+    @SuppressFBWarnings(value = "MS_MUTABLE_ARRAY", justification = "Favor simplicity with current API in overall immutable library layout")
     ModifierContributor.ForType[] DEFAULT_TYPE_MODIFIER = {SyntheticState.SYNTHETIC};
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/MethodDelegationBinder.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.implementation.bind;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.type.TypeDescription;
@@ -598,6 +599,7 @@ public String toString() {
      * Implementations of this interface are able to attempt the resolution of two successful bindings of a method
      * to two different target methods in order to identify a dominating binding.
      */
+    @SuppressFBWarnings(value = "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION", justification = "No circularity, initialization is safe")
     interface AmbiguityResolver {
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.implementation.bind.annotation;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.ParameterDescription;
@@ -135,6 +136,7 @@ public String toString() {
      *
      * @param <T> The {@link java.lang.annotation.Annotation#annotationType()} handled by this parameter binder.
      */
+    @SuppressFBWarnings(value = "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION", justification = "No circularity, initialization is safe")
     public interface ParameterBinder<T extends Annotation> {
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/Assigner.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.implementation.bytecode.assign;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.assign.primitive.PrimitiveTypeAwareAssigner;
@@ -12,6 +13,7 @@
  * An assigner is for example responsible for type casting, auto boxing or unboxing or for the widening of primitive
  * types.
  */
+@SuppressFBWarnings(value = "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION", justification = "No circularity, initialization is safe")
 public interface Assigner {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionSizeMatcher.java
Patch:
@@ -1,5 +1,7 @@
 package net.bytebuddy.matcher;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+
 import java.util.Collection;
 
 /**
@@ -24,6 +26,7 @@ public CollectionSizeMatcher(int size) {
     }
 
     @Override
+    @SuppressFBWarnings(value = "DLS_DEAD_LOCAL_STORE", justification = "Iteration required to count size of an iterable")
     public boolean matches(T target) {
         if (target instanceof Collection) {
             return ((Collection<?>) target).size() == size;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -2999,7 +2999,7 @@ public Map<TypeDescription, File> saveIn(File folder) throws IOException {
             Map<TypeDescription, File> savedFiles = new HashMap<TypeDescription, File>();
             File target = new File(folder, typeDescription.getName().replace('.', File.separatorChar) + CLASS_FILE_EXTENSION);
             if (target.getParentFile() != null) {
-                if(!target.getParentFile().mkdirs()) {
+                if (!target.getParentFile().mkdirs()) {
                     Logger.getAnonymousLogger().info("Writing file to existing folder structure: " + target.getParent());
                 }
             }
@@ -3020,7 +3020,7 @@ public Map<TypeDescription, File> saveIn(File folder) throws IOException {
         public File inject(File sourceJar, File targetJar) throws IOException {
             JarInputStream jarInputStream = new JarInputStream(new BufferedInputStream(new FileInputStream(sourceJar)));
             try {
-                if(!targetJar.createNewFile()) {
+                if (!targetJar.createNewFile()) {
                     Logger.getAnonymousLogger().info("Overwriting file " + targetJar);
                 }
                 JarOutputStream jarOutputStream = new JarOutputStream(new BufferedOutputStream(new FileOutputStream(targetJar)), jarInputStream.getManifest());

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -573,7 +573,7 @@ public V resolve() {
                 public boolean equals(Object other) {
                     if (this == other) return true;
                     if (!(other instanceof AnnotationValue.Loaded<?>)) return false;
-                    AnnotationValue.Loaded<?> loadedOther = (ForEnumeration.Loaded<?>) other;
+                    AnnotationValue.Loaded<?> loadedOther = (AnnotationValue.Loaded<?>) other;
                     return loadedOther.getState().isResolved() && enumeration.equals(loadedOther.resolve());
                 }
 
@@ -1534,7 +1534,7 @@ public S loadSilent(ClassLoader classLoader) {
      *
      * @param <S> The type of the annotation.
      */
-    class ForLoadedAnnotation<S extends Annotation> extends AbstractBase.ForPrepared<S> implements Loadable<S> {
+    class ForLoadedAnnotation<S extends Annotation> extends AbstractBase.ForPrepared<S> {
 
         /**
          * The represented annotation value.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationList.java
Patch:
@@ -16,6 +16,7 @@
  */
 public interface AnnotationList extends FilterableList<AnnotationDescription, AnnotationList> {
 
+
     /**
      * Checks if this list contains an annotation of the given type.
      *

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/modifier/MethodArguments.java
Patch:
@@ -37,7 +37,7 @@ public enum MethodArguments implements ModifierContributor.ForMethod {
      * @param varargs {@code true} if the method is supposed to support varargs.
      * @return The corresponding method argument state.
      */
-    public static MethodArguments isVarargs(boolean varargs) {
+    public static MethodArguments isVarArgs(boolean varargs) {
         return varargs ? VARARGS : PLAIN;
     }
 
@@ -61,7 +61,7 @@ public boolean isDefault() {
      *
      * @return {@code true} if the current state represents a varargs method.
      */
-    public boolean isVarargs() {
+    public boolean isVarArgs() {
         return this == VARARGS;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -274,7 +274,7 @@ protected enum StaticFieldConstructor implements Implementation {
             /**
              * A reference of the {@link Object} type default constructor.
              */
-            protected final MethodDescription objectTypeDefaultConstructor;
+            private final MethodDescription objectTypeDefaultConstructor;
 
             /**
              * Creates the constructor call singleton.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -461,7 +461,7 @@ protected enum StaticFieldConstructor implements Implementation {
                 /**
                  * A reference of the {@link Object} type default constructor.
                  */
-                protected final MethodDescription objectTypeDefaultConstructor;
+                private final MethodDescription objectTypeDefaultConstructor;
 
                 /**
                  * Creates the constructor call singleton.

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/modifier/MethodArgumentsTest.java
Patch:
@@ -22,14 +22,14 @@ public MethodArgumentsTest(ModifierContributor modifierContributor, int expected
     public static Collection<Object[]> data() {
         return Arrays.asList(new Object[][]{
                 {MethodArguments.PLAIN, 0, true},
-                {MethodArguments.isVarargs(false), 0, true},
+                {MethodArguments.isVarArgs(false), 0, true},
                 {MethodArguments.VARARGS, Opcodes.ACC_VARARGS, false},
-                {MethodArguments.isVarargs(true), Opcodes.ACC_VARARGS, false},
+                {MethodArguments.isVarArgs(true), Opcodes.ACC_VARARGS, false},
         });
     }
 
     @Test
     public void testState() throws Exception {
-        assertThat(((MethodArguments) modifierContributor).isVarargs(), is(expectedModifier != 0));
+        assertThat(((MethodArguments) modifierContributor).isVarArgs(), is(expectedModifier != 0));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -23,6 +23,7 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.GenericSignatureFormatError;
 import java.lang.reflect.Method;
+import java.security.AccessController;
 import java.util.*;
 import java.util.concurrent.Callable;
 
@@ -324,6 +325,7 @@ public void testIsAssignableClassLoader() throws Exception {
         ClassLoader classLoader = new ByteArrayClassLoader(null,
                 ClassFileExtraction.of(SampleClass.class),
                 null,
+                AccessController.getContext(),
                 ByteArrayClassLoader.PersistenceHandler.MANIFEST,
                 PackageDefinitionStrategy.NoOp.INSTANCE);
         Class<?> otherSampleClass = classLoader.loadClass(SampleClass.class.getName());
@@ -518,6 +520,7 @@ public static Class<?> malform(Class<?> type) throws Exception {
             ClassLoader classLoader = new ByteArrayClassLoader(null,
                     Collections.singletonMap(type.getName(), classWriter.toByteArray()),
                     null,
+                    AccessController.getContext(),
                     ByteArrayClassLoader.PersistenceHandler.MANIFEST,
                     PackageDefinitionStrategy.NoOp.INSTANCE);
             return classLoader.loadClass(type.getName());

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/DynamicTypeDefaultTest.java
Patch:
@@ -174,6 +174,7 @@ public void testFileSaving() throws Exception {
     @Test
     public void testJarCreation() throws Exception {
         File file = File.createTempFile(FOO, TEMP);
+        assertThat(file.delete(), is(true));
         boolean fileDeletion;
         try {
             assertThat(dynamicType.toJar(file), is(file));
@@ -195,6 +196,7 @@ public void testJarCreation() throws Exception {
     @Test
     public void testJarWithExplicitManifestCreation() throws Exception {
         File file = File.createTempFile(FOO, TEMP);
+        assertThat(file.delete(), is(true));
         boolean fileDeletion;
         try {
             Manifest manifest = new Manifest();
@@ -230,6 +232,7 @@ public void testJarTargetInjection() throws Exception {
             jarOutputStream.close();
         }
         File file = File.createTempFile(FOO, TEMP);
+        assertThat(file.delete(), is(true));
         boolean fileDeletion;
         try {
             assertThat(dynamicType.inject(sourceFile, file), is(file));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoaderChildFirstTest.java
Patch:
@@ -16,6 +16,7 @@
 import org.objectweb.asm.commons.SimpleRemapper;
 
 import java.io.InputStream;
+import java.security.AccessController;
 import java.security.ProtectionDomain;
 import java.util.Arrays;
 import java.util.Collection;
@@ -70,6 +71,7 @@ public void setUp() throws Exception {
         classLoader = new ByteArrayClassLoader.ChildFirst(getClass().getClassLoader(),
                 values,
                 DEFAULT_PROTECTION_DOMAIN,
+                AccessController.getContext(),
                 persistenceHandler,
                 PackageDefinitionStrategy.NoOp.INSTANCE);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoaderTest.java
Patch:
@@ -15,6 +15,7 @@
 
 import java.io.InputStream;
 import java.net.URL;
+import java.security.AccessController;
 import java.security.ProtectionDomain;
 import java.util.Arrays;
 import java.util.Collection;
@@ -71,6 +72,7 @@ public void setUp() throws Exception {
         classLoader = new ByteArrayClassLoader(BOOTSTRAP_CLASS_LOADER,
                 ClassFileExtraction.of(Foo.class),
                 DEFAULT_PROTECTION_DOMAIN,
+                AccessController.getContext(),
                 persistenceHandler,
                 packageDefinitionStrategy);
         sealBase = new URL("file://foo");

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/MultipleParentClassLoaderTest.java
Patch:
@@ -146,6 +146,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(MultipleParentClassLoader.class).applyBasic();
         ObjectPropertyAssertion.of(MultipleParentClassLoader.CompoundEnumeration.class).applyBasic();
         ObjectPropertyAssertion.of(MultipleParentClassLoader.Builder.class).apply();
+        ObjectPropertyAssertion.of(MultipleParentClassLoader.Builder.ClassLoaderCreationAction.class).apply();
     }
 
     public static class Foo {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/MethodDelegationBindingPriorityTest.java
Patch:
@@ -11,7 +11,7 @@ public class MethodDelegationBindingPriorityTest extends AbstractImplementationT
 
     private static final String FOO = "FOO", BAR = "bar";
 
-    private static final double PRIORITY = 10d;
+    private static final int PRIORITY = 10;
 
     @Test
     public void testBindingPriority() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/AnnotationAppenderDefaultTest.java
Patch:
@@ -22,6 +22,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.security.AccessController;
 import java.security.ProtectionDomain;
 import java.util.Collections;
 
@@ -137,6 +138,7 @@ private Class<?> makeTypeWithAnnotation(Annotation annotation) throws Exception
         Class<?> bar = new ByteArrayClassLoader(getClass().getClassLoader(),
                 Collections.singletonMap(BAR, classWriter.toByteArray()),
                 DEFAULT_PROTECTION_DOMAIN,
+                AccessController.getContext(),
                 ByteArrayClassLoader.PersistenceHandler.LATENT,
                 PackageDefinitionStrategy.NoOp.INSTANCE).loadClass(BAR);
         assertThat(bar.getName(), is(BAR));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/BindingPriorityResolverTest.java
Patch:
@@ -39,8 +39,8 @@ public void setUp() throws Exception {
         when(right.getTarget()).thenReturn(rightMethod);
         when(leftMethod.getDeclaredAnnotations()).thenReturn(leftAnnotations);
         when(rightMethod.getDeclaredAnnotations()).thenReturn(rightAnnotations);
-        when(highPriority.value()).thenReturn(BindingPriority.DEFAULT * 2d);
-        when(lowPriority.value()).thenReturn(BindingPriority.DEFAULT / 2d);
+        when(highPriority.value()).thenReturn(BindingPriority.DEFAULT * 3);
+        when(lowPriority.value()).thenReturn(BindingPriority.DEFAULT * 2);
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -197,7 +197,7 @@ public boolean isResolved() {
 
                 @Override
                 public String toString() {
-                    return "TypePool.LazyTypeDescription.AnnotationValue.Loaded.State." + name();
+                    return "AnnotationDescription.AnnotationValue.Loaded.State." + name();
                 }
             }
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AnnotationDescriptionAnnotationValueLoadedStateTest.java
Patch:
@@ -24,6 +24,6 @@ public void testIsResolved() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(AnnotationDescription.AnnotationValue.Loaded.State.class);
+        ObjectPropertyAssertion.of(AnnotationDescription.AnnotationValue.Loaded.State.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/TypeVariableSourceVisitorNoOpTest.java
Patch:
@@ -25,6 +25,6 @@ public void testVisitMethod() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(TypeVariableSource.Visitor.NoOp.class);
+        ObjectPropertyAssertion.of(TypeVariableSource.Visitor.NoOp.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategyDefaultTest.java
Patch:
@@ -202,9 +202,9 @@ public void testInjectionWithPackageDefinitionStrategy() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(ClassLoadingStrategy.Default.class);
-        ObjectPropertyAssertion.of(ClassLoadingStrategy.Default.WrappingDispatcher.class);
-        ObjectPropertyAssertion.of(ClassLoadingStrategy.Default.InjectionDispatcher.class);
+        ObjectPropertyAssertion.of(ClassLoadingStrategy.Default.class).apply();
+        ObjectPropertyAssertion.of(ClassLoadingStrategy.Default.WrappingDispatcher.class).apply();
+        ObjectPropertyAssertion.of(ClassLoadingStrategy.Default.InjectionDispatcher.class).apply();
     }
 
     private static class Foo {

File: byte-buddy-dep/src/main/java/net/bytebuddy/NamingStrategy.java
Patch:
@@ -522,7 +522,7 @@ enum ForUnnamedType implements BaseNameResolver {
 
                 @Override
                 public String resolve(UnnamedType unnamedType) {
-                    return unnamedType.getSuperClass().asRawType().getName();
+                    return unnamedType.getSuperClass().asErasure().getName();
                 }
 
                 @Override
@@ -647,7 +647,7 @@ public PrefixingRandom(String prefix) {
 
         @Override
         public String name(UnnamedType unnamedType) {
-            return String.format("%s.%s$%s", prefix, unnamedType.getSuperClass().asRawType().getName(), randomString.nextString());
+            return String.format("%s.%s$%s", prefix, unnamedType.getSuperClass().asErasure().getName(), randomString.nextString());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -1617,7 +1617,7 @@ public S load(ClassLoader classLoader) {
 
         @Override
         public Object getValue(MethodDescription methodDescription) {
-            if (!methodDescription.getDeclaringType().asRawType().represents(annotation.annotationType())) {
+            if (!methodDescription.getDeclaringType().asErasure().represents(annotation.annotationType())) {
                 throw new IllegalArgumentException(methodDescription + " does not represent " + annotation.annotationType());
             }
             try {
@@ -1631,7 +1631,7 @@ public Object getValue(MethodDescription methodDescription) {
                         method.setAccessible(true);
                     }
                 }
-                return describe(method.invoke(annotation), methodDescription.getReturnType().asRawType());
+                return describe(method.invoke(annotation), methodDescription.getReturnType().asErasure());
             } catch (Exception exception) {
                 throw new IllegalStateException("Cannot access annotation property " + methodDescription, exception);
             }
@@ -1815,7 +1815,7 @@ public Builder define(String property, AnnotationValue<?, ?> value) {
             MethodList<?> methodDescriptions = annotationType.getDeclaredMethods().filter(named(nonNull(property)));
             if (methodDescriptions.isEmpty()) {
                 throw new IllegalArgumentException(annotationType + " does not define a property named " + property);
-            } else if (!methodDescriptions.getOnly().getReturnType().asRawType().isAnnotationValue(value.resolve())) {
+            } else if (!methodDescriptions.getOnly().getReturnType().asErasure().isAnnotationValue(value.resolve())) {
                 throw new IllegalArgumentException(value + " cannot be assigned to " + property);
             }
             Map<String, AnnotationValue<?, ?>> annotationValues = new HashMap<String, AnnotationValue<?, ?>>(this.annotationValues.size() + 1);

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -129,7 +129,7 @@ public int getModifiers() {
 
         @Override
         public int getOffset() {
-            TypeList parameterType = getDeclaringMethod().getParameters().asTypeList().asRawTypes();
+            TypeList parameterType = getDeclaringMethod().getParameters().asTypeList().asErasures();
             int offset = getDeclaringMethod().isStatic()
                     ? StackSize.ZERO.getSize()
                     : StackSize.SINGLE.getSize();
@@ -180,8 +180,8 @@ public String toString() {
                 stringBuilder.append(' ');
             }
             stringBuilder.append(isVarArgs()
-                    ? getType().asRawType().getName().replaceFirst("\\[\\]$", "...")
-                    : getType().asRawType().getName());
+                    ? getType().asErasure().getName().replaceFirst("\\[\\]$", "...")
+                    : getType().asErasure().getName());
             return stringBuilder.append(' ').append(getName()).toString();
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodRegistry.java
Patch:
@@ -510,7 +510,7 @@ public MethodRegistry.Prepared prepare(InstrumentedType instrumentedType,
                         && methodDescription.isPublic()
                         && !(methodDescription.isAbstract() || methodDescription.isFinal())
                         && !node.getSort().isMadeVisible()
-                        && methodDescription.getDeclaringType().asRawType().isPackagePrivate()) {
+                        && methodDescription.getDeclaringType().asErasure().isPackagePrivate()) {
                     // Visibility bridges are required for public types that inherit a public method from a package-private type.
                     // Checking the last condition contradicts any method that is defined by the instrumented type itself.
                     implementations.put(methodDescription, Prepared.Entry.forVisibilityBridge(methodDescription, node.getMethodTypes()));
@@ -528,7 +528,7 @@ public MethodRegistry.Prepared prepare(InstrumentedType instrumentedType,
             return new Prepared(implementations,
                     instrumentedType.getLoadedTypeInitializer(),
                     instrumentedType.getTypeInitializer(),
-                    instrumentedType.asRawType(),
+                    instrumentedType.asErasure(),
                     methodGraph);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/InliningImplementationMatcher.java
Patch:
@@ -50,8 +50,8 @@ protected static LatentMethodMatcher of(ElementMatcher<? super MethodDescription
             ElementMatcher.Junction<MethodDescription> signature = methodDescription.isConstructor()
                     ? isConstructor()
                     : ElementMatchers.<MethodDescription>named(methodDescription.getName());
-            signature = signature.and(returns(methodDescription.getReturnType().asRawType()));
-            signature = signature.and(takesArguments(methodDescription.getParameters().asTypeList().asRawTypes()));
+            signature = signature.and(returns(methodDescription.getReturnType().asErasure()));
+            signature = signature.and(takesArguments(methodDescription.getParameters().asTypeList().asErasures()));
             predefinedMethodSignatures = predefinedMethodSignatures.or(signature);
         }
         return new InliningImplementationMatcher(ignoredMethods, predefinedMethodSignatures);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTarget.java
Patch:
@@ -54,7 +54,7 @@ public Implementation.SpecialMethodInvocation invokeSuper(MethodDescription.Toke
     private Implementation.SpecialMethodInvocation invokeSuper(MethodDescription methodDescription) {
         return methodDescription.getDeclaringType().equals(instrumentedType)
                 ? invokeSuper(methodRebaseResolver.resolve(methodDescription.asDefined()))
-                : Implementation.SpecialMethodInvocation.Simple.of(methodDescription, instrumentedType.getSuperType().asRawType());
+                : Implementation.SpecialMethodInvocation.Simple.of(methodDescription, instrumentedType.getSuperType().asErasure());
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategy.java
Patch:
@@ -75,7 +75,7 @@ public MethodRegistry inject(MethodRegistry methodRegistry, MethodAttributeAppen
         DEFAULT_CONSTRUCTOR {
             @Override
             public List<MethodDescription.Token> extractConstructors(TypeDescription instrumentedType) {
-                TypeDescription superType = instrumentedType.getSuperType().asRawType();
+                TypeDescription superType = instrumentedType.getSuperType().asErasure();
                 MethodList<?> defaultConstructors = superType == null
                         ? new MethodList.Empty()
                         : superType.getDeclaredMethods().filter(isConstructor().and(takesArguments(0)).<MethodDescription>and(isVisibleTo(instrumentedType)));
@@ -130,7 +130,7 @@ public List<MethodDescription.Token> extractConstructors(TypeDescription instrum
                 GenericTypeDescription superType = instrumentedType.getSuperType();
                 return (superType == null
                         ? new MethodList.Empty()
-                        : superType.asRawType().getDeclaredMethods().filter(isPublic().and(isConstructor()))).asTokenList();
+                        : superType.asErasure().getDeclaredMethods().filter(isPublic().and(isConstructor()))).asTokenList();
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTarget.java
Patch:
@@ -65,7 +65,7 @@ private Implementation.SpecialMethodInvocation invokeConstructor(MethodDescripti
         MethodDescription methodDescription = superConstructors.get(methodToken);
         return methodDescription == null
                 ? Implementation.SpecialMethodInvocation.Illegal.INSTANCE
-                : Implementation.SpecialMethodInvocation.Simple.of(methodDescription, instrumentedType.getSuperType().asRawType());
+                : Implementation.SpecialMethodInvocation.Simple.of(methodDescription, instrumentedType.getSuperType().asErasure());
     }
 
     /**
@@ -77,7 +77,7 @@ private Implementation.SpecialMethodInvocation invokeConstructor(MethodDescripti
     private Implementation.SpecialMethodInvocation invokeMethod(MethodDescription.Token methodToken) {
         MethodGraph.Node methodNode = methodGraph.getSuperGraph().locate(methodToken);
         return methodNode.getSort().isUnique()
-                ? Implementation.SpecialMethodInvocation.Simple.of(methodNode.getRepresentative(), instrumentedType.getSuperType().asRawType())
+                ? Implementation.SpecialMethodInvocation.Simple.of(methodNode.getRepresentative(), instrumentedType.getSuperType().asErasure())
                 : Implementation.SpecialMethodInvocation.Illegal.INSTANCE;
     }
 
@@ -124,7 +124,7 @@ public enum OriginTypeResolver {
         SUPER_TYPE {
             @Override
             protected TypeDescription identify(TypeDescription typeDescription) {
-                return typeDescription.getSuperType().asRawType();
+                return typeDescription.getSuperType().asErasure();
             }
         },
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -236,14 +236,14 @@ protected ByteCodeAppender.Size apply(MethodVisitor methodVisitor,
                                           MethodDescription instrumentedMethod,
                                           TypeDescription fixedValueType,
                                           StackManipulation valueLoadingInstruction) {
-        StackManipulation assignment = assigner.assign(fixedValueType, instrumentedMethod.getReturnType().asRawType(), typing);
+        StackManipulation assignment = assigner.assign(fixedValueType, instrumentedMethod.getReturnType().asErasure(), typing);
         if (!assignment.isValid()) {
             throw new IllegalArgumentException("Cannot return value of type " + fixedValueType + " for " + instrumentedMethod);
         }
         StackManipulation.Size stackSize = new StackManipulation.Compound(
                 valueLoadingInstruction,
                 assignment,
-                MethodReturn.returning(instrumentedMethod.getReturnType().asRawType())
+                MethodReturn.returning(instrumentedMethod.getReturnType().asErasure())
         ).apply(methodVisitor, implementationContext);
         return new ByteCodeAppender.Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Forwarding.java
Patch:
@@ -337,9 +337,9 @@ public Size apply(MethodVisitor methodVisitor,
             }
             StackManipulation.Size stackSize = new StackManipulation.Compound(
                     delegateLoadingInstruction,
-                    MethodVariableAccess.allArgumentsOf(instrumentedMethod.asDefined()),
+                    MethodVariableAccess.allArgumentsOf(instrumentedMethod),
                     MethodInvocation.invoke(instrumentedMethod).virtual(fieldType),
-                    MethodReturn.returning(instrumentedMethod.getReturnType().asRawType())
+                    MethodReturn.returning(instrumentedMethod.getReturnType().asErasure())
             ).apply(methodVisitor, implementationContext);
             return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -120,7 +120,7 @@ public static InvocationHandlerAdapter toInstanceField(String fieldName) {
      * @return A list of stack manipulation that loads all arguments of an instrumented method.
      */
     private List<StackManipulation> argumentValuesOf(MethodDescription instrumentedMethod) {
-        TypeList parameterTypes = instrumentedMethod.getParameters().asTypeList().asRawTypes();
+        TypeList parameterTypes = instrumentedMethod.getParameters().asTypeList().asErasures();
         List<StackManipulation> instruction = new ArrayList<StackManipulation>(parameterTypes.size());
         TypeDescription objectType = TypeDescription.OBJECT;
         int currentIndex = 1;
@@ -174,8 +174,8 @@ protected ByteCodeAppender.Size apply(MethodVisitor methodVisitor,
                         : MethodConstant.forMethod(instrumentedMethod.asDefined()),
                 ArrayFactory.forType(TypeDescription.OBJECT).withValues(argumentValuesOf(instrumentedMethod)),
                 MethodInvocation.invoke(INVOCATION_HANDLER_TYPE.getDeclaredMethods().getOnly()),
-                assigner.assign(TypeDescription.OBJECT, instrumentedMethod.getReturnType().asRawType(), Assigner.Typing.DYNAMIC),
-                MethodReturn.returning(instrumentedMethod.getReturnType().asRawType())
+                assigner.assign(TypeDescription.OBJECT, instrumentedMethod.getReturnType().asErasure(), Assigner.Typing.DYNAMIC),
+                MethodReturn.returning(instrumentedMethod.getReturnType().asErasure())
         ).apply(methodVisitor, implementationContext);
         return new ByteCodeAppender.Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/StubMethod.java
Patch:
@@ -41,8 +41,8 @@ public Size apply(MethodVisitor methodVisitor,
                       Context implementationContext,
                       MethodDescription instrumentedMethod) {
         StackManipulation.Size stackSize = new StackManipulation.Compound(
-                DefaultValue.of(instrumentedMethod.getReturnType().asRawType()),
-                MethodReturn.returning(instrumentedMethod.getReturnType().asRawType())
+                DefaultValue.of(instrumentedMethod.getReturnType().asErasure()),
+                MethodReturn.returning(instrumentedMethod.getReturnType().asErasure())
         ).apply(methodVisitor, implementationContext);
         return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/SuperMethodCall.java
Patch:
@@ -113,7 +113,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                 throw new IllegalStateException("Cannot call super (or default) method for " + instrumentedMethod);
             }
             StackManipulation.Size stackSize = new StackManipulation.Compound(
-                    MethodVariableAccess.allArgumentsOf(instrumentedMethod.asDefined()).prependThisReference(),
+                    MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(),
                     superMethodCall,
                     terminationHandler.of(instrumentedMethod)
             ).apply(methodVisitor, implementationContext);
@@ -151,7 +151,7 @@ protected enum TerminationHandler {
             RETURNING {
                 @Override
                 protected StackManipulation of(MethodDescription methodDescription) {
-                    return MethodReturn.returning(methodDescription.getReturnType().asRawType());
+                    return MethodReturn.returning(methodDescription.getReturnType().asErasure());
                 }
             },
 
@@ -161,7 +161,7 @@ protected StackManipulation of(MethodDescription methodDescription) {
             DROPPING {
                 @Override
                 protected StackManipulation of(MethodDescription methodDescription) {
-                    return Removal.pop(methodDescription.getReturnType().asRawType());
+                    return Removal.pop(methodDescription.getReturnType().asErasure());
                 }
             };
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationAppender.java
Patch:
@@ -411,7 +411,7 @@ public Default(Target target, ValueFilter valueFilter) {
         private static void handle(AnnotationVisitor annotationVisitor, AnnotationDescription annotation, ValueFilter valueFilter) {
             for (MethodDescription methodDescription : annotation.getAnnotationType().getDeclaredMethods()) {
                 if (valueFilter.isRelevant(annotation, methodDescription)) {
-                    apply(annotationVisitor, methodDescription.getReturnType().asRawType(), methodDescription.getName(), annotation.getValue(methodDescription));
+                    apply(annotationVisitor, methodDescription.getReturnType().asErasure(), methodDescription.getName(), annotation.getValue(methodDescription));
                 }
             }
             annotationVisitor.visitEnd();

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/TypeAttributeAppender.java
Patch:
@@ -71,7 +71,7 @@ public void apply(ClassVisitor classVisitor, TypeDescription instrumentedType, G
                 return; // Takes into account that types can be renamed. This check is more reliable.
             }
             AnnotationAppender annotationAppender = new AnnotationAppender.Default(new AnnotationAppender.Target.OnType(classVisitor), valueFilter);
-            for (AnnotationDescription annotation : targetType.asRawType().getDeclaredAnnotations()) {
+            for (AnnotationDescription annotation : targetType.asErasure().getDeclaredAnnotations()) {
                 annotationAppender.append(annotation, AnnotationAppender.AnnotationVisibility.of(annotation));
             }
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TypeProxy.java
Patch:
@@ -868,9 +868,9 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                     return new StackManipulation.Compound(
                             MethodVariableAccess.REFERENCE.loadOffset(0),
                             fieldLoadingInstruction,
-                            MethodVariableAccess.allArgumentsOf(instrumentedMethod.asDefined()).asBridgeOf(proxyMethod),
+                            MethodVariableAccess.allArgumentsOf(instrumentedMethod).asBridgeOf(proxyMethod),
                             MethodInvocation.invoke(proxyMethod),
-                            MethodReturn.returning(instrumentedMethod.getReturnType().asRawType())
+                            MethodReturn.returning(instrumentedMethod.getReturnType().asErasure())
                     ).apply(methodVisitor, implementationContext);
                 }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/ArgumentTypeResolver.java
Patch:
@@ -48,8 +48,8 @@ private static Resolution resolveRivalBinding(TypeDescription sourceParameterTyp
                                                   MethodDelegationBinder.MethodBinding left,
                                                   int rightParameterIndex,
                                                   MethodDelegationBinder.MethodBinding right) {
-        TypeDescription leftParameterType = left.getTarget().getParameters().get(leftParameterIndex).getType().asRawType();
-        TypeDescription rightParameterType = right.getTarget().getParameters().get(rightParameterIndex).getType().asRawType();
+        TypeDescription leftParameterType = left.getTarget().getParameters().get(leftParameterIndex).getType().asErasure();
+        TypeDescription rightParameterType = right.getTarget().getParameters().get(rightParameterIndex).getType().asErasure();
         if (!leftParameterType.equals(rightParameterType)) {
             if (leftParameterType.isPrimitive() && rightParameterType.isPrimitive()) {
                 return PrimitiveTypePrecedence.forPrimitive(leftParameterType)
@@ -104,7 +104,7 @@ public Resolution resolve(MethodDescription source,
             Integer rightParameterIndex = right.getTargetParameterIndex(parameterIndexToken);
             if (leftParameterIndex != null && rightParameterIndex != null) {
                 resolution = resolution.merge(
-                        resolveRivalBinding(sourceParameters.get(sourceParameterIndex).getType().asRawType(),
+                        resolveRivalBinding(sourceParameters.get(sourceParameterIndex).getType().asErasure(),
                                 leftParameterIndex,
                                 left,
                                 rightParameterIndex,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/DeclaringTypeResolver.java
Patch:
@@ -18,8 +18,8 @@ public enum DeclaringTypeResolver implements MethodDelegationBinder.AmbiguityRes
     public Resolution resolve(MethodDescription source,
                               MethodDelegationBinder.MethodBinding left,
                               MethodDelegationBinder.MethodBinding right) {
-        TypeDescription leftType = left.getTarget().getDeclaringType().asRawType();
-        TypeDescription rightType = right.getTarget().getDeclaringType().asRawType();
+        TypeDescription leftType = left.getTarget().getDeclaringType().asErasure();
+        TypeDescription rightType = right.getTarget().getDeclaringType().asErasure();
         if (leftType.equals(rightType)) {
             return Resolution.AMBIGUOUS;
         } else if (leftType.isAssignableFrom(rightType)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/AllArguments.java
Patch:
@@ -135,13 +135,13 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             if (!target.getType().isArray()) {
                 throw new IllegalStateException("Expected an array type for all argument annotation on " + source);
             }
-            ArrayFactory arrayFactory = ArrayFactory.forType(target.getType().asRawType().getComponentType());
+            ArrayFactory arrayFactory = ArrayFactory.forType(target.getType().asErasure().getComponentType());
             boolean includeThis = !source.isStatic() && annotation.loadSilent().includeSelf();
             List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(source.getParameters().size() + (includeThis ? 1 : 0));
             int offset = source.isStatic() || includeThis ? 0 : 1;
             for (TypeDescription sourceParameter : includeThis
-                    ? join(implementationTarget.getTypeDescription(), source.getParameters().asTypeList().asRawTypes())
-                    : source.getParameters().asTypeList().asRawTypes()) {
+                    ? join(implementationTarget.getTypeDescription(), source.getParameters().asTypeList().asErasures())
+                    : source.getParameters().asTypeList().asErasures()) {
                 StackManipulation stackManipulation = new StackManipulation.Compound(
                         MethodVariableAccess.forType(sourceParameter).loadOffset(offset),
                         assigner.assign(sourceParameter, arrayFactory.getComponentType(), RuntimeType.Verifier.check(target)));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Argument.java
Patch:
@@ -161,8 +161,8 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             } else if (source.getParameters().size() <= argument.value()) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             }
-            return argument.bindingMechanic().makeBinding(source.getParameters().get(argument.value()).getType().asRawType(),
-                    target.getType().asRawType(),
+            return argument.bindingMechanic().makeBinding(source.getParameters().get(argument.value()).getType().asErasure(),
+                    target.getType().asErasure(),
                     argument.value(),
                     assigner,
                     RuntimeType.Verifier.check(target),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Default.java
Patch:
@@ -54,12 +54,12 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            if (!target.getType().asRawType().isInterface()) {
+            if (!target.getType().asErasure().isInterface()) {
                 throw new IllegalStateException(target + " uses the @Default annotation on a non-interface type");
-            } else if (source.isStatic() || !implementationTarget.getTypeDescription().getInterfaces().asRawTypes().contains(target.getType().asRawType())) {
+            } else if (source.isStatic() || !implementationTarget.getTypeDescription().getInterfaces().asErasures().contains(target.getType().asErasure())) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             } else {
-                return new MethodDelegationBinder.ParameterBinding.Anonymous(new TypeProxy.ForDefaultMethod(target.getType().asRawType(),
+                return new MethodDelegationBinder.ParameterBinding.Anonymous(new TypeProxy.ForDefaultMethod(target.getType().asErasure(),
                         implementationTarget,
                         annotation.loadSilent().serializableProxy()));
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultCall.java
Patch:
@@ -95,7 +95,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            TypeDescription targetType = target.getType().asRawType();
+            TypeDescription targetType = target.getType().asErasure();
             if (!targetType.represents(Runnable.class) && !targetType.represents(Callable.class) && !targetType.represents(Object.class)) {
                 throw new IllegalStateException("A default method call proxy can only be assigned to Runnable or Callable types: " + target);
             }
@@ -145,7 +145,7 @@ enum Implicit implements DefaultMethodLocator {
                 public Implementation.SpecialMethodInvocation resolve(Implementation.Target implementationTarget,
                                                                       MethodDescription source) {
                     Implementation.SpecialMethodInvocation specialMethodInvocation = null;
-                    for (TypeDescription candidate : implementationTarget.getTypeDescription().getInterfaces().asRawTypes()) {
+                    for (TypeDescription candidate : implementationTarget.getTypeDescription().getInterfaces().asErasures()) {
                         if (source.isSpecializableFor(candidate)) {
                             if (specialMethodInvocation != null) {
                                 return Implementation.SpecialMethodInvocation.Illegal.INSTANCE;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Empty.java
Patch:
@@ -43,7 +43,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            return new MethodDelegationBinder.ParameterBinding.Anonymous(DefaultValue.of(target.getType().asRawType()));
+            return new MethodDelegationBinder.ParameterBinding.Anonymous(DefaultValue.of(target.getType().asErasure()));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldValue.java
Patch:
@@ -98,8 +98,8 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                 ? StackManipulation.LegalTrivial.INSTANCE
                                 : MethodVariableAccess.REFERENCE.loadOffset(0),
                         FieldAccess.forField(resolution.getFieldDescription()).getter(),
-                        assigner.assign(resolution.getFieldDescription().getType().asRawType(),
-                                target.getType().asRawType(),
+                        assigner.assign(resolution.getFieldDescription().getType().asErasure(),
+                                target.getType().asErasure(),
                                 RuntimeType.Verifier.check(target))
                 );
                 return stackManipulation.isValid()

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Origin.java
Patch:
@@ -75,7 +75,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            TypeDescription parameterType = target.getType().asRawType();
+            TypeDescription parameterType = target.getType().asErasure();
             if (parameterType.represents(Class.class)) {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(ClassConstant.of(implementationTarget.getOriginType()));
             } else if (parameterType.represents(Method.class)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Super.java
Patch:
@@ -207,12 +207,12 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            if (source.isStatic() || !implementationTarget.getTypeDescription().isAssignableTo(target.getType().asRawType())) {
+            if (source.isStatic() || !implementationTarget.getTypeDescription().isAssignableTo(target.getType().asErasure())) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             } else {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(annotation
                         .getValue(STRATEGY, EnumerationDescription.class).load(Instantiation.class)
-                        .proxyFor(target.getType().asRawType(), implementationTarget, annotation));
+                        .proxyFor(target.getType().asErasure(), implementationTarget, annotation));
             }
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperCall.java
Patch:
@@ -69,7 +69,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            TypeDescription targetType = target.getType().asRawType();
+            TypeDescription targetType = target.getType().asErasure();
             if (!targetType.represents(Runnable.class) && !targetType.represents(Callable.class) && !targetType.represents(Object.class)) {
                 throw new IllegalStateException("A super method call proxy can only be assigned to Runnable or Callable types: " + target);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/This.java
Patch:
@@ -72,7 +72,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             StackManipulation assignment = source.isStatic()
                     ? NullConstant.INSTANCE
                     : new StackManipulation.Compound(MethodVariableAccess.REFERENCE.loadOffset(THIS_REFERENCE_INDEX),
-                    assigner.assign(implementationTarget.getTypeDescription(), target.getType().asRawType(), RuntimeType.Verifier.check(target)));
+                    assigner.assign(implementationTarget.getTypeDescription(), target.getType().asErasure(), RuntimeType.Verifier.check(target)));
             return assignment.isValid()
                     ? new MethodDelegationBinder.ParameterBinding.Anonymous(assignment)
                     : MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodConstant.java
Patch:
@@ -80,7 +80,7 @@ public boolean isValid() {
     public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
         Size argumentSize = prepare(methodVisitor)
                 .aggregate(ArrayFactory.forType(TypeDescription.CLASS)
-                        .withValues(typeConstantsFor(methodDescription.getParameters().asTypeList().asRawTypes()))
+                        .withValues(typeConstantsFor(methodDescription.getParameters().asTypeList().asErasures()))
                         .apply(methodVisitor, implementationContext));
         methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                 CLASS_TYPE_INTERNAL_NAME,
@@ -210,7 +210,7 @@ protected ForMethod(MethodDescription.InDefinedShape methodDescription) {
 
         @Override
         protected Size prepare(MethodVisitor methodVisitor) {
-            methodVisitor.visitLdcInsn(Type.getType(methodDescription.getDeclaringType().asRawType().getDescriptor()));
+            methodVisitor.visitLdcInsn(Type.getType(methodDescription.getDeclaringType().asErasure().getDescriptor()));
             methodVisitor.visitLdcInsn(methodDescription.getInternalName());
             return new Size(2, 2);
         }
@@ -260,7 +260,7 @@ protected ForConstructor(MethodDescription.InDefinedShape methodDescription) {
 
         @Override
         protected Size prepare(MethodVisitor methodVisitor) {
-            methodVisitor.visitLdcInsn(Type.getType(methodDescription.getDeclaringType().asRawType().getDescriptor()));
+            methodVisitor.visitLdcInsn(Type.getType(methodDescription.getDeclaringType().asErasure().getDescriptor()));
             return new Size(1, 1);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodHandleConstant.java
Patch:
@@ -46,7 +46,7 @@ public static StackManipulation of(MethodDescription.InDefinedShape methodDescri
         return methodDescription.isTypeInitializer()
                 ? Illegal.INSTANCE
                 : new MethodHandleConstant(new Handle(tagFor(methodDescription),
-                methodDescription.getDeclaringType().asRawType().getInternalName(),
+                methodDescription.getDeclaringType().asErasure().getInternalName(),
                 methodDescription.getInternalName(),
                 methodDescription.getDescriptor()));
     }
@@ -118,7 +118,7 @@ public static StackManipulation ofPutter(FieldDescription fieldDescription) {
      */
     private static StackManipulation of(FieldDescription fieldDescription, int tag) {
         return new MethodHandleConstant(new Handle(tag,
-                fieldDescription.getDeclaringType().asRawType().getInternalName(),
+                fieldDescription.getDeclaringType().asErasure().getInternalName(),
                 fieldDescription.getInternalName(),
                 fieldDescription.getDescriptor()));
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/FieldAccess.java
Patch:
@@ -92,7 +92,7 @@ public static Defined forField(FieldDescription.InDefinedShape fieldDescription)
      */
     public static Defined forField(FieldDescription fieldDescription) {
         FieldDescription.InDefinedShape declaredField = fieldDescription.asDefined();
-        return fieldDescription.getType().asRawType().equals(declaredField.getType().asRawType())
+        return fieldDescription.getType().asErasure().equals(declaredField.getType().asErasure())
                 ? forField(declaredField)
                 : OfGenericField.of(fieldDescription, forField(declaredField));
     }
@@ -156,7 +156,7 @@ protected OfGenericField(TypeDescription targetType, Defined defined) {
          * @return A field access dispatcher for the given field.
          */
         protected static Defined of(FieldDescription fieldDescription, Defined fieldAccess) {
-            return new OfGenericField(fieldDescription.getType().asRawType(), fieldAccess);
+            return new OfGenericField(fieldDescription.getType().asErasure(), fieldAccess);
         }
 
         @Override
@@ -264,7 +264,7 @@ public boolean isValid() {
             @Override
             public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                 methodVisitor.visitFieldInsn(getOpcode(),
-                        fieldDescription.getDeclaringType().asRawType().getInternalName(),
+                        fieldDescription.getDeclaringType().asErasure().getInternalName(),
                         fieldDescription.getInternalName(),
                         fieldDescription.getDescriptor());
                 return resolveSize(fieldDescription.getType().getStackSize());

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionRawTypeMatcher.java
Patch:
@@ -31,7 +31,7 @@ public CollectionRawTypeMatcher(ElementMatcher<? super Iterable<? extends TypeDe
     public boolean matches(T target) {
         List<TypeDescription> typeDescriptions = new LinkedList<TypeDescription>();
         for (GenericTypeDescription typeDescription : target) {
-            typeDescriptions.add(typeDescription.asRawType());
+            typeDescriptions.add(typeDescription.asErasure());
         }
         return matcher.matches(typeDescriptions);
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -1111,7 +1111,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> declaresG
      * @return A matcher that matches any method that exactly matches the provided generic exception.
      */
     public static <T extends MethodDescription> ElementMatcher.Junction<T> declaresGenericException(GenericTypeDescription exceptionType) {
-        return !exceptionType.getSort().isWildcard() && exceptionType.asRawType().isAssignableTo(Throwable.class)
+        return !exceptionType.getSort().isWildcard() && exceptionType.asErasure().isAssignableTo(Throwable.class)
                 ? ElementMatchers.<T>declaresGenericException(new CollectionItemMatcher<GenericTypeDescription>(is(exceptionType)))
                 : new BooleanMatcher<T>(false);
     }
@@ -1135,7 +1135,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> declaresE
      * @return A matcher that matches any method that exactly matches the provided exception.
      */
     public static <T extends MethodDescription> ElementMatcher.Junction<T> declaresException(TypeDescription exceptionType) {
-        return !exceptionType.getSort().isWildcard() && exceptionType.asRawType().isAssignableTo(Throwable.class)
+        return !exceptionType.getSort().isWildcard() && exceptionType.asErasure().isAssignableTo(Throwable.class)
                 ? ElementMatchers.<T>declaresGenericException(new CollectionItemMatcher<GenericTypeDescription>(rawType(exceptionType)))
                 : new BooleanMatcher<T>(false);
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/RawTypeMatcher.java
Patch:
@@ -27,7 +27,7 @@ public RawTypeMatcher(ElementMatcher<? super TypeDescription> rawTypeMatcher) {
 
     @Override
     public boolean matches(T target) {
-        return !target.getSort().isWildcard() && rawTypeMatcher.matches(target.asRawType());
+        return !target.getSort().isWildcard() && rawTypeMatcher.matches(target.asErasure());
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTest.java
Patch:
@@ -73,7 +73,7 @@ public class ByteBuddyTest {
     public void setUp() throws Exception {
         when(modifierContributorForType.getMask()).thenReturn(MASK);
         when(typeDescription.isInterface()).thenReturn(true);
-        when(typeDescription.asRawType()).thenReturn(typeDescription);
+        when(typeDescription.asErasure()).thenReturn(typeDescription);
         when(typeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -438,7 +438,7 @@ public enum SumMethod implements ByteCodeAppender {
         public Size apply(MethodVisitor methodVisitor,
                           Implementation.Context implementationContext,
                           MethodDescription instrumentedMethod) {
-            if (!instrumentedMethod.getReturnType().asRawType().represents(int.class)) {
+            if (!instrumentedMethod.getReturnType().asErasure().represents(int.class)) {
                 throw new IllegalArgumentException(instrumentedMethod + " must return int");
             }
             StackManipulation.Size operandStackSize = new StackManipulation.Compound(
@@ -496,7 +496,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            if (!target.getType().asRawType().represents(String.class)) {
+            if (!target.getType().asErasure().represents(String.class)) {
                 throw new IllegalStateException(target + " makes wrong use of StringValue");
             }
             StackManipulation constant = new TextConstant(annotation.loadSilent().value());
@@ -604,7 +604,7 @@ private static class GettingStartedNamingStrategy implements NamingStrategy {
 
         @Override
         public String name(UnnamedType unnamedType) {
-            return "i.love.ByteBuddy." + unnamedType.getSuperClass().asRawType().getSimpleName();
+            return "i.love.ByteBuddy." + unnamedType.getSuperClass().asErasure().getSimpleName();
         }
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/NamingStrategyTest.java
Patch:
@@ -36,7 +36,7 @@ public class NamingStrategyTest {
 
     @Before
     public void setUp() throws Exception {
-        when(genericSuperType.asRawType()).thenReturn(rawSuperType);
+        when(genericSuperType.asErasure()).thenReturn(rawSuperType);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/AbstractFieldDescriptionTest.java
Patch:
@@ -176,7 +176,7 @@ public void testAnnotations() throws Exception {
     @Test
     public void testGenericTypes() throws Exception {
         assertThat(describe(genericField).getType(), is(GenericTypeDescription.Sort.describe(genericField.getGenericType())));
-        assertThat(describe(genericField).getType().asRawType(), is((TypeDescription) new TypeDescription.ForLoadedType(genericField.getType())));
+        assertThat(describe(genericField).getType().asErasure(), is((TypeDescription) new TypeDescription.ForLoadedType(genericField.getType())));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionTokenTest.java
Patch:
@@ -45,8 +45,8 @@ public class MethodDescriptionTokenTest {
 
     @Before
     public void setUp() throws Exception {
-        when(first.asRawType()).thenReturn(firstRaw);
-        when(second.asRawType()).thenReturn(secondRaw);
+        when(first.asErasure()).thenReturn(firstRaw);
+        when(second.asErasure()).thenReturn(secondRaw);
         when(firstParameter.getType()).thenReturn(first);
         when(secondParameter.getType()).thenReturn(second);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/AbstractGenericTypeListTest.java
Patch:
@@ -13,8 +13,8 @@ public abstract class AbstractGenericTypeListTest<U> extends AbstractFilterableL
 
     @Test
     public void testRawTypes() throws Exception {
-        assertThat(asList(Collections.singletonList(getFirst())).asRawTypes().size(), is(1));
-        assertThat(asList(Collections.singletonList(getFirst())).asRawTypes().getOnly(), is(asElement(getFirst()).asRawType()));
+        assertThat(asList(Collections.singletonList(getFirst())).asErasures().size(), is(1));
+        assertThat(asList(Collections.singletonList(getFirst())).asErasures().getOnly(), is(asElement(getFirst()).asErasure()));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericTypeDescriptionTest.java
Patch:
@@ -38,7 +38,7 @@ public void testZeroArityReturnsInstance() throws Exception {
     @Test
     public void testNonGenericArrayType() throws Exception {
         TypeDescription typeDescription = mock(TypeDescription.class);
-        when(typeDescription.asRawType()).thenReturn(typeDescription);
+        when(typeDescription.asErasure()).thenReturn(typeDescription);
         when(typeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
         assertThat(GenericTypeDescription.ForGenericArray.Latent.of(typeDescription, 1).getSort(), is(GenericTypeDescription.Sort.NON_GENERIC));
         assertThat(GenericTypeDescription.ForGenericArray.Latent.of(typeDescription, 1).getComponentType(), is((GenericTypeDescription) typeDescription));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericTypeDescriptionVisitorTypeErasingTest.java
Patch:
@@ -26,7 +26,7 @@ public class GenericTypeDescriptionVisitorTypeErasingTest {
 
     @Before
     public void setUp() throws Exception {
-        when(genericTypeDescription.asRawType()).thenReturn(typeDescription);
+        when(genericTypeDescription.asErasure()).thenReturn(typeDescription);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericTypeListEmptyTest.java
Patch:
@@ -9,7 +9,7 @@ public class GenericTypeListEmptyTest {
 
     @Test
     public void testRawTypes() throws Exception {
-        assertThat(new GenericTypeList.Empty().asRawTypes().size(), is(0));
+        assertThat(new GenericTypeList.Empty().asErasures().size(), is(0));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/MethodTransformerSimpleTest.java
Patch:
@@ -92,9 +92,9 @@ public void setUp() throws Exception {
         when(parameterToken.getModifiers()).thenReturn(MODIFIERS * 2);
         when(definedMethod.getParameters())
                 .thenReturn(new ParameterList.Explicit<ParameterDescription.InDefinedShape>(Collections.singletonList(definedParameter)));
-        when(declaringType.asRawType()).thenReturn(rawDeclaringType);
-        when(returnType.asRawType()).thenReturn(rawReturnType);
-        when(parameterType.asRawType()).thenReturn(rawParameterType);
+        when(declaringType.asErasure()).thenReturn(rawDeclaringType);
+        when(returnType.asErasure()).thenReturn(rawReturnType);
+        when(parameterType.asErasure()).thenReturn(rawParameterType);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterMethodPoolRecordTest.java
Patch:
@@ -87,7 +87,7 @@ public void setUp() throws Exception {
         when(methodDescription.getGenericSignature()).thenReturn(QUX);
         when(methodDescription.getExceptionTypes()).thenReturn(exceptionTypes);
         when(methodDescription.getAdjustedModifiers(anyBoolean())).thenReturn(MODIFIERS);
-        when(exceptionTypes.asRawTypes()).thenReturn(rawExceptionTypes);
+        when(exceptionTypes.asErasures()).thenReturn(rawExceptionTypes);
         when(rawExceptionTypes.toInternalNames()).thenReturn(new String[]{BAZ});
         when(classVisitor.visitMethod(MODIFIERS, FOO, BAR, QUX, new String[]{BAZ})).thenReturn(methodVisitor);
         when(methodDescription.getParameters())

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/InlineImplementationMatcherTest.java
Patch:
@@ -38,9 +38,9 @@ public class InlineImplementationMatcherTest {
     public void setUp() throws Exception {
         latentMethodMatcher = new InliningImplementationMatcher(ignoredMethods, predefinedMethods);
         when(typeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
-        when(typeDescription.asRawType()).thenReturn(typeDescription);
+        when(typeDescription.asErasure()).thenReturn(typeDescription);
         when(otherType.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
-        when(otherType.asRawType()).thenReturn(otherType);
+        when(otherType.asErasure()).thenReturn(otherType);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverMethodsOnlyTest.java
Patch:
@@ -55,11 +55,11 @@ public void setUp() throws Exception {
         when(method.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(method, Collections.singletonList(parameterType)));
         when(constructor.isConstructor()).thenReturn(true);
         when(methodNameTransformer.transform(method)).thenReturn(BAR);
-        when(returnType.asRawType()).thenReturn(returnType);
-        when(parameterType.asRawType()).thenReturn(parameterType);
+        when(returnType.asErasure()).thenReturn(returnType);
+        when(parameterType.asErasure()).thenReturn(parameterType);
         when(parameterType.accept(Mockito.any(GenericTypeDescription.Visitor.class))).thenReturn(parameterType);
         when(method.getDeclaringType()).thenReturn(declaringType);
-        when(declaringType.asRawType()).thenReturn(declaringType);
+        when(declaringType.asErasure()).thenReturn(declaringType);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedMethodTest.java
Patch:
@@ -61,9 +61,9 @@ public void setUp() throws Exception {
         when(otherMethodNameTransformer.transform(methodDescription)).thenReturn(FOO + BAR);
         when(parameterType.getStackSize()).thenReturn(StackSize.ZERO);
         when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(methodDescription, Collections.singletonList(parameterType)));
-        when(returnType.asRawType()).thenReturn(returnType);
+        when(returnType.asErasure()).thenReturn(returnType);
         when(returnType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(returnType);
-        when(parameterType.asRawType()).thenReturn(parameterType);
+        when(parameterType.asErasure()).thenReturn(parameterType);
         when(parameterType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(parameterType);
     }
 
@@ -94,7 +94,7 @@ public void apply(MethodDescription mock) {
                 when(mock.getExceptionTypes()).thenReturn(new GenericTypeList.Empty());
                 when(mock.getDeclaringType()).thenReturn(mock(TypeDescription.class));
                 TypeDescription returnType = mock(TypeDescription.class);
-                when(returnType.asRawType()).thenReturn(returnType);
+                when(returnType.asErasure()).thenReturn(returnType);
                 when(mock.getReturnType()).thenReturn(returnType);
             }
         }).refine(new ObjectPropertyAssertion.Refinement<MethodRebaseResolver.MethodNameTransformer>() {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilderTest.java
Patch:
@@ -121,14 +121,14 @@ public void testObjectProperties() throws Exception {
             @Override
             public List<?> create() {
                 TypeDescription typeDescription = mock(TypeDescription.class);
-                when(typeDescription.asRawType()).thenReturn(typeDescription);
+                when(typeDescription.asErasure()).thenReturn(typeDescription);
                 return Collections.singletonList(typeDescription);
             }
         }).create(new ObjectPropertyAssertion.Creator<TypeDescription>() {
             @Override
             public TypeDescription create() {
                 TypeDescription typeDescription = mock(TypeDescription.class);
-                when(typeDescription.asRawType()).thenReturn(typeDescription);
+                when(typeDescription.asErasure()).thenReturn(typeDescription);
                 when(typeDescription.getInterfaces()).thenReturn(new GenericTypeList.Explicit(Collections.singletonList(typeDescription)));
                 when(typeDescription.getDeclaredFields()).thenReturn(new FieldList.Empty());
                 when(typeDescription.getDeclaredMethods()).thenReturn(new MethodList.Empty());

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTargetTest.java
Patch:
@@ -38,7 +38,7 @@ public void setUp() throws Exception {
         when(methodGraph.locate(Mockito.any(MethodDescription.Token.class))).thenReturn(MethodGraph.Node.Unresolved.INSTANCE);
         when(methodGraph.locate(invokableToken)).thenReturn(new MethodGraph.Node.Simple(invokableMethod));
         when(instrumentedType.getSuperType()).thenReturn(superType);
-        when(superType.asRawType()).thenReturn(superType);
+        when(superType.asErasure()).thenReturn(superType);
         when(superType.getInternalName()).thenReturn(BAR);
         when(rebasedMethod.getInternalName()).thenReturn(QUX);
         when(rebasedMethod.getDescriptor()).thenReturn(FOO);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilderTest.java
Patch:
@@ -98,14 +98,14 @@ public void testObjectProperties() throws Exception {
             @Override
             public List<?> create() {
                 TypeDescription typeDescription = mock(TypeDescription.class);
-                when(typeDescription.asRawType()).thenReturn(typeDescription);
+                when(typeDescription.asErasure()).thenReturn(typeDescription);
                 return Collections.singletonList(typeDescription);
             }
         }).create(new ObjectPropertyAssertion.Creator<TypeDescription>() {
             @Override
             public TypeDescription create() {
                 TypeDescription typeDescription = mock(TypeDescription.class);
-                when(typeDescription.asRawType()).thenReturn(typeDescription);
+                when(typeDescription.asErasure()).thenReturn(typeDescription);
                 when(typeDescription.getInterfaces()).thenReturn(new GenericTypeList.Explicit(Collections.singletonList(typeDescription)));
                 when(typeDescription.getDeclaredFields()).thenReturn(new FieldList.Empty());
                 when(typeDescription.getDeclaredMethods()).thenReturn(new MethodList.Empty());

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategyDefaultTest.java
Patch:
@@ -53,7 +53,7 @@ public void setUp() throws Exception {
                 any(MethodTransformer.class))).thenReturn(methodRegistry);
         when(instrumentedType.getSuperType()).thenReturn(superType);
         when(superType.getDeclaredMethods()).thenReturn((MethodList) methodList);
-        when(superType.asRawType()).thenReturn(superType);
+        when(superType.asErasure()).thenReturn(superType);
         when(filteredMethodList.asTokenList()).thenReturn(filteredMethodTokenList);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderInstrumentableMatcherTest.java
Patch:
@@ -37,9 +37,9 @@ public class SubclassDynamicTypeBuilderInstrumentableMatcherTest {
     @Before
     public void setUp() throws Exception {
         latentMethodMatcher = new SubclassDynamicTypeBuilder.InstrumentableMatcher(ignoredMethods);
-        when(typeDescription.asRawType()).thenReturn(typeDescription);
+        when(typeDescription.asErasure()).thenReturn(typeDescription);
         when(typeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
-        when(otherType.asRawType()).thenReturn(otherType);
+        when(otherType.asErasure()).thenReturn(otherType);
         when(otherType.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTargetFactoryTest.java
Patch:
@@ -32,7 +32,7 @@ public class SubclassImplementationTargetFactoryTest {
     @Before
     public void setUp() throws Exception {
         when(instrumentedType.getSuperType()).thenReturn(superType);
-        when(superType.asRawType()).thenReturn(superType);
+        when(superType.asErasure()).thenReturn(superType);
         when(superType.getDeclaredMethods()).thenReturn(new MethodList.Empty());
         factory = new SubclassImplementationTarget.Factory(SubclassImplementationTarget.OriginTypeResolver.SUPER_TYPE);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTargetTest.java
Patch:
@@ -41,7 +41,7 @@ public void setUp() throws Exception {
         when(superGraph.locate(Mockito.any(MethodDescription.Token.class))).thenReturn(MethodGraph.Node.Unresolved.INSTANCE);
         when(superGraph.locate(invokableToken)).thenReturn(new MethodGraph.Node.Simple(invokableMethod));
         when(instrumentedType.getSuperType()).thenReturn(superType);
-        when(superType.asRawType()).thenReturn(superType);
+        when(superType.asErasure()).thenReturn(superType);
         when(superType.getInternalName()).thenReturn(BAR);
         when(superType.getDeclaredMethods())
                 .thenReturn(new MethodList.Explicit<MethodDescription.InDefinedShape>(Collections.singletonList(superTypeConstructor)));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/DefaultMethodCallTest.java
Patch:
@@ -161,7 +161,7 @@ public void testObjectProperties() throws Exception {
             public List<?> create() {
                 TypeDescription typeDescription = mock(TypeDescription.class);
                 when(typeDescription.isInterface()).thenReturn(true);
-                when(typeDescription.asRawType()).thenReturn(typeDescription);
+                when(typeDescription.asErasure()).thenReturn(typeDescription);
                 when(typeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
                 return Collections.singletonList(typeDescription);
             }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/TypeAttributeAppenderForInstrumentedTypeTest.java
Patch:
@@ -20,7 +20,7 @@ public class TypeAttributeAppenderForInstrumentedTypeTest extends AbstractTypeAt
     public void setUp() throws Exception {
         super.setUp();
         when(typeDescription.getSuperType()).thenReturn(targetType);
-        when(targetType.asRawType()).thenReturn(rawSuperType);
+        when(targetType.asErasure()).thenReturn(rawSuperType);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/AbstractArgumentTypeResolverTest.java
Patch:
@@ -49,7 +49,7 @@ public void setUp() throws Exception {
         when(sourceParameter.getType()).thenReturn(sourceType);
         when(leftMethod.getParameters()).thenReturn((ParameterList) leftParameterList);
         when(rightMethod.getParameters()).thenReturn((ParameterList) rightParameterList);
-        when(sourceType.asRawType()).thenReturn(sourceType);
+        when(sourceType.asErasure()).thenReturn(sourceType);
     }
 
     private static class IndexTokenMatcher extends BaseMatcher<ArgumentTypeResolver.ParameterIndexToken> {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/ArgumentTypeResolverPrimitiveTest.java
Patch:
@@ -83,8 +83,8 @@ public void setUp() throws Exception {
         when(firstPrimitive.represents(firstType)).thenReturn(true);
         when(secondPrimitive.isPrimitive()).thenReturn(true);
         when(secondPrimitive.represents(secondType)).thenReturn(true);
-        when(firstPrimitive.asRawType()).thenReturn(firstPrimitive);
-        when(secondPrimitive.asRawType()).thenReturn(secondPrimitive);
+        when(firstPrimitive.asErasure()).thenReturn(firstPrimitive);
+        when(secondPrimitive.asErasure()).thenReturn(secondPrimitive);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/ArgumentTypeResolverReferenceTest.java
Patch:
@@ -37,8 +37,8 @@ public void setUp() throws Exception {
         when(dominantTargetType.isAssignableTo(weakTargetType)).thenReturn(true);
         when(weakTargetParameter.getType()).thenReturn(weakTargetType);
         when(dominantTargetParameter.getType()).thenReturn(dominantTargetType);
-        when(weakTargetType.asRawType()).thenReturn(weakTargetType);
-        when(dominantTargetType.asRawType()).thenReturn(dominantTargetType);
+        when(weakTargetType.asErasure()).thenReturn(weakTargetType);
+        when(dominantTargetType.asErasure()).thenReturn(dominantTargetType);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/AllArgumentsBinderTest.java
Patch:
@@ -41,7 +41,7 @@ public void setUp() throws Exception {
         super.setUp();
         when(firstSourceType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(secondSourceType.getStackSize()).thenReturn(StackSize.SINGLE);
-        when(targetType.asRawType()).thenReturn(targetType);
+        when(targetType.asErasure()).thenReturn(targetType);
     }
 
     @Override
@@ -149,7 +149,7 @@ public void testNonArrayTypeBinding() throws Exception {
         TypeDescription targetType = mock(TypeDescription.class);
         when(targetType.isArray()).thenReturn(false);
         when(target.getType()).thenReturn(targetType);
-        when(targetType.asRawType()).thenReturn(targetType);
+        when(targetType.asErasure()).thenReturn(targetType);
         AllArguments.Binder.INSTANCE.bind(annotationDescription, source, target, implementationTarget, assigner);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ArgumentBinderTest.java
Patch:
@@ -37,9 +37,9 @@ public ArgumentBinderTest() {
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
         super.setUp();
-        when(sourceType.asRawType()).thenReturn(sourceType);
+        when(sourceType.asErasure()).thenReturn(sourceType);
         when(sourceType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(sourceType);
-        when(targetType.asRawType()).thenReturn(targetType);
+        when(targetType.asErasure()).thenReturn(targetType);
         when(targetType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(targetType);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/DefaultBinderTest.java
Patch:
@@ -34,8 +34,8 @@ public void setUp() throws Exception {
         super.setUp();
         when(target.getType()).thenReturn(targetType);
         when(instrumentedType.getInterfaces()).thenReturn(interfaces);
-        when(interfaces.asRawTypes()).thenReturn(rawInterfaces);
-        when(targetType.asRawType()).thenReturn(targetType);
+        when(interfaces.asErasures()).thenReturn(rawInterfaces);
+        when(targetType.asErasure()).thenReturn(targetType);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/DefaultCallBinderTest.java
Patch:
@@ -39,10 +39,10 @@ public DefaultCallBinderTest() {
     public void setUp() throws Exception {
         super.setUp();
         when(target.getType()).thenReturn(targetParameterType);
-        when(targetParameterType.asRawType()).thenReturn(targetParameterType);
+        when(targetParameterType.asErasure()).thenReturn(targetParameterType);
         when(implementationTarget.invokeDefault(any(TypeDescription.class), eq(methodToken))).thenReturn(specialMethodInvocation);
-        when(firstInterface.asRawType()).thenReturn(firstInterface);
-        when(secondInterface.asRawType()).thenReturn(secondInterface);
+        when(firstInterface.asErasure()).thenReturn(firstInterface);
+        when(secondInterface.asErasure()).thenReturn(secondInterface);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldValueBinderTest.java
Patch:
@@ -40,8 +40,8 @@ public void setUp() throws Exception {
         super.setUp();
         when(fieldDescription.asDefined()).thenReturn(fieldDescription);
         when(fieldDescription.getType()).thenReturn(fieldType);
-        when(fieldType.asRawType()).thenReturn(fieldType);
-        when(targetType.asRawType()).thenReturn(targetType);
+        when(fieldType.asErasure()).thenReturn(fieldType);
+        when(targetType.asErasure()).thenReturn(targetType);
         when(target.getType()).thenReturn(targetType);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/MorphBinderTest.java
Patch:
@@ -47,8 +47,8 @@ protected TargetMethodAnnotationDrivenBinder.ParameterBinder<Morph> getSimpleBin
     @Before
     public void setUp() throws Exception {
         super.setUp();
-        when(morphType.asRawType()).thenReturn(morphType);
-        when(defaultType.asRawType()).thenReturn(defaultType);
+        when(morphType.asErasure()).thenReturn(morphType);
+        when(defaultType.asErasure()).thenReturn(defaultType);
         when(source.asToken()).thenReturn(sourceToken);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/OriginBinderTest.java
Patch:
@@ -40,7 +40,7 @@ public OriginBinderTest() {
     public void setUp() throws Exception {
         super.setUp();
         when(target.getType()).thenReturn(targetType);
-        when(targetType.asRawType()).thenReturn(targetType);
+        when(targetType.asErasure()).thenReturn(targetType);
         when(source.asDefined()).thenReturn(methodDescription);
     }
 
@@ -92,7 +92,7 @@ public void testMethodHandleBinding() throws Exception {
         targetType = new TypeDescription.ForLoadedType(JavaType.METHOD_HANDLE.load());
         when(target.getType()).thenReturn(targetType);
         TypeDescription typeDescription = mock(TypeDescription.class);
-        when(typeDescription.asRawType()).thenReturn(typeDescription);
+        when(typeDescription.asErasure()).thenReturn(typeDescription);
         when(methodDescription.getDeclaringType()).thenReturn(typeDescription);
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = Origin.Binder.INSTANCE
                 .bind(annotationDescription, source, target, implementationTarget, assigner);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/PipeBinderTest.java
Patch:
@@ -33,7 +33,7 @@ public void setUp() throws Exception {
         super.setUp();
         when(targetMethod.getDeclaringType()).thenReturn(targetMethodType);
         binder = new Pipe.Binder(targetMethod);
-        when(targetMethodType.asRawType()).thenReturn(targetMethodType);
+        when(targetMethodType.asErasure()).thenReturn(targetMethodType);
     }
 
     @Override
@@ -67,7 +67,7 @@ public void testCannotPipeStaticMethod() throws Exception {
     @Test(expected = IllegalStateException.class)
     public void testParameterBindingOnIllegalTargetTypeThrowsException() throws Exception {
         TypeDescription targetType = mock(TypeDescription.class);
-        when(targetType.asRawType()).thenReturn(targetType);
+        when(targetType.asErasure()).thenReturn(targetType);
         when(target.getType()).thenReturn(targetType);
         binder.bind(annotationDescription,
                 source,

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/StubValueBinderTest.java
Patch:
@@ -35,7 +35,7 @@ public void testVoidReturnType() throws Exception {
     public void testNonVoidAssignableReturnType() throws Exception {
         when(target.getType()).thenReturn(TypeDescription.OBJECT);
         TypeDescription typeDescription = mock(TypeDescription.class);
-        when(typeDescription.asRawType()).thenReturn(typeDescription);
+        when(typeDescription.asErasure()).thenReturn(typeDescription);
         when(source.getReturnType()).thenReturn(typeDescription);
         when(stackManipulation.isValid()).thenReturn(true);
         assertThat(StubValue.Binder.INSTANCE.bind(annotationDescription,
@@ -60,7 +60,7 @@ public void testNonVoidNonAssignableReturnType() throws Exception {
     @Test(expected = IllegalStateException.class)
     public void testIllegalParameter() throws Exception {
         TypeDescription typeDescription = mock(TypeDescription.class);
-        when(typeDescription.asRawType()).thenReturn(typeDescription);
+        when(typeDescription.asErasure()).thenReturn(typeDescription);
         when(target.getType()).thenReturn(typeDescription);
         StubValue.Binder.INSTANCE.bind(annotationDescription, source, target, implementationTarget, assigner);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/SuperBinderTest.java
Patch:
@@ -32,7 +32,7 @@ public void setUp() throws Exception {
         when(annotation.strategy()).thenReturn(instantiation);
         when(instantiation.proxyFor(targetType, implementationTarget, annotationDescription)).thenReturn(stackManipulation);
         when(annotation.constructorParameters()).thenReturn(new Class<?>[0]);
-        when(targetType.asRawType()).thenReturn(targetType);
+        when(targetType.asErasure()).thenReturn(targetType);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/SuperCallBinderTest.java
Patch:
@@ -34,7 +34,7 @@ public void setUp() throws Exception {
         super.setUp();
         when(target.getType()).thenReturn(targetParameterType);
         when(implementationTarget.invokeSuper(sourceToken)).thenReturn(specialMethodInvocation);
-        when(targetParameterType.asRawType()).thenReturn(targetParameterType);
+        when(targetParameterType.asErasure()).thenReturn(targetParameterType);
         when(source.asToken()).thenReturn(sourceToken);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinderTerminationHandlerDroppingTest.java
Patch:
@@ -34,7 +34,7 @@ public class TargetMethodAnnotationDrivenBinderTerminationHandlerDroppingTest {
     @Before
     public void setUp() throws Exception {
         when(target.getReturnType()).thenReturn(targetType);
-        when(targetType.asRawType()).thenReturn(targetType);
+        when(targetType.asErasure()).thenReturn(targetType);
         when(targetType.getStackSize()).thenReturn(StackSize.SINGLE);
     }
 
@@ -43,7 +43,7 @@ public void testApplication() throws Exception {
         StackManipulation stackManipulation = TargetMethodAnnotationDrivenBinder.TerminationHandler.Dropping.INSTANCE.resolve(assigner, source, target);
         assertThat(stackManipulation, is((StackManipulation) Removal.SINGLE));
         verify(targetType).getStackSize();
-        verify(targetType).asRawType();
+        verify(targetType).asErasure();
         verifyNoMoreInteractions(targetType);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinderTerminationHandlerReturningTest.java
Patch:
@@ -44,8 +44,8 @@ public class TargetMethodAnnotationDrivenBinderTerminationHandlerReturningTest {
     public void setUp() throws Exception {
         when(source.getReturnType()).thenReturn(sourceType);
         when(target.getReturnType()).thenReturn(targetType);
-        when(sourceType.asRawType()).thenReturn(sourceType);
-        when(targetType.asRawType()).thenReturn(targetType);
+        when(sourceType.asErasure()).thenReturn(sourceType);
+        when(targetType.asErasure()).thenReturn(targetType);
         when(assigner.assign(eq(targetType), eq(sourceType), any(Assigner.Typing.class))).thenReturn(stackManipulation);
         when(target.getDeclaredAnnotations()).thenReturn(annotationList);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ThisBinderTest.java
Patch:
@@ -34,7 +34,7 @@ public void testAnnotationType() throws Exception {
     public void setUp() throws Exception {
         super.setUp();
         when(stackManipulation.isValid()).thenReturn(true);
-        when(parameterType.asRawType()).thenReturn(parameterType);
+        when(parameterType.asErasure()).thenReturn(parameterType);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/MethodConstantTest.java
Patch:
@@ -61,19 +61,19 @@ public class MethodConstantTest {
     @Before
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
-        when(declaringType.asRawType()).thenReturn(declaringType);
+        when(declaringType.asErasure()).thenReturn(declaringType);
         when(methodDescription.getDeclaringType()).thenReturn(declaringType);
         when(methodDescription.getInternalName()).thenReturn(FOO);
         when(methodDescription.getParameters()).thenReturn((ParameterList) parameterList);
         when(parameterList.asTypeList()).thenReturn(typeList);
         when(declaringType.getDescriptor()).thenReturn(BAR);
-        when(typeList.asRawTypes()).thenReturn(rawTypeList);
+        when(typeList.asErasures()).thenReturn(rawTypeList);
         when(rawTypeList.iterator()).thenReturn(Collections.singletonList(parameterType).iterator());
         when(parameterType.getDescriptor()).thenReturn(QUX);
         when(fieldDescription.getType()).thenReturn(fieldType);
         when(fieldDescription.isStatic()).thenReturn(true);
         when(fieldType.getStackSize()).thenReturn(StackSize.SINGLE);
-        when(fieldType.asRawType()).thenReturn(fieldType);
+        when(fieldType.asErasure()).thenReturn(fieldType);
         when(fieldDescription.getDeclaringType()).thenReturn(declaringType);
         when(declaringType.getInternalName()).thenReturn(BAZ);
         when(fieldDescription.getInternalName()).thenReturn(FOO);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/MethodHandleConstantTest.java
Patch:
@@ -48,7 +48,7 @@ public class MethodHandleConstantTest {
 
     @Before
     public void setUp() throws Exception {
-        when(typeDescription.asRawType()).thenReturn(typeDescription);
+        when(typeDescription.asErasure()).thenReturn(typeDescription);
         when(methodDescription.getDeclaringType()).thenReturn(typeDescription);
         when(typeDescription.getInternalName()).thenReturn(FOO);
         when(methodDescription.getInternalName()).thenReturn(BAR);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/FieldAccessTest.java
Patch:
@@ -82,7 +82,7 @@ public static Collection<Object[]> data() {
 
     @Before
     public void setUp() throws Exception {
-        when(declaringType.asRawType()).thenReturn(declaringType);
+        when(declaringType.asErasure()).thenReturn(declaringType);
         when(fieldDescription.getDeclaringType()).thenReturn(declaringType);
         when(fieldDescription.getType()).thenReturn(fieldType);
         when(declaringType.getInternalName()).thenReturn(FOO);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationDynamicTest.java
Patch:
@@ -48,7 +48,7 @@ public class MethodInvocationDynamicTest {
 
     @Before
     public void setUp() throws Exception {
-        when(declaringType.asRawType()).thenReturn(declaringType);
+        when(declaringType.asErasure()).thenReturn(declaringType);
         when(methodDescription.getDeclaringType()).thenReturn(declaringType);
         when(firstType.getStackSize()).thenReturn(StackSize.ZERO);
         when(firstType.getDescriptor()).thenReturn(FOO);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationOtherTest.java
Patch:
@@ -43,7 +43,7 @@ public void testObjectProperties() throws Exception {
             public void apply(MethodDescription mock) {
                 when(mock.asToken()).thenReturn(mock(MethodDescription.Token.class));
                 TypeDescription declaringType = mock(TypeDescription.class);
-                when(declaringType.asRawType()).thenReturn(declaringType);
+                when(declaringType.asErasure()).thenReturn(declaringType);
                 when(mock.getDeclaringType()).thenReturn(declaringType);
             }
         }).apply();

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationTest.java
Patch:
@@ -66,7 +66,7 @@ public static Collection<Object[]> data() {
 
     @Before
     public void setUp() throws Exception {
-        when(declaringType.asRawType()).thenReturn(declaringType);
+        when(declaringType.asErasure()).thenReturn(declaringType);
         when(methodDescription.getReturnType()).thenReturn(returnType);
         when(methodDescription.getDeclaringType()).thenReturn(declaringType);
         when(methodDescription.getStackSize()).thenReturn(ARGUMENT_STACK_SIZE);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccessOfMethodArgumentsTest.java
Patch:
@@ -52,9 +52,9 @@ public void setUp() throws Exception {
         when(declaringType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(firstParameterType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(secondParameterType.getStackSize()).thenReturn(StackSize.SINGLE);
-        when(firstParameterType.asRawType()).thenReturn(firstParameterType);
+        when(firstParameterType.asErasure()).thenReturn(firstParameterType);
         when(firstParameterType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(firstParameterType);
-        when(secondParameterType.asRawType()).thenReturn(secondParameterType);
+        when(secondParameterType.asErasure()).thenReturn(secondParameterType);
         when(secondParameterType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(secondParameterType);
         when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(methodDescription,
                 Arrays.asList(firstParameterType, secondParameterType)));

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/RawTypeMatcherTest.java
Patch:
@@ -28,7 +28,7 @@ public RawTypeMatcherTest() {
 
     @Before
     public void setUp() throws Exception {
-        when(genericTypeDescription.asRawType()).thenReturn(typeDescription);
+        when(genericTypeDescription.asErasure()).thenReturn(typeDescription);
     }
 
     @Test
@@ -37,7 +37,7 @@ public void testMatch() throws Exception {
         when(genericTypeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
         assertThat(new RawTypeMatcher<GenericTypeDescription>(elementMatcher).matches(genericTypeDescription), is(true));
         verify(genericTypeDescription).getSort();
-        verify(genericTypeDescription).asRawType();
+        verify(genericTypeDescription).asErasure();
         verifyNoMoreInteractions(genericTypeDescription);
         verify(elementMatcher).matches(typeDescription);
         verifyNoMoreInteractions(elementMatcher);
@@ -60,7 +60,7 @@ public void testNoMatch() throws Exception {
         when(genericTypeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
         assertThat(new RawTypeMatcher<GenericTypeDescription>(elementMatcher).matches(genericTypeDescription), is(false));
         verify(genericTypeDescription).getSort();
-        verify(genericTypeDescription).asRawType();
+        verify(genericTypeDescription).asErasure();
         verifyNoMoreInteractions(genericTypeDescription);
         verify(elementMatcher).matches(typeDescription);
         verifyNoMoreInteractions(elementMatcher);

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultComponentTypeLocatorTest.java
Patch:
@@ -33,7 +33,7 @@ public void testForAnnotationProperty() throws Exception {
                 .thenReturn(new MethodList.Explicit<MethodDescription.InDefinedShape>(Collections.singletonList(methodDescription)));
         when(methodDescription.getSourceCodeName()).thenReturn(FOO);
         TypeDescription returnType = mock(TypeDescription.class);
-        when(returnType.asRawType()).thenReturn(returnType);
+        when(returnType.asErasure()).thenReturn(returnType);
         when(methodDescription.getReturnType()).thenReturn(returnType);
         TypeDescription componentType = mock(TypeDescription.class);
         when(returnType.getComponentType()).thenReturn(componentType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyTypeListTest.java
Patch:
@@ -36,7 +36,7 @@ protected Class<?> getSecond() throws Exception {
 
     @Override
     protected TypeList asList(List<Class<?>> elements) {
-        return typePool.describe(Holder.class.getName()).resolve().getInterfaces().asRawTypes().filter(anyOf(elements.toArray(new Class<?>[elements.size()])));
+        return typePool.describe(Holder.class.getName()).resolve().getInterfaces().asErasures().filter(anyOf(elements.toArray(new Class<?>[elements.size()])));
     }
 
     @Override

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/ClassByExtensionBenchmark.java
Patch:
@@ -80,7 +80,7 @@ public ExampleClass benchmarkByteBuddyWithAnnotations() throws Exception {
                 .subclass(baseClass)
                 .method(isDeclaredBy(ExampleClass.class)).intercept(MethodDelegation.to(ByteBuddyInterceptor.class))
                 .make()
-                .load(newClassLoader(), ClassLoadingStrategy.Default.INJECTION.withPackageDefiner(PackageDefinitionStrategy.NoOp.INSTANCE))
+                .load(newClassLoader(), ClassLoadingStrategy.Default.INJECTION.withPackageDefinitionStrategy(PackageDefinitionStrategy.NoOp.INSTANCE))
                 .getLoaded()
                 .newInstance();
     }
@@ -99,7 +99,7 @@ public ExampleClass benchmarkByteBuddySpecialized() throws Exception {
                 .subclass(baseClass)
                 .method(isDeclaredBy(ExampleClass.class)).intercept(SuperMethodCall.INSTANCE)
                 .make()
-                .load(newClassLoader(), ClassLoadingStrategy.Default.INJECTION.withPackageDefiner(PackageDefinitionStrategy.NoOp.INSTANCE))
+                .load(newClassLoader(), ClassLoadingStrategy.Default.INJECTION.withPackageDefinitionStrategy(PackageDefinitionStrategy.NoOp.INSTANCE))
                 .getLoaded()
                 .newInstance();
     }

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/ClassByImplementationBenchmark.java
Patch:
@@ -171,7 +171,7 @@ public ExampleInterface benchmarkByteBuddy() throws Exception {
                 .subclass(baseClass)
                 .method(isDeclaredBy(baseClass)).intercept(StubMethod.INSTANCE)
                 .make()
-                .load(newClassLoader(), ClassLoadingStrategy.Default.INJECTION.withPackageDefiner(PackageDefinitionStrategy.NoOp.INSTANCE))
+                .load(newClassLoader(), ClassLoadingStrategy.Default.INJECTION.withPackageDefinitionStrategy(PackageDefinitionStrategy.NoOp.INSTANCE))
                 .getLoaded()
                 .newInstance();
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodRegistry.java
Patch:
@@ -491,7 +491,9 @@ public MethodRegistry.Prepared prepare(InstrumentedType instrumentedType,
                 }
             }
             MethodGraph.Linked methodGraph = methodGraphCompiler.compile(instrumentedType);
-            ElementMatcher<? super MethodDescription> relevanceMatcher = not(anyOf(implementations.keySet())).and(methodFilter.resolve(instrumentedType));
+            // Casting required for Java 6 compiler.
+            ElementMatcher<? super MethodDescription> relevanceMatcher = (ElementMatcher<? super MethodDescription>) not(anyOf(implementations.keySet()))
+                    .and(methodFilter.resolve(instrumentedType));
             for (MethodGraph.Node node : methodGraph.listNodes()) {
                 MethodDescription methodDescription = node.getRepresentative();
                 boolean visibilityBridge = instrumentedType.isPublic() && !instrumentedType.isInterface();

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/AnnotationAppenderDefaultTest.java
Patch:
@@ -146,7 +146,7 @@ private Class<?> makeTypeWithAnnotation(Annotation annotation) throws Exception
     @SuppressWarnings("unchecked")
     public void testSkipValues() throws Exception {
         when(valueFilter.isRelevant(any(AnnotationDescription.class), any(MethodDescription.class))).thenReturn(false);
-        MethodDescription methodDescription = mock(MethodDescription.class);
+        MethodDescription methodDescription = mock(MethodDescription.InDefinedShape.class);
         TypeDescription annotationType = mock(TypeDescription.class);
         when(annotationType.getDeclaredMethods())
                 .thenReturn((MethodList) new MethodList.Explicit<MethodDescription>(Collections.singletonList(methodDescription)));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -2044,7 +2044,7 @@ public void visit(int classFileVersionNumber,
                                     TypeDescription.OBJECT :
                                     instrumentedType.getSuperType().asRawType()).getInternalName(),
                             instrumentedType.getInterfaces().asRawTypes().toInternalNames());
-                    attributeAppender.apply(this, instrumentedType);
+                    attributeAppender.apply(this, instrumentedType, targetType);
                 }
 
                 @Override
@@ -2545,7 +2545,7 @@ public byte[] create(Implementation.Context.ExtractableView implementationContex
                                 ? TypeDescription.OBJECT
                                 : instrumentedType.getSuperType().asRawType()).getInternalName(),
                         instrumentedType.getInterfaces().asRawTypes().toInternalNames());
-                attributeAppender.apply(classVisitor, instrumentedType);
+                attributeAppender.apply(classVisitor, instrumentedType, instrumentedType.getSuperType());
                 for (FieldDescription fieldDescription : instrumentedType.getDeclaredFields()) {
                     fieldPool.target(fieldDescription).apply(classVisitor);
                 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/TypeAttributeAppenderForTypeTest.java
Patch:
@@ -14,10 +14,11 @@ public class TypeAttributeAppenderForTypeTest extends AbstractTypeAttributeAppen
     @Test
     public void testTypeAnnotation() throws Exception {
         TypeAttributeAppender fieldAttributeAppender = new TypeAttributeAppender.ForType(FooBar.class, valueFilter);
-        fieldAttributeAppender.apply(classVisitor, typeDescription);
+        fieldAttributeAppender.apply(classVisitor, typeDescription, targetType);
         verify(classVisitor).visitAnnotation(Type.getDescriptor(Baz.class), true);
         verifyNoMoreInteractions(classVisitor);
         verifyZeroInteractions(typeDescription);
+        verifyZeroInteractions(targetType);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/TypeAttributeAppenderNoOpTest.java
Patch:
@@ -14,9 +14,10 @@ public class TypeAttributeAppenderNoOpTest extends AbstractTypeAttributeAppender
 
     @Test
     public void testNoOp() throws Exception {
-        TypeAttributeAppender.NoOp.INSTANCE.apply(classVisitor, typeDescription);
+        TypeAttributeAppender.NoOp.INSTANCE.apply(classVisitor, typeDescription, targetType);
         verifyZeroInteractions(classVisitor);
         verifyZeroInteractions(typeDescription);
+        verifyZeroInteractions(targetType);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphNodeSimpleTest.java
Patch:
@@ -26,7 +26,7 @@ public void testRepresentative() throws Exception {
 
     @Test
     public void testBridgesEmpty() throws Exception {
-        assertThat(new MethodGraph.Node.Simple(methodDescription).getBridges().size(), is(0));
+        assertThat(new MethodGraph.Node.Simple(methodDescription).getMethodTypes().size(), is(0));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodGraphNodeUnresolvedTest.java
Patch:
@@ -15,7 +15,7 @@ public void testSort() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testBridgesThrowsException() throws Exception {
-        MethodGraph.Node.Unresolved.INSTANCE.getBridges();
+        MethodGraph.Node.Unresolved.INSTANCE.getMethodTypes();
     }
 
     @Test(expected = IllegalStateException.class)

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTarget.java
Patch:
@@ -148,7 +148,7 @@ protected TypeDescription identify(TypeDescription typeDescription) {
 
         @Override
         public String toString() {
-            return "SubclassImplementationTarget.OriginTypeIdentifier." + name();
+            return "SubclassImplementationTarget.OriginTypeResolver." + name();
         }
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTargetTest.java
Patch:
@@ -122,7 +122,6 @@ public void testLevelTypeOrigin() throws Exception {
     }
 
     @Test
-    @SuppressWarnings("unchecked")
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(SubclassImplementationTarget.class).apply();
         ObjectPropertyAssertion.of(SubclassImplementationTarget.OriginTypeResolver.class).apply();

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTarget.java
Patch:
@@ -106,7 +106,7 @@ public int hashCode() {
     public String toString() {
         return "SubclassImplementationTarget{" +
                 "superConstructors=" + superConstructors +
-                ", originTypeIdentifier=" + originTypeResolver +
+                ", originTypeResolver=" + originTypeResolver +
                 ", instrumentedType=" + instrumentedType +
                 ", methodGraph=" + methodGraph +
                 '}';
@@ -190,7 +190,7 @@ public int hashCode() {
         @Override
         public String toString() {
             return "SubclassImplementationTarget.Factory{" +
-                    "originTypeIdentifier=" + originTypeResolver +
+                    "originTypeResolver=" + originTypeResolver +
                     '}';
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -531,7 +531,7 @@ protected Key.Store<T> analyzeNullable(GenericTypeDescription typeDescription,
             }
 
             /**
-             * Analyzes the given type description without checking if it is already presented in the key store
+             * Analyzes the given type description without checking if it is already presented in the key store.
              *
              * @param typeDescription The type to analyze.
              * @param snapshots       A map containing snapshots of key stores for previously analyzed types.
@@ -1003,9 +1003,9 @@ public String toString() {
                 }
 
                 /**
-                 * A store
+                 * A store for collected methods that are identified by keys.
                  *
-                 * @param <V>
+                 * @param <V> The type of the token used for deciding on method equality.
                  */
                 protected static class Store<V> {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -559,7 +559,7 @@ public int hashCode() {
 
                     @Override
                     public String toString() {
-                        return "TypeWriter.MethodPool.Record.ForDeclaredMethod.WithBody{" +
+                        return "TypeWriter.MethodPool.Record.ForDefinedMethod.WithBody{" +
                                 "methodDescription=" + methodDescription +
                                 ", byteCodeAppender=" + byteCodeAppender +
                                 ", methodAttributeAppender=" + methodAttributeAppender +

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/StackManipulation.java
Patch:
@@ -191,7 +191,7 @@ public Compound(StackManipulation... stackManipulation) {
         /**
          * Creates a new compound stack manipulation.
          *
-         * @param stackManipulation The stack manipulations to be composed in the order of their composition.
+         * @param stackManipulations The stack manipulations to be composed in the order of their composition.
          */
         public Compound(List<StackManipulation> stackManipulations) {
             this.stackManipulations = stackManipulations;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationTest.java
Patch:
@@ -59,8 +59,8 @@ public MethodInvocationTest(StackSize stackSize) {
     public static Collection<Object[]> data() {
         return Arrays.asList(new Object[][]{
                 {StackSize.ZERO},
-//                {StackSize.SINGLE},
-//                {StackSize.DOUBLE}
+                {StackSize.SINGLE},
+                {StackSize.DOUBLE}
         });
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodRegistry.java
Patch:
@@ -509,6 +509,7 @@ public MethodRegistry.Prepared prepare(InstrumentedType instrumentedType,
                 }
                 if (visibilityBridge
                         && methodDescription.isPublic()
+                        && !(methodDescription.isAbstract() || methodDescription.isFinal())
                         && !node.getVisibility().isVisible()
                         && methodDescription.getDeclaringType().asRawType().isPackagePrivate()) {
                     // Visibility bridges are required for public types that inherit a public method from a package-private type.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccess.java
Patch:
@@ -227,7 +227,7 @@ public StackManipulation prependThisReference() {
                     : new Compound(MethodVariableAccess.REFERENCE.loadOffset(0), this);
         }
 
-        public StackManipulation asBridgeOf(MethodDescription methodDescription) {
+        public MethodLoading asBridgeOf(MethodDescription methodDescription) {
             return new MethodLoading(this.methodDescription, new TypeCastingHandler.ForBridgeTarget(methodDescription));
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodRegistryDefaultTest.java
Patch:
@@ -94,6 +94,7 @@ public void setUp() throws Exception {
         when(implementationTargetFactory.make(typeDescription, methodGraph)).thenReturn(implementationTarget);
         when(firstCompiledHandler.assemble(firstAppender, instrumentedMethod)).thenReturn(firstRecord);
         when(secondCompiledHandler.assemble(secondAppender, instrumentedMethod)).thenReturn(secondRecord);
+        when(typeDescription.asRawType()).thenReturn(typeDescription);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodRegistryDefaultTest.java
Patch:
@@ -304,8 +304,7 @@ public void testVisibilityBridgeIfNotMatchedAndVisible() throws Exception {
         when(typeDescription.isPublic()).thenReturn(true);
         when(instrumentedMethod.isPublic()).thenReturn(true);
         when(declaringType.isPublic()).thenReturn(false);
-        assertThat(methodRegistry.target(instrumentedMethod),
-                is((TypeWriter.MethodPool.Record) new TypeWriter.MethodPool.Record.ForDeclaredMethod.OfVisibilityBridge(instrumentedMethod)));
+        // TODO: change test
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/SuperMethodCallOtherTest.java
Patch:
@@ -90,7 +90,7 @@ public void testConstructor() throws Exception {
         when(methodDescription.isConstructor()).thenReturn(true);
         when(superType.getDeclaredMethods()).thenReturn(superTypeMethods);
         when(superTypeMethods.filter(any(ElementMatcher.class))).thenReturn(superTypeMethods);
-        when(implementationTarget.invokeSuper(methodToken)).thenReturn(Implementation.SpecialMethodInvocation.Illegal.INSTANCE);
+        when(implementationTarget.invokeDominant(methodToken)).thenReturn(Implementation.SpecialMethodInvocation.Illegal.INSTANCE);
         SuperMethodCall.INSTANCE.appender(implementationTarget).apply(methodVisitor, implementationContext, methodDescription);
     }
 
@@ -104,7 +104,7 @@ public void testStaticMethod() throws Exception {
         when(returnType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(superType.getDeclaredMethods()).thenReturn(superTypeMethods);
         when(superTypeMethods.filter(any(ElementMatcher.class))).thenReturn(superTypeMethods);
-        when(implementationTarget.invokeSuper(methodToken)).thenReturn(Implementation.SpecialMethodInvocation.Illegal.INSTANCE);
+        when(implementationTarget.invokeDominant(methodToken)).thenReturn(Implementation.SpecialMethodInvocation.Illegal.INSTANCE);
         SuperMethodCall.INSTANCE.appender(implementationTarget).apply(methodVisitor, implementationContext, methodDescription);
     }
 
@@ -119,7 +119,7 @@ public void testNoSuper() throws Exception {
         when(returnType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(superType.getDeclaredMethods()).thenReturn(superTypeMethods);
         when(superTypeMethods.filter(any(ElementMatcher.class))).thenReturn(superTypeMethods);
-        when(implementationTarget.invokeSuper(methodToken)).thenReturn(Implementation.SpecialMethodInvocation.Illegal.INSTANCE);
+        when(implementationTarget.invokeDominant(methodToken)).thenReturn(Implementation.SpecialMethodInvocation.Illegal.INSTANCE);
         SuperMethodCall.INSTANCE.appender(implementationTarget).apply(methodVisitor, implementationContext, methodDescription);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -836,7 +836,7 @@ public int hashCode() {
 
                             @Override
                             public String toString() {
-                                return "MethodGraph.Compiler.Default.Key.Store.Entry.ForMethod{" +
+                                return "MethodGraph.Compiler.Default.Key.Store.Entry.Resolved{" +
                                         "key=" + key +
                                         ", methodDescription=" + methodDescription +
                                         ", madeVisible=" + madeVisible +
@@ -897,7 +897,7 @@ public int hashCode() {
 
                                 @Override
                                 public String toString() {
-                                    return "MethodGraph.Compiler.Default.Key.Store.Entry.ForMethod.Node{" +
+                                    return "MethodGraph.Compiler.Default.Key.Store.Entry.Resolved.Node{" +
                                             "key=" + key +
                                             ", methodDescription=" + methodDescription +
                                             ", madeVisible=" + madeVisible +

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/SuperMethodCall.java
Patch:
@@ -107,9 +107,7 @@ protected Appender(Target implementationTarget, TerminationHandler terminationHa
         }
 
         @Override
-        public Size apply(MethodVisitor methodVisitor,
-                          Implementation.Context implementationContext,
-                          MethodDescription instrumentedMethod) {
+        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
             StackManipulation superMethodCall = instrumentedMethod.isDefaultMethod()
                     && implementationTarget.getTypeDescription().getInterfaces().asRawTypes().contains(instrumentedMethod.getDeclaringType().asRawType())
                     ? implementationTarget.invokeDefault(instrumentedMethod.getDeclaringType().asRawType(), instrumentedMethod.asToken())

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodGraph.java
Patch:
@@ -614,7 +614,7 @@ private static <W> Entry<W> combine(Entry<W> left, Entry<W> right, Merger merger
                         TypeDescription leftType = leftMethod.getDeclaringType().asRawType(), rightType = rightMethod.getDeclaringType().asRawType();
                         if (leftType.isAssignableTo(rightType)) {
                             return left;
-                        } else if (leftType.isAssignableTo(rightType)) {
+                        } else if (rightType.isAssignableTo(leftType)) {
                             return right;
                         } else {
                             return Entry.Ambiguous.of(left.getKey().combineWith(right.getKey()), leftMethod, rightMethod, merger);

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -380,7 +380,7 @@ public boolean isDefaultMethod() {
         public boolean isSpecializableFor(TypeDescription targetType) {
             if (isStatic()) { // Static private methods are never specializable, check static property first
                 return false;
-            } else if (isPrivate() || isConstructor()) {
+            } else if (isPrivate() || isConstructor() || isDefaultMethod()) {
                 return getDeclaringType().equals(targetType);
             } else {
                 return !isAbstract() && getDeclaringType().asRawType().isAssignableFrom(targetType);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodInvocation.java
Patch:
@@ -76,7 +76,7 @@ public static WithImplicitInvocationTargetType invoke(MethodDescription.InDefine
             return STATIC.new Invocation(methodDescription);
         } else if (methodDescription.isConstructor()) {
             return SPECIAL_CONSTRUCTOR.new Invocation(methodDescription); // Check this property second, constructors might be private
-        } else if (methodDescription.isPrivate() || methodDescription.isDefaultMethod()) {
+        } else if (methodDescription.isPrivate()) {
             return SPECIAL.new Invocation(methodDescription);
         } else if (methodDescription.getDeclaringType().asRawType().isInterface()) { // Check this property last, default methods must be called by INVOKESPECIAL
             return INTERFACE.new Invocation(methodDescription);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/MethodDelegationBinder.java
Patch:
@@ -921,7 +921,7 @@ private MethodBinding resolve(MethodDescription source,
                             return right;
                         case AMBIGUOUS:
                         case UNKNOWN:
-                            throw new IllegalArgumentException("Could not resolve ambiguous delegation of " + source + " to either " + left + " or " + right);
+                            throw new IllegalArgumentException("Cannot resolve ambiguous delegation of " + source + " to " + left + " or " + right);
                         default:
                             throw new AssertionError();
                     }
@@ -947,7 +947,7 @@ private MethodBinding resolve(MethodDescription source,
                                 case LEFT:
                                 case AMBIGUOUS:
                                 case UNKNOWN:
-                                    throw new IllegalArgumentException("Could not resolve ambiguous delegation to either " + left + " or " + right);
+                                    throw new IllegalArgumentException("Cannot resolve ambiguous delegation of " + source + " to " + left + " or " + right);
                                 default:
                                     throw new AssertionError();
                             }

File: byte-buddy-dep/src/test/java/net/bytebuddy/ClassFileVersionKnownVersionsTest.java
Patch:
@@ -34,6 +34,7 @@ public static Collection<Object[]> data() {
                 {6, Opcodes.V1_6},
                 {7, Opcodes.V1_7},
                 {8, Opcodes.V1_8},
+                {9, Opcodes.V1_8}
         });
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/ElementMatchersTest.java
Patch:
@@ -697,7 +697,7 @@ public void testSortIsTypeBridge() throws Exception {
         assertThat(ElementMatchers.isTypeBridge().matches(new TypeDescription.ForLoadedType(TypeVariableReturnTypeOverrideBridge.Inner.class)
                 .getDeclaredMethods().filter(named(FOO).and(ElementMatchers.returns(Number.class))).getOnly()), is(true));
         assertThat(ElementMatchers.isTypeBridge().matches(new TypeDescription.ForLoadedType(TypeVariableReturnTypeCombinationBridge.Inner.class)
-                .getDeclaredMethods().filter(named(FOO).and(ElementMatchers.returns(Number.class))).getOnly()), is(true));
+                .getDeclaredMethods().filter(named(FOO).and(ElementMatchers.returns(Object.class))).getOnly()), is(true));
         assertThat(ElementMatchers.isTypeBridge().matches(new TypeDescription.ForLoadedType(TypeVariableReturnTypeSpecializationBridge.Inner.class)
                 .getDeclaredMethods().filter(named(FOO).and(ElementMatchers.returns(Object.class))).getOnly()), is(true));
         assertThat(ElementMatchers.isTypeBridge()
@@ -737,7 +737,7 @@ public void testSortIsVisibilityBridge() throws Exception {
         assertThat(ElementMatchers.isVisibilityBridge().matches(new TypeDescription.ForLoadedType(TypeVariableReturnTypeOverrideBridge.Inner.class)
                 .getDeclaredMethods().filter(named(FOO).and(ElementMatchers.returns(Number.class))).getOnly()), is(false));
         assertThat(ElementMatchers.isVisibilityBridge().matches(new TypeDescription.ForLoadedType(TypeVariableReturnTypeCombinationBridge.Inner.class)
-                .getDeclaredMethods().filter(named(FOO).and(ElementMatchers.returns(Number.class))).getOnly()), is(false));
+                .getDeclaredMethods().filter(named(FOO).and(ElementMatchers.returns(Object.class))).getOnly()), is(false));
         assertThat(ElementMatchers.isVisibilityBridge().matches(new TypeDescription.ForLoadedType(TypeVariableReturnTypeSpecializationBridge.Inner.class)
                 .getDeclaredMethods().filter(named(FOO).and(ElementMatchers.returns(Object.class))).getOnly()), is(false));
         assertThat(ElementMatchers.isVisibilityBridge()
@@ -790,7 +790,7 @@ public void testSortIsBridge() throws Exception {
         assertThat(ElementMatchers.isBridge().matches(new TypeDescription.ForLoadedType(TypeVariableReturnTypeOverrideBridge.Inner.class)
                 .getDeclaredMethods().filter(named(FOO).and(ElementMatchers.returns(Object.class))).getOnly()), is(true));
         assertThat(ElementMatchers.isBridge().matches(new TypeDescription.ForLoadedType(TypeVariableReturnTypeCombinationBridge.Inner.class)
-                .getDeclaredMethods().filter(named(FOO).and(ElementMatchers.returns(Number.class))).getOnly()), is(true));
+                .getDeclaredMethods().filter(named(FOO).and(ElementMatchers.returns(Object.class))).getOnly()), is(true));
         assertThat(ElementMatchers.isBridge().matches(new TypeDescription.ForLoadedType(TypeVariableReturnTypeSpecializationBridge.Inner.class)
                 .getDeclaredMethods().filter(named(FOO).and(ElementMatchers.returns(Object.class))).getOnly()), is(true));
         assertThat(ElementMatchers.isBridge()

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Super.java
Patch:
@@ -194,7 +194,7 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<Super>
          */
         static {
             MethodList<?> annotationProperties = new TypeDescription.ForLoadedType(Super.class).getDeclaredMethods();
-            STRATEGY = annotationProperties.filter(returns(Instantiation.class)).getOnly();
+            STRATEGY = annotationProperties.filter(named("strategy")).getOnly();
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldList.java
Patch:
@@ -33,7 +33,7 @@ public interface FieldList<T extends FieldDescription> extends FilterableList<T,
      * @param targetTypeMatcher A matcher that indicates type substitution.
      * @return The transformed token list.
      */
-    ByteCodeElement.Token.TokenList<FieldDescription.Token> asTokenList(ElementMatcher<? super TypeDescription> targetTypeMatcher);
+    ByteCodeElement.Token.TokenList<FieldDescription.Token> asTokenList(ElementMatcher<? super GenericTypeDescription> targetTypeMatcher);
 
     FieldList<FieldDescription.InDefinedShape> asDefined();
 
@@ -48,7 +48,7 @@ public ByteCodeElement.Token.TokenList<FieldDescription.Token> asTokenList() {
         }
 
         @Override
-        public ByteCodeElement.Token.TokenList<FieldDescription.Token> asTokenList(ElementMatcher<? super TypeDescription> targetTypeMatcher) {
+        public ByteCodeElement.Token.TokenList<FieldDescription.Token> asTokenList(ElementMatcher<? super GenericTypeDescription> targetTypeMatcher) {
             List<FieldDescription.Token> tokens = new ArrayList<FieldDescription.Token>(size());
             for (FieldDescription fieldDescription : this) {
                 tokens.add(fieldDescription.asToken(targetTypeMatcher));
@@ -235,7 +235,7 @@ public ByteCodeElement.Token.TokenList<FieldDescription.Token> asTokenList() {
         }
 
         @Override
-        public ByteCodeElement.Token.TokenList<FieldDescription.Token> asTokenList(ElementMatcher<? super TypeDescription> targetTypeMatcher) {
+        public ByteCodeElement.Token.TokenList<FieldDescription.Token> asTokenList(ElementMatcher<? super GenericTypeDescription> targetTypeMatcher) {
             return new ByteCodeElement.Token.TokenList<FieldDescription.Token>(Collections.<FieldDescription.Token>emptyList());
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodList.java
Patch:
@@ -34,7 +34,7 @@ public interface MethodList<T extends MethodDescription> extends FilterableList<
      * @param targetTypeMatcher A matcher that indicates type substitution.
      * @return The transformed token list.
      */
-    ByteCodeElement.Token.TokenList<MethodDescription.Token> asTokenList(ElementMatcher<? super TypeDescription> targetTypeMatcher);
+    ByteCodeElement.Token.TokenList<MethodDescription.Token> asTokenList(ElementMatcher<? super GenericTypeDescription> targetTypeMatcher);
 
     MethodList<MethodDescription.InDefinedShape> asDefined();
 
@@ -54,7 +54,7 @@ public ByteCodeElement.Token.TokenList<MethodDescription.Token> asTokenList() {
         }
 
         @Override
-        public ByteCodeElement.Token.TokenList<MethodDescription.Token> asTokenList(ElementMatcher<? super TypeDescription> targetTypeMatcher) {
+        public ByteCodeElement.Token.TokenList<MethodDescription.Token> asTokenList(ElementMatcher<? super GenericTypeDescription> targetTypeMatcher) {
             List<MethodDescription.Token> tokens = new ArrayList<MethodDescription.Token>(size());
             for (MethodDescription fieldDescription : this) {
                 tokens.add(fieldDescription.asToken(targetTypeMatcher));
@@ -259,7 +259,7 @@ public ByteCodeElement.Token.TokenList<MethodDescription.Token> asTokenList() {
         }
 
         @Override
-        public ByteCodeElement.Token.TokenList<MethodDescription.Token> asTokenList(ElementMatcher<? super TypeDescription> targetTypeMatcher) {
+        public ByteCodeElement.Token.TokenList<MethodDescription.Token> asTokenList(ElementMatcher<? super GenericTypeDescription> targetTypeMatcher) {
             return new ByteCodeElement.Token.TokenList<MethodDescription.Token>(Collections.<MethodDescription.Token>emptyList());
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -3,7 +3,6 @@
 import net.bytebuddy.description.ByteCodeElement;
 import net.bytebuddy.description.ModifierReviewable;
 import net.bytebuddy.description.NamedElement;
-import net.bytebuddy.description.TypeDefinable;
 import net.bytebuddy.description.annotation.AnnotatedCodeElement;
 import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.annotation.AnnotationList;

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -3,6 +3,7 @@
 import net.bytebuddy.description.ByteCodeElement;
 import net.bytebuddy.description.ModifierReviewable;
 import net.bytebuddy.description.NamedElement;
+import net.bytebuddy.description.TypeDefinable;
 import net.bytebuddy.description.annotation.AnnotatedCodeElement;
 import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.annotation.AnnotationList;
@@ -76,7 +77,7 @@ public static <T extends FieldDescription> ElementMatcher.Junction<T> is(Field f
      * @param <T>              The type of the matched object.
      * @return An element matcher that matches the given field description.
      */
-    public static <T extends FieldDescription> ElementMatcher.Junction<T> is(FieldDescription fieldDescription) {
+    public static <T extends FieldDescription.InDefinedShape> ElementMatcher.Junction<T> is(FieldDescription fieldDescription) {
         return new EqualityMatcher<T>(nonNull(fieldDescription));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/NamingStrategyTest.java
Patch:
@@ -37,7 +37,6 @@ public class NamingStrategyTest {
     @Before
     public void setUp() throws Exception {
         when(genericSuperType.asRawType()).thenReturn(rawSuperType);
-
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -507,7 +507,7 @@ public FieldList<FieldDescription.InDefinedShape> getDeclaredFields() {
         }
 
         @Override
-        public MethodList<MethodDescription.inDefinedShape> getDeclaredMethods() {
+        public MethodList<MethodDescription.InDefinedShape> getDeclaredMethods() {
             return new MethodList.ForTokens(this, methodTokens);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodLookupEngine.java
Patch:
@@ -787,7 +787,7 @@ public Object getDefaultValue() {
         }
 
         @Override
-        public inDefinedShape asDefined() {
+        public InDefinedShape asDefined() {
             return methodChain.get(MOST_SPECIFIC).asDefined();
         }
     }
@@ -796,7 +796,7 @@ public inDefinedShape asDefined() {
      * This {@link MethodDescription} represents methods that are defined
      * ambiguously on several interfaces of a common type.
      */
-    class ConflictingInterfaceMethod extends MethodDescription.inDefinedShape.AbstractBase {
+    class ConflictingInterfaceMethod extends MethodDescription.InDefinedShape.AbstractBase {
 
         /**
          * An index that is guaranteed to exist but that expresses the fact that any method that is represented

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodHandleConstant.java
Patch:
@@ -42,7 +42,7 @@ private MethodHandleConstant(Handle handle) {
      * @param methodDescription The method for which a method handle is to be put onto the operand stack.
      * @return A stack manipulation that represents the loading of the handle.
      */
-    public static StackManipulation of(MethodDescription.inDefinedShape methodDescription) {
+    public static StackManipulation of(MethodDescription.InDefinedShape methodDescription) {
         return methodDescription.isTypeInitializer()
                 ? Illegal.INSTANCE
                 : new MethodHandleConstant(new Handle(tagFor(methodDescription),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodTypeConstant.java
Patch:
@@ -39,7 +39,7 @@ protected MethodTypeConstant(Type methodType) {
      * @param methodDescription The method of which the method type should be loaded onto the operand stack.
      * @return A stack manipulation that loads the method type of the given method onto the operand stack.
      */
-    public static StackManipulation of(MethodDescription.inDefinedShape methodDescription) {
+    public static StackManipulation of(MethodDescription.InDefinedShape methodDescription) {
         return new MethodTypeConstant(Type.getMethodType(methodDescription.getDescriptor()));
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodInvocation.java
Patch:
@@ -69,7 +69,7 @@ public enum MethodInvocation {
      * @param methodDescription The method to be invoked.
      * @return A stack manipulation with implicitly determined invocation type.
      */
-    public static WithImplicitInvocationTargetType invoke(MethodDescription.inDefinedShape methodDescription) {
+    public static WithImplicitInvocationTargetType invoke(MethodDescription.InDefinedShape methodDescription) {
         if (methodDescription.isTypeInitializer()) {
             return IllegalInvocation.INSTANCE;
         } else if (methodDescription.isStatic()) { // Check this property first, private static methods must use INVOKESTATIC
@@ -86,7 +86,7 @@ public static WithImplicitInvocationTargetType invoke(MethodDescription.inDefine
     }
 
     public static WithImplicitInvocationTargetType invoke(MethodDescription methodDescription) {
-        MethodDescription.inDefinedShape declaredMethod = methodDescription.asDefined();
+        MethodDescription.InDefinedShape declaredMethod = methodDescription.asDefined();
         return declaredMethod.getReturnType().asRawType().equals(methodDescription.getReturnType().asRawType())
                 ? invoke(declaredMethod)
                 : OfGenericMethod.of(methodDescription, invoke(declaredMethod));

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodSortMatcher.java
Patch:
@@ -112,7 +112,7 @@ protected boolean isSort(MethodDescription target) {
                     if (target.getDeclaringType().asRawType().isInterface()) {
                         return true;
                     }
-                    if (!target.getDeclaringType().getDeclaredMethods().filter(not(is(target))
+                    if (!target.getDeclaringType().getDeclaredMethods().filter(not(isBridge())
                             .and(hasMethodName(target.getInternalName()))
                             .and(takesArguments(target.getParameters().asTypeList().asRawTypes()))).isEmpty()) {
                         return true;

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionForLoadedTest.java
Patch:
@@ -11,12 +11,12 @@
 public class MethodDescriptionForLoadedTest extends AbstractMethodDescriptionTest {
 
     @Override
-    protected MethodDescription.inDefinedShape describe(Method method) {
+    protected MethodDescription.InDefinedShape describe(Method method) {
         return new MethodDescription.ForLoadedMethod(method);
     }
 
     @Override
-    protected MethodDescription.inDefinedShape describe(Constructor<?> constructor) {
+    protected MethodDescription.InDefinedShape describe(Constructor<?> constructor) {
         return new MethodDescription.ForLoadedConstructor(constructor);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTest.java
Patch:
@@ -17,13 +17,13 @@
 public class MethodDescriptionLatentTest extends AbstractMethodDescriptionTest {
 
     @Override
-    protected MethodDescription.inDefinedShape describe(Method method) {
+    protected MethodDescription.InDefinedShape describe(Method method) {
         return new MethodDescription.Latent(new TypeDescription.ForLoadedType(method.getDeclaringClass()),
                 new MethodDescription.ForLoadedMethod(method).asToken(ElementMatchers.is(method.getDeclaringClass())));
     }
 
     @Override
-    protected MethodDescription.inDefinedShape describe(Constructor<?> constructor) {
+    protected MethodDescription.InDefinedShape describe(Constructor<?> constructor) {
         return new MethodDescription.Latent(new TypeDescription.ForLoadedType(constructor.getDeclaringClass()),
                 new MethodDescription.ForLoadedConstructor(constructor).asToken(ElementMatchers.is(constructor.getDeclaringClass())));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTypeInitializerTest.java
Patch:
@@ -20,7 +20,7 @@ public class MethodDescriptionLatentTypeInitializerTest {
     @Mock
     private TypeDescription typeDescription;
 
-    private MethodDescription.inDefinedShape typeInitializer;
+    private MethodDescription.InDefinedShape typeInitializer;
 
     @Before
     public void setUp() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodListForLoadedTypeTest.java
Patch:
@@ -4,7 +4,7 @@
 import java.lang.reflect.Method;
 import java.util.List;
 
-public class MethodListForLoadedTypeTest extends AbstractMethodListTest<Method, MethodDescription.inDefinedShape> {
+public class MethodListForLoadedTypeTest extends AbstractMethodListTest<Method, MethodDescription.InDefinedShape> {
 
     @Override
     protected Method getFirst() throws Exception {
@@ -17,12 +17,12 @@ protected Method getSecond() throws Exception {
     }
 
     @Override
-    protected MethodList<MethodDescription.inDefinedShape> asList(List<Method> elements) {
+    protected MethodList<MethodDescription.InDefinedShape> asList(List<Method> elements) {
         return new MethodList.ForLoadedType(new Constructor<?>[0], elements.toArray(new Method[elements.size()]));
     }
 
     @Override
-    protected MethodDescription.inDefinedShape asElement(Method element) {
+    protected MethodDescription.InDefinedShape asElement(Method element) {
         return new MethodDescription.ForLoadedMethod(element);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverDisabledTest.java
Patch:
@@ -18,7 +18,7 @@ public class MethodRebaseResolverDisabledTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription.inDefinedShape methodDescription;
+    private MethodDescription.InDefinedShape methodDescription;
 
     @Test
     public void testResolutionPreservesMethod() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverEnabledTest.java
Patch:
@@ -35,7 +35,7 @@ public class MethodRebaseResolverEnabledTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription.inDefinedShape method, constructor, other;
+    private MethodDescription.InDefinedShape method, constructor, other;
 
     @Mock
     private TypeDescription placeholderType, returnType, parameterType, declaringType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverMethodsOnlyTest.java
Patch:
@@ -32,7 +32,7 @@ public class MethodRebaseResolverMethodsOnlyTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription.inDefinedShape method, constructor, other;
+    private MethodDescription.InDefinedShape method, constructor, other;
 
     @Mock
     private TypeDescription returnType, parameterType, declaringType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedConstructorTest.java
Patch:
@@ -33,7 +33,7 @@ public class MethodRebaseResolverResolutionForRebasedConstructorTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription.inDefinedShape methodDescription;
+    private MethodDescription.InDefinedShape methodDescription;
 
     @Mock
     private StackManipulation stackManipulation;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedMethodTest.java
Patch:
@@ -31,7 +31,7 @@ public class MethodRebaseResolverResolutionForRebasedMethodTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription.inDefinedShape methodDescription;
+    private MethodDescription.InDefinedShape methodDescription;
 
     @Mock
     private MethodRebaseResolver.MethodNameTransformer methodNameTransformer, otherMethodNameTransformer;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionPreservedTest.java
Patch:
@@ -18,7 +18,7 @@ public class MethodRebaseResolverResolutionPreservedTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription.inDefinedShape methodDescription;
+    private MethodDescription.InDefinedShape methodDescription;
 
     @Test
     public void testPreservation() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTargetTest.java
Patch:
@@ -31,7 +31,7 @@ public class RebaseImplementationTargetTest extends AbstractImplementationTarget
     private MethodRebaseResolver methodRebaseResolver;
 
     @Mock
-    private MethodDescription.inDefinedShape rebasedMethod;
+    private MethodDescription.InDefinedShape rebasedMethod;
 
     @Mock
     private TypeDescription superType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTargetTest.java
Patch:
@@ -31,7 +31,7 @@ public class SubclassImplementationTargetTest extends AbstractImplementationTarg
     private TypeDescription superType;
 
     @Mock
-    private MethodDescription.inDefinedShape superTypeConstructor;
+    private MethodDescription.InDefinedShape superTypeConstructor;
 
     @Mock
     private MethodDescription.Token superConstructorToken;
@@ -43,7 +43,7 @@ public void setUp() throws Exception {
         when(superType.asRawType()).thenReturn(superType);
         when(superType.getInternalName()).thenReturn(BAR);
         when(superType.getDeclaredMethods())
-                .thenReturn(new MethodList.Explicit<MethodDescription.inDefinedShape>(Collections.singletonList(superTypeConstructor)));
+                .thenReturn(new MethodList.Explicit<MethodDescription.InDefinedShape>(Collections.singletonList(superTypeConstructor)));
         when(superTypeConstructor.asToken()).thenReturn(superConstructorToken);
         when(superTypeConstructor.getInternalName()).thenReturn(QUX);
         when(superTypeConstructor.getDescriptor()).thenReturn(BAZ);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/AbstractImplementationTargetTest.java
Patch:
@@ -42,7 +42,7 @@ public abstract class AbstractImplementationTargetTest {
     protected BridgeMethodResolver bridgeMethodResolver;
 
     @Mock
-    protected MethodDescription.inDefinedShape invokableMethod, defaultMethod;
+    protected MethodDescription.InDefinedShape invokableMethod, defaultMethod;
 
     protected Implementation.Target implementationTarget;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/AbstractMethodCallProxyTest.java
Patch:
@@ -35,7 +35,7 @@ public class AbstractMethodCallProxyTest {
     private AuxiliaryType.MethodAccessorFactory methodAccessorFactory;
 
     protected Class<?> proxyOnlyDeclaredMethodOf(Class<?> proxyTarget) throws Exception {
-        MethodDescription.inDefinedShape proxyMethod = new TypeDescription.ForLoadedType(proxyTarget)
+        MethodDescription.InDefinedShape proxyMethod = new TypeDescription.ForLoadedType(proxyTarget)
                 .getDeclaredMethods().filter(not(isConstructor())).getOnly();
         when(methodAccessorFactory.registerAccessorFor(eq(specialMethodInvocation))).thenReturn(proxyMethod);
         String auxiliaryTypeName = getClass().getName() + "$" + proxyTarget.getSimpleName() + "$Proxy";

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TypeProxyCreationTest.java
Patch:
@@ -55,7 +55,7 @@ public class TypeProxyCreationTest {
     private Implementation.SpecialMethodInvocation specialMethodInvocation;
 
     @Mock
-    private MethodDescription.inDefinedShape proxyMethod;
+    private MethodDescription.InDefinedShape proxyMethod;
 
     private TypeDescription foo;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/AbstractAnnotationBinderTest.java
Patch:
@@ -39,7 +39,7 @@ public abstract class AbstractAnnotationBinderTest<T extends Annotation> {
     protected T annotation;
 
     @Mock
-    protected MethodDescription.inDefinedShape source;
+    protected MethodDescription.InDefinedShape source;
 
     @Mock
     protected ParameterDescription target;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ArgumentNextUnboundAsDefaultBinderTest.java
Patch:
@@ -32,7 +32,7 @@ public class ArgumentNextUnboundAsDefaultBinderTest {
     private Implementation.Target implementationTarget;
 
     @Mock
-    private MethodDescription.inDefinedShape source, target;
+    private MethodDescription.InDefinedShape source, target;
 
     @Mock
     private TypeDescription firstParameter, secondParameter;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/OriginBinderTest.java
Patch:
@@ -29,7 +29,7 @@ public class OriginBinderTest extends AbstractAnnotationBinderTest<Origin> {
     private TypeDescription targetType;
 
     @Mock
-    private MethodDescription.inDefinedShape methodDescription;
+    private MethodDescription.InDefinedShape methodDescription;
 
     public OriginBinderTest() {
         super(Origin.class);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/MethodConstantTest.java
Patch:
@@ -35,7 +35,7 @@ public class MethodConstantTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription.inDefinedShape methodDescription;
+    private MethodDescription.InDefinedShape methodDescription;
 
     @Mock
     private TypeDescription declaringType, parameterType, fieldType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/MethodHandleConstantTest.java
Patch:
@@ -32,7 +32,7 @@ public class MethodHandleConstantTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription.inDefinedShape methodDescription;
+    private MethodDescription.InDefinedShape methodDescription;
 
     @Mock
     private FieldDescription fieldDescription;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/MethodTypeConstantTest.java
Patch:
@@ -28,7 +28,7 @@ public class MethodTypeConstantTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription.inDefinedShape methodDescription;
+    private MethodDescription.InDefinedShape methodDescription;
 
     @Mock
     private MethodVisitor methodVisitor;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationDynamicTest.java
Patch:
@@ -32,7 +32,7 @@ public class MethodInvocationDynamicTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription.inDefinedShape methodDescription;
+    private MethodDescription.InDefinedShape methodDescription;
 
     @Mock
     private TypeDescription returnType, declaringType, firstType, secondType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationGenericTest.java
Patch:
@@ -28,7 +28,7 @@ public class MethodInvocationGenericTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription.inDefinedShape declaredMethod;
+    private MethodDescription.InDefinedShape declaredMethod;
 
     @Mock
     private MethodDescription methodDescription;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationTest.java
Patch:
@@ -39,7 +39,7 @@ public class MethodInvocationTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription.inDefinedShape methodDescription;
+    private MethodDescription.InDefinedShape methodDescription;
 
     @Mock
     private TypeDescription returnType, declaringType, otherType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccessOfMethodArgumentsTest.java
Patch:
@@ -34,7 +34,7 @@ public class MethodVariableAccessOfMethodArgumentsTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription.inDefinedShape methodDescription, bridgeMethod;
+    private MethodDescription.InDefinedShape methodDescription, bridgeMethod;
 
     @Mock
     private TypeDescription declaringType, firstParameterType, secondParameterType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultComponentTypeLocatorTest.java
Patch:
@@ -28,9 +28,9 @@ public void testForAnnotationProperty() throws Exception {
         TypePool typePool = mock(TypePool.class);
         TypeDescription typeDescription = mock(TypeDescription.class);
         when(typePool.describe(BAR)).thenReturn(new TypePool.Resolution.Simple(typeDescription));
-        MethodDescription.inDefinedShape methodDescription = mock(MethodDescription.inDefinedShape.class);
+        MethodDescription.InDefinedShape methodDescription = mock(MethodDescription.InDefinedShape.class);
         when(typeDescription.getDeclaredMethods())
-                .thenReturn(new MethodList.Explicit<MethodDescription.inDefinedShape>(Collections.singletonList(methodDescription)));
+                .thenReturn(new MethodList.Explicit<MethodDescription.InDefinedShape>(Collections.singletonList(methodDescription)));
         when(methodDescription.getSourceCodeName()).thenReturn(FOO);
         TypeDescription returnType = mock(TypeDescription.class);
         when(returnType.asRawType()).thenReturn(returnType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultMethodDescriptionTest.java
Patch:
@@ -26,14 +26,14 @@ public void tearDown() throws Exception {
     }
 
     @Override
-    protected MethodDescription.inDefinedShape describe(Method method) {
+    protected MethodDescription.InDefinedShape describe(Method method) {
         return typePool.describe(method.getDeclaringClass().getName())
                 .resolve()
                 .getDeclaredMethods().filter(is(method)).getOnly();
     }
 
     @Override
-    protected MethodDescription.inDefinedShape describe(Constructor<?> constructor) {
+    protected MethodDescription.InDefinedShape describe(Constructor<?> constructor) {
         return typePool.describe(constructor.getDeclaringClass().getName())
                 .resolve()
                 .getDeclaredMethods().filter(is(constructor)).getOnly();

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyMethodListTest.java
Patch:
@@ -14,7 +14,7 @@
 import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.mock;
 
-public class TypePoolLazyMethodListTest extends AbstractMethodListTest<Method, MethodDescription.inDefinedShape> {
+public class TypePoolLazyMethodListTest extends AbstractMethodListTest<Method, MethodDescription.InDefinedShape> {
 
     private TypePool typePool;
 
@@ -39,12 +39,12 @@ protected Method getSecond() throws Exception {
     }
 
     @Override
-    protected MethodList<MethodDescription.inDefinedShape> asList(List<Method> elements) {
+    protected MethodList<MethodDescription.InDefinedShape> asList(List<Method> elements) {
         return typePool.describe(Foo.class.getName()).resolve().getDeclaredMethods().filter(anyOf(elements.toArray(new Method[elements.size()])));
     }
 
     @Override
-    protected MethodDescription.inDefinedShape asElement(Method element) {
+    protected MethodDescription.InDefinedShape asElement(Method element) {
         return new MethodDescription.ForLoadedMethod(element);
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -5,6 +5,7 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.modifier.ModifierContributor;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.TargetType;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
@@ -270,13 +271,12 @@ public ForInstrumentedTypeHierarchy(TypeDescription instrumentedType) {
 
             @Override
             public FieldDescription locate(String name, boolean staticMethod) {
-                TypeDescription currentType = instrumentedType;
-                do {
+                for (GenericTypeDescription currentType : instrumentedType) {
                     FieldList<?> fieldList = currentType.getDeclaredFields().filter(named(name).and(isVisibleTo(instrumentedType)));
                     if (!fieldList.isEmpty() && (!staticMethod || fieldList.getOnly().isStatic())) {
                         return fieldList.getOnly();
                     }
-                } while (!(currentType = currentType.getSuperType().asRawType()).represents(Object.class));
+                }
                 throw new IllegalArgumentException("There is no field '" + name + " that is visible to " + instrumentedType);
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodSortMatcher.java
Patch:
@@ -117,14 +117,12 @@ protected boolean isSort(MethodDescription target) {
                             .and(takesArguments(target.getParameters().asTypeList().asRawTypes()))).isEmpty()) {
                         return true;
                     }
-                    GenericTypeDescription currentType = target.getDeclaringType().getSuperType();
-                    while (currentType != null) {
+                    for (GenericTypeDescription currentType : target.getDeclaringType().getSuperType()) {
                         for (MethodDescription methodDescription : currentType.getDeclaredMethods()) {
                             if (target.asToken().equals(methodDescription.asDefined().asToken())) {
                                 return !methodDescription.equals(methodDescription.asDefined());
                             }
                         }
-                        currentType = currentType.getSuperType();
                     }
                 }
                 return false;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/GenericTypeDescription.java
Patch:
@@ -1161,7 +1161,7 @@ public Iterator<GenericTypeDescription> iterator() {
         @Override
         public <T> T accept(Visitor<T> visitor) {
             return getSort().isNonGeneric()
-                    ? visitor.onNonGenericType(asRawType())
+                    ? visitor.onNonGenericType(this)
                     : visitor.onGenericArray(this);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -939,7 +939,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> takesGene
      * @param <T>              The type of the matched object.
      * @return A method matcher that matches a method's generic parameter types against the supplied arguments.
      */
-    public static <T extends MethodDescription> ElementMatcher.Junction<T> takesGenericArguments(Iterable<? extends GenericTypeDescription> typeDescriptions) {
+    public static <T extends MethodDescription> ElementMatcher.Junction<T> takesGenericArguments(List<? extends GenericTypeDescription> typeDescriptions) {
         List<ElementMatcher<? super GenericTypeDescription>> typeMatchers = new LinkedList<ElementMatcher<? super GenericTypeDescription>>();
         for (GenericTypeDescription typeDescription : typeDescriptions) {
             typeMatchers.add(is(nonNull(typeDescription)));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/AllArguments.java
Patch:
@@ -132,7 +132,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            if (!target.getType().asRawType().isArray()) {
+            if (!target.getType().isArray()) {
                 throw new IllegalStateException("Expected an array type for all argument annotation on " + source);
             }
             ArrayFactory arrayFactory = ArrayFactory.forType(target.getType().asRawType().getComponentType());

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/This.java
Patch:
@@ -62,9 +62,9 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            if (target.getType().asRawType().isPrimitive()) {
+            if (target.getType().isPrimitive()) {
                 throw new IllegalStateException(target + " uses a primitive type with a @This annotation");
-            } else if (target.getType().asRawType().isArray()) {
+            } else if (target.getType().isArray()) {
                 throw new IllegalStateException(target + " uses an array type with a @This annotation");
             } else if (source.isStatic() && !annotation.loadSilent().optional()) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -1213,12 +1213,12 @@ public GenericTypeDescription onParameterizedType(GenericTypeDescription paramet
             }
 
             @Override
-            public GenericTypeDescription onNonGenericType(TypeDescription typeDescription) {
+            public GenericTypeDescription onNonGenericType(GenericTypeDescription typeDescription) {
                 return visitor.onNonGenericType(typeDescription);
             }
 
             @Override
-            protected TypeDescription onSimpleType(TypeDescription typeDescription) {
+            protected GenericTypeDescription onSimpleType(GenericTypeDescription typeDescription) {
                 throw new UnsupportedOperationException();
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodSortMatcher.java
Patch:
@@ -101,6 +101,7 @@ protected boolean isSort(MethodDescription target) {
         VISIBILITY_BRIDGE("isVisibilityBridge()") {
             @Override
             protected boolean isSort(MethodDescription target) {
+                // Visibility bridges are never required for Java 8 default methods.
                 if (target.isBridge() && !target.getDeclaringType().asRawType().isInterface()) {
                     GenericTypeDescription currentType = target.getDeclaringType().getSuperType();
                     while (currentType != null) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/AbstractDynamicTypeBuilderForInliningTest.java
Patch:
@@ -196,9 +196,9 @@ public void testBridgeMethodCreation() throws Exception {
                 .getLoaded();
         assertEquals(String.class, dynamicType.getDeclaredMethod(FOO).getReturnType());
         assertThat(dynamicType.getDeclaredMethod(FOO).getGenericReturnType(), is((Type) String.class));
-        SuperCall<String> superCall = (SuperCall<String>) dynamicType.newInstance();
-        assertThat(superCall.foo(FOO), is(FOO));
-        superCall.assertOnlyCall(FOO);
+        BridgeRetention<String> bridgeRetention = (BridgeRetention<String>) dynamicType.newInstance();
+        assertThat(bridgeRetention.foo(), is(FOO));
+        bridgeRetention.assertZeroCalls();
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderTest.java
Patch:
@@ -363,9 +363,9 @@ public void testBridgeMethodCreation() throws Exception {
                 .getLoaded();
         assertEquals(String.class, dynamicType.getDeclaredMethod(FOO).getReturnType());
         assertThat(dynamicType.getDeclaredMethod(FOO).getGenericReturnType(), is((Type) String.class));
-        SuperCall<String> superCall = (SuperCall<String>) dynamicType.newInstance();
-        assertThat(superCall.foo(FOO), is(FOO));
-        superCall.assertOnlyCall(FOO);
+        BridgeRetention<String> bridgeRetention = (BridgeRetention<String>) dynamicType.newInstance();
+        assertThat(bridgeRetention.foo(), is(FOO));
+        bridgeRetention.assertZeroCalls();
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccess.java
Patch:
@@ -229,7 +229,7 @@ public StackManipulation prependThisReference() {
         }
 
         public StackManipulation asBridgeOf(MethodDescription methodDescription) {
-            return new MethodLoading(methodDescription, new TypeCastingHandler.ForBridgeTarget(methodDescription));
+            return new MethodLoading(this.methodDescription, new TypeCastingHandler.ForBridgeTarget(methodDescription));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTarget.java
Patch:
@@ -45,7 +45,7 @@ protected RebaseImplementationTarget(MethodLookupEngine.Finding finding,
     @Override
     protected Implementation.SpecialMethodInvocation invokeSuper(MethodDescription methodDescription) {
         return methodDescription.getDeclaringType().equals(typeDescription)
-                ? invokeSuper(methodRebaseResolver.resolve(methodDescription))
+                ? invokeSuper(methodRebaseResolver.resolve(methodDescription.asDeclared()))
                 : Implementation.SpecialMethodInvocation.Simple.of(methodDescription, typeDescription.getSuperType().asRawType());
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodLookupEngineDefaultTest.java
Patch:
@@ -10,6 +10,7 @@
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import net.bytebuddy.test.utility.PrecompiledTypeClassLoader;
 import org.hamcrest.CoreMatchers;
+import org.hamcrest.Matcher;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverDisabledTest.java
Patch:
@@ -18,7 +18,7 @@ public class MethodRebaseResolverDisabledTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription methodDescription;
+    private MethodDescription.InDeclaredForm methodDescription;
 
     @Test
     public void testResolutionPreservesMethod() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverEnabledTest.java
Patch:
@@ -35,7 +35,7 @@ public class MethodRebaseResolverEnabledTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription method, constructor, other;
+    private MethodDescription.InDeclaredForm method, constructor, other;
 
     @Mock
     private TypeDescription placeholderType, returnType, parameterType, declaringType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedConstructorTest.java
Patch:
@@ -33,7 +33,7 @@ public class MethodRebaseResolverResolutionForRebasedConstructorTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription methodDescription;
+    private MethodDescription.InDeclaredForm methodDescription;
 
     @Mock
     private StackManipulation stackManipulation;
@@ -90,11 +90,12 @@ public void testPreservation() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("unchecked")
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(MethodRebaseResolver.Resolution.ForRebasedConstructor.class).refine(new ObjectPropertyAssertion.Refinement<MethodDescription>() {
             @Override
             public void apply(MethodDescription mock) {
-                when(mock.getParameters()).thenReturn(new ParameterList.Empty());
+                when(mock.getParameters()).thenReturn((ParameterList) new ParameterList.Empty());
                 when(mock.getExceptionTypes()).thenReturn(new GenericTypeList.Empty());
                 when(mock.getDeclaringType()).thenReturn(mock(TypeDescription.class));
                 TypeDescription returnType = mock(TypeDescription.class);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedMethodTest.java
Patch:
@@ -31,7 +31,7 @@ public class MethodRebaseResolverResolutionForRebasedMethodTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription methodDescription;
+    private MethodDescription.InDeclaredForm methodDescription;
 
     @Mock
     private MethodRebaseResolver.MethodNameTransformer methodNameTransformer, otherMethodNameTransformer;
@@ -85,11 +85,12 @@ public void testPreservation() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("unchecked")
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(MethodRebaseResolver.Resolution.ForRebasedMethod.class).refine(new ObjectPropertyAssertion.Refinement<MethodDescription>() {
             @Override
             public void apply(MethodDescription mock) {
-                when(mock.getParameters()).thenReturn(new ParameterList.Empty());
+                when(mock.getParameters()).thenReturn((ParameterList) new ParameterList.Empty());
                 when(mock.getExceptionTypes()).thenReturn(new GenericTypeList.Empty());
                 when(mock.getDeclaringType()).thenReturn(mock(TypeDescription.class));
                 TypeDescription returnType = mock(TypeDescription.class);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionPreservedTest.java
Patch:
@@ -18,7 +18,7 @@ public class MethodRebaseResolverResolutionPreservedTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription methodDescription;
+    private MethodDescription.InDeclaredForm methodDescription;
 
     @Test
     public void testPreservation() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTargetFactoryTest.java
Patch:
@@ -36,16 +36,17 @@ public class RebaseImplementationTargetFactoryTest {
     private MethodLookupEngine.Finding finding;
 
     @Mock
-    private MethodList instrumentedMethods;
+    private MethodList<?> instrumentedMethods;
 
     @Mock
     private TypeDescription instrumentedType, superType;
 
     private Implementation.Target.Factory factory;
 
     @Before
+    @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
-        when(finding.getInvokableMethods()).thenReturn(new MethodList.Empty());
+        when(finding.getInvokableMethods()).thenReturn((MethodList) new MethodList.Empty());
         when(finding.getInvokableDefaultMethods()).thenReturn(Collections.<TypeDescription, Set<MethodDescription>>emptyMap());
         when(finding.getTypeDescription()).thenReturn(instrumentedType);
         when(instrumentedType.getSuperType()).thenReturn(superType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/SuperMethodCallOtherTest.java
Patch:
@@ -97,7 +97,7 @@ public void testConstructor() throws Exception {
     public void testStaticMethod() throws Exception {
         when(typeDescription.getSuperType()).thenReturn(superType);
         when(methodDescription.isStatic()).thenReturn(true);
-        when(methodDescription.getParameters()).thenReturn(new ParameterList.Empty());
+        when(methodDescription.getParameters()).thenReturn((ParameterList) new ParameterList.Empty());
         when(methodDescription.getReturnType()).thenReturn(returnType);
         when(returnType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(superType.getDeclaredMethods()).thenReturn(superTypeMethods);
@@ -111,7 +111,7 @@ public void testStaticMethod() throws Exception {
     @SuppressWarnings("unchecked")
     public void testNoSuper() throws Exception {
         when(typeDescription.getSuperType()).thenReturn(superType);
-        when(methodDescription.getParameters()).thenReturn(new ParameterList.Empty());
+        when(methodDescription.getParameters()).thenReturn((ParameterList) new ParameterList.Empty());
         when(methodDescription.getReturnType()).thenReturn(returnType);
         when(methodDescription.getDeclaringType()).thenReturn(declaringType);
         when(declaringType.getStackSize()).thenReturn(StackSize.SINGLE);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/AbstractAnnotationBinderTest.java
Patch:
@@ -39,7 +39,7 @@ public abstract class AbstractAnnotationBinderTest<T extends Annotation> {
     protected T annotation;
 
     @Mock
-    protected MethodDescription source;
+    protected MethodDescription.InDeclaredForm source;
 
     @Mock
     protected ParameterDescription target;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldProxyBinderTest.java
Patch:
@@ -32,7 +32,7 @@ public class FieldProxyBinderTest extends AbstractAnnotationBinderTest<FieldProx
     private TypeDescription setterType, getterType, fieldType;
 
     @Mock
-    private FieldDescription fieldDescription;
+    private FieldDescription.InDeclaredForm fieldDescription;
 
     public FieldProxyBinderTest() {
         super(FieldProxy.class);
@@ -44,7 +44,8 @@ public void setUp() throws Exception {
         super.setUp();
         when(getterMethod.getDeclaringType()).thenReturn(getterType);
         when(setterMethod.getDeclaringType()).thenReturn(setterType);
-        when(instrumentedType.getDeclaredFields()).thenReturn(new FieldList.Explicit(Collections.singletonList(fieldDescription)));
+        when(instrumentedType.getDeclaredFields())
+                .thenReturn(new FieldList.Explicit<FieldDescription.InDeclaredForm>(Collections.singletonList(fieldDescription)));
         when(fieldDescription.getType()).thenReturn(fieldType);
         when(fieldType.getStackSize()).thenReturn(StackSize.ZERO);
         when(fieldType.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/MethodSortMatcherTest.java
Patch:
@@ -119,7 +119,7 @@ protected void prepare(MethodDescription mock) {
                 when(typeDescription.getDeclaredMethods()).thenReturn(methodList);
                 when(methodList.filter(any(ElementMatcher.class))).thenReturn(methodList);
                 when(methodList.size()).thenReturn(0);
-                when(mock.getParameters()).thenReturn(new ParameterList.Empty());
+                when(mock.getParameters()).thenReturn((ParameterList) new ParameterList.Empty());
                 TypeDescription returnType = Mockito.mock(TypeDescription.class);
                 when(returnType.asRawType()).thenReturn(returnType);
                 when(mock.getReturnType()).thenReturn(returnType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/AbstractFieldDescriptionTest.java
Patch:
@@ -22,7 +22,7 @@ public abstract class AbstractFieldDescriptionTest {
 
     private Field first, second, genericField;
 
-    protected abstract FieldDescription describe(Field field);
+    protected abstract FieldDescription.InDeclaredForm describe(Field field);
 
     @Before
     public void setUp() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/AbstractFieldListTest.java
Patch:
@@ -11,7 +11,7 @@
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 
-public abstract class AbstractFieldListTest<U> extends AbstractFilterableListTest<FieldDescription, FieldList, U> {
+public abstract class AbstractFieldListTest<U, V extends FieldDescription> extends AbstractFilterableListTest<V, FieldList<V>, U> {
 
     @Test
     @SuppressWarnings("unchecked")

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/FieldDescriptionForLoadedFieldTest.java
Patch:
@@ -5,7 +5,7 @@
 public class FieldDescriptionForLoadedFieldTest extends AbstractFieldDescriptionTest {
 
     @Override
-    protected FieldDescription describe(Field field) {
+    protected FieldDescription.InDeclaredForm describe(Field field) {
         return new FieldDescription.ForLoadedField(field);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/FieldDescriptionLatentTest.java
Patch:
@@ -8,10 +8,8 @@
 
 public class FieldDescriptionLatentTest extends AbstractFieldDescriptionTest {
 
-    private static final String FOO = "foo";
-
     @Override
-    protected FieldDescription describe(Field field) {
+    protected FieldDescription.InDeclaredForm describe(Field field) {
         return new FieldDescription.Latent(new TypeDescription.ForLoadedType(field.getDeclaringClass()),
                 field.getName(),
                 field.getModifiers(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/FieldListExplicitTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import java.util.List;
 
-public class FieldListExplicitTest extends AbstractFieldListTest<FieldDescription> {
+public class FieldListExplicitTest extends AbstractFieldListTest<FieldDescription, FieldDescription> {
 
     @Override
     protected FieldDescription getFirst() throws Exception {
@@ -15,8 +15,8 @@ protected FieldDescription getSecond() throws Exception {
     }
 
     @Override
-    protected FieldList asList(List<FieldDescription> elements) {
-        return new FieldList.Explicit(elements);
+    protected FieldList<FieldDescription> asList(List<FieldDescription> elements) {
+        return new FieldList.Explicit<FieldDescription>(elements);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/AbstractMethodListTest.java
Patch:
@@ -10,7 +10,7 @@
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 
-public abstract class AbstractMethodListTest<U> extends AbstractFilterableListTest<MethodDescription, MethodList, U> {
+public abstract class AbstractMethodListTest<U, V extends MethodDescription> extends AbstractFilterableListTest<V, MethodList<V>, U> {
 
     @Test
     @SuppressWarnings("unchecked")

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionForLoadedTest.java
Patch:
@@ -11,12 +11,12 @@
 public class MethodDescriptionForLoadedTest extends AbstractMethodDescriptionTest {
 
     @Override
-    protected MethodDescription describe(Method method) {
+    protected MethodDescription.InDeclaredForm describe(Method method) {
         return new MethodDescription.ForLoadedMethod(method);
     }
 
     @Override
-    protected MethodDescription describe(Constructor<?> constructor) {
+    protected MethodDescription.InDeclaredForm describe(Constructor<?> constructor) {
         return new MethodDescription.ForLoadedConstructor(constructor);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTest.java
Patch:
@@ -17,13 +17,13 @@
 public class MethodDescriptionLatentTest extends AbstractMethodDescriptionTest {
 
     @Override
-    protected MethodDescription describe(Method method) {
+    protected MethodDescription.InDeclaredForm describe(Method method) {
         return new MethodDescription.Latent(new TypeDescription.ForLoadedType(method.getDeclaringClass()),
                 new MethodDescription.ForLoadedMethod(method).asToken(ElementMatchers.is(method.getDeclaringClass())));
     }
 
     @Override
-    protected MethodDescription describe(Constructor<?> constructor) {
+    protected MethodDescription.InDeclaredForm describe(Constructor<?> constructor) {
         return new MethodDescription.Latent(new TypeDescription.ForLoadedType(constructor.getDeclaringClass()),
                 new MethodDescription.ForLoadedConstructor(constructor).asToken(ElementMatchers.is(constructor.getDeclaringClass())));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTypeInitializerTest.java
Patch:
@@ -18,9 +18,9 @@ public class MethodDescriptionLatentTypeInitializerTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private GenericTypeDescription typeDescription;
+    private TypeDescription typeDescription;
 
-    private MethodDescription typeInitializer;
+    private MethodDescription.InDeclaredForm typeInitializer;
 
     @Before
     public void setUp() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodListExplicitTest.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Arrays;
 import java.util.List;
 
-public class MethodListExplicitTest extends AbstractMethodListTest<MethodDescription> {
+public class MethodListExplicitTest extends AbstractMethodListTest<MethodDescription, MethodDescription> {
 
     @Override
     protected MethodDescription getFirst() throws Exception {
@@ -16,8 +16,8 @@ protected MethodDescription getSecond() throws Exception {
     }
 
     @Override
-    protected MethodList asList(List<MethodDescription> elements) {
-        return new MethodList.Explicit(elements);
+    protected MethodList<MethodDescription> asList(List<MethodDescription> elements) {
+        return new MethodList.Explicit<MethodDescription>(elements);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodListForLoadedTypeTest.java
Patch:
@@ -4,7 +4,7 @@
 import java.lang.reflect.Method;
 import java.util.List;
 
-public class MethodListForLoadedTypeTest extends AbstractMethodListTest<Method> {
+public class MethodListForLoadedTypeTest extends AbstractMethodListTest<Method, MethodDescription.InDeclaredForm> {
 
     @Override
     protected Method getFirst() throws Exception {
@@ -17,12 +17,12 @@ protected Method getSecond() throws Exception {
     }
 
     @Override
-    protected MethodList asList(List<Method> elements) {
+    protected MethodList<MethodDescription.InDeclaredForm> asList(List<Method> elements) {
         return new MethodList.ForLoadedType(new Constructor<?>[0], elements.toArray(new Method[elements.size()]));
     }
 
     @Override
-    protected MethodDescription asElement(Method element) {
+    protected MethodDescription.InDeclaredForm asElement(Method element) {
         return new MethodDescription.ForLoadedMethod(element);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverMethodsOnlyTest.java
Patch:
@@ -32,7 +32,7 @@ public class MethodRebaseResolverMethodsOnlyTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription method, constructor, other;
+    private MethodDescription.InDeclaredForm method, constructor, other;
 
     @Mock
     private TypeDescription returnType, parameterType, declaringType;
@@ -67,7 +67,7 @@ public void testResolutionPreservesNonInstrumentedMethod() throws Exception {
         MethodRebaseResolver.Resolution resolution = methodRebaseResolver.resolve(other);
         assertThat(resolution.isRebased(), is(false));
         assertThat(resolution.getAdditionalArguments(), is((StackManipulation) StackManipulation.LegalTrivial.INSTANCE));
-        assertThat(resolution.getResolvedMethod(), is(other));
+        assertThat(resolution.getResolvedMethod(), is((MethodDescription) other));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTargetSpecialMethodInvocationTest.java
Patch:
@@ -31,7 +31,7 @@ protected Implementation.SpecialMethodInvocation make(String name,
                                                           TypeDescription targetType) {
         MethodRebaseResolver.Resolution resolution = mock(MethodRebaseResolver.Resolution.class);
         when(resolution.getAdditionalArguments()).thenReturn(StackManipulation.LegalTrivial.INSTANCE);
-        MethodDescription methodDescription = mock(MethodDescription.class);
+        MethodDescription.InDeclaredForm methodDescription = mock(MethodDescription.InDeclaredForm.class);
         when(methodDescription.getInternalName()).thenReturn(name);
         when(methodDescription.getReturnType()).thenReturn(returnType);
         when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(methodDescription, parameterTypes));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/AbstractMethodCallProxyTest.java
Patch:
@@ -35,7 +35,7 @@ public class AbstractMethodCallProxyTest {
     private AuxiliaryType.MethodAccessorFactory methodAccessorFactory;
 
     protected Class<?> proxyOnlyDeclaredMethodOf(Class<?> proxyTarget) throws Exception {
-        MethodDescription proxyMethod = new TypeDescription.ForLoadedType(proxyTarget)
+        MethodDescription.InDeclaredForm proxyMethod = new TypeDescription.ForLoadedType(proxyTarget)
                 .getDeclaredMethods().filter(not(isConstructor())).getOnly();
         when(methodAccessorFactory.registerAccessorFor(eq(specialMethodInvocation))).thenReturn(proxyMethod);
         String auxiliaryTypeName = getClass().getName() + "$" + proxyTarget.getSimpleName() + "$Proxy";

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TypeProxyCreationTest.java
Patch:
@@ -55,11 +55,11 @@ public class TypeProxyCreationTest {
     private Implementation.SpecialMethodInvocation specialMethodInvocation;
 
     @Mock
-    private MethodDescription proxyMethod;
+    private MethodDescription.InDeclaredForm proxyMethod;
 
     private TypeDescription foo;
 
-    private MethodList fooMethods;
+    private MethodList<?> fooMethods;
 
     private int modifiers;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/MethodDelegationBinderTest.java
Patch:
@@ -15,6 +15,7 @@
 public class MethodDelegationBinderTest {
 
     @Test
+    @SuppressWarnings("unchecked")
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(MethodDelegationBinder.MethodInvoker.Simple.class).apply();
         ObjectPropertyAssertion.of(MethodDelegationBinder.MethodInvoker.Virtual.class).apply();
@@ -26,7 +27,7 @@ public void testObjectProperties() throws Exception {
             @Override
             public MethodDescription create() {
                 MethodDescription methodDescription = mock(MethodDescription.class);
-                when(methodDescription.getParameters()).thenReturn(new ParameterList.Empty());
+                when(methodDescription.getParameters()).thenReturn((ParameterList) new ParameterList.Empty());
                 return methodDescription;
             }
         }).applyBasic();

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ArgumentNextUnboundAsDefaultBinderTest.java
Patch:
@@ -37,7 +37,7 @@ public class ArgumentNextUnboundAsDefaultBinderTest {
     @Mock
     private TypeDescription firstParameter, secondParameter;
 
-    private ParameterList sourceParameters;
+    private ParameterList<?> sourceParameters;
 
     @Mock
     private ParameterDescription firstTargetParameter, secondTargetParameter;
@@ -47,7 +47,7 @@ public void setUp() throws Exception {
         when(firstParameter.getStackSize()).thenReturn(StackSize.ZERO);
         when(secondParameter.getStackSize()).thenReturn(StackSize.ZERO);
         sourceParameters = new ParameterList.Explicit.ForTypes(source, Arrays.asList(firstParameter, secondParameter));
-        ParameterList targetParameters = new ParameterList.Explicit(Arrays.asList(firstTargetParameter, secondTargetParameter));
+        ParameterList<?> targetParameters = new ParameterList.Explicit(Arrays.asList(firstTargetParameter, secondTargetParameter));
         when(source.getParameters()).thenReturn(sourceParameters);
         when(target.getParameters()).thenReturn(targetParameters);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/FieldAccessOtherTest.java
Patch:
@@ -33,13 +33,14 @@ public class FieldAccessOtherTest {
     private TypeDescription typeDescription;
 
     @Mock
-    private FieldDescription fieldDescription;
+    private FieldDescription.InDeclaredForm fieldDescription;
 
     @Before
     public void setUp() throws Exception {
         when(enumerationDescription.getEnumerationType()).thenReturn(typeDescription);
         when(enumerationDescription.getValue()).thenReturn(FOO);
-        when(typeDescription.getDeclaredFields()).thenReturn(new FieldList.Explicit(Collections.singletonList(fieldDescription)));
+        when(typeDescription.getDeclaredFields())
+                .thenReturn(new FieldList.Explicit<FieldDescription.InDeclaredForm>(Collections.singletonList(fieldDescription)));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationDynamicTest.java
Patch:
@@ -32,7 +32,7 @@ public class MethodInvocationDynamicTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription methodDescription;
+    private MethodDescription.InDeclaredForm methodDescription;
 
     @Mock
     private TypeDescription returnType, declaringType, firstType, secondType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationOtherTest.java
Patch:
@@ -23,6 +23,7 @@ public class MethodInvocationOtherTest {
     private static final String FOO = "foo";
 
     @Test
+    @SuppressWarnings("unchecked")
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(MethodInvocation.class).apply();
         ObjectPropertyAssertion.of(MethodInvocation.IllegalInvocation.class).apply();
@@ -37,7 +38,7 @@ public void apply(MethodDescription mock) {
                 when(mock.getReturnType()).thenReturn(returnType);
                 when(returnType.asRawType()).thenReturn(returnType);
                 when(mock.getInternalName()).thenReturn(FOO);
-                when(mock.getParameters()).thenReturn(new ParameterList.Empty());
+                when(mock.getParameters()).thenReturn((ParameterList) new ParameterList.Empty());
             }
         }).apply();
         ObjectPropertyAssertion.of(MethodInvocation.DynamicInvocation.class).apply();

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccessDescriptionTest.java
Patch:
@@ -31,7 +31,7 @@ public class MethodVariableAccessDescriptionTest {
     public TestRule mockitoRule = new MockitoRule(this);
 
     @Mock
-    private MethodDescription methodDescription;
+    private MethodDescription.InDeclaredForm methodDescription;
 
     @Mock
     private TypeDescription declaringType, firstParameterType, secondParameterType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccessOtherTest.java
Patch:
@@ -20,13 +20,14 @@ public void testVoidArgument() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("unchecked")
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(MethodVariableAccess.class).apply();
         ObjectPropertyAssertion.of(MethodVariableAccess.ArgumentLoadingStackManipulation.class).apply();
         ObjectPropertyAssertion.of(MethodVariableAccess.TypeCastingHandler.ForBridgeTarget.class).refine(new ObjectPropertyAssertion.Refinement<MethodDescription>() {
             @Override
             public void apply(MethodDescription mock) {
-                when(mock.getParameters()).thenReturn(new ParameterList.Empty());
+                when(mock.getParameters()).thenReturn((ParameterList) new ParameterList.Empty());
             }
         }).applyBasic();
         ObjectPropertyAssertion.of(MethodVariableAccess.TypeCastingHandler.NoOp.class).apply();

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultFieldDescriptionTest.java
Patch:
@@ -25,7 +25,7 @@ public void tearDown() throws Exception {
     }
 
     @Override
-    protected FieldDescription describe(Field field) {
+    protected FieldDescription.InDeclaredForm describe(Field field) {
         return typePool.describe(field.getDeclaringClass().getName())
                 .resolve()
                 .getDeclaredFields().filter(named(field.getName())).getOnly();

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultMethodDescriptionTest.java
Patch:
@@ -26,14 +26,14 @@ public void tearDown() throws Exception {
     }
 
     @Override
-    protected MethodDescription describe(Method method) {
+    protected MethodDescription.InDeclaredForm describe(Method method) {
         return typePool.describe(method.getDeclaringClass().getName())
                 .resolve()
                 .getDeclaredMethods().filter(is(method)).getOnly();
     }
 
     @Override
-    protected MethodDescription describe(Constructor<?> constructor) {
+    protected MethodDescription.InDeclaredForm describe(Constructor<?> constructor) {
         return typePool.describe(constructor.getDeclaringClass().getName())
                 .resolve()
                 .getDeclaredMethods().filter(is(constructor)).getOnly();

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyFieldListTest.java
Patch:
@@ -16,7 +16,7 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
 
-public class TypePoolLazyFieldListTest extends AbstractFieldListTest<Field> {
+public class TypePoolLazyFieldListTest extends AbstractFieldListTest<Field, FieldDescription.InDeclaredForm> {
 
     private TypePool typePool;
 
@@ -41,12 +41,12 @@ protected Field getSecond() throws Exception {
     }
 
     @Override
-    protected FieldList asList(List<Field> elements) {
+    protected FieldList<FieldDescription.InDeclaredForm> asList(List<Field> elements) {
         return typePool.describe(Foo.class.getName()).resolve().getDeclaredFields().filter(anyOf(elements.toArray(new Field[elements.size()])));
     }
 
     @Override
-    protected FieldDescription asElement(Field element) {
+    protected FieldDescription.InDeclaredForm asElement(Field element) {
         return new FieldDescription.ForLoadedField(element);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyMethodListTest.java
Patch:
@@ -20,7 +20,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-public class TypePoolLazyMethodListTest extends AbstractMethodListTest<Method> {
+public class TypePoolLazyMethodListTest extends AbstractMethodListTest<Method, MethodDescription.InDeclaredForm> {
 
     private TypePool typePool;
 
@@ -45,12 +45,12 @@ protected Method getSecond() throws Exception {
     }
 
     @Override
-    protected MethodList asList(List<Method> elements) {
+    protected MethodList<MethodDescription.InDeclaredForm> asList(List<Method> elements) {
         return typePool.describe(Foo.class.getName()).resolve().getDeclaredMethods().filter(anyOf(elements.toArray(new Method[elements.size()])));
     }
 
     @Override
-    protected MethodDescription asElement(Method element) {
+    protected MethodDescription.InDeclaredForm asElement(Method element) {
         return new MethodDescription.ForLoadedMethod(element);
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -4,7 +4,6 @@
 import net.bytebuddy.description.NamedElement;
 import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.annotation.AnnotationList;
-import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.matcher.ElementMatcher;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -13,7 +13,6 @@
 import net.bytebuddy.dynamic.scaffold.MethodLookupEngine;
 import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
 import net.bytebuddy.implementation.Implementation;
-import net.bytebuddy.implementation.MethodDelegation;
 import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
 import net.bytebuddy.implementation.bind.MethodDelegationBinder;
 import net.bytebuddy.implementation.bytecode.ByteCodeAppender;

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterMatcher.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.method.MethodDescription;
+import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.description.method.ParameterList;
 
 /**
@@ -20,7 +21,7 @@ public class MethodParameterMatcher<T extends MethodDescription> extends Element
      *
      * @param parameterMatcher The matcher to apply to the parameters.
      */
-    public MethodParameterMatcher(ElementMatcher<? super ParameterList<?>> parameterMatcher) {
+    public MethodParameterMatcher(ElementMatcher<? super ParameterList<? extends ParameterDescription>> parameterMatcher) {
         this.parameterMatcher = parameterMatcher;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -1807,7 +1807,7 @@ public static Builder forType(TypeDescription annotationType) {
          * @return A builder with the additional, given property.
          */
         public Builder define(String property, AnnotationValue<?, ?> value) {
-            MethodList methodDescriptions = annotationType.getDeclaredMethods().filter(named(nonNull(property)));
+            MethodList<?> methodDescriptions = annotationType.getDeclaredMethods().filter(named(nonNull(property)));
             if (methodDescriptions.isEmpty()) {
                 throw new IllegalArgumentException(annotationType + " does not define a property named " + property);
             } else if (!methodDescriptions.getOnly().getReturnType().asRawType().isAnnotationValue(value.resolve())) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/GenericTypeDescription.java
Patch:
@@ -86,7 +86,7 @@ public interface GenericTypeDescription extends NamedElement {
      *
      * @return A list of fields that are declared by this type.
      */
-    FieldList getDeclaredFields();
+    FieldList<?> getDeclaredFields();
 
     /**
      * <p>
@@ -101,7 +101,7 @@ public interface GenericTypeDescription extends NamedElement {
      *
      * @return A list of methods that are declared by this type.
      */
-    MethodList getDeclaredMethods();
+    MethodList<?> getDeclaredMethods();
 
     /**
      * <p>

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/BridgeMethodResolver.java
Patch:
@@ -105,8 +105,8 @@ protected Simple(Map<MethodDescription.Token, BridgeTarget> bridges) {
          * @param conflictHandler A conflict handler that is queried for handling ambiguous resolutions.
          * @return A corresponding bridge method resolver.
          */
-        public static BridgeMethodResolver of(MethodList methodList, ConflictHandler conflictHandler) {
-            MethodList bridgeMethods = methodList.filter(isBridge());
+        public static BridgeMethodResolver of(MethodList<?> methodList, ConflictHandler conflictHandler) {
+            MethodList<?> bridgeMethods = methodList.filter(isBridge());
             HashMap<MethodDescription.Token, BridgeTarget> bridges = new HashMap<MethodDescription.Token, BridgeTarget>(bridgeMethods.size());
             for (MethodDescription bridgeMethod : bridgeMethods) {
                 bridges.put(bridgeMethod.asToken(), findBridgeTargetFor(bridgeMethod, conflictHandler));
@@ -123,7 +123,7 @@ public static BridgeMethodResolver of(MethodList methodList, ConflictHandler con
          */
         private static BridgeTarget findBridgeTargetFor(MethodDescription bridgeMethod,
                                                         ConflictHandler conflictHandler) {
-            MethodList targetCandidates = bridgeMethod.getDeclaringType()
+            MethodList<?> targetCandidates = bridgeMethod.getDeclaringType()
                     .getDeclaredMethods()
                     .filter(not(isBridge()).and(isSpecializationOf(bridgeMethod)));
             switch (targetCandidates.size()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -502,12 +502,12 @@ protected GenericTypeList getDeclaredInterfaces() {
         }
 
         @Override
-        public FieldList getDeclaredFields() {
+        public FieldList<FieldDescription.InDeclaredForm> getDeclaredFields() {
             return new FieldList.ForTokens(this, fieldTokens);
         }
 
         @Override
-        public MethodList getDeclaredMethods() {
+        public MethodList<MethodDescription.InDeclaredForm> getDeclaredMethods() {
             return new MethodList.ForTokens(this, methodTokens);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -415,7 +415,7 @@ public void apply(ClassVisitor classVisitor, Implementation.Context implementati
                             methodDescription.getDescriptor(),
                             methodDescription.getGenericSignature(),
                             methodDescription.getExceptionTypes().asRawTypes().toInternalNames());
-                    ParameterList parameterList = methodDescription.getParameters();
+                    ParameterList<?> parameterList = methodDescription.getParameters();
                     if (parameterList.hasExplicitMetaData()) {
                         for (ParameterDescription parameterDescription : parameterList) {
                             methodVisitor.visitParameter(parameterDescription.getName(), parameterDescription.getModifiers());
@@ -768,7 +768,7 @@ abstract class Default<S> implements TypeWriter<S> {
         /**
          * A list of all instrumented methods.
          */
-        protected final MethodList instrumentedMethods;
+        protected final MethodList<?> instrumentedMethods;
 
         /**
          * Creates a new default type writer.
@@ -795,7 +795,7 @@ protected Default(TypeDescription instrumentedType,
                           TypeAttributeAppender attributeAppender,
                           FieldPool fieldPool,
                           MethodPool methodPool,
-                          MethodList instrumentedMethods) {
+                          MethodList<?> instrumentedMethods) {
             this.instrumentedType = instrumentedType;
             this.loadedTypeInitializer = loadedTypeInitializer;
             this.typeInitializer = typeInitializer;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategy.java
Patch:
@@ -76,7 +76,7 @@ public MethodRegistry inject(MethodRegistry methodRegistry, MethodAttributeAppen
             @Override
             public List<MethodDescription.Token> extractConstructors(TypeDescription instrumentedType) {
                 TypeDescription superType = instrumentedType.getSuperType().asRawType();
-                MethodList defaultConstructors = superType == null
+                MethodList<?> defaultConstructors = superType == null
                         ? new MethodList.Empty()
                         : superType.getDeclaredMethods().filter(isConstructor().and(takesArguments(0)).<MethodDescription>and(isVisibleTo(instrumentedType)));
                 if (defaultConstructors.size() == 1) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTarget.java
Patch:
@@ -41,7 +41,7 @@ protected SubclassImplementationTarget(MethodLookupEngine.Finding finding,
                                            OriginTypeIdentifier originTypeIdentifier) {
         super(finding, bridgeMethodResolverFactory);
         GenericTypeDescription superType = finding.getTypeDescription().getSuperType();
-        MethodList superConstructors = superType == null
+        MethodList<?> superConstructors = superType == null
                 ? new MethodList.Empty()
                 : superType.asRawType().getDeclaredMethods().filter(isConstructor());
         this.superConstructors = new HashMap<MethodDescription.Token, MethodDescription>(superConstructors.size());

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -272,7 +272,7 @@ public ForInstrumentedTypeHierarchy(TypeDescription instrumentedType) {
             public FieldDescription locate(String name, boolean staticMethod) {
                 TypeDescription currentType = instrumentedType;
                 do {
-                    FieldList fieldList = currentType.getDeclaredFields().filter(named(name).and(isVisibleTo(instrumentedType)));
+                    FieldList<?> fieldList = currentType.getDeclaredFields().filter(named(name).and(isVisibleTo(instrumentedType)));
                     if (!fieldList.isEmpty() && (!staticMethod || fieldList.getOnly().isStatic())) {
                         return fieldList.getOnly();
                     }
@@ -347,7 +347,7 @@ public ForGivenType(TypeDescription targetType, TypeDescription instrumentedType
 
             @Override
             public FieldDescription locate(String name, boolean staticMethod) {
-                FieldList fieldList = targetType.getDeclaredFields().filter(named(name).and(isVisibleTo(instrumentedType)));
+                FieldList<?> fieldList = targetType.getDeclaredFields().filter(named(name).and(isVisibleTo(instrumentedType)));
                 if (fieldList.isEmpty() || (staticMethod && !fieldList.getOnly().isStatic())) {
                     throw new IllegalArgumentException("No field named " + name + " on " + targetType + " is visible to " + instrumentedType);
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -1727,7 +1727,7 @@ public Resolved resolve(TypeDescription instrumentedType,
                     GenericTypeDescription currentType = instrumentedType;
                     FieldDescription fieldDescription = null;
                     do {
-                        FieldList fieldList = currentType.asRawType().getDeclaredFields().filter(named(fieldName));
+                        FieldList<?> fieldList = currentType.asRawType().getDeclaredFields().filter(named(fieldName));
                         if (fieldList.size() != 0) {
                             fieldDescription = fieldList.getOnly();
                         }
@@ -1795,7 +1795,7 @@ public Resolved resolve(TypeDescription instrumentedType,
                                         MethodDescription instrumentedMethod,
                                         Assigner assigner,
                                         boolean dynamicallyTyped) {
-                    ParameterList parameters = instrumentedMethod.getParameters();
+                    ParameterList<?> parameters = instrumentedMethod.getParameters();
                     if (index >= parameters.size()) {
                         throw new IllegalStateException("No parameter " + index + " for " + instrumentedMethod);
                     }
@@ -1858,7 +1858,7 @@ public Resolved resolve(TypeDescription instrumentedType,
                                         MethodDescription instrumentedMethod,
                                         Assigner assigner,
                                         boolean dynamicallyTyped) {
-                    ParameterList parameters = instrumentedMethod.getParameters();
+                    ParameterList<?> parameters = instrumentedMethod.getParameters();
                     if (index >= parameters.size()) {
                         throw new IllegalStateException("No parameter " + index + " for " + instrumentedMethod);
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -1231,7 +1231,7 @@ public StackManipulation resolve(TypeDescription instrumentedType,
                 GenericTypeDescription currentType = instrumentedType;
                 FieldDescription fieldDescription = null;
                 do {
-                    FieldList fieldList = currentType.asRawType().getDeclaredFields().filter(named(fieldName));
+                    FieldList<?> fieldList = currentType.asRawType().getDeclaredFields().filter(named(fieldName));
                     if (fieldList.size() != 0) {
                         fieldDescription = fieldList.getOnly();
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -178,7 +178,7 @@ public class MethodDelegation implements Implementation {
     /**
      * A list of methods to be considered as target by this method delegation.
      */
-    private final MethodList targetMethodCandidates;
+    private final MethodList<?> targetMethodCandidates;
 
     /**
      * Creates a new method delegation.
@@ -198,7 +198,7 @@ protected MethodDelegation(ImplementationDelegate implementationDelegate,
                                TargetMethodAnnotationDrivenBinder.TerminationHandler terminationHandler,
                                MethodDelegationBinder.AmbiguityResolver ambiguityResolver,
                                Assigner assigner,
-                               MethodList targetMethodCandidates) {
+                               MethodList<?> targetMethodCandidates) {
         this.implementationDelegate = implementationDelegate;
         this.parameterBinders = parameterBinders;
         this.defaultsProvider = defaultsProvider;
@@ -611,7 +611,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
 
     @Override
     public ByteCodeAppender appender(Target implementationTarget) {
-        MethodList methodList = this.targetMethodCandidates.filter(isVisibleTo(implementationTarget.getTypeDescription()));
+        MethodList<?> methodList = this.targetMethodCandidates.filter(isVisibleTo(implementationTarget.getTypeDescription()));
         if (methodList.size() == 0) {
             throw new IllegalStateException("No bindable method is visible to " + implementationTarget.getTypeDescription());
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultCall.java
Patch:
@@ -79,7 +79,7 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<Defaul
          * Finds references to the methods of the default call annotation.
          */
         static {
-            MethodList annotationProperties = new TypeDescription.ForLoadedType(DefaultCall.class).getDeclaredMethods();
+            MethodList<?> annotationProperties = new TypeDescription.ForLoadedType(DefaultCall.class).getDeclaredMethods();
             TARGET_TYPE = annotationProperties.filter(named("targetType")).getOnly();
             SERIALIZABLE_PROXY = annotationProperties.filter(named("serializableProxy")).getOnly();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldValue.java
Patch:
@@ -73,7 +73,7 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<FieldV
          * Initializes the methods of the annotation that is read by this binder.
          */
         static {
-            MethodList methodList = new TypeDescription.ForLoadedType(FieldValue.class).getDeclaredMethods();
+            MethodList<?> methodList = new TypeDescription.ForLoadedType(FieldValue.class).getDeclaredMethods();
             DEFINING_TYPE = methodList.filter(named("definingType")).getOnly();
             FIELD_NAME = methodList.filter(named("value")).getOnly();
         }
@@ -262,7 +262,7 @@ protected ForFieldInHierarchy(TypeDescription instrumentedType) {
                 @Override
                 protected Resolution resolve(String fieldName, boolean staticMethod) {
                     for (GenericTypeDescription currentType : instrumentedType) {
-                        FieldList fieldList = currentType.getDeclaredFields().filter(named(fieldName));
+                        FieldList<?> fieldList = currentType.getDeclaredFields().filter(named(fieldName));
                         if (!fieldList.isEmpty() && fieldList.getOnly().isVisibleTo(instrumentedType) && (!staticMethod || fieldList.getOnly().isStatic())) {
                             return new Resolution.Resolved(fieldList.getOnly());
                         }
@@ -336,7 +336,7 @@ protected static FieldLocator of(TypeDescription typeDescription, TypeDescriptio
 
                 @Override
                 protected Resolution resolve(String fieldName, boolean staticMethod) {
-                    FieldList fieldList = typeDescription.getDeclaredFields().filter(named(fieldName));
+                    FieldList<?> fieldList = typeDescription.getDeclaredFields().filter(named(fieldName));
                     return fieldList.isEmpty() || !fieldList.getOnly().isVisibleTo(instrumentedType) || (staticMethod && !fieldList.getOnly().isStatic())
                             ? Resolution.Unresolved.INSTANCE
                             : new Resolution.Resolved(fieldList.getOnly());

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Super.java
Patch:
@@ -145,7 +145,7 @@ protected StackManipulation proxyFor(TypeDescription parameterType,
          * Extracts method references to the annotation methods.
          */
         static {
-            MethodList annotationProperties = new TypeDescription.ForLoadedType(Super.class).getDeclaredMethods();
+            MethodList<?> annotationProperties = new TypeDescription.ForLoadedType(Super.class).getDeclaredMethods();
             IGNORE_FINALIZER = annotationProperties.filter(named("ignoreFinalizer")).getOnly();
             SERIALIZABLE_PROXY = annotationProperties.filter(named("serializableProxy")).getOnly();
             CONSTRUCTOR_PARAMETERS = annotationProperties.filter(named("constructorParameters")).getOnly();
@@ -193,7 +193,7 @@ enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<Super>
          * Extracts method references of the super annotation.
          */
         static {
-            MethodList annotationProperties = new TypeDescription.ForLoadedType(Super.class).getDeclaredMethods();
+            MethodList<?> annotationProperties = new TypeDescription.ForLoadedType(Super.class).getDeclaredMethods();
             STRATEGY = annotationProperties.filter(returns(Instantiation.class)).getOnly();
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/FieldAccess.java
Patch:
@@ -63,7 +63,7 @@ public enum FieldAccess {
      * @return A stack manipulation for reading the enumeration.
      */
     public static StackManipulation forEnumeration(EnumerationDescription enumerationDescription) {
-        FieldList fieldList = enumerationDescription.getEnumerationType().getDeclaredFields().filter(named(enumerationDescription.getValue()));
+        FieldList<?> fieldList = enumerationDescription.getEnumerationType().getDeclaredFields().filter(named(enumerationDescription.getValue()));
         return fieldList.size() != 1 || !fieldList.getOnly().isStatic() || !fieldList.getOnly().isPublic() || !fieldList.getOnly().isEnum()
                 ? StackManipulation.Illegal.INSTANCE
                 : STATIC.new AccessDispatcher(fieldList.getOnly()).getter();

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringFieldMatcher.java
Patch:
@@ -13,14 +13,14 @@ public class DeclaringFieldMatcher<T extends TypeDescription> extends ElementMat
     /**
      * The field matcher to apply to the declared fields of the matched type description.
      */
-    private final ElementMatcher<? super FieldList> fieldMatcher;
+    private final ElementMatcher<? super FieldList<?>> fieldMatcher;
 
     /**
      * Creates a new matcher for a type's declared fields.
      *
      * @param fieldMatcher The field matcher to apply to the declared fields of the matched type description.
      */
-    public DeclaringFieldMatcher(ElementMatcher<? super FieldList> fieldMatcher) {
+    public DeclaringFieldMatcher(ElementMatcher<? super FieldList<?>> fieldMatcher) {
         this.fieldMatcher = fieldMatcher;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringMethodMatcher.java
Patch:
@@ -13,14 +13,14 @@ public class DeclaringMethodMatcher<T extends TypeDescription> extends ElementMa
     /**
      * The field matcher to apply to the declared fields of the matched type description.
      */
-    private final ElementMatcher<? super MethodList> methodMatcher;
+    private final ElementMatcher<? super MethodList<?>> methodMatcher;
 
     /**
      * Creates a new matcher for a type's declared methods.
      *
      * @param methodMatcher The method matcher to apply to the declared methods of the matched type description.
      */
-    public DeclaringMethodMatcher(ElementMatcher<? super MethodList> methodMatcher) {
+    public DeclaringMethodMatcher(ElementMatcher<? super MethodList<?>> methodMatcher) {
         this.methodMatcher = methodMatcher;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -973,7 +973,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> takesGene
      * @return A matcher that matches a method description by the number of its parameters.
      */
     public static <T extends MethodDescription> ElementMatcher.Junction<T> takesArguments(int length) {
-        return new MethodParameterMatcher<T>(new CollectionSizeMatcher<ParameterList>(length));
+        return new MethodParameterMatcher<T>(new CollectionSizeMatcher<ParameterList<?>>(length));
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterMatcher.java
Patch:
@@ -13,14 +13,14 @@ public class MethodParameterMatcher<T extends MethodDescription> extends Element
     /**
      * The matcher to apply to the parameters.
      */
-    private final ElementMatcher<? super ParameterList> parameterMatcher;
+    private final ElementMatcher<? super ParameterList<?>> parameterMatcher;
 
     /**
      * Creates a new matcher for a method's parameters.
      *
      * @param parameterMatcher The matcher to apply to the parameters.
      */
-    public MethodParameterMatcher(ElementMatcher<? super ParameterList> parameterMatcher) {
+    public MethodParameterMatcher(ElementMatcher<? super ParameterList<?>> parameterMatcher) {
         this.parameterMatcher = parameterMatcher;
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericTypeDescriptionVisitorTypeVariableErasingTest.java
Patch:
@@ -8,5 +8,6 @@ public class GenericTypeDescriptionVisitorTypeVariableErasingTest {
     @Test
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(GenericTypeDescription.Visitor.TypeVariableErasing.class).apply();
+        ObjectPropertyAssertion.of(GenericTypeDescription.Visitor.TypeVariableErasing.PartialErasureReviser.class).apply();
     }
 }
\ No newline at end of file

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategyTest.java
Patch:
@@ -51,8 +51,7 @@ public void testFromAgentClassReloadingStrategy() throws Exception {
 
     @Test
     @ToolsJarRule.Enforce
-    @Ignore("Requires expanded frames")
-    public void testClassRedefinitionRenamingWihFrameChange() throws Exception {
+    public void testClassRedefinitionRenamingWithStackMapFrames() throws Exception {
         assertThat(ByteBuddyAgent.installOnOpenJDK(), instanceOf(Instrumentation.class));
         ClassReloadingStrategy classReloadingStrategy = ClassReloadingStrategy.fromInstalledAgent();
         Bar bar = new Bar();

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -120,7 +120,7 @@ public void testTutorialGettingStartedNamingStrategy() throws Exception {
                 .make();
         assertThat(dynamicType, notNullValue());
         Class<?> type = dynamicType.load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER).getLoaded();
-        assertThat(type.getName(), is("i.heart.ByteBuddy.Object"));
+        assertThat(type.getName(), is("i.love.ByteBuddy.Object"));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -5244,7 +5244,7 @@ public S load() throws ClassNotFoundException {
                 public S load(ClassLoader classLoader) throws ClassNotFoundException {
                     return (S) Proxy.newProxyInstance(classLoader,
                             new Class<?>[]{annotationType},
-                            AnnotationInvocationHandler.of(annotationType.getClassLoader(), annotationType, values));
+                            AnnotationInvocationHandler.of(classLoader, annotationType, values));
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/GenericTypeDescription.java
Patch:
@@ -555,7 +555,7 @@ public SignatureVisitor onParameterizedType(GenericTypeDescription parameterized
              */
             private void onOwnableType(GenericTypeDescription genericTypeDescription) {
                 GenericTypeDescription ownerType = genericTypeDescription.getOwnerType();
-                if (ownerType != null) {
+                if (ownerType != null && ownerType.getSort().isParameterized()) {
                     onOwnableType(ownerType);
                     signatureVisitor.visitInnerClassType(genericTypeDescription.asRawType().getSimpleName());
                 } else {
@@ -622,9 +622,9 @@ public SignatureVisitor onWildcardType(GenericTypeDescription wildcardType) {
                     if (lowerBounds.isEmpty() && upperBounds.getOnly().asRawType().represents(Object.class)) {
                         signatureVisitor.visitTypeArgument();
                     } else if (!lowerBounds.isEmpty() /* && upperBounds.isEmpty() */) {
-                        lowerBounds.getOnly().accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.EXTENDS)));
+                        lowerBounds.getOnly().accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.SUPER)));
                     } else /* if (!upperBounds.isEmpty() && lowerBounds.isEmpty()) */ {
-                        upperBounds.getOnly().accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.SUPER)));
+                        upperBounds.getOnly().accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.EXTENDS)));
                     }
                     return signatureVisitor;
                 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractPackageDescriptionTest.java
Patch:
@@ -1,8 +1,8 @@
 package net.bytebuddy.description.type;
 
 import net.bytebuddy.description.annotation.AnnotationList;
-import net.bytebuddy.test.pkg.Sample;
-import net.bytebuddy.test.pkg.child.Child;
+import net.bytebuddy.test.visibility.Sample;
+import net.bytebuddy.test.visibility.child.Child;
 import org.junit.Test;
 
 import static org.hamcrest.CoreMatchers.*;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilderTest.java
Patch:
@@ -12,8 +12,8 @@
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.implementation.StubMethod;
 import net.bytebuddy.implementation.SuperMethodCall;
-import net.bytebuddy.test.pkg.PkgAnnotation;
-import net.bytebuddy.test.pkg.Sample;
+import net.bytebuddy.test.visibility.PackageAnnotation;
+import net.bytebuddy.test.visibility.Sample;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.hamcrest.CoreMatchers;
 import org.junit.Test;
@@ -111,7 +111,7 @@ public void testPackageRebasement() throws Exception {
         assertThat(packageType.getDeclaredFields().length, CoreMatchers.is(0));
         assertThat(packageType.getDeclaredMethods().length, CoreMatchers.is(0));
         assertThat(packageType.getDeclaredAnnotations().length, CoreMatchers.is(2));
-        assertThat(packageType.getAnnotation(PkgAnnotation.class), notNullValue(PkgAnnotation.class));
+        assertThat(packageType.getAnnotation(PackageAnnotation.class), notNullValue(PackageAnnotation.class));
         assertThat(packageType.getAnnotation(Baz.class), notNullValue(Baz.class));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/pkg/package-info.java
Patch:
@@ -1 +0,0 @@
-@PkgAnnotation package net.bytebuddy.test.pkg;

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/visibility/PackageAnnotation.java
Patch:
@@ -1,9 +1,9 @@
-package net.bytebuddy.test.pkg;
+package net.bytebuddy.test.visibility;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
 @Retention(RetentionPolicy.RUNTIME)
-public @interface PkgAnnotation {
+public @interface PackageAnnotation {
     /* empty */
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/visibility/package-info.java
Patch:
@@ -0,0 +1 @@
+@PackageAnnotation package net.bytebuddy.test.visibility;

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/FilterableListEmptyTest.java
Patch:
@@ -5,6 +5,7 @@
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
 
 public class FilterableListEmptyTest {
 
@@ -16,7 +17,7 @@ public void testGet() throws Exception {
         empty.get(0);
     }
 
-    @Test(expected = IndexOutOfBoundsException.class)
+    @Test(expected = IllegalStateException.class)
     public void testGetOnly() throws Exception {
         empty.getOnly();
     }
@@ -29,7 +30,7 @@ public void testSize() throws Exception {
     @Test
     @SuppressWarnings("unchecked")
     public void testFilter() throws Exception {
-        assertThat(empty.filter(any(ElementMatcher.class)), is(empty));
+        assertThat(empty.filter(mock(ElementMatcher.class)), is(empty));
     }
 
     @Test

File: byte-buddy-android/src/test/java/net/bytebuddy/android/AndroidClassLoadingStrategyTest.java
Patch:
@@ -111,7 +111,7 @@ public void testObjectProperties() throws Exception {
             public File create() {
                 return folder;
             }
-        }).applyMutable();
+        }).applyBasic();
         ObjectPropertyAssertion.of(AndroidClassLoadingStrategy.DexProcessor.ForSdkCompiler.class).apply();
         ObjectPropertyAssertion.of(AndroidClassLoadingStrategy.DexProcessor.ForSdkCompiler.Conversion.class).create(new ObjectPropertyAssertion.Creator<DexFile>() {
             @Override

File: byte-buddy-android/src/test/java/net/bytebuddy/test/utility/ObjectPropertyAssertion.java
Patch:
@@ -190,7 +190,7 @@ private void checkString(T instance) {
         } while ((currentType = currentType.getSuperclass()) != Object.class);
     }
 
-    public void applyMutable() throws IllegalAccessException, InvocationTargetException, InstantiationException {
+    public void applyBasic() throws IllegalAccessException, InvocationTargetException, InstantiationException {
         for (Constructor<?> constructor : type.getDeclaredConstructors()) {
             if (constructor.isSynthetic() && skipSynthetic) {
                 continue;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/ClassFileLocator.java
Patch:
@@ -181,7 +181,7 @@ public static ClassFileLocator ofClassPath() {
         /**
          * Creates a class file locator for a given class loader.
          *
-         * @param classLoader The class loader to be used. If this class loader represents the bootstrap class
+         * @param classLoader The class loader to be used. If this class loader representedBy the bootstrap class
          *                    loader which is represented by the {@code null} value, this system class loader
          *                    is used instead.
          * @return A corresponding source locator.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassInjector.java
Patch:
@@ -274,12 +274,12 @@ protected Faulty(Exception exception) {
 
                 @Override
                 public Method getFindLoadedClassMethod() {
-                    throw new RuntimeException(MESSAGE, exception);
+                    throw new IllegalStateException(MESSAGE, exception);
                 }
 
                 @Override
                 public Method getLoadByteArrayMethod() {
-                    throw new RuntimeException(MESSAGE, exception);
+                    throw new IllegalStateException(MESSAGE, exception);
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassLoadingStrategy.java
Patch:
@@ -43,7 +43,8 @@ public Map<TypeDescription, Class<?>> load(ClassLoader classLoader, Map<TypeDesc
                 return ByteArrayClassLoader.load(classLoader,
                         types,
                         DEFAULT_PROTECTION_DOMAIN,
-                        ByteArrayClassLoader.PersistenceHandler.LATENT, PARENT_FIRST);
+                        ByteArrayClassLoader.PersistenceHandler.LATENT,
+                        PARENT_FIRST);
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -297,9 +297,9 @@ protected abstract void apply(Instrumentation instrumentation,
                                       Map<Class<?>, ClassDefinition> classDefinitions) throws UnmodifiableClassException, ClassNotFoundException;
 
         /**
-         * Returns {@code true} if this engine represents {@link net.bytebuddy.dynamic.loading.ClassReloadingStrategy.Engine#REDEFINITION}.
+         * Returns {@code true} if this engine representedBy {@link net.bytebuddy.dynamic.loading.ClassReloadingStrategy.Engine#REDEFINITION}.
          *
-         * @return {@code true} if this engine represents {@link net.bytebuddy.dynamic.loading.ClassReloadingStrategy.Engine#REDEFINITION}.
+         * @return {@code true} if this engine representedBy {@link net.bytebuddy.dynamic.loading.ClassReloadingStrategy.Engine#REDEFINITION}.
          */
         public boolean isRedefinition() {
             return redefinition;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * This package contains classes and interfaces that are connected to writing the byte stream that represents a Java
+ * This package contains classes and interfaces that are connected to writing the byte stream that representedBy a Java
  * type that is dynamically created and for loading this type into a running JVM process.
  */
 package net.bytebuddy.dynamic;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/InliningImplementationMatcher.java
Patch:
@@ -50,8 +50,8 @@ protected static LatentMethodMatcher of(ElementMatcher<? super MethodDescription
             ElementMatcher.Junction<MethodDescription> signature = methodDescription.isConstructor()
                     ? isConstructor()
                     : ElementMatchers.<MethodDescription>named(methodDescription.getName());
-            signature = signature.and(returns(methodDescription.getReturnType()));
-            signature = signature.and(takesArguments(methodDescription.getParameters().asTypeList()));
+            signature = signature.and(returns(methodDescription.getReturnType().asRawType()));
+            signature = signature.and(takesArguments(methodDescription.getParameters().asTypeList().asRawTypes()));
             predefinedMethodSignatures = predefinedMethodSignatures.or(signature);
         }
         return new InliningImplementationMatcher(ignoredMethods, predefinedMethodSignatures);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/LoadedTypeInitializer.java
Patch:
@@ -127,9 +127,9 @@ public void onLoad(Class<?> type) {
                 }
                 field.set(STATIC_FIELD, value);
             } catch (IllegalAccessException e) {
-                throw new IllegalArgumentException(String.format("Could not access field %s on %s", fieldName, type), e);
+                throw new IllegalArgumentException("Cannot access " + fieldName + " from " + type, e);
             } catch (NoSuchFieldException e) {
-                throw new IllegalStateException(String.format("There is no field %s defined for %s", fieldName, type), e);
+                throw new IllegalStateException("There is no field " + fieldName + " defined on " + type, e);
             }
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/StubMethod.java
Patch:
@@ -41,8 +41,8 @@ public Size apply(MethodVisitor methodVisitor,
                       Context implementationContext,
                       MethodDescription instrumentedMethod) {
         StackManipulation.Size stackSize = new StackManipulation.Compound(
-                DefaultValue.of(instrumentedMethod.getReturnType()),
-                MethodReturn.returning(instrumentedMethod.getReturnType())
+                DefaultValue.of(instrumentedMethod.getReturnType().asRawType()),
+                MethodReturn.returning(instrumentedMethod.getReturnType().asRawType())
         ).apply(methodVisitor, implementationContext);
         return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/FieldAttributeAppender.java
Patch:
@@ -69,7 +69,7 @@ interface Factory {
         class Compound implements Factory {
 
             /**
-             * The factories that this compound factory represents in their application order.
+             * The factories that this compound factory representedBy in their application order.
              */
             private final Factory[] factory;
 
@@ -250,7 +250,7 @@ public String toString() {
     class Compound implements FieldAttributeAppender {
 
         /**
-         * The field attribute appenders this appender represents in their application order.
+         * The field attribute appenders this appender representedBy in their application order.
          */
         private final FieldAttributeAppender[] fieldAttributeAppender;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/MethodAttributeAppender.java
Patch:
@@ -133,7 +133,7 @@ interface Factory {
         class Compound implements Factory {
 
             /**
-             * The factories this compound factory represents in their application order.
+             * The factories this compound factory representedBy in their application order.
              */
             private final Factory[] factory;
 
@@ -289,7 +289,7 @@ protected interface Target {
              *                          attribute appender are written to.
              * @param methodDescription The description of the method for which the given method visitor creates an
              *                          instrumentation for.
-             * @return The target of the annotation appender this target represents.
+             * @return The target of the annotation appender this target representedBy.
              */
             AnnotationAppender.Target make(MethodVisitor methodVisitor, MethodDescription methodDescription);
 
@@ -460,7 +460,7 @@ public String toString() {
     class Compound implements MethodAttributeAppender {
 
         /**
-         * The method attribute appenders this compound appender represents in their application order.
+         * The method attribute appenders this compound appender representedBy in their application order.
          */
         private final MethodAttributeAppender[] methodAttributeAppender;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/TypeAttributeAppender.java
Patch:
@@ -65,7 +65,7 @@ public ForSuperType(AnnotationAppender.ValueFilter valueFilter) {
         @Override
         public void apply(ClassVisitor classVisitor, TypeDescription typeDescription) {
             AnnotationAppender annotationAppender = new AnnotationAppender.Default(new AnnotationAppender.Target.OnType(classVisitor), valueFilter);
-            for (AnnotationDescription annotation : typeDescription.getSupertype().getDeclaredAnnotations()) {
+            for (AnnotationDescription annotation : typeDescription.getSuperType().asRawType().getDeclaredAnnotations()) {
                 annotationAppender.append(annotation, AnnotationAppender.AnnotationVisibility.of(annotation));
             }
         }
@@ -213,7 +213,7 @@ public String toString() {
     class Compound implements TypeAttributeAppender {
 
         /**
-         * The type attribute appenders this compound appender represents in their application order.
+         * The type attribute appenders this compound appender representedBy in their application order.
          */
         private final TypeAttributeAppender[] typeAttributeAppender;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/AuxiliaryType.java
Patch:
@@ -26,7 +26,7 @@ public interface AuxiliaryType {
     /**
      * Creates a new auxiliary type.
      *
-     * @param auxiliaryTypeName     The fully qualified non-internal name for this auxiliary type. The type should be in
+     * @param auxiliaryTypeName     The fully qualified binary name for this auxiliary type. The type should be in
      *                              the same package than the instrumented type this auxiliary type is providing services
      *                              to in order to allow package-private access.
      * @param classFileVersion      The class file version the auxiliary class should be written in.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/DeclaringTypeResolver.java
Patch:
@@ -18,8 +18,8 @@ public enum DeclaringTypeResolver implements MethodDelegationBinder.AmbiguityRes
     public Resolution resolve(MethodDescription source,
                               MethodDelegationBinder.MethodBinding left,
                               MethodDelegationBinder.MethodBinding right) {
-        TypeDescription leftType = left.getTarget().getDeclaringType();
-        TypeDescription rightType = right.getTarget().getDeclaringType();
+        TypeDescription leftType = left.getTarget().getDeclaringType().asRawType();
+        TypeDescription rightType = right.getTarget().getDeclaringType().asRawType();
         if (leftType.equals(rightType)) {
             return Resolution.AMBIGUOUS;
         } else if (leftType.isAssignableFrom(rightType)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Default.java
Patch:
@@ -54,12 +54,12 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            if (!target.getTypeDescription().isInterface()) {
+            if (!target.getType().asRawType().isInterface()) {
                 throw new IllegalStateException(target + " uses the @Default annotation on a non-interface type");
-            } else if (source.isStatic() || !implementationTarget.getTypeDescription().getInterfaces().contains(target.getTypeDescription())) {
+            } else if (source.isStatic() || !implementationTarget.getTypeDescription().getInterfaces().asRawTypes().contains(target.getType().asRawType())) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             } else {
-                return new MethodDelegationBinder.ParameterBinding.Anonymous(new TypeProxy.ForDefaultMethod(target.getTypeDescription(),
+                return new MethodDelegationBinder.ParameterBinding.Anonymous(new TypeProxy.ForDefaultMethod(target.getType().asRawType(),
                         implementationTarget,
                         annotation.loadSilent().serializableProxy()));
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Empty.java
Patch:
@@ -43,7 +43,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            return new MethodDelegationBinder.ParameterBinding.Anonymous(DefaultValue.of(target.getTypeDescription()));
+            return new MethodDelegationBinder.ParameterBinding.Anonymous(DefaultValue.of(target.getType().asRawType()));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Origin.java
Patch:
@@ -75,7 +75,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            TypeDescription parameterType = target.getTypeDescription();
+            TypeDescription parameterType = target.getType().asRawType();
             if (parameterType.represents(Class.class)) {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(ClassConstant.of(implementationTarget.getOriginType()));
             } else if (parameterType.represents(Method.class)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperCall.java
Patch:
@@ -69,17 +69,17 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            TypeDescription targetType = target.getTypeDescription();
+            TypeDescription targetType = target.getType().asRawType();
             if (!targetType.represents(Runnable.class) && !targetType.represents(Callable.class) && !targetType.represents(Object.class)) {
                 throw new IllegalStateException("A super method call proxy can only be assigned to Runnable or Callable types: " + target);
             }
             Implementation.SpecialMethodInvocation specialMethodInvocation = implementationTarget.invokeSuper(source,
                     Implementation.Target.MethodLookup.Default.EXACT);
             if (!specialMethodInvocation.isValid()
                     && source.isDefaultMethod()
-                    && implementationTarget.getTypeDescription().getInterfaces().contains(source.getDeclaringType())
+                    && implementationTarget.getTypeDescription().getInterfaces().asRawTypes().contains(source.getDeclaringType().asRawType())
                     && annotation.loadSilent().fallbackToDefault()) {
-                specialMethodInvocation = implementationTarget.invokeDefault(source.getDeclaringType(), source.getUniqueSignature());
+                specialMethodInvocation = implementationTarget.invokeDefault(source.getDeclaringType().asRawType(), source.asToken());
             }
             return specialMethodInvocation.isValid()
                     ? new MethodDelegationBinder.ParameterBinding.Anonymous(new MethodCallProxy.AssignableSignatureCall(specialMethodInvocation, annotation.loadSilent().serializableProxy()))

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/ByteCodeAppender.java
Patch:
@@ -150,7 +150,7 @@ public String toString() {
     }
 
     /**
-     * A simple byte code appender that only represents a given array of
+     * A simple byte code appender that only representedBy a given array of
      * {@link StackManipulation}s.
      */
     class Simple implements ByteCodeAppender {
@@ -161,7 +161,7 @@ class Simple implements ByteCodeAppender {
         private final StackManipulation stackManipulation;
 
         /**
-         * Creates a new simple byte code appender which represents the given stack manipulation.
+         * Creates a new simple byte code appender which representedBy the given stack manipulation.
          *
          * @param stackManipulation The stack manipulations to apply for this byte code appender in their application
          *                          order.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Duplication.java
Patch:
@@ -36,15 +36,15 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
     private final Size size;
 
     /**
-     * The opcode that represents the manipulation.
+     * The opcode that representedBy the manipulation.
      */
     private final int opcode;
 
     /**
      * Creates a new duplication.
      *
      * @param stackSize The size representing the impact of applying the duplication onto the operand stack.
-     * @param opcode    The opcode that represents the manipulation.
+     * @param opcode    The opcode that representedBy the manipulation.
      */
     Duplication(StackSize stackSize, int opcode) {
         size = stackSize.toIncreasingSize();

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/Removal.java
Patch:
@@ -55,7 +55,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
      * Removes a value from the operand stack dependant of its size.
      *
      * @param typeDescription The type to remove from the stack.
-     * @return A stack manipulation that represents the removal.
+     * @return A stack manipulation that representedBy the removal.
      */
     public static StackManipulation pop(TypeDescription typeDescription) {
         switch (typeDescription.getStackSize()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/StackManipulation.java
Patch:
@@ -174,7 +174,7 @@ public String toString() {
     class Compound implements StackManipulation {
 
         /**
-         * The stack manipulations this compound operation represents in their application order.
+         * The stack manipulations this compound operation representedBy in their application order.
          */
         private final StackManipulation[] stackManipulation;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/StackSize.java
Patch:
@@ -21,14 +21,14 @@ public enum StackSize {
     DOUBLE(2);
 
     /**
-     * The size of the stack this instance represents.
+     * The size of the stack this instance representedBy.
      */
     private final int size;
 
     /**
      * Creates a new stack size.
      *
-     * @param size The size of the stack this instance represents.
+     * @param size The size of the stack this instance representedBy.
      */
     StackSize(int size) {
         this.size = size;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/TypeCreation.java
Patch:
@@ -28,7 +28,7 @@ protected TypeCreation(TypeDescription typeDescription) {
      * Creates a type creation for the given type.
      *
      * @param typeDescription The type to be create.
-     * @return A stack manipulation that represents the creation of the given type.
+     * @return A stack manipulation that representedBy the creation of the given type.
      */
     public static StackManipulation forType(TypeDescription typeDescription) {
         if (typeDescription.isArray() || typeDescription.isPrimitive() || typeDescription.isAbstract()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/TypeCasting.java
Patch:
@@ -17,7 +17,7 @@ public class TypeCasting implements StackManipulation {
      * Creates a casting to the given, non-primitive type.
      *
      * @param typeDescription The type to which a value should be casted.
-     * @return A stack manipulation that represents the casting.
+     * @return A stack manipulation that representedBy the casting.
      */
     public static StackManipulation to(TypeDescription typeDescription) {
         if (typeDescription.isPrimitive()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveBoxingDelegate.java
Patch:
@@ -126,7 +126,7 @@ public static PrimitiveBoxingDelegate forPrimitive(TypeDescription typeDescripti
      * @param targetType       The type that is target of the assignment operation.
      * @param chainedAssigner  The assigner that is to be used to perform the chained assignment.
      * @param dynamicallyTyped If {@code true}, unsafe cast operations are allowed for performing an assignment.
-     * @return A stack manipulation that represents the described assignment operation.
+     * @return A stack manipulation that representedBy the described assignment operation.
      */
     public StackManipulation assignBoxedTo(TypeDescription targetType, Assigner chainedAssigner, boolean dynamicallyTyped) {
         return new BoxingStackManipulation(chainedAssigner.assign(wrapperType, targetType, dynamicallyTyped));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/assign/primitive/PrimitiveUnboxingDelegate.java
Patch:
@@ -130,7 +130,7 @@ protected static PrimitiveUnboxingDelegate forPrimitive(TypeDescription typeDesc
     /**
      * Creates an unboxing responsible that is capable of unboxing a wrapper type.
      * <ol>
-     * <li>If the reference type represents a wrapper type, the wrapper type will simply be unboxed.</li>
+     * <li>If the reference type representedBy a wrapper type, the wrapper type will simply be unboxed.</li>
      * <li>If the reference type does not represent a wrapper type, the wrapper type will be inferred by the primitive target
      * type that is later given to the
      * {@link net.bytebuddy.implementation.bytecode.assign.primitive.PrimitiveUnboxingDelegate.UnboxingResponsible}

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/ClassConstant.java
Patch:
@@ -89,7 +89,7 @@ public enum ClassConstant implements StackManipulation {
 
     /**
      * Returns a stack manipulation that loads a {@link java.lang.Class} type onto the operand stack which
-     * represents the given type.
+     * representedBy the given type.
      *
      * @param typeDescription The type to load onto the operand stack.
      * @return The corresponding stack manipulation.
@@ -145,7 +145,7 @@ protected static class ForReferenceType implements StackManipulation {
         private final TypeDescription typeDescription;
 
         /**
-         * Creates a stack manipulation that represents loading a class constant onto the stack.
+         * Creates a stack manipulation that representedBy loading a class constant onto the stack.
          *
          * @param typeDescription A description of the class to load onto the stack.
          */

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/DefaultValue.java
Patch:
@@ -42,14 +42,14 @@ public enum DefaultValue implements StackManipulation {
     ANY_REFERENCE(NullConstant.INSTANCE);
 
     /**
-     * The stack manipulation that represents the loading of a given default value onto the operand stack.
+     * The stack manipulation that representedBy the loading of a given default value onto the operand stack.
      */
     private final StackManipulation stackManipulation;
 
     /**
      * Creates a new default value load operation.
      *
-     * @param stackManipulation The stack manipulation that represents the loading of a given default value onto the
+     * @param stackManipulation The stack manipulation that representedBy the loading of a given default value onto the
      *                          operand stack.
      */
     DefaultValue(StackManipulation stackManipulation) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodConstant.java
Patch:
@@ -80,7 +80,7 @@ public boolean isValid() {
     public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
         Size argumentSize = prepare(methodVisitor)
                 .aggregate(ArrayFactory.forType(TypeDescription.CLASS)
-                        .withValues(typeConstantsFor(methodDescription.getParameters().asTypeList()))
+                        .withValues(typeConstantsFor(methodDescription.getParameters().asTypeList().asRawTypes()))
                         .apply(methodVisitor, implementationContext));
         methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                 CLASS_TYPE_INTERNAL_NAME,
@@ -210,7 +210,7 @@ protected ForMethod(MethodDescription methodDescription) {
 
         @Override
         protected Size prepare(MethodVisitor methodVisitor) {
-            methodVisitor.visitLdcInsn(Type.getType(methodDescription.getDeclaringType().getDescriptor()));
+            methodVisitor.visitLdcInsn(Type.getType(methodDescription.getDeclaringType().asRawType().getDescriptor()));
             methodVisitor.visitLdcInsn(methodDescription.getInternalName());
             return new Size(2, 2);
         }
@@ -260,7 +260,7 @@ protected ForConstructor(MethodDescription methodDescription) {
 
         @Override
         protected Size prepare(MethodVisitor methodVisitor) {
-            methodVisitor.visitLdcInsn(Type.getType(methodDescription.getDeclaringType().getDescriptor()));
+            methodVisitor.visitLdcInsn(Type.getType(methodDescription.getDeclaringType().asRawType().getDescriptor()));
             return new Size(1, 1);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/FieldAccess.java
Patch:
@@ -191,10 +191,10 @@ public boolean isValid() {
             @Override
             public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                 methodVisitor.visitFieldInsn(getOpcode(),
-                        fieldDescription.getDeclaringType().getInternalName(),
+                        fieldDescription.getDeclaringType().asRawType().getInternalName(),
                         fieldDescription.getInternalName(),
                         fieldDescription.getDescriptor());
-                return resolveSize(fieldDescription.getFieldType().getStackSize());
+                return resolveSize(fieldDescription.getType().getStackSize());
             }
 
             /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodExceptionTypeMatcher.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.method.MethodDescription;
-import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.generic.GenericTypeList;
 
 /**
  * An element matcher that matches the exceptions that are declared by a method.
@@ -13,14 +13,14 @@ public class MethodExceptionTypeMatcher<T extends MethodDescription> extends Ele
     /**
      * The matcher to apply to the matched method's exceptions.
      */
-    private final ElementMatcher<? super TypeList> exceptionMatcher;
+    private final ElementMatcher<? super GenericTypeList> exceptionMatcher;
 
     /**
      * Creates a new matcher for a method's exceptions.
      *
      * @param exceptionMatcher The matcher to apply to the matched method's exceptions.
      */
-    public MethodExceptionTypeMatcher(ElementMatcher<? super TypeList> exceptionMatcher) {
+    public MethodExceptionTypeMatcher(ElementMatcher<? super GenericTypeList> exceptionMatcher) {
         this.exceptionMatcher = exceptionMatcher;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypeMatcher.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.method.ParameterList;
-import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.generic.GenericTypeList;
 
 /**
  * An element matcher that matches a method's parameter types.
@@ -13,14 +13,14 @@ public class MethodParameterTypeMatcher<T extends ParameterList> extends Element
     /**
      * The matcher to apply to the parameter types.
      */
-    private final ElementMatcher<? super TypeList> parameterMatcher;
+    private final ElementMatcher<? super GenericTypeList> parameterMatcher;
 
     /**
      * Creates a new matcher for a method's parameter types.
      *
      * @param parameterMatcher The matcher to apply to the parameter types.
      */
-    public MethodParameterTypeMatcher(ElementMatcher<? super TypeList> parameterMatcher) {
+    public MethodParameterTypeMatcher(ElementMatcher<? super GenericTypeList> parameterMatcher) {
         this.parameterMatcher = parameterMatcher;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodReturnTypeMatcher.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.method.MethodDescription;
-import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 /**
  * An element matcher that matches its argument's return type against a given type matcher.
@@ -13,14 +13,14 @@ public class MethodReturnTypeMatcher<T extends MethodDescription> extends Elemen
     /**
      * The type matcher to apply to the matched element's return type.
      */
-    private final ElementMatcher<? super TypeDescription> typeMatcher;
+    private final ElementMatcher<? super GenericTypeDescription> typeMatcher;
 
     /**
      * Creates a new matcher for a matched element's return type.
      *
      * @param typeMatcher The type matcher to apply to the matched element's return type.
      */
-    public MethodReturnTypeMatcher(ElementMatcher<? super TypeDescription> typeMatcher) {
+    public MethodReturnTypeMatcher(ElementMatcher<? super GenericTypeDescription> typeMatcher) {
         this.typeMatcher = typeMatcher;
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTest.java
Patch:
@@ -4,6 +4,7 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.modifier.ModifierContributor;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.BridgeMethodResolver;
 import net.bytebuddy.dynamic.scaffold.MethodLookupEngine;
 import net.bytebuddy.implementation.Implementation;
@@ -76,6 +77,8 @@ public class ByteBuddyTest {
     public void setUp() throws Exception {
         when(modifierContributorForType.getMask()).thenReturn(MASK);
         when(typeDescription.isInterface()).thenReturn(true);
+        when(typeDescription.asRawType()).thenReturn(typeDescription);
+        when(typeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -202,7 +202,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(AgentBuilder.Default.Transformation.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.Default.BootstrapInjectionStrategy.Enabled.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.Default.BootstrapInjectionStrategy.Disabled.class).apply();
-        ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.class).applyMutable();
+        ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.class).applyBasic();
         final Iterator<Class<?>> iterator = Arrays.<Class<?>>asList(Object.class, AgentBuilderDefaultTest.class).iterator();
         ObjectPropertyAssertion.of(AgentBuilder.Default.InitializationStrategy.SelfInjection.Nexus.class).create(new ObjectPropertyAssertion.Creator<Class<?>>() {
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/modifier/ModifierConstributorObjectPropertiesTest.java
Patch:
@@ -12,6 +12,8 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(MethodArguments.class).apply();
         ObjectPropertyAssertion.of(MethodManifestation.class).apply();
         ObjectPropertyAssertion.of(Ownership.class).apply();
+        ObjectPropertyAssertion.of(ParameterManifestation.class).apply();
+        ObjectPropertyAssertion.of(ProvisioningState.class).apply();
         ObjectPropertyAssertion.of(SynchronizationState.class).apply();
         ObjectPropertyAssertion.of(SyntheticState.class).apply();
         ObjectPropertyAssertion.of(TypeManifestation.class).apply();

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringTypeMatcher.java
Patch:
@@ -1,7 +1,6 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.DeclaredByType;
-import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -295,12 +295,12 @@ abstract class AbstractTypeDescription extends AbstractModifierReviewable implem
 
         @Override
         public GenericTypeDescription getSuperType() {
-            return GenericTypeDescription.ForParameterizedType.Raw.resolve(getDeclaredSuperType(), GenericTypeDescription.Visitor.NoOp.INSTANCE);
+            return LazyProjection.OfUntransformedType.of(getDeclaredSuperType(), GenericTypeDescription.Visitor.NoOp.INSTANCE);
         }
 
         @Override
         public GenericTypeList getInterfaces() {
-            return new GenericTypeList.PotentiallyRaw(getDeclaredInterfaces(), GenericTypeDescription.Visitor.NoOp.INSTANCE);
+            return new GenericTypeList.OfUntransformedType(getDeclaredInterfaces(), GenericTypeDescription.Visitor.NoOp.INSTANCE);
         }
 
         @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDefaultTest.java
Patch:
@@ -114,6 +114,7 @@ public void setUp() throws Exception {
         firstSpecialExceptionTypes = new GenericTypeList.Explicit(Collections.singletonList(firstSpecialExceptionType));
         secondSpecialExceptionTypes = new GenericTypeList.Explicit(Collections.singletonList(secondSpecialExceptionType));
         when(instrumentedType.getInternalName()).thenReturn(BAZ);
+        when(instrumentedType.asRawType()).thenReturn(instrumentedType);
         when(methodPool.target(any(MethodDescription.class))).thenReturn(entry);
         when(auxiliaryType.make(any(String.class), any(ClassFileVersion.class), any(AuxiliaryType.MethodAccessorFactory.class)))
                 .thenReturn(firstDynamicType);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1627,7 +1627,7 @@ public ExceptionDeclarableMethodInterception<S> defineMethod(String name,
                         resolveModifierContributors(METHOD_MODIFIER_MASK, nonNull(modifier)),
                         Collections.<GenericTypeDescription>emptyList(),
                         nonNull(returnType),
-                        ParameterDescription.Token.asList(isActualType(parameterTypes)),
+                        new ParameterDescription.Token.TypeList(isActualType(parameterTypes)),
                         Collections.<TypeDescription>emptyList(),
                         Collections.<AnnotationDescription>emptyList(),
                         null));
@@ -1669,7 +1669,7 @@ public ExceptionDeclarableMethodInterception<S> defineMethod(String name,
                         modifiers,
                         Collections.<GenericTypeDescription>emptyList(),
                         nonNull(returnType),
-                        ParameterDescription.Token.asList(isActualType(parameterTypes)),
+                        new ParameterDescription.Token.TypeList(isActualType(parameterTypes)),
                         Collections.<TypeDescription>emptyList(),
                         Collections.<AnnotationDescription>emptyList(),
                         null));
@@ -1706,7 +1706,7 @@ public ExceptionDeclarableMethodInterception<S> defineConstructor(List<? extends
                         modifiers,
                         Collections.<GenericTypeDescription>emptyList(),
                         TypeDescription.VOID,
-                        ParameterDescription.Token.asList(isActualType(parameterTypes)),
+                        new ParameterDescription.Token.TypeList(isActualType(parameterTypes)),
                         Collections.<TypeDescription>emptyList(),
                         Collections.<AnnotationDescription>emptyList(),
                         null));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -878,7 +878,7 @@ public static PreparationHandler of(String name, TypeDescription typeDescription
 
                 @Override
                 public InstrumentedType prepare(InstrumentedType instrumentedType) {
-                    return instrumentedType.withField(name, typeDescription, modifiers);
+                    return instrumentedType.withField(new FieldDescription.Token(name, modifiers, typeDescription));
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.implementation;
 
+import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
@@ -425,7 +426,7 @@ public Implementation withAssigner(Assigner assigner, boolean dynamicallyTyped)
         @Override
         public InstrumentedType prepare(InstrumentedType instrumentedType) {
             return instrumentedType
-                    .withField(fieldName, fieldType, Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC)
+                    .withField(new FieldDescription.Token(fieldName, Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC, fieldType))
                     .withInitializer(LoadedTypeInitializer.ForStaticField.nonAccessible(fieldName, fixedValue));
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -1601,7 +1601,7 @@ public Resolved resolve(TypeDescription instrumentedType,
                 @Override
                 public InstrumentedType prepare(InstrumentedType instrumentedType) {
                     return instrumentedType
-                            .withField(name, typeDescription, FIELD_MODIFIER)
+                            .withField(new FieldDescription.Token(name, FIELD_MODIFIER, typeDescription))
                             .withInitializer(LoadedTypeInitializer.ForStaticField.nonAccessible(name, value));
                 }
 
@@ -1673,7 +1673,7 @@ public Resolved resolve(TypeDescription instrumentedType,
 
                 @Override
                 public InstrumentedType prepare(InstrumentedType instrumentedType) {
-                    return instrumentedType.withField(fieldName, fieldType, FIELD_MODIFIER);
+                    return instrumentedType.withField(new FieldDescription.Token(fieldName, FIELD_MODIFIER, fieldType));
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -676,9 +676,9 @@ protected InstanceFieldConstructor(TypeDescription instrumentedType) {
 
             @Override
             public InstrumentedType prepare(InstrumentedType instrumentedType) {
-                return instrumentedType.withField(AccessorProxy.FIELD_NAME,
-                        this.instrumentedType,
-                        Opcodes.ACC_FINAL | Opcodes.ACC_PRIVATE);
+                return instrumentedType.withField(new FieldDescription.Token(AccessorProxy.FIELD_NAME,
+                        Opcodes.ACC_FINAL | Opcodes.ACC_PRIVATE,
+                        this.instrumentedType));
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -532,9 +532,9 @@ protected InstanceFieldConstructor(TypeDescription instrumentedType) {
 
                 @Override
                 public InstrumentedType prepare(InstrumentedType instrumentedType) {
-                    return instrumentedType.withField(RedirectionProxy.FIELD_NAME,
-                            this.instrumentedType,
-                            Opcodes.ACC_FINAL | Opcodes.ACC_PRIVATE);
+                    return instrumentedType.withField(new FieldDescription.Token(RedirectionProxy.FIELD_NAME,
+                            Opcodes.ACC_FINAL | Opcodes.ACC_PRIVATE,
+                            this.instrumentedType));
                 }
 
                 @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/FieldAccessorPreparationTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.implementation;
 
+import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.test.utility.MockitoRule;
@@ -29,14 +30,13 @@ public class FieldAccessorPreparationTest {
 
     @Before
     public void setUp() throws Exception {
-        when(instrumentedType.withField(any(String.class), any(TypeDescription.class), anyInt()))
-                .thenReturn(instrumentedType);
+        when(instrumentedType.withField(any(FieldDescription.Token.class))).thenReturn(instrumentedType);
     }
 
     @Test
     public void testPreparationDefineField() throws Exception {
         assertThat(FieldAccessor.ofField(FOO).defineAs(TYPE).prepare(instrumentedType), is(instrumentedType));
-        verify(instrumentedType).withField(FOO, new TypeDescription.ForLoadedType(TYPE), NO_MODIFIERS);
+        verify(instrumentedType).withField(new FieldDescription.Token(FOO, NO_MODIFIERS, new TypeDescription.ForLoadedType(TYPE)));
         verifyNoMoreInteractions(instrumentedType);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodLookupEngine.java
Patch:
@@ -386,7 +386,7 @@ public GenericTypeDescription getReturnType() {
 
         @Override
         public ParameterList getParameters() {
-            return ParameterList.Explicit.latent(this, methodDescriptions.get(ANY).getParameters().asTypeList().asRawTypes());
+            return new ParameterList.Explicit.ForTypes(this, methodDescriptions.get(ANY).getParameters().asTypeList().asRawTypes());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolver.java
Patch:
@@ -354,7 +354,7 @@ public GenericTypeDescription getReturnType() {
 
                 @Override
                 public ParameterList getParameters() {
-                    return ParameterList.Explicit.latent(this, methodDescription.getParameters().asTypeList().asRawTypes());
+                    return new ParameterList.Explicit.ForTypes(this, methodDescription.getParameters().asTypeList().asRawTypes());
                 }
 
                 @Override
@@ -463,7 +463,7 @@ public GenericTypeDescription getReturnType() {
 
                 @Override
                 public ParameterList getParameters() {
-                    return ParameterList.Explicit.latent(this, join(methodDescription.getParameters().asTypeList().asRawTypes(), placeholderType));
+                    return new ParameterList.Explicit.ForTypes(this, join(methodDescription.getParameters().asTypeList().asRawTypes(), placeholderType));
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -925,7 +925,7 @@ public GenericTypeDescription getReturnType() {
 
                 @Override
                 public ParameterList getParameters() {
-                    return ParameterList.Explicit.latent(this, methodDescription.getParameters().asTypeList().asRawTypes());
+                    return new ParameterList.Explicit.ForTypes(this, methodDescription.getParameters().asTypeList().asRawTypes());
                 }
 
                 @Override
@@ -1049,7 +1049,7 @@ public GenericTypeDescription getReturnType() {
 
                 @Override
                 public ParameterList getParameters() {
-                    return ParameterList.Explicit.latent(this, Collections.singletonList(fieldDescription.getType().asRawType()));
+                    return new ParameterList.Explicit.ForTypes(this, Collections.singletonList(fieldDescription.getType().asRawType()));
                 }
 
                 @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverMethodsOnlyTest.java
Patch:
@@ -53,8 +53,7 @@ public void setUp() throws Exception {
         methodRebaseResolver = new MethodRebaseResolver.MethodsOnly(methodDescriptions, methodNameTransformer);
         when(method.getInternalName()).thenReturn(FOO);
         when(method.getReturnType()).thenReturn(returnType);
-        ParameterList methodParameterList = ParameterList.Explicit.latent(method, Collections.singletonList(parameterType));
-        when(method.getParameters()).thenReturn(methodParameterList);
+        when(method.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(method, Collections.singletonList(parameterType)));
         when(constructor.isConstructor()).thenReturn(true);
         when(methodNameTransformer.transform(method)).thenReturn(BAR);
         when(returnType.asRawType()).thenReturn(returnType); // REFACTOR

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedConstructorTest.java
Patch:
@@ -59,8 +59,7 @@ public void setUp() throws Exception {
         when(methodDescription.getReturnType()).thenReturn(returnType);
         when(parameterType.getStackSize()).thenReturn(StackSize.ZERO);
         when(placeholderType.getStackSize()).thenReturn(StackSize.ZERO);
-        ParameterList parameterList = ParameterList.Explicit.latent(methodDescription, Collections.singletonList(parameterType));
-        when(methodDescription.getParameters()).thenReturn(parameterList);
+        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(methodDescription, Collections.singletonList(parameterType)));
         when(methodDescription.getInternalName()).thenReturn(FOO);
         when(methodDescription.getDescriptor()).thenReturn(QUX);
         when(typeDescription.getInternalName()).thenReturn(BAR);
@@ -80,7 +79,7 @@ public void testPreservation() throws Exception {
         assertThat(resolution.getResolvedMethod().getInternalName(), is(MethodDescription.CONSTRUCTOR_INTERNAL_NAME));
         assertThat(resolution.getResolvedMethod().getModifiers(), is(MethodRebaseResolver.REBASED_METHOD_MODIFIER));
         assertThat(resolution.getResolvedMethod().getReturnType(), is((GenericTypeDescription) TypeDescription.VOID));
-        assertThat(resolution.getResolvedMethod().getParameters(), is(ParameterList.Explicit.latent(resolution.getResolvedMethod(),
+        assertThat(resolution.getResolvedMethod().getParameters(), is((ParameterList) new ParameterList.Explicit.ForTypes(resolution.getResolvedMethod(),
                 Arrays.asList(parameterType, placeholderType))));
         StackManipulation.Size size = resolution.getAdditionalArguments().apply(methodVisitor, implementationContext);
         assertThat(size.getSizeImpact(), is(1));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedMethodTest.java
Patch:
@@ -60,8 +60,7 @@ public void setUp() throws Exception {
         when(methodNameTransformer.transform(methodDescription)).thenReturn(QUX);
         when(otherMethodNameTransformer.transform(methodDescription)).thenReturn(FOO + BAR);
         when(parameterType.getStackSize()).thenReturn(StackSize.ZERO);
-        ParameterList parameterList = ParameterList.Explicit.latent(methodDescription, Collections.singletonList(parameterType));
-        when(methodDescription.getParameters()).thenReturn(parameterList);
+        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(methodDescription, Collections.singletonList(parameterType)));
         when(returnType.asRawType()).thenReturn(returnType); // REFACTOR
         when(returnType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(returnType); // REFACTOR
         when(parameterType.asRawType()).thenReturn(parameterType); // REFACTOR
@@ -76,7 +75,8 @@ public void testPreservation() throws Exception {
         assertThat(resolution.getResolvedMethod().getInternalName(), is(QUX));
         assertThat(resolution.getResolvedMethod().getModifiers(), is(MethodRebaseResolver.REBASED_METHOD_MODIFIER));
         assertThat(resolution.getResolvedMethod().getReturnType(), is((GenericTypeDescription) returnType));
-        assertThat(resolution.getResolvedMethod().getParameters(), is(ParameterList.Explicit.latent(resolution.getResolvedMethod(), Collections.singletonList(parameterType))));
+        assertThat(resolution.getResolvedMethod().getParameters(), is((ParameterList) new ParameterList.Explicit.ForTypes(resolution.getResolvedMethod(),
+                Collections.singletonList(parameterType))));
         StackManipulation.Size size = resolution.getAdditionalArguments().apply(methodVisitor, implementationContext);
         assertThat(size.getSizeImpact(), is(0));
         assertThat(size.getMaximalSize(), is(0));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTargetSpecialMethodInvocationTest.java
Patch:
@@ -37,8 +37,7 @@ protected Implementation.SpecialMethodInvocation make(String name,
         MethodDescription methodDescription = mock(MethodDescription.class);
         when(methodDescription.getInternalName()).thenReturn(name);
         when(methodDescription.getReturnType()).thenReturn(returnType);
-        ParameterList parameterList = ParameterList.Explicit.latent(methodDescription, parameterTypes);
-        when(methodDescription.getParameters()).thenReturn(parameterList);
+        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(methodDescription, parameterTypes));
         TypeDescription declaringType = mock(TypeDescription.class);
         when(declaringType.asRawType()).thenReturn(declaringType);
         when(methodDescription.getDeclaringType()).thenReturn(declaringType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TypeProxyCreationTest.java
Patch:
@@ -73,8 +73,7 @@ public void setUp() throws Exception {
         fooMethods = methodLookupEngine.process(foo)
                 .getInvokableMethods()
                 .filter(isOverridable().and(not(isDefaultFinalizer())));
-        ParameterList parameterList = ParameterList.Explicit.latent(proxyMethod, Arrays.asList(foo, foo, foo));
-        when(proxyMethod.getParameters()).thenReturn(parameterList);
+        when(proxyMethod.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(proxyMethod, Arrays.asList(foo, foo, foo)));
         when(proxyMethod.getDeclaringType()).thenReturn(foo);
         when(proxyMethod.getInternalName()).thenReturn(FOO);
         when(proxyMethod.getDescriptor()).thenReturn(FOO);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ArgumentBinderTest.java
Patch:
@@ -86,8 +86,7 @@ private void assertBinding(boolean dynamicallyTyped,
         }
         when(sourceType.getStackSize()).thenReturn(StackSize.ZERO);
         typeDescriptions.add(sourceIndex, sourceType);
-        ParameterList parameterList = ParameterList.Explicit.latent(source, typeDescriptions);
-        when(source.getParameters()).thenReturn(parameterList);
+        when(source.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(source, typeDescriptions));
         when(source.isStatic()).thenReturn(false);
         when(target.getType()).thenReturn(targetType);
         when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.ForLoadedAnnotation(annotations));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ArgumentNextUnboundAsDefaultBinderTest.java
Patch:
@@ -46,7 +46,7 @@ public class ArgumentNextUnboundAsDefaultBinderTest {
     public void setUp() throws Exception {
         when(firstParameter.getStackSize()).thenReturn(StackSize.ZERO);
         when(secondParameter.getStackSize()).thenReturn(StackSize.ZERO);
-        sourceParameters = ParameterList.Explicit.latent(source, Arrays.asList(firstParameter, secondParameter));
+        sourceParameters = new ParameterList.Explicit.ForTypes(source, Arrays.asList(firstParameter, secondParameter));
         ParameterList targetParameters = new ParameterList.Explicit(Arrays.asList(firstTargetParameter, secondTargetParameter));
         when(source.getParameters()).thenReturn(sourceParameters);
         when(target.getParameters()).thenReturn(targetParameters);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationDynamicTest.java
Patch:
@@ -59,8 +59,7 @@ public void setUp() throws Exception {
         when(methodDescription.getInternalName()).thenReturn(QUX);
         when(methodDescription.getDescriptor()).thenReturn(BAZ);
         when(declaringType.getInternalName()).thenReturn(BAR);
-        ParameterList parameterList = ParameterList.Explicit.latent(methodDescription, Arrays.asList(firstType, secondType));
-        when(methodDescription.getParameters()).thenReturn(parameterList);
+        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(methodDescription, Arrays.asList(firstType, secondType)));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccessDescriptionTest.java
Patch:
@@ -53,8 +53,8 @@ public void setUp() throws Exception {
         when(firstParameterType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(firstParameterType);
         when(secondParameterType.asRawType()).thenReturn(secondParameterType); // REFACTOR
         when(secondParameterType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(secondParameterType);
-        ParameterList parameterList = ParameterList.Explicit.latent(methodDescription, Arrays.asList(firstParameterType, secondParameterType));
-        when(methodDescription.getParameters()).thenReturn(parameterList);
+        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(methodDescription,
+                Arrays.asList(firstParameterType, secondParameterType)));
     }
 
     @After

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionTokenTest.java
Patch:
@@ -120,7 +120,7 @@ public void testParameterTypeInequality() throws Exception {
                 not(new MethodDescription.Token(FOO,
                         MODIFIERS,
                         Collections.singletonList(mock(GenericTypeDescription.class)),
-                        second,
+                        first,
                         Collections.singletonList(secondParameter),
                         Collections.singletonList(mock(GenericTypeDescription.class)),
                         Collections.singletonList(mock(AnnotationDescription.class)),
@@ -140,7 +140,7 @@ public void testParameterTypeLengthInequality() throws Exception {
                 not(new MethodDescription.Token(FOO,
                         MODIFIERS,
                         Collections.singletonList(mock(GenericTypeDescription.class)),
-                        second,
+                        first,
                         Collections.<ParameterDescription.Token>emptyList(),
                         Collections.singletonList(mock(GenericTypeDescription.class)),
                         Collections.singletonList(mock(AnnotationDescription.class)),

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -1421,7 +1421,7 @@ public boolean equals(Object other) {
             Token token = (Token) other;
             if (!getInternalName().equals(token.getInternalName())) return false;
             if (!getReturnType().asRawType().equals(token.getReturnType().asRawType())) return false;
-            List<ParameterDescription.Token> tokens = getParameterTokens(), otherTokens = getParameterTokens();
+            List<ParameterDescription.Token> tokens = getParameterTokens(), otherTokens = token.getParameterTokens();
             if (tokens.size() != otherTokens.size()) return false;
             for (int index = 0; index < tokens.size(); index++) {
                 if (!tokens.get(index).getType().asRawType().equals(otherTokens.get(index).getType().asRawType())) return false;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -299,7 +299,7 @@ public AnnotationList getDeclaredAnnotations() {
 
         @Override
         public GenericTypeDescription getDeclaringType() {
-            return fieldDescription.getDeclaringType();
+            return declaringType;
         }
 
         @Override

File: byte-buddy-android/src/test/java/net/bytebuddy/android/AndroidClassLoadingStrategyTest.java
Patch:
@@ -111,7 +111,7 @@ public void testObjectProperties() throws Exception {
             public File create() {
                 return folder;
             }
-        }).applyCustom();
+        }).applyBasic();
         ObjectPropertyAssertion.of(AndroidClassLoadingStrategy.DexProcessor.ForSdkCompiler.class).apply();
         ObjectPropertyAssertion.of(AndroidClassLoadingStrategy.DexProcessor.ForSdkCompiler.Conversion.class).create(new ObjectPropertyAssertion.Creator<DexFile>() {
             @Override

File: byte-buddy-android/src/test/java/net/bytebuddy/test/utility/ObjectPropertyAssertion.java
Patch:
@@ -190,7 +190,7 @@ private void checkString(T instance) {
         } while ((currentType = currentType.getSuperclass()) != Object.class);
     }
 
-    public void applyMutable() throws IllegalAccessException, InvocationTargetException, InstantiationException {
+    public void applyBasic() throws IllegalAccessException, InvocationTargetException, InstantiationException {
         for (Constructor<?> constructor : type.getDeclaredConstructors()) {
             if (constructor.isSynthetic() && skipSynthetic) {
                 continue;

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -2478,7 +2478,7 @@ protected InitializationAppender(List<String> values) {
 
             @Override
             public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
-                TypeDescription instrumentedType = instrumentedMethod.getDeclaringType();
+                TypeDescription instrumentedType = instrumentedMethod.getDeclaringType().asRawType();
                 MethodDescription enumConstructor = instrumentedType.getDeclaredMethods()
                         .filter(isConstructor().and(takesArguments(String.class, int.class)))
                         .getOnly();

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -1588,7 +1588,7 @@ public S load(ClassLoader classLoader) {
 
         @Override
         public Object getValue(MethodDescription methodDescription) {
-            if (!methodDescription.getDeclaringType().represents(annotation.annotationType())) {
+            if (!methodDescription.getDeclaringType().asRawType().represents(annotation.annotationType())) {
                 throw new IllegalArgumentException(methodDescription + " does not represent " + annotation.annotationType());
             }
             try {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolver.java
Patch:
@@ -378,7 +378,7 @@ public AnnotationList getDeclaredAnnotations() {
                 }
 
                 @Override
-                public TypeDescription getDeclaringType() {
+                public GenericTypeDescription getDeclaringType() {
                     return methodDescription.getDeclaringType();
                 }
 
@@ -487,7 +487,7 @@ public AnnotationList getDeclaredAnnotations() {
                 }
 
                 @Override
-                public TypeDescription getDeclaringType() {
+                public GenericTypeDescription getDeclaringType() {
                     return methodDescription.getDeclaringType();
                 }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -1047,7 +1047,7 @@ public StackManipulation getStackManipulation() {
                 public List<TypeDescription> getParameterTypes() {
                     return methodDescription.isStatic()
                             ? methodDescription.getParameters().asTypeList().asRawTypes()
-                            : new TypeList.Explicit(join(methodDescription.getDeclaringType(), methodDescription.getParameters().asTypeList().asRawTypes()));
+                            : new TypeList.Explicit(join(methodDescription.getDeclaringType().asRawType(), methodDescription.getParameters().asTypeList().asRawTypes()));
                 }
 
                 @Override
@@ -1118,7 +1118,7 @@ public Resolved resolve(TypeDescription instrumentedType,
                     return new Resolved.Simple(MethodVariableAccess.loadThisReferenceAndArguments(instrumentedMethod),
                             instrumentedMethod.isStatic()
                                     ? instrumentedMethod.getParameters().asTypeList().asRawTypes()
-                                    : join(instrumentedMethod.getDeclaringType(), instrumentedMethod.getParameters().asTypeList().asRawTypes()));
+                                    : join(instrumentedMethod.getDeclaringType().asRawType(), instrumentedMethod.getParameters().asTypeList().asRawTypes()));
                 }
 
                 @Override
@@ -3005,7 +3005,7 @@ public StackManipulation resolve(MethodDescription interceptedMethod,
                                              Assigner assigner,
                                              boolean dynamicallyTyped) {
                 return Removal.pop(interceptedMethod.isConstructor()
-                        ? interceptedMethod.getDeclaringType()
+                        ? interceptedMethod.getDeclaringType().asRawType()
                         : interceptedMethod.getReturnType().asRawType());
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/SuperMethodCall.java
Patch:
@@ -111,8 +111,8 @@ public Size apply(MethodVisitor methodVisitor,
                           Implementation.Context implementationContext,
                           MethodDescription instrumentedMethod) {
             StackManipulation superMethodCall = instrumentedMethod.isDefaultMethod()
-                    && implementationTarget.getTypeDescription().getInterfaces().asRawTypes().contains(instrumentedMethod.getDeclaringType())
-                    ? implementationTarget.invokeDefault(instrumentedMethod.getDeclaringType(), instrumentedMethod.asToken())
+                    && implementationTarget.getTypeDescription().getInterfaces().asRawTypes().contains(instrumentedMethod.getDeclaringType().asRawType())
+                    ? implementationTarget.invokeDefault(instrumentedMethod.getDeclaringType().asRawType(), instrumentedMethod.asToken())
                     : implementationTarget.invokeSuper(instrumentedMethod, Target.MethodLookup.Default.EXACT);
             if (!superMethodCall.isValid()) {
                 throw new IllegalStateException("Cannot call super (or default) method of " + instrumentedMethod);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -108,7 +108,7 @@ private static LinkedHashMap<String, TypeDescription> extractFields(MethodDescri
         LinkedHashMap<String, TypeDescription> typeDescriptions = new LinkedHashMap<String, TypeDescription>((methodDescription.isStatic() ? 0 : 1) + parameters.size());
         int currentIndex = 0;
         if (!methodDescription.isStatic()) {
-            typeDescriptions.put(fieldName(currentIndex++), methodDescription.getDeclaringType());
+            typeDescriptions.put(fieldName(currentIndex++), methodDescription.getDeclaringType().asRawType());
         }
         for (ParameterDescription parameterDescription : parameters) {
             typeDescriptions.put(fieldName(currentIndex++), parameterDescription.getType().asRawType());

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/DeclaringTypeResolver.java
Patch:
@@ -18,8 +18,8 @@ public enum DeclaringTypeResolver implements MethodDelegationBinder.AmbiguityRes
     public Resolution resolve(MethodDescription source,
                               MethodDelegationBinder.MethodBinding left,
                               MethodDelegationBinder.MethodBinding right) {
-        TypeDescription leftType = left.getTarget().getDeclaringType();
-        TypeDescription rightType = right.getTarget().getDeclaringType();
+        TypeDescription leftType = left.getTarget().getDeclaringType().asRawType();
+        TypeDescription rightType = right.getTarget().getDeclaringType().asRawType();
         if (leftType.equals(rightType)) {
             return Resolution.AMBIGUOUS;
         } else if (leftType.isAssignableFrom(rightType)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -311,7 +311,7 @@ protected enum AccessType {
             GETTER {
                 @Override
                 protected TypeDescription proxyType(MethodDescription getterMethod, MethodDescription setterMethod) {
-                    return getterMethod.getDeclaringType();
+                    return getterMethod.getDeclaringType().asRawType();
                 }
 
                 @Override
@@ -328,7 +328,7 @@ protected Implementation access(FieldDescription fieldDescription,
             SETTER {
                 @Override
                 protected TypeDescription proxyType(MethodDescription getterMethod, MethodDescription setterMethod) {
-                    return setterMethod.getDeclaringType();
+                    return setterMethod.getDeclaringType().asRawType();
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -197,7 +197,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                         : new DefaultMethodLocator.Explicit(typeDescription)).resolve(implementationTarget, source);
             }
             return specialMethodInvocation.isValid()
-                    ? new MethodDelegationBinder.ParameterBinding.Anonymous(new RedirectionProxy(forwardingMethod.getDeclaringType(),
+                    ? new MethodDelegationBinder.ParameterBinding.Anonymous(new RedirectionProxy(forwardingMethod.getDeclaringType().asRawType(),
                     implementationTarget.getTypeDescription(),
                     specialMethodInvocation,
                     assigner,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -190,7 +190,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             } else if (source.isStatic()) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             }
-            return new MethodDelegationBinder.ParameterBinding.Anonymous(new Redirection(forwardingMethod.getDeclaringType(),
+            return new MethodDelegationBinder.ParameterBinding.Anonymous(new Redirection(forwardingMethod.getDeclaringType().asRawType(),
                     source,
                     assigner,
                     annotation.loadSilent().serializableProxy(),
@@ -440,7 +440,7 @@ private Appender(TypeDescription instrumentedType) {
 
                     @Override
                     public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
-                        StackManipulation thisReference = MethodVariableAccess.forType(instrumentedMethod.getDeclaringType()).loadOffset(0);
+                        StackManipulation thisReference = MethodVariableAccess.REFERENCE.loadOffset(0);
                         FieldList fieldList = instrumentedType.getDeclaredFields();
                         StackManipulation[] fieldLoading = new StackManipulation[fieldList.size()];
                         int index = 0;
@@ -571,7 +571,7 @@ public Size apply(MethodVisitor methodVisitor,
                         }
                         StackManipulation.Size stackSize = new StackManipulation.Compound(
                                 MethodVariableAccess.REFERENCE.loadOffset(1),
-                                assigner.assign(TypeDescription.OBJECT, redirectedMethod.getDeclaringType(), Assigner.DYNAMICALLY_TYPED),
+                                assigner.assign(TypeDescription.OBJECT, redirectedMethod.getDeclaringType().asRawType(), Assigner.DYNAMICALLY_TYPED),
                                 new StackManipulation.Compound(fieldLoading),
                                 MethodInvocation.invoke(redirectedMethod),
                                 assigner.assign(redirectedMethod.getReturnType().asRawType(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperCall.java
Patch:
@@ -77,9 +77,9 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                     Implementation.Target.MethodLookup.Default.EXACT);
             if (!specialMethodInvocation.isValid()
                     && source.isDefaultMethod()
-                    && implementationTarget.getTypeDescription().getInterfaces().asRawTypes().contains(source.getDeclaringType())
+                    && implementationTarget.getTypeDescription().getInterfaces().asRawTypes().contains(source.getDeclaringType().asRawType())
                     && annotation.loadSilent().fallbackToDefault()) {
-                specialMethodInvocation = implementationTarget.invokeDefault(source.getDeclaringType(), source.asToken());
+                specialMethodInvocation = implementationTarget.invokeDefault(source.getDeclaringType().asRawType(), source.asToken());
             }
             return specialMethodInvocation.isValid()
                     ? new MethodDelegationBinder.ParameterBinding.Anonymous(new MethodCallProxy.AssignableSignatureCall(specialMethodInvocation, annotation.loadSilent().serializableProxy()))

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -268,7 +268,7 @@ enum Returning implements TerminationHandler {
             @Override
             public StackManipulation resolve(Assigner assigner, MethodDescription source, MethodDescription target) {
                 return new StackManipulation.Compound(assigner.assign(target.isConstructor()
-                                ? target.getDeclaringType()
+                                ? target.getDeclaringType().asRawType()
                                 : target.getReturnType().asRawType(),
                         source.getReturnType().asRawType(),
                         RuntimeType.Verifier.check(target)), MethodReturn.returning(source.getReturnType().asRawType()));
@@ -293,7 +293,7 @@ enum Dropping implements TerminationHandler {
             @Override
             public StackManipulation resolve(Assigner assigner, MethodDescription source, MethodDescription target) {
                 return Removal.pop(target.isConstructor()
-                        ? target.getDeclaringType()
+                        ? target.getDeclaringType().asRawType()
                         : target.getReturnType().asRawType());
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodConstant.java
Patch:
@@ -210,7 +210,7 @@ protected ForMethod(MethodDescription methodDescription) {
 
         @Override
         protected Size prepare(MethodVisitor methodVisitor) {
-            methodVisitor.visitLdcInsn(Type.getType(methodDescription.getDeclaringType().getDescriptor()));
+            methodVisitor.visitLdcInsn(Type.getType(methodDescription.getDeclaringType().asRawType().getDescriptor()));
             methodVisitor.visitLdcInsn(methodDescription.getInternalName());
             return new Size(2, 2);
         }
@@ -260,7 +260,7 @@ protected ForConstructor(MethodDescription methodDescription) {
 
         @Override
         protected Size prepare(MethodVisitor methodVisitor) {
-            methodVisitor.visitLdcInsn(Type.getType(methodDescription.getDeclaringType().getDescriptor()));
+            methodVisitor.visitLdcInsn(Type.getType(methodDescription.getDeclaringType().asRawType().getDescriptor()));
             return new Size(1, 1);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodHandleConstant.java
Patch:
@@ -46,7 +46,7 @@ public static StackManipulation of(MethodDescription methodDescription) {
         return methodDescription.isTypeInitializer()
                 ? Illegal.INSTANCE
                 : new MethodHandleConstant(new Handle(tagFor(methodDescription),
-                methodDescription.getDeclaringType().getInternalName(),
+                methodDescription.getDeclaringType().asRawType().getInternalName(),
                 methodDescription.getInternalName(),
                 methodDescription.getDescriptor()));
     }
@@ -118,7 +118,7 @@ public static StackManipulation ofPutter(FieldDescription fieldDescription) {
      */
     private static StackManipulation of(FieldDescription fieldDescription, int tag) {
         return new MethodHandleConstant(new Handle(tag,
-                fieldDescription.getDeclaringType().getInternalName(),
+                fieldDescription.getDeclaringType().asRawType().getInternalName(),
                 fieldDescription.getInternalName(),
                 fieldDescription.getDescriptor()));
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/FieldAccess.java
Patch:
@@ -191,7 +191,7 @@ public boolean isValid() {
             @Override
             public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                 methodVisitor.visitFieldInsn(getOpcode(),
-                        fieldDescription.getDeclaringType().getInternalName(),
+                        fieldDescription.getDeclaringType().asRawType().getInternalName(),
                         fieldDescription.getInternalName(),
                         fieldDescription.getDescriptor());
                 return resolveSize(fieldDescription.getType().getStackSize());

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodInvocation.java
Patch:
@@ -77,7 +77,7 @@ public static WithImplicitInvocationTargetType invoke(MethodDescription methodDe
             return SPECIAL_CONSTRUCTOR.new Invocation(methodDescription); // Check this property second, constructors might be private
         } else if (methodDescription.isPrivate() || methodDescription.isDefaultMethod()) {
             return SPECIAL.new Invocation(methodDescription);
-        } else if (methodDescription.getDeclaringType().isInterface()) { // Check this property last, default methods must be called by INVOKESPECIAL
+        } else if (methodDescription.getDeclaringType().asRawType().isInterface()) { // Check this property last, default methods must be called by INVOKESPECIAL
             return INTERFACE.new Invocation(methodDescription);
         } else {
             return VIRTUAL.new Invocation(methodDescription);
@@ -193,7 +193,7 @@ protected class Invocation implements WithImplicitInvocationTargetType {
          * @param methodDescription The method to be invoked.
          */
         protected Invocation(MethodDescription methodDescription) {
-            this(methodDescription, methodDescription.getDeclaringType());
+            this(methodDescription, methodDescription.getDeclaringType().asRawType());
         }
 
         /**
@@ -359,7 +359,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
             methodVisitor.visitInvokeDynamicInsn(methodName,
                     methodDescriptor,
                     new Handle(handle,
-                            bootstrapMethod.getDeclaringType().getInternalName(),
+                            bootstrapMethod.getDeclaringType().asRawType().getInternalName(),
                             bootstrapMethod.getInternalName(),
                             bootstrapMethod.getDescriptor()),
                     arguments.toArray(new Object[arguments.size()]));

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -542,7 +542,7 @@ public static <T extends ByteCodeElement> ElementMatcher.Junction<T> isDeclaredB
      * @param <T>     The type of the matched object.
      * @return A matcher for byte code elements being declared by a type matched by the given {@code matcher}.
      */
-    public static <T extends ByteCodeElement> ElementMatcher.Junction<T> isDeclaredBy(ElementMatcher<? super TypeDescription> matcher) {
+    public static <T extends ByteCodeElement> ElementMatcher.Junction<T> isDeclaredBy(ElementMatcher<? super GenericTypeDescription> matcher) {
         return new DeclaringTypeMatcher<T>(nonNull(matcher));
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -3624,7 +3624,7 @@ public Tokenized(GenericTypeToken fieldTypeToken) {
 
                         @Override
                         public GenericTypeDescription resolveFieldType(String fieldTypeDescriptor, TypePool typePool, FieldDescription definingField) {
-                            return new TokenizedGenericType(typePool, fieldTypeToken, fieldTypeDescriptor, definingField.getDeclaringType());
+                            return new TokenizedGenericType(typePool, fieldTypeToken, fieldTypeDescriptor, definingField.getDeclaringType().asRawType());
                         }
                     }
                 }
@@ -4079,7 +4079,7 @@ private LazyAnnotationDescription(TypePool typePool,
 
             @Override
             public Object getValue(MethodDescription methodDescription) {
-                if (!methodDescription.getDeclaringType().getDescriptor().equals(descriptor)) {
+                if (!methodDescription.getDeclaringType().asRawType().getDescriptor().equals(descriptor)) {
                     throw new IllegalArgumentException(methodDescription + " is not declared by " + getAnnotationType());
                 }
                 AnnotationValue<?, ?> annotationValue = values.get(methodDescription.getName());

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -202,7 +202,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(AgentBuilder.Default.Transformation.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.Default.BootstrapInjectionStrategy.Enabled.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.Default.BootstrapInjectionStrategy.Disabled.class).apply();
-        ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.class).applyCustom();
+        ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.class).applyBasic();
         final Iterator<Class<?>> iterator = Arrays.<Class<?>>asList(Object.class, AgentBuilderDefaultTest.class).iterator();
         ObjectPropertyAssertion.of(AgentBuilder.Default.InitializationStrategy.SelfInjection.Nexus.class).create(new ObjectPropertyAssertion.Creator<Class<?>>() {
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/field/FieldDescriptionTokenTest.java
Patch:
@@ -46,6 +46,6 @@ public void testFieldNameInequality() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(FieldDescription.Token.class).applyCustom();
+        ObjectPropertyAssertion.of(FieldDescription.Token.class).applyBasic();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTest.java
Patch:
@@ -32,7 +32,7 @@ protected MethodDescription describe(Constructor<?> constructor) {
     public void testTypeInitializer() throws Exception {
         TypeDescription typeDescription = mock(TypeDescription.class);
         MethodDescription typeInitializer = new MethodDescription.Latent.TypeInitializer(typeDescription);
-        assertThat(typeInitializer.getDeclaringType(), is(typeDescription));
+        assertThat(typeInitializer.getDeclaringType(), is((GenericTypeDescription) typeDescription));
         assertThat(typeInitializer.getReturnType(), is((GenericTypeDescription) new TypeDescription.ForLoadedType(void.class)));
         assertThat(typeInitializer.getParameters(), is((ParameterList) new ParameterList.Empty()));
         assertThat(typeInitializer.getExceptionTypes(), is((GenericTypeList) new GenericTypeList.Empty()));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionTokenTest.java
Patch:
@@ -1,7 +1,6 @@
 package net.bytebuddy.description.method;
 
 import net.bytebuddy.description.annotation.AnnotationDescription;
-import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.test.utility.MockitoRule;
@@ -150,6 +149,6 @@ public void testParameterTypeLengthInequality() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(MethodDescription.Token.class).applyCustom();
+        ObjectPropertyAssertion.of(MethodDescription.Token.class).applyBasic();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -438,7 +438,7 @@ public void testHierarchyEnds() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(TypeDescription.AbstractTypeDescription.SuperTypeIterator.class).applyCustom();
+        ObjectPropertyAssertion.of(TypeDescription.AbstractTypeDescription.SuperTypeIterator.class).applyBasic();
     }
 
     protected interface SampleInterface {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericTypeDescriptionVisitorForDetachmentTest.java
Patch:
@@ -57,7 +57,7 @@ public void testDetachedNoSource() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(GenericTypeDescription.Visitor.Substitutor.ForDetachment.class).applyCustom();
+        ObjectPropertyAssertion.of(GenericTypeDescription.Visitor.Substitutor.ForDetachment.class).applyBasic();
     }
 
     @SuppressWarnings("unused")

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassFileLocatorAgentBasedTest.java
Patch:
@@ -109,7 +109,7 @@ public Collection<Class<?>> create() {
                 return Collections.<Class<?>>singletonList(otherIterator.next());
             }
         }).apply();
-        ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.ExtractionClassFileTransformer.class).applyCustom();
+        ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.ExtractionClassFileTransformer.class).applyBasic();
     }
 
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoaderObjectPropertiesTest.java
Patch:
@@ -7,8 +7,8 @@ public class ByteArrayClassLoaderObjectPropertiesTest {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(ByteArrayClassLoader.class).applyCustom();
-        ObjectPropertyAssertion.of(ByteArrayClassLoader.ChildFirst.class).applyCustom();
+        ObjectPropertyAssertion.of(ByteArrayClassLoader.class).applyBasic();
+        ObjectPropertyAssertion.of(ByteArrayClassLoader.ChildFirst.class).applyBasic();
         ObjectPropertyAssertion.of(ByteArrayClassLoader.PersistenceHandler.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategyTest.java
Patch:
@@ -102,7 +102,7 @@ public void apply(Instrumentation mock) {
         }).apply();
         ObjectPropertyAssertion.of(ClassReloadingStrategy.BootstrapInjection.Enabled.class).apply();
         ObjectPropertyAssertion.of(ClassReloadingStrategy.Engine.class).apply();
-        ObjectPropertyAssertion.of(ClassReloadingStrategy.Engine.ClassRedefinitionTransformer.class).applyCustom();
+        ObjectPropertyAssertion.of(ClassReloadingStrategy.Engine.ClassRedefinitionTransformer.class).applyBasic();
         ObjectPropertyAssertion.of(ClassReloadingStrategy.BootstrapInjection.Enabled.class).apply();
         ObjectPropertyAssertion.of(ClassReloadingStrategy.BootstrapInjection.Disabled.class).apply();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultTest.java
Patch:
@@ -208,8 +208,8 @@ public void testAnnotationPropertyWithParametersAssertion() throws Exception {
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(TypeWriter.Default.ForCreation.class).apply();
         ObjectPropertyAssertion.of(TypeWriter.Default.ForInlining.class).apply();
-        ObjectPropertyAssertion.of(TypeWriter.Default.ValidatingClassVisitor.class).applyCustom();
-        ObjectPropertyAssertion.of(TypeWriter.Default.ValidatingClassVisitor.ValidatingMethodVisitor.class).applyCustom();
+        ObjectPropertyAssertion.of(TypeWriter.Default.ValidatingClassVisitor.class).applyBasic();
+        ObjectPropertyAssertion.of(TypeWriter.Default.ValidatingClassVisitor.ValidatingMethodVisitor.class).applyBasic();
         ObjectPropertyAssertion.of(TypeWriter.Default.ValidatingClassVisitor.Constraint.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverMethodsOnlyTest.java
Patch:
@@ -36,7 +36,7 @@ public class MethodRebaseResolverMethodsOnlyTest {
     private MethodDescription method, constructor, other;
 
     @Mock
-    private TypeDescription returnType, parameterType;
+    private TypeDescription returnType, parameterType, declaringType;
 
     @Mock
     private MethodRebaseResolver.MethodNameTransformer methodNameTransformer;
@@ -60,6 +60,8 @@ public void setUp() throws Exception {
         when(returnType.asRawType()).thenReturn(returnType); // REFACTOR
         when(parameterType.asRawType()).thenReturn(parameterType); // REFACTOR
         when(parameterType.accept(Mockito.any(GenericTypeDescription.Visitor.class))).thenReturn(parameterType);
+        when(method.getDeclaringType()).thenReturn(declaringType);
+        when(declaringType.asRawType()).thenReturn(declaringType);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedMethodTest.java
Patch:
@@ -72,7 +72,7 @@ public void setUp() throws Exception {
     public void testPreservation() throws Exception {
         MethodRebaseResolver.Resolution resolution = MethodRebaseResolver.Resolution.ForRebasedMethod.of(methodDescription, methodNameTransformer);
         assertThat(resolution.isRebased(), is(true));
-        assertThat(resolution.getResolvedMethod().getDeclaringType(), is(typeDescription));
+        assertThat(resolution.getResolvedMethod().getDeclaringType(), is((GenericTypeDescription) typeDescription));
         assertThat(resolution.getResolvedMethod().getInternalName(), is(QUX));
         assertThat(resolution.getResolvedMethod().getModifiers(), is(MethodRebaseResolver.REBASED_METHOD_MODIFIER));
         assertThat(resolution.getResolvedMethod().getReturnType(), is((GenericTypeDescription) returnType));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTargetTest.java
Patch:
@@ -45,6 +45,7 @@ public class RebaseImplementationTargetTest extends AbstractImplementationTarget
     @Override
     @Before
     public void setUp() throws Exception {
+        when(instrumentedType.asRawType()).thenReturn(instrumentedType);
         when(instrumentedType.getInternalName()).thenReturn(BAR);
         when(targetRebaseMethod.getDeclaringType()).thenReturn(instrumentedType);
         when(rebasedMethod.getDeclaringType()).thenReturn(instrumentedType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTargetTest.java
Patch:
@@ -49,18 +49,20 @@ public void setUp() throws Exception {
         when(superType.getDeclaredMethods()).thenReturn(new MethodList.Explicit(Collections.singletonList(superMethodConstructor)));
         when(superType.getInternalName()).thenReturn(BAR);
         when(superType.asRawType()).thenReturn(superType);
-        when(superMethod.getDeclaringType()).thenReturn(superType);
+        when(superType.asRawType()).thenReturn(superType);
         when(superType.getStackSize()).thenReturn(StackSize.ZERO);
         when(superMethod.getReturnType()).thenReturn(returnType);
         when(superMethod.getInternalName()).thenReturn(BAZ);
         when(superMethod.getDescriptor()).thenReturn(FOOBAR);
         when(superMethod.getParameters()).thenReturn(parameterList);
+        when(superMethod.getDeclaringType()).thenReturn(superType);
         when(superMethodConstructor.isConstructor()).thenReturn(true);
         when(superMethodConstructor.getParameters()).thenReturn(parameterList);
         when(superMethodConstructor.getReturnType()).thenReturn(returnType);
         when(superMethodConstructor.isSpecializableFor(superType)).thenReturn(true);
         when(superMethodConstructor.getInternalName()).thenReturn(QUXBAZ);
         when(superMethodConstructor.getDescriptor()).thenReturn(BAZBAR);
+        when(superMethodConstructor.getDeclaringType()).thenReturn(superType);
         super.setUp();
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/AbstractImplementationTargetTest.java
Patch:
@@ -59,6 +59,7 @@ public abstract class AbstractImplementationTargetTest {
     @Before
     @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
+        when(methodType.asRawType()).thenReturn(methodType);
         when(finding.getTypeDescription()).thenReturn(instrumentedType);
         when(finding.getInvokableMethods()).thenReturn(new MethodList.Explicit(Collections.singletonList(invokableMethod)));
         when(finding.getInvokableDefaultMethods()).thenReturn(Collections.singletonMap(defaultType, Collections.singleton(defaultMethod)));
@@ -82,6 +83,7 @@ public MethodDescription answer(InvocationOnMock invocation) throws Throwable {
         when(defaultMethod.getReturnType()).thenReturn(returnType);
         when(defaultMethod.asToken()).thenReturn(defaultToken);
         when(defaultType.isInterface()).thenReturn(true);
+        when(defaultType.asRawType()).thenReturn(defaultType);
         when(defaultMethod.isSpecializableFor(defaultType)).thenReturn(true);
         when(defaultType.getInternalName()).thenReturn(BAZBAR);
         implementationTarget = makeImplementationTarget();
@@ -115,6 +117,7 @@ public void testIllegalSuperMethod() throws Exception {
         MethodDescription methodDescription = mock(MethodDescription.class);
         when(methodDescription.getReturnType()).thenReturn(returnType);
         TypeDescription typeDescription = mock(TypeDescription.class);
+        when(typeDescription.asRawType()).thenReturn(typeDescription);
         when(methodDescription.getDeclaringType()).thenReturn(typeDescription);
         assertThat(implementationTarget.invokeSuper(methodDescription, methodLookup).isValid(), is(false));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationSpecialMethodInvocationSimpleTest.java
Patch:
@@ -32,7 +32,9 @@ protected Implementation.SpecialMethodInvocation make(String name,
         for (TypeDescription parameterType : parameterTypes) {
             tokens.add(new ParameterDescription.Token(parameterType));
         }
-        return new Implementation.SpecialMethodInvocation.Simple(new MethodDescription.Latent(mock(TypeDescription.class),
+        TypeDescription declaringType = mock(TypeDescription.class);
+        when(declaringType.asRawType()).thenReturn(declaringType);
+        return new Implementation.SpecialMethodInvocation.Simple(new MethodDescription.Latent(declaringType,
                 name,
                 Opcodes.ACC_PUBLIC,
                 Collections.<GenericTypeDescription>emptyList(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/MethodDelegationBinderTest.java
Patch:
@@ -29,7 +29,7 @@ public MethodDescription create() {
                 when(methodDescription.getParameters()).thenReturn(new ParameterList.Empty());
                 return methodDescription;
             }
-        }).applyCustom();
+        }).applyBasic();
         ObjectPropertyAssertion.of(MethodDelegationBinder.MethodBinding.Builder.Build.class).create(new ObjectPropertyAssertion.Creator<Map<?, ?>>() {
             @Override
             public Map<?, ?> create() {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ArgumentBinderTest.java
Patch:
@@ -144,7 +144,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(Argument.Binder.class).apply();
         ObjectPropertyAssertion.of(Argument.BindingMechanic.class).apply();
         ObjectPropertyAssertion.of(Argument.NextUnboundAsDefaultsProvider.class).apply();
-        ObjectPropertyAssertion.of(Argument.NextUnboundAsDefaultsProvider.NextUnboundArgumentIterator.class).applyCustom();
+        ObjectPropertyAssertion.of(Argument.NextUnboundAsDefaultsProvider.NextUnboundArgumentIterator.class).applyBasic();
 
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/OriginBinderTest.java
Patch:
@@ -86,7 +86,9 @@ public void testModifierBinding() throws Exception {
     public void testMethodHandleBinding() throws Exception {
         targetType = new TypeDescription.ForLoadedType(JavaType.METHOD_HANDLE.load());
         when(target.getType()).thenReturn(targetType);
-        when(source.getDeclaringType()).thenReturn(mock(TypeDescription.class));
+        TypeDescription typeDescription = mock(TypeDescription.class);
+        when(typeDescription.asRawType()).thenReturn(typeDescription);
+        when(source.getDeclaringType()).thenReturn(typeDescription);
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = Origin.Binder.INSTANCE
                 .bind(annotationDescription, source, target, implementationTarget, assigner);
         assertThat(parameterBinding.isValid(), is(true));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/MethodConstantTest.java
Patch:
@@ -60,6 +60,7 @@ public class MethodConstantTest {
 
     @Before
     public void setUp() throws Exception {
+        when(declaringType.asRawType()).thenReturn(declaringType);
         when(methodDescription.getDeclaringType()).thenReturn(declaringType);
         when(methodDescription.getInternalName()).thenReturn(FOO);
         when(methodDescription.getParameters()).thenReturn(parameterList);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/MethodHandleConstantTest.java
Patch:
@@ -48,6 +48,7 @@ public class MethodHandleConstantTest {
 
     @Before
     public void setUp() throws Exception {
+        when(typeDescription.asRawType()).thenReturn(typeDescription);
         when(methodDescription.getDeclaringType()).thenReturn(typeDescription);
         when(typeDescription.getInternalName()).thenReturn(FOO);
         when(methodDescription.getInternalName()).thenReturn(BAR);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/FieldAccessTest.java
Patch:
@@ -82,6 +82,7 @@ public static Collection<Object[]> data() {
 
     @Before
     public void setUp() throws Exception {
+        when(declaringType.asRawType()).thenReturn(declaringType);
         when(fieldDescription.getDeclaringType()).thenReturn(declaringType);
         when(fieldDescription.getType()).thenReturn(fieldType);
         when(declaringType.getInternalName()).thenReturn(FOO);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationDynamicTest.java
Patch:
@@ -48,6 +48,7 @@ public class MethodInvocationDynamicTest {
 
     @Before
     public void setUp() throws Exception {
+        when(declaringType.asRawType()).thenReturn(declaringType);
         when(methodDescription.getDeclaringType()).thenReturn(declaringType);
         when(firstType.getStackSize()).thenReturn(StackSize.ZERO);
         when(firstType.getDescriptor()).thenReturn(FOO);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationOtherTest.java
Patch:
@@ -29,7 +29,9 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(MethodInvocation.Invocation.class).refine(new ObjectPropertyAssertion.Refinement<MethodDescription>() {
             @Override
             public void apply(MethodDescription mock) {
-                when(mock.getDeclaringType()).thenReturn(mock(TypeDescription.class));
+                TypeDescription declaringType = mock(TypeDescription.class);
+                when(declaringType.asRawType()).thenReturn(declaringType);
+                when(mock.getDeclaringType()).thenReturn(declaringType);
                 TypeDescription returnType = mock(TypeDescription.class);
                 when(returnType.getStackSize()).thenReturn(StackSize.ZERO);
                 when(mock.getReturnType()).thenReturn(returnType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationTest.java
Patch:
@@ -66,6 +66,7 @@ public static Collection<Object[]> data() {
 
     @Before
     public void setUp() throws Exception {
+        when(declaringType.asRawType()).thenReturn(declaringType);
         when(methodDescription.getReturnType()).thenReturn(returnType);
         when(methodDescription.getDeclaringType()).thenReturn(declaringType);
         when(methodDescription.getStackSize()).thenReturn(ARGUMENT_STACK_SIZE);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccessOtherTest.java
Patch:
@@ -28,7 +28,7 @@ public void testObjectProperties() throws Exception {
             public void apply(MethodDescription mock) {
                 when(mock.getParameters()).thenReturn(new ParameterList.Empty());
             }
-        }).applyCustom();
+        }).applyBasic();
         ObjectPropertyAssertion.of(MethodVariableAccess.TypeCastingHandler.NoOp.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/DeclaringTypeMatcherTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import net.bytebuddy.description.DeclaredByType;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import org.junit.Test;
 import org.mockito.Mock;
 
@@ -12,7 +13,7 @@
 public class DeclaringTypeMatcherTest extends AbstractElementMatcherTest<DeclaringTypeMatcher<?>> {
 
     @Mock
-    private ElementMatcher<? super TypeDescription> typeMatcher;
+    private ElementMatcher<? super GenericTypeDescription> typeMatcher;
 
     @Mock
     private DeclaredByType declaredByType;

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolCacheProviderTest.java
Patch:
@@ -48,6 +48,6 @@ public void testSimple() throws Exception {
     @Test
     public void testSimpleObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(TypePool.CacheProvider.NoOp.class).apply();
-        ObjectPropertyAssertion.of(TypePool.CacheProvider.Simple.class).applyCustom();
+        ObjectPropertyAssertion.of(TypePool.CacheProvider.Simple.class).applyBasic();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/ObjectPropertyAssertion.java
Patch:
@@ -197,7 +197,7 @@ private void checkString(T instance) {
         } while ((currentType = currentType.getSuperclass()) != Object.class);
     }
 
-    public void applyCustom() throws IllegalAccessException, InvocationTargetException, InstantiationException {
+    public void applyBasic() throws IllegalAccessException, InvocationTargetException, InstantiationException {
         for (Constructor<?> constructor : type.getDeclaredConstructors()) {
             if (constructor.isSynthetic() && skipSynthetic) {
                 continue;

File: byte-buddy-android/src/test/java/net/bytebuddy/android/AndroidClassLoadingStrategyTest.java
Patch:
@@ -111,7 +111,7 @@ public void testObjectProperties() throws Exception {
             public File create() {
                 return folder;
             }
-        }).applyMutable();
+        }).applyCustom();
         ObjectPropertyAssertion.of(AndroidClassLoadingStrategy.DexProcessor.ForSdkCompiler.class).apply();
         ObjectPropertyAssertion.of(AndroidClassLoadingStrategy.DexProcessor.ForSdkCompiler.Conversion.class).create(new ObjectPropertyAssertion.Creator<DexFile>() {
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/DeclaredByType.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.description;
 
-import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 /**
  * This interface represents all elements that can be declared within a type, i.e. other types and type members.
@@ -12,5 +12,5 @@ public interface DeclaredByType {
      *
      * @return The declaring type or {@code null} if no such type exists.
      */
-    TypeDescription getDeclaringType();
+    GenericTypeDescription getDeclaringType();
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/BridgeMethodResolver.java
Patch:
@@ -84,6 +84,9 @@ interface Factory {
      */
     class Simple implements BridgeMethodResolver {
 
+        /**
+         * A mapping of method shapes represented as tokens to their bridge method target.
+         */
         private final Map<MethodDescription.Token, BridgeTarget> bridges;
 
         /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -202,7 +202,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(AgentBuilder.Default.Transformation.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.Default.BootstrapInjectionStrategy.Enabled.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.Default.BootstrapInjectionStrategy.Disabled.class).apply();
-        ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.class).applyMutable();
+        ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.class).applyCustom();
         final Iterator<Class<?>> iterator = Arrays.<Class<?>>asList(Object.class, AgentBuilderDefaultTest.class).iterator();
         ObjectPropertyAssertion.of(AgentBuilder.Default.InitializationStrategy.SelfInjection.Nexus.class).create(new ObjectPropertyAssertion.Creator<Class<?>>() {
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -438,7 +438,7 @@ public void testHierarchyEnds() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(TypeDescription.AbstractTypeDescription.SuperTypeIterator.class).applyMutable();
+        ObjectPropertyAssertion.of(TypeDescription.AbstractTypeDescription.SuperTypeIterator.class).applyCustom();
     }
 
     protected interface SampleInterface {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericTypeDescriptionVisitorForDetachmentTest.java
Patch:
@@ -1,14 +1,12 @@
 package net.bytebuddy.description.type.generic;
 
-import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.TargetType;
 import net.bytebuddy.matcher.ElementMatchers;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 import java.util.List;
 
-import static net.bytebuddy.matcher.ElementMatchers.named;
 import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.assertThat;
 
@@ -59,7 +57,7 @@ public void testDetachedNoSource() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(GenericTypeDescription.Visitor.Substitutor.ForDetachment.class).applyMutable();
+        ObjectPropertyAssertion.of(GenericTypeDescription.Visitor.Substitutor.ForDetachment.class).applyCustom();
     }
 
     @SuppressWarnings("unused")

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassFileLocatorAgentBasedTest.java
Patch:
@@ -109,7 +109,7 @@ public Collection<Class<?>> create() {
                 return Collections.<Class<?>>singletonList(otherIterator.next());
             }
         }).apply();
-        ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.ExtractionClassFileTransformer.class).applyMutable();
+        ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.ExtractionClassFileTransformer.class).applyCustom();
     }
 
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoaderObjectPropertiesTest.java
Patch:
@@ -7,8 +7,8 @@ public class ByteArrayClassLoaderObjectPropertiesTest {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(ByteArrayClassLoader.class).applyMutable();
-        ObjectPropertyAssertion.of(ByteArrayClassLoader.ChildFirst.class).applyMutable();
+        ObjectPropertyAssertion.of(ByteArrayClassLoader.class).applyCustom();
+        ObjectPropertyAssertion.of(ByteArrayClassLoader.ChildFirst.class).applyCustom();
         ObjectPropertyAssertion.of(ByteArrayClassLoader.PersistenceHandler.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategyTest.java
Patch:
@@ -102,7 +102,7 @@ public void apply(Instrumentation mock) {
         }).apply();
         ObjectPropertyAssertion.of(ClassReloadingStrategy.BootstrapInjection.Enabled.class).apply();
         ObjectPropertyAssertion.of(ClassReloadingStrategy.Engine.class).apply();
-        ObjectPropertyAssertion.of(ClassReloadingStrategy.Engine.ClassRedefinitionTransformer.class).applyMutable();
+        ObjectPropertyAssertion.of(ClassReloadingStrategy.Engine.ClassRedefinitionTransformer.class).applyCustom();
         ObjectPropertyAssertion.of(ClassReloadingStrategy.BootstrapInjection.Enabled.class).apply();
         ObjectPropertyAssertion.of(ClassReloadingStrategy.BootstrapInjection.Disabled.class).apply();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodLookupEngineDefaultTest.java
Patch:
@@ -398,8 +398,8 @@ public void testObjectProperties() throws Exception {
             public void apply(TypeDescription mock) {
                 when(mock.getDeclaredMethods()).thenReturn(new MethodList.Empty());
             }
-        }).applyMutable();
-        ObjectPropertyAssertion.of(MethodLookupEngine.Default.MethodBucket.DefaultMethodLookup.Enabled.class).applyMutable();
+        }).applyCustom();
+        ObjectPropertyAssertion.of(MethodLookupEngine.Default.MethodBucket.DefaultMethodLookup.Enabled.class).applyCustom();
         ObjectPropertyAssertion.of(MethodLookupEngine.Default.MethodBucket.DefaultMethodLookup.Disabled.class).apply();
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultTest.java
Patch:
@@ -13,7 +13,6 @@
 import org.junit.Test;
 import org.junit.rules.MethodRule;
 
-import java.security.acl.Owner;
 import java.util.Collections;
 
 public class TypeWriterDefaultTest {
@@ -209,8 +208,8 @@ public void testAnnotationPropertyWithParametersAssertion() throws Exception {
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(TypeWriter.Default.ForCreation.class).apply();
         ObjectPropertyAssertion.of(TypeWriter.Default.ForInlining.class).apply();
-        ObjectPropertyAssertion.of(TypeWriter.Default.ValidatingClassVisitor.class).applyMutable();
-        ObjectPropertyAssertion.of(TypeWriter.Default.ValidatingClassVisitor.ValidatingMethodVisitor.class).applyMutable();
+        ObjectPropertyAssertion.of(TypeWriter.Default.ValidatingClassVisitor.class).applyCustom();
+        ObjectPropertyAssertion.of(TypeWriter.Default.ValidatingClassVisitor.ValidatingMethodVisitor.class).applyCustom();
         ObjectPropertyAssertion.of(TypeWriter.Default.ValidatingClassVisitor.Constraint.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDefaultTest.java
Patch:
@@ -609,7 +609,7 @@ public void testFieldSetterRegistrationWritesSecond() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
-        ObjectPropertyAssertion.of(Implementation.Context.Default.class).applyMutable();
+        ObjectPropertyAssertion.of(Implementation.Context.Default.class).applyCustom();
         ObjectPropertyAssertion.of(Implementation.Context.Default.FieldCacheEntry.class).apply();
         ObjectPropertyAssertion.of(Implementation.Context.Default.AccessorMethodDelegation.class).apply();
         ObjectPropertyAssertion.of(Implementation.Context.Default.FieldSetterDelegation.class).apply();

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/MethodDelegationBinderTest.java
Patch:
@@ -29,7 +29,7 @@ public MethodDescription create() {
                 when(methodDescription.getParameters()).thenReturn(new ParameterList.Empty());
                 return methodDescription;
             }
-        }).applyMutable();
+        }).applyCustom();
         ObjectPropertyAssertion.of(MethodDelegationBinder.MethodBinding.Builder.Build.class).create(new ObjectPropertyAssertion.Creator<Map<?, ?>>() {
             @Override
             public Map<?, ?> create() {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ArgumentBinderTest.java
Patch:
@@ -144,7 +144,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(Argument.Binder.class).apply();
         ObjectPropertyAssertion.of(Argument.BindingMechanic.class).apply();
         ObjectPropertyAssertion.of(Argument.NextUnboundAsDefaultsProvider.class).apply();
-        ObjectPropertyAssertion.of(Argument.NextUnboundAsDefaultsProvider.NextUnboundArgumentIterator.class).applyMutable();
+        ObjectPropertyAssertion.of(Argument.NextUnboundAsDefaultsProvider.NextUnboundArgumentIterator.class).applyCustom();
 
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccessOtherTest.java
Patch:
@@ -28,7 +28,7 @@ public void testObjectProperties() throws Exception {
             public void apply(MethodDescription mock) {
                 when(mock.getParameters()).thenReturn(new ParameterList.Empty());
             }
-        }).applyMutable();
+        }).applyCustom();
         ObjectPropertyAssertion.of(MethodVariableAccess.TypeCastingHandler.NoOp.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolCacheProviderTest.java
Patch:
@@ -48,6 +48,6 @@ public void testSimple() throws Exception {
     @Test
     public void testSimpleObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(TypePool.CacheProvider.NoOp.class).apply();
-        ObjectPropertyAssertion.of(TypePool.CacheProvider.Simple.class).applyMutable();
+        ObjectPropertyAssertion.of(TypePool.CacheProvider.Simple.class).applyCustom();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/ObjectPropertyAssertion.java
Patch:
@@ -197,7 +197,7 @@ private void checkString(T instance) {
         } while ((currentType = currentType.getSuperclass()) != Object.class);
     }
 
-    public void applyMutable() throws IllegalAccessException, InvocationTargetException, InstantiationException {
+    public void applyCustom() throws IllegalAccessException, InvocationTargetException, InstantiationException {
         for (Constructor<?> constructor : type.getDeclaredConstructors()) {
             if (constructor.isSynthetic() && skipSynthetic) {
                 continue;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodRegistry.java
Patch:
@@ -466,7 +466,8 @@ public MethodRegistry.Prepared prepare(InstrumentedType instrumentedType,
                 }
             }
             MethodLookupEngine.Finding finding = methodLookupEngine.process(instrumentedType);
-            ElementMatcher<? super MethodDescription> instrumented = not(anyOf(implementations.keySet())).and(methodFilter.resolve(instrumentedType));
+            ElementMatcher<? super MethodDescription> instrumented = (ElementMatcher<? super MethodDescription>) not(anyOf(implementations.keySet()))
+                    .and(methodFilter.resolve(instrumentedType));
             List<MethodDescription> methodDescriptions = join(typeInitializerOf(instrumentedType), finding.getInvokableMethods().filter(instrumented));
             for (MethodDescription methodDescription : methodDescriptions) {
                 for (Entry entry : entries) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/GenericTypeDescription.java
Patch:
@@ -968,7 +968,6 @@ public GenericTypeDescription onWildcardType(GenericTypeDescription genericTypeD
 
             @Override
             public GenericTypeDescription onParameterizedType(GenericTypeDescription genericTypeDescription) {
-                GenericTypeDescription ownerType = genericTypeDescription.getOwnerType();
                 List<GenericTypeDescription> parameters = new ArrayList<GenericTypeDescription>(genericTypeDescription.getParameters().size());
                 for (GenericTypeDescription parameter : genericTypeDescription.getParameters()) {
                     if (parameter.getSort().isTypeVariable()) {
@@ -982,6 +981,7 @@ public GenericTypeDescription onParameterizedType(GenericTypeDescription generic
                     }
                     parameters.add(parameter.accept(this));
                 }
+                GenericTypeDescription ownerType = genericTypeDescription.getOwnerType();
                 return new GenericTypeDescription.ForParameterizedType.Latent(genericTypeDescription.asRawType(),
                         parameters,
                         ownerType == null
@@ -1493,7 +1493,7 @@ public StackSize getStackSize() {
         @Override
         public int hashCode() {
             int result = 1;
-            for (GenericTypeDescription genericTypeDescription : getLowerBounds()) {
+            for (GenericTypeDescription genericTypeDescription : getParameters()) {
                 result = 31 * result + genericTypeDescription.hashCode();
             }
             GenericTypeDescription ownerType = getOwnerType();

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/GenericTypeDescription.java
Patch:
@@ -877,9 +877,7 @@ public static Visitor<GenericTypeDescription> bind(GenericTypeDescription typeDe
                         }
                         typeDescription = typeDescription.getOwnerType();
                     } while (typeDescription != null && typeDescription.getSort().isParameterized());
-                    return bindings.isEmpty()
-                            ? NoOp.INSTANCE
-                            : new ForTypeVariableBinding(bindings);
+                    return new ForTypeVariableBinding(bindings);
                 }
 
                 /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/package-info.java
Patch:
@@ -2,4 +2,4 @@
  * Contains descriptions for generic types as defined in the Java programming language. This information is
  * attached as meta data to generated code and is accessible via the reflection API.
  */
-package net.bytebuddy.description.type.generic;
\ No newline at end of file
+package net.bytebuddy.description.type.generic;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -432,14 +432,14 @@ public TypeDescription getDeclaringType() {
         }
 
         @Override
-        protected GenericTypeDescription getDeclaredSuperType() {
+        public GenericTypeDescription getDeclaredSuperType() {
             return superType == null
                     ? null
                     : superType.accept(GenericTypeDescription.Visitor.Substitutor.ForAttachment.of(this));
         }
 
         @Override
-        protected List<? extends GenericTypeDescription> getDeclaredInterfaces() {
+        public GenericTypeList getDeclaredInterfaces() {
             return GenericTypeList.ForDetachedTypes.attach(this, interfaceTypes);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -2682,14 +2682,14 @@ protected LazyTypeDescription(TypePool typePool,
         }
 
         @Override
-        protected GenericTypeDescription getDeclaredSuperType() {
+        public GenericTypeDescription getDeclaredSuperType() {
             return superTypeDescriptor == null || isInterface()
                     ? null
                     : signatureResolution.resolveSuperType(superTypeDescriptor, typePool, this);
         }
 
         @Override
-        protected List<? extends GenericTypeDescription> getDeclaredInterfaces() {
+        public GenericTypeList getDeclaredInterfaces() {
             return signatureResolution.resolveInterfaceTypes(interfaceTypeDescriptors, typePool, this);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -432,14 +432,14 @@ public TypeDescription getDeclaringType() {
         }
 
         @Override
-        public GenericTypeDescription getSuperType() {
+        protected GenericTypeDescription getDeclaredSuperType() {
             return superType == null
                     ? null
                     : superType.accept(GenericTypeDescription.Visitor.Substitutor.ForAttachment.of(this));
         }
 
         @Override
-        public GenericTypeList getInterfaces() {
+        protected List<? extends GenericTypeDescription> getDeclaredInterfaces() {
             return GenericTypeList.ForDetachedTypes.attach(this, interfaceTypes);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -2682,14 +2682,14 @@ protected LazyTypeDescription(TypePool typePool,
         }
 
         @Override
-        public GenericTypeDescription getSuperType() {
+        protected GenericTypeDescription getDeclaredSuperType() {
             return superTypeDescriptor == null || isInterface()
                     ? null
                     : signatureResolution.resolveSuperType(superTypeDescriptor, typePool, this);
         }
 
         @Override
-        public GenericTypeList getInterfaces() {
+        protected List<? extends GenericTypeDescription> getDeclaredInterfaces() {
             return signatureResolution.resolveInterfaceTypes(interfaceTypeDescriptors, typePool, this);
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericTypeDescriptionTest.java
Patch:
@@ -31,12 +31,12 @@ public void testNegativeArityGenericArray() throws Exception {
     @Test
     public void testZeroArityReturnsInstance() throws Exception {
         GenericTypeDescription genericTypeDescription = mock(GenericTypeDescription.class);
-        when(genericTypeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);
+        when(genericTypeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.PARAMETERIZED);
         assertThat(GenericTypeDescription.ForGenericArray.Latent.of(genericTypeDescription, 0), is(genericTypeDescription));
     }
 
     @Test
-    public void testNonGenericType() throws Exception {
+    public void testNonGenericArrayType() throws Exception {
         TypeDescription typeDescription = mock(TypeDescription.class);
         when(typeDescription.asRawType()).thenReturn(typeDescription);
         when(typeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.NON_GENERIC);

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericTypeDescriptionVisitorAttachmentDetachmentTest.java
Patch:
@@ -82,7 +82,7 @@ public void testAttachment() throws Exception {
     public void testDetachedNoSource() throws Exception {
         GenericTypeDescription original = GenericTypeDescription.Sort.describe(Foo.Inner.class.getDeclaredField(FOO).getGenericType());
         GenericTypeDescription detached = original.accept(new GenericTypeDescription.Visitor.Substitutor.ForDetachment(ElementMatchers.is(Foo.Inner.class)));
-        detached.getParameters().get(0).getUpperBounds();
+        detached.getParameters().get(0).getVariableSource();
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -210,7 +210,7 @@ protected DynamicType.Builder<T> materialize(ClassFileVersion classFileVersion,
     @Override
     public DynamicType.Unloaded<T> make() {
         MethodRegistry.Prepared preparedMethodRegistry = methodRegistry.prepare(new InstrumentedType.Default(namingStrategy.name(new NamingStrategy
-                        .UnnamedType.Default(targetType.getSuperType().asRawType(), interfaceTypes, modifiers, classFileVersion)),
+                        .UnnamedType.Default(targetType.getSuperType(), interfaceTypes, modifiers, classFileVersion)),
                         modifiers,
                         targetType.getTypeVariables().accept(new GenericTypeDescription.Visitor.Substitutor.ForDetachment(is(targetType))),
                         targetType.getSuperType(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderTest.java
Patch:
@@ -160,7 +160,6 @@ public void testAnnotationDefinition() throws Exception {
     public void testEnumerationDefinition() throws Exception {
         Class<? extends Enum<?>> type = new ByteBuddy()
                 .makeEnumeration(FOO, BAR)
-                .classVisitor(DebuggingWrapper.makeDefault())
                 .make()
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -374,7 +374,7 @@ public InstrumentedType withInitializer(ByteCodeAppender byteCodeAppender) {
                     fieldTokens,
                     methodTokens,
                     annotationDescriptions,
-                    typeInitializer,
+                    typeInitializer.expandWith(byteCodeAppender),
                     loadedTypeInitializer);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -765,7 +765,7 @@ public void drain(ClassVisitor classVisitor, TypeWriter.MethodPool methodPool, I
                 if (injectedCode.isDefined()) {
                     typeInitializer = typeInitializer.expandWith(injectedCode.getByteCodeAppender());
                 }
-                MethodDescription typeInitializerMethod = MethodDescription.Latent.typeInitializerOf(instrumentedType);
+                MethodDescription typeInitializerMethod = new MethodDescription.Latent.TypeInitializer(instrumentedType);
                 TypeWriter.MethodPool.Entry initializerEntry = methodPool.target(typeInitializerMethod);
                 if (initializerEntry.getSort().isImplemented() && typeInitializer.isDefined()) {
                     initializerEntry = initializerEntry.prepend(typeInitializer);

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTest.java
Patch:
@@ -31,7 +31,7 @@ protected MethodDescription describe(Constructor<?> constructor) {
     @Test
     public void testTypeInitializer() throws Exception {
         TypeDescription typeDescription = mock(TypeDescription.class);
-        MethodDescription typeInitializer = MethodDescription.Latent.typeInitializerOf(typeDescription);
+        MethodDescription typeInitializer = new MethodDescription.Latent.TypeInitializer(typeDescription);
         assertThat(typeInitializer.getDeclaringType(), is(typeDescription));
         assertThat(typeInitializer.getReturnType(), is((GenericTypeDescription) new TypeDescription.ForLoadedType(void.class)));
         assertThat(typeInitializer.getParameters(), is((ParameterList) new ParameterList.Empty()));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderTest.java
Patch:
@@ -160,6 +160,7 @@ public void testAnnotationDefinition() throws Exception {
     public void testEnumerationDefinition() throws Exception {
         Class<? extends Enum<?>> type = new ByteBuddy()
                 .makeEnumeration(FOO, BAR)
+                .classVisitor(DebuggingWrapper.makeDefault())
                 .make()
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/ElementMatchersTest.java
Patch:
@@ -545,7 +545,7 @@ public void testSortIsMethod() throws Exception {
         assertThat(ElementMatchers.isMethod()
                 .matches(new MethodDescription.ForLoadedConstructor(Object.class.getDeclaredConstructor())), is(false));
         assertThat(ElementMatchers.isMethod()
-                .matches(MethodDescription.Latent.typeInitializerOf(mock(TypeDescription.class))), is(false));
+                .matches(new MethodDescription.Latent.TypeInitializer(mock(TypeDescription.class))), is(false));
     }
 
     @Test
@@ -555,7 +555,7 @@ public void testSortIsConstructor() throws Exception {
         assertThat(ElementMatchers.isConstructor()
                 .matches(new MethodDescription.ForLoadedConstructor(Object.class.getDeclaredConstructor())), is(true));
         assertThat(ElementMatchers.isConstructor()
-                .matches(MethodDescription.Latent.typeInitializerOf(mock(TypeDescription.class))), is(false));
+                .matches(new MethodDescription.Latent.TypeInitializer(mock(TypeDescription.class))), is(false));
     }
 
     @Test
@@ -574,7 +574,7 @@ public void testSortIsTypeInitializer() throws Exception {
         assertThat(ElementMatchers.isTypeInitializer()
                 .matches(new MethodDescription.ForLoadedConstructor(Object.class.getDeclaredConstructor())), is(false));
         assertThat(ElementMatchers.isTypeInitializer()
-                .matches(MethodDescription.Latent.typeInitializerOf(mock(TypeDescription.class))), is(true));
+                .matches(new MethodDescription.Latent.TypeInitializer(mock(TypeDescription.class))), is(true));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -560,7 +560,7 @@ public DynamicType.Builder<? extends Enum<?>> makeEnumeration(String... value) {
      * @return A builder for a new enumeration type with the given values.
      */
     @SuppressWarnings("unchecked")
-    public DynamicType.Builder<? extends Enum<?>> makeEnumeration(Collection<String> values) {
+    public DynamicType.Builder<? extends Enum<?>> makeEnumeration(Collection<? extends String> values) {
         if (unique(nonNull(values)).size() == 0) {
             throw new IllegalArgumentException("Require at least one enumeration constant");
         }
@@ -2138,7 +2138,7 @@ public DynamicType.Builder<? extends Enum<?>> makeEnumeration(String... value) {
         }
 
         @Override
-        public DynamicType.Builder<? extends Enum<?>> makeEnumeration(Collection<String> values) {
+        public DynamicType.Builder<? extends Enum<?>> makeEnumeration(Collection<? extends String> values) {
             return materialize().makeEnumeration(values);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -2442,7 +2442,7 @@ public MethodAnnotationTarget<S> withDefaultValue(Object value) {
                  * @return A subclass matched method interception that represents the materialized method.
                  */
                 private DefaultMatchedMethodInterception materialize(MethodDescription.Token methodToken) {
-                    return new DefaultMatchedMethodInterception(new LatentMethodMatcher.Resolved(represents(methodToken)), join(methodTokens, methodToken));
+                    return new DefaultMatchedMethodInterception(new LatentMethodMatcher.ForToken(methodToken), join(methodTokens, methodToken));
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1159,7 +1159,7 @@ abstract class AbstractBase<S> implements Builder<S> {
             /**
              * The interface types to implement as specified for this builder.
              */
-            protected final List<TypeDescription> interfaceTypes;
+            protected final List<GenericTypeDescription> interfaceTypes;
 
             /**
              * The modifiers specified for this builder.
@@ -1252,7 +1252,7 @@ protected AbstractBase(ClassFileVersion classFileVersion,
                                    NamingStrategy namingStrategy,
                                    AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
                                    TypeDescription targetType,
-                                   List<TypeDescription> interfaceTypes,
+                                   List<GenericTypeDescription> interfaceTypes,
                                    int modifiers,
                                    TypeAttributeAppender attributeAppender,
                                    ElementMatcher<? super MethodDescription> ignoredMethods,
@@ -1769,7 +1769,7 @@ protected abstract Builder<S> materialize(ClassFileVersion classFileVersion,
                                                       NamingStrategy namingStrategy,
                                                       AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
                                                       TypeDescription targetType,
-                                                      List<TypeDescription> interfaceTypes,
+                                                      List<GenericTypeDescription> interfaceTypes,
                                                       int modifiers,
                                                       TypeAttributeAppender attributeAppender,
                                                       ElementMatcher<? super MethodDescription> ignoredMethods,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -433,7 +433,9 @@ public TypeDescription getDeclaringType() {
 
         @Override
         public GenericTypeDescription getSuperType() {
-            return superType.accept(GenericTypeDescription.Visitor.Substitutor.ForAttachment.of(this));
+            return superType == null
+                    ? null
+                    : superType.accept(GenericTypeDescription.Visitor.Substitutor.ForAttachment.of(this));
         }
 
         @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedConstructorTest.java
Patch:
@@ -63,8 +63,9 @@ public void setUp() throws Exception {
         when(placeholderType.getDescriptor()).thenReturn(BAZ);
         when(otherPlaceHolderType.getDescriptor()).thenReturn(FOO);
         when(returnType.asRawType()).thenReturn(returnType); // REFACTOR
-        when(parameterType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(parameterType);
+        when(returnType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(returnType); // REFACTOR
         when(parameterType.asRawType()).thenReturn(parameterType); // REFACTOR
+        when(parameterType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(parameterType);
     }
 
     @Test
@@ -74,7 +75,7 @@ public void testPreservation() throws Exception {
         assertThat(resolution.getResolvedMethod().getDeclaringType(), is(typeDescription));
         assertThat(resolution.getResolvedMethod().getInternalName(), is(MethodDescription.CONSTRUCTOR_INTERNAL_NAME));
         assertThat(resolution.getResolvedMethod().getModifiers(), is(MethodRebaseResolver.REBASED_METHOD_MODIFIER));
-        assertThat(resolution.getResolvedMethod().getReturnType(), is((GenericTypeDescription) returnType));
+        assertThat(resolution.getResolvedMethod().getReturnType(), is((GenericTypeDescription) TypeDescription.VOID));
         assertThat(resolution.getResolvedMethod().getParameters(), is(ParameterList.Explicit.latent(resolution.getResolvedMethod(),
                 Arrays.asList(parameterType, placeholderType))));
         StackManipulation.Size size = resolution.getAdditionalArguments().apply(methodVisitor, implementationContext);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedMethodTest.java
Patch:
@@ -49,6 +49,7 @@ public class MethodRebaseResolverResolutionForRebasedMethodTest {
     private Implementation.Context implementationContext;
 
     @Before
+    @SuppressWarnings("unchecked")
     public void setUp() throws Exception {
         when(methodDescription.getDeclaringType()).thenReturn(typeDescription);
         when(methodDescription.getReturnType()).thenReturn(returnType);
@@ -62,7 +63,9 @@ public void setUp() throws Exception {
         ParameterList parameterList = ParameterList.Explicit.latent(methodDescription, Collections.singletonList(parameterType));
         when(methodDescription.getParameters()).thenReturn(parameterList);
         when(returnType.asRawType()).thenReturn(returnType); // REFACTOR
+        when(returnType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(returnType); // REFACTOR
         when(parameterType.asRawType()).thenReturn(parameterType); // REFACTOR
+        when(parameterType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(parameterType); // REFACTOR
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -219,12 +219,12 @@ class Default extends AbstractTypeDescription.OfSimpleType implements Instrument
 
         private final int modifiers;
 
+        private final List<? extends GenericTypeDescription> typeVariables;
+
         private final GenericTypeDescription superType;
 
         private final List<? extends GenericTypeDescription> interfaceTypes;
 
-        private final List<? extends GenericTypeDescription> typeVariables;
-
         private final List<? extends FieldDescription.Token> fieldTokens;
 
         private final List<? extends MethodDescription.Token> methodTokens;
@@ -453,7 +453,7 @@ public MethodList getDeclaredMethods() {
 
         @Override
         public GenericTypeList getTypeVariables() {
-            return GenericTypeList.ForDetachedTypes.OfTypeVariable.attach(this, interfaceTypes);
+            return GenericTypeList.ForDetachedTypes.OfTypeVariable.attach(this, typeVariables);
         }
 
         @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverEnabledTest.java
Patch:
@@ -99,7 +99,7 @@ public void testResolutionInstrumentedConstructor() throws Exception {
         MethodRebaseResolver.Resolution resolution = methodRebaseResolver.resolve(constructor);
         assertThat(resolution.isRebased(), is(true));
         assertThat(resolution.getAdditionalArguments(), is((StackManipulation) NullConstant.INSTANCE));
-        assertThat(resolution.getResolvedMethod().getInternalName(), is(FOO));
+        assertThat(resolution.getResolvedMethod().getInternalName(), is(MethodDescription.CONSTRUCTOR_INTERNAL_NAME));
         assertThat(resolution.getResolvedMethod().getReturnType(), is((GenericTypeDescription) returnType));
         assertThat(resolution.getResolvedMethod().getParameters().asTypeList(),
                 is((GenericTypeList) new GenericTypeList.Explicit(Arrays.asList(parameterType, placeholderType))));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedConstructorTest.java
Patch:
@@ -72,7 +72,7 @@ public void testPreservation() throws Exception {
         MethodRebaseResolver.Resolution resolution = MethodRebaseResolver.Resolution.ForRebasedConstructor.of(methodDescription, placeholderType);
         assertThat(resolution.isRebased(), is(true));
         assertThat(resolution.getResolvedMethod().getDeclaringType(), is(typeDescription));
-        assertThat(resolution.getResolvedMethod().getInternalName(), is(FOO));
+        assertThat(resolution.getResolvedMethod().getInternalName(), is(MethodDescription.CONSTRUCTOR_INTERNAL_NAME));
         assertThat(resolution.getResolvedMethod().getModifiers(), is(MethodRebaseResolver.REBASED_METHOD_MODIFIER));
         assertThat(resolution.getResolvedMethod().getReturnType(), is((GenericTypeDescription) returnType));
         assertThat(resolution.getResolvedMethod().getParameters(), is(ParameterList.Explicit.latent(resolution.getResolvedMethod(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDefaultTest.java
Patch:
@@ -169,6 +169,7 @@ public void setUp() throws Exception {
         when(secondSpecialMethod.getParameters()).thenReturn(secondSpecialMethodParameters);
         when(firstFieldType.getSort()).thenReturn(GenericTypeDescription.Sort.RAW);
         when(firstFieldType.asRawType()).thenReturn(firstFieldType); // REFACTOR
+        when(firstFieldType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(firstFieldType); // REFACTOR
         when(firstField.getType()).thenReturn(firstFieldType);
         when(firstField.getName()).thenReturn(FOO);
         when(firstField.getInternalName()).thenReturn(FOO);
@@ -177,6 +178,7 @@ public void setUp() throws Exception {
         when(firstFieldDeclaringType.getInternalName()).thenReturn(QUX);
         when(secondFieldType.getSort()).thenReturn(GenericTypeDescription.Sort.RAW);
         when(secondFieldType.asRawType()).thenReturn(secondFieldType); // REFACTOR
+        when(secondFieldType.accept(any(GenericTypeDescription.Visitor.class))).thenReturn(secondFieldType); // REFACTOR
         when(secondField.getType()).thenReturn(secondFieldType);
         when(secondField.getName()).thenReturn(BAR);
         when(secondField.getInternalName()).thenReturn(BAR);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -216,8 +216,7 @@ public DynamicType.Unloaded<T> make() {
                                 LoadedTypeInitializer.NoOp.INSTANCE)),
                         methodLookupEngineFactory.make(classFileVersion.isSupportsDefaultMethods()),
                         new InstrumentableMatcher(ignoredMethods))
-                .compile(new SubclassImplementationTarget.Factory(bridgeMethodResolverFactory,
-                        SubclassImplementationTarget.OriginTypeIdentifier.SUPER_TYPE));
+                .compile(new SubclassImplementationTarget.Factory(bridgeMethodResolverFactory, SubclassImplementationTarget.OriginTypeIdentifier.SUPER_TYPE));
         return TypeWriter.Default.<T>forCreation(compiledMethodRegistry,
                 fieldRegistry.prepare(compiledMethodRegistry.getInstrumentedType()).compile(TypeWriter.FieldPool.Entry.NoOp.INSTANCE),
                 auxiliaryTypeNamingStrategy,

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodTokenMatcher.java
Patch:
@@ -2,6 +2,8 @@
 
 import net.bytebuddy.description.method.MethodDescription;
 
+import static net.bytebuddy.matcher.ElementMatchers.none;
+
 public class MethodTokenMatcher<T extends MethodDescription> extends ElementMatcher.Junction.AbstractBase<T> {
 
     private final ElementMatcher<? super MethodDescription.Token> matcher;
@@ -12,6 +14,6 @@ public MethodTokenMatcher(ElementMatcher<? super MethodDescription.Token> matche
 
     @Override
     public boolean matches(T target) {
-        return matcher.matches(target.asToken());
+        return matcher.matches(target.asToken(none()));
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -212,7 +212,7 @@ public DynamicType.Unloaded<T> make() {
         MethodRegistry.Prepared preparedMethodRegistry = methodRegistry.prepare(new InstrumentedType.Default(namingStrategy.name(new NamingStrategy
                         .UnnamedType.Default(targetType.getSuperType().asRawType(), interfaceTypes, modifiers, classFileVersion)),
                         modifiers,
-                        Collections.<GenericTypeDescription>emptyList(),
+                        targetType.getTypeVariables().accept(new GenericTypeDescription.Visitor.Substitutor.ForDetachment(targetType)),
                         targetType.getSuperType(),
                         interfaceTypes,
                         fieldTokens,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -202,7 +202,7 @@ public DynamicType.Unloaded<T> make() {
         MethodRegistry.Compiled compiledMethodRegistry = methodRegistry.prepare(new InstrumentedType.Default(namingStrategy.name(new NamingStrategy
                         .UnnamedType.Default(targetType.getSuperType().asRawType(), interfaceTypes, modifiers, classFileVersion)),
                         modifiers,
-                        Collections.<GenericTypeDescription>emptyList(),
+                        targetType.getTypeVariables().accept(new GenericTypeDescription.Visitor.Substitutor.ForDetachment(targetType)),
                         targetType.getSuperType(),
                         interfaceTypes,
                         fieldTokens,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -199,7 +199,6 @@ protected DynamicType.Builder<T> materialize(ClassFileVersion classFileVersion,
 
     @Override
     public DynamicType.Unloaded<T> make() {
-        ;
         MethodRegistry.Compiled compiledMethodRegistry = constructorStrategy
                 .inject(methodRegistry, defaultMethodAttributeAppenderFactory)
                 .prepare(applyConstructorStrategy(new InstrumentedType.Default(namingStrategy.name(new NamingStrategy.UnnamedType.Default(targetType,

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericSignatureResolutionTest.java
Patch:
@@ -47,7 +47,6 @@ public void testGenericField() throws Exception {
     }
 
     @Test
-    @Ignore("Requires refactoring of instrumented type!")
     public void testGenericMethod() throws Exception {
         DynamicType.Unloaded<?> unloaded = new ByteBuddy()
                 .redefine(GenericMethod.class)

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -318,7 +318,7 @@ public InstrumentedType withField(String name,
                     typeVariables,
                     superType,
                     interfaceTypes,
-                    joinUnique(fieldTokens, new FieldDescription.Token(name, fieldType, modifiers, Collections.<AnnotationDescription>emptyList())),
+                    joinUnique(fieldTokens, new FieldDescription.Token(name, modifiers, fieldType, Collections.<AnnotationDescription>emptyList())),
                     methodTokens,
                     annotationDescriptions,
                     typeInitializer,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategy.java
Patch:
@@ -40,8 +40,7 @@ public interface ConstructorStrategy {
      * @return A method registry that is capable of providing byte code for the constructors that were added by
      * this strategy.
      */
-    MethodRegistry inject(MethodRegistry methodRegistry,
-                          MethodAttributeAppender.Factory defaultMethodAttributeAppenderFactory);
+    MethodRegistry inject(MethodRegistry methodRegistry, MethodAttributeAppender.Factory defaultMethodAttributeAppenderFactory);
 
     /**
      * Default implementations of constructor strategies.

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AbstractAnnotationDescriptionTest.java
Patch:
@@ -387,7 +387,8 @@ private void assertValue(Annotation annotation, String methodName, Object rawVal
                 new TypeDescription.ForLoadedType(annotation.annotationType().getDeclaredMethod(methodName).getReturnType()),
                 Collections.<ParameterDescription.Token>emptyList(),
                 Collections.<GenericTypeDescription>emptyList(),
-                Collections.<AnnotationDescription>emptyList())), is(rawValue));
+                Collections.<AnnotationDescription>emptyList(),
+                MethodDescription.NO_DEFAULT_VALUE)), is(rawValue));
         assertThat(annotation.annotationType().getDeclaredMethod(methodName)
                 .invoke(describe(annotation).prepare(annotation.annotationType()).load()), is(loadedValue));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/AbstractInstrumentedTypeTest.java
Patch:
@@ -42,6 +42,8 @@ public abstract class AbstractInstrumentedTypeTest {
 
     protected abstract InstrumentedType makePlainInstrumentedType();
 
+    // TODO: Make non-abstract!
+
     @Test
     @SuppressWarnings("unchecked")
     public void testWithField() throws Exception {
@@ -89,6 +91,7 @@ public void testWithFieldOfInstrumentedTypeAsArray() throws Exception {
     }
 
     @Test(expected = IllegalArgumentException.class)
+    @SuppressWarnings("unchecked")
     public void testWithFieldDouble() throws Exception {
         TypeDescription fieldType = mock(TypeDescription.class);
         when(fieldType.asRawType()).thenReturn(fieldType); // REFACTOR

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -97,7 +97,7 @@ public static AssignerConfigurable value(Object fixedValue) {
                     Assigner.DEFAULT,
                     Assigner.STATICALLY_TYPED);
         } else if (type == Class.class) {
-            return new ForPoolValue(ClassConstant.of(new TypeDescription.ForLoadedType(type)),
+            return new ForPoolValue(ClassConstant.of(new TypeDescription.ForLoadedType((Class<?>) fixedValue)),
                     TypeDescription.CLASS,
                     Assigner.DEFAULT,
                     Assigner.STATICALLY_TYPED);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -97,7 +97,7 @@ public static AssignerConfigurable value(Object fixedValue) {
                     Assigner.DEFAULT,
                     Assigner.STATICALLY_TYPED);
         } else if (type == Class.class) {
-            return new ForPoolValue(ClassConstant.of(new TypeDescription.ForLoadedType(type)),
+            return new ForPoolValue(ClassConstant.of(new TypeDescription.ForLoadedType((Class<?>) fixedValue)),
                     TypeDescription.CLASS,
                     Assigner.DEFAULT,
                     Assigner.STATICALLY_TYPED);

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -2406,7 +2406,8 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                         TypeDescription.OBJECT,
                         Collections.<ParameterDescription.Token>emptyList(),
                         Collections.<GenericTypeDescription>emptyList(),
-                        Collections.<AnnotationDescription>emptyList());
+                        Collections.<AnnotationDescription>emptyList(),
+                        MethodDescription.NO_DEFAULT_VALUE);
                 return new Size(new StackManipulation.Compound(
                         FieldAccess.forField(valuesField).getter(),
                         MethodInvocation.invoke(cloneArrayMethod),

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -493,7 +493,7 @@ public Latent(MethodDescription declaringMethod,
 
         @Override
         public GenericTypeDescription getType() {
-            return parameterType;
+            return parameterType.accept(GenericTypeDescription.Visitor.Substitutor.ForAttachment.of(this));
         }
 
         @Override
@@ -600,7 +600,7 @@ public Integer getModifiers() {
         @Override
         public Token accept(GenericTypeDescription.Visitor<? extends GenericTypeDescription> visitor) {
             return new Token(getType().accept(visitor),
-                    annotationDescriptions, // Field access to avoid nesting of lists.
+                    getAnnotations(),
                     getName(),
                     getModifiers());
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1688,7 +1688,8 @@ private TypeInitializerInjection() {
                                 TypeDescription.VOID,
                                 Collections.<ParameterDescription.Token>emptyList(),
                                 Collections.<GenericTypeDescription>emptyList(),
-                                Collections.<AnnotationDescription>emptyList());
+                                Collections.<AnnotationDescription>emptyList(),
+                                MethodDescription.NO_DEFAULT_VALUE);
                     }
 
                     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -291,7 +291,7 @@ protected InstrumentableMatcher(ElementMatcher<? super MethodDescription> ignore
 
         @Override
         public ElementMatcher<? super MethodDescription> resolve(TypeDescription instrumentedType) {
-            return (ElementMatcher<? super MethodDescription>) isOverridable().and(not(ignoredMethods)).or(isDeclaredBy(instrumentedType));
+            return isOverridable().and(not(ignoredMethods)).or(isDeclaredBy(instrumentedType));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -878,7 +878,7 @@ public static PreparationHandler of(String name, TypeDescription typeDescription
 
                 @Override
                 public InstrumentedType prepare(InstrumentedType instrumentedType) {
-                    return instrumentedType.withField(name, TargetType.resolve(typeDescription, instrumentedType), modifiers);
+                    return instrumentedType.withField(name, typeDescription, modifiers);
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -1082,7 +1082,7 @@ protected static FieldLocator consider(MethodDescription methodDescription) {
                 protected LookupEngine lookup(TypeDescription typeDescription, TypeDescription instrumentedType) {
                     return typeDescription.represents(void.class)
                             ? new LookupEngine.ForHierarchy(fieldName)
-                            : new LookupEngine.ForExplicitType(fieldName, TargetType.resolve(typeDescription, instrumentedType).asRawType());
+                            : new LookupEngine.ForExplicitType(fieldName, typeDescription.equals(TargetType.DESCRIPTION) ? instrumentedType : typeDescription);
                 }
 
                 @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/AbstractInstrumentedTypeTest.java
Patch:
@@ -92,6 +92,7 @@ public void testWithFieldOfInstrumentedTypeAsArray() throws Exception {
     public void testWithFieldDouble() throws Exception {
         TypeDescription fieldType = mock(TypeDescription.class);
         when(fieldType.asRawType()).thenReturn(fieldType); // REFACTOR
+        when(fieldType.accept(Mockito.any(GenericTypeDescription.Visitor.class))).thenReturn(fieldType); // REFACTOR
         when(fieldType.getName()).thenReturn(FOO);
         makePlainInstrumentedType()
                 .withField(BAR, fieldType, Opcodes.ACC_PUBLIC)

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/MultipleParentClassLoaderTest.java
Patch:
@@ -109,7 +109,7 @@ public void testMultipleParentURLNotFound() throws Exception {
     }
 
     @Test
-    public void testMultipleParenEnumerationURL() throws Exception {
+    public void testMultipleParentEnumerationURL() throws Exception {
         ClassLoader classLoader = new MultipleParentClassLoader.Builder().append(first, second, null).build();
         Enumeration<URL> foo = classLoader.getResources(FOO);
         assertThat(foo.hasMoreElements(), is(true));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/AnnotationAppenderDefaultTest.java
Patch:
@@ -21,6 +21,7 @@
 import java.security.ProtectionDomain;
 import java.util.Collections;
 
+import static net.bytebuddy.matcher.ElementMatchers.none;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
 import static org.junit.Assert.assertEquals;
@@ -108,7 +109,7 @@ private Class<?> makeTypeWithAnnotation(Annotation annotation) throws Exception
         when(target.visit(any(String.class), anyBoolean())).thenReturn(annotationVisitor);
         AnnotationDescription annotationDescription = AnnotationDescription.ForLoadedAnnotation.of(annotation);
         AnnotationAppender.AnnotationVisibility annotationVisibility = AnnotationAppender.AnnotationVisibility.of(annotationDescription);
-        annotationAppender.append(annotationDescription, annotationVisibility);
+        annotationAppender.append(annotationDescription, none(), annotationVisibility);
         switch (annotationVisibility) {
             case RUNTIME:
                 verify(target).visit(Type.getDescriptor(annotation.annotationType()), true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/attribute/TypeAttributeAppenderForTypeTest.java
Patch:
@@ -22,7 +22,7 @@ public void testTypeAnnotation() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
-        final Iterator<Class<?>> iterator = Arrays.<Class<?>>asList(Void.class, String.class).iterator();
+        final Iterator<Class<?>> iterator = Arrays.<Class<?>>asList(Void.class, String.class, Void.class, String.class).iterator();
         ObjectPropertyAssertion.of(TypeAttributeAppender.ForType.class).create(new ObjectPropertyAssertion.Creator<Class<?>>() {
             @Override
             public Class<?> create() {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/This.java
Patch:
@@ -73,7 +73,8 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             }
             StackManipulation assignment = source.isStatic()
                     ? NullConstant.INSTANCE
-                    : MethodVariableAccess.REFERENCE.loadOffset(THIS_REFERENCE_INDEX);
+                    : new StackManipulation.Compound(MethodVariableAccess.REFERENCE.loadOffset(THIS_REFERENCE_INDEX),
+                    assigner.assign(implementationTarget.getTypeDescription(), target.getTypeDescription(), RuntimeType.Verifier.check(target)));
             return assignment.isValid()
                     ? new MethodDelegationBinder.ParameterBinding.Anonymous(assignment)
                     : MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodDelegation.java
Patch:
@@ -67,6 +67,8 @@
  * {@code Qux#baz} that is annotated with {@code Origin} is assigned a reference to either a {@link java.lang.reflect.Method}
  * or a {@link java.lang.Class} instance. A {@code Method}-typed parameter is assigned a reference to the original method that
  * is overriden. A {@code Class}-typed parameter is assigned the type of the caller.</li>
+ * <li>{@link net.bytebuddy.implementation.bind.annotation.StubValue}: Assigns the (boxed) default value of the
+ * intercepted method's return type to the parameter. If the return type is {@code void}, {@code null} is assigned.</li>
  * <li>{@link net.bytebuddy.implementation.bind.annotation.Empty}: Assigns the parameter type's
  * default value, i.e. {@code null} for a reference type or zero for primitive types. This is an opportunity to
  * ignore a parameter.</li>
@@ -448,6 +450,7 @@ private static List<TargetMethodAnnotationDrivenBinder.ParameterBinder<?>> defau
                 SuperCall.Binder.INSTANCE,
                 DefaultCall.Binder.INSTANCE,
                 FieldValue.Binder.INSTANCE,
+                StubValue.Binder.INSTANCE,
                 Empty.Binder.INSTANCE);
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Argument.java
Patch:
@@ -26,7 +26,7 @@
  * if the source method parameter at the specified index is not assignable to the annotated parameter.
  *
  * @see net.bytebuddy.implementation.MethodDelegation
- * @see TargetMethodAnnotationDrivenBinder
+ * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
  * @see net.bytebuddy.implementation.bind.annotation.RuntimeType
  */
 @Documented

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/BindingPriority.java
Patch:
@@ -9,6 +9,9 @@
 /**
  * Defines a binding priority for a target method. If two target methods can be bound to a source method,
  * the one with the higher priority will be selected.
+ *
+ * @see net.bytebuddy.implementation.MethodDelegation
+ * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Default.java
Patch:
@@ -16,6 +16,9 @@
  * directly implemented by the instrumented type. The generated proxy will directly implement the parameter's
  * interface. If the interface of the annotation is not implemented by the instrumented type, the method with this
  * parameter is not considered as a binding target.
+ *
+ * @see net.bytebuddy.implementation.MethodDelegation
+ * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultCall.java
Patch:
@@ -21,7 +21,7 @@
  * parameter is considered to be unbindable.
  *
  * @see net.bytebuddy.implementation.MethodDelegation
- * @see TargetMethodAnnotationDrivenBinder
+ * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Empty.java
Patch:
@@ -13,6 +13,9 @@
 /**
  * Binds the parameter type's default value to the annotated parameter, i.e. {@code null} or a numeric value
  * representing zero.
+ *
+ * @see net.bytebuddy.implementation.MethodDelegation
+ * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -42,6 +42,9 @@
  * must similarly return {@code void} and take a single {@link java.lang.Object} argument. After installing these
  * interfaces with the {@link FieldProxy.Binder}, this
  * binder needs to be registered with a {@link net.bytebuddy.implementation.MethodDelegation} before it can be used.
+ *
+ * @see net.bytebuddy.implementation.MethodDelegation
+ * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldValue.java
Patch:
@@ -24,7 +24,9 @@
  * assignable to the given field. For attempting a type casting, the {@link RuntimeType} annotation can be
  * applied to the parameter.
  *
- * @see TargetMethodAnnotationDrivenBinder
+ * @see net.bytebuddy.implementation.MethodDelegation
+ * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
+ * @see net.bytebuddy.implementation.bind.annotation.RuntimeType
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/IgnoreForBinding.java
Patch:
@@ -8,7 +8,7 @@
  * Indicates that a given target method should never be considered for binding to a source method.
  *
  * @see net.bytebuddy.implementation.MethodDelegation
- * @see TargetMethodAnnotationDrivenBinder
+ * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -44,6 +44,9 @@
  * {@link net.bytebuddy.implementation.bind.annotation.SuperCall} or
  * {@link net.bytebuddy.implementation.bind.annotation.DefaultCall} annotations which call a super
  * method using the same arguments as the intercepted method was invoked with.
+ *
+ * @see net.bytebuddy.implementation.MethodDelegation
+ * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Origin.java
Patch:
@@ -35,7 +35,7 @@
  * Any other parameter type will cause an {@link java.lang.IllegalStateException}.
  *
  * @see net.bytebuddy.implementation.MethodDelegation
- * @see TargetMethodAnnotationDrivenBinder
+ * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -77,9 +77,8 @@
  *   .appendParameterBinder(Pipe.Binder.install(ForwardingType.class))
  * </pre>
  *
- * @see net.bytebuddy.implementation.bind.annotation.Pipe.Binder
  * @see net.bytebuddy.implementation.MethodDelegation
- * @see TargetMethodAnnotationDrivenBinder
+ * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/RuntimeType.java
Patch:
@@ -16,7 +16,7 @@
  * {@code foo} method casting the target's method return value to {@code String} before returning a value itself.
  *
  * @see net.bytebuddy.implementation.MethodDelegation
- * @see TargetMethodAnnotationDrivenBinder
+ * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Super.java
Patch:
@@ -50,6 +50,9 @@
  * <p>&nbsp;</p>
  * If a method parameter is not a super type of the instrumented type, the method with the parameter that is annoted by
  * #{@code Super} is not considered a possible delegation target.
+ *
+ * @see net.bytebuddy.implementation.MethodDelegation
+ * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperCall.java
Patch:
@@ -22,7 +22,7 @@
  * type.
  *
  * @see net.bytebuddy.implementation.MethodDelegation
- * @see TargetMethodAnnotationDrivenBinder
+ * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldValueBinderTest.java
Patch:
@@ -256,6 +256,7 @@ public void testIllegalAssignmentExplicitTypeNoField() throws Exception {
 
     @Test
     public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(FieldValue.Binder.class).apply();
         ObjectPropertyAssertion.of(FieldValue.Binder.FieldLocator.ForFieldInHierarchy.class).apply();
         ObjectPropertyAssertion.of(FieldValue.Binder.FieldLocator.ForSpecificType.class).apply();
         ObjectPropertyAssertion.of(FieldValue.Binder.FieldLocator.Impossible.class).apply();

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/ByteCodeElement.java
Patch:
@@ -24,7 +24,9 @@ public interface ByteCodeElement extends NamedElement, ModifierReviewable, Decla
     String getGenericSignature();
 
     /**
-     * Checks if this element is visible from a given type.
+     * Checks if this element is visible from a given type. Methods are only considered visible if their return type and their parameter
+     * types are also visible to the given type. Similarly, fields are only considered visible if the field's type is visible to the
+     * given type. For array types, a type is considered visible only if the component type is visible to the given type.
      *
      * @param typeDescription The type which is checked for its access of this element.
      * @return {@code true} if this element is visible for {@code typeDescription}.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -48,6 +48,7 @@ public String getGenericSignature() {
         @Override
         public boolean isVisibleTo(TypeDescription typeDescription) {
             return getDeclaringType().isVisibleTo(typeDescription)
+                    && getFieldType().isVisibleTo(typeDescription)
                     && (isPublic()
                     || typeDescription.equals(getDeclaringType())
                     || (isProtected() && getDeclaringType().isAssignableFrom(typeDescription))

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategy.java
Patch:
@@ -106,8 +106,7 @@ public MethodList extractConstructors(TypeDescription instrumentedType) {
                 TypeDescription superType = instrumentedType.getSupertype();
                 return superType == null
                         ? new MethodList.Empty()
-                        : superType.getDeclaredMethods()
-                        .filter(isConstructor().<MethodDescription>and(isVisibleTo(instrumentedType)));
+                        : superType.getDeclaredMethods().filter(isConstructor().<MethodDescription>and(isVisibleTo(instrumentedType)));
             }
 
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -321,6 +321,9 @@ public void testIsVisible() throws Exception {
         assertThat(describe(SamplePackagePrivate.class).isVisibleTo(new TypeDescription.ForLoadedType(Object.class)), is(false));
         assertThat(describe(SampleInterface.class).isVisibleTo(new TypeDescription.ForLoadedType(Object.class)), is(true));
         assertThat(describe(SampleAnnotation.class).isVisibleTo(new TypeDescription.ForLoadedType(Object.class)), is(false));
+        assertThat(describe(int.class).isVisibleTo(new TypeDescription.ForLoadedType(Object.class)), is(true));
+        assertThat(describe(SampleInterface[].class).isVisibleTo(new TypeDescription.ForLoadedType(Object.class)), is(true));
+        assertThat(describe(SamplePackagePrivate[].class).isVisibleTo(new TypeDescription.ForLoadedType(Object.class)), is(false));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -2401,9 +2401,10 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                 FieldDescription valuesField = instrumentedType.getDeclaredFields().filter(named(ENUM_VALUES)).getOnly();
                 MethodDescription cloneArrayMethod = new MethodDescription.Latent(valuesField.getType().asRawType(),
                         CLONE_METHOD_NAME,
+                        Opcodes.ACC_PUBLIC,
+                        Collections.<GenericTypeDescription>emptyList(),
                         TypeDescription.OBJECT,
                         Collections.<ParameterDescription.Token>emptyList(),
-                        Opcodes.ACC_PUBLIC,
                         Collections.<GenericTypeDescription>emptyList(),
                         Collections.<AnnotationDescription>emptyList());
                 return new Size(new StackManipulation.Compound(

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -11,7 +11,6 @@
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.PackageDescription;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.DynamicType;
@@ -1681,11 +1680,13 @@ protected class TypeInitializerInjection implements Implementation.Context.Extra
                      * Creates a new type initializer injection.
                      */
                     private TypeInitializerInjection() {
+                        // TODO: Check!
                         injectorProxyMethod = new MethodDescription.Latent(instrumentedType,
                                 String.format("%s$%s", TYPE_INITIALIZER_PROXY_PREFIX, RandomString.make()),
+                                TYPE_INITIALIZER_PROXY_MODIFIERS,
+                                Collections.<GenericTypeDescription>emptyList(),
                                 TypeDescription.VOID,
                                 Collections.<ParameterDescription.Token>emptyList(),
-                                TYPE_INITIALIZER_PROXY_MODIFIERS,
                                 Collections.<GenericTypeDescription>emptyList(),
                                 Collections.<AnnotationDescription>emptyList());
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/InlineInstrumentedType.java
Patch:
@@ -128,9 +128,10 @@ public InstrumentedType withMethod(String internalName,
                                        int modifiers) {
         MethodDescription additionalMethod = new MethodDescription.Latent(this,
                 internalName,
+                modifiers,
+                Collections.<GenericTypeDescription>emptyList(),
                 returnType,
                 ParameterDescription.Token.asList(parameterTypes),
-                modifiers,
                 exceptionTypes,
                 Collections.<AnnotationDescription>emptyList());
         if (methodDescriptions.contains(additionalMethod)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentedType.java
Patch:
@@ -130,9 +130,10 @@ public InstrumentedType withMethod(String internalName,
                                        int modifiers) {
         MethodDescription additionalMethod = new MethodDescription.Latent(this,
                 internalName,
+                modifiers,
+                Collections.<GenericTypeDescription>emptyList(),
                 returnType,
                 ParameterDescription.Token.asList(parameterTypes),
-                modifiers,
                 exceptionTypes,
                 Collections.<AnnotationDescription>emptyList());
         if (methodDescriptions.contains(additionalMethod)) {

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/annotation/AbstractAnnotationDescriptionTest.java
Patch:
@@ -382,9 +382,10 @@ private void assertValue(Annotation annotation, String methodName, Object rawVal
                 .ForLoadedMethod(annotation.annotationType().getDeclaredMethod(methodName))), is(rawValue));
         assertThat(describe(annotation).getValue(new MethodDescription.Latent(new TypeDescription.ForLoadedType(annotation.annotationType()),
                 methodName,
+                Opcodes.ACC_PUBLIC,
+                Collections.<GenericTypeDescription>emptyList(),
                 new TypeDescription.ForLoadedType(annotation.annotationType().getDeclaredMethod(methodName).getReturnType()),
                 Collections.<ParameterDescription.Token>emptyList(),
-                Opcodes.ACC_PUBLIC,
                 Collections.<GenericTypeDescription>emptyList(),
                 Collections.<AnnotationDescription>emptyList())), is(rawValue));
         assertThat(annotation.annotationType().getDeclaredMethod(methodName)

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/AbstractGenericTypeDescriptionTest.java
Patch:
@@ -390,7 +390,7 @@ public void testNestedInnerType() throws Exception {
         assertThat(qux.getSort(), is(GenericTypeDescription.Sort.VARIABLE));
         assertThat(qux.getSymbol(), is(U));
         assertThat(qux.getUpperBounds().size(), is(1));
-        assertThat(qux.getUpperBounds().getOnly(), is(foo));
+        assertThat(qux.getUpperBounds().getOnly(), is(bar));
         MethodDescription quxMethod = new MethodDescription.ForLoadedMethod(NestedInnerType.InnerType.class.getDeclaredMethod(QUX));
         assertThat(qux.getVariableSource(), is((TypeVariableSource) quxMethod));
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTarget.java
Patch:
@@ -46,7 +46,7 @@ protected RebaseImplementationTarget(MethodLookupEngine.Finding finding,
     protected Implementation.SpecialMethodInvocation invokeSuper(MethodDescription methodDescription) {
         return methodDescription.getDeclaringType().equals(typeDescription)
                 ? invokeSuper(methodRebaseResolver.resolve(methodDescription))
-                : Implementation.SpecialMethodInvocation.Simple.of(methodDescription, typeDescription.getSuperType());
+                : Implementation.SpecialMethodInvocation.Simple.of(methodDescription, typeDescription.getSuperType().asRawType());
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/DefaultMethodCall.java
Patch:
@@ -143,7 +143,7 @@ public ByteCodeAppender appender(Target implementationTarget) {
      */
     private List<TypeDescription> filterRelevant(TypeDescription typeDescription) {
         List<TypeDescription> filtered = new ArrayList<TypeDescription>(prioritizedInterfaces.size());
-        Set<TypeDescription> relevant = new HashSet<TypeDescription>(typeDescription.getInterfaces());
+        Set<TypeDescription> relevant = new HashSet<TypeDescription>(typeDescription.getInterfaces().asRawTypes());
         for (TypeDescription prioritizedInterface : prioritizedInterfaces) {
             if (relevant.remove(prioritizedInterface)) {
                 filtered.add(prioritizedInterface);
@@ -197,7 +197,7 @@ protected static class Appender implements ByteCodeAppender {
         protected Appender(Target implementationTarget, List<TypeDescription> prioritizedInterfaces) {
             this.implementationTarget = implementationTarget;
             this.prioritizedInterfaces = prioritizedInterfaces;
-            this.nonPrioritizedInterfaces = new HashSet<TypeDescription>(implementationTarget.getTypeDescription().getInterfaces());
+            this.nonPrioritizedInterfaces = new HashSet<TypeDescription>(implementationTarget.getTypeDescription().getInterfaces().asRawTypes());
             nonPrioritizedInterfaces.removeAll(prioritizedInterfaces);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -275,7 +275,7 @@ public FieldDescription locate(String name) {
                     if (fieldList.size() == 1) {
                         return fieldList.getOnly();
                     }
-                } while (!(currentType = currentType.getSuperType()).represents(Object.class));
+                } while (!(currentType = currentType.getSuperType().asRawType()).represents(Object.class));
                 throw new IllegalArgumentException("There is no field '" + name + " that is visible to " + instrumentedType);
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -7,6 +7,7 @@
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
 import net.bytebuddy.implementation.bytecode.Removal;
@@ -1723,10 +1724,10 @@ public Resolved resolve(TypeDescription instrumentedType,
                                         MethodDescription instrumentedMethod,
                                         Assigner assigner,
                                         boolean dynamicallyTyped) {
-                    TypeDescription currentType = instrumentedType;
+                    GenericTypeDescription currentType = instrumentedType;
                     FieldDescription fieldDescription = null;
                     do {
-                        FieldList fieldList = currentType.getDeclaredFields().filter(named(fieldName));
+                        FieldList fieldList = currentType.asRawType().getDeclaredFields().filter(named(fieldName));
                         if (fieldList.size() != 0) {
                             fieldDescription = fieldList.getOnly();
                         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -7,6 +7,7 @@
 import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.implementation.bytecode.*;
 import net.bytebuddy.implementation.bytecode.assign.Assigner;
@@ -1228,10 +1229,10 @@ public StackManipulation resolve(TypeDescription instrumentedType,
                                              TypeDescription targetType,
                                              Assigner assigner,
                                              boolean dynamicallyTyped) {
-                TypeDescription currentType = instrumentedType;
+                GenericTypeDescription currentType = instrumentedType;
                 FieldDescription fieldDescription = null;
                 do {
-                    FieldList fieldList = currentType.getDeclaredFields().filter(named(fieldName));
+                    FieldList fieldList = currentType.asRawType().getDeclaredFields().filter(named(fieldName));
                     if (fieldList.size() != 0) {
                         fieldDescription = fieldList.getOnly();
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/SuperMethodCall.java
Patch:
@@ -111,7 +111,7 @@ public Size apply(MethodVisitor methodVisitor,
                           Implementation.Context implementationContext,
                           MethodDescription instrumentedMethod) {
             StackManipulation superMethodCall = instrumentedMethod.isDefaultMethod()
-                    && implementationTarget.getTypeDescription().getInterfaces().contains(instrumentedMethod.getDeclaringType())
+                    && implementationTarget.getTypeDescription().getInterfaces().asRawTypes().contains(instrumentedMethod.getDeclaringType())
                     ? implementationTarget.invokeDefault(instrumentedMethod.getDeclaringType(), instrumentedMethod.getUniqueSignature())
                     : implementationTarget.invokeSuper(instrumentedMethod, Target.MethodLookup.Default.EXACT);
             if (!superMethodCall.isValid()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/TypeAttributeAppender.java
Patch:
@@ -57,7 +57,7 @@ enum ForSuperType implements TypeAttributeAppender {
         public void apply(ClassVisitor classVisitor, TypeDescription typeDescription) {
             AnnotationAppender annotationAppender =
                     new AnnotationAppender.Default(new AnnotationAppender.Target.OnType(classVisitor));
-            for (AnnotationDescription annotation : typeDescription.getSuperType().getDeclaredAnnotations()) {
+            for (AnnotationDescription annotation : typeDescription.getSuperType().asRawType().getDeclaredAnnotations()) {
                 annotationAppender.append(annotation, AnnotationAppender.AnnotationVisibility.of(annotation));
             }
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Default.java
Patch:
@@ -53,7 +53,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                Assigner assigner) {
             if (!target.getType().asRawType().isInterface()) {
                 throw new IllegalStateException(target + " uses the @Default annotation on a non-interface type");
-            } else if (source.isStatic() || !implementationTarget.getTypeDescription().getInterfaces().contains(target.getType().asRawType())) {
+            } else if (source.isStatic() || !implementationTarget.getTypeDescription().getInterfaces().asRawTypes().contains(target.getType().asRawType())) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             } else {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(new TypeProxy.ForDefaultMethod(target.getType().asRawType(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultCall.java
Patch:
@@ -146,7 +146,7 @@ public Implementation.SpecialMethodInvocation resolve(Implementation.Target impl
                                                                       MethodDescription source) {
                     String uniqueSignature = source.getUniqueSignature();
                     Implementation.SpecialMethodInvocation specialMethodInvocation = null;
-                    for (TypeDescription candidate : implementationTarget.getTypeDescription().getInterfaces()) {
+                    for (TypeDescription candidate : implementationTarget.getTypeDescription().getInterfaces().asRawTypes()) {
                         if (source.isSpecializableFor(candidate)) {
                             if (specialMethodInvocation != null) {
                                 return Implementation.SpecialMethodInvocation.Illegal.INSTANCE;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -155,7 +155,7 @@ public static TargetMethodAnnotationDrivenBinder.ParameterBinder<Morph> install(
         private static MethodDescription onlyMethod(TypeDescription typeDescription) {
             if (!typeDescription.isInterface()) {
                 throw new IllegalArgumentException(typeDescription + " is not an interface");
-            } else if (typeDescription.getInterfaces().size() > 0) {
+            } else if (!typeDescription.getInterfaces().isEmpty()) {
                 throw new IllegalArgumentException(typeDescription + " must not extend other interfaces");
             } else if (!typeDescription.isPublic()) {
                 throw new IllegalArgumentException(typeDescription + " is mot public");
@@ -265,7 +265,7 @@ public Implementation.SpecialMethodInvocation resolve(Implementation.Target impl
                                                                       MethodDescription source) {
                     String uniqueSignature = source.getUniqueSignature();
                     Implementation.SpecialMethodInvocation specialMethodInvocation = null;
-                    for (TypeDescription candidate : implementationTarget.getTypeDescription().getInterfaces()) {
+                    for (TypeDescription candidate : implementationTarget.getTypeDescription().getInterfaces().asRawTypes()) {
                         if (source.isSpecializableFor(candidate)) {
                             if (specialMethodInvocation != null) {
                                 return Implementation.SpecialMethodInvocation.Illegal.INSTANCE;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -156,7 +156,7 @@ public static TargetMethodAnnotationDrivenBinder.ParameterBinder<Pipe> install(T
         private static MethodDescription onlyMethod(TypeDescription typeDescription) {
             if (!typeDescription.isInterface()) {
                 throw new IllegalArgumentException(typeDescription + " is not an interface");
-            } else if (typeDescription.getInterfaces().size() > 0) {
+            } else if (!typeDescription.getInterfaces().isEmpty()) {
                 throw new IllegalArgumentException(typeDescription + " must not extend other interfaces");
             } else if (!typeDescription.isPublic()) {
                 throw new IllegalArgumentException(typeDescription + " is mot public");

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperCall.java
Patch:
@@ -77,7 +77,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                     Implementation.Target.MethodLookup.Default.EXACT);
             if (!specialMethodInvocation.isValid()
                     && source.isDefaultMethod()
-                    && implementationTarget.getTypeDescription().getInterfaces().contains(source.getDeclaringType())
+                    && implementationTarget.getTypeDescription().getInterfaces().asRawTypes().contains(source.getDeclaringType())
                     && annotation.loadSilent().fallbackToDefault()) {
                 specialMethodInvocation = implementationTarget.invokeDefault(source.getDeclaringType(), source.getUniqueSignature());
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -2683,14 +2683,14 @@ protected LazyTypeDescription(TypePool typePool,
         }
 
         @Override
-        public GenericTypeDescription getSuperTypeGen() {
+        public GenericTypeDescription getSuperType() {
             return superTypeDescriptor == null || isInterface()
                     ? null
                     : signatureResolution.resolveSuperType(superTypeDescriptor, typePool, this);
         }
 
         @Override
-        public GenericTypeList getInterfacesGen() {
+        public GenericTypeList getInterfaces() {
             return signatureResolution.resolveInterfaceTypes(interfaceTypeDescriptors, typePool, this);
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/InlineInstrumentedTypeTest.java
Patch:
@@ -39,9 +39,9 @@ public void setUp() throws Exception {
         when(levelType.getSourceCodeName()).thenReturn(FOO);
         when(levelType.getDeclaredMethods()).thenReturn(new MethodList.Empty());
         when(levelType.getDeclaredFields()).thenReturn(new FieldList.Empty());
-        when(levelType.getInterfacesGen()).thenReturn(new GenericTypeList.Empty());
+        when(levelType.getInterfaces()).thenReturn(new GenericTypeList.Empty());
         when(levelType.getTypeVariables()).thenReturn(new GenericTypeList.Empty());
-        when(levelType.getSuperTypeGen()).thenReturn(new TypeDescription.ForLoadedType(Object.class));
+        when(levelType.getSuperType()).thenReturn(new TypeDescription.ForLoadedType(Object.class));
         when(levelType.getPackage()).thenReturn(packageDescription);
         when(packageDescription.getName()).thenReturn(FOO);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTargetTest.java
Patch:
@@ -61,6 +61,7 @@ public void setUp() throws Exception {
         when(instrumentedType.getSuperType()).thenReturn(superType);
         when(superType.getInternalName()).thenReturn(QUX);
         when(superType.getStackSize()).thenReturn(StackSize.ZERO);
+        when(superType.asRawType()).thenReturn(superType);
         when(superMethod.getDeclaringType()).thenReturn(superType);
         when(superMethod.getReturnType()).thenReturn(returnType);
         when(superMethod.getInternalName()).thenReturn(BAZ);
@@ -76,7 +77,7 @@ public void setUp() throws Exception {
     }
 
     @Override
-    protected Implementation.Target makeimplementationTarget() {
+    protected Implementation.Target makeImplementationTarget() {
         return new RebaseImplementationTarget(finding, bridgeMethodResolverFactory, methodRebaseResolver);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategyDefaultTest.java
Patch:
@@ -44,6 +44,7 @@ public void setUp() throws Exception {
                 any(MethodAttributeAppender.Factory.class))).thenReturn(methodRegistry);
         when(instrumentedType.getSuperType()).thenReturn(superType);
         when(superType.getDeclaredMethods()).thenReturn(methodList);
+        when(superType.asRawType()).thenReturn(superType);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTargetFactoryTest.java
Patch:
@@ -46,6 +46,7 @@ public void setUp() throws Exception {
         when(finding.getInvokableDefaultMethods()).thenReturn(Collections.<TypeDescription, Set<MethodDescription>>emptyMap());
         when(finding.getTypeDescription()).thenReturn(instrumentedType);
         when(instrumentedType.getSuperType()).thenReturn(superType);
+        when(superType.asRawType()).thenReturn(superType);
         when(superType.getDeclaredMethods()).thenReturn(new MethodList.Empty());
         factory = new SubclassImplementationTarget.Factory(bridgeMethodResolverFactory,
                 SubclassImplementationTarget.OriginTypeIdentifier.SUPER_TYPE);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTargetTest.java
Patch:
@@ -48,6 +48,7 @@ public void setUp() throws Exception {
         when(instrumentedType.getSuperType()).thenReturn(superType);
         when(superType.getDeclaredMethods()).thenReturn(new MethodList.Explicit(Collections.singletonList(superMethodConstructor)));
         when(superType.getInternalName()).thenReturn(BAR);
+        when(superType.asRawType()).thenReturn(superType);
         when(superMethod.getDeclaringType()).thenReturn(superType);
         when(superType.getStackSize()).thenReturn(StackSize.ZERO);
         when(superMethod.getReturnType()).thenReturn(returnType);
@@ -64,7 +65,7 @@ public void setUp() throws Exception {
     }
 
     @Override
-    protected Implementation.Target makeimplementationTarget() {
+    protected Implementation.Target makeImplementationTarget() {
         return new SubclassImplementationTarget(finding,
                 bridgeMethodResolverFactory,
                 SubclassImplementationTarget.OriginTypeIdentifier.SUPER_TYPE);
@@ -137,6 +138,7 @@ public void apply(MethodLookupEngine.Finding mock) {
                 when(mock.getInvokableDefaultMethods()).thenReturn(Collections.<TypeDescription, Set<MethodDescription>>emptyMap());
                 TypeDescription typeDescription = mock(TypeDescription.class);
                 when(mock.getTypeDescription()).thenReturn(typeDescription);
+                when(typeDescription.asRawType()).thenReturn(typeDescription);
                 when(typeDescription.getSuperType()).thenReturn(typeDescription);
                 when(typeDescription.getDeclaredMethods()).thenReturn(new MethodList.Empty());
             }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/AbstractImplementationTargetTest.java
Patch:
@@ -79,10 +79,10 @@ public MethodDescription answer(InvocationOnMock invocation) throws Throwable {
         when(defaultType.isInterface()).thenReturn(true);
         when(defaultMethod.isSpecializableFor(defaultType)).thenReturn(true);
         when(defaultType.getInternalName()).thenReturn(BAZBAR);
-        implementationTarget = makeimplementationTarget();
+        implementationTarget = makeImplementationTarget();
     }
 
-    protected abstract Implementation.Target makeimplementationTarget();
+    protected abstract Implementation.Target makeImplementationTarget();
 
     @Test
     public void testDefaultMethodInvocation() throws Exception {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/DefaultMethodCallTest.java
Patch:
@@ -1,8 +1,8 @@
 package net.bytebuddy.implementation;
 
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeList;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.test.utility.JavaVersionRule;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
@@ -180,7 +180,7 @@ public List<?> create() {
             @Override
             public void apply(Implementation.Target mock) {
                 TypeDescription typeDescription = mock(TypeDescription.class);
-                when(typeDescription.getInterfaces()).thenReturn(new TypeList.Explicit(Arrays.asList(removalType, mock(TypeDescription.class))));
+                when(typeDescription.getInterfaces()).thenReturn(new GenericTypeList.Explicit(Arrays.asList(removalType, mock(TypeDescription.class))));
                 when(mock.getTypeDescription()).thenReturn(typeDescription);
             }
         }).create(new ObjectPropertyAssertion.Creator<List<?>>() {

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/AbstractAnnotationBinderTest.java
Patch:
@@ -82,5 +82,6 @@ public void setUp() throws Exception {
         when(assigner.assign(any(TypeDescription.class), any(TypeDescription.class), anyBoolean())).thenReturn(stackManipulation);
         when(implementationTarget.getTypeDescription()).thenReturn(instrumentedType);
         when(implementationTarget.getOriginType()).thenReturn(instrumentedType);
+        when(instrumentedType.asRawType()).thenReturn(instrumentedType);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyTypeListTest.java
Patch:
@@ -22,7 +22,7 @@ public class TypePoolLazyTypeListTest {
     @Before
     public void setUp() throws Exception {
         typePool = TypePool.Default.ofClassPath();
-        typeList = typePool.describe(Sample.class.getName()).resolve().getInterfaces();
+        typeList = typePool.describe(Sample.class.getName()).resolve().getInterfaces().asRawTypes();
     }
 
     @After

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -93,7 +93,7 @@ public int getModifiers() {
 
         @Override
         public int getOffset() {
-            TypeList parameterType = getDeclaringMethod().getParameters().asTypeList();
+            TypeList parameterType = getDeclaringMethod().getParameters().asTypeList().asRawTypes();
             int offset = getDeclaringMethod().isStatic()
                     ? StackSize.ZERO.getSize()
                     : StackSize.SINGLE.getSize();

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/GenericTypeDescription.java
Patch:
@@ -430,8 +430,8 @@ protected static TypeVariableProxy of(TypeDescription substitute,
                                                            Visitor<TypeDescription> substitutor,
                                                            MethodDescription methodDescription) {
                             return new ForMethod(substitute,
-                                    returns(rawType(methodDescription.getReturnType().asRawType().accept(substitutor)))
-                                            .and(takesArguments(rawTypes(methodDescription.getParameters().asTypeListGen().asRawTypes().accept(substitutor))))
+                                    returns(methodDescription.getReturnType().asRawType().accept(substitutor))
+                                            .and(takesArguments(methodDescription.getParameters().asTypeList().asRawTypes().accept(substitutor)))
                                             .and(methodDescription.isConstructor()
                                                     ? isConstructor()
                                                     : ElementMatchers.<MethodDescription>named(methodDescription.getName())));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1648,7 +1648,7 @@ public MatchedMethodInterception<S> defineMethod(MethodDescription methodDescrip
                 }
                 return defineMethod(methodDescription.getName(),
                         methodDescription.getReturnType(),
-                        methodDescription.getParameters().asTypeListGen(),
+                        methodDescription.getParameters().asTypeList(),
                         methodDescription.getModifiers()).throwing(methodDescription.getExceptionTypes());
             }
 
@@ -1692,7 +1692,7 @@ public MatchedMethodInterception<S> defineConstructor(MethodDescription methodDe
                 if (!methodDescription.isConstructor()) {
                     throw new IllegalArgumentException("Not a constructor: " + methodDescription);
                 }
-                return defineConstructor(methodDescription.getParameters().asTypeListGen(), methodDescription.getModifiers())
+                return defineConstructor(methodDescription.getParameters().asTypeList(), methodDescription.getModifiers())
                         .throwing(methodDescription.getExceptionTypes());
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodLookupEngine.java
Patch:
@@ -386,7 +386,7 @@ public GenericTypeDescription getReturnType() {
 
         @Override
         public ParameterList getParameters() {
-            return ParameterList.Explicit.latent(this, methodDescriptions.get(ANY).getParameters().asTypeList());
+            return ParameterList.Explicit.latent(this, methodDescriptions.get(ANY).getParameters().asTypeList().asRawTypes());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/InliningImplementationMatcher.java
Patch:
@@ -51,7 +51,7 @@ protected static LatentMethodMatcher of(ElementMatcher<? super MethodDescription
                     ? isConstructor()
                     : ElementMatchers.<MethodDescription>named(methodDescription.getName());
             signature = signature.and(returns(methodDescription.getReturnType().asRawType()));
-            signature = signature.and(takesArguments(methodDescription.getParameters().asTypeList()));
+            signature = signature.and(takesArguments(methodDescription.getParameters().asTypeList().asRawTypes()));
             predefinedMethodSignatures = predefinedMethodSignatures.or(signature);
         }
         return new InliningImplementationMatcher(ignoredMethods, predefinedMethodSignatures);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTarget.java
Patch:
@@ -170,14 +170,14 @@ public boolean equals(Object other) {
             return isValid() == specialMethodInvocation.isValid()
                     && instrumentedType.equals(specialMethodInvocation.getTypeDescription())
                     && methodDescription.getInternalName().equals(specialMethodInvocation.getMethodDescription().getInternalName())
-                    && methodDescription.getParameters().asTypeList().equals(specialMethodInvocation.getMethodDescription().getParameters().asTypeList())
+                    && methodDescription.getParameters().asTypeList().asRawTypes().equals(specialMethodInvocation.getMethodDescription().getParameters().asTypeList().asRawTypes())
                     && methodDescription.getReturnType().asRawType().equals(specialMethodInvocation.getMethodDescription().getReturnType().asRawType());
         }
 
         @Override
         public int hashCode() {
             int result = methodDescription.getInternalName().hashCode();
-            result = 31 * result + methodDescription.getParameters().asTypeList().hashCode();
+            result = 31 * result + methodDescription.getParameters().asTypeList().asRawTypes().hashCode();
             result = 31 * result + methodDescription.getReturnType().asRawType().hashCode();
             result = 31 * result + instrumentedType.hashCode();
             return result;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTarget.java
Patch:
@@ -47,15 +47,15 @@ protected SubclassImplementationTarget(MethodLookupEngine.Finding finding,
                 : superType.getDeclaredMethods().filter(isConstructor());
         this.superConstructors = new HashMap<TypeList, MethodDescription>(superConstructors.size());
         for (MethodDescription superConstructor : superConstructors) {
-            this.superConstructors.put(superConstructor.getParameters().asTypeList(), superConstructor);
+            this.superConstructors.put(superConstructor.getParameters().asTypeList().asRawTypes(), superConstructor);
         }
         this.originTypeIdentifier = originTypeIdentifier;
     }
 
     @Override
     protected Implementation.SpecialMethodInvocation invokeSuper(MethodDescription methodDescription) {
         if (methodDescription.isConstructor()) {
-            methodDescription = this.superConstructors.get(methodDescription.getParameters().asTypeList());
+            methodDescription = this.superConstructors.get(methodDescription.getParameters().asTypeList().asRawTypes());
             if (methodDescription == null) {
                 return Implementation.SpecialMethodInvocation.Illegal.INSTANCE;
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -206,14 +206,14 @@ public boolean equals(Object other) {
                 return isValid() == specialMethodInvocation.isValid()
                         && typeDescription.equals(specialMethodInvocation.getTypeDescription())
                         && methodDescription.getInternalName().equals(specialMethodInvocation.getMethodDescription().getInternalName())
-                        && methodDescription.getParameters().asTypeList().equals(specialMethodInvocation.getMethodDescription().getParameters().asTypeList())
+                        && methodDescription.getParameters().asTypeList().asRawTypes().equals(specialMethodInvocation.getMethodDescription().getParameters().asTypeList().asRawTypes())
                         && methodDescription.getReturnType().asRawType().equals(specialMethodInvocation.getMethodDescription().getReturnType().asRawType());
             }
 
             @Override
             public int hashCode() {
                 int result = methodDescription.getInternalName().hashCode();
-                result = 31 * result + methodDescription.getParameters().asTypeList().hashCode();
+                result = 31 * result + methodDescription.getParameters().asTypeList().asRawTypes().hashCode();
                 result = 31 * result + methodDescription.getReturnType().asRawType().hashCode();
                 result = 31 * result + typeDescription.hashCode();
                 return result;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -114,7 +114,7 @@ public static InvocationHandlerAdapter toInstanceField(String fieldName) {
      * @return A list of stack manipulation that loads all arguments of an instrumented method.
      */
     private List<StackManipulation> argumentValuesOf(MethodDescription instrumentedMethod) {
-        TypeList parameterTypes = instrumentedMethod.getParameters().asTypeList();
+        TypeList parameterTypes = instrumentedMethod.getParameters().asTypeList().asRawTypes();
         List<StackManipulation> instruction = new ArrayList<StackManipulation>(parameterTypes.size());
         TypeDescription objectType = TypeDescription.OBJECT;
         int currentIndex = 1;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -2278,7 +2278,7 @@ public Size apply(MethodVisitor methodVisitor,
                           Context implementationContext,
                           MethodDescription instrumentedMethod) {
             MethodDescription invokedMethod = methodLocator.resolve(instrumentedMethod);
-            TypeList methodParameters = invokedMethod.getParameters().asTypeList();
+            TypeList methodParameters = invokedMethod.getParameters().asTypeList().asRawTypes();
             if (methodParameters.size() != argumentLoaders.size()) {
                 throw new IllegalStateException(invokedMethod + " does not take " + argumentLoaders.size() + " arguments");
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/AllArguments.java
Patch:
@@ -142,8 +142,8 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             int offset = source.isStatic() || includeThis ? 0 : 1;
             boolean dynamicallyTyped = RuntimeType.Verifier.check(target);
             for (TypeDescription sourceParameter : includeThis
-                    ? join(implementationTarget.getTypeDescription(), source.getParameters().asTypeList())
-                    : source.getParameters().asTypeList()) {
+                    ? join(implementationTarget.getTypeDescription(), source.getParameters().asTypeList().asRawTypes())
+                    : source.getParameters().asTypeList().asRawTypes()) {
                 StackManipulation stackManipulation = new StackManipulation.Compound(
                         MethodVariableAccess.forType(sourceParameter).loadOffset(offset),
                         assigner.assign(sourceParameter, arrayFactory.getComponentType(), dynamicallyTyped));

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -701,7 +701,7 @@ public Size apply(MethodVisitor methodVisitor,
                         StackManipulation arrayReference = MethodVariableAccess.REFERENCE.loadOffset(1);
                         StackManipulation[] parameterLoading = new StackManipulation[accessorMethod.getParameters().size()];
                         int index = 0;
-                        for (TypeDescription parameterType : accessorMethod.getParameters().asTypeList()) {
+                        for (TypeDescription parameterType : accessorMethod.getParameters().asTypeList().asRawTypes()) {
                             parameterLoading[index] = new StackManipulation.Compound(arrayReference,
                                     IntegerConstant.forValue(index),
                                     ArrayAccess.REFERENCE.load(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -289,7 +289,7 @@ protected Redirection(TypeDescription forwardingType,
              * given method.
              */
             private static LinkedHashMap<String, TypeDescription> extractFields(MethodDescription methodDescription) {
-                TypeList parameterTypes = methodDescription.getParameters().asTypeList();
+                TypeList parameterTypes = methodDescription.getParameters().asTypeList().asRawTypes();
                 LinkedHashMap<String, TypeDescription> typeDescriptions = new LinkedHashMap<String, TypeDescription>(parameterTypes.size());
                 int currentIndex = 0;
                 for (TypeDescription parameterType : parameterTypes) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/constant/MethodConstant.java
Patch:
@@ -80,7 +80,7 @@ public boolean isValid() {
     public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
         Size argumentSize = prepare(methodVisitor)
                 .aggregate(ArrayFactory.forType(TypeDescription.CLASS)
-                        .withValues(typeConstantsFor(methodDescription.getParameters().asTypeList()))
+                        .withValues(typeConstantsFor(methodDescription.getParameters().asTypeList().asRawTypes()))
                         .apply(methodVisitor, implementationContext));
         methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                 CLASS_TYPE_INTERNAL_NAME,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodInvocation.java
Patch:
@@ -270,7 +270,7 @@ public boolean equals(Object other) {
             return MethodInvocation.this.equals(((Invocation) other).getOuterInstance())
                     && methodDescription.getInternalName().equals(that.methodDescription.getInternalName())
                     && methodDescription.getReturnType().asRawType().equals(((Invocation) other).methodDescription.getReturnType().asRawType())
-                    && methodDescription.getParameters().asTypeList().equals(((Invocation) other).methodDescription.getParameters().asTypeList())
+                    && methodDescription.getParameters().asTypeList().asRawTypes().equals(((Invocation) other).methodDescription.getParameters().asTypeList().asRawTypes())
                     && typeDescription.equals(that.typeDescription);
         }
 
@@ -279,7 +279,7 @@ public int hashCode() {
             int result = typeDescription.hashCode();
             result = 31 * result + MethodInvocation.this.hashCode();
             result = 31 * result + methodDescription.getInternalName().hashCode();
-            result = 31 * result + methodDescription.getParameters().asTypeList().hashCode();
+            result = 31 * result + methodDescription.getParameters().asTypeList().asRawTypes().hashCode();
             result = 31 * result + methodDescription.getReturnType().asRawType().hashCode();
             return result;
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypeMatcher.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.method.ParameterList;
-import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.generic.GenericTypeList;
 
 /**
  * An element matcher that matches a method's parameter types.
@@ -13,14 +13,14 @@ public class MethodParameterTypeMatcher<T extends ParameterList> extends Element
     /**
      * The matcher to apply to the parameter types.
      */
-    private final ElementMatcher<? super TypeList> parameterMatcher;
+    private final ElementMatcher<? super GenericTypeList> parameterMatcher;
 
     /**
      * Creates a new matcher for a method's parameter types.
      *
      * @param parameterMatcher The matcher to apply to the parameter types.
      */
-    public MethodParameterTypeMatcher(ElementMatcher<? super TypeList> parameterMatcher) {
+    public MethodParameterTypeMatcher(ElementMatcher<? super GenericTypeList> parameterMatcher) {
         this.parameterMatcher = parameterMatcher;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaInstance.java
Patch:
@@ -163,7 +163,7 @@ public static MethodType of(Constructor<?> constructor) {
          * @return The method type of the given method.
          */
         public static MethodType of(MethodDescription methodDescription) {
-            return new MethodType(methodDescription.getReturnType().asRawType(), methodDescription.getParameters().asTypeList());
+            return new MethodType(methodDescription.getReturnType().asRawType(), methodDescription.getParameters().asTypeList().asRawTypes());
         }
 
         /**
@@ -523,7 +523,7 @@ public static MethodHandle of(MethodDescription methodDescription) {
                     methodDescription.getDeclaringType(),
                     methodDescription.getInternalName(),
                     methodDescription.getReturnType().asRawType(),
-                    methodDescription.getParameters().asTypeList());
+                    methodDescription.getParameters().asTypeList().asRawTypes());
 
         }
 
@@ -553,7 +553,7 @@ public static MethodHandle ofSpecial(MethodDescription methodDescription, TypeDe
                     typeDescription,
                     methodDescription.getInternalName(),
                     methodDescription.getReturnType().asRawType(),
-                    methodDescription.getParameters().asTypeList());
+                    methodDescription.getParameters().asTypeList().asRawTypes());
         }
 
         /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverMethodsOnlyTest.java
Patch:
@@ -3,8 +3,8 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeList;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.StackSize;
 import net.bytebuddy.test.utility.MockitoRule;
@@ -73,7 +73,8 @@ public void testResolutionInstrumentedMethod() throws Exception {
         assertThat(resolution.getAdditionalArguments(), is((StackManipulation) StackManipulation.LegalTrivial.INSTANCE));
         assertThat(resolution.getResolvedMethod().getInternalName(), is(BAR));
         assertThat(resolution.getResolvedMethod().getReturnType(), is((GenericTypeDescription) returnType));
-        assertThat(resolution.getResolvedMethod().getParameters().asTypeList(), is((TypeList) new TypeList.Explicit(Collections.singletonList(parameterType))));
+        assertThat(resolution.getResolvedMethod().getParameters().asTypeList(),
+                is((GenericTypeList) new GenericTypeList.Explicit(Collections.singletonList(parameterType))));
         assertThat(resolution.getResolvedMethod().isSynthetic(), is(true));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTargetTest.java
Patch:
@@ -4,7 +4,7 @@
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.generic.GenericTypeList;
 import net.bytebuddy.dynamic.scaffold.BridgeMethodResolver;
 import net.bytebuddy.dynamic.scaffold.MethodLookupEngine;
 import net.bytebuddy.implementation.AbstractImplementationTargetTest;
@@ -39,7 +39,7 @@ public class SubclassImplementationTargetTest extends AbstractImplementationTarg
     private ParameterList parameterList;
 
     @Mock
-    private TypeList parameterTypes;
+    private GenericTypeList parameterTypes;
 
     @Override
     @Before

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/AllArgumentsBinderTest.java
Patch:
@@ -66,7 +66,7 @@ public void testLegalStrictBindingNoRuntimeType() throws Exception {
     private void testLegalStrictBinding(boolean dynamicallyTyped, Annotation... targetAnnotation) throws Exception {
         when(annotation.value()).thenReturn(AllArguments.Assignment.STRICT);
         when(stackManipulation.isValid()).thenReturn(true);
-        when(sourceTypeList.iterator()).thenReturn(Arrays.asList(firstSourceType, secondSourceType).iterator());
+        when(rawSourceTypeList.iterator()).thenReturn(Arrays.asList(firstSourceType, secondSourceType).iterator());
         when(source.isStatic()).thenReturn(false);
         when(targetType.isArray()).thenReturn(true);
         when(targetType.getComponentType()).thenReturn(componentType);
@@ -90,7 +90,7 @@ public void testIllegalBinding() throws Exception {
         when(target.getIndex()).thenReturn(1);
         when(annotation.value()).thenReturn(AllArguments.Assignment.STRICT);
         when(stackManipulation.isValid()).thenReturn(false);
-        when(sourceTypeList.iterator()).thenReturn(Arrays.asList(firstSourceType, secondSourceType).iterator());
+        when(rawSourceTypeList.iterator()).thenReturn(Arrays.asList(firstSourceType, secondSourceType).iterator());
         when(source.isStatic()).thenReturn(false);
         when(targetType.isArray()).thenReturn(true);
         when(targetType.getComponentType()).thenReturn(componentType);
@@ -113,7 +113,7 @@ public void testLegalSlackBinding() throws Exception {
         when(target.getIndex()).thenReturn(1);
         when(annotation.value()).thenReturn(AllArguments.Assignment.SLACK);
         when(stackManipulation.isValid()).thenReturn(false);
-        when(sourceTypeList.iterator()).thenReturn(Arrays.asList(firstSourceType, secondSourceType).iterator());
+        when(rawSourceTypeList.iterator()).thenReturn(Arrays.asList(firstSourceType, secondSourceType).iterator());
         when(source.isStatic()).thenReturn(false);
         when(targetType.isArray()).thenReturn(true);
         when(targetType.getComponentType()).thenReturn(componentType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/ElementMatchersTest.java
Patch:
@@ -534,7 +534,8 @@ public void testCanThrow() throws Exception {
     @Test
     @SuppressWarnings("unchecked")
     public void testDeclaresExceptionForNonThrowableType() throws Exception {
-        assertThat(ElementMatchers.declaresException((Class) Object.class).matches(new Object()), is(false));
+        ElementMatcher<Object> elementMatcher = (ElementMatcher) ElementMatchers.declaresException((Class) Object.class);
+        assertThat(elementMatcher.matches(new Object()), is(false));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterList.java
Patch:
@@ -329,7 +329,7 @@ public int size() {
         public TypeList asTypeList() {
             List<TypeDescription> typeDescriptions = new ArrayList<TypeDescription>(parameterDescriptions.size());
             for (ParameterDescription parameterDescription : parameterDescriptions) {
-                typeDescriptions.add(parameterDescription.getType());
+                typeDescriptions.add(parameterDescription.getType().asRawType());
             }
             return new TypeList.Explicit(typeDescriptions);
         }
@@ -338,7 +338,7 @@ public TypeList asTypeList() {
         public GenericTypeList asTypeListGen() {
             List<GenericTypeDescription> types = new ArrayList<GenericTypeDescription>(parameterDescriptions.size());
             for (ParameterDescription parameterDescription : parameterDescriptions) {
-                types.add(parameterDescription.getTypeGen());
+                types.add(parameterDescription.getType());
             }
             return new GenericTypeList.Explicit(types);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1649,7 +1649,7 @@ public MatchedMethodInterception<S> defineMethod(MethodDescription methodDescrip
                 return defineMethod(methodDescription.getName(),
                         methodDescription.getReturnType(),
                         methodDescription.getParameters().asTypeListGen(),
-                        methodDescription.getModifiers()).throwing(methodDescription.getExceptionTypesGen());
+                        methodDescription.getModifiers()).throwing(methodDescription.getExceptionTypes());
             }
 
             @Override
@@ -1693,7 +1693,7 @@ public MatchedMethodInterception<S> defineConstructor(MethodDescription methodDe
                     throw new IllegalArgumentException("Not a constructor: " + methodDescription);
                 }
                 return defineConstructor(methodDescription.getParameters().asTypeListGen(), methodDescription.getModifiers())
-                        .throwing(methodDescription.getExceptionTypesGen());
+                        .throwing(methodDescription.getExceptionTypes());
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodLookupEngine.java
Patch:
@@ -227,7 +227,7 @@ public ParameterList getParameters() {
         }
 
         @Override
-        public GenericTypeList getExceptionTypesGen() {
+        public GenericTypeList getExceptionTypes() {
             return new GenericTypeList.Explicit(methodChain.get(MOST_SPECIFIC).getExceptionTypes());
         }
 
@@ -390,7 +390,7 @@ public ParameterList getParameters() {
         }
 
         @Override
-        public GenericTypeList getExceptionTypesGen() {
+        public GenericTypeList getExceptionTypes() {
             return new GenericTypeList.Empty();
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -127,7 +127,7 @@ protected ByteCodeAppender.Size applySetter(MethodVisitor methodVisitor,
                                                 Implementation.Context implementationContext,
                                                 FieldDescription fieldDescription,
                                                 MethodDescription methodDescription) {
-        StackManipulation stackManipulation = assigner.assign(methodDescription.getParameters().get(0).getType(),
+        StackManipulation stackManipulation = assigner.assign(methodDescription.getParameters().get(0).getType().asRawType(),
                 fieldDescription.getType().asRawType(),
                 dynamicallyTyped);
         if (!stackManipulation.isValid()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -973,8 +973,8 @@ public StackManipulation resolve(TypeDescription instrumentedType,
                 }
                 ParameterDescription parameterDescription = interceptedMethod.getParameters().get(index);
                 StackManipulation stackManipulation = new StackManipulation.Compound(
-                        MethodVariableAccess.forType(parameterDescription.getType()).loadOffset(parameterDescription.getOffset()),
-                        assigner.assign(parameterDescription.getType(), targetType, dynamicallyTyped));
+                        MethodVariableAccess.forType(parameterDescription.getType().asRawType()).loadOffset(parameterDescription.getOffset()),
+                        assigner.assign(parameterDescription.getType().asRawType(), targetType, dynamicallyTyped));
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot assign " + parameterDescription + " to " + targetType + " for " + interceptedMethod);
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -111,7 +111,7 @@ private static LinkedHashMap<String, TypeDescription> extractFields(MethodDescri
             typeDescriptions.put(fieldName(currentIndex++), methodDescription.getDeclaringType());
         }
         for (ParameterDescription parameterDescription : parameters) {
-            typeDescriptions.put(fieldName(currentIndex++), parameterDescription.getType());
+            typeDescriptions.put(fieldName(currentIndex++), parameterDescription.getType().asRawType());
         }
         return typeDescriptions;
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/ArgumentTypeResolver.java
Patch:
@@ -48,8 +48,8 @@ private static Resolution resolveRivalBinding(TypeDescription sourceParameterTyp
                                                   MethodDelegationBinder.MethodBinding left,
                                                   int rightParameterIndex,
                                                   MethodDelegationBinder.MethodBinding right) {
-        TypeDescription leftParameterType = left.getTarget().getParameters().get(leftParameterIndex).getType();
-        TypeDescription rightParameterType = right.getTarget().getParameters().get(rightParameterIndex).getType();
+        TypeDescription leftParameterType = left.getTarget().getParameters().get(leftParameterIndex).getType().asRawType();
+        TypeDescription rightParameterType = right.getTarget().getParameters().get(rightParameterIndex).getType().asRawType();
         if (!leftParameterType.equals(rightParameterType)) {
             if (leftParameterType.isPrimitive() && rightParameterType.isPrimitive()) {
                 return PrimitiveTypePrecedence.forPrimitive(leftParameterType)
@@ -104,7 +104,7 @@ public Resolution resolve(MethodDescription source,
             Integer rightParameterIndex = right.getTargetParameterIndex(parameterIndexToken);
             if (leftParameterIndex != null && rightParameterIndex != null) {
                 resolution = resolution.merge(
-                        resolveRivalBinding(sourceParameters.get(sourceParameterIndex).getType(),
+                        resolveRivalBinding(sourceParameters.get(sourceParameterIndex).getType().asRawType(),
                                 leftParameterIndex,
                                 left,
                                 rightParameterIndex,

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/AllArguments.java
Patch:
@@ -133,10 +133,10 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            if (!target.getType().isArray()) {
+            if (!target.getType().asRawType().isArray()) {
                 throw new IllegalStateException("Expected an array type for all argument annotation on " + source);
             }
-            ArrayFactory arrayFactory = ArrayFactory.forType(target.getType().getComponentType());
+            ArrayFactory arrayFactory = ArrayFactory.forType(target.getType().asRawType().getComponentType());
             boolean includeThis = !source.isStatic() && annotation.loadSilent().includeSelf();
             List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(source.getParameters().size() + (includeThis ? 1 : 0));
             int offset = source.isStatic() || includeThis ? 0 : 1;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Argument.java
Patch:
@@ -162,8 +162,8 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             } else if (source.getParameters().size() <= argument.value()) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             }
-            return argument.bindingMechanic().makeBinding(source.getParameters().get(argument.value()).getType(),
-                    target.getType(),
+            return argument.bindingMechanic().makeBinding(source.getParameters().get(argument.value()).getType().asRawType(),
+                    target.getType().asRawType(),
                     argument.value(),
                     assigner,
                     RuntimeType.Verifier.check(target),

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Default.java
Patch:
@@ -51,12 +51,12 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            if (!target.getType().isInterface()) {
+            if (!target.getType().asRawType().isInterface()) {
                 throw new IllegalStateException(target + " uses the @Default annotation on a non-interface type");
-            } else if (source.isStatic() || !implementationTarget.getTypeDescription().getInterfaces().contains(target.getType())) {
+            } else if (source.isStatic() || !implementationTarget.getTypeDescription().getInterfaces().contains(target.getType().asRawType())) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             } else {
-                return new MethodDelegationBinder.ParameterBinding.Anonymous(new TypeProxy.ForDefaultMethod(target.getType(),
+                return new MethodDelegationBinder.ParameterBinding.Anonymous(new TypeProxy.ForDefaultMethod(target.getType().asRawType(),
                         implementationTarget,
                         annotation.loadSilent().serializableProxy()));
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/DefaultCall.java
Patch:
@@ -95,7 +95,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            TypeDescription targetType = target.getType();
+            TypeDescription targetType = target.getType().asRawType();
             if (!targetType.represents(Runnable.class) && !targetType.represents(Callable.class) && !targetType.represents(Object.class)) {
                 throw new IllegalStateException("A default method call proxy can only be assigned to Runnable or Callable types: " + target);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Empty.java
Patch:
@@ -40,7 +40,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            return new MethodDelegationBinder.ParameterBinding.Anonymous(DefaultValue.of(target.getType()));
+            return new MethodDelegationBinder.ParameterBinding.Anonymous(DefaultValue.of(target.getType().asRawType()));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java
Patch:
@@ -167,7 +167,7 @@ private static MethodDescription onlyMethod(TypeDescription typeDescription) {
             MethodDescription methodDescription = methodCandidates.getOnly();
             if (!methodDescription.getReturnType().asRawType().represents(Object.class)) {
                 throw new IllegalArgumentException(methodDescription + " does not return an Object-type");
-            } else if (methodDescription.getParameters().size() != 1 || !methodDescription.getParameters().get(0).getType().represents(Object[].class)) {
+            } else if (methodDescription.getParameters().size() != 1 || !methodDescription.getParameters().get(0).getType().asRawType().represents(Object[].class)) {
                 throw new IllegalArgumentException(methodDescription + " does not take a single argument of type Object[]");
             }
             return methodDescription;
@@ -184,9 +184,9 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            if (!target.getType().equals(forwardingMethod.getDeclaringType())) {
+            if (!target.getType().asRawType().equals(forwardingMethod.getDeclaringType())) {
                 throw new IllegalStateException(String.format("The installed type %s for the @Morph annotation does not " +
-                        "equal the annotated parameter type on %s", target.getType(), target));
+                        "equal the annotated parameter type on %s", target.getType().asRawType(), target));
             }
             Implementation.SpecialMethodInvocation specialMethodInvocation;
             TypeDescription typeDescription = annotation.getValue(DEFAULT_TARGET, TypeDescription.class);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Origin.java
Patch:
@@ -75,7 +75,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            TypeDescription parameterType = target.getType();
+            TypeDescription parameterType = target.getType().asRawType();
             if (parameterType.represents(Class.class)) {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(ClassConstant.of(implementationTarget.getOriginType()));
             } else if (parameterType.represents(Method.class)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -168,7 +168,7 @@ private static MethodDescription onlyMethod(TypeDescription typeDescription) {
             MethodDescription methodDescription = methodCandidates.getOnly();
             if (!methodDescription.getReturnType().asRawType().represents(Object.class)) {
                 throw new IllegalArgumentException(methodDescription + " does not return an Object-type");
-            } else if (methodDescription.getParameters().size() != 1 || !methodDescription.getParameters().get(0).getType().represents(Object.class)) {
+            } else if (methodDescription.getParameters().size() != 1 || !methodDescription.getParameters().getOnly().getType().asRawType().represents(Object.class)) {
                 throw new IllegalArgumentException(methodDescription + " does not take a single Object-typed argument");
             }
             return methodDescription;
@@ -185,9 +185,9 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            if (!target.getType().equals(forwardingMethod.getDeclaringType())) {
+            if (!target.getType().asRawType().equals(forwardingMethod.getDeclaringType())) {
                 throw new IllegalStateException(String.format("The installed type %s for the @Pipe annotation does not " +
-                        "equal the annotated parameter type on %s", target.getType(), target));
+                        "equal the annotated parameter type on %s", target.getType().asRawType(), target));
             } else if (source.isStatic()) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Super.java
Patch:
@@ -14,7 +14,6 @@
 import net.bytebuddy.implementation.bytecode.assign.Assigner;
 
 import java.lang.annotation.*;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
@@ -212,12 +211,12 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            if (source.isStatic() || !implementationTarget.getTypeDescription().isAssignableTo(target.getType())) {
+            if (source.isStatic() || !implementationTarget.getTypeDescription().isAssignableTo(target.getType().asRawType())) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             } else {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(annotation
                         .getValue(STRATEGY, EnumerationDescription.class).load(Instantiation.class)
-                        .proxyFor(target.getType(), implementationTarget, annotation));
+                        .proxyFor(target.getType().asRawType(), implementationTarget, annotation));
             }
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/SuperCall.java
Patch:
@@ -69,7 +69,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            TypeDescription targetType = target.getType();
+            TypeDescription targetType = target.getType().asRawType();
             if (!targetType.represents(Runnable.class) && !targetType.represents(Callable.class) && !targetType.represents(Object.class)) {
                 throw new IllegalStateException("A super method call proxy can only be assigned to Runnable or Callable types: " + target);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/This.java
Patch:
@@ -63,10 +63,10 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            if (target.getType().isPrimitive()) {
+            if (target.getType().asRawType().isPrimitive()) {
                 throw new IllegalStateException(String.format("The %d. argument virtual %s is a primitive type " +
                         "and can never be bound to an instance", target.getIndex(), target));
-            } else if (target.getType().isArray()) {
+            } else if (target.getType().asRawType().isArray()) {
                 throw new IllegalStateException(String.format("The %d. argument virtual %s is an array type " +
                         "and can never be bound to an instance", target.getIndex(), target));
             } else if (source.isStatic() && !annotation.loadSilent().optional()) {
@@ -75,7 +75,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             StackManipulation assignment = source.isStatic()
                     ? NullConstant.INSTANCE
                     : new StackManipulation.Compound(MethodVariableAccess.REFERENCE.loadOffset(THIS_REFERENCE_INDEX),
-                    assigner.assign(implementationTarget.getTypeDescription(), target.getType(), RuntimeType.Verifier.check(target)));
+                    assigner.assign(implementationTarget.getTypeDescription(), target.getType().asRawType(), RuntimeType.Verifier.check(target)));
             return assignment.isValid()
                     ? new MethodDelegationBinder.ParameterBinding.Anonymous(assignment)
                     : MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -902,7 +902,8 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> declaresE
      */
     public static <T extends MethodDescription> ElementMatcher.Junction<T> declaresException(TypeDescription exceptionType) {
         return exceptionType.isAssignableTo(Throwable.class)
-                ? ElementMatchers.<T>declaresException(new CollectionItemMatcher<TypeDescription>(new SubTypeMatcher<TypeDescription>(exceptionType)))
+                ? ElementMatchers.<T>declaresException(new CollectionItemMatcher<GenericTypeDescription>(
+                rawType(new SubTypeMatcher<TypeDescription>(exceptionType))))
                 : new BooleanMatcher<T>(false);
     }
 
@@ -914,7 +915,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> declaresE
      * @return A matcher that matches a method description by its declared exceptions.
      */
     public static <T extends MethodDescription> ElementMatcher.Junction<T> declaresException(
-            ElementMatcher<? super Iterable<? extends TypeDescription>> exceptionMatcher) {
+            ElementMatcher<? super Iterable<? extends GenericTypeDescription>> exceptionMatcher) {
         return new MethodExceptionTypeMatcher<T>(nonNull(exceptionMatcher));
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodExceptionTypeMatcher.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.method.MethodDescription;
-import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.generic.GenericTypeList;
 
 /**
  * An element matcher that matches the exceptions that are declared by a method.
@@ -13,14 +13,14 @@ public class MethodExceptionTypeMatcher<T extends MethodDescription> extends Ele
     /**
      * The matcher to apply to the matched method's exceptions.
      */
-    private final ElementMatcher<? super TypeList> exceptionMatcher;
+    private final ElementMatcher<? super GenericTypeList> exceptionMatcher;
 
     /**
      * Creates a new matcher for a method's exceptions.
      *
      * @param exceptionMatcher The matcher to apply to the matched method's exceptions.
      */
-    public MethodExceptionTypeMatcher(ElementMatcher<? super TypeList> exceptionMatcher) {
+    public MethodExceptionTypeMatcher(ElementMatcher<? super GenericTypeList> exceptionMatcher) {
         this.exceptionMatcher = exceptionMatcher;
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -501,7 +501,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                                                                ParameterDescription target,
                                                                Implementation.Target implementationTarget,
                                                                Assigner assigner) {
-            if (!target.getType().represents(String.class)) {
+            if (!target.getType().asRawType().represents(String.class)) { // TODO: Change tutorial
                 throw new IllegalStateException(target + " makes wrong use of StringValue");
             }
             StackManipulation constant = new TextConstant(annotation.loadSilent().value());

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTest.java
Patch:
@@ -59,7 +59,7 @@ public void testTypeInitializer() throws Exception {
         assertThat(typeInitializer.getDeclaringType(), is(typeDescription));
         assertThat(typeInitializer.getReturnType(), is((GenericTypeDescription) new TypeDescription.ForLoadedType(void.class)));
         assertThat(typeInitializer.getParameters(), is((ParameterList) new ParameterList.Empty()));
-        assertThat(typeInitializer.getExceptionTypes(), is((TypeList) new TypeList.Empty()));
+        assertThat(typeInitializer.getExceptionTypes(), is((GenericTypeList) new GenericTypeList.Empty()));
         assertThat(typeInitializer.getDeclaredAnnotations(), is((AnnotationList) new AnnotationList.Empty()));
         assertThat(typeInitializer.getModifiers(), is(MethodDescription.TYPE_INITIALIZER_MODIFIER));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/ParameterListForLoadedExecutableTest.java
Patch:
@@ -26,10 +26,10 @@ public void testMethodList() throws Exception {
         assertThat(parameterList.size(), is(2));
         assertThat(parameterList.get(0).getIndex(), is(0));
         assertThat(parameterList.get(0).getOffset(), is(1));
-        assertThat(parameterList.get(0).getType().represents(Void.class), is(true));
+        assertThat(parameterList.get(0).getType().asRawType().represents(Void.class), is(true));
         assertThat(parameterList.get(1).getIndex(), is(1));
         assertThat(parameterList.get(1).getOffset(), is(2));
-        assertThat(parameterList.get(1).getType().represents(Void.class), is(true));
+        assertThat(parameterList.get(1).getType().asRawType().represents(Void.class), is(true));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericSignatureResolutionTest.java
Patch:
@@ -57,8 +57,8 @@ public void testGenericMethod() throws Exception {
         MethodDescription originalMethod = new MethodDescription.ForLoadedMethod(GenericMethod.class.getDeclaredMethod(FOO, Exception.class));
         assertThat(createdMethod.getTypeVariables(), is(originalMethod.getTypeVariables()));
         assertThat(createdMethod.getReturnType(), is(originalMethod.getReturnType()));
-        assertThat(createdMethod.getParameters().getOnly().getTypeGen(), is(originalMethod.getParameters().getOnly().getTypeGen()));
-        assertThat(createdMethod.getExceptionTypesGen().getOnly(), is(originalMethod.getExceptionTypesGen().getOnly()));
+        assertThat(createdMethod.getParameters().getOnly().getType(), is(originalMethod.getParameters().getOnly().getType()));
+        assertThat(createdMethod.getExceptionTypes().getOnly(), is(originalMethod.getExceptionTypes().getOnly()));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/AbstractInstrumentedTypeTest.java
Patch:
@@ -124,7 +124,7 @@ public void testWithMethod() throws Exception {
         assertThat(methodDescription.getParameters().size(), is(1));
         assertThat(methodDescription.getParameters().asTypeList(), is(Collections.singletonList(parameterType)));
         assertThat(methodDescription.getExceptionTypes().size(), is(1));
-        assertThat(methodDescription.getExceptionTypes(), is(Collections.singletonList(exceptionType)));
+        assertThat(methodDescription.getExceptionTypes(), is(Collections.<GenericTypeDescription>singletonList(exceptionType)));
         assertThat(methodDescription.getModifiers(), is(Opcodes.ACC_PUBLIC));
         assertThat(methodDescription.getName(), is(BAR));
         assertThat(methodDescription.getDeclaringType(), sameInstance((TypeDescription) instrumentedType));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedConstructorTest.java
Patch:
@@ -3,8 +3,8 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeList;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.StackSize;
@@ -88,7 +88,7 @@ public void testObjectProperties() throws Exception {
             @Override
             public void apply(MethodDescription mock) {
                 when(mock.getParameters()).thenReturn(new ParameterList.Empty());
-                when(mock.getExceptionTypes()).thenReturn(new TypeList.Empty());
+                when(mock.getExceptionTypes()).thenReturn(new GenericTypeList.Empty());
                 when(mock.getDeclaringType()).thenReturn(mock(TypeDescription.class));
                 TypeDescription returnType = mock(TypeDescription.class);
                 when(returnType.asRawType()).thenReturn(returnType); // REFACTOR

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedMethodTest.java
Patch:
@@ -3,8 +3,8 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.TypeList;
 import net.bytebuddy.description.type.generic.GenericTypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeList;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.StackSize;
@@ -87,7 +87,7 @@ public void testObjectProperties() throws Exception {
             @Override
             public void apply(MethodDescription mock) {
                 when(mock.getParameters()).thenReturn(new ParameterList.Empty());
-                when(mock.getExceptionTypes()).thenReturn(new TypeList.Empty());
+                when(mock.getExceptionTypes()).thenReturn(new GenericTypeList.Empty());
                 when(mock.getDeclaringType()).thenReturn(mock(TypeDescription.class));
                 TypeDescription returnType = mock(TypeDescription.class);
                 when(returnType.asRawType()).thenReturn(returnType); // REFACTOR

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/AbstractArgumentTypeResolverTest.java
Patch:
@@ -48,6 +48,7 @@ public void setUp() throws Exception {
         when(sourceParameter.getType()).thenReturn(sourceType);
         when(leftMethod.getParameters()).thenReturn(leftParameterList);
         when(rightMethod.getParameters()).thenReturn(rightParameterList);
+        when(sourceType.asRawType()).thenReturn(sourceType);
     }
 
     private static class IndexTokenMatcher extends BaseMatcher<ArgumentTypeResolver.ParameterIndexToken> {
@@ -89,7 +90,7 @@ protected TokenAnswer(int[][] mapping) {
         @Override
         public Integer answer(InvocationOnMock invocation) throws Throwable {
             assert invocation.getArguments().length == 1;
-            return indexMapping.get(invocation.getArguments()[0]);
+            return indexMapping.get((ArgumentTypeResolver.ParameterIndexToken) invocation.getArguments()[0]);
         }
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/ArgumentTypeResolverPrimitiveTest.java
Patch:
@@ -83,6 +83,8 @@ public void setUp() throws Exception {
         when(firstPrimitive.represents(firstType)).thenReturn(true);
         when(secondPrimitive.isPrimitive()).thenReturn(true);
         when(secondPrimitive.represents(secondType)).thenReturn(true);
+        when(firstPrimitive.asRawType()).thenReturn(firstPrimitive);
+        when(secondPrimitive.asRawType()).thenReturn(secondPrimitive);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/ArgumentTypeResolverReferenceTest.java
Patch:
@@ -36,6 +36,8 @@ public void setUp() throws Exception {
         when(dominantTargetType.isAssignableTo(weakTargetType)).thenReturn(true);
         when(weakTargetParameter.getType()).thenReturn(weakTargetType);
         when(dominantTargetParameter.getType()).thenReturn(dominantTargetType);
+        when(weakTargetType.asRawType()).thenReturn(weakTargetType);
+        when(dominantTargetType.asRawType()).thenReturn(dominantTargetType);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/AllArgumentsBinderTest.java
Patch:
@@ -40,6 +40,7 @@ public void setUp() throws Exception {
         super.setUp();
         when(firstSourceType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(secondSourceType.getStackSize()).thenReturn(StackSize.SINGLE);
+        when(targetType.asRawType()).thenReturn(targetType);
     }
 
     @Override
@@ -147,6 +148,7 @@ public void testNonArrayTypeBinding() throws Exception {
         TypeDescription targetType = mock(TypeDescription.class);
         when(targetType.isArray()).thenReturn(false);
         when(target.getType()).thenReturn(targetType);
+        when(targetType.asRawType()).thenReturn(targetType);
         AllArguments.Binder.INSTANCE.bind(annotationDescription, source, target, implementationTarget, assigner);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ArgumentBinderTest.java
Patch:
@@ -35,6 +35,7 @@ public ArgumentBinderTest() {
     public void setUp() throws Exception {
         super.setUp();
         when(sourceType.asRawType()).thenReturn(sourceType); // REFACTOR
+        when(targetType.asRawType()).thenReturn(targetType);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/DefaultBinderTest.java
Patch:
@@ -30,6 +30,7 @@ public void setUp() throws Exception {
         super.setUp();
         when(target.getType()).thenReturn(targetType);
         when(instrumentedType.getInterfaces()).thenReturn(interfaces);
+        when(targetType.asRawType()).thenReturn(targetType);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/DefaultCallBinderTest.java
Patch:
@@ -37,6 +37,7 @@ public DefaultCallBinderTest() {
     public void setUp() throws Exception {
         super.setUp();
         when(target.getType()).thenReturn(targetParameterType);
+        when(targetParameterType.asRawType()).thenReturn(targetParameterType);
         when(implementationTarget.invokeDefault(any(TypeDescription.class), any(String.class)))
                 .thenReturn(specialMethodInvocation);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/OriginBinderTest.java
Patch:
@@ -36,6 +36,7 @@ public OriginBinderTest() {
     public void setUp() throws Exception {
         super.setUp();
         when(target.getType()).thenReturn(targetType);
+        when(targetType.asRawType()).thenReturn(targetType);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/SuperBinderTest.java
Patch:
@@ -32,6 +32,7 @@ public void setUp() throws Exception {
         when(annotation.strategy()).thenReturn(instantiation);
         when(instantiation.proxyFor(targetType, implementationTarget, annotationDescription)).thenReturn(stackManipulation);
         when(annotation.constructorParameters()).thenReturn(new Class<?>[0]);
+        when(targetType.asRawType()).thenReturn(targetType);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/SuperCallBinderTest.java
Patch:
@@ -31,6 +31,7 @@ public void setUp() throws Exception {
         when(target.getType()).thenReturn(targetParameterType);
         when(implementationTarget.invokeSuper(eq(source), any(Implementation.Target.MethodLookup.class)))
                 .thenReturn(specialMethodInvocation);
+        when(targetParameterType.asRawType()).thenReturn(targetParameterType);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/ThisBinderTest.java
Patch:
@@ -33,6 +33,7 @@ public void testAnnotationType() throws Exception {
     public void setUp() throws Exception {
         super.setUp();
         when(stackManipulation.isValid()).thenReturn(true);
+        when(parameterType.asRawType()).thenReturn(parameterType);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -1602,7 +1602,7 @@ public Object getValue(MethodDescription methodDescription) {
                         method.setAccessible(true);
                     }
                 }
-                return describe(method.invoke(annotation), methodDescription.getReturnType());
+                return describe(method.invoke(annotation), methodDescription.getReturnType().asRawType());
             } catch (Exception e) {
                 throw new IllegalStateException("Cannot access annotation property " + methodDescription, e);
             }
@@ -1786,7 +1786,7 @@ public Builder define(String property, AnnotationValue<?, ?> value) {
             MethodList methodDescriptions = annotationType.getDeclaredMethods().filter(named(nonNull(property)));
             if (methodDescriptions.isEmpty()) {
                 throw new IllegalArgumentException(annotationType + " does not define a property named " + property);
-            } else if (!methodDescriptions.getOnly().getReturnType().isAnnotationValue(value.resolve())) {
+            } else if (!methodDescriptions.getOnly().getReturnType().asRawType().isAnnotationValue(value.resolve())) {
                 throw new IllegalArgumentException(value + " cannot be assigned to " + property);
             }
             Map<String, AnnotationValue<?, ?>> annotationValues = new HashMap<String, AnnotationValue<?, ?>>(this.annotationValues.size() + 1);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1647,7 +1647,7 @@ public MatchedMethodInterception<S> defineMethod(MethodDescription methodDescrip
                     throw new IllegalArgumentException("Not a method: " + methodDescription);
                 }
                 return defineMethod(methodDescription.getName(),
-                        methodDescription.getReturnTypeGen(),
+                        methodDescription.getReturnType(),
                         methodDescription.getParameters().asTypeListGen(),
                         methodDescription.getModifiers()).throwing(methodDescription.getExceptionTypesGen());
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -478,7 +478,7 @@ private MethodToken(GenericTypeDescription.Visitor<GenericTypeDescription> subst
                 for (GenericTypeDescription typeVariable : methodDescription.getTypeVariables()) {
                     typeVariables.add(new TypeVariableToken(substitutor, typeVariable));
                 }
-                returnType = methodDescription.getReturnTypeGen().accept(substitutor);
+                returnType = methodDescription.getReturnType().accept(substitutor);
                 exceptionTypes = methodDescription.getExceptionTypesGen().accept(substitutor);
                 modifiers = methodDescription.getModifiers();
                 declaredAnnotations = methodDescription.getDeclaredAnnotations();
@@ -490,7 +490,7 @@ private MethodToken(GenericTypeDescription.Visitor<GenericTypeDescription> subst
             }
 
             @Override
-            public GenericTypeDescription getReturnTypeGen() {
+            public GenericTypeDescription getReturnType() {
                 return returnType;
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -574,7 +574,7 @@ public void applyHead(MethodVisitor methodVisitor, MethodDescription methodDescr
                     }
                     AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();
                     AnnotationAppender.Default.apply(annotationVisitor,
-                            methodDescription.getReturnType(),
+                            methodDescription.getReturnType().asRawType(),
                             AnnotationAppender.NO_NAME,
                             annotationValue);
                     annotationVisitor.visitEnd();

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/InliningImplementationMatcher.java
Patch:
@@ -50,7 +50,7 @@ protected static LatentMethodMatcher of(ElementMatcher<? super MethodDescription
             ElementMatcher.Junction<MethodDescription> signature = methodDescription.isConstructor()
                     ? isConstructor()
                     : ElementMatchers.<MethodDescription>named(methodDescription.getName());
-            signature = signature.and(returns(methodDescription.getReturnType()));
+            signature = signature.and(returns(methodDescription.getReturnType().asRawType()));
             signature = signature.and(takesArguments(methodDescription.getParameters().asTypeList()));
             predefinedMethodSignatures = predefinedMethodSignatures.or(signature);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseImplementationTarget.java
Patch:
@@ -171,14 +171,14 @@ public boolean equals(Object other) {
                     && instrumentedType.equals(specialMethodInvocation.getTypeDescription())
                     && methodDescription.getInternalName().equals(specialMethodInvocation.getMethodDescription().getInternalName())
                     && methodDescription.getParameters().asTypeList().equals(specialMethodInvocation.getMethodDescription().getParameters().asTypeList())
-                    && methodDescription.getReturnType().equals(specialMethodInvocation.getMethodDescription().getReturnType());
+                    && methodDescription.getReturnType().asRawType().equals(specialMethodInvocation.getMethodDescription().getReturnType().asRawType());
         }
 
         @Override
         public int hashCode() {
             int result = methodDescription.getInternalName().hashCode();
             result = 31 * result + methodDescription.getParameters().asTypeList().hashCode();
-            result = 31 * result + methodDescription.getReturnType().hashCode();
+            result = 31 * result + methodDescription.getReturnType().asRawType().hashCode();
             result = 31 * result + instrumentedType.hashCode();
             return result;
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/DefaultMethodCall.java
Patch:
@@ -210,7 +210,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
             StackManipulation.Size stackSize = new StackManipulation.Compound(
                     MethodVariableAccess.loadThisReferenceAndArguments(instrumentedMethod),
                     defaultMethodInvocation,
-                    MethodReturn.returning(instrumentedMethod.getReturnType())
+                    MethodReturn.returning(instrumentedMethod.getReturnType().asRawType())
             ).apply(methodVisitor, implementationContext);
             return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -98,7 +98,7 @@ protected ByteCodeAppender.Size applyGetter(MethodVisitor methodVisitor,
                                                 FieldDescription fieldDescription,
                                                 MethodDescription methodDescription) {
         StackManipulation stackManipulation = assigner.assign(fieldDescription.getType().asRawType(),
-                methodDescription.getReturnType(),
+                methodDescription.getReturnType().asRawType(),
                 dynamicallyTyped);
         if (!stackManipulation.isValid()) {
             throw new IllegalStateException("Getter type of " + methodDescription + " is not compatible with " + fieldDescription);
@@ -172,7 +172,7 @@ private ByteCodeAppender.Size apply(MethodVisitor methodVisitor,
                         ? StackManipulation.LegalTrivial.INSTANCE
                         : MethodVariableAccess.REFERENCE.loadOffset(0),
                 fieldAccess,
-                MethodReturn.returning(methodDescription.getReturnType())
+                MethodReturn.returning(methodDescription.getReturnType().asRawType())
         ).apply(methodVisitor, implementationContext);
         return new ByteCodeAppender.Size(stackSize.getMaximalSize(), methodDescription.getStackSize());
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
Patch:
@@ -236,14 +236,14 @@ protected ByteCodeAppender.Size apply(MethodVisitor methodVisitor,
                                           MethodDescription instrumentedMethod,
                                           TypeDescription fixedValueType,
                                           StackManipulation valueLoadingInstruction) {
-        StackManipulation assignment = assigner.assign(fixedValueType, instrumentedMethod.getReturnType(), dynamicallyTyped);
+        StackManipulation assignment = assigner.assign(fixedValueType, instrumentedMethod.getReturnType().asRawType(), dynamicallyTyped);
         if (!assignment.isValid()) {
             throw new IllegalArgumentException("Cannot return value of type " + fixedValueType + " for " + instrumentedMethod);
         }
         StackManipulation.Size stackSize = new StackManipulation.Compound(
                 valueLoadingInstruction,
                 assignment,
-                MethodReturn.returning(instrumentedMethod.getReturnType())
+                MethodReturn.returning(instrumentedMethod.getReturnType().asRawType())
         ).apply(methodVisitor, implementationContext);
         return new ByteCodeAppender.Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Forwarding.java
Patch:
@@ -336,7 +336,7 @@ public Size apply(MethodVisitor methodVisitor,
                     delegateLoadingInstruction,
                     MethodVariableAccess.loadArguments(instrumentedMethod),
                     MethodInvocation.invoke(instrumentedMethod).virtual(fieldType),
-                    MethodReturn.returning(instrumentedMethod.getReturnType())
+                    MethodReturn.returning(instrumentedMethod.getReturnType().asRawType())
             ).apply(methodVisitor, implementationContext);
             return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -207,14 +207,14 @@ public boolean equals(Object other) {
                         && typeDescription.equals(specialMethodInvocation.getTypeDescription())
                         && methodDescription.getInternalName().equals(specialMethodInvocation.getMethodDescription().getInternalName())
                         && methodDescription.getParameters().asTypeList().equals(specialMethodInvocation.getMethodDescription().getParameters().asTypeList())
-                        && methodDescription.getReturnType().equals(specialMethodInvocation.getMethodDescription().getReturnType());
+                        && methodDescription.getReturnType().asRawType().equals(specialMethodInvocation.getMethodDescription().getReturnType().asRawType());
             }
 
             @Override
             public int hashCode() {
                 int result = methodDescription.getInternalName().hashCode();
                 result = 31 * result + methodDescription.getParameters().asTypeList().hashCode();
-                result = 31 * result + methodDescription.getReturnType().hashCode();
+                result = 31 * result + methodDescription.getReturnType().asRawType().hashCode();
                 result = 31 * result + typeDescription.hashCode();
                 return result;
             }
@@ -991,7 +991,7 @@ public Size apply(MethodVisitor methodVisitor,
                     StackManipulation.Size stackSize = new StackManipulation.Compound(
                             MethodVariableAccess.loadThisReferenceAndArguments(instrumentedMethod),
                             accessorMethodInvocation,
-                            MethodReturn.returning(instrumentedMethod.getReturnType())
+                            MethodReturn.returning(instrumentedMethod.getReturnType().asRawType())
                     ).apply(methodVisitor, implementationContext);
                     return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -169,8 +169,8 @@ protected ByteCodeAppender.Size apply(MethodVisitor methodVisitor,
                         : MethodConstant.forMethod(instrumentedMethod),
                 ArrayFactory.forType(TypeDescription.OBJECT).withValues(argumentValuesOf(instrumentedMethod)),
                 MethodInvocation.invoke(invocationHandlerType.getDeclaredMethods().getOnly()),
-                assigner.assign(TypeDescription.OBJECT, instrumentedMethod.getReturnType(), Assigner.DYNAMICALLY_TYPED),
-                MethodReturn.returning(instrumentedMethod.getReturnType())
+                assigner.assign(TypeDescription.OBJECT, instrumentedMethod.getReturnType().asRawType(), Assigner.DYNAMICALLY_TYPED),
+                MethodReturn.returning(instrumentedMethod.getReturnType().asRawType())
         ).apply(methodVisitor, implementationContext);
         return new ByteCodeAppender.Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -2095,12 +2095,12 @@ public StackManipulation resolve(MethodDescription invokedMethod,
                                              boolean dynamicallyTyped) {
                 StackManipulation stackManipulation = assigner.assign(invokedMethod.isConstructor()
                         ? invokedMethod.getDeclaringType()
-                        : invokedMethod.getReturnType(), interceptedMethod.getReturnType(), dynamicallyTyped);
+                        : invokedMethod.getReturnType().asRawType(), interceptedMethod.getReturnType().asRawType(), dynamicallyTyped);
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot return " + invokedMethod.getReturnType() + " from " + interceptedMethod);
                 }
                 return new StackManipulation.Compound(stackManipulation,
-                        MethodReturn.returning(interceptedMethod.getReturnType()));
+                        MethodReturn.returning(interceptedMethod.getReturnType().asRawType()));
             }
 
             @Override
@@ -2127,7 +2127,7 @@ public StackManipulation resolve(MethodDescription invokedMethod,
                                              boolean dynamicallyTyped) {
                 return Removal.pop(invokedMethod.isConstructor()
                         ? invokedMethod.getDeclaringType()
-                        : invokedMethod.getReturnType());
+                        : invokedMethod.getReturnType().asRawType());
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/StubMethod.java
Patch:
@@ -41,8 +41,8 @@ public Size apply(MethodVisitor methodVisitor,
                       Context implementationContext,
                       MethodDescription instrumentedMethod) {
         StackManipulation.Size stackSize = new StackManipulation.Compound(
-                DefaultValue.of(instrumentedMethod.getReturnType()),
-                MethodReturn.returning(instrumentedMethod.getReturnType())
+                DefaultValue.of(instrumentedMethod.getReturnType().asRawType()),
+                MethodReturn.returning(instrumentedMethod.getReturnType().asRawType())
         ).apply(methodVisitor, implementationContext);
         return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/SuperMethodCall.java
Patch:
@@ -156,7 +156,7 @@ protected enum TerminationHandler {
             RETURNING {
                 @Override
                 protected StackManipulation of(MethodDescription methodDescription) {
-                    return MethodReturn.returning(methodDescription.getReturnType());
+                    return MethodReturn.returning(methodDescription.getReturnType().asRawType());
                 }
             },
 
@@ -166,7 +166,7 @@ protected StackManipulation of(MethodDescription methodDescription) {
             DROPPING {
                 @Override
                 protected StackManipulation of(MethodDescription methodDescription) {
-                    return Removal.pop(methodDescription.getReturnType());
+                    return Removal.pop(methodDescription.getReturnType().asRawType());
                 }
             };
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/attribute/AnnotationAppender.java
Patch:
@@ -340,7 +340,7 @@ public Default(Target target) {
          */
         private static void handle(AnnotationVisitor annotationVisitor, AnnotationDescription annotation) {
             for (MethodDescription methodDescription : annotation.getAnnotationType().getDeclaredMethods()) {
-                apply(annotationVisitor, methodDescription.getReturnType(), methodDescription.getName(), annotation.getValue(methodDescription));
+                apply(annotationVisitor, methodDescription.getReturnType().asRawType(), methodDescription.getName(), annotation.getValue(methodDescription));
             }
             annotationVisitor.visitEnd();
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/TypeProxy.java
Patch:
@@ -894,7 +894,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                             fieldLoadingInstruction,
                             MethodVariableAccess.forBridgeMethodInvocation(instrumentedMethod, proxyMethod),
                             MethodInvocation.invoke(proxyMethod),
-                            MethodReturn.returning(instrumentedMethod.getReturnType())
+                            MethodReturn.returning(instrumentedMethod.getReturnType().asRawType())
                     ).apply(methodVisitor, implementationContext);
                 }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/MethodInvocation.java
Patch:
@@ -269,7 +269,7 @@ public boolean equals(Object other) {
             Invocation that = (Invocation) other;
             return MethodInvocation.this.equals(((Invocation) other).getOuterInstance())
                     && methodDescription.getInternalName().equals(that.methodDescription.getInternalName())
-                    && methodDescription.getReturnType().equals(((Invocation) other).methodDescription.getReturnType())
+                    && methodDescription.getReturnType().asRawType().equals(((Invocation) other).methodDescription.getReturnType().asRawType())
                     && methodDescription.getParameters().asTypeList().equals(((Invocation) other).methodDescription.getParameters().asTypeList())
                     && typeDescription.equals(that.typeDescription);
         }
@@ -280,7 +280,7 @@ public int hashCode() {
             result = 31 * result + MethodInvocation.this.hashCode();
             result = 31 * result + methodDescription.getInternalName().hashCode();
             result = 31 * result + methodDescription.getParameters().asTypeList().hashCode();
-            result = 31 * result + methodDescription.getReturnType().hashCode();
+            result = 31 * result + methodDescription.getReturnType().asRawType().hashCode();
             return result;
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -764,7 +764,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> returns(G
      * @param <T>     The type of the matched object.
      * @return An element matcher that matches a given return type against another {@code matcher}.
      */
-    public static <T extends MethodDescription> ElementMatcher.Junction<T> returns(ElementMatcher<? super TypeDescription> matcher) {
+    public static <T extends MethodDescription> ElementMatcher.Junction<T> returns(ElementMatcher<? super GenericTypeDescription> matcher) {
         return new MethodReturnTypeMatcher<T>(nonNull(matcher));
     }
 
@@ -1156,7 +1156,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> isSpecial
         }
         return (methodDescription.isStatic() ? ElementMatchers.<T>isStatic() : ElementMatchers.<T>not(isStatic()))
                 .<T>and(named(methodDescription.getSourceCodeName()))
-                .<T>and(returns(isSubTypeOf(methodDescription.getReturnType())))
+                .<T>and(returns(rawType(isSubTypeOf(methodDescription.getReturnType().asRawType()))))
                 .and(takesArguments(new CollectionOneToOneMatcher<GenericTypeDescription>(matchers)));
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodReturnTypeMatcher.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.method.MethodDescription;
-import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 
 /**
  * An element matcher that matches its argument's return type against a given type matcher.
@@ -13,14 +13,14 @@ public class MethodReturnTypeMatcher<T extends MethodDescription> extends Elemen
     /**
      * The type matcher to apply to the matched element's return type.
      */
-    private final ElementMatcher<? super TypeDescription> typeMatcher;
+    private final ElementMatcher<? super GenericTypeDescription> typeMatcher;
 
     /**
      * Creates a new matcher for a matched element's return type.
      *
      * @param typeMatcher The type matcher to apply to the matched element's return type.
      */
-    public MethodReturnTypeMatcher(ElementMatcher<? super TypeDescription> typeMatcher) {
+    public MethodReturnTypeMatcher(ElementMatcher<? super GenericTypeDescription> typeMatcher) {
         this.typeMatcher = typeMatcher;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -1145,6 +1145,7 @@ public String lookup() {
                                 .filter(named(name))
                                 .getOnly()
                                 .getReturnType()
+                                .asRawType()
                                 .getComponentType()
                                 .getName();
                     }
@@ -4404,7 +4405,7 @@ private LazyMethodDescription(int modifiers,
             }
 
             @Override
-            public GenericTypeDescription getReturnTypeGen() {
+            public GenericTypeDescription getReturnType() {
                 return signatureResolution.resolveReturnType(returnTypeDescriptor, typePool, this);
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaInstance.java
Patch:
@@ -163,7 +163,7 @@ public static MethodType of(Constructor<?> constructor) {
          * @return The method type of the given method.
          */
         public static MethodType of(MethodDescription methodDescription) {
-            return new MethodType(methodDescription.getReturnType(), methodDescription.getParameters().asTypeList());
+            return new MethodType(methodDescription.getReturnType().asRawType(), methodDescription.getParameters().asTypeList());
         }
 
         /**
@@ -522,7 +522,7 @@ public static MethodHandle of(MethodDescription methodDescription) {
             return new MethodHandle(HandleType.of(methodDescription),
                     methodDescription.getDeclaringType(),
                     methodDescription.getInternalName(),
-                    methodDescription.getReturnType(),
+                    methodDescription.getReturnType().asRawType(),
                     methodDescription.getParameters().asTypeList());
 
         }
@@ -552,7 +552,7 @@ public static MethodHandle ofSpecial(MethodDescription methodDescription, TypeDe
             return new MethodHandle(HandleType.ofSpecial(methodDescription),
                     typeDescription,
                     methodDescription.getInternalName(),
-                    methodDescription.getReturnType(),
+                    methodDescription.getReturnType().asRawType(),
                     methodDescription.getParameters().asTypeList());
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -441,7 +441,7 @@ public enum SumMethod implements ByteCodeAppender {
         public Size apply(MethodVisitor methodVisitor,
                           Implementation.Context implementationContext,
                           MethodDescription instrumentedMethod) {
-            if (!instrumentedMethod.getReturnType().represents(int.class)) {
+            if (!instrumentedMethod.getReturnType().asRawType().represents(int.class)) { // TODO: change tutorial!
                 throw new IllegalArgumentException(instrumentedMethod + " must return int");
             }
             StackManipulation.Size operandStackSize = new StackManipulation.Compound(

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/method/MethodDescriptionLatentTest.java
Patch:
@@ -57,7 +57,7 @@ public void testTypeInitializer() throws Exception {
         TypeDescription typeDescription = mock(TypeDescription.class);
         MethodDescription typeInitializer = MethodDescription.Latent.typeInitializerOf(typeDescription);
         assertThat(typeInitializer.getDeclaringType(), is(typeDescription));
-        assertThat(typeInitializer.getReturnType(), is((TypeDescription) new TypeDescription.ForLoadedType(void.class)));
+        assertThat(typeInitializer.getReturnType(), is((GenericTypeDescription) new TypeDescription.ForLoadedType(void.class)));
         assertThat(typeInitializer.getParameters(), is((ParameterList) new ParameterList.Empty()));
         assertThat(typeInitializer.getExceptionTypes(), is((TypeList) new TypeList.Empty()));
         assertThat(typeInitializer.getDeclaredAnnotations(), is((AnnotationList) new AnnotationList.Empty()));

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/TypeDescriptionForLoadedTypeTest.java
Patch:
@@ -20,6 +20,6 @@ protected GenericTypeDescription describe(Field field) {
 
     @Override
     protected GenericTypeDescription describe(Method method) {
-        return new MethodDescription.ForLoadedMethod(method).getReturnTypeGen();
+        return new MethodDescription.ForLoadedMethod(method).getReturnType();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericSignatureResolutionTest.java
Patch:
@@ -56,7 +56,7 @@ public void testGenericMethod() throws Exception {
         MethodDescription createdMethod = new MethodDescription.ForLoadedMethod(type.getDeclaredMethod(FOO, Exception.class));
         MethodDescription originalMethod = new MethodDescription.ForLoadedMethod(GenericMethod.class.getDeclaredMethod(FOO, Exception.class));
         assertThat(createdMethod.getTypeVariables(), is(originalMethod.getTypeVariables()));
-        assertThat(createdMethod.getReturnTypeGen(), is(originalMethod.getReturnTypeGen()));
+        assertThat(createdMethod.getReturnType(), is(originalMethod.getReturnType()));
         assertThat(createdMethod.getParameters().getOnly().getTypeGen(), is(originalMethod.getParameters().getOnly().getTypeGen()));
         assertThat(createdMethod.getExceptionTypesGen().getOnly(), is(originalMethod.getExceptionTypesGen().getOnly()));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverEnabledTest.java
Patch:
@@ -4,6 +4,7 @@
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.StackSize;
@@ -84,7 +85,7 @@ public void testResolutionInstrumentedMethod() throws Exception {
         assertThat(resolution.isRebased(), is(true));
         assertThat(resolution.getAdditionalArguments(), is((StackManipulation) StackManipulation.LegalTrivial.INSTANCE));
         assertThat(resolution.getResolvedMethod().getInternalName(), is(BAR));
-        assertThat(resolution.getResolvedMethod().getReturnType(), is(returnType));
+        assertThat(resolution.getResolvedMethod().getReturnType(), is((GenericTypeDescription) returnType));
         assertThat(resolution.getResolvedMethod().getParameters().asTypeList(), is((TypeList) new TypeList.Explicit(Collections.singletonList(parameterType))));
         assertThat(resolution.getResolvedMethod().isSynthetic(), is(true));
     }
@@ -95,7 +96,7 @@ public void testResolutionInstrumentedConstructor() throws Exception {
         assertThat(resolution.isRebased(), is(true));
         assertThat(resolution.getAdditionalArguments(), is((StackManipulation) NullConstant.INSTANCE));
         assertThat(resolution.getResolvedMethod().getInternalName(), is(FOO));
-        assertThat(resolution.getResolvedMethod().getReturnType(), is(returnType));
+        assertThat(resolution.getResolvedMethod().getReturnType(), is((GenericTypeDescription) returnType));
         assertThat(resolution.getResolvedMethod().getParameters().asTypeList(), is((TypeList) new TypeList.Explicit(Arrays.asList(parameterType, placeholderType))));
         assertThat(resolution.getResolvedMethod().isSynthetic(), is(true));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverMethodsOnlyTest.java
Patch:
@@ -4,6 +4,7 @@
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.StackSize;
 import net.bytebuddy.test.utility.MockitoRule;
@@ -71,7 +72,7 @@ public void testResolutionInstrumentedMethod() throws Exception {
         assertThat(resolution.isRebased(), is(true));
         assertThat(resolution.getAdditionalArguments(), is((StackManipulation) StackManipulation.LegalTrivial.INSTANCE));
         assertThat(resolution.getResolvedMethod().getInternalName(), is(BAR));
-        assertThat(resolution.getResolvedMethod().getReturnType(), is(returnType));
+        assertThat(resolution.getResolvedMethod().getReturnType(), is((GenericTypeDescription) returnType));
         assertThat(resolution.getResolvedMethod().getParameters().asTypeList(), is((TypeList) new TypeList.Explicit(Collections.singletonList(parameterType))));
         assertThat(resolution.getResolvedMethod().isSynthetic(), is(true));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedConstructorTest.java
Patch:
@@ -4,6 +4,7 @@
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.StackSize;
@@ -71,7 +72,7 @@ public void testPreservation() throws Exception {
         assertThat(resolution.getResolvedMethod().getDeclaringType(), is(typeDescription));
         assertThat(resolution.getResolvedMethod().getInternalName(), is(FOO));
         assertThat(resolution.getResolvedMethod().getModifiers(), is(MethodRebaseResolver.REBASED_METHOD_MODIFIER));
-        assertThat(resolution.getResolvedMethod().getReturnType(), is(returnType));
+        assertThat(resolution.getResolvedMethod().getReturnType(), is((GenericTypeDescription) returnType));
         assertThat(resolution.getResolvedMethod().getParameters(), is(ParameterList.Explicit.latent(resolution.getResolvedMethod(), Arrays.asList(parameterType, placeholderType))));
         StackManipulation.Size size = resolution.getAdditionalArguments().apply(methodVisitor, implementationContext);
         assertThat(size.getSizeImpact(), is(1));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedMethodTest.java
Patch:
@@ -4,6 +4,7 @@
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bytecode.StackManipulation;
 import net.bytebuddy.implementation.bytecode.StackSize;
@@ -71,7 +72,7 @@ public void testPreservation() throws Exception {
         assertThat(resolution.getResolvedMethod().getDeclaringType(), is(typeDescription));
         assertThat(resolution.getResolvedMethod().getInternalName(), is(QUX));
         assertThat(resolution.getResolvedMethod().getModifiers(), is(MethodRebaseResolver.REBASED_METHOD_MODIFIER));
-        assertThat(resolution.getResolvedMethod().getReturnType(), is(returnType));
+        assertThat(resolution.getResolvedMethod().getReturnType(), is((GenericTypeDescription) returnType));
         assertThat(resolution.getResolvedMethod().getParameters(), is(ParameterList.Explicit.latent(resolution.getResolvedMethod(), Collections.singletonList(parameterType))));
         StackManipulation.Size size = resolution.getAdditionalArguments().apply(methodVisitor, implementationContext);
         assertThat(size.getSizeImpact(), is(0));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinderTerminationHandlerDroppingTest.java
Patch:
@@ -34,15 +34,16 @@ public class TargetMethodAnnotationDrivenBinderTerminationHandlerDroppingTest {
     @Before
     public void setUp() throws Exception {
         when(target.getReturnType()).thenReturn(targetType);
+        when(targetType.asRawType()).thenReturn(targetType);
         when(targetType.getStackSize()).thenReturn(StackSize.SINGLE);
     }
 
     @Test
     public void testApplication() throws Exception {
-        StackManipulation stackManipulation = TargetMethodAnnotationDrivenBinder.TerminationHandler.Dropping.INSTANCE
-                .resolve(assigner, source, target);
+        StackManipulation stackManipulation = TargetMethodAnnotationDrivenBinder.TerminationHandler.Dropping.INSTANCE.resolve(assigner, source, target);
         assertThat(stackManipulation, is((StackManipulation) Removal.SINGLE));
         verify(targetType).getStackSize();
+        verify(targetType).asRawType();
         verifyNoMoreInteractions(targetType);
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/TargetMethodAnnotationDrivenBinderTerminationHandlerReturningTest.java
Patch:
@@ -44,6 +44,8 @@ public class TargetMethodAnnotationDrivenBinderTerminationHandlerReturningTest {
     public void setUp() throws Exception {
         when(source.getReturnType()).thenReturn(sourceType);
         when(target.getReturnType()).thenReturn(targetType);
+        when(sourceType.asRawType()).thenReturn(sourceType);
+        when(targetType.asRawType()).thenReturn(targetType);
         when(assigner.assign(eq(targetType), eq(sourceType), any(boolean.class))).thenReturn(stackManipulation);
         when(target.getDeclaredAnnotations()).thenReturn(annotationList);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodInvocationOtherTest.java
Patch:
@@ -33,6 +33,7 @@ public void apply(MethodDescription mock) {
                 TypeDescription returnType = mock(TypeDescription.class);
                 when(returnType.getStackSize()).thenReturn(StackSize.ZERO);
                 when(mock.getReturnType()).thenReturn(returnType);
+                when(returnType.asRawType()).thenReturn(returnType);
                 when(mock.getInternalName()).thenReturn(FOO);
                 when(mock.getParameters()).thenReturn(new ParameterList.Empty());
             }

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/MethodReturnTypeMatcherTest.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.matcher;
 
 import net.bytebuddy.description.method.MethodDescription;
-import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -13,10 +13,10 @@
 public class MethodReturnTypeMatcherTest extends AbstractElementMatcherTest<MethodReturnTypeMatcher<?>> {
 
     @Mock
-    private ElementMatcher<? super TypeDescription> typeMatcher;
+    private ElementMatcher<? super GenericTypeDescription> typeMatcher;
 
     @Mock
-    private TypeDescription returnType;
+    private GenericTypeDescription returnType;
 
     @Mock
     private MethodDescription methodDescription;

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/MethodSortMatcherTest.java
Patch:
@@ -120,7 +120,9 @@ protected void prepare(MethodDescription mock) {
                 when(methodList.filter(any(ElementMatcher.class))).thenReturn(methodList);
                 when(methodList.size()).thenReturn(0);
                 when(mock.getParameters()).thenReturn(new ParameterList.Empty());
-                when(mock.getReturnType()).thenReturn(Mockito.mock(TypeDescription.class));
+                TypeDescription returnType = Mockito.mock(TypeDescription.class);
+                when(returnType.asRawType()).thenReturn(returnType);
+                when(mock.getReturnType()).thenReturn(returnType);
                 when(mock.getSourceCodeName()).thenReturn(FOO);
             }
         };

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultComponentTypeLocatorTest.java
Patch:
@@ -32,12 +32,12 @@ public void testForAnnotationProperty() throws Exception {
         when(typeDescription.getDeclaredMethods()).thenReturn(new MethodList.Explicit(Collections.singletonList(methodDescription)));
         when(methodDescription.getSourceCodeName()).thenReturn(FOO);
         TypeDescription returnType = mock(TypeDescription.class);
+        when(returnType.asRawType()).thenReturn(returnType);
         when(methodDescription.getReturnType()).thenReturn(returnType);
         TypeDescription componentType = mock(TypeDescription.class);
         when(returnType.getComponentType()).thenReturn(componentType);
         when(componentType.getName()).thenReturn(QUX);
-        assertThat(new TypePool.Default.ComponentTypeLocator.ForAnnotationProperty(typePool, BAR_DESCRIPTOR)
-                .bind(FOO).lookup(), is(QUX));
+        assertThat(new TypePool.Default.ComponentTypeLocator.ForAnnotationProperty(typePool, BAR_DESCRIPTOR).bind(FOO).lookup(), is(QUX));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultTypeDescriptionTest.java
Patch:
@@ -45,6 +45,6 @@ protected GenericTypeDescription describe(Method method) {
                 .getDeclaredMethods()
                 .filter(is(method))
                 .getOnly()
-                .getReturnTypeGen();
+                .getReturnType();
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -2399,15 +2399,15 @@ protected ValuesMethodAppender(TypeDescription instrumentedType) {
             public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
                 FieldDescription valuesField = instrumentedType.getDeclaredFields().filter(named(ENUM_VALUES)).getOnly();
                 MethodDescription cloneArrayMethod = new MethodDescription.Latent(CLONE_METHOD_NAME,
-                        valuesField.getFieldType(),
+                        valuesField.getType().asRawType(),
                         TypeDescription.OBJECT,
                         Collections.<TypeDescription>emptyList(),
                         Opcodes.ACC_PUBLIC,
                         Collections.<TypeDescription>emptyList());
                 return new Size(new StackManipulation.Compound(
                         FieldAccess.forField(valuesField).getter(),
                         MethodInvocation.invoke(cloneArrayMethod),
-                        TypeCasting.to(valuesField.getFieldType()),
+                        TypeCasting.to(valuesField.getType().asRawType()),
                         MethodReturn.REFERENCE
                 ).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1624,7 +1624,7 @@ public FieldValueTarget<S> defineField(Field field) {
 
             @Override
             public FieldValueTarget<S> defineField(FieldDescription fieldDescription) {
-                return defineField(fieldDescription.getName(), fieldDescription.getFieldTypeGen(), fieldDescription.getModifiers());
+                return defineField(fieldDescription.getName(), fieldDescription.getType(), fieldDescription.getModifiers());
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/InstrumentedType.java
Patch:
@@ -399,13 +399,13 @@ protected class FieldToken extends FieldDescription.AbstractFieldDescription {
 
             private FieldToken(GenericTypeDescription.Visitor<GenericTypeDescription> substitutor, FieldDescription fieldDescription) {
                 name = fieldDescription.getName();
-                fieldType = fieldDescription.getFieldTypeGen().accept(substitutor);
+                fieldType = fieldDescription.getType().accept(substitutor);
                 modifiers = fieldDescription.getModifiers();
                 declaredAnnotations = fieldDescription.getDeclaredAnnotations();
             }
 
             @Override
-            public GenericTypeDescription getFieldTypeGen() {
+            public GenericTypeDescription getType() {
                 return fieldType;
             }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -97,7 +97,7 @@ protected ByteCodeAppender.Size applyGetter(MethodVisitor methodVisitor,
                                                 Implementation.Context implementationContext,
                                                 FieldDescription fieldDescription,
                                                 MethodDescription methodDescription) {
-        StackManipulation stackManipulation = assigner.assign(fieldDescription.getFieldType(),
+        StackManipulation stackManipulation = assigner.assign(fieldDescription.getType().asRawType(),
                 methodDescription.getReturnType(),
                 dynamicallyTyped);
         if (!stackManipulation.isValid()) {
@@ -128,7 +128,7 @@ protected ByteCodeAppender.Size applySetter(MethodVisitor methodVisitor,
                                                 FieldDescription fieldDescription,
                                                 MethodDescription methodDescription) {
         StackManipulation stackManipulation = assigner.assign(methodDescription.getParameters().get(0).getType(),
-                fieldDescription.getFieldType(),
+                fieldDescription.getType().asRawType(),
                 dynamicallyTyped);
         if (!stackManipulation.isValid()) {
             throw new IllegalStateException("Setter type of " + methodDescription + " is not compatible with " + fieldDescription);
@@ -140,7 +140,7 @@ protected ByteCodeAppender.Size applySetter(MethodVisitor methodVisitor,
                 fieldDescription,
                 methodDescription,
                 new StackManipulation.Compound(
-                        MethodVariableAccess.forType(fieldDescription.getFieldType())
+                        MethodVariableAccess.forType(fieldDescription.getType().asRawType())
                                 .loadOffset(methodDescription.getParameters().get(0).getOffset()),
                         stackManipulation,
                         FieldAccess.forField(fieldDescription).putter()

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -716,7 +716,7 @@ public MethodDescription registerGetterFor(FieldDescription fieldDescription) {
                             randomString.nextString());
                     accessorMethod = new MethodDescription.Latent(name,
                             instrumentedType,
-                            fieldDescription.getFieldType(),
+                            fieldDescription.getType().asRawType(),
                             Collections.<TypeDescription>emptyList(),
                             resolveModifier(fieldDescription.isStatic()),
                             Collections.<TypeDescription>emptyList());
@@ -746,7 +746,7 @@ public MethodDescription registerSetterFor(FieldDescription fieldDescription) {
                     accessorMethod = new MethodDescription.Latent(name,
                             instrumentedType,
                             TypeDescription.VOID,
-                            Collections.singletonList(fieldDescription.getFieldType()),
+                            Collections.singletonList(fieldDescription.getType().asRawType()),
                             resolveModifier(fieldDescription.isStatic()),
                             Collections.<TypeDescription>emptyList());
                     registerSetter(fieldDescription, accessorMethod);
@@ -1039,7 +1039,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                                     ? StackManipulation.LegalTrivial.INSTANCE
                                     : MethodVariableAccess.REFERENCE.loadOffset(0),
                             FieldAccess.forField(fieldDescription).getter(),
-                            MethodReturn.returning(fieldDescription.getFieldType())
+                            MethodReturn.returning(fieldDescription.getType().asRawType())
                     ).apply(methodVisitor, implementationContext);
                     return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
Patch:
@@ -1589,12 +1589,12 @@ public Resolved resolve(TypeDescription instrumentedType,
                                         Assigner assigner,
                                         boolean dynamicallyTyped) {
                     FieldDescription fieldDescription = instrumentedType.getDeclaredFields().filter(named(name)).getOnly();
-                    StackManipulation stackManipulation = assigner.assign(fieldDescription.getFieldType(), typeDescription, dynamicallyTyped);
+                    StackManipulation stackManipulation = assigner.assign(fieldDescription.getType().asRawType(), typeDescription, dynamicallyTyped);
                     if (!stackManipulation.isValid()) {
                         throw new IllegalStateException("Cannot assign " + fieldDescription + " to " + typeDescription);
                     }
                     return new Resolved.Simple(new StackManipulation.Compound(FieldAccess.forField(fieldDescription).getter(),
-                            stackManipulation), fieldDescription.getFieldType());
+                            stackManipulation), fieldDescription.getType().asRawType());
                 }
 
                 @Override
@@ -1743,7 +1743,7 @@ public Resolved resolve(TypeDescription instrumentedType,
                                     ? StackManipulation.LegalTrivial.INSTANCE
                                     : MethodVariableAccess.REFERENCE.loadOffset(0),
                             FieldAccess.forField(fieldDescription).getter()
-                    ), fieldDescription.getFieldType());
+                    ), fieldDescription.getType().asRawType());
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
Patch:
@@ -1248,7 +1248,7 @@ public StackManipulation resolve(TypeDescription instrumentedType,
                                 ? StackManipulation.LegalTrivial.INSTANCE
                                 : MethodVariableAccess.REFERENCE.loadOffset(0),
                         FieldAccess.forField(fieldDescription).getter(),
-                        assigner.assign(fieldDescription.getFieldType(), targetType, dynamicallyTyped)
+                        assigner.assign(fieldDescription.getType().asRawType(), targetType, dynamicallyTyped)
                 );
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot assign " + fieldDescription + " to " + targetType);

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -287,7 +287,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                 for (FieldDescription fieldDescription : fieldList) {
                     fieldLoading[index] = new StackManipulation.Compound(
                             thisReference,
-                            MethodVariableAccess.forType(fieldDescription.getFieldType())
+                            MethodVariableAccess.forType(fieldDescription.getType().asRawType())
                                     .loadOffset(instrumentedMethod.getParameters().get(index).getOffset()),
                             FieldAccess.forField(fieldDescription).putter()
                     );

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Pipe.java
Patch:
@@ -448,7 +448,7 @@ public Size apply(MethodVisitor methodVisitor, Context implementationContext, Me
                         for (FieldDescription fieldDescription : fieldList) {
                             fieldLoading[index] = new StackManipulation.Compound(
                                     thisReference,
-                                    MethodVariableAccess.forType(fieldDescription.getFieldType())
+                                    MethodVariableAccess.forType(fieldDescription.getType().asRawType())
                                             .loadOffset(instrumentedMethod.getParameters().get(index).getOffset()),
                                     FieldAccess.forField(fieldDescription).putter()
                             );

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bytecode/member/FieldAccess.java
Patch:
@@ -194,7 +194,7 @@ public Size apply(MethodVisitor methodVisitor, Implementation.Context implementa
                         fieldDescription.getDeclaringType().getInternalName(),
                         fieldDescription.getInternalName(),
                         fieldDescription.getDescriptor());
-                return resolveSize(fieldDescription.getFieldType().getStackSize());
+                return resolveSize(fieldDescription.getType().getStackSize());
             }
 
             /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -4255,7 +4255,7 @@ private LazyFieldDescription(int modifiers,
             }
 
             @Override
-            public GenericTypeDescription getFieldTypeGen() {
+            public GenericTypeDescription getType() {
                 return signatureResolution.resolveFieldType(fieldTypeDescriptor, typePool, this);
             }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericSignatureResolutionTest.java
Patch:
@@ -7,9 +7,7 @@
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.implementation.FixedValue;
-import net.bytebuddy.test.utility.DebuggingWrapper;
 import org.junit.Test;
-import org.objectweb.asm.util.ASMifier;
 
 import java.util.ArrayList;
 import java.util.concurrent.Callable;
@@ -44,7 +42,7 @@ public void testGenericField() throws Exception {
         Class<?> type = unloaded.load(null, ClassLoadingStrategy.Default.WRAPPER).getLoaded();
         FieldDescription createdField = new FieldDescription.ForLoadedField(type.getDeclaredField(FOO));
         FieldDescription originalField = new FieldDescription.ForLoadedField(GenericField.class.getDeclaredField(FOO));
-        assertThat(createdField.getFieldTypeGen(), is(originalField.getFieldTypeGen()));
+        assertThat(createdField.getType(), is(originalField.getType()));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDefaultTest.java
Patch:
@@ -168,15 +168,15 @@ public void setUp() throws Exception {
         when(secondSpecialMethod.getParameters()).thenReturn(secondSpecialMethodParameters);
         when(firstFieldType.getSort()).thenReturn(GenericTypeDescription.Sort.RAW);
         when(firstFieldType.asRawType()).thenReturn(firstFieldType); // REFACTOR
-        when(firstField.getFieldType()).thenReturn(firstFieldType);
+        when(firstField.getType()).thenReturn(firstFieldType);
         when(firstField.getName()).thenReturn(FOO);
         when(firstField.getInternalName()).thenReturn(FOO);
         when(firstField.getDescriptor()).thenReturn(BAR);
         when(firstField.getDeclaringType()).thenReturn(firstFieldDeclaringType);
         when(firstFieldDeclaringType.getInternalName()).thenReturn(QUX);
         when(secondFieldType.getSort()).thenReturn(GenericTypeDescription.Sort.RAW);
         when(secondFieldType.asRawType()).thenReturn(secondFieldType); // REFACTOR
-        when(secondField.getFieldType()).thenReturn(secondFieldType);
+        when(secondField.getType()).thenReturn(secondFieldType);
         when(secondField.getName()).thenReturn(BAR);
         when(secondField.getInternalName()).thenReturn(BAR);
         when(secondField.getDescriptor()).thenReturn(FOO);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldProxyBinderTest.java
Patch:
@@ -45,7 +45,7 @@ public void setUp() throws Exception {
         when(getterMethod.getDeclaringType()).thenReturn(getterType);
         when(setterMethod.getDeclaringType()).thenReturn(setterType);
         when(instrumentedType.getDeclaredFields()).thenReturn(new FieldList.Explicit(Collections.singletonList(fieldDescription)));
-        when(fieldDescription.getFieldType()).thenReturn(fieldType);
+        when(fieldDescription.getType()).thenReturn(fieldType);
         when(fieldType.getStackSize()).thenReturn(StackSize.ZERO);
         when(fieldType.getSort()).thenReturn(GenericTypeDescription.Sort.RAW);
         when(fieldType.asRawType()).thenReturn(fieldType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/constant/MethodConstantTest.java
Patch:
@@ -63,7 +63,7 @@ public void setUp() throws Exception {
         when(declaringType.getDescriptor()).thenReturn(BAR);
         when(typeList.iterator()).thenReturn(Collections.singletonList(parameterType).iterator());
         when(parameterType.getDescriptor()).thenReturn(QUX);
-        when(fieldDescription.getFieldType()).thenReturn(fieldType);
+        when(fieldDescription.getType()).thenReturn(fieldType);
         when(fieldDescription.isStatic()).thenReturn(true);
         when(fieldType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(fieldDescription.getDeclaringType()).thenReturn(declaringType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/FieldAccessTest.java
Patch:
@@ -83,7 +83,7 @@ public static Collection<Object[]> data() {
     @Before
     public void setUp() throws Exception {
         when(fieldDescription.getDeclaringType()).thenReturn(declaringType);
-        when(fieldDescription.getFieldType()).thenReturn(fieldType);
+        when(fieldDescription.getType()).thenReturn(fieldType);
         when(declaringType.getInternalName()).thenReturn(FOO);
         when(fieldDescription.getInternalName()).thenReturn(BAR);
         when(fieldDescription.getDescriptor()).thenReturn(QUX);

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultTypeDescriptionTest.java
Patch:
@@ -10,7 +10,6 @@
 import java.lang.reflect.Method;
 
 import static net.bytebuddy.matcher.ElementMatchers.is;
-import static net.bytebuddy.matcher.ElementMatchers.named;
 
 public class TypePoolDefaultTypeDescriptionTest extends AbstractTypeDescriptionTest {
 
@@ -37,7 +36,7 @@ protected GenericTypeDescription describe(Field field) {
                 .getDeclaredFields()
                 .filter(is(field))
                 .getOnly()
-                .getFieldTypeGen();
+                .getType();
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -58,7 +58,7 @@ public RedefinitionDynamicTypeBuilder(ClassFileVersion classFileVersion,
                                           NamingStrategy namingStrategy,
                                           AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
                                           TypeDescription levelType,
-                                          List<? extends TypeDescription> interfaceTypes,
+                                          List<? extends GenericTypeDescription> interfaceTypes,
                                           int modifiers,
                                           TypeAttributeAppender attributeAppender,
                                           ElementMatcher<? super MethodDescription> ignoredMethods,
@@ -74,7 +74,7 @@ public RedefinitionDynamicTypeBuilder(ClassFileVersion classFileVersion,
                 namingStrategy,
                 auxiliaryTypeNamingStrategy,
                 levelType,
-                new ArrayList<TypeDescription>(interfaceTypes),
+                new ArrayList<GenericTypeDescription>(interfaceTypes),
                 modifiers,
                 attributeAppender,
                 ignoredMethods,

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentedTypeTest.java
Patch:
@@ -3,13 +3,12 @@
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.NamingStrategy;
 import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.generic.GenericTypeList;
 import net.bytebuddy.dynamic.scaffold.AbstractInstrumentedTypeTest;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import org.objectweb.asm.Opcodes;
 
 import java.io.Serializable;
-import java.util.Collections;
 
 public class SubclassInstrumentedTypeTest extends AbstractInstrumentedTypeTest {
 
@@ -20,7 +19,7 @@ protected InstrumentedType makePlainInstrumentedType() {
         return new SubclassInstrumentedType(
                 ClassFileVersion.forCurrentJavaVersion(),
                 new TypeDescription.ForLoadedType(Object.class),
-                new TypeList.ForLoadedType(Collections.<Class<?>>singletonList(Serializable.class)),
+                new GenericTypeList.ForLoadedType(Serializable.class),
                 Opcodes.ACC_PUBLIC,
                 new NamingStrategy.Fixed(FOOBAR));
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/GenericTypeDescription.java
Patch:
@@ -658,7 +658,7 @@ public <T> T accept(Visitor<T> visitor) {
 
         @Override
         public StackSize getStackSize() {
-            return StackSize.SINGLE;
+            throw new IllegalStateException("A wildcard does not imply an operand stack size: " + this);
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -3746,7 +3746,7 @@ public static GenericTypeToken of(char descriptor) {
                         case 'D':
                             return DOUBLE;
                         default:
-                            throw new IllegalArgumentException("Not a valid descriptor: " + descriptor);
+                            throw new IllegalArgumentException("Not a valid primitive type descriptor: " + descriptor);
                     }
                 }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -925,7 +925,7 @@ protected ValidatingClassVisitor(ClassVisitor classVisitor) {
             @Override
             public void visit(int version, int modifier, String name, String signature, String superName, String[] interfaces) {
                 ClassFileVersion classFileVersion = new ClassFileVersion(version);
-                if (name.endsWith("." + PackageDescription.PACKAGE_CLASS_NAME)) {
+                if (name.endsWith("/" + PackageDescription.PACKAGE_CLASS_NAME)) {
                     constraint = Constraint.PACKAGE_CLASS;
                 } else if ((modifier & Opcodes.ACC_ANNOTATION) != ModifierReviewable.EMPTY_MASK) {
                     constraint = classFileVersion.isSupportsDefaultMethods()

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/InlineInstrumentedType.java
Patch:
@@ -62,7 +62,7 @@ public InlineInstrumentedType(ClassFileVersion classFileVersion,
                                   NamingStrategy namingStrategy) {
         super(LoadedTypeInitializer.NoOp.INSTANCE,
                 TypeInitializer.None.INSTANCE,
-                named(levelType.getName()),
+                named(levelType.getSourceCodeName()),
                 levelType.getTypeVariables(),
                 levelType.getDeclaredFields(),
                 levelType.getDeclaredMethods());

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -878,7 +878,7 @@ public static PreparationHandler of(String name, TypeDescription typeDescription
 
                 @Override
                 public InstrumentedType prepare(InstrumentedType instrumentedType) {
-                    return instrumentedType.withField(name, TargetType.resolve(typeDescription, instrumentedType, TargetType.MATCHER), modifiers);
+                    return instrumentedType.withField(name, TargetType.resolve(typeDescription, instrumentedType), modifiers);
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -1081,7 +1081,7 @@ protected static FieldLocator consider(MethodDescription methodDescription) {
                 protected LookupEngine lookup(TypeDescription typeDescription, TypeDescription instrumentedType) {
                     return typeDescription.represents(void.class)
                             ? new LookupEngine.ForHierarchy(fieldName)
-                            : new LookupEngine.ForExplicitType(fieldName, TargetType.resolve(typeDescription, instrumentedType, TargetType.MATCHER));
+                            : new LookupEngine.ForExplicitType(fieldName, TargetType.resolve(typeDescription, instrumentedType).asRawType());
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Super.java
Patch:
@@ -105,8 +105,7 @@ protected StackManipulation proxyFor(TypeDescription parameterType,
                                                  AnnotationDescription.Loadable<Super> annotation) {
                 TypeDescription[] constructorParameters = annotation.getValue(CONSTRUCTOR_PARAMETERS, TypeDescription[].class);
                 List<TypeDescription> typeDescriptions = TargetType.resolve(Arrays.asList(constructorParameters),
-                        implementationTarget.getTypeDescription(),
-                        TargetType.MATCHER).asRawTypes();
+                        implementationTarget.getTypeDescription()).asRawTypes();
                 return new TypeProxy.ForSuperMethodByConstructor(parameterType,
                         implementationTarget,
                         typeDescriptions,

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -3803,7 +3803,7 @@ public Sort getSort() {
                 public GenericTypeDescription toGenericType(TypePool typePool, TypeVariableSource typeVariableSource) {
                     GenericTypeDescription typeVariable = typeVariableSource.findVariable(symbol);
                     if (typeVariable == null) {
-                        throw new IllegalStateException("Cannot resolve type variable " + symbol + " for " + typeVariableSource);
+                        throw new IllegalStateException("Cannot resolve type variable '" + symbol + "' for " + typeVariableSource);
                     } else {
                         return typeVariable;
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/GenericTypeDescription.java
Patch:
@@ -11,6 +11,8 @@
 import java.util.Collections;
 import java.util.List;
 
+import static net.bytebuddy.matcher.ElementMatchers.named;
+
 public interface GenericTypeDescription extends NamedElement {
 
     Sort getSort();

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/MethodRegistry.java
Patch:
@@ -416,8 +416,7 @@ public MethodRegistry.Prepared prepare(InstrumentedType instrumentedType,
                 }
             }
             MethodLookupEngine.Finding finding = methodLookupEngine.process(instrumentedType);
-            ElementMatcher<? super MethodDescription> instrumented = (ElementMatcher<? super MethodDescription>) not(anyOf(implementations.keySet()))
-                    .and(methodFilter.resolve(instrumentedType));
+            ElementMatcher<? super MethodDescription> instrumented = not(anyOf(implementations.keySet())).and(methodFilter.resolve(instrumentedType));
             List<MethodDescription> methodDescriptions = join(typeInitializerOf(instrumentedType), finding.getInvokableMethods().filter(instrumented));
             for (MethodDescription methodDescription : methodDescriptions) {
                 for (Entry entry : entries) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -878,7 +878,7 @@ public static PreparationHandler of(String name, TypeDescription typeDescription
 
                 @Override
                 public InstrumentedType prepare(InstrumentedType instrumentedType) {
-                    return instrumentedType.withField(name, TargetType.resolve(typeDescription, instrumentedType, is(TargetType.DESCRIPTION)), modifiers);
+                    return instrumentedType.withField(name, TargetType.resolve(typeDescription, instrumentedType, TargetType.MATCHER), modifiers);
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -1081,7 +1081,7 @@ protected static FieldLocator consider(MethodDescription methodDescription) {
                 protected LookupEngine lookup(TypeDescription typeDescription, TypeDescription instrumentedType) {
                     return typeDescription.represents(void.class)
                             ? new LookupEngine.ForHierarchy(fieldName)
-                            : new LookupEngine.ForExplicitType(fieldName, TargetType.resolveRaw(typeDescription, instrumentedType, is(TargetType.DESCRIPTION)));
+                            : new LookupEngine.ForExplicitType(fieldName, TargetType.resolve(typeDescription, instrumentedType, TargetType.MATCHER));
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Super.java
Patch:
@@ -104,9 +104,9 @@ protected StackManipulation proxyFor(TypeDescription parameterType,
                                                  Implementation.Target implementationTarget,
                                                  AnnotationDescription.Loadable<Super> annotation) {
                 TypeDescription[] constructorParameters = annotation.getValue(CONSTRUCTOR_PARAMETERS, TypeDescription[].class);
-                List<TypeDescription> typeDescriptions = TargetType.resolveRaw(Arrays.asList(constructorParameters),
+                List<TypeDescription> typeDescriptions = TargetType.resolve(Arrays.asList(constructorParameters),
                         implementationTarget.getTypeDescription(),
-                        is(TargetType.DESCRIPTION));
+                        TargetType.MATCHER).asRawTypes();
                 return new TypeProxy.ForSuperMethodByConstructor(parameterType,
                         implementationTarget,
                         typeDescriptions,

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/RawTypeMatcher.java
Patch:
@@ -43,6 +43,6 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return "asRawType(" + rawTypeMatcher + ")";
+        return "rawType(" + rawTypeMatcher + ")";
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/RawTypeMatcherTest.java
Patch:
@@ -25,7 +25,7 @@ public class RawTypeMatcherTest extends AbstractElementMatcherTest<RawTypeMatche
 
     @SuppressWarnings("unchecked")
     public RawTypeMatcherTest() {
-        super((Class<? extends RawTypeMatcher<?>>) (Object) RawTypeMatcher.class, "asRawType");
+        super((Class<? extends RawTypeMatcher<?>>) (Object) RawTypeMatcher.class, "rawType");
     }
 
     @Before

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/pkg/package-info.java
Patch:
@@ -1 +1,2 @@
-@PkgAnnotation package net.bytebuddy.test.pkg;
+@PkgAnnotation
+package net.bytebuddy.test.pkg;

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/TypeVariableSource.java
Patch:
@@ -7,4 +7,6 @@ public interface TypeVariableSource extends ByteCodeElement {
     GenericTypeList getTypeVariables();
 
     TypeVariableSource getEnclosingSource();
+
+    // TODO: TypeVariableSource find(String symbol);
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/InlineInstrumentedType.java
Patch:
@@ -17,6 +17,7 @@
 import java.util.List;
 import java.util.Set;
 
+import static net.bytebuddy.matcher.ElementMatchers.named;
 import static net.bytebuddy.utility.ByteBuddyCommons.isValidTypeName;
 import static net.bytebuddy.utility.ByteBuddyCommons.join;
 
@@ -61,7 +62,7 @@ public InlineInstrumentedType(ClassFileVersion classFileVersion,
                                   NamingStrategy namingStrategy) {
         super(LoadedTypeInitializer.NoOp.INSTANCE,
                 TypeInitializer.None.INSTANCE,
-                levelType.getName(),
+                named(levelType.getName()),
                 levelType.getDeclaredFields(),
                 levelType.getDeclaredMethods());
         this.levelType = levelType;
@@ -97,7 +98,7 @@ protected InlineInstrumentedType(TypeDescription levelType,
                                      TypeInitializer typeInitializer) {
         super(loadedTypeInitializer,
                 typeInitializer,
-                name,
+                named(name),
                 fieldDescriptions,
                 methodDescriptions);
         this.levelType = levelType;

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentedType.java
Patch:
@@ -15,6 +15,7 @@
 import java.util.Collections;
 import java.util.List;
 
+import static net.bytebuddy.matcher.ElementMatchers.named;
 import static net.bytebuddy.utility.ByteBuddyCommons.isValidTypeName;
 import static net.bytebuddy.utility.ByteBuddyCommons.join;
 
@@ -96,7 +97,7 @@ protected SubclassInstrumentedType(ClassFileVersion classFileVersion,
                                        TypeInitializer typeInitializer) {
         super(loadedTypeInitializer,
                 typeInitializer,
-                name,
+                named(name),
                 fieldDescriptions,
                 methodDescriptions);
         this.classFileVersion = classFileVersion;

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FieldAccessor.java
Patch:
@@ -878,7 +878,7 @@ public static PreparationHandler of(String name, TypeDescription typeDescription
 
                 @Override
                 public InstrumentedType prepare(InstrumentedType instrumentedType) {
-                    return instrumentedType.withField(name, TargetType.resolve(typeDescription, instrumentedType), modifiers);
+                    return instrumentedType.withField(name, TargetType.resolve(typeDescription, instrumentedType, is(TargetType.DESCRIPTION)), modifiers);
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -1081,7 +1081,7 @@ protected static FieldLocator consider(MethodDescription methodDescription) {
                 protected LookupEngine lookup(TypeDescription typeDescription, TypeDescription instrumentedType) {
                     return typeDescription.represents(void.class)
                             ? new LookupEngine.ForHierarchy(fieldName)
-                            : new LookupEngine.ForExplicitType(fieldName, TargetType.resolve(typeDescription, instrumentedType));
+                            : new LookupEngine.ForExplicitType(fieldName, TargetType.resolveRaw(typeDescription, instrumentedType, is(TargetType.DESCRIPTION)));
                 }
 
                 @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTest.java
Patch:
@@ -4,6 +4,7 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.modifier.ModifierContributor;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.scaffold.BridgeMethodResolver;
 import net.bytebuddy.dynamic.scaffold.MethodLookupEngine;
 import net.bytebuddy.implementation.Implementation;
@@ -76,6 +77,8 @@ public class ByteBuddyTest {
     public void setUp() throws Exception {
         when(modifierContributorForType.getMask()).thenReturn(MASK);
         when(typeDescription.isInterface()).thenReturn(true);
+        when(typeDescription.asRawType()).thenReturn(typeDescription);
+        when(typeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.RAW);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/DefaultMethodCallTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.test.utility.JavaVersionRule;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
@@ -169,6 +170,8 @@ public void testObjectProperties() throws Exception {
             public List<?> create() {
                 TypeDescription typeDescription = mock(TypeDescription.class);
                 when(typeDescription.isInterface()).thenReturn(true);
+                when(typeDescription.asRawType()).thenReturn(typeDescription);
+                when(typeDescription.getSort()).thenReturn(GenericTypeDescription.Sort.RAW);
                 return Collections.singletonList(typeDescription);
             }
         }).apply();

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -1757,7 +1757,7 @@ public static Builder forType(TypeDescription annotationType) {
         /**
          * The annotation type.
          */
-        protected final TypeDescription annotationType;
+        private final TypeDescription annotationType;
 
         /**
          * A mapping of annotation properties to their annotation values.

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/generic/GenericSignatureResolutionTest.java
Patch:
@@ -8,8 +8,8 @@
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.implementation.FixedValue;
 import net.bytebuddy.test.utility.DebuggingWrapper;
-import org.junit.Ignore;
 import org.junit.Test;
+import org.objectweb.asm.util.ASMifier;
 
 import java.util.ArrayList;
 import java.util.concurrent.Callable;
@@ -19,7 +19,6 @@
 import static org.hamcrest.CoreMatchers.notNullValue;
 import static org.hamcrest.MatcherAssert.assertThat;
 
-@Ignore
 public class GenericSignatureResolutionTest {
 
     private static final String FOO = "foo";
@@ -41,7 +40,6 @@ public void testGenericType() throws Exception {
     public void testGenericField() throws Exception {
         DynamicType.Unloaded<?> unloaded = new ByteBuddy()
                 .redefine(GenericField.class)
-                .classVisitor(DebuggingWrapper.makeDefault())
                 .make();
         Class<?> type = unloaded.load(null, ClassLoadingStrategy.Default.WRAPPER).getLoaded();
         FieldDescription createdField = new FieldDescription.ForLoadedField(type.getDeclaredField(FOO));

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldProxyBinderTest.java
Patch:
@@ -5,6 +5,7 @@
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.ParameterList;
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericTypeDescription;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bind.MethodDelegationBinder;
 import net.bytebuddy.implementation.bytecode.StackSize;
@@ -46,6 +47,8 @@ public void setUp() throws Exception {
         when(instrumentedType.getDeclaredFields()).thenReturn(new FieldList.Explicit(Collections.singletonList(fieldDescription)));
         when(fieldDescription.getFieldType()).thenReturn(fieldType);
         when(fieldType.getStackSize()).thenReturn(StackSize.ZERO);
+        when(fieldType.getSort()).thenReturn(GenericTypeDescription.Sort.RAW);
+        when(fieldType.asRawType()).thenReturn(fieldType);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -4505,7 +4505,7 @@ public int getModifiers() {
 
                 @Override
                 public GenericTypeDescription getTypeGen() {
-                    return getTypeDescription();
+                    return signatureResolution.resolveParameterTypes(parameterTypeDescriptors, typePool, LazyMethodDescription.this).get(index);
                 }
 
                 @Override
@@ -4662,7 +4662,7 @@ private TokenList(TypePool typePool,
 
                 @Override
                 public GenericTypeDescription get(int index) {
-                    return genericTypeTokens.get(index).toGenericType(typePool, typeVariableSource);
+                    return new TokenizedGenericType(typePool, genericTypeTokens.get(index), rawTypeDescriptors.get(index), typeVariableSource);
                 }
 
                 @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/AbstractInstrumentedTypeTest.java
Patch:
@@ -100,6 +100,7 @@ public void testWithMethod() throws Exception {
         TypeDescription returnType = mock(TypeDescription.class);
         when(returnType.asRawType()).thenReturn(returnType); // REFACTOR
         TypeDescription parameterType = mock(TypeDescription.class);
+        when(parameterType.asRawType()).thenReturn(parameterType); // REFACTOR
         TypeDescription exceptionType = mock(TypeDescription.class);
         when(exceptionType.asRawType()).thenReturn(exceptionType); // REFACTOR
         when(returnType.getName()).thenReturn(FOO);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverEnabledTest.java
Patch:
@@ -66,6 +66,8 @@ public void setUp() throws Exception {
         when(constructor.getParameters()).thenReturn(constructorParameterList);
         when(methodNameTransformer.transform(method)).thenReturn(BAR);
         when(returnType.asRawType()).thenReturn(returnType); // REFACTOR
+        when(parameterType.asRawType()).thenReturn(parameterType); // REFACTOR
+        when(placeholderType.asRawType()).thenReturn(placeholderType); // REFACTOR
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverMethodsOnlyTest.java
Patch:
@@ -54,6 +54,7 @@ public void setUp() throws Exception {
         when(constructor.isConstructor()).thenReturn(true);
         when(methodNameTransformer.transform(method)).thenReturn(BAR);
         when(returnType.asRawType()).thenReturn(returnType); // REFACTOR
+        when(parameterType.asRawType()).thenReturn(parameterType); // REFACTOR
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedConstructorTest.java
Patch:
@@ -61,6 +61,7 @@ public void setUp() throws Exception {
         when(placeholderType.getDescriptor()).thenReturn(BAZ);
         when(otherPlaceHolderType.getDescriptor()).thenReturn(FOO);
         when(returnType.asRawType()).thenReturn(returnType); // REFACTOR
+        when(parameterType.asRawType()).thenReturn(parameterType); // REFACTOR
     }
 
     @Test
@@ -97,6 +98,7 @@ public void apply(MethodDescription mock) {
             @Override
             public void apply(TypeDescription mock) {
                 when(mock.getDescriptor()).thenReturn(FOO + System.identityHashCode(mock));
+                when(mock.asRawType()).thenReturn(mock); // REFACTOR
                 when(mock.getStackSize()).thenReturn(StackSize.ZERO);
             }
         }).apply();

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedMethodTest.java
Patch:
@@ -61,6 +61,7 @@ public void setUp() throws Exception {
         ParameterList parameterList = ParameterList.Explicit.latent(methodDescription, Collections.singletonList(parameterType));
         when(methodDescription.getParameters()).thenReturn(parameterList);
         when(returnType.asRawType()).thenReturn(returnType); // REFACTOR
+        when(parameterType.asRawType()).thenReturn(parameterType); // REFACTOR
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/AbstractSpecialMethodInvocationTest.java
Patch:
@@ -38,6 +38,7 @@ public void setUp() throws Exception {
         when(parameterType.getStackSize()).thenReturn(StackSize.ZERO);
         parameterTypes = new TypeList.Explicit(Collections.singletonList(parameterType));
         when(returnType.asRawType()).thenReturn(returnType); // REFACTOR
+        when(parameterType.asRawType()).thenReturn(parameterType); // REFACTOR
     }
 
     protected abstract Implementation.SpecialMethodInvocation make(String name,

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/ImplementationContextDefaultTest.java
Patch:
@@ -186,6 +186,8 @@ public void setUp() throws Exception {
         when(secondSpecialReturnType.asRawType()).thenReturn(secondSpecialReturnType); // REFACTOR
         when(firstSpecialExceptionType.asRawType()).thenReturn(firstSpecialExceptionType); // REFACTOR
         when(secondSpecialExceptionType.asRawType()).thenReturn(secondSpecialExceptionType); // REFACTOR
+        when(firstSpecialParameterType.asRawType()).thenReturn(firstSpecialParameterType); // REFACTOR
+        when(secondSpecialParameterType.asRawType()).thenReturn(secondSpecialParameterType); // REFACTOR
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/MethodVariableAccessDescriptionTest.java
Patch:
@@ -47,6 +47,8 @@ public void setUp() throws Exception {
         when(declaringType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(firstParameterType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(secondParameterType.getStackSize()).thenReturn(StackSize.SINGLE);
+        when(firstParameterType.asRawType()).thenReturn(firstParameterType); // REFACTOR
+        when(secondParameterType.asRawType()).thenReturn(secondParameterType); // REFACTOR
         ParameterList parameterList = ParameterList.Explicit.latent(methodDescription, Arrays.asList(firstParameterType, secondParameterType));
         when(methodDescription.getParameters()).thenReturn(parameterList);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/AbstractInstrumentedTypeTest.java
Patch:
@@ -98,8 +98,10 @@ public void testWithFieldDouble() throws Exception {
     @Test
     public void testWithMethod() throws Exception {
         TypeDescription returnType = mock(TypeDescription.class);
+        when(returnType.asRawType()).thenReturn(returnType); // REFACTOR
         TypeDescription parameterType = mock(TypeDescription.class);
         TypeDescription exceptionType = mock(TypeDescription.class);
+        when(exceptionType.asRawType()).thenReturn(exceptionType); // REFACTOR
         when(returnType.getName()).thenReturn(FOO);
         when(parameterType.getName()).thenReturn(QUX);
         when(parameterType.getStackSize()).thenReturn(StackSize.ZERO);
@@ -168,6 +170,7 @@ public void testWithMethodOfInstrumentedTypeAsArray() throws Exception {
     @Test(expected = IllegalArgumentException.class)
     public void testWithMethodDouble() throws Exception {
         TypeDescription returnType = mock(TypeDescription.class);
+        when(returnType.asRawType()).thenReturn(returnType); // REFACTOR
         when(returnType.getName()).thenReturn(FOO);
         makePlainInstrumentedType()
                 .withMethod(BAR, returnType, Collections.<TypeDescription>emptyList(), Collections.<TypeDescription>emptyList(), Opcodes.ACC_PUBLIC)

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverEnabledTest.java
Patch:
@@ -65,6 +65,7 @@ public void setUp() throws Exception {
         ParameterList constructorParameterList = ParameterList.Explicit.latent(method, Collections.singletonList(parameterType));
         when(constructor.getParameters()).thenReturn(constructorParameterList);
         when(methodNameTransformer.transform(method)).thenReturn(BAR);
+        when(returnType.asRawType()).thenReturn(returnType); // REFACTOR
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverMethodsOnlyTest.java
Patch:
@@ -53,6 +53,7 @@ public void setUp() throws Exception {
         when(method.getParameters()).thenReturn(methodParameterList);
         when(constructor.isConstructor()).thenReturn(true);
         when(methodNameTransformer.transform(method)).thenReturn(BAR);
+        when(returnType.asRawType()).thenReturn(returnType); // REFACTOR
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/implementation/AbstractSpecialMethodInvocationTest.java
Patch:
@@ -37,6 +37,7 @@ public abstract class AbstractSpecialMethodInvocationTest {
     public void setUp() throws Exception {
         when(parameterType.getStackSize()).thenReturn(StackSize.ZERO);
         parameterTypes = new TypeList.Explicit(Collections.singletonList(parameterType));
+        when(returnType.asRawType()).thenReturn(returnType); // REFACTOR
     }
 
     protected abstract Implementation.SpecialMethodInvocation make(String name,

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/GenericTypeDescription.java
Patch:
@@ -278,7 +278,7 @@ protected Latent(GenericTypeDescription componentType, int arity) {
 
             @Override
             public GenericTypeDescription getComponentType() {
-                return arity == 0
+                return arity == 1
                         ? componentType
                         : new Latent(componentType, arity - 1);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -4409,7 +4409,7 @@ public int getModifiers() {
 
             @Override
             public GenericTypeList getTypeVariables() {
-                return new GenericTypeList.Empty();
+                return signatureResolution.resolveTypeVariables(typePool, this);
             }
 
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -3,6 +3,7 @@
 import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.annotation.AnnotationList;
 import net.bytebuddy.description.method.MethodDescription;
+import net.bytebuddy.description.type.generic.AbstractGenericTypeDescriptionTest;
 import net.bytebuddy.dynamic.loading.ByteArrayClassLoader;
 import net.bytebuddy.implementation.bytecode.StackSize;
 import net.bytebuddy.test.utility.ClassFileExtraction;
@@ -26,7 +27,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-public abstract class AbstractTypeDescriptionTest {
+public abstract class AbstractTypeDescriptionTest extends AbstractGenericTypeDescriptionTest {
 
     private static final String FOO = "foo", BAR = "bar";
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -1437,11 +1437,11 @@ public void visitTypeArgument() {
             @Override
             public SignatureVisitor visitTypeArgument(char wildcard) {
                 switch (wildcard) {
-                    case '-':
+                    case SignatureVisitor.SUPER:
                         return incompleteToken.appendLowerBound();
-                    case '+':
+                    case SignatureVisitor.EXTENDS:
                         return incompleteToken.appendUpperBound();
-                    case '=':
+                    case SignatureVisitor.INSTANCEOF:
                         return incompleteToken.appendDirectBound();
                     default:
                         throw new IllegalArgumentException("Unknown wildcard: " + wildcard);

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -310,7 +310,6 @@ public String getGenericSignature() {
                     SignatureVisitor boundVisitor = classBound
                             ? signatureWriter.visitClassBound()
                             : signatureWriter.visitInterfaceBound();
-                    boundVisitor.visitTypeArgument(SignatureVisitor.EXTENDS);
                     upperBound.accept(new GenericTypeDescription.Visitor.ForSignatureVisitor(boundVisitor));
                     classBound = false;
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -470,7 +470,6 @@ public String getGenericSignature() {
                     SignatureVisitor boundVisitor = classBound
                             ? signatureWriter.visitClassBound()
                             : signatureWriter.visitInterfaceBound();
-                    boundVisitor.visitTypeArgument(SignatureVisitor.EXTENDS);
                     upperBound.accept(new Visitor.ForSignatureVisitor(boundVisitor));
                     classBound = false;
                 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/InlineInstrumentedTypeTest.java
Patch:
@@ -38,7 +38,7 @@ public void setUp() throws Exception {
         when(targetType.getDeclaredMethods()).thenReturn(new MethodList.Empty());
         when(targetType.getDeclaredFields()).thenReturn(new FieldList.Empty());
         when(targetType.getInterfaces()).thenReturn(new TypeList.Empty());
-        when(targetType.getSupertype()).thenReturn(new TypeDescription.ForLoadedType(Object.class));
+        when(targetType.getSuperTypeGen()).thenReturn(new TypeDescription.ForLoadedType(Object.class));
         when(targetType.getPackage()).thenReturn(packageDescription);
         when(packageDescription.getName()).thenReturn(FOO);
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/GenericType.java
Patch:
@@ -769,7 +769,6 @@ public static class OfLoadedParameter extends LazyProjection {
                 GET_GENERIC_TYPE = getGenericType;
             }
 
-
             private final Object parameter;
 
             public OfLoadedParameter(Object parameter) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -107,7 +107,7 @@ public TypeDescription getFieldType() {
 
         @Override
         public GenericType getFieldTypeGen() {
-            return new GenericType.LazyProjection.OfFieldType(field);
+            return new GenericType.LazyProjection.OfLoadedFieldType(field);
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -235,7 +235,7 @@ public TypeDescription getTypeDescription() {
 
         @Override
         public GenericType getTypeGen() {
-            return new TypeDescription.LazyProjection.OfParameter(parameter);
+            return new GenericType.LazyProjection.OfLoadedParameter(parameter);
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/TypeVariableSource.java
Patch:
@@ -5,4 +5,6 @@
 public interface TypeVariableSource extends ByteCodeElement {
 
     GenericTypeList getTypeVariables();
+
+    TypeVariableSource getEnclosingSource();
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/ByteCodeElement.java
Patch:
@@ -1,13 +1,12 @@
 package net.bytebuddy.description;
 
 import net.bytebuddy.description.annotation.AnnotatedCodeElement;
-import net.bytebuddy.description.type.DeclaredInType;
 import net.bytebuddy.description.type.TypeDescription;
 
 /**
  * Implementations describe an element represented in byte code, i.e. a type, a field or a method or a constructor.
  */
-public interface ByteCodeElement extends NamedElement, ModifierReviewable, DeclaredInType, AnnotatedCodeElement {
+public interface ByteCodeElement extends NamedElement, ModifierReviewable, DeclaredByType, AnnotatedCodeElement {
 
     /**
      * Returns the descriptor of this byte code element.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/DeclaredByType.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.description;
 
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericType;
 
 /**
  * This interface represents all elements that can be declared within a type, i.e. other types and type members.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringTypeMatcher.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.matcher;
 
-import net.bytebuddy.description.type.DeclaredInType;
+import net.bytebuddy.description.DeclaredByType;
 import net.bytebuddy.description.type.TypeDescription;
 
 /**
@@ -9,7 +9,7 @@
  *
  * @param <T> The exact type of the element being matched.
  */
-public class DeclaringTypeMatcher<T extends DeclaredInType> extends ElementMatcher.Junction.AbstractBase<T> {
+public class DeclaringTypeMatcher<T extends DeclaredByType> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**
      * The type matcher to be applied if the target element is declared in a type.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1686,8 +1686,7 @@ public ExceptionDeclarableMethodInterception<S> defineMethod(String name,
             public ExceptionDeclarableMethodInterception<S> defineConstructor(
                     List<? extends TypeDescription> parameterTypes,
                     ModifierContributor.ForMethod... modifier) {
-                return defineConstructor(parameterTypes,
-                        resolveModifierContributors(METHOD_MODIFIER_MASK & ~Opcodes.ACC_STATIC, nonNull(modifier)));
+                return defineConstructor(parameterTypes, resolveModifierContributors(METHOD_MODIFIER_MASK & ~Opcodes.ACC_STATIC, nonNull(modifier)));
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -241,9 +241,7 @@ protected enum ConstructorCall implements Implementation {
          * Creates the constructor call singleton.
          */
         ConstructorCall() {
-            this.objectTypeDefaultConstructor = TypeDescription.OBJECT.getDeclaredMethods()
-                    .filter(isConstructor())
-                    .getOnly();
+            objectTypeDefaultConstructor = TypeDescription.OBJECT.getDeclaredMethods().filter(isConstructor()).getOnly();
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/GenericTypeDescription.java
Patch:
@@ -278,7 +278,7 @@ protected Latent(GenericTypeDescription componentType, int arity) {
 
             @Override
             public GenericTypeDescription getComponentType() {
-                return arity == 0
+                return arity == 1
                         ? componentType
                         : new Latent(componentType, arity - 1);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -4409,7 +4409,7 @@ public int getModifiers() {
 
             @Override
             public GenericTypeList getTypeVariables() {
-                return new GenericTypeList.Empty();
+                return signatureResolution.resolveTypeVariables(typePool, this);
             }
 
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
Patch:
@@ -3,6 +3,7 @@
 import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.annotation.AnnotationList;
 import net.bytebuddy.description.method.MethodDescription;
+import net.bytebuddy.description.type.generic.AbstractGenericTypeDescriptionTest;
 import net.bytebuddy.dynamic.loading.ByteArrayClassLoader;
 import net.bytebuddy.implementation.bytecode.StackSize;
 import net.bytebuddy.test.utility.ClassFileExtraction;
@@ -26,7 +27,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-public abstract class AbstractTypeDescriptionTest {
+public abstract class AbstractTypeDescriptionTest extends AbstractGenericTypeDescriptionTest {
 
     private static final String FOO = "foo", BAR = "bar";
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -1437,11 +1437,11 @@ public void visitTypeArgument() {
             @Override
             public SignatureVisitor visitTypeArgument(char wildcard) {
                 switch (wildcard) {
-                    case '-':
+                    case SignatureVisitor.SUPER:
                         return incompleteToken.appendLowerBound();
-                    case '+':
+                    case SignatureVisitor.EXTENDS:
                         return incompleteToken.appendUpperBound();
-                    case '=':
+                    case SignatureVisitor.INSTANCEOF:
                         return incompleteToken.appendDirectBound();
                     default:
                         throw new IllegalArgumentException("Unknown wildcard: " + wildcard);

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -310,7 +310,6 @@ public String getGenericSignature() {
                     SignatureVisitor boundVisitor = classBound
                             ? signatureWriter.visitClassBound()
                             : signatureWriter.visitInterfaceBound();
-                    boundVisitor.visitTypeArgument(SignatureVisitor.EXTENDS);
                     upperBound.accept(new GenericTypeDescription.Visitor.ForSignatureVisitor(boundVisitor));
                     classBound = false;
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
Patch:
@@ -470,7 +470,6 @@ public String getGenericSignature() {
                     SignatureVisitor boundVisitor = classBound
                             ? signatureWriter.visitClassBound()
                             : signatureWriter.visitInterfaceBound();
-                    boundVisitor.visitTypeArgument(SignatureVisitor.EXTENDS);
                     upperBound.accept(new Visitor.ForSignatureVisitor(boundVisitor));
                     classBound = false;
                 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/InlineInstrumentedTypeTest.java
Patch:
@@ -38,7 +38,7 @@ public void setUp() throws Exception {
         when(targetType.getDeclaredMethods()).thenReturn(new MethodList.Empty());
         when(targetType.getDeclaredFields()).thenReturn(new FieldList.Empty());
         when(targetType.getInterfaces()).thenReturn(new TypeList.Empty());
-        when(targetType.getSupertype()).thenReturn(new TypeDescription.ForLoadedType(Object.class));
+        when(targetType.getSuperTypeGen()).thenReturn(new TypeDescription.ForLoadedType(Object.class));
         when(targetType.getPackage()).thenReturn(packageDescription);
         when(packageDescription.getName()).thenReturn(FOO);
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/GenericType.java
Patch:
@@ -769,7 +769,6 @@ public static class OfLoadedParameter extends LazyProjection {
                 GET_GENERIC_TYPE = getGenericType;
             }
 
-
             private final Object parameter;
 
             public OfLoadedParameter(Object parameter) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
Patch:
@@ -107,7 +107,7 @@ public TypeDescription getFieldType() {
 
         @Override
         public GenericType getFieldTypeGen() {
-            return new GenericType.LazyProjection.OfFieldType(field);
+            return new GenericType.LazyProjection.OfLoadedFieldType(field);
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
Patch:
@@ -235,7 +235,7 @@ public TypeDescription getTypeDescription() {
 
         @Override
         public GenericType getTypeGen() {
-            return new TypeDescription.LazyProjection.OfParameter(parameter);
+            return new GenericType.LazyProjection.OfLoadedParameter(parameter);
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/type/generic/TypeVariableSource.java
Patch:
@@ -5,4 +5,6 @@
 public interface TypeVariableSource extends ByteCodeElement {
 
     GenericTypeList getTypeVariables();
+
+    TypeVariableSource getEnclosingSource();
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/ByteCodeElement.java
Patch:
@@ -1,13 +1,12 @@
 package net.bytebuddy.description;
 
 import net.bytebuddy.description.annotation.AnnotatedCodeElement;
-import net.bytebuddy.description.type.DeclaredInType;
 import net.bytebuddy.description.type.TypeDescription;
 
 /**
  * Implementations describe an element represented in byte code, i.e. a type, a field or a method or a constructor.
  */
-public interface ByteCodeElement extends NamedElement, ModifierReviewable, DeclaredInType, AnnotatedCodeElement {
+public interface ByteCodeElement extends NamedElement, ModifierReviewable, DeclaredByType, AnnotatedCodeElement {
 
     /**
      * Returns the descriptor of this byte code element.

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/DeclaredByType.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.description;
 
 import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.description.type.generic.GenericType;
 
 /**
  * This interface represents all elements that can be declared within a type, i.e. other types and type members.

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringTypeMatcher.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.matcher;
 
-import net.bytebuddy.description.type.DeclaredInType;
+import net.bytebuddy.description.DeclaredByType;
 import net.bytebuddy.description.type.TypeDescription;
 
 /**
@@ -9,7 +9,7 @@
  *
  * @param <T> The exact type of the element being matched.
  */
-public class DeclaringTypeMatcher<T extends DeclaredInType> extends ElementMatcher.Junction.AbstractBase<T> {
+public class DeclaringTypeMatcher<T extends DeclaredByType> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**
      * The type matcher to be applied if the target element is declared in a type.

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -453,7 +453,7 @@ public DynamicType.Builder<?> makeInterface(Iterable<? extends Class<?>> types)
     /**
      * Creates a dynamic type builder for an interface that extends a number of given interfaces.
      *
-     * @param type The interface types to extend.
+     * @param typeDescription Descriptions of the interface types to extend.
      * @return A dynamic type builder for this configuration that defines an interface that extends the specified
      * interfaces.
      */

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/ByteBuddyCommonsTest.java
Patch:
@@ -278,12 +278,12 @@ public void testResolveModifierContributorsMask() throws Exception {
 
     @Test
     public void testUniqueForUniqueTypes() throws Exception {
-        assertThat(uniqueTypes(Arrays.asList(first, second)), is(Arrays.asList(first, second)));
+        assertThat(unique(Arrays.asList(first, second)), is(Arrays.asList(first, second)));
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void testUniqueForNonUniqueTypes() throws Exception {
-        uniqueTypes(Arrays.asList(first, second, first));
+        unique(Arrays.asList(first, second, first));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -1031,7 +1031,7 @@ protected enum Constraint {
                 /**
                  * Constrains for an annotation type since Java 8.
                  */
-                JAVA8_ANNOTATION("annotation (Java 8+)", false, false, false, true, true, false, true);
+                JAVA8_ANNOTATION("annotation (Java 8+)", false, false, false, true, true, true, true);
 
                 /**
                  * A name to represent the type being validated within an error message.
@@ -1141,7 +1141,7 @@ protected void assertMethod(String name, boolean isAbstract, boolean isPublic, b
                     } else if (!isStatic && isAbstract && !allowsAbstract) {
                         throw new IllegalStateException("Cannot define abstract method " + name + " for " + sortName);
                     } else if (!isAbstract && !allowsNonAbstract) {
-                        throw new IllegalStateException("Cannot define non-abstract method " + name + " + for " + sortName);
+                        throw new IllegalStateException("Cannot define non-abstract method " + name + " for " + sortName);
                     } else if (!isStatic && isDefaultIncompatible && allowsDefaultValue) {
                         throw new IllegalStateException("The signature of " + name + " is not compatible for a property of " + sortName);
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -432,8 +432,7 @@ public boolean isBootstrap(List<?> arguments) {
 
         @Override
         public boolean isDefaultValue() {
-            return getDeclaringType().isAnnotation()
-                    && !isConstructor()
+            return !isConstructor()
                     && !isStatic()
                     && getReturnType().isAnnotationReturnType()
                     && getParameters().isEmpty();

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
Patch:
@@ -156,7 +156,7 @@ public interface MethodDescription extends ByteCodeElement {
      * <li>{@link java.lang.annotation.Annotation} values are represented as
      * {@link AnnotationDescription}s</li>
      * <li>{@link java.lang.Enum} values are represented as
-     * {@link net.bytebuddy.description.annotation.AnnotationDescription.EnumerationDescription}s.</li>
+     * {@link net.bytebuddy.description.enumeration.EnumerationDescription}s.</li>
      * <li>Arrays of the latter types are represented as arrays of the named wrapper types.</li>
      * </ul>
      *

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -686,7 +686,7 @@ interface MatchedMethodInterception<S> {
 
             /**
              * Defines a default annotation value to set for any matched method. The value is to be represented in a wrapper format,
-             * {@code enum} values should be handed as {@link net.bytebuddy.description.annotation.AnnotationDescription.EnumerationDescription}
+             * {@code enum} values should be handed as {@link net.bytebuddy.description.enumeration.EnumerationDescription}
              * instances, annotations as {@link AnnotationDescription} instances and
              * {@link Class} values as {@link TypeDescription} instances. Other values are handed in their raw format or as their wrapper types.
              *

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -1963,7 +1963,7 @@ public Builder defineTypeArray(String property, Class<?>... type) {
          */
         @SuppressWarnings("unchecked")
         public Builder defineTypeArray(String property, TypeDescription... typeDescription) {
-            return define(property, AnnotationValue.ForComplexArray.<Class>of(typeDescription));
+            return define(property, AnnotationValue.ForComplexArray.of(typeDescription));
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/description/annotation/AnnotationDescription.java
Patch:
@@ -911,7 +911,7 @@ public static <W extends Annotation> AnnotationValue<AnnotationDescription[], W[
             public static AnnotationValue<TypeDescription[], Class<?>[]> of(TypeDescription[] typeDescription) {
                 List<AnnotationValue<TypeDescription, Class<?>>> values = new ArrayList<AnnotationValue<TypeDescription, Class<?>>>(typeDescription.length);
                 for (TypeDescription value : typeDescription) {
-                    values.add((AnnotationValue) ForType.of(value));
+                    values.add((AnnotationValue) ForType.<Class>of(value));
                 }
                 return new ForComplexArray<TypeDescription, Class<?>>(TypeDescription.class, TypeDescription.CLASS, values);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassImplementationTarget.java
Patch:
@@ -131,7 +131,7 @@ public String toString() {
     }
 
     /**
-     * A factory for creating a {@link net.bytebuddy.dynamic.scaffold.subclass.SubclassimplementationTarget}.
+     * A factory for creating a {@link net.bytebuddy.dynamic.scaffold.subclass.SubclassImplementationTarget}.
      */
     public static class Factory implements Implementation.Target.Factory {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -1637,9 +1637,8 @@ public String toString() {
     }
 
     /**
-     * A type description that looks up any referenced {@link ByteCodeElement}s or
-     * {@link AnnotationDescription}s by querying a type pool
-     * at lookup time.
+     * A type description that looks up any referenced {@link net.bytebuddy.description.ByteCodeElement} or
+     * {@link AnnotationDescription} by querying a type pool at lookup time.
      */
     class LazyTypeDescription extends TypeDescription.AbstractTypeDescription.OfSimpleType {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/InliningImplementationMatcher.java
Patch:
@@ -24,7 +24,7 @@ public class InliningImplementationMatcher implements LatentMethodMatcher {
     private final ElementMatcher<? super MethodDescription> predefinedMethodSignatures;
 
     /**
-     * Creates a new inline instrumentation matcher.
+     * Creates a new inline implementation matcher.
      *
      * @param ignoredMethods             A method matcher that matches any ignored method.
      * @param predefinedMethodSignatures A method matcher that matches any predefined method.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/DefaultMethodCall.java
Patch:
@@ -84,12 +84,12 @@ public static Implementation prioritize(TypeDescription... prioritizedInterface)
     }
 
     /**
-     * Creates a {@link net.bytebuddy.implementation.DefaultMethodCall} instrumentation without prioritizing any
+     * Creates a {@link net.bytebuddy.implementation.DefaultMethodCall} implementation without prioritizing any
      * interface. Instead, any interface that is defined for a given type is searched for a suitable default method. If
      * exactly one interface defines a suitable default method, this method is invoked from the instrumented method.
      * Otherwise, an exception is thrown.
      *
-     * @return An instrumentation which calls an instrumented method's compatible default method if such a method
+     * @return An implementation which calls an instrumented method's compatible default method if such a method
      * is unambiguous.
      */
     public static Implementation unambiguousOnly() {

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/Implementation.java
Patch:
@@ -29,11 +29,11 @@
  * implementation is applied in two stages:
  * <ol>
  * <li>The implementation is able to prepare an instrumented type by adding fields and/or helper methods that are
- * required for the methods implemented by this instrumentation. Furthermore,
+ * required for the methods implemented by this implementation. Furthermore,
  * {@link LoadedTypeInitializer}s  and byte code for the type initializer can be registered for the instrumented
  * type.</li>
  * <li>Any implementation is required to supply a byte code appender that is responsible for providing the byte code
- * to the instrumented methods that were delegated to this instrumentation. This byte code appender is also
+ * to the instrumented methods that were delegated to this implementation. This byte code appender is also
  * be responsible for providing implementations for the methods added in step <i>1</i>.</li>
  * </ol>
  * <p>&nbsp;</p>

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvocationHandlerAdapter.java
Patch:
@@ -151,10 +151,10 @@ private List<StackManipulation> argumentValuesOf(MethodDescription instrumentedM
     public abstract AssignerConfigurable withMethodCache();
 
     /**
-     * Applies an instrumentation that delegates to a invocation handler.
+     * Applies an implementation that delegates to a invocation handler.
      *
      * @param methodVisitor         The method visitor for writing the byte code to.
-     * @param implementationContext The implementation context for the current instrumentation.
+     * @param implementationContext The implementation context for the current implementation.
      * @param instrumentedMethod    The method that is instrumented.
      * @param instrumentedType      The type that is instrumented.
      * @param preparingManipulation A stack manipulation that applies any preparation to the operand stack.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/auxiliary/MethodCallProxy.java
Patch:
@@ -343,7 +343,7 @@ protected static class MethodCall implements Implementation {
         private final Assigner assigner;
 
         /**
-         * Creates a new method call instrumentation.
+         * Creates a new method call implementation.
          *
          * @param accessorMethod The method that is accessed by the implemented method.
          * @param assigner       The assigner to be used for invoking the accessor method.

File: byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/FieldProxy.java
Patch:
@@ -357,7 +357,7 @@ protected Implementation access(FieldDescription fieldDescription,
              * @param fieldDescription      The field to be accessed.
              * @param assigner              The assigner to use.
              * @param methodAccessorFactory The accessed type's method accessor factory.
-             * @return A suitable instrumentation.
+             * @return A suitable implementation.
              */
             protected abstract Implementation access(FieldDescription fieldDescription,
                                                      Assigner assigner,

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/AbstractDynamicTypeBuilderForInliningTest.java
Patch:
@@ -83,7 +83,6 @@ public void testParameterMetaDataRetention() throws Exception {
                 .make()
                 .load(new URLClassLoader(new URL[0], null), ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
-        assertThat(dynamicType.getDeclaredMethods().length, is(3));
         Class<?> executable = Class.forName("java.lang.reflect.Executable");
         Method getParameters = executable.getDeclaredMethod("getParameters");
         Class<?> parameter = Class.forName("java.lang.reflect.Parameter");
@@ -101,7 +100,7 @@ public void testParameterMetaDataRetention() throws Exception {
 
     public static class Qux {
 
-        public static String foo;
+        public static final String foo;
 
         public static String bar;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/constant/MethodConstant.java
Patch:
@@ -136,7 +136,7 @@ public int hashCode() {
     /**
      * Represents a method constant that cannot be represented by Java's reflection API.
      */
-    private enum CanCacheIllegal implements CanCache {
+    protected enum CanCacheIllegal implements CanCache {
 
         /**
          * The singleton instance.

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/constant/MethodConstantTest.java
Patch:
@@ -138,6 +138,6 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(MethodConstant.ForMethod.class).apply();
         ObjectPropertyAssertion.of(MethodConstant.ForConstructor.class).apply();
         ObjectPropertyAssertion.of(MethodConstant.Cached.class).apply();
-        ObjectPropertyAssertion.of(MethodConstant.CanCache.Illegal.class).apply();
+        ObjectPropertyAssertion.of(MethodConstant.CanCacheIllegal.class).apply();
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseDynamicTypeBuilder.java
Patch:
@@ -9,7 +9,6 @@
 import net.bytebuddy.dynamic.scaffold.FieldRegistry;
 import net.bytebuddy.dynamic.scaffold.MethodRegistry;
 import net.bytebuddy.dynamic.scaffold.TypeWriter;
-import net.bytebuddy.instrumentation.Instrumentation;
 import net.bytebuddy.instrumentation.attribute.FieldAttributeAppender;
 import net.bytebuddy.instrumentation.attribute.MethodAttributeAppender;
 import net.bytebuddy.instrumentation.attribute.TypeAttributeAppender;
@@ -19,6 +18,7 @@
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.instrumentation.type.auxiliary.AuxiliaryType;
 import net.bytebuddy.matcher.ElementMatcher;
+import net.bytebuddy.matcher.LatentMethodMatcher;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -156,7 +156,7 @@ public DynamicType.Unloaded<T> make() {
         InstrumentedType instrumentedType = new InlineInstrumentedType(classFileVersion, targetType, interfaceTypes, modifiers, namingStrategy);
         MethodRegistry.Prepared preparedMethodRegistry = methodRegistry.prepare(applyRecordedMembersTo(instrumentedType),
                 methodLookupEngineFactory.make(classFileVersion.isSupportsDefaultMethods()),
-                isOverridable().and(not(ignoredMethods)).or(isDeclaredBy(instrumentedType).and(not(anyOf(targetType.getDeclaredMethods())))));
+                InlineInstrumentationMatcher.of(ignoredMethods, targetType));
         MethodRebaseResolver methodRebaseResolver = MethodRebaseResolver.Enabled.make(preparedMethodRegistry.getInstrumentedMethods(),
                 instrumentedType,
                 classFileVersion,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RedefinitionDynamicTypeBuilder.java
Patch:
@@ -19,6 +19,7 @@
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.instrumentation.type.auxiliary.AuxiliaryType;
 import net.bytebuddy.matcher.ElementMatcher;
+import net.bytebuddy.matcher.LatentMethodMatcher;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -145,7 +146,7 @@ public DynamicType.Unloaded<T> make() {
         InstrumentedType instrumentedType = new InlineInstrumentedType(classFileVersion, targetType, interfaceTypes, modifiers, namingStrategy);
         MethodRegistry.Compiled compiledMethodRegistry = methodRegistry.prepare(applyRecordedMembersTo(instrumentedType),
                 methodLookupEngineFactory.make(classFileVersion.isSupportsDefaultMethods()),
-                isOverridable().and(not(ignoredMethods)).or(isDeclaredBy(instrumentedType).and(not(anyOf(targetType.getDeclaredMethods())))))
+                InlineInstrumentationMatcher.of(ignoredMethods, targetType))
                 .compile(new SubclassInstrumentationTarget.Factory(bridgeMethodResolverFactory, SubclassInstrumentationTarget.OriginTypeIdentifier.LEVEL_TYPE));
         return TypeWriter.Default.<T>forRedefinition(compiledMethodRegistry,
                 fieldRegistry.prepare(instrumentedType).compile(TypeWriter.FieldPool.Entry.NoOp.INSTANCE),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategy.java
Patch:
@@ -89,7 +89,7 @@ public MethodList extractConstructors(TypeDescription instrumentedType) {
             @Override
             public MethodRegistry inject(MethodRegistry methodRegistry, MethodAttributeAppender.Factory defaultMethodAttributeAppenderFactory) {
                 return methodRegistry.append(new LatentMethodMatcher.Simple(isConstructor()),
-                        new MethodRegistry.Prepareable.ForInstrumentation(SuperMethodCall.INSTANCE),
+                        new MethodRegistry.Handler.ForInstrumentation(SuperMethodCall.INSTANCE),
                         defaultMethodAttributeAppenderFactory);
             }
         },
@@ -113,7 +113,7 @@ public MethodList extractConstructors(TypeDescription instrumentedType) {
             @Override
             public MethodRegistry inject(MethodRegistry methodRegistry, MethodAttributeAppender.Factory defaultMethodAttributeAppenderFactory) {
                 return methodRegistry.append(new LatentMethodMatcher.Simple(isConstructor()),
-                        new MethodRegistry.Prepareable.ForInstrumentation(SuperMethodCall.INSTANCE),
+                        new MethodRegistry.Handler.ForInstrumentation(SuperMethodCall.INSTANCE),
                         defaultMethodAttributeAppenderFactory);
             }
         },
@@ -135,7 +135,7 @@ public MethodList extractConstructors(TypeDescription instrumentedType) {
             @Override
             public MethodRegistry inject(MethodRegistry methodRegistry, MethodAttributeAppender.Factory defaultMethodAttributeAppenderFactory) {
                 return methodRegistry.append(new LatentMethodMatcher.Simple(isConstructor()),
-                        new MethodRegistry.Prepareable.ForInstrumentation(SuperMethodCall.INSTANCE),
+                        new MethodRegistry.Handler.ForInstrumentation(SuperMethodCall.INSTANCE),
                         defaultMethodAttributeAppenderFactory);
             }
         };

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/FixedValue.java
Patch:
@@ -500,8 +500,7 @@ private class StaticFieldByteCodeAppender implements ByteCodeAppender {
              * @param instrumentedType The instrumented type that is subject of the instrumentation.
              */
             private StaticFieldByteCodeAppender(TypeDescription instrumentedType) {
-                fieldGetAccess = FieldAccess.forField(instrumentedType.getDeclaredFields()
-                        .filter((named(fieldName))).getOnly()).getter();
+                fieldGetAccess = FieldAccess.forField(instrumentedType.getDeclaredFields().filter((named(fieldName))).getOnly()).getter();
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/LatentMethodMatcher.java
Patch:
@@ -5,7 +5,7 @@
 
 public interface LatentMethodMatcher {
 
-    boolean matches(MethodDescription methodDescription, TypeDescription instrumentedType);
+    ElementMatcher<? super MethodDescription> manifest(TypeDescription typeDescription);
 
     class Simple implements LatentMethodMatcher {
 
@@ -16,8 +16,8 @@ public Simple(ElementMatcher<? super MethodDescription> methodMatcher) {
         }
 
         @Override
-        public boolean matches(MethodDescription methodDescription, TypeDescription instrumentedType) {
-            return methodMatcher.matches(methodDescription);
+        public ElementMatcher<? super MethodDescription> manifest(TypeDescription typeDescription) {
+            return methodMatcher;
         }
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/type/AbstractInstrumentedTypeTest.java
Patch:
@@ -160,7 +160,7 @@ public void testWithTypeInitializerSingle() throws Exception {
         instrumentedType = instrumentedType.withInitializer(stackManipulation);
         InstrumentedType.TypeInitializer typeInitializer = instrumentedType.getTypeInitializer();
         assertThat(typeInitializer.isDefined(), is(true));
-        assertThat(typeInitializer.getStackManipulation(), is(stackManipulation));
+//        assertThat(typeInitializer.getStackManipulation(), is(stackManipulation));
     }
 
     @Test
@@ -171,7 +171,7 @@ public void testWithTypeInitializerDouble() throws Exception {
         instrumentedType = instrumentedType.withInitializer(first).withInitializer(second);
         InstrumentedType.TypeInitializer typeInitializer = instrumentedType.getTypeInitializer();
         assertThat(typeInitializer.isDefined(), is(true));
-        assertThat(typeInitializer.getStackManipulation(), is((StackManipulation) new StackManipulation.Compound(first, second)));
+//        assertThat(typeInitializer.getStackManipulation(), is((StackManipulation) new StackManipulation.Compound(first, second)));
     }
 
     @Test

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaMethod.java
Patch:
@@ -51,7 +51,7 @@ public boolean isInvokable() {
 
         @Override
         public Object invoke(Object instance, Object... argument) {
-            throw new IllegalStateException("Java language feature is not available for current virtual machine");
+            throw new IllegalStateException("This feature is not available for current version / configuration of the Java virtual machine");
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaMethod.java
Patch:
@@ -180,7 +180,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return "JavaMethod.ForLoadedMethod{" +
+            return "JavaMethod.ForLoadedConstructor{" +
                     "constructor=" + constructor +
                     '}';
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Origin.java
Patch:
@@ -101,10 +101,10 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                         : MethodConstant.forMethod(source));
             } else if (parameterType.represents(String.class)) {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(new TextConstant(source.getUniqueSignature()));
-            } else if (JavaType.METHOD_HANDLE.representedBy(parameterType)) {
+            } else if (parameterType.equals(JavaType.METHOD_HANDLE.getTypeStub())) {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(MethodHandleConstant.of(source));
-            } else if (JavaType.METHOD_TYPE.representedBy(parameterType)) {
-                return new MethodDelegationBinder.ParameterBinding.Anonymous(new MethodTypeConstant(source));
+            } else if (parameterType.equals(JavaType.METHOD_TYPE.getTypeStub())) {
+                return new MethodDelegationBinder.ParameterBinding.Anonymous(MethodTypeConstant.of(source));
             } else {
                 throw new IllegalStateException("The " + target + " method's " + target.getIndex() +
                         " parameter is annotated with a Origin annotation with an argument not representing a Class" +

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/constant/MethodTypeConstantTest.java
Patch:
@@ -43,7 +43,7 @@ public void setUp() throws Exception {
 
     @Test
     public void testApplication() throws Exception {
-        StackManipulation stackManipulation = new MethodTypeConstant(methodDescription);
+        StackManipulation stackManipulation = MethodTypeConstant.of(methodDescription);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, instrumentationContext);
         assertThat(size.getSizeImpact(), is(1));

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -1349,11 +1349,11 @@ public StackManipulation initializerFor(TypeDescription instrumentedType) {
                                     new TextConstant(Nexus.class.getName()),
                                     MethodInvocation.invoke(loadClass),
                                     new TextConstant("initialize"),
-                                    ArrayFactory.targeting(new TypeDescription.ForLoadedType(Class.class))
-                                            .withValues(Collections.singletonList(ClassConstant.of(new TypeDescription.ForLoadedType(Class.class)))),
+                                    ArrayFactory.targeting(TypeDescription.CLASS)
+                                            .withValues(Collections.singletonList(ClassConstant.of(TypeDescription.CLASS))),
                                     MethodInvocation.invoke(getDeclaredMethod),
                                     NullConstant.INSTANCE,
-                                    ArrayFactory.targeting(new TypeDescription.ForLoadedType(Object.class))
+                                    ArrayFactory.targeting(TypeDescription.OBJECT)
                                             .withValues(Collections.singletonList(ClassConstant.of(instrumentedType))),
                                     MethodInvocation.invoke(invokeMethod),
                                     Removal.SINGLE

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -1619,7 +1619,7 @@ public MethodToken(List<? extends TypeDescription> parameterTypes,
                                    List<? extends TypeDescription> exceptionTypes,
                                    int modifiers) {
                     this(MethodDescription.CONSTRUCTOR_INTERNAL_NAME,
-                            new TypeDescription.ForLoadedType(void.class),
+                            TypeDescription.VOID,
                             parameterTypes,
                             exceptionTypes,
                             modifiers);
@@ -2625,7 +2625,7 @@ protected DynamicType.Builder<S> materialize() {
                     return AbstractBase.this.materialize(classFileVersion,
                             namingStrategy,
                             targetType,
-                            join(interfaceTypes, isInterface(Arrays.asList(interfaceType))),
+                            joinUnique(interfaceTypes, isInterface(Arrays.asList(interfaceType))),
                             modifiers,
                             attributeAppender,
                             ignoredMethods,

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -589,7 +589,7 @@ private TypeInitializerInjection() {
                         injectorProxyMethod = new MethodDescription.Latent(
                                 String.format("%s$%s", TYPE_INITIALIZER_PROXY_PREFIX, RandomString.make()),
                                 instrumentedType,
-                                new TypeDescription.ForLoadedType(void.class),
+                                TypeDescription.VOID,
                                 new TypeList.Empty(),
                                 TYPE_INITIALIZER_PROXY_MODIFIERS,
                                 Collections.<TypeDescription>emptyList());
@@ -700,7 +700,7 @@ public byte[] create(Instrumentation.Context.ExtractableView instrumentationCont
                         instrumentedType.getInternalName(),
                         instrumentedType.getGenericSignature(),
                         (instrumentedType.getSupertype() == null
-                                ? new TypeDescription.ForLoadedType(Object.class)
+                                ? TypeDescription.OBJECT
                                 : instrumentedType.getSupertype()).getInternalName(),
                         instrumentedType.getInterfaces().toInternalNames());
                 attributeAppender.apply(classVisitor, instrumentedType);

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/FixedValue.java
Patch:
@@ -85,14 +85,14 @@ public static Instrumentation nullValue() {
     public static AssignerConfigurable value(Object fixedValue) {
         if (fixedValue == null) {
             return new ForPoolValue(NullConstant.INSTANCE,
-                    new TypeDescription.ForLoadedType(Object.class),
+                    TypeDescription.OBJECT,
                     defaultAssigner(),
                     true);
         }
         Class<?> type = fixedValue.getClass();
         if (type == String.class) {
             return new ForPoolValue(new TextConstant((String) fixedValue),
-                    new TypeDescription.ForLoadedType(String.class),
+                    TypeDescription.STRING,
                     defaultAssigner(),
                     defaultConsiderRuntimeType());
         } else if (type == Boolean.class) {
@@ -155,7 +155,7 @@ public static AssignerConfigurable value(Object fixedValue) {
     public static AssignerConfigurable reference(Object fixedValue) {
         if (fixedValue == null) {
             return new ForPoolValue(NullConstant.INSTANCE,
-                    new TypeDescription.ForLoadedType(Object.class),
+                    TypeDescription.OBJECT,
                     defaultAssigner(),
                     true);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/Instrumentation.java
Patch:
@@ -816,7 +816,7 @@ public MethodDescription registerSetterFor(FieldDescription fieldDescription) {
                             randomString.nextString());
                     accessorMethod = new MethodDescription.Latent(name,
                             instrumentedType,
-                            new TypeDescription.ForLoadedType(void.class),
+                            TypeDescription.VOID,
                             Collections.singletonList(fieldDescription.getFieldType()),
                             resolveModifier(fieldDescription.isStatic()),
                             Collections.<TypeDescription>emptyList());

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/MethodCall.java
Patch:
@@ -1653,7 +1653,7 @@ public StackManipulation resolve(TypeDescription instrumentedType,
                                              boolean dynamicallyTyped) {
                 StackManipulation stackManipulation = new StackManipulation.Compound(
                         new TextConstant(value),
-                        assigner.assign(new TypeDescription.ForLoadedType(String.class), targetType, dynamicallyTyped));
+                        assigner.assign(TypeDescription.STRING, targetType, dynamicallyTyped));
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot assign String value to " + targetType);
                 }
@@ -1711,7 +1711,7 @@ public StackManipulation resolve(TypeDescription instrumentedType,
                                              boolean dynamicallyTyped) {
                 StackManipulation stackManipulation = new StackManipulation.Compound(
                         ClassConstant.of(typeDescription),
-                        assigner.assign(new TypeDescription.ForLoadedType(Class.class), targetType, dynamicallyTyped));
+                        assigner.assign(TypeDescription.CLASS, targetType, dynamicallyTyped));
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot assign Class value to " + targetType);
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Field.java
Patch:
@@ -278,8 +278,7 @@ protected enum StaticFieldConstructor implements Instrumentation {
              * Creates the constructor call singleton.
              */
             StaticFieldConstructor() {
-                objectTypeDefaultConstructor = new TypeDescription.ForLoadedType(Object.class)
-                        .getDeclaredMethods()
+                objectTypeDefaultConstructor = TypeDescription.OBJECT.getDeclaredMethods()
                         .filter(isConstructor())
                         .getOnly();
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Morph.java
Patch:
@@ -493,8 +493,7 @@ protected enum StaticFieldConstructor implements Instrumentation {
                  * Creates the constructor call singleton.
                  */
                 StaticFieldConstructor() {
-                    objectTypeDefaultConstructor = new TypeDescription.ForLoadedType(Object.class)
-                            .getDeclaredMethods()
+                    objectTypeDefaultConstructor = TypeDescription.OBJECT.getDeclaredMethods()
                             .filter(isConstructor())
                             .getOnly();
                 }
@@ -718,7 +717,7 @@ public Size apply(MethodVisitor methodVisitor,
                             parameterLoading[index] = new StackManipulation.Compound(arrayReference,
                                     IntegerConstant.forValue(index),
                                     ArrayAccess.REFERENCE.load(),
-                                    assigner.assign(new TypeDescription.ForLoadedType(Object.class), parameterType, true));
+                                    assigner.assign(TypeDescription.OBJECT, parameterType, true));
                             index++;
                         }
                         StackManipulation.Size stackSize = new StackManipulation.Compound(

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Pipe.java
Patch:
@@ -401,8 +401,7 @@ protected enum ConstructorCall implements Instrumentation {
                  * Creates the constructor call singleton.
                  */
                 ConstructorCall() {
-                    this.objectTypeDefaultConstructor = new TypeDescription.ForLoadedType(Object.class)
-                            .getDeclaredMethods()
+                    this.objectTypeDefaultConstructor = TypeDescription.OBJECT.getDeclaredMethods()
                             .filter(isConstructor())
                             .getOnly();
                 }
@@ -585,7 +584,7 @@ public Size apply(MethodVisitor methodVisitor,
                         }
                         StackManipulation.Size stackSize = new StackManipulation.Compound(
                                 MethodVariableAccess.REFERENCE.loadOffset(1),
-                                assigner.assign(new TypeDescription.ForLoadedType(Object.class), redirectedMethod.getDeclaringType(), true),
+                                assigner.assign(TypeDescription.OBJECT, redirectedMethod.getDeclaringType(), true),
                                 new StackManipulation.Compound(fieldLoading),
                                 MethodInvocation.invoke(redirectedMethod),
                                 assigner.assign(redirectedMethod.getReturnType(), instrumentedMethod.getReturnType(), true),

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/constant/MethodConstant.java
Patch:
@@ -79,7 +79,7 @@ public boolean isValid() {
     @Override
     public Size apply(MethodVisitor methodVisitor, Instrumentation.Context instrumentationContext) {
         Size argumentSize = prepare(methodVisitor)
-                .aggregate(ArrayFactory.targeting(new TypeDescription.ForLoadedType(Class.class))
+                .aggregate(ArrayFactory.targeting(TypeDescription.CLASS)
                         .withValues(typeConstantsFor(methodDescription.getParameters().asTypeList()))
                         .apply(methodVisitor, instrumentationContext));
         methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/member/MethodInvocation.java
Patch:
@@ -248,7 +248,7 @@ public StackManipulation dynamic(String methodName,
                                          TypeDescription returnType,
                                          List<? extends TypeDescription> methodType,
                                          List<?> arguments) {
-            return methodDescription.isBootstrap(arguments)
+            return methodDescription.isBootstrap()
                     ? new DynamicInvocation(methodName, returnType, new TypeList.Explicit(methodType), methodDescription, arguments)
                     : Illegal.INSTANCE;
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/auxiliary/MethodCallProxy.java
Patch:
@@ -242,8 +242,7 @@ protected enum ConstructorCall implements Instrumentation {
          * Creates the constructor call singleton.
          */
         ConstructorCall() {
-            this.objectTypeDefaultConstructor = new TypeDescription.ForLoadedType(Object.class)
-                    .getDeclaredMethods()
+            this.objectTypeDefaultConstructor = TypeDescription.OBJECT.getDeclaredMethods()
                     .filter(isConstructor())
                     .getOnly();
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -181,7 +181,7 @@ public void testFieldsAndMethodsToString() throws Exception {
 
     @Test
     public void testFieldsAndMethodsDetailedMatcher() throws Exception {
-        assertThat(new TypeDescription.ForLoadedType(Object.class)
+        assertThat(TypeDescription.OBJECT
                 .getDeclaredMethods()
                 .filter(named("toString").and(returns(String.class)).and(takesArguments(0))).size(), is(1));
     }
@@ -476,8 +476,7 @@ public StackManipulation assign(TypeDescription sourceType,
                                         TypeDescription targetType,
                                         boolean dynamicallyTyped) {
             if (!sourceType.isPrimitive() && targetType.represents(String.class)) {
-                MethodDescription toStringMethod = new TypeDescription.ForLoadedType(Object.class)
-                        .getDeclaredMethods()
+                MethodDescription toStringMethod = TypeDescription.OBJECT.getDeclaredMethods()
                         .filter(named("toString"))
                         .getOnly();
                 return MethodInvocation.invoke(toStringMethod).virtual(sourceType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/NamingStrategyTest.java
Patch:
@@ -66,7 +66,7 @@ public void testFixedObjectProperties() throws Exception {
 
     @Test
     public void testPrefixingRandom() throws Exception {
-        when(unnamedType.getSuperClass()).thenReturn(new TypeDescription.ForLoadedType(Object.class));
+        when(unnamedType.getSuperClass()).thenReturn(TypeDescription.OBJECT);
         NamingStrategy namingStrategy = new NamingStrategy.PrefixingRandom(FOO);
         assertThat(namingStrategy.name(unnamedType), startsWith(FOO + "." + Object.class.getName()));
         verify(unnamedType).getSuperClass();

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/member/MethodInvocationDynamicTest.java
Patch:
@@ -66,7 +66,7 @@ public void setUp() throws Exception {
 
     @Test
     public void testDynamicStaticBootstrap() throws Exception {
-        when(methodDescription.isBootstrap(Mockito.any(List.class))).thenReturn(true);
+        when(methodDescription.isBootstrap()).thenReturn(true);
         when(methodDescription.isStatic()).thenReturn(true);
         StackManipulation stackManipulation = MethodInvocation.invoke(methodDescription)
                 .dynamic(FOO, returnType, Arrays.asList(firstType, secondType), Collections.singletonList(argument));
@@ -79,7 +79,7 @@ public void testDynamicStaticBootstrap() throws Exception {
 
     @Test
     public void testDynamicConstructorBootstrap() throws Exception {
-        when(methodDescription.isBootstrap(Mockito.any(List.class))).thenReturn(true);
+        when(methodDescription.isBootstrap()).thenReturn(true);
         when(methodDescription.isConstructor()).thenReturn(true);
         StackManipulation stackManipulation = MethodInvocation.invoke(methodDescription)
                 .dynamic(FOO, returnType, Arrays.asList(firstType, secondType), Collections.singletonList(argument));

File: byte-buddy-dep/src/test/java/net/bytebuddy/modifier/TypeManifestationTest.java
Patch:
@@ -26,6 +26,7 @@ public static Collection<Object[]> data() {
                 {TypeManifestation.ABSTRACT, Opcodes.ACC_ABSTRACT},
                 {TypeManifestation.FINAL, Opcodes.ACC_FINAL},
                 {TypeManifestation.INTERFACE, Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT},
+                {TypeManifestation.ANNOTATION, Opcodes.ACC_ANNOTATION | Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT}
         });
     }
 
@@ -35,5 +36,6 @@ public void testProperties() throws Exception {
                 is((expectedModifier & Opcodes.ACC_ABSTRACT) != 0 && (expectedModifier & Opcodes.ACC_INTERFACE) == 0));
         assertThat(((TypeManifestation) modifierContributor).isFinal(), is((expectedModifier & Opcodes.ACC_FINAL) != 0));
         assertThat(((TypeManifestation) modifierContributor).isInterface(), is((expectedModifier & Opcodes.ACC_INTERFACE) != 0));
+        assertThat(((TypeManifestation) modifierContributor).isAnnotation(), is((expectedModifier & Opcodes.ACC_ANNOTATION) != 0));
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/InvokeDynamic.java
Patch:
@@ -2060,7 +2060,7 @@ class ForClassValue implements ArgumentProvider {
                  * @param typeDescription The type to represent.
                  */
                 public ForClassValue(TypeDescription typeDescription) {
-                    this.typeDescription= typeDescription;
+                    this.typeDescription = typeDescription;
                 }
 
                 @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/TypeDescription.java
Patch:
@@ -380,6 +380,7 @@ public boolean isConstantPool() {
                     || represents(float.class)
                     || represents(double.class)
                     || represents(String.class)
+                    || represents(Class.class)
                     || JavaType.METHOD_HANDLE.representedBy(this)
                     || JavaType.METHOD_TYPE.representedBy(this);
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/MethodCallTest.java
Patch:
@@ -453,6 +453,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(MethodCall.ArgumentLoader.ForMethodParameter.class).apply();
         ObjectPropertyAssertion.of(MethodCall.ArgumentLoader.ForShortConstant.class).apply();
         ObjectPropertyAssertion.of(MethodCall.ArgumentLoader.ForTextConstant.class).apply();
+        ObjectPropertyAssertion.of(MethodCall.ArgumentLoader.ForClassConstant.class).apply();
     }
 
     public static class StaticMethod {

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/MethodCallTypeTest.java
Patch:
@@ -30,6 +30,8 @@ public class MethodCallTypeTest extends AbstractInstrumentationTest {
 
     private static final String STRING_VALUE = "foo";
 
+    private static final Class<?> CLASS_VALUE = Object.class;
+
     private static final boolean BOOLEAN_VALUE = true;
 
     private static final byte BYTE_VALUE = 42;
@@ -81,6 +83,7 @@ public static Collection<Object[]> data() {
                 {DOUBLE_VALUE, true, false},
                 {NULL_CONSTANT, false, false},
                 {STRING_VALUE, true, false},
+                {CLASS_VALUE, true, false},
                 {REFERENCE_VALUE, true, true}
         });
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/type/AbstractTypeDescriptionTest.java
Patch:
@@ -372,6 +372,7 @@ public void testConstantPool() throws Exception {
         assertThat(describe(int.class).isConstantPool(), is(true));
         assertThat(describe(Integer.class).isConstantPool(), is(false));
         assertThat(describe(String.class).isConstantPool(), is(true));
+        assertThat(describe(Class.class).isConstantPool(), is(true));
     }
 
     protected interface SampleInterface {

File: byte-buddy-dep/src/test/resources/net/bytebuddy/test/precompiled/ParameterBootstrap.java
Patch:
@@ -31,9 +31,10 @@ public static CallSite bootstrapExplicitArguments(MethodHandles.Lookup lookup,
                                                       long arg5,
                                                       float arg6,
                                                       double arg7,
-                                                      String arg8)
+                                                      String arg8,
+                                                      Class<?> arg9)
             throws NoSuchMethodException, IllegalAccessException {
-        ParameterBootstrap.arguments = new Object[]{arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8};
+        ParameterBootstrap.arguments = new Object[]{arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9};
         return new ConstantCallSite(lookup.findStatic(ParameterBootstrap.class, methodName, methodType));
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/BridgeMethodResolver.java
Patch:
@@ -103,6 +103,7 @@ protected Simple(Map<String, BridgeTarget> bridges) {
          *
          * @param methodList      The relevant methods which can be called in a given context.
          * @param conflictHandler A conflict handler that is queried for handling ambiguous resolutions.
+         * @return A corresponding bridge method resolver.
          */
         public static BridgeMethodResolver of(MethodList methodList, ConflictHandler conflictHandler) {
             MethodList bridgeMethods = methodList.filter(isBridge());

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/FieldAccessor.java
Patch:
@@ -891,6 +891,7 @@ protected FieldDefiner(String name, TypeDescription typeDescription, int modifie
                  * @param name            The name of the field that is defined by this preparation handler.
                  * @param typeDescription The type of the field that is to be defined.
                  * @param contributor     The modifiers of the field that is to be defined.
+                 * @return A corresponding preparation handler.
                  */
                 public static PreparationHandler of(String name, TypeDescription typeDescription, ModifierContributor.ForField... contributor) {
                     return new FieldDefiner(name, typeDescription, resolveModifierContributors(ByteBuddyCommons.FIELD_MODIFIER_MASK, contributor));

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/FieldAttributeAppender.java
Patch:
@@ -2,12 +2,10 @@
 
 import net.bytebuddy.instrumentation.attribute.annotation.AnnotationAppender;
 import net.bytebuddy.instrumentation.attribute.annotation.AnnotationDescription;
-import net.bytebuddy.instrumentation.attribute.annotation.AnnotationList;
 import net.bytebuddy.instrumentation.field.FieldDescription;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import org.objectweb.asm.FieldVisitor;
 
-import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
 import java.util.Arrays;
 import java.util.List;

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/TypeAttributeAppender.java
Patch:
@@ -2,11 +2,9 @@
 
 import net.bytebuddy.instrumentation.attribute.annotation.AnnotationAppender;
 import net.bytebuddy.instrumentation.attribute.annotation.AnnotationDescription;
-import net.bytebuddy.instrumentation.attribute.annotation.AnnotationList;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import org.objectweb.asm.ClassVisitor;
 
-import java.lang.annotation.Annotation;
 import java.util.Arrays;
 import java.util.List;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -329,6 +329,7 @@ protected DelegationProcessor(Map<TypeDescription, ParameterBinder<?>> parameter
          * @param parameterBinders A list of parameter binder delegates. Each such delegate is responsible for creating
          *                         a {@link net.bytebuddy.instrumentation.method.bytecode.bind.MethodDelegationBinder.ParameterBinding}
          *                         for a specific annotation.
+         * @return A corresponding delegation processor.
          */
         protected static DelegationProcessor of(List<ParameterBinder<?>> parameterBinders) {
             Map<TypeDescription, ParameterBinder<?>> parameterBinderMap = new HashMap<TypeDescription, ParameterBinder<?>>();

File: byte-buddy-agent/src/test/java/net/bytebuddy/test/utility/ToolsJarRule.java
Patch:
@@ -36,7 +36,7 @@ public Statement apply(Statement base, FrameworkMethod method, Object target) {
 
     @Retention(RetentionPolicy.RUNTIME)
     @Target(ElementType.METHOD)
-    public static @interface Enforce {
+    public @interface Enforce {
         /* empty */
     }
 

File: byte-buddy-android/src/main/java/net/bytebuddy/android/AndroidClassLoadingStrategy.java
Patch:
@@ -160,7 +160,7 @@ public String toString() {
     /**
      * A dex processor is responsible for converting a collection of Java class files into a Android dex file.
      */
-    public static interface DexProcessor {
+    public interface DexProcessor {
 
         /**
          * Creates a new conversion process which allows to store several Java class files in the created dex
@@ -184,7 +184,7 @@ public static interface DexProcessor {
         /**
          * Represents an ongoing conversion of several Java class files into an Android dex file.
          */
-        static interface Conversion {
+        interface Conversion {
 
             /**
              * Adds a Java class to the generated dex file.
@@ -207,7 +207,7 @@ static interface Conversion {
          * An implementation of a dex processor based on the Android SDK's <i>dx.jar</i> with an API that is
          * compatible to version 1.7.
          */
-        static class ForSdkCompiler implements DexProcessor {
+        class ForSdkCompiler implements DexProcessor {
 
             /**
              * The file name extension of a Java class file.

File: byte-buddy-android/src/test/java/net/bytebuddy/test/utility/DexCompilerRule.java
Patch:
@@ -60,7 +60,7 @@ public Statement apply(Statement base, FrameworkMethod method, Object target) {
 
     @Retention(RetentionPolicy.RUNTIME)
     @Target(ElementType.METHOD)
-    public static @interface Enforce {
+    public @interface Enforce {
         /* empty */
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/ClassVisitorWrapper.java
Patch:
@@ -25,7 +25,7 @@ public interface ClassVisitorWrapper {
     /**
      * An ordered, immutable chain of {@link net.bytebuddy.asm.ClassVisitorWrapper}s.
      */
-    static class Chain implements ClassVisitorWrapper {
+    class Chain implements ClassVisitorWrapper {
 
         /**
          * The class visitor wrappers that are represented by this chain in their order. This list must not be mutated.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategy.java
Patch:
@@ -250,8 +250,7 @@ protected void apply(Instrumentation instrumentation,
          */
         RETRANSFORMATION(false) {
             @Override
-            protected void apply(Instrumentation instrumentation,
-                                 Map<Class<?>, ClassDefinition> classDefinitions) throws UnmodifiableClassException {
+            protected void apply(Instrumentation instrumentation, Map<Class<?>, ClassDefinition> classDefinitions) throws UnmodifiableClassException {
                 ClassRedefinitionTransformer classRedefinitionTransformer = new ClassRedefinitionTransformer(classDefinitions);
                 synchronized (instrumentation) {
                     instrumentation.addTransformer(classRedefinitionTransformer, REDEFINE_CLASSES);

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/ExceptionMethod.java
Patch:
@@ -154,7 +154,7 @@ public String toString() {
     /**
      * A construction delegate is responsible for calling a isThrowable's constructor.
      */
-    public static interface ConstructionDelegate {
+    public interface ConstructionDelegate {
 
         /**
          * Creates a stack manipulation that creates pushes all constructor arguments onto the operand stack
@@ -167,7 +167,7 @@ public static interface ConstructionDelegate {
         /**
          * A construction delegate that calls the default constructor.
          */
-        static class ForDefaultConstructor implements ConstructionDelegate {
+        class ForDefaultConstructor implements ConstructionDelegate {
 
             /**
              * The type of the exception that is to be thrown.
@@ -221,7 +221,7 @@ public String toString() {
         /**
          * A construction delegate that calls a constructor that takes a single string as its argument.
          */
-        static class ForStringConstructor implements ConstructionDelegate {
+        class ForStringConstructor implements ConstructionDelegate {
 
             /**
              * The type of the exception that is to be thrown.

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/FixedValue.java
Patch:
@@ -245,7 +245,7 @@ public int hashCode() {
      * Represents a fixed value instrumentation that is using a default assigner for attempting to assign
      * the fixed value to the return type of the instrumented method.
      */
-    public static interface AssignerConfigurable extends Instrumentation {
+    public interface AssignerConfigurable extends Instrumentation {
 
         /**
          * Defines an explicit assigner to this fixed value instrumentation.

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/InvocationHandlerAdapter.java
Patch:
@@ -205,7 +205,7 @@ public int hashCode() {
      * Allows for the configuration of an {@link net.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner}
      * of an {@link net.bytebuddy.instrumentation.InvocationHandlerAdapter}.
      */
-    protected static interface AssignerConfigurable extends Instrumentation {
+    protected interface AssignerConfigurable extends Instrumentation {
 
         /**
          * Configures an assigner to use with this invocation handler adapter.

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/ModifierReviewable.java
Patch:
@@ -12,7 +12,7 @@ public interface ModifierReviewable {
     /**
      * Representation of the default modifier.
      */
-    static final int EMPTY_MASK = 0;
+    int EMPTY_MASK = 0;
 
     /**
      * Specifies if the modifier described by this object is {@code final}.
@@ -171,7 +171,7 @@ public interface ModifierReviewable {
     /**
      * An abstract base implementation of a {@link net.bytebuddy.instrumentation.ModifierReviewable} class.
      */
-    abstract static class AbstractModifierReviewable implements ModifierReviewable {
+    abstract class AbstractModifierReviewable implements ModifierReviewable {
 
         @Override
         public boolean isAbstract() {

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/NamedElement.java
Patch:
@@ -8,7 +8,7 @@ public interface NamedElement {
     /**
      * Represents an element without a name in the source code.
      */
-    static final String EMPTY_NAME = "";
+    String EMPTY_NAME = "";
 
     /**
      * Returns the internalName of this byte code element.

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/annotation/AnnotationList.java
Patch:
@@ -52,7 +52,7 @@ public interface AnnotationList extends FilterableList<AnnotationDescription, An
     /**
      * Describes an array of loaded {@link java.lang.annotation.Annotation}s as an annotatoon list.
      */
-    static class ForLoadedAnnotation extends AbstractBase<AnnotationDescription, AnnotationList> implements AnnotationList {
+    class ForLoadedAnnotation extends AbstractBase<AnnotationDescription, AnnotationList> implements AnnotationList {
 
         /**
          * The represented annotations.
@@ -143,7 +143,7 @@ protected AnnotationList wrap(List<AnnotationDescription> values) {
     /**
      * Represents a list of explicitly provided annotation descriptions.
      */
-    static class Explicit extends AbstractBase<AnnotationDescription, AnnotationList> implements AnnotationList {
+    class Explicit extends AbstractBase<AnnotationDescription, AnnotationList> implements AnnotationList {
 
         /**
          * The list of represented annotation descriptions.
@@ -234,7 +234,7 @@ protected AnnotationList wrap(List<AnnotationDescription> values) {
     /**
      * Represents an empty annotation list.
      */
-    static class Empty extends FilterableList.Empty<AnnotationDescription, AnnotationList> implements AnnotationList {
+    class Empty extends FilterableList.Empty<AnnotationDescription, AnnotationList> implements AnnotationList {
 
         /**
          * Creates a list of empty annotation lists of the given dimension.

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/field/FieldDescription.java
Patch:
@@ -23,7 +23,7 @@ public interface FieldDescription extends ByteCodeElement {
     /**
      * An abstract base implementation of a field description.
      */
-    abstract static class AbstractFieldDescription extends AbstractModifierReviewable implements FieldDescription {
+    abstract class AbstractFieldDescription extends AbstractModifierReviewable implements FieldDescription {
 
         @Override
         public String getInternalName() {
@@ -81,7 +81,7 @@ public String toString() {
     /**
      * An implementation of a field description for a loaded field.
      */
-    static class ForLoadedField extends AbstractFieldDescription {
+    class ForLoadedField extends AbstractFieldDescription {
 
         /**
          * The represented loaded field.
@@ -132,7 +132,7 @@ public boolean isSynthetic() {
      * A latent field description describes a field that is not attached to a declaring
      * {@link net.bytebuddy.instrumentation.type.TypeDescription}.
      */
-    static class Latent extends AbstractFieldDescription {
+    class Latent extends AbstractFieldDescription {
 
         /**
          * The name of the field.

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/field/FieldList.java
Patch:
@@ -13,7 +13,7 @@ public interface FieldList extends FilterableList<FieldDescription, FieldList> {
     /**
      * An implementation of a field list for an array of loaded fields.
      */
-    static class ForLoadedField extends AbstractBase<FieldDescription, FieldList> implements FieldList {
+    class ForLoadedField extends AbstractBase<FieldDescription, FieldList> implements FieldList {
 
         /**
          * The loaded fields this field list represents.
@@ -48,7 +48,7 @@ protected FieldList wrap(List<FieldDescription> values) {
     /**
      * A wrapper implementation of a field list for a given list of field descriptions.
      */
-    static class Explicit extends AbstractBase<FieldDescription, FieldList> implements FieldList {
+    class Explicit extends AbstractBase<FieldDescription, FieldList> implements FieldList {
 
         /**
          * The list of field descriptions this list represents.
@@ -83,7 +83,7 @@ protected FieldList wrap(List<FieldDescription> values) {
     /**
      * An implementation of an empty field list.
      */
-    static class Empty extends FilterableList.Empty<FieldDescription, FieldList> implements FieldList {
+    class Empty extends FilterableList.Empty<FieldDescription, FieldList> implements FieldList {
 
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/MethodList.java
Patch:
@@ -16,7 +16,7 @@ public interface MethodList extends FilterableList<MethodDescription, MethodList
      * A method list implementation that returns all loaded byte code methods (methods and constructors) that
      * are declared for a given type.
      */
-    static class ForLoadedType extends AbstractBase<MethodDescription, MethodList> implements MethodList {
+    class ForLoadedType extends AbstractBase<MethodDescription, MethodList> implements MethodList {
 
         /**
          * The loaded methods that are represented by this method list.
@@ -73,7 +73,7 @@ protected MethodList wrap(List<MethodDescription> values) {
     /**
      * A method list that is a wrapper for a given list of method descriptions.
      */
-    static class Explicit extends AbstractBase<MethodDescription, MethodList> implements MethodList {
+    class Explicit extends AbstractBase<MethodDescription, MethodList> implements MethodList {
 
         /**
          * The list of methods that is represented by this method list.
@@ -108,7 +108,7 @@ protected MethodList wrap(List<MethodDescription> values) {
     /**
      * An implementation of an empty method list.
      */
-    static class Empty extends FilterableList.Empty<MethodDescription, MethodList> implements MethodList {
+    class Empty extends FilterableList.Empty<MethodDescription, MethodList> implements MethodList {
 
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/ByteCodeAppender.java
Patch:
@@ -44,7 +44,7 @@ Size apply(MethodVisitor methodVisitor,
      * An immutable description of both the operand stack size and the size of the local variable array that is
      * required to run the code generated by this {@code ByteCodeAppender}.
      */
-    static class Size {
+    class Size {
 
         /**
          * The size of the operand stack.
@@ -114,7 +114,7 @@ public String toString() {
     /**
      * A compound appender that combines a given number of other byte code appenders.
      */
-    static class Compound implements ByteCodeAppender {
+    class Compound implements ByteCodeAppender {
 
         /**
          * The byte code appenders that are represented by this compound appender in their application order.
@@ -172,7 +172,7 @@ public String toString() {
      * A simple byte code appender that only represents a given array of
      * {@link net.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation}s.
      */
-    static class Simple implements ByteCodeAppender {
+    class Simple implements ByteCodeAppender {
 
         /**
          * A compound stack manipulation to be applied for this byte code appender.

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/IgnoreForBinding.java
Patch:
@@ -18,7 +18,7 @@
     /**
      * A non-instantiable type that allows to check if a method should be ignored for binding.
      */
-    static final class Verifier {
+    final class Verifier {
 
         /**
          * As this is merely a utility method, the constructor is not supposed to be invoked.

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/RuntimeType.java
Patch:
@@ -26,7 +26,7 @@
     /**
      * A non-instantiable type that allows to check if a method or parameter should consider a runtime type.
      */
-    static final class Verifier {
+    final class Verifier {
 
         /**
          * As this is merely a utility method, the constructor is not supposed to be invoked.

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/PackageDescription.java
Patch:
@@ -19,7 +19,7 @@ public interface PackageDescription extends NamedElement, AnnotatedElement {
     /**
      * An abstract base implementation of a package description.
      */
-    public abstract static class AbstractPackageDescription implements PackageDescription {
+    abstract class AbstractPackageDescription implements PackageDescription {
 
         @Override
         public String getInternalName() {
@@ -51,7 +51,7 @@ public String toString() {
     /**
      * A simple implementation of a package without annotations.
      */
-    public static class Simple extends AbstractPackageDescription {
+    class Simple extends AbstractPackageDescription {
 
         /**
          * The name of the package.
@@ -87,7 +87,7 @@ public boolean isSealed() {
      * Represents a loaded {@link java.lang.Package} wrapped as a
      * {@link net.bytebuddy.instrumentation.type.PackageDescription}.
      */
-    public static class ForLoadedPackage extends AbstractPackageDescription {
+    class ForLoadedPackage extends AbstractPackageDescription {
 
         /**
          * The represented package.

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/TypeDescription.java
Patch:
@@ -257,7 +257,7 @@ public interface TypeDescription extends ByteCodeElement {
     /**
      * An abstract base implementation of a type description.
      */
-    abstract static class AbstractTypeDescription extends AbstractModifierReviewable implements TypeDescription {
+    abstract class AbstractTypeDescription extends AbstractModifierReviewable implements TypeDescription {
 
         /**
          * Collects all interfaces for a given type description.
@@ -520,7 +520,7 @@ public StackSize getStackSize() {
     /**
      * A type description implementation that represents a loaded type.
      */
-    static class ForLoadedType extends AbstractTypeDescription {
+    class ForLoadedType extends AbstractTypeDescription {
 
         /**
          * The loaded type this instance represents.
@@ -705,7 +705,7 @@ public AnnotationList getInheritedAnnotations() {
     /**
      * A projection for an array type based on an existing {@link net.bytebuddy.instrumentation.type.TypeDescription}.
      */
-    static class ArrayProjection extends AbstractTypeDescription {
+    class ArrayProjection extends AbstractTypeDescription {
 
         /**
          * The modifiers of any array type.

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/TypeList.java
Patch:
@@ -29,7 +29,7 @@ public interface TypeList extends FilterableList<TypeDescription, TypeList> {
     /**
      * Implementation of a type list for an array of loaded types.
      */
-    static class ForLoadedType extends AbstractBase<TypeDescription, TypeList> implements TypeList {
+    class ForLoadedType extends AbstractBase<TypeDescription, TypeList> implements TypeList {
 
         /**
          * The loaded types this type list represents.
@@ -88,7 +88,7 @@ protected TypeList wrap(List<TypeDescription> values) {
     /**
      * A wrapper implementation of an explicit list of types.
      */
-    static class Explicit extends AbstractBase<TypeDescription, TypeList> implements TypeList {
+    class Explicit extends AbstractBase<TypeDescription, TypeList> implements TypeList {
 
         /**
          * The list of type descriptions this list represents.
@@ -142,7 +142,7 @@ protected TypeList wrap(List<TypeDescription> values) {
     /**
      * An implementation of an empty type list.
      */
-    static class Empty extends FilterableList.Empty<TypeDescription, TypeList> implements TypeList {
+    class Empty extends FilterableList.Empty<TypeDescription, TypeList> implements TypeList {
 
         @Override
         public String[] toInternalNames() {

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AnnotationTypeMatcher.java
Patch:
@@ -32,7 +32,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && typeMatcher.equals(((AnnotationTypeMatcher) other).typeMatcher);
+                && typeMatcher.equals(((AnnotationTypeMatcher<?>) other).typeMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderHierarchyMatcher.java
Patch:
@@ -37,7 +37,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && classLoaderMatcher.equals(((ClassLoaderHierarchyMatcher) other).classLoaderMatcher);
+                && classLoaderMatcher.equals(((ClassLoaderHierarchyMatcher<?>) other).classLoaderMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionItemMatcher.java
Patch:
@@ -35,7 +35,7 @@ public boolean matches(Iterable<? extends T> target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && elementMatcher.equals(((CollectionItemMatcher) other).elementMatcher);
+                && elementMatcher.equals(((CollectionItemMatcher<?>) other).elementMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/CollectionOneToOneMatcher.java
Patch:
@@ -46,7 +46,7 @@ public boolean matches(Iterable<? extends T> target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && elementMatchers.equals(((CollectionOneToOneMatcher) other).elementMatchers);
+                && elementMatchers.equals(((CollectionOneToOneMatcher<?>) other).elementMatchers);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringAnnotationMatcher.java
Patch:
@@ -32,7 +32,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && annotationMatcher.equals(((DeclaringAnnotationMatcher) other).annotationMatcher);
+                && annotationMatcher.equals(((DeclaringAnnotationMatcher<?>) other).annotationMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringFieldMatcher.java
Patch:
@@ -32,7 +32,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && fieldMatcher.equals(((DeclaringFieldMatcher) other).fieldMatcher);
+                && fieldMatcher.equals(((DeclaringFieldMatcher<?>) other).fieldMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringMethodMatcher.java
Patch:
@@ -32,7 +32,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && methodMatcher.equals(((DeclaringMethodMatcher) other).methodMatcher);
+                && methodMatcher.equals(((DeclaringMethodMatcher<?>) other).methodMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DeclaringTypeMatcher.java
Patch:
@@ -34,7 +34,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && typeMatcher.equals(((DeclaringTypeMatcher) other).typeMatcher);
+                && typeMatcher.equals(((DeclaringTypeMatcher<?>) other).typeMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DescriptorMatcher.java
Patch:
@@ -31,7 +31,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && descriptorMatcher.equals(((DescriptorMatcher) other).descriptorMatcher);
+                && descriptorMatcher.equals(((DescriptorMatcher<?>) other).descriptorMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/FilterableList.java
Patch:
@@ -31,15 +31,15 @@ public interface FilterableList<T, S extends FilterableList<T, S>> extends List<
     T getOnly();
 
     @Override
-    public S subList(int fromIndex, int toIndex);
+    S subList(int fromIndex, int toIndex);
 
     /**
      * An implementation of an empty {@link net.bytebuddy.matcher.FilterableList}.
      *
      * @param <T> The type of the collection's elements.
      * @param <S> The type of this list.
      */
-    static class Empty<T, S extends FilterableList<T, S>> extends AbstractList<T> implements FilterableList<T, S> {
+    class Empty<T, S extends FilterableList<T, S>> extends AbstractList<T> implements FilterableList<T, S> {
 
         @Override
         public T get(int index) {
@@ -81,7 +81,7 @@ public S subList(int fromIndex, int toIndex) {
      * @param <T> The type of the collection's elements.
      * @param <S> The type of this list.
      */
-    abstract static class AbstractBase<T, S extends FilterableList<T, S>> extends AbstractList<T> implements FilterableList<T, S> {
+    abstract class AbstractBase<T, S extends FilterableList<T, S>> extends AbstractList<T> implements FilterableList<T, S> {
 
         @Override
         @SuppressWarnings("unchecked")

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/InheritedAnnotationMatcher.java
Patch:
@@ -32,7 +32,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && annotationMatcher.equals(((InheritedAnnotationMatcher) other).annotationMatcher);
+                && annotationMatcher.equals(((InheritedAnnotationMatcher<?>) other).annotationMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodExceptionTypeMatcher.java
Patch:
@@ -32,7 +32,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && exceptionMatcher.equals(((MethodExceptionTypeMatcher) other).exceptionMatcher);
+                && exceptionMatcher.equals(((MethodExceptionTypeMatcher<?>) other).exceptionMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterMatcher.java
Patch:
@@ -32,7 +32,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && parameterMatcher.equals(((MethodParameterMatcher) other).parameterMatcher);
+                && parameterMatcher.equals(((MethodParameterMatcher<?>) other).parameterMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterTypeMatcher.java
Patch:
@@ -32,7 +32,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && parameterMatcher.equals(((MethodParameterTypeMatcher) other).parameterMatcher);
+                && parameterMatcher.equals(((MethodParameterTypeMatcher<?>) other).parameterMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodReturnTypeMatcher.java
Patch:
@@ -32,7 +32,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && typeMatcher.equals(((MethodReturnTypeMatcher) other).typeMatcher);
+                && typeMatcher.equals(((MethodReturnTypeMatcher<?>) other).typeMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NameMatcher.java
Patch:
@@ -38,7 +38,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && nameMatcher.equals(((NameMatcher) other).nameMatcher);
+                && nameMatcher.equals(((NameMatcher<?>) other).nameMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NegatingMatcher.java
Patch:
@@ -29,7 +29,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && negatedMatcher.equals(((NegatingMatcher) other).negatedMatcher);
+                && negatedMatcher.equals(((NegatingMatcher<?>) other).negatedMatcher);
     }
 
     @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTest.java
Patch:
@@ -194,7 +194,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(ByteBuddy.OptionalMethodInterception.class).apply();
     }
 
-    public static interface Foo {
+    public interface Foo {
         /* empty */
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -39,6 +39,7 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Method;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.concurrent.Callable;
@@ -274,7 +275,7 @@ public void testFieldsAndMethodsMethodDefaultCall() throws Exception {
     public void testFieldsAndMethodsExplicitMethodCall() throws Exception {
         Object object = new ByteBuddy()
                 .subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS)
-                .defineConstructor(Arrays.<Class<?>>asList(int.class), Visibility.PUBLIC)
+                .defineConstructor(Collections.singletonList(int.class), Visibility.PUBLIC)
                 .intercept(MethodCall.invoke(Object.class.getDeclaredConstructor()))
                 .make()
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/test/java/net/bytebuddy/NamingStrategyUnnamedTypeDefaultTest.java
Patch:
@@ -14,8 +14,8 @@
 import org.mockito.Mock;
 import org.mockito.asm.Opcodes;
 
-import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.List;
 
 import static org.hamcrest.CoreMatchers.is;
@@ -38,7 +38,7 @@ public class NamingStrategyUnnamedTypeDefaultTest {
 
     @Before
     public void setUp() throws Exception {
-        interfaceTypes = Arrays.asList(interfaceType);
+        interfaceTypes = Collections.singletonList(interfaceType);
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultApplicationTest.java
Patch:
@@ -91,7 +91,7 @@ public void testAgentSelfInitializationAuxiliaryTypes() throws Exception {
     }
 
     @Retention(RetentionPolicy.RUNTIME)
-    private static @interface ShouldRebase {
+    private @interface ShouldRebase {
 
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -25,8 +25,6 @@
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.nullValue;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Mockito.*;
 
 public class AgentBuilderDefaultTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/asm/ClassVisitorWrapperChainTest.java
Patch:
@@ -9,7 +9,6 @@
 import org.mockito.Mock;
 import org.objectweb.asm.ClassVisitor;
 
-import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.*;
 
 public class ClassVisitorWrapperChainTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassFileLocatorAgentBasedTest.java
Patch:
@@ -14,6 +14,7 @@
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Iterator;
 
 import static org.hamcrest.CoreMatchers.*;
@@ -68,7 +69,7 @@ public void testExtractionOfInflatedMethodAccessor() throws Exception {
     @Test
     public void testExplicitLookup() throws Exception {
         ClassFileLocator.AgentBased.ClassLoadingDelegate fallback = mock(ClassFileLocator.AgentBased.ClassLoadingDelegate.class);
-        ClassFileLocator.AgentBased.ClassLoadingDelegate classLoadingDelegate = new ClassFileLocator.AgentBased.ClassLoadingDelegate.Explicit(fallback, Arrays.<Class<?>>asList(Object.class));
+        ClassFileLocator.AgentBased.ClassLoadingDelegate classLoadingDelegate = new ClassFileLocator.AgentBased.ClassLoadingDelegate.Explicit(fallback, Collections.singletonList(Object.class));
         assertEquals(Object.class, classLoadingDelegate.locate(Object.class.getName()));
         doReturn(String.class).when(fallback).locate(String.class.getName());
         assertEquals(String.class, classLoadingDelegate.locate(String.class.getName()));
@@ -104,7 +105,7 @@ public Field create() {
         ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.ClassLoadingDelegate.Explicit.class).create(new ObjectPropertyAssertion.Creator<Collection<Class<?>>>() {
             @Override
             public Collection<Class<?>> create() {
-                return Arrays.<Class<?>>asList(otherIterator.next());
+                return Collections.<Class<?>>singletonList(otherIterator.next());
             }
         }).apply();
         ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.ExtractionClassFileTransformer.class).applyMutable();

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodRegistryDefaultTest.java
Patch:
@@ -25,7 +25,6 @@
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.not;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.*;
 
 public class MethodRegistryDefaultTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultTest.java
Patch:
@@ -14,7 +14,7 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 
-import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 import static org.hamcrest.CoreMatchers.is;
@@ -51,7 +51,7 @@ public class TypeWriterDefaultTest {
 
     @Before
     public void setUp() throws Exception {
-        explicitAuxiliaryTypes = Arrays.asList(firstAuxiliary);
+        explicitAuxiliaryTypes = Collections.singletonList(firstAuxiliary);
         when(engine.create(any(Instrumentation.Context.ExtractableView.class))).thenReturn(MAIN);
         when(firstAuxiliary.getTypeDescription()).thenReturn(otherAuxiliaryDescription);
         when(firstAuxiliary.getBytes()).thenReturn(FIRST);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterEngineForCreationTest.java
Patch:
@@ -24,7 +24,6 @@
 
 import static org.hamcrest.CoreMatchers.notNullValue;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.*;
 
 public class TypeWriterEngineForCreationTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterEngineForRedefinitionTest.java
Patch:
@@ -34,7 +34,6 @@
 
 import static org.hamcrest.CoreMatchers.notNullValue;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.*;
 
 public class TypeWriterEngineForRedefinitionTest {
@@ -304,7 +303,7 @@ public void testObjectProperties() throws Exception {
     }
 
     @Retention(RetentionPolicy.RUNTIME)
-    public static @interface Bar {
+    public @interface Bar {
         /* empty */
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterMethodPoolEntryTest.java
Patch:
@@ -17,11 +17,10 @@
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.MethodVisitor;
 
-import java.util.Arrays;
+import java.util.Collections;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.*;
 
 public class TypeWriterMethodPoolEntryTest {
@@ -68,7 +67,7 @@ public void setUp() throws Exception {
         when(methodDescription.getAdjustedModifiers(any(Boolean.class))).thenReturn(MODIFIER);
         when(classVisitor.visitMethod(MODIFIER, FOO, BAR, QUX, new String[]{BAZ})).thenReturn(methodVisitor);
         when(first.apply(methodVisitor, instrumentationContext, methodDescription)).thenReturn(new ByteCodeAppender.Size(0, 0));
-        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit(Arrays.asList(parameterDescription)));
+        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit(Collections.singletonList(parameterDescription)));
         when(parameterDescription.getModifiers()).thenReturn(MODIFIER);
         when(parameterDescription.getName()).thenReturn(FOO);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverDefaultTest.java
Patch:
@@ -17,7 +17,7 @@
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
-import java.util.Arrays;
+import java.util.Collections;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -144,7 +144,7 @@ public void testNonIgnoredConstructorIsRebased() throws Exception {
         assertThat(resolution.getResolvedMethod().getInternalName(), is(FOO));
         assertThat(resolution.getResolvedMethod().getModifiers(), is(MethodRebaseResolver.REBASED_METHOD_MODIFIER));
         assertThat(resolution.getResolvedMethod().getDeclaringType(), is(instrumentedType));
-        assertThat(resolution.getResolvedMethod().getParameters(), is(ParameterList.Explicit.latent(resolution.getResolvedMethod(), Arrays.asList(placeholderType))));
+        assertThat(resolution.getResolvedMethod().getParameters(), is(ParameterList.Explicit.latent(resolution.getResolvedMethod(), Collections.singletonList(placeholderType))));
         assertThat(resolution.getResolvedMethod().getReturnType(), is(returnType));
         assertThat(resolution.getAdditionalArguments().isValid(), is(true));
         StackManipulation.Size size = resolution.getAdditionalArguments().apply(methodVisitor, instrumentationContext);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedConstructorTest.java
Patch:
@@ -18,6 +18,7 @@
 import org.objectweb.asm.Opcodes;
 
 import java.util.Arrays;
+import java.util.Collections;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -52,7 +53,7 @@ public void setUp() throws Exception {
         when(methodDescription.getReturnType()).thenReturn(returnType);
         when(parameterType.getStackSize()).thenReturn(StackSize.ZERO);
         when(placeholderType.getStackSize()).thenReturn(StackSize.ZERO);
-        ParameterList parameterList = ParameterList.Explicit.latent(methodDescription, Arrays.asList(parameterType));
+        ParameterList parameterList = ParameterList.Explicit.latent(methodDescription, Collections.singletonList(parameterType));
         when(methodDescription.getParameters()).thenReturn(parameterList);
         when(methodDescription.getInternalName()).thenReturn(FOO);
         when(methodDescription.getDescriptor()).thenReturn(QUX);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedMethodTest.java
Patch:
@@ -16,7 +16,7 @@
 import org.mockito.Mock;
 import org.objectweb.asm.MethodVisitor;
 
-import java.util.Arrays;
+import java.util.Collections;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -58,7 +58,7 @@ public void setUp() throws Exception {
         when(methodNameTransformer.transform(FOO)).thenReturn(QUX);
         when(otherMethodNameTransformer.transform(FOO)).thenReturn(FOO + BAR);
         when(parameterType.getStackSize()).thenReturn(StackSize.ZERO);
-        ParameterList parameterList = ParameterList.Explicit.latent(methodDescription, Arrays.asList(parameterType));
+        ParameterList parameterList = ParameterList.Explicit.latent(methodDescription, Collections.singletonList(parameterType));
         when(methodDescription.getParameters()).thenReturn(parameterList);
     }
 
@@ -70,7 +70,7 @@ public void testPreservation() throws Exception {
         assertThat(resolution.getResolvedMethod().getInternalName(), is(QUX));
         assertThat(resolution.getResolvedMethod().getModifiers(), is(MethodRebaseResolver.REBASED_METHOD_MODIFIER));
         assertThat(resolution.getResolvedMethod().getReturnType(), is(returnType));
-        assertThat(resolution.getResolvedMethod().getParameters(), is(ParameterList.Explicit.latent(resolution.getResolvedMethod(), Arrays.asList(parameterType))));
+        assertThat(resolution.getResolvedMethod().getParameters(), is(ParameterList.Explicit.latent(resolution.getResolvedMethod(), Collections.singletonList(parameterType))));
         StackManipulation.Size size = resolution.getAdditionalArguments().apply(methodVisitor, instrumentationContext);
         assertThat(size.getSizeImpact(), is(0));
         assertThat(size.getMaximalSize(), is(0));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseInstrumentationTargetTest.java
Patch:
@@ -21,7 +21,6 @@
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.*;
 
 public class RebaseInstrumentationTargetTest extends AbstractInstrumentationTargetTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategyDefaultTest.java
Patch:
@@ -18,7 +18,6 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.*;
 
 public class ConstructorStrategyDefaultTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentationTargetTest.java
Patch:
@@ -18,7 +18,6 @@
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Set;
 
@@ -47,7 +46,7 @@ public class SubclassInstrumentationTargetTest extends AbstractInstrumentationTa
     public void setUp() throws Exception {
         when(parameterList.asTypeList()).thenReturn(parameterTypes);
         when(instrumentedType.getSupertype()).thenReturn(superType);
-        when(superType.getDeclaredMethods()).thenReturn(new MethodList.Explicit(Arrays.asList(superMethodConstructor)));
+        when(superType.getDeclaredMethods()).thenReturn(new MethodList.Explicit(Collections.singletonList(superMethodConstructor)));
         when(superType.getInternalName()).thenReturn(BAR);
         when(superMethod.getDeclaringType()).thenReturn(superType);
         when(superType.getStackSize()).thenReturn(StackSize.ZERO);

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/AbstractSpecialMethodInvocationTest.java
Patch:
@@ -12,7 +12,7 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 
-import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 import static org.hamcrest.CoreMatchers.is;
@@ -36,7 +36,7 @@ public abstract class AbstractSpecialMethodInvocationTest {
     @Before
     public void setUp() throws Exception {
         when(parameterType.getStackSize()).thenReturn(StackSize.ZERO);
-        parameterTypes = new TypeList.Explicit(Arrays.asList(parameterType));
+        parameterTypes = new TypeList.Explicit(Collections.singletonList(parameterType));
     }
 
     protected abstract Instrumentation.SpecialMethodInvocation make(String name,
@@ -88,7 +88,7 @@ public void testEquals() throws Exception {
         when(equalMethodButParameter.getReturnType()).thenReturn(returnType);
         TypeDescription parameterType = mock(TypeDescription.class);
         when(parameterType.getStackSize()).thenReturn(StackSize.ZERO);
-        ParameterList equalMethodButParameterParameters = ParameterList.Explicit.latent(equalMethodButParameter, Arrays.asList(parameterType));
+        ParameterList equalMethodButParameterParameters = ParameterList.Explicit.latent(equalMethodButParameter, Collections.singletonList(parameterType));
         when(equalMethodButParameter.getParameters()).thenReturn(equalMethodButParameterParameters);
         assertThat(make(FOO, returnType, parameterTypes, targetType), not(is(equalButParameter)));
         assertThat(make(FOO, returnType, parameterTypes, targetType), not(is(new Object())));

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/DefaultMethodCallTest.java
Patch:
@@ -13,6 +13,7 @@
 
 import java.lang.reflect.Method;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 import static net.bytebuddy.matcher.ElementMatchers.*;
@@ -168,7 +169,7 @@ public void testObjectProperties() throws Exception {
             public List<?> create() {
                 TypeDescription typeDescription = mock(TypeDescription.class);
                 when(typeDescription.isInterface()).thenReturn(true);
-                return Arrays.asList(typeDescription);
+                return Collections.singletonList(typeDescription);
             }
         }).apply();
         final TypeDescription removalType = mock(TypeDescription.class);

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/FieldAccessorPreparationTest.java
Patch:
@@ -11,8 +11,6 @@
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
 import static org.mockito.Mockito.*;
 
 public class FieldAccessorPreparationTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/LoadedTypeInitializerCompoundTest.java
Patch:
@@ -10,7 +10,7 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 
-import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -71,7 +71,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(LoadedTypeInitializer.Compound.class).create(new ObjectPropertyAssertion.Creator<List<?>>() {
             @Override
             public List<?> create() {
-                return Arrays.asList(mock(LoadedTypeInitializer.class));
+                return Collections.singletonList(mock(LoadedTypeInitializer.class));
             }
         }).apply();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/MethodDelegationDefaultTest.java
Patch:
@@ -69,7 +69,7 @@ public void testDefaultInterfaceSerializableProxy() throws Exception {
         assertThat(instance.getClass().getDeclaredMethod(FOO).invoke(instance), is((Object) (FOO + BAR)));
     }
 
-    public static interface DelegationNoDefaultInterface {
+    public interface DelegationNoDefaultInterface {
 
         String foo();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/MethodDelegationSuperTest.java
Patch:
@@ -54,7 +54,7 @@ public void testSerializableProxy() throws Exception {
         assertThat(instance.qux(), is((Object) (FOO + QUX)));
     }
 
-    public static interface Qux {
+    public interface Qux {
 
         Object qux();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/FieldAttributeAppenderForAnnotationTest.java
Patch:
@@ -49,7 +49,7 @@ public void apply(SimpleAnnotation mock) {
         }).apply();
     }
 
-    public static @interface SimpleAnnotation {
+    public @interface SimpleAnnotation {
 
         String value();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/MethodAttributeAppenderForInstrumentedMethodTest.java
Patch:
@@ -8,7 +8,7 @@
 import org.junit.Test;
 import org.mockito.asm.Type;
 
-import java.util.Arrays;
+import java.util.Collections;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -42,7 +42,7 @@ public void testMethodParameterAnnotations() throws Exception {
         ParameterDescription parameterDescription = mock(ParameterDescription.class);
         when(parameterDescription.getDeclaredAnnotations())
                 .thenReturn(new AnnotationList.ForLoadedAnnotation(new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()));
-        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit(Arrays.asList(parameterDescription)));
+        when(methodDescription.getParameters()).thenReturn(new ParameterList.Explicit(Collections.singletonList(parameterDescription)));
         MethodAttributeAppender.ForInstrumentedMethod.INSTANCE.apply(methodVisitor, methodDescription);
         verify(methodVisitor).visitParameterAnnotation(0, Type.getDescriptor(Baz.class), true);
         verify(methodVisitor).visitParameterAnnotation(0, Type.getDescriptor(QuxBaz.class), false);

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/TypeAttributeAppenderForAnnotationTest.java
Patch:
@@ -49,7 +49,7 @@ public void apply(SimpleAnnotation mock) {
         }).apply();
     }
 
-    public static @interface SimpleAnnotation {
+    public @interface SimpleAnnotation {
 
         String value();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/annotation/AbstractAnnotationDescriptionTest.java
Patch:
@@ -385,13 +385,13 @@ private void assertValue(Annotation annotation, String methodName, Object rawVal
                 .invoke(describe(annotation).prepare(annotation.annotationType()).load()), is(loadedValue));
     }
 
-    public static enum SampleEnumeration {
+    public enum SampleEnumeration {
         VALUE,
         OTHER
     }
 
     @Retention(RetentionPolicy.RUNTIME)
-    public static @interface Sample {
+    public @interface Sample {
 
         boolean booleanValue();
 
@@ -445,7 +445,7 @@ public static enum SampleEnumeration {
     }
 
     @Retention(RetentionPolicy.RUNTIME)
-    public static @interface SampleDefault {
+    public @interface SampleDefault {
 
         boolean booleanValue() default BOOLEAN;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/annotation/AbstractEnumerationValueTest.java
Patch:
@@ -95,16 +95,16 @@ public void testIncompatible() throws Exception {
         describe(Sample.FIRST).load(Other.class);
     }
 
-    public static enum Sample {
+    public enum Sample {
         FIRST,
         SECOND
     }
 
-    private static enum Other {
+    private enum Other {
         INSTANCE
     }
 
-    public static @interface Carrier {
+    public @interface Carrier {
 
         Sample value();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/annotation/AnnotationDescriptionForLoadedAnnotationTest.java
Patch:
@@ -42,11 +42,11 @@ public void testInoperational() throws Exception {
     }
 
     @Retention(RetentionPolicy.RUNTIME)
-    private static @interface PrivateAnnotation {
+    private @interface PrivateAnnotation {
 
         String value();
 
-        static enum Defect implements PrivateAnnotation {
+        enum Defect implements PrivateAnnotation {
 
             INSTANCE;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/annotation/AnnotationListForLoadedAnnotationTest.java
Patch:
@@ -82,12 +82,12 @@ public void testSubList() throws Exception {
                 is((AnnotationList) new AnnotationList.ForLoadedAnnotation(foo)));
     }
 
-    private static @interface Foo {
+    private @interface Foo {
 
     }
 
     @Inherited
-    private static @interface Bar {
+    private @interface Bar {
 
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/field/FieldListExplicitTest.java
Patch:
@@ -9,6 +9,7 @@
 import org.mockito.Mock;
 
 import java.util.Arrays;
+import java.util.Collections;
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
@@ -56,6 +57,6 @@ public void testGetOnly() throws Exception {
 
     @Test
     public void testSubList() throws Exception {
-        assertThat(fieldList.subList(0, 1), is((FieldList) new FieldList.Explicit(Arrays.asList(firstFieldDescription))));
+        assertThat(fieldList.subList(0, 1), is((FieldList) new FieldList.Explicit(Collections.singletonList(firstFieldDescription))));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/AbstractMethodDescriptionTest.java
Patch:
@@ -552,7 +552,7 @@ public void testInvokable() throws Exception {
     }
 
     @Retention(RetentionPolicy.RUNTIME)
-    private static @interface SampleAnnotation {
+    private @interface SampleAnnotation {
 
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/MethodListExplicitTest.java
Patch:
@@ -9,6 +9,7 @@
 import org.mockito.Mock;
 
 import java.util.Arrays;
+import java.util.Collections;
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
@@ -54,6 +55,6 @@ public void testGetOnly() throws Exception {
 
     @Test
     public void testSubList() throws Exception {
-        assertThat(methodList.subList(0, 1), is((MethodList) new MethodList.Explicit(Arrays.asList(firstMethodDescription))));
+        assertThat(methodList.subList(0, 1), is((MethodList) new MethodList.Explicit(Collections.singletonList(firstMethodDescription))));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/ParameterListExplicitTest.java
Patch:
@@ -9,6 +9,7 @@
 import org.mockito.Mock;
 
 import java.util.Arrays;
+import java.util.Collections;
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
@@ -54,7 +55,7 @@ public void testGetOnly() throws Exception {
 
     @Test
     public void testSubList() throws Exception {
-        assertThat(parameterList.subList(0, 1), is((ParameterList) new ParameterList.Explicit(Arrays.asList(firstParameterDescription))));
+        assertThat(parameterList.subList(0, 1), is((ParameterList) new ParameterList.Explicit(Collections.singletonList(firstParameterDescription))));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/ParameterListForLoadedExecutableTest.java
Patch:
@@ -49,7 +49,7 @@ public void testSubList() throws Exception {
     }
 
     @Retention(RetentionPolicy.RUNTIME)
-    private static @interface Bar {
+    private @interface Bar {
         /* empty */
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/ArgumentTypeResolverPrimitiveTest.java
Patch:
@@ -14,8 +14,6 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
 import static org.hamcrest.core.IsNot.not;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.argThat;
 import static org.mockito.Mockito.*;
 
 @RunWith(Parameterized.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/MethodDelegationBinderProcessorTest.java
Patch:
@@ -12,6 +12,7 @@
 import org.mockito.Mock;
 
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -160,7 +161,7 @@ public void testThreeBindableTargetsDominantBindableLast() throws Exception {
 
     @Test(expected = IllegalArgumentException.class)
     public void testInvisibleDoesNotBind() throws Exception {
-        List<MethodDescription> methodDescriptions = Arrays.asList(invisibleTarget);
+        List<MethodDescription> methodDescriptions = Collections.singletonList(invisibleTarget);
         MethodDelegationBinder.Processor processor = new MethodDelegationBinder.Processor(methodDelegationBinder, ambiguityResolver);
         processor.process(instrumentationTarget, source, methodDescriptions);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/AbstractAnnotationBinderTest.java
Patch:
@@ -19,8 +19,6 @@
 import java.lang.annotation.Annotation;
 
 import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Mockito.*;
 
 public abstract class AbstractAnnotationBinderTest<T extends Annotation> {

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/ArgumentNextUnboundAsDefaultBinderTest.java
Patch:
@@ -37,7 +37,7 @@ public class ArgumentNextUnboundAsDefaultBinderTest {
     @Mock
     private TypeDescription firstParameter, secondParameter;
 
-    private ParameterList sourceParameters, targetParameters;
+    private ParameterList sourceParameters;
 
     @Mock
     private ParameterDescription firstTargetParameter, secondTargetParameter;
@@ -47,7 +47,7 @@ public void setUp() throws Exception {
         when(firstParameter.getStackSize()).thenReturn(StackSize.ZERO);
         when(secondParameter.getStackSize()).thenReturn(StackSize.ZERO);
         sourceParameters = ParameterList.Explicit.latent(source, Arrays.asList(firstParameter, secondParameter));
-        targetParameters = new ParameterList.Explicit(Arrays.asList(firstTargetParameter, secondTargetParameter));
+        ParameterList targetParameters = new ParameterList.Explicit(Arrays.asList(firstTargetParameter, secondTargetParameter));
         when(source.getParameters()).thenReturn(sourceParameters);
         when(target.getParameters()).thenReturn(targetParameters);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/DefaultCallBinderTest.java
Patch:
@@ -14,7 +14,6 @@
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.*;
 
 public class DefaultCallBinderTest extends AbstractAnnotationBinderTest<DefaultCall> {

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/SuperCallBinderTest.java
Patch:
@@ -10,8 +10,6 @@
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.*;
 
 public class SuperCallBinderTest extends AbstractAnnotationBinderTest<SuperCall> {

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/ThisBinderTest.java
Patch:
@@ -12,8 +12,6 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
 import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Mockito.*;
 
 public class ThisBinderTest extends AbstractAnnotationBinderTest<This> {

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveBoxingDelegateTest.java
Patch:
@@ -22,8 +22,6 @@
 
 import static org.hamcrest.core.Is.is;
 import static org.junit.Assert.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Mockito.*;
 
 @RunWith(Parameterized.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveTypeAwareAssignerBoxingTest.java
Patch:
@@ -17,7 +17,6 @@
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
-import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.*;
 
 @RunWith(Parameterized.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveTypeAwareAssignerImplicitUnboxingTest.java
Patch:
@@ -17,8 +17,6 @@
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Mockito.*;
 
 @RunWith(Parameterized.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveTypeAwareAssignerPrimitiveTest.java
Patch:
@@ -17,7 +17,6 @@
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
-import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.*;
 
 @RunWith(Parameterized.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveTypeAwareAssignerUnboxingTest.java
Patch:
@@ -17,7 +17,6 @@
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
-import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.*;
 
 @RunWith(Parameterized.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveUnboxingDelegateDirectTest.java
Patch:
@@ -23,8 +23,6 @@
 
 import static org.hamcrest.core.Is.is;
 import static org.junit.Assert.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Mockito.*;
 
 @RunWith(Parameterized.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/collection/AbstractArrayFactoryTest.java
Patch:
@@ -14,7 +14,7 @@
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
-import java.util.Arrays;
+import java.util.Collections;
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
@@ -50,7 +50,7 @@ public void tearDown() throws Exception {
     protected void testCreationUsing(Class<?> componentType, int storageOpcode) throws Exception {
         defineComponentType(componentType);
         CollectionFactory arrayFactory = ArrayFactory.targeting(componentTypeDescription);
-        StackManipulation arrayStackManipulation = arrayFactory.withValues(Arrays.asList(stackManipulation));
+        StackManipulation arrayStackManipulation = arrayFactory.withValues(Collections.singletonList(stackManipulation));
         assertThat(arrayStackManipulation.isValid(), is(true));
         verify(stackManipulation, atLeast(1)).isValid();
         StackManipulation.Size size = arrayStackManipulation.apply(methodVisitor, instrumentationContext);

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/collection/ArrayFactoryObjectPropertiesTest.java
Patch:
@@ -10,7 +10,7 @@
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
 
-import java.util.Arrays;
+import java.util.Collections;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -32,7 +32,7 @@ public void testVoidIsIllegal() throws Exception {
     @Test
     public void testIllegalArrayStackManipulation() throws Exception {
         assertThat(ArrayFactory.targeting(new TypeDescription.ForLoadedType(Object.class))
-                .new ArrayStackManipulation(Arrays.<StackManipulation>asList(StackManipulation.Illegal.INSTANCE))
+                .new ArrayStackManipulation(Collections.singletonList(StackManipulation.Illegal.INSTANCE))
                 .isValid(), is(false));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/constant/IntegerConstantTest.java
Patch:
@@ -81,7 +81,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(IntegerConstant.ConstantPool.class).apply();
     }
 
-    private static enum PushType {
+    private enum PushType {
 
         BIPUSH,
         SIPUSH,

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/constant/MethodConstantTest.java
Patch:
@@ -20,7 +20,7 @@
 import org.objectweb.asm.MethodVisitor;
 
 import java.lang.reflect.Method;
-import java.util.Arrays;
+import java.util.Collections;
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
@@ -61,7 +61,7 @@ public void setUp() throws Exception {
         when(methodDescription.getParameters()).thenReturn(parameterList);
         when(parameterList.asTypeList()).thenReturn(typeList);
         when(declaringType.getDescriptor()).thenReturn(BAR);
-        when(typeList.iterator()).thenReturn(Arrays.asList(parameterType).iterator());
+        when(typeList.iterator()).thenReturn(Collections.singletonList(parameterType).iterator());
         when(parameterType.getDescriptor()).thenReturn(QUX);
         when(fieldDescription.getFieldType()).thenReturn(fieldType);
         when(fieldDescription.isStatic()).thenReturn(true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/member/MethodVariableAccessDescriptionTest.java
Patch:
@@ -35,8 +35,6 @@ public class MethodVariableAccessDescriptionTest {
     @Mock
     private TypeDescription declaringType, firstParameterType, secondParameterType;
 
-    private ParameterList parameterList;
-
     @Mock
     private MethodVisitor methodVisitor;
 
@@ -49,7 +47,7 @@ public void setUp() throws Exception {
         when(declaringType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(firstParameterType.getStackSize()).thenReturn(StackSize.SINGLE);
         when(secondParameterType.getStackSize()).thenReturn(StackSize.SINGLE);
-        parameterList = ParameterList.Explicit.latent(methodDescription, Arrays.asList(firstParameterType, secondParameterType));
+        ParameterList parameterList = ParameterList.Explicit.latent(methodDescription, Arrays.asList(firstParameterType, secondParameterType));
         when(methodDescription.getParameters()).thenReturn(parameterList);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/type/TypeListExplicitTest.java
Patch:
@@ -73,7 +73,7 @@ public void testEmptyList() throws Exception {
 
     @Test
     public void testSubList() throws Exception {
-        assertThat(typeList.subList(0, 1), is((TypeList) new TypeList.Explicit(Arrays.asList(firstTypeDescription))));
+        assertThat(typeList.subList(0, 1), is((TypeList) new TypeList.Explicit(Collections.singletonList(firstTypeDescription))));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/type/auxiliary/TypeProxyCreationTest.java
Patch:
@@ -32,7 +32,6 @@
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.*;
 
 public class TypeProxyCreationTest {

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/type/auxiliary/TypeProxyObjectPropertiesTest.java
Patch:
@@ -7,7 +7,7 @@
 import org.junit.Test;
 import org.mockito.Mockito;
 
-import java.util.Arrays;
+import java.util.Collections;
 
 import static org.mockito.Mockito.when;
 
@@ -24,7 +24,7 @@ public void testObjectProperties() throws Exception {
             public void apply(TypeDescription mock) {
                 FieldDescription fieldDescription = Mockito.mock(FieldDescription.class);
                 when(fieldDescription.getSourceCodeName()).thenReturn(TypeProxy.INSTANCE_FIELD);
-                when(mock.getDeclaredFields()).thenReturn(new FieldList.Explicit(Arrays.asList(fieldDescription)));
+                when(mock.getDeclaredFields()).thenReturn(new FieldList.Explicit(Collections.singletonList(fieldDescription)));
             }
         }).skipSynthetic().apply();
         ObjectPropertyAssertion.of(TypeProxy.MethodCall.Appender.AccessorMethodInvocation.class).skipSynthetic().apply();

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/CollectionOneToOneMatcherTest.java
Patch:
@@ -6,6 +6,7 @@
 import org.mockito.Mock;
 
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 import static org.hamcrest.CoreMatchers.is;
@@ -70,7 +71,7 @@ public void testNoMatchSecond() throws Exception {
     @Test
     @SuppressWarnings("unchecked")
     public void testNoMatchSize() throws Exception {
-        assertThat(new CollectionOneToOneMatcher<Object>(Arrays.asList(firstMatcher, secondMatcher)).matches(Arrays.asList(firstMatcher)), is(false));
+        assertThat(new CollectionOneToOneMatcher<Object>(Arrays.asList(firstMatcher, secondMatcher)).matches(Collections.singletonList(firstMatcher)), is(false));
         verifyZeroInteractions(firstMatcher);
         verifyZeroInteractions(secondMatcher);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/ElementMatchersTest.java
Patch:
@@ -833,13 +833,13 @@ public void testConstructorIsHidden() throws Exception {
     }
 
     @Retention(RetentionPolicy.RUNTIME)
-    private static @interface IsAnnotatedWithAnnotation {
+    private @interface IsAnnotatedWithAnnotation {
 
     }
 
     @Inherited
     @Retention(RetentionPolicy.RUNTIME)
-    public static @interface OtherAnnotation {
+    public @interface OtherAnnotation {
 
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/MethodSortMatcherTest.java
Patch:
@@ -71,7 +71,7 @@ public void testToString() throws Exception {
         assertThat(new MethodSortMatcher<MethodDescription>(sort).toString(), is(sort.getDescription()));
     }
 
-    private static enum MockEngine {
+    private enum MockEngine {
 
         CONSTRUCTOR {
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyAnnotationInvocationHandlerTest.java
Patch:
@@ -243,16 +243,16 @@ public void testEqualsToInvocationExceptionIsFalse() throws Throwable {
         verify(loadedAnnotationValue).resolve();
     }
 
-    public static enum Bar {
+    public enum Bar {
         VALUE
     }
 
-    public static @interface Foo {
+    public @interface Foo {
 
         String foo();
     }
 
-    public static @interface DefaultFoo {
+    public @interface DefaultFoo {
 
         String foo() default FOO;
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyDeclarationContextTest.java
Patch:
@@ -5,7 +5,7 @@
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import org.junit.Test;
 
-import java.util.Arrays;
+import java.util.Collections;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.nullValue;
@@ -91,7 +91,7 @@ public void testDeclaredInMethodGetMethodIsNull() throws Exception {
         TypeDescription typeDescription = mock(TypeDescription.class);
         TypePool typePool = mock(TypePool.class);
         when(typePool.describe(FOO)).thenReturn(new TypePool.Resolution.Simple(typeDescription));
-        when(typeDescription.getDeclaredMethods()).thenReturn(new MethodList.Explicit(Arrays.asList(methodDescription)));
+        when(typeDescription.getDeclaredMethods()).thenReturn(new MethodList.Explicit(Collections.singletonList(methodDescription)));
         assertThat(new TypePool.LazyTypeDescription.DeclarationContext.DeclaredInMethod(FOO_INTERNAL, BAR, QUX)
                 .getEnclosingMethod(typePool), is(methodDescription));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyFieldListTest.java
Patch:
@@ -6,7 +6,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Arrays;
+import java.util.Collections;
 
 import static net.bytebuddy.matcher.ElementMatchers.named;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -49,7 +49,7 @@ public void testNamedIllegal() throws Exception {
 
     @Test
     public void testSubList() throws Exception {
-        assertThat(fieldList.subList(0, 1), is((FieldList) new FieldList.Explicit(Arrays.asList(fieldList.get(0)))));
+        assertThat(fieldList.subList(0, 1), is((FieldList) new FieldList.Explicit(Collections.singletonList(fieldList.get(0)))));
     }
 
     @Test(expected = IndexOutOfBoundsException.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyMethodListTest.java
Patch:
@@ -7,7 +7,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Arrays;
+import java.util.Collections;
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
@@ -56,7 +56,7 @@ public void testGetOnly() throws Exception {
 
     @Test
     public void testSubList() throws Exception {
-        assertThat(methodList.subList(0, 1), is((MethodList) new MethodList.Explicit(Arrays.asList(methodList.get(0)))));
+        assertThat(methodList.subList(0, 1), is((MethodList) new MethodList.Explicit(Collections.singletonList(methodList.get(0)))));
     }
 
     @Test(expected = IndexOutOfBoundsException.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/JavaVersionRule.java
Patch:
@@ -29,7 +29,7 @@ public Statement apply(Statement base, FrameworkMethod method, Object target) {
 
     @Retention(RetentionPolicy.RUNTIME)
     @Target(ElementType.METHOD)
-    public static @interface Enforce {
+    public @interface Enforce {
 
         int value();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/test/utility/ToolsJarRule.java
Patch:
@@ -36,7 +36,7 @@ public Statement apply(Statement base, FrameworkMethod method, Object target) {
 
     @Retention(RetentionPolicy.RUNTIME)
     @Target(ElementType.METHOD)
-    public static @interface Enforce {
+    public @interface Enforce {
         /* empty */
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/BridgeMethodResolver.java
Patch:
@@ -90,8 +90,9 @@ class Simple implements BridgeMethodResolver {
         private final Map<String, BridgeTarget> bridges;
 
         /**
-         * Creates a new simple bridge method resolver
-         * @param bridges  A map of all bridges mapped by their unique signature.
+         * Creates a new simple bridge method resolver.
+         *
+         * @param bridges A map of all bridges mapped by their unique signature.
          */
         protected Simple(Map<String, BridgeTarget> bridges) {
             this.bridges = bridges;

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/annotation/package-info.java
Patch:
@@ -1,5 +1,5 @@
 /**
- *  Types and classes in this package are responsible for writing Java annotations to a Java type, field or byte code
- *  method. In this context, annotations are nothing more than a specific type of class file attribute.
+ * Types and classes in this package are responsible for writing Java annotations to a Java type, field or byte code
+ * method. In this context, annotations are nothing more than a specific type of class file attribute.
  */
 package net.bytebuddy.instrumentation.attribute.annotation;

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -773,7 +773,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> hasParame
 
     /**
      * Matches a {@link net.bytebuddy.instrumentation.method.MethodDescription} by validating that its parameters
-     * fulfill a given constraint
+     * fulfill a given constraint.
      *
      * @param matcher The matcher to apply for validating the parameters.
      * @param <T>     The type of the matched object.

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategy.java
Patch:
@@ -122,7 +122,7 @@ public MethodRegistry inject(MethodRegistry methodRegistry,
                 case DEFAULT_CONSTRUCTOR:
                 case IMITATE_SUPER_TYPE:
                 case IMITATE_SUPER_TYPE_PUBLIC:
-                    return methodRegistry.prepend(new MethodRegistry.LatentMethodMatcher.Simple(isConstructor()),
+                    return methodRegistry.append(new MethodRegistry.LatentMethodMatcher.Simple(isConstructor()),
                             SuperMethodCall.INSTANCE,
                             defaultMethodAttributeAppenderFactory);
                 default:

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/AbstractInstrumentationTest.java
Patch:
@@ -61,7 +61,7 @@ protected <T> DynamicType.Loaded<T> instrument(Class<T> target,
                 FieldAttributeAppender.NoOp.INSTANCE,
                 MethodAttributeAppender.NoOp.INSTANCE,
                 ConstructorStrategy.Default.IMITATE_SUPER_TYPE)
-                .method(targetMethods).intercept(instrumentation)
+                .invokable(targetMethods).intercept(instrumentation)
                 .make()
                 .load(classLoader, ClassLoadingStrategy.Default.WRAPPER);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/type/AbstractTypeDescriptionTest.java
Patch:
@@ -27,6 +27,7 @@ public abstract class AbstractTypeDescriptionTest {
 
     private static final String FOO = "foo", BAR = "bar";
 
+    @SuppressWarnings("unchecked")
     private static final List<Class<?>> TYPES = Arrays.asList(Object.class,
             SampleClass.class,
             void.class,

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -123,7 +123,7 @@ public void testSuccessful() throws Exception {
                 .installOn(instrumentation);
         assertThat(instrumentations.size(), is(1));
         assertThat(instrumentations.get(0).transform(classLoader, FOO, REDEFINED, protectionDomain, QUX), is(BAZ));
-        verify(listener).onTransformation(unloaded);
+        verify(listener).onTransformation(typeDescription, unloaded);
         verify(listener).onComplete(FOO);
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
@@ -144,7 +144,7 @@ public void testSuccessfulWithRetransformation() throws Exception {
                 .installOn(instrumentation);
         assertThat(instrumentations.size(), is(1));
         assertThat(instrumentations.get(0).transform(classLoader, FOO, REDEFINED, protectionDomain, QUX), is(BAZ));
-        verify(listener).onTransformation(unloaded);
+        verify(listener).onTransformation(typeDescription, unloaded);
         verify(listener).onComplete(FOO);
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaTypeTest.java
Patch:
@@ -61,6 +61,7 @@ public void testLoading() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("unchecked")
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(JavaType.TypeLookup.ForNamedType.class).apply();
         final Iterator<Class<?>> iterator = Arrays.asList(Object.class, String.class).iterator();

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/DefaultMethodCall.java
Patch:
@@ -182,7 +182,7 @@ public boolean appendsCode() {
         public Size apply(MethodVisitor methodVisitor, Context instrumentationContext, MethodDescription instrumentedMethod) {
             StackManipulation defaultMethodInvocation = locateDefault(instrumentedMethod);
             if (!defaultMethodInvocation.isValid()) {
-                throw new IllegalArgumentException("Cannot invoke default method on " + instrumentedMethod);
+                throw new IllegalStateException("Cannot invoke default method on " + instrumentedMethod);
             }
             StackManipulation.Size stackSize = new StackManipulation.Compound(
                     MethodVariableAccess.loadThisReferenceAndArguments(instrumentedMethod),
@@ -211,7 +211,7 @@ private StackManipulation locateDefault(MethodDescription methodDescription) {
             for (TypeDescription typeDescription : nonPrioritizedInterfaces) {
                 SpecialMethodInvocation other = instrumentationTarget.invokeDefault(typeDescription, uniqueMethodSignature);
                 if (specialMethodInvocation.isValid() && other.isValid()) {
-                    throw new IllegalArgumentException(methodDescription + " has an ambiguous default method with "
+                    throw new IllegalStateException(methodDescription + " has an ambiguous default method with "
                             + other.getMethodDescription() + " and " + specialMethodInvocation.getMethodDescription());
                 }
                 specialMethodInvocation = other;

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/MethodDescription.java
Patch:
@@ -313,7 +313,7 @@ public boolean isDefaultMethod() {
         public boolean isSpecializableFor(TypeDescription targetType) {
             if (isStatic()) { // Static private methods are never specializable, check static property first
                 return false;
-            } else if (isPrivate() || isConstructor() || isDefaultMethod()) {
+            } else if (isPrivate() || isConstructor()) {
                 return getDeclaringType().equals(targetType);
             } else {
                 return !isAbstract() && getDeclaringType().isAssignableFrom(targetType);

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -142,7 +142,7 @@ public boolean isResolved() {
 
             @Override
             public TypeDescription resolve() {
-                throw new IllegalStateException("Cannot resolve type for " + name);
+                throw new IllegalStateException("Cannot resolve type description for " + name);
             }
 
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -53,7 +53,7 @@ public class ByteBuddyTutorialExamplesTest {
     private static final String CONFLICTING_DEFAULT_METHOD_INTERFACE = "net.bytebuddy.test.precompiled.SingleDefaultMethodConflictingInterface";
 
     @Rule
-    public MethodRule java8Rule = new JavaVersionRule(8);
+    public MethodRule javaVersionRule = new JavaVersionRule();
 
     @Rule
     public MethodRule toolsJarRule = new ToolsJarRule();
@@ -154,7 +154,7 @@ public void testTutorialGettingStartedTypePool() throws Exception {
     public void testTutorialGettingStartedJavaAgent() throws Exception {
         new AgentBuilder.Default().rebase(isAnnotatedWith(Rebase.class)).transform(new AgentBuilder.Transformer() {
             @Override
-            public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder) {
+            public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription) {
                 return builder.method(named("toString")).intercept(FixedValue.value("transformed"));
             }
         }).installOn(mock(java.lang.instrument.Instrumentation.class));
@@ -248,7 +248,7 @@ public void testFieldsAndMethodsMethodSuperCallExplicit() throws Exception {
     }
 
     @Test
-    @JavaVersionRule.Enforce
+    @JavaVersionRule.Enforce(8)
     public void testFieldsAndMethodMethodDefaultCall() throws Exception {
         // This test differs from the tutorial by only conditionally expressing the Java 8 types.
         ClassLoader classLoader = new PrecompiledTypeClassLoader(getClass().getClassLoader());

File: byte-buddy-dep/src/test/java/net/bytebuddy/Java8DefaultMethodDiscoveryTest.java
Patch:
@@ -25,7 +25,7 @@ public class Java8DefaultMethodDiscoveryTest {
     private static final String INTERFACE_STATIC_FIELD_NAME = "FOO";
 
     @Rule
-    public MethodRule java8Rule = new JavaVersionRule(8);
+    public MethodRule javaVersionRule = new JavaVersionRule();
 
     private ClassLoader classLoader;
     private Object interfaceMarker;
@@ -41,7 +41,7 @@ public void setUp() throws Exception {
     }
 
     @Test
-    @JavaVersionRule.Enforce
+    @JavaVersionRule.Enforce(8)
     public void testDefaultMethodNonOverridden() throws Exception {
         Class<?> dynamicType = new ByteBuddy()
                 .subclass(interfaceType)
@@ -54,7 +54,7 @@ public void testDefaultMethodNonOverridden() throws Exception {
     }
 
     @Test
-    @JavaVersionRule.Enforce
+    @JavaVersionRule.Enforce(8)
     public void testDefaultMethodOverridden() throws Exception {
         Class<?> dynamicType = new ByteBuddy()
                 .subclass(interfaceType)

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -104,7 +104,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         Map<TypeDescription, LoadedTypeInitializer> loadedTypeInitializers = new HashMap<TypeDescription, LoadedTypeInitializer>();
         loadedTypeInitializers.put(typeDescription, loadedTypeInitializer);
         when(unloaded.getLoadedTypeInitializers()).thenReturn(loadedTypeInitializers);
-        when(transformer.transform(builder)).thenReturn((DynamicType.Builder) builder);
+        when(transformer.transform(builder, typeDescription)).thenReturn((DynamicType.Builder) builder);
         when(binaryLocator.initialize(FOO, QUX, classLoader)).thenReturn(initialized);
         when(initialized.getTypePool()).thenReturn(typePool);
         when(typePool.describe(FOO)).thenReturn(resolution);
@@ -205,7 +205,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.class)
                 .apply(new AgentBuilder.Default().new ExecutingTransformer());
         ObjectPropertyAssertion.of(AgentBuilder.Default.InitializationStrategy.SelfInjection.class).apply();
-        final Iterator<Class<?>> iterator = Arrays.<Class<?>>asList(Object.class, AgentBuilderDefaultTest.class).iterator();
+        final Iterator<Class<?>> iterator = Arrays.asList(Object.class, AgentBuilderDefaultTest.class).iterator();
         ObjectPropertyAssertion.of(AgentBuilder.Default.InitializationStrategy.SelfInjection.Nexus.class).create(new ObjectPropertyAssertion.Creator<Class<?>>() {
             @Override
             public Class<?> create() {

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/MethodCallTest.java
Patch:
@@ -40,7 +40,7 @@ public class MethodCallTest extends AbstractInstrumentationTest {
     public TestRule methodRule = new MockitoRule(this);
 
     @Rule
-    public MethodRule javaVersionRule = new JavaVersionRule(8);
+    public MethodRule javaVersionRule = new JavaVersionRule();
 
     @Mock
     private Assigner nonAssigner;
@@ -360,7 +360,7 @@ public void testWithFieldTarget() throws Exception {
     }
 
     @Test
-    @JavaVersionRule.Enforce
+    @JavaVersionRule.Enforce(8)
     public void testDefaultMethod() throws Exception {
         DynamicType.Loaded<?> loaded = instrument(Object.class,
                 MethodCall.invoke(classLoader.loadClass(SINGLE_DEFAULT_METHOD).getDeclaredMethod(FOO)).onDefault(),

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/MethodDelegationMorphTest.java
Patch:
@@ -32,7 +32,7 @@ public class MethodDelegationMorphTest extends AbstractInstrumentationTest {
     private static final String DEFAULT_INTERFACE_TARGET_IMPLICIT = "net.bytebuddy.test.precompiled.MorphDefaultDelegationTargetImplicit";
 
     @Rule
-    public MethodRule java8Rule = new JavaVersionRule(8);
+    public MethodRule javaVersionRule = new JavaVersionRule();
 
     private ClassLoader classLoader;
 
@@ -116,7 +116,7 @@ public void testPipeTypeIsNotInterfaceThrowsException() throws Exception {
     }
 
     @Test
-    @JavaVersionRule.Enforce
+    @JavaVersionRule.Enforce(8)
     public void testDefaultMethodExplicit() throws Exception {
         DynamicType.Loaded<?> loaded = instrument(Object.class,
                 MethodDelegation.to(classLoader.loadClass(DEFAULT_INTERFACE_TARGET_EXPLICIT))
@@ -130,7 +130,7 @@ public void testDefaultMethodExplicit() throws Exception {
     }
 
     @Test
-    @JavaVersionRule.Enforce
+    @JavaVersionRule.Enforce(8)
     public void testDefaultMethodImplicit() throws Exception {
         DynamicType.Loaded<?> loaded = instrument(Object.class,
                 MethodDelegation.to(classLoader.loadClass(DEFAULT_INTERFACE_TARGET_IMPLICIT))

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/MethodDelegationOriginTest.java
Patch:
@@ -24,7 +24,7 @@ public class MethodDelegationOriginTest extends AbstractInstrumentationTest {
     private static final String ORIGIN_METHOD_HANDLE = "net.bytebuddy.test.precompiled.OriginMethodHandle";
     private static final String ORIGIN_METHOD_TYPE = "net.bytebuddy.test.precompiled.OriginMethodType";
     @Rule
-    public MethodRule java7Rule = new JavaVersionRule(7);
+    public MethodRule javaVersionRule = new JavaVersionRule();
     private ClassLoader classLoader;
 
     @Before
@@ -70,7 +70,7 @@ public void testOriginString() throws Exception {
     }
 
     @Test
-    @JavaVersionRule.Enforce
+    @JavaVersionRule.Enforce(7)
     public void testOriginMethodHandle() throws Throwable {
         Class<?> originMethodHandle = classLoader.loadClass(ORIGIN_METHOD_HANDLE);
         DynamicType.Loaded<Foo> loaded = instrument(Foo.class, MethodDelegation.to(originMethodHandle));
@@ -79,7 +79,7 @@ public void testOriginMethodHandle() throws Throwable {
     }
 
     @Test
-    @JavaVersionRule.Enforce
+    @JavaVersionRule.Enforce(7)
     public void testOriginMethodType() throws Throwable {
         Class<?> originMethodType = classLoader.loadClass(ORIGIN_METHOD_TYPE);
         DynamicType.Loaded<Foo> loaded = instrument(Foo.class, MethodDelegation.to(originMethodType));

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/OriginBinderTest.java
Patch:
@@ -23,7 +23,7 @@ public class OriginBinderTest extends AbstractAnnotationBinderTest<Origin> {
     private static final int INDEX = 0;
 
     @Rule
-    public MethodRule javaVersionRule = new JavaVersionRule(7);
+    public MethodRule javaVersionRule = new JavaVersionRule();
 
     @Mock
     private TypeDescription targetType;
@@ -73,7 +73,7 @@ public void testStringBinding() throws Exception {
     }
 
     @Test
-    @JavaVersionRule.Enforce
+    @JavaVersionRule.Enforce(7)
     public void testMethodHandleBinding() throws Exception {
         targetType = new TypeDescription.ForLoadedType(JavaType.METHOD_HANDLE.load());
         when(targetTypeList.get(INDEX)).thenReturn(targetType);
@@ -84,7 +84,7 @@ public void testMethodHandleBinding() throws Exception {
     }
 
     @Test
-    @JavaVersionRule.Enforce
+    @JavaVersionRule.Enforce(7)
     public void testMethodTypeBinding() throws Exception {
         targetType = new TypeDescription.ForLoadedType(JavaType.METHOD_TYPE.load());
         when(targetTypeList.get(INDEX)).thenReturn(targetType);

File: byte-buddy-dep/src/test/java/net/bytebuddy/matcher/ElementMatchersTest.java
Patch:
@@ -38,7 +38,7 @@ public class ElementMatchersTest {
     private static final String SINGLE_DEFAULT_METHOD = "net.bytebuddy.test.precompiled.SingleDefaultMethodInterface";
 
     @Rule
-    public MethodRule java8Rule = new JavaVersionRule(8);
+    public MethodRule javaVersionRule = new JavaVersionRule();
 
     private ClassLoader classLoader;
 
@@ -526,7 +526,7 @@ public void testSortIsConstructor() throws Exception {
     }
 
     @Test
-    @JavaVersionRule.Enforce
+    @JavaVersionRule.Enforce(8)
     public void testIsDefaultMethod() throws Exception {
         assertThat(ElementMatchers.isDefaultMethod().matches(new MethodDescription.ForLoadedMethod(
                 classLoader.loadClass(SINGLE_DEFAULT_METHOD).getDeclaredMethod(FOO))), is(true));

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaTypeTest.java
Patch:
@@ -17,7 +17,7 @@
 public class JavaTypeTest {
 
     @Rule
-    public MethodRule javaVersionRule = new JavaVersionRule(7);
+    public MethodRule javaVersionRule = new JavaVersionRule();
 
     @Test
     public void testIsAssignableTo() throws Exception {
@@ -52,7 +52,7 @@ public void testRepresents() throws Exception {
     }
 
     @Test
-    @JavaVersionRule.Enforce
+    @JavaVersionRule.Enforce(7)
     public void testLoading() throws Exception {
         JavaType.METHOD_HANDLE.load();
         JavaType.METHOD_TYPE.load();
@@ -63,7 +63,7 @@ public void testLoading() throws Exception {
     @Test
     public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(JavaType.TypeLookup.ForNamedType.class).apply();
-        final Iterator<Class<?>> iterator = Arrays.<Class<?>>asList(Object.class, String.class).iterator();
+        final Iterator<Class<?>> iterator = Arrays.asList(Object.class, String.class).iterator();
         ObjectPropertyAssertion.of(JavaType.TypeLookup.ForLoadedType.class).create(new ObjectPropertyAssertion.Creator<Class<?>>() {
             @Override
             public Class<?> create() {

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/TypeDescription.java
Patch:
@@ -10,7 +10,6 @@
 import net.bytebuddy.utility.JavaType;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
-import org.objectweb.asm.signature.SignatureWriter;
 
 import java.io.Serializable;
 import java.lang.reflect.Constructor;

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/OriginBinderTest.java
Patch:
@@ -96,7 +96,7 @@ public void testMethodTypeBinding() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testIllegalBinding() throws Exception {
-        when(targetType.getInternalName()).thenReturn(FOO);
+        when(targetType.getName()).thenReturn(FOO);
         Origin.Binder.INSTANCE.bind(annotationDescription, INDEX, source, target, instrumentationTarget, assigner);
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Origin.java
Patch:
@@ -7,6 +7,7 @@
 import net.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import net.bytebuddy.instrumentation.method.bytecode.stack.constant.*;
 import net.bytebuddy.instrumentation.type.TypeDescription;
+import net.bytebuddy.utility.JavaType;
 
 import java.lang.annotation.*;
 import java.lang.reflect.Method;
@@ -100,9 +101,9 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
                         : MethodConstant.forMethod(source));
             } else if (parameterType.represents(String.class)) {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(new TextConstant(source.getUniqueSignature()));
-            } else if (MethodHandleConstant.isRepresentedBy(parameterType)) {
+            } else if (JavaType.METHOD_HANDLE.representedBy(parameterType)) {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(MethodHandleConstant.of(source));
-            } else if (MethodTypeConstant.isRepresentedBy(parameterType)) {
+            } else if (JavaType.METHOD_TYPE.representedBy(parameterType)) {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(new MethodTypeConstant(source));
             } else {
                 throw new IllegalStateException("The " + target + " method's " + targetParameterIndex +

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/AbstractInstrumentationTest.java
Patch:
@@ -18,6 +18,7 @@
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.instrumentation.type.TypeList;
 import net.bytebuddy.matcher.ElementMatcher;
+import net.bytebuddy.test.utility.DebuggingWrapper;
 import org.hamcrest.CoreMatchers;
 import org.objectweb.asm.Opcodes;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/MethodCallTest.java
Patch:
@@ -40,7 +40,7 @@ public class MethodCallTest extends AbstractInstrumentationTest {
     public TestRule methodRule = new MockitoRule(this);
 
     @Rule
-    public MethodRule javaVersionRule = new JavaVersionRule(7);
+    public MethodRule javaVersionRule = new JavaVersionRule(8);
 
     @Mock
     private Assigner nonAssigner;

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/AbstractInstrumentationTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.instrumentation;
 
+import jdk.nashorn.internal.runtime.Debug;
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.NamingStrategy;
 import net.bytebuddy.asm.ClassVisitorWrapper;

File: byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java
Patch:
@@ -193,8 +193,8 @@ private static synchronized void doInstall() throws Exception {
                 .invoke(STATIC_MEMBER, runtimeName.substring(0, runtimeName.indexOf('@')));
         try {
             File agentFile = File.createTempFile(AGENT_FILE_NAME, JAR_FILE_EXTENSION);
-            saveAgentJar(agentFile);
             try {
+                saveAgentJar(agentFile);
                 virtualMachine.getDeclaredMethod(LOAD_AGENT_METHOD_NAME, String.class, String.class)
                         .invoke(virtualMachineInstance, agentFile.getAbsolutePath(), WITHOUT_ARGUMENTS);
             } finally {

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -444,7 +444,7 @@ public String toString() {
     /**
      * A default implementation of a {@link net.bytebuddy.pool.TypePool} that models binary data in the
      * Java byte code format into a {@link net.bytebuddy.instrumentation.type.TypeDescription}. The data lookup
-     * is delegated to a {@link SourceLocator}.
+     * is delegated to a {@link net.bytebuddy.dynamic.ClassFileLocator}.
      */
     static class Default extends AbstractBase {
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -824,7 +824,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> isTypeIni
     /**
      * Only matches method descriptions that represent a visibility bridge. A visibility bridge is a Java bridge
      * method that was inserted by the compiler in order to increase the visibility of a method when inheriting
-     * a {@link public} method from a package-private type. In this case, the package-private type's method
+     * a {@code public} method from a package-private type. In this case, the package-private type's method
      * is declared to be package-private itself such that the bridge method needs to increase the visibility and
      * delegates the call to the original, package-private implementation.
      *

File: byte-buddy-android/src/test/java/net/bytebuddy/android/AndroidClassLoadingStrategyTest.java
Patch:
@@ -4,6 +4,7 @@
 import com.android.dx.dex.file.DexFile;
 import dalvik.system.DexClassLoader;
 import net.bytebuddy.ByteBuddy;
+import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.dynamic.ClassLoadingStrategy;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.instrumentation.FixedValue;
@@ -86,7 +87,7 @@ public void testAndroidClassLoaderRequiresDirectory() throws Exception {
 
     @Test
     public void testStubbedClassLoading() throws Exception {
-        DynamicType dynamicType = new ByteBuddy().subclass(Object.class)
+        DynamicType dynamicType = new ByteBuddy(ClassFileVersion.JAVA_V6).subclass(Object.class)
                 .method(named(TO_STRING)).intercept(FixedValue.value(FOO))
                 .make();
         ClassLoadingStrategy classLoadingStrategy = new AndroidClassLoadingStrategy(directory);

File: byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
Patch:
@@ -631,7 +631,7 @@ public int hashCode() {
 
             @Override
             public String toString() {
-                return "AgentBuilder.Default.Entry{" +
+                return "AgentBuilder.Default.Transformation{" +
                         "rawMatcher=" + rawMatcher +
                         ", transformer=" + transformer +
                         '}';

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -13,7 +13,6 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(AgentBuilder.Default.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.Default.Matched.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.Default.Entry.class).apply();
-        ObjectPropertyAssertion.of(AgentBuilder.Default.NameClassLoaderPair.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.class)
                 .apply(new AgentBuilder.Default().new ExecutingTransformer());
         ObjectPropertyAssertion.of(AgentBuilder.Default.InitializationStrategy.SelfInjection.class).apply();

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/InlineDynamicTypeBuilder.java
Patch:
@@ -3,6 +3,7 @@
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.NamingStrategy;
 import net.bytebuddy.asm.ClassVisitorWrapper;
+import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.scaffold.BridgeMethodResolver;
 import net.bytebuddy.dynamic.scaffold.FieldRegistry;

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderBinaryLocatorDefaultTest.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.agent.builder;
 
-import net.bytebuddy.dynamic.scaffold.inline.ClassFileLocator;
+import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.pool.TypePool;
 import net.bytebuddy.test.utility.MockitoRule;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassFileLocatorAgentBasedNonAttachedTest.java
Patch:
@@ -1,4 +1,4 @@
-package net.bytebuddy.dynamic.scaffold.inline;
+package net.bytebuddy.dynamic;
 
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
 import org.junit.Test;

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/InlineDynamicTypeBuilderTest.java
Patch:
@@ -3,6 +3,7 @@
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.NamingStrategy;
 import net.bytebuddy.asm.ClassVisitorWrapper;
+import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.ClassLoadingStrategy;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.scaffold.BridgeMethodResolver;

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultComponentTypeLocatorTest.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.pool;
 
-import net.bytebuddy.dynamic.scaffold.inline.ClassFileLocator;
+import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.instrumentation.method.MethodDescription;
 import net.bytebuddy.instrumentation.method.MethodList;
 import net.bytebuddy.instrumentation.type.TypeDescription;

File: byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
Patch:
@@ -13,6 +13,7 @@ public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(AgentBuilder.Default.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.Default.Matched.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.Default.Entry.class).apply();
+        ObjectPropertyAssertion.of(AgentBuilder.Default.NameClassLoaderPair.class).apply();
         ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.class)
                 .apply(new AgentBuilder.Default().new ExecutingTransformer());
         ObjectPropertyAssertion.of(AgentBuilder.Default.InitializationStrategy.SelfInjection.class).apply();

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTest.java
Patch:
@@ -53,7 +53,7 @@ public class ByteBuddyTest {
     @Mock
     private ModifierContributor.ForType modifierContributorForType;
     @Mock
-    private NamingStrategy namingStrategy;
+    private NamingStrategy.Unbound namingStrategy;
     @Mock
     private Instrumentation instrumentation;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -103,8 +103,8 @@ public void testTutorialGettingStartedNamed() throws Exception {
     @Test
     public void testTutorialGettingStartedNamingStrategy() throws Exception {
         DynamicType.Unloaded<?> dynamicType = new ByteBuddy()
-                .withNamingStrategy(new GettingStartedNamingStrategy())
                 .subclass(Object.class)
+                .name(new GettingStartedNamingStrategy()) // TODO: change tutorial
                 .make();
         assertThat(dynamicType, notNullValue());
         Class<?> type = dynamicType.load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER).getLoaded();

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -581,7 +581,7 @@ public StackManipulation getInjectedCode() {
                     }
 
                     @Override
-                    public boolean isInjected() {
+                    public boolean isDefined() {
                         return true;
                     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/InstrumentationContextExtractableViewInjectedCodeNoneTest.java
Patch:
@@ -9,7 +9,7 @@ public class InstrumentationContextExtractableViewInjectedCodeNoneTest {
 
     @Test
     public void testNoInjectedCode() throws Exception {
-        assertThat(Instrumentation.Context.ExtractableView.InjectedCode.None.INSTANCE.isInjected(), is(false));
+        assertThat(Instrumentation.Context.ExtractableView.InjectedCode.None.INSTANCE.isDefined(), is(false));
     }
 
     @Test(expected = IllegalStateException.class)

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/InlineDynamicTypeBuilder.java
Patch:
@@ -224,6 +224,7 @@ public DynamicType.Unloaded<T> make() {
                 preparedTargetHandler.getMethodPoolEntryDefault());
         return new TypeWriter.Default<T>(compiledMethodRegistry.getInstrumentedType(),
                 compiledMethodRegistry.getLoadedTypeInitializer(),
+                compiledMethodRegistry.getTypeInitializer(),
                 preparedTargetHandler.getAuxiliaryTypes(),
                 classFileVersion,
                 new TypeWriter.Engine.ForRedefinition(compiledMethodRegistry.getInstrumentedType(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -205,6 +205,7 @@ public DynamicType.Unloaded<T> make() {
                         MethodRegistry.Compiled.Entry.Skip.INSTANCE);
         return new TypeWriter.Default<T>(compiledMethodRegistry.getInstrumentedType(),
                 compiledMethodRegistry.getLoadedTypeInitializer(),
+                compiledMethodRegistry.getTypeInitializer(),
                 Collections.<DynamicType>emptyList(),
                 classFileVersion,
                 new TypeWriter.Engine.ForCreation(compiledMethodRegistry.getInstrumentedType(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/ArgumentTypeResolver.java
Patch:
@@ -25,7 +25,7 @@
  * methods {@code foo(Object)} and {@code bar(String)}, this ambiguity resolver will detect that the {@code String} type
  * is more specific than the {@code Object} type and determine {@code bar(String)} as the dominant binding.
  */
-public enum MostSpecificTypeResolver implements MethodDelegationBinder.AmbiguityResolver {
+public enum ArgumentTypeResolver implements MethodDelegationBinder.AmbiguityResolver {
 
     /**
      * The singleton instance.

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/ArgumentBinderTest.java
Patch:
@@ -1,8 +1,8 @@
 package net.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
 import net.bytebuddy.instrumentation.attribute.annotation.AnnotationList;
+import net.bytebuddy.instrumentation.method.bytecode.bind.ArgumentTypeResolver;
 import net.bytebuddy.instrumentation.method.bytecode.bind.MethodDelegationBinder;
-import net.bytebuddy.instrumentation.method.bytecode.bind.MostSpecificTypeResolver;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.instrumentation.type.TypeList;
 import org.junit.Test;
@@ -74,7 +74,7 @@ private void assertBinding(Annotation[][] annotations,
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = Argument.Binder.INSTANCE
                 .bind(annotationDescription, targetIndex, source, target, instrumentationTarget, assigner);
         assertThat(parameterBinding.isValid(), is(true));
-        Object expectedToken = new MostSpecificTypeResolver.ParameterIndexToken(sourceIndex);
+        Object expectedToken = new ArgumentTypeResolver.ParameterIndexToken(sourceIndex);
         if (bindingMechanic == Argument.BindingMechanic.UNIQUE) {
             assertThat(parameterBinding.getIdentificationToken(), equalTo(expectedToken));
             assertThat(parameterBinding.getIdentificationToken().hashCode(), equalTo(expectedToken.hashCode()));

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -620,7 +620,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> canThrow(
         if (exceptionType.isAssignableTo(Throwable.class)) {
             return exceptionType.isAssignableTo(RuntimeType.class) || exceptionType.isAssignableTo(Error.class)
                     ? new BooleanMatcher<T>(true)
-                    : ElementMatchers.<T>canThrow(new CollectionItemMatcher<TypeDescription>(new SubTypeMatcher2<TypeDescription>(exceptionType)));
+                    : ElementMatchers.<T>canThrow(new CollectionItemMatcher<TypeDescription>(new SubTypeMatcher<TypeDescription>(exceptionType)));
         } else {
             throw new IllegalArgumentException(exceptionType + " is not an exception type");
         }
@@ -724,7 +724,7 @@ public static <T extends TypeDescription> ElementMatcher.Junction<T> isSubTypeOf
     }
 
     public static <T extends TypeDescription> ElementMatcher.Junction<T> isSubTypeOf(TypeDescription typeDescription) {
-        return new SubTypeMatcher2<T>(nonNull(typeDescription));
+        return new SubTypeMatcher<T>(nonNull(typeDescription));
     }
 
     public static <T extends TypeDescription> ElementMatcher.Junction<T> isSuperTypeOf(Class<?> type) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SubTypeMatcher.java
Patch:
@@ -7,7 +7,7 @@
  *
  * @param <T> The type of the matched entity.
  */
-public class SubTypeMatcher2<T extends TypeDescription> extends ElementMatcher.Junction.AbstractBase<T> {
+public class SubTypeMatcher<T extends TypeDescription> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**
      * The type to be matched being a super type of the matched type.
@@ -19,7 +19,7 @@ public class SubTypeMatcher2<T extends TypeDescription> extends ElementMatcher.J
      *
      * @param typeDescription The type to be matched being a super type of the matched type.
      */
-    public SubTypeMatcher2(TypeDescription typeDescription) {
+    public SubTypeMatcher(TypeDescription typeDescription) {
         this.typeDescription = typeDescription;
     }
 
@@ -31,7 +31,7 @@ public boolean matches(T target) {
     @Override
     public boolean equals(Object other) {
         return this == other || !(other == null || getClass() != other.getClass())
-                && typeDescription.equals(((SubTypeMatcher2) other).typeDescription);
+                && typeDescription.equals(((SubTypeMatcher) other).typeDescription);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/SubtypeMatcher.java
Patch:
@@ -44,3 +44,4 @@ public String toString() {
         return "isSubTypeOf(" + typeDescription + ')';
     }
 }
+

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -620,7 +620,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> canThrow(
         if (exceptionType.isAssignableTo(Throwable.class)) {
             return exceptionType.isAssignableTo(RuntimeType.class) || exceptionType.isAssignableTo(Error.class)
                     ? new BooleanMatcher<T>(true)
-                    : ElementMatchers.<T>canThrow(new CollectionItemMatcher<TypeDescription>(new SubTypeMatcher<TypeDescription>(exceptionType)));
+                    : ElementMatchers.<T>canThrow(new CollectionItemMatcher<TypeDescription>(new SubTypeMatcher2<TypeDescription>(exceptionType)));
         } else {
             throw new IllegalArgumentException(exceptionType + " is not an exception type");
         }
@@ -706,7 +706,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> isSpecial
             matchers.add(isSubTypeOf(typeDescription));
         }
         return (methodDescription.isStatic() ? ElementMatchers.<T>isStatic() : ElementMatchers.<T>not(isStatic()))
-                .<T>and(named(methodDescription.getName()))
+                .<T>and(named(methodDescription.getSourceCodeName()))
                 .<T>and(returns(isSubTypeOf(methodDescription.getReturnType())))
                 .and(takesArguments(new CollectionOneToOneMatcher<TypeDescription>(matchers)));
     }
@@ -724,7 +724,7 @@ public static <T extends TypeDescription> ElementMatcher.Junction<T> isSubTypeOf
     }
 
     public static <T extends TypeDescription> ElementMatcher.Junction<T> isSubTypeOf(TypeDescription typeDescription) {
-        return new SubTypeMatcher<T>(nonNull(typeDescription));
+        return new SubTypeMatcher2<T>(nonNull(typeDescription));
     }
 
     public static <T extends TypeDescription> ElementMatcher.Junction<T> isSuperTypeOf(Class<?> type) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/FixedValue.java
Patch:
@@ -186,7 +186,7 @@ public static AssignerConfigurable reference(Object fixedValue, String fieldName
      * @return The default assigner that is to be used if no other assigner was explicitly specified.
      */
     private static Assigner defaultAssigner() {
-        return new VoidAwareAssigner(new PrimitiveTypeAwareAssigner(ReferenceTypeAwareAssigner.INSTANCE), false);
+        return new VoidAwareAssigner(new PrimitiveTypeAwareAssigner(ReferenceTypeAwareAssigner.INSTANCE));
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/MethodDelegation.java
Patch:
@@ -480,7 +480,7 @@ private static MethodDelegationBinder.AmbiguityResolver defaultAmbiguityResolver
      * @return The assigner that is to be used if no other is specified explicitly.
      */
     private static Assigner defaultAssigner() {
-        return new VoidAwareAssigner(new PrimitiveTypeAwareAssigner(ReferenceTypeAwareAssigner.INSTANCE), false);
+        return new VoidAwareAssigner(new PrimitiveTypeAwareAssigner(ReferenceTypeAwareAssigner.INSTANCE));
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Morph.java
Patch:
@@ -720,7 +720,7 @@ public Size apply(MethodVisitor methodVisitor,
                                         FieldAccess.forField(typeDescription.getDeclaredFields().named(RedirectionProxy.FIELD_NAME)).getter()),
                                 new StackManipulation.Compound(parameterLoading),
                                 MethodInvocation.invoke(accessorMethod),
-                                assigner.assign(accessorMethod.getReturnType(), instrumentedMethod.getReturnType(), false),
+                                assigner.assign(accessorMethod.getReturnType(), instrumentedMethod.getReturnType(), true),
                                 MethodReturn.REFERENCE
                         ).apply(methodVisitor, instrumentationContext);
                         return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Pipe.java
Patch:
@@ -584,7 +584,7 @@ public Size apply(MethodVisitor methodVisitor,
                                 assigner.assign(new TypeDescription.ForLoadedType(Object.class), redirectedMethod.getDeclaringType(), true),
                                 new StackManipulation.Compound(fieldLoading),
                                 MethodInvocation.invoke(redirectedMethod),
-                                assigner.assign(redirectedMethod.getReturnType(), instrumentedMethod.getReturnType(), false),
+                                assigner.assign(redirectedMethod.getReturnType(), instrumentedMethod.getReturnType(), true),
                                 MethodReturn.REFERENCE
                         ).apply(methodVisitor, instrumentationContext);
                         return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/assign/reference/ReferenceTypeAwareAssigner.java
Patch:
@@ -18,7 +18,7 @@ public enum ReferenceTypeAwareAssigner implements Assigner {
     @Override
     public StackManipulation assign(TypeDescription sourceType,
                                     TypeDescription targetType,
-                                    boolean considerRuntimeType) {
+                                    boolean dynamicallyTyped) {
         if (sourceType.isPrimitive() || targetType.isPrimitive()) {
             if (sourceType.equals(targetType)) {
                 return StackManipulation.LegalTrivial.INSTANCE;
@@ -27,7 +27,7 @@ public StackManipulation assign(TypeDescription sourceType,
             }
         } else if (targetType.isAssignableFrom(sourceType)) {
             return StackManipulation.LegalTrivial.INSTANCE;
-        } else if (considerRuntimeType) {
+        } else if (dynamicallyTyped) {
             return new DownCasting(targetType);
         } else {
             return StackManipulation.Illegal.INSTANCE;

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/auxiliary/MethodCallProxy.java
Patch:
@@ -80,7 +80,7 @@ public MethodCallProxy(Instrumentation.SpecialMethodInvocation specialMethodInvo
                            boolean serializableProxy) {
         this(specialMethodInvocation,
                 serializableProxy,
-                new VoidAwareAssigner(new PrimitiveTypeAwareAssigner(ReferenceTypeAwareAssigner.INSTANCE), true));
+                new VoidAwareAssigner(new PrimitiveTypeAwareAssigner(ReferenceTypeAwareAssigner.INSTANCE)));
     }
 
     /**
@@ -417,7 +417,7 @@ public Size apply(MethodVisitor methodVisitor,
                 StackManipulation.Size stackSize = new StackManipulation.Compound(
                         new StackManipulation.Compound(fieldLoading),
                         MethodInvocation.invoke(accessorMethod),
-                        assigner.assign(accessorMethod.getReturnType(), instrumentedMethod.getReturnType(), false),
+                        assigner.assign(accessorMethod.getReturnType(), instrumentedMethod.getReturnType(), true),
                         MethodReturn.returning(instrumentedMethod.getReturnType())
                 ).apply(methodVisitor, instrumentationContext);
                 return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTutorialExamplesTest.java
Patch:
@@ -440,7 +440,7 @@ public static enum ToStringAssigner implements Assigner {
         @Override
         public StackManipulation assign(TypeDescription sourceType,
                                         TypeDescription targetType,
-                                        boolean considerRuntimeType) {
+                                        boolean dynamicallyTyped) {
             if (!sourceType.isPrimitive() && targetType.represents(String.class)) {
                 MethodDescription toStringMethod = new TypeDescription.ForLoadedType(Object.class)
                         .getDeclaredMethods()

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/VoidAwareAssignerNonVoidToVoidTest.java
Patch:
@@ -87,8 +87,8 @@ public void testAssignNoDefaultValue() throws Exception {
     }
 
     private void testAssignDefaultValue(boolean defaultValue) throws Exception {
-        Assigner voidAwareAssigner = new VoidAwareAssigner(chainedAssigner, defaultValue);
-        StackManipulation stackManipulation = voidAwareAssigner.assign(sourceTypeDescription, targetTypeDescription, false);
+        Assigner voidAwareAssigner = new VoidAwareAssigner(chainedAssigner);
+        StackManipulation stackManipulation = voidAwareAssigner.assign(sourceTypeDescription, targetTypeDescription, defaultValue);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, instrumentationContext);
         assertThat(size.getSizeImpact(), is(-1 * StackSize.of(sourceType).getSize()));

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/VoidAwareAssignerTest.java
Patch:
@@ -41,7 +41,7 @@ public void tearDown() throws Exception {
     public void testAssignVoidToVoid() throws Exception {
         when(sourceTypeDescription.represents(void.class)).thenReturn(true);
         when(targetTypeDescription.represents(void.class)).thenReturn(true);
-        Assigner voidAwareAssigner = new VoidAwareAssigner(chainedAssigner, true);
+        Assigner voidAwareAssigner = new VoidAwareAssigner(chainedAssigner);
         StackManipulation stackManipulation = voidAwareAssigner.assign(sourceTypeDescription, targetTypeDescription, false);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, instrumentationContext);
@@ -52,7 +52,7 @@ public void testAssignVoidToVoid() throws Exception {
 
     @Test
     public void testAssignNonVoidToNonVoid() throws Exception {
-        Assigner voidAwareAssigner = new VoidAwareAssigner(chainedAssigner, true);
+        Assigner voidAwareAssigner = new VoidAwareAssigner(chainedAssigner);
         StackManipulation chainedStackManipulation = mock(StackManipulation.class);
         when(chainedAssigner.assign(sourceTypeDescription, targetTypeDescription, false)).thenReturn(chainedStackManipulation);
         StackManipulation stackManipulation = voidAwareAssigner.assign(sourceTypeDescription, targetTypeDescription, false);

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/VoidAwareAssignerVoidToNonVoidTest.java
Patch:
@@ -77,8 +77,8 @@ public void tearDown() throws Exception {
 
     @Test
     public void testAssignDefaultValue() throws Exception {
-        Assigner voidAwareAssigner = new VoidAwareAssigner(chainedAssigner, true);
-        StackManipulation stackManipulation = voidAwareAssigner.assign(sourceTypeDescription, targetTypeDescription, false);
+        Assigner voidAwareAssigner = new VoidAwareAssigner(chainedAssigner);
+        StackManipulation stackManipulation = voidAwareAssigner.assign(sourceTypeDescription, targetTypeDescription, true);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, instrumentationContext);
         assertThat(size.getSizeImpact(), is(StackSize.of(targetType).getSize()));
@@ -89,7 +89,7 @@ public void testAssignDefaultValue() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testAssignNoDefaultValue() throws Exception {
-        Assigner voidAwareAssigner = new VoidAwareAssigner(chainedAssigner, false);
+        Assigner voidAwareAssigner = new VoidAwareAssigner(chainedAssigner);
         StackManipulation stackManipulation = voidAwareAssigner.assign(sourceTypeDescription, targetTypeDescription, false);
         assertThat(stackManipulation.isValid(), is(false));
         stackManipulation.apply(methodVisitor, instrumentationContext);

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -327,9 +327,9 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> isCompati
         for (TypeDescription typeDescription : parameterTypes) {
             matchers.add(isSubTypeOf(typeDescription));
         }
-        return (methodDescription.isStatic() ? isStatic() : not(isStatic()))
-                .and(named(methodDescription.getName()))
-                .and(returns(isSubTypeOf(methodDescription.getReturnType())))
+        return (methodDescription.isStatic() ? ElementMatchers.<T>isStatic() : ElementMatchers.<T>not(isStatic()))
+                .<T>and(named(methodDescription.getName()))
+                .<T>and(returns(isSubTypeOf(methodDescription.getReturnType())))
                 .and(takesArguments(new ListOneToOneMatcher<TypeDescription>(matchers)));
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/DescriptorMatcher.java
Patch:
@@ -12,7 +12,7 @@ public DescriptorMatcher(ElementMatcher<String> descriptorMatcher) {
 
     @Override
     public boolean matches(T target) {
-        return descriptorMatcher.matches(target.getName());
+        return descriptorMatcher.matches(target.getDescriptor());
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
Patch:
@@ -315,7 +315,7 @@ public static <T extends MethodDescription> ElementMatcher.Junction<T> isCompati
         TypeList parameterTypes = methodDescription.getParameterTypes();
         List<ElementMatcher<TypeDescription>> matchers = new ArrayList<ElementMatcher<TypeDescription>>(parameterTypes.size());
         for (TypeDescription typeDescription : parameterTypes) {
-            matchers.add(isSuperTypeOf(typeDescription));
+            matchers.add(isSubTypeOf(typeDescription));
         }
         return (methodDescription.isStatic() ? isStatic() : not(isStatic()))
                 .and(named(methodDescription.getName()))

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -8,6 +8,7 @@
 import net.bytebuddy.instrumentation.method.MethodList;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.instrumentation.type.TypeList;
+import net.bytebuddy.matcher.ElementMatchers;
 import net.bytebuddy.matcher.FilterableList;
 import net.bytebuddy.utility.PropertyDispatcher;
 import net.bytebuddy.utility.StreamDrainer;
@@ -1765,9 +1766,9 @@ public DeclaredInMethod(String internalName, String methodName, String methodDes
                 @Override
                 public MethodDescription getEnclosingMethod(TypePool typePool) {
                     return getEnclosingType(typePool).getDeclaredMethods()
-                            .filter(MethodDescription.CONSTRUCTOR_INTERNAL_NAME.equals(methodName)
+                            .filter((MethodDescription.CONSTRUCTOR_INTERNAL_NAME.equals(methodName)
                                     ? isConstructor()
-                                    : named(methodName)
+                                    : ElementMatchers.<MethodDescription>named(methodName))
                                     .<MethodDescription>and(hasDescriptor(methodDescriptor))).getOnly();
                 }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodRegistryDefaultTest.java
Patch:
@@ -92,7 +92,7 @@ public void setUp() throws Exception {
         when(croppedMethodList.filter(any(ElementMatcher.class))).thenAnswer(new Answer<MethodList>() {
             @Override
             public MethodList answer(InvocationOnMock invocation) throws Throwable {
-                Field field = invocation.getArguments()[0].getClass().getDeclaredField("methodDescription");
+                Field field = invocation.getArguments()[0].getClass().getDeclaredField("value");
                 field.setAccessible(true);
                 return field.get(invocation.getArguments()[0]) == instrumentationAppendedMethod ? singleSize : zeroSize;
             }

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultComponentTypeLocatorTest.java
Patch:
@@ -30,7 +30,7 @@ public void testForAnnotationProperty() throws Exception {
         when(typePool.describe(BAR)).thenReturn(typeDescription);
         MethodDescription methodDescription = mock(MethodDescription.class);
         when(typeDescription.getDeclaredMethods()).thenReturn(new MethodList.Explicit(Arrays.asList(methodDescription)));
-        when(methodDescription.getName()).thenReturn(FOO);
+        when(methodDescription.getSourceCodeName()).thenReturn(FOO);
         TypeDescription returnType = mock(TypeDescription.class);
         when(methodDescription.getReturnType()).thenReturn(returnType);
         TypeDescription componentType = mock(TypeDescription.class);

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyDeclarationContextTest.java
Patch:
@@ -86,9 +86,9 @@ public void testDeclaredInMethodGetTypeIsNotNull() throws Exception {
     @Test
     public void testDeclaredInMethodGetMethodIsNull() throws Exception {
         MethodDescription methodDescription = mock(MethodDescription.class);
-        TypeDescription typeDescription = mock(TypeDescription.class);
-        when(methodDescription.getName()).thenReturn(BAR);
+        when(methodDescription.getSourceCodeName()).thenReturn(BAR);
         when(methodDescription.getDescriptor()).thenReturn(QUX);
+        TypeDescription typeDescription = mock(TypeDescription.class);
         TypePool typePool = mock(TypePool.class);
         when(typePool.describe(FOO)).thenReturn(typeDescription);
         when(typeDescription.getDeclaredMethods()).thenReturn(new MethodList.Explicit(Arrays.asList(methodDescription)));

File: byte-buddy-dep/src/main/java/net/bytebuddy/matcher/MethodParameterLengthMatcher.java
Patch:
@@ -12,7 +12,7 @@ public MethodParameterLengthMatcher(int length) {
 
     @Override
     public boolean matches(T target) {
-        return false;
+        return target.getParameterTypes().size() == length;
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassLoaderByteArrayInjector.java
Patch:
@@ -85,7 +85,7 @@ public ClassLoaderByteArrayInjector(ClassLoader classLoader) {
      * @param protectionDomain The protection domain to apply during class definition.
      */
     public ClassLoaderByteArrayInjector(ClassLoader classLoader, ProtectionDomain protectionDomain) {
-        if(classLoader == null) {
+        if (classLoader == null) {
             throw new IllegalArgumentException("Cannot inject classes into the bootstrap class loader");
         }
         this.classLoader = classLoader;

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/type/auxiliary/TypeProxyObjectPropertiesTest.java
Patch:
@@ -25,7 +25,7 @@ public void apply(TypeDescription mock) {
                 when(mock.getDeclaredFields()).thenReturn(new FieldList.Explicit(Arrays.asList(fieldDescription)));
             }
         }).skipSynthetic().apply();
-        ObjectPropertyAssertion.of(TypeProxy.MethodCall.Appender.AccessorMethodInvocation .class).skipSynthetic().apply();
+        ObjectPropertyAssertion.of(TypeProxy.MethodCall.Appender.AccessorMethodInvocation.class).skipSynthetic().apply();
         ObjectPropertyAssertion.of(TypeProxy.SilentConstruction.Appender.class).skipSynthetic().apply();
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/ByteBuddyCommonsTest.java
Patch:
@@ -82,6 +82,7 @@ public void testNonVoidThrowsException() throws Exception {
         when(typeDescription.represents(void.class)).thenReturn(true);
         assertThat(nonVoid(typeDescription), sameInstance(typeDescription));
     }
+
     @Test
     public void testNonVoidCollection() throws Exception {
         List<TypeDescription> typeDescriptions = Arrays.asList(mock(TypeDescription.class));

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/field/FieldDescription.java
Patch:
@@ -67,8 +67,8 @@ public String toString() {
             if (getModifiers() != 0) {
                 stringBuilder.append(Modifier.toString(getModifiers())).append(" ");
             }
-            stringBuilder.append(getFieldType().getJavaName()).append(" ");
-            stringBuilder.append(getDeclaringType().getJavaName()).append(".");
+            stringBuilder.append(getFieldType().getSourceCodeName()).append(" ");
+            stringBuilder.append(getDeclaringType().getSourceCodeName()).append(".");
             return stringBuilder.append(getName()).toString();
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/TypeDescription.java
Patch:
@@ -255,7 +255,7 @@ public interface TypeDescription extends ByteCodeElement {
      *
      * @return The name of this type as represented in Java source code.
      */
-    String getJavaName();
+    String getSourceCodeName();
 
     /**
      * Returns the annotations that this type declares or inherits from super types.
@@ -472,7 +472,7 @@ public AnnotationList getInheritedAnnotations() {
         }
 
         @Override
-        public String getJavaName() {
+        public String getSourceCodeName() {
             if (isArray()) {
                 TypeDescription typeDescription = this;
                 int dimensions = 0;

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Morph.java
Patch:
@@ -127,7 +127,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loa
             }
             Instrumentation.SpecialMethodInvocation specialMethodInvocation;
             TypeDescription typeDescription = annotation.getValue(DEFAULT_TARGET, TypeDescription.class);
-            if (!typeDescription.represents(void.class) && annotation.getValue(DEFAULT_METHOD, Boolean.class)) {
+            if (typeDescription.represents(void.class) && !annotation.getValue(DEFAULT_METHOD, Boolean.class)) {
                 specialMethodInvocation = instrumentationTarget.invokeSuper(source, Instrumentation.Target.MethodLookup.Default.EXACT);
             } else {
                 specialMethodInvocation = (typeDescription.represents(void.class)

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/DefaultCall.java
Patch:
@@ -197,7 +197,7 @@ public int hashCode() {
 
                 @Override
                 public String toString() {
-                    return "Binder.DefaultCall.DefaultMethodLocator.Explicit{typeDescription=" + typeDescription + '}';
+                    return "DefaultCall.Binder.DefaultMethodLocator.Explicit{typeDescription=" + typeDescription + '}';
                 }
             }
         }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/annotation/AnnotationDescriptionAbstractPreparedExceptionTest.java
Patch:
@@ -8,12 +8,12 @@
 
 public class AnnotationDescriptionAbstractPreparedExceptionTest {
 
-    @Test(expected = ClassNotFoundException.class)
+    @Test(expected = IllegalStateException.class)
     public void testThrowWithoutClassLoader() throws Exception {
         new PseudoDescription().loadSilent();
     }
 
-    @Test(expected = ClassNotFoundException.class)
+    @Test(expected = IllegalStateException.class)
     public void testThrowWithClassLoader() throws Exception {
         new PseudoDescription().loadSilent(getClass().getClassLoader());
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/annotation/AnnotationDescriptionAbstractPreparedExceptionTest.java
Patch:
@@ -10,12 +10,12 @@ public class AnnotationDescriptionAbstractPreparedExceptionTest {
 
     @Test(expected = ClassNotFoundException.class)
     public void testThrowWithoutClassLoader() throws Exception {
-        new PseudoDescription().load();
+        new PseudoDescription().loadSilent();
     }
 
     @Test(expected = ClassNotFoundException.class)
     public void testThrowWithClassLoader() throws Exception {
-        new PseudoDescription().load(getClass().getClassLoader());
+        new PseudoDescription().loadSilent(getClass().getClassLoader());
     }
 
     private static class PseudoDescription extends AnnotationDescription.AbstractAnnotationDescription.ForPrepared<Annotation> {

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/MethodDescription.java
Patch:
@@ -280,10 +280,8 @@ public boolean isDefaultMethod() {
         public boolean isSpecializableFor(TypeDescription targetType) {
             if (isStatic()) { // Static private methods are never specializable, check static property first
                 return false;
-            } else if (isPrivate() || isConstructor()) {
+            } else if (isPrivate() || isConstructor() || isDefaultMethod()) {
                 return getDeclaringType().equals(targetType);
-            } else if (isDefaultMethod()) {
-                return targetType.getInterfaces().contains(getDeclaringType());
             } else {
                 return !isAbstract() && getDeclaringType().isAssignableFrom(targetType);
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/InstrumentedType.java
Patch:
@@ -146,7 +146,7 @@ public MethodDescription getEnclosingMethod() {
         }
 
         @Override
-        public TypeDescription getEnclosingClass() {
+        public TypeDescription getEnclosingType() {
             return null;
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/type/AbstractTypeDescriptionTest.java
Patch:
@@ -334,9 +334,9 @@ class MethodSample {
 
     @Test
     public void testDeclaredInType() throws Exception {
-        assertThat(describe(SampleClass.class).getEnclosingClass().represents(AbstractTypeDescriptionTest.class), is(true));
-        assertThat(describe(Object.class).getEnclosingClass(), nullValue(TypeDescription.class));
-        assertThat(describe(Object[].class).getEnclosingClass(), nullValue(TypeDescription.class));
+        assertThat(describe(SampleClass.class).getEnclosingType().represents(AbstractTypeDescriptionTest.class), is(true));
+        assertThat(describe(Object.class).getEnclosingType(), nullValue(TypeDescription.class));
+        assertThat(describe(Object[].class).getEnclosingType(), nullValue(TypeDescription.class));
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolLazyTypeListTest.java
Patch:
@@ -62,6 +62,7 @@ public void testSubListOutOfBounds() throws Exception {
     public void testSubListIllegal() throws Exception {
         typeList.subList(1, 0);
     }
+
     @Test
     public void testStackSize() throws Exception {
         assertThat(typeList.getStackSize(), is(2));

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/ByteBuddyCommonsTest.java
Patch:
@@ -61,7 +61,7 @@ public void testNonNullThrowsException() throws Exception {
 
     @Test
     public void testNonNullArray() throws Exception {
-        Object[] object = new Object[] {new Object()};
+        Object[] object = new Object[]{new Object()};
         assertThat(nonNull(object), sameInstance(object));
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/FieldAccessor.java
Patch:
@@ -685,7 +685,7 @@ public AssignerConfigurable defineAs(TypeDescription typeDescription, ModifierCo
             return new ForNamedField(assigner,
                     considerRuntimeType,
                     fieldName,
-                    new PreparationHandler.FieldDefiner(fieldName, nonNull(typeDescription), nonNull(modifier)),
+                    new PreparationHandler.FieldDefiner(fieldName, nonVoid(typeDescription), nonNull(modifier)),
                     FieldLocator.ForInstrumentedType.INSTANCE);
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/FieldAccessor.java
Patch:
@@ -422,6 +422,8 @@ public String toString() {
 
     public static interface FieldNameExtractor {
 
+        String fieldNameFor(MethodDescription methodDescription);
+
         static enum ForBeanProperty implements FieldNameExtractor {
 
             INSTANCE;
@@ -444,8 +446,6 @@ public String fieldNameFor(MethodDescription methodDescription) {
                 return Character.toLowerCase(name.charAt(0)) + name.substring(1);
             }
         }
-
-        String fieldNameFor(MethodDescription methodDescription);
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Field.java
Patch:
@@ -51,12 +51,14 @@ static class Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinde
         private static final MethodDescription DEFINING_TYPE;
         private static final MethodDescription FIELD_NAME;
         private static final MethodDescription SERIALIZABLE_PROXY;
+
         static {
             MethodList methodList = new TypeDescription.ForLoadedType(Field.class).getDeclaredMethods();
             DEFINING_TYPE = methodList.filter(named("definingType")).getOnly();
             FIELD_NAME = methodList.filter(named("value")).getOnly();
             SERIALIZABLE_PROXY = methodList.filter(named("serializableProxy")).getOnly();
         }
+
         private final MethodDescription getterMethod;
         private final MethodDescription setterMethod;
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -89,6 +89,7 @@ abstract static class AbstractBase implements TypePool {
 
         protected static final Map<String, TypeDescription> PRIMITIVE_TYPES;
         protected static final Map<String, String> PRIMITIVE_DESCRIPTORS;
+
         static {
             Map<String, TypeDescription> primitiveTypes = new HashMap<String, TypeDescription>();
             Map<String, String> primitiveDescriptors = new HashMap<String, String>();
@@ -107,6 +108,7 @@ abstract static class AbstractBase implements TypePool {
             PRIMITIVE_TYPES = Collections.unmodifiableMap(primitiveTypes);
             PRIMITIVE_DESCRIPTORS = Collections.unmodifiableMap(primitiveDescriptors);
         }
+
         private static final String ARRAY_SYMBOL = "[";
         protected final CacheProvider cacheProvider;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoaderTest.java
Patch:
@@ -1,7 +1,6 @@
 package net.bytebuddy.dynamic.loading;
 
 import net.bytebuddy.utility.ClassFileExtraction;
-import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.hamcrest.Matcher;
 import org.junit.Before;
 import org.junit.Test;

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/FieldAccessor.java
Patch:
@@ -606,7 +606,7 @@ public boolean equals(Object other) {
 
         @Override
         public int hashCode() {
-            return 31 *(31 * super.hashCode() + fieldLocatorFactory.hashCode()) + fieldNameExtractor.hashCode();
+            return 31 * (31 * super.hashCode() + fieldLocatorFactory.hashCode()) + fieldNameExtractor.hashCode();
         }
 
         @Override
@@ -890,7 +890,7 @@ public boolean appendsCode() {
         public Size apply(MethodVisitor methodVisitor,
                           Instrumentation.Context instrumentationContext,
                           MethodDescription instrumentedMethod) {
-            if(isConstructor().matches(instrumentedMethod)) {
+            if (isConstructor().matches(instrumentedMethod)) {
                 throw new IllegalArgumentException("Constructors cannot define beans: " + instrumentedMethod);
             }
             if (takesArguments(0).and(not(returns(void.class))).matches(instrumentedMethod)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/BridgeMethodResolver.java
Patch:
@@ -87,7 +87,7 @@ static class Simple implements BridgeMethodResolver {
         /**
          * Creates a new simple bridge method resolver.
          *
-         * @param methodList        The relevant methods which can be called in a given context.
+         * @param methodList      The relevant methods which can be called in a given context.
          * @param conflictHandler A conflict handler that is queried for handling ambiguous resolutions.
          */
         public Simple(MethodList methodList, ConflictHandler conflictHandler) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/MethodDelegation.java
Patch:
@@ -972,9 +972,9 @@ protected static class Appender implements ByteCodeAppender {
          *                                 the method delegation.
          */
         protected Appender(StackManipulation preparingStackAssignment,
-                         Target instrumentationTarget,
-                         Iterable<? extends MethodDescription> targetMethods,
-                         MethodDelegationBinder.Processor processor) {
+                           Target instrumentationTarget,
+                           Iterable<? extends MethodDescription> targetMethods,
+                           MethodDelegationBinder.Processor processor) {
             this.preparingStackAssignment = preparingStackAssignment;
             this.instrumentationTarget = instrumentationTarget;
             this.targetMethods = targetMethods;

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/Duplication.java
Patch:
@@ -14,7 +14,6 @@ public enum Duplication implements StackManipulation {
      * A duplication of no values. This corresponds a no-op instruction.
      */
     ZERO(StackSize.ZERO, Opcodes.NOP) {
-
         @Override
         public Size apply(MethodVisitor methodVisitor, Instrumentation.Context instrumentationContext) {
             return new Size(0, 0);

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypeSourceLocator.java
Patch:
@@ -7,6 +7,8 @@
 
 public interface TypeSourceLocator {
 
+    byte[] locate(String typeName);
+
     static class ForClassLoader implements TypeSourceLocator {
 
         private static final String CLASS_FILE_SUFFIX = ".class";
@@ -34,6 +36,4 @@ public byte[] locate(String typeName) {
             }
         }
     }
-
-    byte[] locate(String typeName);
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/AbstractSpecialMethodInvocationTest.java
Patch:
@@ -82,5 +82,7 @@ public void testEquals() throws Exception {
         when(equalMethodButParameter.getReturnType()).thenReturn(returnType);
         when(equalMethodButParameter.getParameterTypes()).thenReturn(new TypeList.Explicit(Arrays.asList(mock(TypeDescription.class))));
         assertThat(make(FOO, returnType, parameterTypes, targetType), not(is(equalButParameter)));
+        assertThat(make(FOO, returnType, parameterTypes, targetType), not(is(new Object())));
+        assertThat(make(FOO, returnType, parameterTypes, targetType), not(is((Object) null)));
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/type/TypeListForLoadedTypeTest.java
Patch:
@@ -15,7 +15,7 @@ public class TypeListForLoadedTypeTest {
 
     @Before
     public void setUp() throws Exception {
-        typeList = new TypeList.ForLoadedType(new Class<?>[]{Object.class, Integer.class, long.class});
+        typeList = new TypeList.ForLoadedType(Object.class, Integer.class, long.class);
     }
 
     @Test
@@ -37,7 +37,7 @@ public void testInternalNames() throws Exception {
 
     @Test
     public void testEmptyList() throws Exception {
-        TypeList typeList = new TypeList.ForLoadedType(new Class<?>[0]);
+        TypeList typeList = new TypeList.ForLoadedType();
         assertThat(typeList.isEmpty(), is(true));
         assertThat(typeList.toInternalNames(), nullValue(String[].class));
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseInstrumentationTarget.java
Patch:
@@ -87,7 +87,7 @@ public String toString() {
                 "typeDescription=" + typeDescription +
                 ", defaultMethods=" + defaultMethods +
                 ", bridgeMethodResolver=" + bridgeMethodResolver +
-                ", methodRedefinitionResolver=" + methodRebaseResolver +
+                ", methodRebaseResolver=" + methodRebaseResolver +
                 '}';
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentationTarget.java
Patch:
@@ -80,7 +80,8 @@ public String toString() {
                 "typeDescription=" + typeDescription +
                 ", defaultMethods=" + defaultMethods +
                 ", bridgeMethodResolver=" + bridgeMethodResolver +
-                ", targetTypeIdentifier=" + originTypeIdentifier +
+                ", superConstructors=" + superConstructors +
+                ", originTypeIdentifier=" + originTypeIdentifier +
                 '}';
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/MethodAttributeAppenderForLoadedConstructorTest.java
Patch:
@@ -54,7 +54,7 @@ public void testLoadedFieldAttributeAppender() throws Exception {
     @Test
     public void testObjectProperties() throws Exception {
         Constructor<?> first = Sample.class.getDeclaredConstructor(), second = Sample.class.getDeclaredConstructor(Void.class);
-        final Iterator<Constructor<?>> iterator = Arrays.asList(first, second).iterator();
+        final Iterator<Constructor<?>> iterator = Arrays.<Constructor<?>>asList(first, second).iterator();
         ObjectPropertyAssertion.of(MethodAttributeAppender.ForLoadedConstructor.class).create(new ObjectPropertyAssertion.Creator<Constructor<?>>() {
             @Override
             public Constructor<?> create() {

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/annotation/AnnotationDescriptionForLoadedAnnotationTest.java
Patch:
@@ -117,7 +117,7 @@ public void testPropertyRetrieval() throws Exception {
 
     @Test
     public void testPropertyRetrievalCasted() throws Exception {
-        assertThat(annotationDescription.getValue(methodDescription, castType), instanceOf(castType));
+        assertThat(castType.isInstance(annotationDescription.getValue(methodDescription, castType)), is(true));
         assertThat(annotationDescription.getValue(methodDescription, castType), is(expected));
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/type/auxiliary/MethodCallProxyOtherTest.java
Patch:
@@ -3,15 +3,15 @@
 import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
-public class MethodCallProxyEqualsHashCodeTest {
+public class MethodCallProxyOtherTest {
 
     @Test
     public void testEqualsHashCode() throws Exception {
         ObjectPropertyAssertion.of(MethodCallProxy.class).apply();
     }
 
     @Test
-    public void testAssignableSignatureCallEqualsHashCode() throws Exception {
+    public void testObjectProperties() throws Exception {
         ObjectPropertyAssertion.of(MethodCallProxy.AssignableSignatureCall.class).apply();
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Super.java
Patch:
@@ -69,7 +69,7 @@
     boolean ignoreFinalizer() default true;
 
     /**
-     * Determines if the generated proxy should be forced to be {@link java.io.Serializable}. If the annotated type
+     * Determines if the generated proxy should be {@link java.io.Serializable}. If the annotated type
      * already is serializable, such an explicit specification is not required.
      *
      * @return {@code true} if the generated proxy should be {@link java.io.Serializable}.

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -7,6 +7,7 @@
 import net.bytebuddy.instrumentation.method.bytecode.stack.Removal;
 import net.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import net.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
+import net.bytebuddy.instrumentation.method.bytecode.stack.member.MethodReturn;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 
 import java.lang.annotation.Annotation;
@@ -249,9 +250,9 @@ static enum Returning implements TerminationHandler {
 
             @Override
             public StackManipulation resolve(Assigner assigner, MethodDescription source, MethodDescription target) {
-                return assigner.assign(target.isConstructor() ? target.getDeclaringType() : target.getReturnType(),
+                return new StackManipulation.Compound(assigner.assign(target.isConstructor() ? target.getDeclaringType() : target.getReturnType(),
                         source.getReturnType(),
-                        RuntimeType.Verifier.check(target));
+                        RuntimeType.Verifier.check(target)), MethodReturn.returning(source.getReturnType()));
             }
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/AbstractInstrumentationTest.java
Patch:
@@ -17,10 +17,8 @@
 import net.bytebuddy.instrumentation.method.matcher.MethodMatcher;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.instrumentation.type.TypeList;
-import net.bytebuddy.utility.DebuggingWrapper;
 import org.hamcrest.CoreMatchers;
 import org.objectweb.asm.Opcodes;
-import org.objectweb.asm.util.Textifier;
 
 import java.util.Arrays;
 
@@ -63,7 +61,6 @@ protected <T> DynamicType.Loaded<T> instrument(Class<T> target,
                 MethodAttributeAppender.NoOp.INSTANCE,
                 ConstructorStrategy.Default.IMITATE_SUPER_TYPE)
                 .method(targetMethods).intercept(instrumentation)
-                .classVisitor(new DebuggingWrapper(System.out, new Textifier()))
                 .make()
                 .load(classLoader, ClassLoadingStrategy.Default.WRAPPER);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/MethodListEmptyTest.java
Patch:
@@ -4,8 +4,6 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.NoSuchElementException;
-
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
 
@@ -33,7 +31,7 @@ public void testIsIdenticalWhenFiltered() throws Exception {
         assertThat(methodList.filter(MethodMatchers.any()), is(methodList));
     }
 
-    @Test(expected = NoSuchElementException.class)
+    @Test(expected = IndexOutOfBoundsException.class)
     public void testNoElements() throws Exception {
         methodList.get(0);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/AbstractAnnotationBinderTest.java
Patch:
@@ -17,8 +17,7 @@
 
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
+import static org.mockito.Mockito.*;
 
 public abstract class AbstractAnnotationBinderTest<T extends Annotation> {
 
@@ -50,6 +49,7 @@ protected AbstractAnnotationBinderTest(Class<T> annotationType) {
     @Before
     public void setUp() throws Exception {
         annotation = mock(annotationType);
+        doReturn(annotationType).when(annotation).annotationType();
         annotationDescription = AnnotationDescription.ForLoadedAnnotation.of(annotation);
         when(source.getParameterTypes()).thenReturn(sourceTypeList);
         when(target.getParameterTypes()).thenReturn(targetTypeList);

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/TargetMethodAnnotationDrivenBinderTerminationHandlerReturningTest.java
Patch:
@@ -4,6 +4,7 @@
 import net.bytebuddy.instrumentation.method.MethodDescription;
 import net.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import net.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
+import net.bytebuddy.instrumentation.method.bytecode.stack.member.MethodReturn;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
@@ -51,7 +52,7 @@ public void setUp() throws Exception {
     public void testApplication() throws Exception {
         StackManipulation stackManipulation = TargetMethodAnnotationDrivenBinder.TerminationHandler.Returning.INSTANCE
                 .resolve(assigner, source, target);
-        assertThat(stackManipulation, is(this.stackManipulation));
+        assertThat(stackManipulation, is((StackManipulation) new StackManipulation.Compound(this.stackManipulation, MethodReturn.REFERENCE)));
         verify(annotationList).isAnnotationPresent(RuntimeType.class);
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/ByteCodeElement.java
Patch:
@@ -1,11 +1,13 @@
 package net.bytebuddy.instrumentation;
 
+import net.bytebuddy.instrumentation.attribute.annotation.AnnotatedElement;
+import net.bytebuddy.instrumentation.type.DeclaredInType;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 
 /**
  * Implementations describe an element represented in byte code, i.e. a type, a field or a method or a constructor.
  */
-public interface ByteCodeElement {
+public interface ByteCodeElement extends ModifierReviewable, DeclaredInType, AnnotatedElement {
 
     /**
      * Returns the internalName of this byte code element.

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedConstructorTest.java
Patch:
@@ -75,6 +75,7 @@ public void testObjectProperties() throws Exception {
             @Override
             public void apply(MethodDescription mock) {
                 when(mock.getParameterTypes()).thenReturn(new TypeList.Empty());
+                when(mock.getExceptionTypes()).thenReturn(new TypeList.Empty());
                 when(mock.getDeclaringType()).thenReturn(mock(TypeDescription.class));
                 when(mock.getReturnType()).thenReturn(mock(TypeDescription.class));
                 when(mock.getInternalName()).thenReturn(FOO + System.identityHashCode(mock));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionForRebasedMethodTest.java
Patch:
@@ -75,6 +75,7 @@ public void testObjectProperties() throws Exception {
             @Override
             public void apply(MethodDescription mock) {
                 when(mock.getParameterTypes()).thenReturn(new TypeList.Empty());
+                when(mock.getExceptionTypes()).thenReturn(new TypeList.Empty());
                 when(mock.getDeclaringType()).thenReturn(mock(TypeDescription.class));
                 when(mock.getReturnType()).thenReturn(mock(TypeDescription.class));
             }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/DuplicationTest.java
Patch:
@@ -64,8 +64,8 @@ public void testDuplication() throws Exception {
         StackManipulation stackManipulation = Duplication.duplicate(typeDescription);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, instrumentationContext);
-        assertThat(size.getMaximalSize(), is(stackSize.getSize()));
         assertThat(size.getSizeImpact(), is(stackSize.getSize()));
+        assertThat(size.getMaximalSize(), is(stackSize.getSize()));
         if (stackSize != StackSize.ZERO) {
             verify(methodVisitor).visitInsn(opcode);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolver.java
Patch:
@@ -268,7 +268,7 @@ public int hashCode() {
 
             @Override
             public String toString() {
-                return "MethodRebaseResolver.Resolution.ForRedefinedMethod{methodDescription=" + methodDescription + '}';
+                return "MethodRebaseResolver.Resolution.ForRebasedMethod{methodDescription=" + methodDescription + '}';
             }
         }
 
@@ -326,7 +326,7 @@ public int hashCode() {
 
             @Override
             public String toString() {
-                return "MethodRebaseResolver.Resolution.ForRedefinedConstructor{methodDescription=" + methodDescription + '}';
+                return "MethodRebaseResolver.Resolution.ForRebasedConstructor{methodDescription=" + methodDescription + '}';
             }
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/MethodLookupEngine.java
Patch:
@@ -153,7 +153,7 @@ public int hashCode() {
             public String toString() {
                 return "MethodLookupEngine.Finding.Default{" +
                         "lookedUpType=" + lookedUpType +
-                        ", defaultMethods=" + invokableMethods +
+                        ", invokableMethods=" + invokableMethods +
                         ", invokableDefaultMethods=" + invokableDefaultMethods +
                         '}';
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -2466,7 +2466,7 @@ public String toString() {
             return "DynamicType.Default{" +
                     "typeDescription='" + typeDescription + '\'' +
                     ", binaryRepresentation=" + Arrays.toString(binaryRepresentation) +
-                    ", typeInitializer=" + loadedTypeInitializer +
+                    ", loadedTypeInitializer=" + loadedTypeInitializer +
                     ", auxiliaryTypes=" + auxiliaryTypes +
                     '}';
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentationTarget.java
Patch:
@@ -168,7 +168,7 @@ public int hashCode() {
         public String toString() {
             return "SubclassInstrumentationTarget.Factory{" +
                     "bridgeMethodResolverFactory=" + bridgeMethodResolverFactory +
-                    "targetTypeIdentifier=" + originTypeIdentifier +
+                    "originTypeIdentifier=" + originTypeIdentifier +
                     '}';
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/Instrumentation.java
Patch:
@@ -1362,7 +1362,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return "Instrumentation.Compound{" + Arrays.toString(instrumentation) + '}';
+            return "Instrumentation.Compound{instrumentation=" + Arrays.toString(instrumentation) + '}';
         }
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/LoadedTypeInitializer.java
Patch:
@@ -219,7 +219,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return "LoadedTypeInitializer.Compound{typeInitializer=" + Arrays.toString(loadedTypeInitializer) + '}';
+            return "LoadedTypeInitializer.Compound{loadedTypeInitializer=" + Arrays.toString(loadedTypeInitializer) + '}';
         }
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/FieldAttributeAppender.java
Patch:
@@ -103,7 +103,7 @@ public int hashCode() {
 
             @Override
             public String toString() {
-                return "FieldAttributeAppender.Factory.Compound{" + Arrays.toString(factory) + '}';
+                return "FieldAttributeAppender.Factory.Compound{factory=" + Arrays.toString(factory) + '}';
             }
         }
     }
@@ -251,7 +251,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return "FieldAttributeAppender.Compound{" + Arrays.toString(fieldAttributeAppender) + '}';
+            return "FieldAttributeAppender.Compound{fieldAttributeAppender=" + Arrays.toString(fieldAttributeAppender) + '}';
         }
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/MethodAttributeAppender.java
Patch:
@@ -139,7 +139,7 @@ public int hashCode() {
 
             @Override
             public String toString() {
-                return "MethodAttributeAppender.Factory.Compound{" + Arrays.toString(factory) + '}';
+                return "MethodAttributeAppender.Factory.Compound{factory=" + Arrays.toString(factory) + '}';
             }
         }
     }
@@ -441,7 +441,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return "MethodAttributeAppender.Compound{" + Arrays.toString(methodAttributeAppender) + '}';
+            return "MethodAttributeAppender.Compound{methodAttributeAppender=" + Arrays.toString(methodAttributeAppender) + '}';
         }
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/TypeAttributeAppender.java
Patch:
@@ -199,7 +199,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return "TypeAttributeAppender.Compound{" + Arrays.toString(typeAttributeAppender) + '}';
+            return "TypeAttributeAppender.Compound{typeAttributeAppender=" + Arrays.toString(typeAttributeAppender) + '}';
         }
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/ByteCodeAppender.java
Patch:
@@ -164,7 +164,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return "ByteCodeAppender.Compound{" + Arrays.toString(byteCodeAppender) + '}';
+            return "ByteCodeAppender.Compound{byteCodeAppender=" + Arrays.toString(byteCodeAppender) + '}';
         }
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/StackManipulation.java
Patch:
@@ -209,7 +209,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return "StackManipulation.Compound{" + Arrays.asList(stackManipulation) + "}";
+            return "StackManipulation.Compound{stackManipulation=" + Arrays.asList(stackManipulation) + "}";
         }
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveTypeAwareAssigner.java
Patch:
@@ -63,6 +63,6 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return "PrimitiveTypeAwareAssigner{chained=" + referenceTypeAwareAssigner + '}';
+        return "PrimitiveTypeAwareAssigner{referenceTypeAwareAssigner=" + referenceTypeAwareAssigner + '}';
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveUnboxingDelegate.java
Patch:
@@ -183,7 +183,7 @@ public Size apply(MethodVisitor methodVisitor, Instrumentation.Context instrumen
     /**
      * An explicitly types unboxing responsible is applied for directly unboxing a wrapper type.
      */
-    private static enum ExplicitlyTypedUnboxingResponsible implements UnboxingResponsible {
+    protected static enum ExplicitlyTypedUnboxingResponsible implements UnboxingResponsible {
 
         /**
          * An unboxing responsible for unboxing a {@link java.lang.Boolean} type.
@@ -277,7 +277,7 @@ public static interface UnboxingResponsible {
      * were not found to be of a given wrapper type. Instead, this unboxing responsible tries to assign the
      * source type to the primitive target type's wrapper type before performing an unboxing operation.
      */
-    private static class ImplicitlyTypedUnboxingResponsible implements UnboxingResponsible {
+    protected static class ImplicitlyTypedUnboxingResponsible implements UnboxingResponsible {
 
         /**
          * The original type which should be unboxed but is not of any known wrapper type.
@@ -289,7 +289,7 @@ private static class ImplicitlyTypedUnboxingResponsible implements UnboxingRespo
          *
          * @param originalType The original type which should be unboxed but is not of any known wrapper type.
          */
-        private ImplicitlyTypedUnboxingResponsible(TypeDescription originalType) {
+        protected ImplicitlyTypedUnboxingResponsible(TypeDescription originalType) {
             this.originalType = originalType;
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveWideningDelegate.java
Patch:
@@ -246,7 +246,7 @@ public StackManipulation widenTo(TypeDescription typeDescription) {
     /**
      * A stack manipulation that widens a primitive type into a more general primitive type.
      */
-    private static class WideningStackManipulation implements StackManipulation {
+    protected static class WideningStackManipulation implements StackManipulation {
 
         /**
          * The opcode for executing the conversion.
@@ -264,7 +264,7 @@ private static class WideningStackManipulation implements StackManipulation {
          * @param conversionOpcode The opcode for executing the conversion.
          * @param size             The size change of applying the conversion.
          */
-        public WideningStackManipulation(int conversionOpcode, Size size) {
+        protected WideningStackManipulation(int conversionOpcode, Size size) {
             this.conversionOpcode = conversionOpcode;
             this.size = size;
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/constant/ClassConstant.java
Patch:
@@ -131,7 +131,7 @@ public Size apply(MethodVisitor methodVisitor, Instrumentation.Context instrumen
     /**
      * A class constant for a non-primitive {@link java.lang.Class}.
      */
-    private static class ForReferenceType implements StackManipulation {
+    protected static class ForReferenceType implements StackManipulation {
 
         /**
          * The type which should be loaded onto the operand stack as a class value.
@@ -143,7 +143,7 @@ private static class ForReferenceType implements StackManipulation {
          *
          * @param typeDescription A description of the class to load onto the stack.
          */
-        private ForReferenceType(TypeDescription typeDescription) {
+        protected ForReferenceType(TypeDescription typeDescription) {
             this.typeDescription = typeDescription;
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/constant/DoubleConstant.java
Patch:
@@ -72,7 +72,7 @@ public StackManipulation.Size apply(MethodVisitor methodVisitor, Instrumentation
     /**
      * A stack manipulation for loading a {@code double} value from a class's constant pool onto the operand stack.
      */
-    private static class ConstantPool implements StackManipulation {
+    protected static class ConstantPool implements StackManipulation {
 
         /**
          * The {@code double} value to be loaded onto the operand stack.
@@ -84,7 +84,7 @@ private static class ConstantPool implements StackManipulation {
          *
          * @param value The {@code double} value to be loaded onto the operand stack.
          */
-        private ConstantPool(double value) {
+        protected ConstantPool(double value) {
             this.value = value;
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/constant/FloatConstant.java
Patch:
@@ -79,7 +79,7 @@ public Size apply(MethodVisitor methodVisitor, Instrumentation.Context instrumen
     /**
      * A stack manipulation for loading a {@code float} value from a class's constant pool onto the operand stack.
      */
-    private static class ConstantPool implements StackManipulation {
+    protected static class ConstantPool implements StackManipulation {
 
         /**
          * The {@code float} value to be loaded onto the operand stack.
@@ -91,7 +91,7 @@ private static class ConstantPool implements StackManipulation {
          *
          * @param value The {@code float} value to be loaded onto the operand stack.
          */
-        private ConstantPool(float value) {
+        protected ConstantPool(float value) {
             this.value = value;
         }
 
@@ -119,7 +119,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return "ConstantPool.ConstantPool{value=" + value + '}';
+            return "FloatConstant.ConstantPool{value=" + value + '}';
         }
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/constant/LongConstant.java
Patch:
@@ -72,7 +72,7 @@ public Size apply(MethodVisitor methodVisitor, Instrumentation.Context instrumen
     /**
      * A stack manipulation for loading a {@code long} value from a class's constant pool onto the operand stack.
      */
-    private static class ConstantPool implements StackManipulation {
+    protected static class ConstantPool implements StackManipulation {
 
         /**
          * The {@code long} value to be loaded onto the operand stack.
@@ -84,7 +84,7 @@ private static class ConstantPool implements StackManipulation {
          *
          * @param value The {@code long} value to be loaded onto the operand stack.
          */
-        private ConstantPool(long value) {
+        protected ConstantPool(long value) {
             this.value = value;
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/constant/TextConstant.java
Patch:
@@ -53,6 +53,6 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return "TextConstant{'" + text + '\'' + '}';
+        return "TextConstant{text='" + text + '\'' + '}';
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/member/MethodVariableAccess.java
Patch:
@@ -251,7 +251,7 @@ public String toString() {
     /**
      * A stack manipulation for loading a variable of a method's local variable array onto the operand stack.
      */
-    private class ArgumentLoadingStackManipulation implements StackManipulation {
+    protected class ArgumentLoadingStackManipulation implements StackManipulation {
 
         /**
          * The index of the local variable array from which the variable should be loaded.

File: byte-buddy-dep/src/test/java/net/bytebuddy/ClassFileVersionTest.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 import org.objectweb.asm.Opcodes;
 
@@ -38,7 +38,7 @@ public void testComparison() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(ClassFileVersion.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(ClassFileVersion.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/NamingStrategyUnnamedTypeDefaultTest.java
Patch:
@@ -4,7 +4,7 @@
 import net.bytebuddy.modifier.SyntheticState;
 import net.bytebuddy.modifier.TypeManifestation;
 import net.bytebuddy.modifier.Visibility;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -85,7 +85,7 @@ public void testTypeManifestationProperty() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(NamingStrategy.UnnamedType.Default.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(NamingStrategy.UnnamedType.Default.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassLoadingStrategyDefaultProtectionDomainInjectionTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.utility.ClassFileExtraction;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -42,8 +42,8 @@ public void testProtectionDomainInjection() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(ClassLoadingStrategy.Default.ProtectionDomainInjection.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(ClassLoadingStrategy.Default.ProtectionDomainInjection.class).apply();
     }
 
     private static class Foo {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/ClassLoadingStrategyDefaultProtectionDomainWrapperTest.java
Patch:
@@ -3,7 +3,7 @@
 import net.bytebuddy.dynamic.loading.ByteArrayClassLoader;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.utility.ClassFileExtraction;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -44,8 +44,8 @@ public void testProtectionDomainInjection() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(ClassLoadingStrategy.Default.ProtectionDomainWrapper.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(ClassLoadingStrategy.Default.ProtectionDomainWrapper.class).apply();
     }
 
     private static class Foo {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/DynamicTypeDefaultLoadedTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.instrumentation.LoadedTypeInitializer;
 import net.bytebuddy.instrumentation.type.TypeDescription;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -59,7 +59,7 @@ public void testLoadedTypeDescription() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(DynamicType.Default.Loaded.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(DynamicType.Default.Loaded.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/DynamicTypeDefaultTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.instrumentation.LoadedTypeInitializer;
 import net.bytebuddy.instrumentation.type.TypeDescription;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import net.bytebuddy.utility.RandomString;
 import org.junit.Before;
@@ -256,6 +256,6 @@ public void testJarSelfInjection() throws Exception {
 
     @Test
     public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(DynamicType.Default.class).apply();
+        ObjectPropertyAssertion.of(DynamicType.Default.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/DynamicTypeDefaultUnloadedTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.instrumentation.LoadedTypeInitializer;
 import net.bytebuddy.instrumentation.type.TypeDescription;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -83,7 +83,7 @@ public void testTypeLoading() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(DynamicType.Default.Unloaded.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(DynamicType.Default.Unloaded.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ClassReloadingStrategyNonAttachedTest.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.dynamic.loading;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 import java.lang.instrument.Instrumentation;
@@ -16,8 +16,8 @@ public void testNonCompatible() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(ClassReloadingStrategy.class).refine(new HashCodeEqualsTester.Refinement<Instrumentation>() {
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(ClassReloadingStrategy.class).refine(new ObjectPropertyAssertion.Refinement<Instrumentation>() {
             @Override
             public void apply(Instrumentation mock) {
                 when(mock.isRedefineClassesSupported()).thenReturn(true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/MethodRegistryLatentMethodMatcherSimpleTest.java
Patch:
@@ -1,12 +1,12 @@
 package net.bytebuddy.dynamic.scaffold;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 public class MethodRegistryLatentMethodMatcherSimpleTest {
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(MethodRegistry.LatentMethodMatcher.Simple.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(MethodRegistry.LatentMethodMatcher.Simple.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultTest.java
Patch:
@@ -5,7 +5,7 @@
 import net.bytebuddy.instrumentation.Instrumentation;
 import net.bytebuddy.instrumentation.LoadedTypeInitializer;
 import net.bytebuddy.instrumentation.type.TypeDescription;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -64,7 +64,7 @@ public void testDynamicTypeCreation() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(TypeWriter.Default.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(TypeWriter.Default.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterEngineForCreationTest.java
Patch:
@@ -9,7 +9,7 @@
 import net.bytebuddy.instrumentation.method.MethodDescription;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.instrumentation.type.TypeList;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -116,7 +116,7 @@ public void testTypeWriting() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(TypeWriter.Engine.ForCreation.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(TypeWriter.Engine.ForCreation.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterEngineForRedefinitionTest.java
Patch:
@@ -13,7 +13,7 @@
 import net.bytebuddy.instrumentation.method.bytecode.ByteCodeAppender;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.instrumentation.type.TypeList;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -267,8 +267,8 @@ public void testTypeCreationWithoutRebase() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(TypeWriter.Engine.ForRedefinition.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(TypeWriter.Engine.ForRedefinition.class).apply();
     }
 
     @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterFieldPoolEntryTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.instrumentation.attribute.FieldAttributeAppender;
 import net.bytebuddy.instrumentation.field.FieldDescription;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -71,7 +71,7 @@ public void testSimpleEntryWritesField() throws Exception {
 
     @Test
     public void testSimpleEntryEntryHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(TypeWriter.FieldPool.Entry.Simple.class).apply();
+        ObjectPropertyAssertion.of(TypeWriter.FieldPool.Entry.Simple.class).apply();
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterMethodPoolEntryTest.java
Patch:
@@ -5,7 +5,7 @@
 import net.bytebuddy.instrumentation.method.MethodDescription;
 import net.bytebuddy.instrumentation.method.bytecode.ByteCodeAppender;
 import net.bytebuddy.instrumentation.type.TypeList;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -107,7 +107,7 @@ public void testSimpleEntryDoesNotAppendCode() throws Exception {
 
     @Test
     public void testSimpleEntryHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(TypeWriter.MethodPool.Entry.Simple.class).apply();
+        ObjectPropertyAssertion.of(TypeWriter.MethodPool.Entry.Simple.class).apply();
     }
 
     @Test

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/ClassFileLocatorAgentBasedNonAttachedTest.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.dynamic.scaffold.inline;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 import java.lang.instrument.Instrumentation;
@@ -16,8 +16,8 @@ public void testNonCompatible() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(ClassFileLocator.AgentBased.class).refine(new HashCodeEqualsTester.Refinement<Instrumentation>() {
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(ClassFileLocator.AgentBased.class).refine(new ObjectPropertyAssertion.Refinement<Instrumentation>() {
             @Override
             public void apply(Instrumentation mock) {
                 when(mock.isRetransformClassesSupported()).thenReturn(true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/ClassFileLocatorCompoundTest.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.dynamic.scaffold.inline;
 
 import net.bytebuddy.instrumentation.type.TypeDescription;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Rule;
 import org.junit.Test;
@@ -46,7 +46,7 @@ public void testApplicationOrderDoesNotCallSecond() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(ClassFileLocator.Compound.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(ClassFileLocator.Compound.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/InlineDynamicTypeBuilderTest.java
Patch:
@@ -22,7 +22,7 @@
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.instrumentation.type.TypeList;
 import net.bytebuddy.modifier.Visibility;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -521,8 +521,8 @@ public void testRedefinitionWithDefinedAbstractMethod() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(InlineDynamicTypeBuilder.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(InlineDynamicTypeBuilder.class).apply();
     }
 
     @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverDefaultTest.java
Patch:
@@ -6,7 +6,7 @@
 import net.bytebuddy.instrumentation.method.matcher.MethodMatcher;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.instrumentation.type.TypeList;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -164,7 +164,7 @@ public void testIgnoredMethodIsNotRebased() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(MethodRebaseResolver.Default.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(MethodRebaseResolver.Default.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverMethodNameTransformerSuffixingTest.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.dynamic.scaffold.inline;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.RandomString;
 import org.junit.Test;
 
@@ -23,8 +23,8 @@ public void testTransformation() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(MethodRebaseResolver.MethodNameTransformer.Suffixing.class).refine(new HashCodeEqualsTester.Refinement<RandomString>() {
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(MethodRebaseResolver.MethodNameTransformer.Suffixing.class).refine(new ObjectPropertyAssertion.Refinement<RandomString>() {
             @Override
             public void apply(RandomString mock) {
                 when(mock.nextString()).thenReturn("" + new Random().nextInt());

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/MethodRebaseResolverResolutionPreservedTest.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.dynamic.scaffold.inline;
 
 import net.bytebuddy.instrumentation.method.MethodDescription;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Rule;
 import org.junit.Test;
@@ -34,7 +34,7 @@ public void testPreservation() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(MethodRebaseResolver.Resolution.Preserved.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(MethodRebaseResolver.Resolution.Preserved.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseInstrumentationTargetFactoryTest.java
Patch:
@@ -6,7 +6,7 @@
 import net.bytebuddy.instrumentation.method.MethodList;
 import net.bytebuddy.instrumentation.method.MethodLookupEngine;
 import net.bytebuddy.instrumentation.type.TypeDescription;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -53,7 +53,7 @@ public void testReturnsRebaseInstrumentationTarget() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(RebaseInstrumentationTarget.Factory.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(RebaseInstrumentationTarget.Factory.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderTest.java
Patch:
@@ -23,7 +23,7 @@
 import net.bytebuddy.instrumentation.type.TypeList;
 import net.bytebuddy.modifier.Ownership;
 import net.bytebuddy.modifier.Visibility;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -564,8 +564,8 @@ public void testInterceptTypeInitializerWithFieldCache() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(SubclassDynamicTypeBuilder.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(SubclassDynamicTypeBuilder.class).apply();
     }
 
     public static class Foo {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentationTargetFactoryTest.java
Patch:
@@ -6,7 +6,7 @@
 import net.bytebuddy.instrumentation.method.MethodList;
 import net.bytebuddy.instrumentation.method.MethodLookupEngine;
 import net.bytebuddy.instrumentation.type.TypeDescription;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -66,7 +66,7 @@ public void testOriginTypeLevelType() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(SubclassInstrumentationTarget.Factory.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(SubclassInstrumentationTarget.Factory.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/ExceptionMethodTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.utility.CallTraceable;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 import static org.hamcrest.CoreMatchers.*;
@@ -72,7 +72,7 @@ public void testWithNonDeclaredCheckedException() throws Exception {
 
     @Test
     public void testEqualsHashCode() throws Exception {
-        HashCodeEqualsTester.of(ExceptionMethod.class).apply();
+        ObjectPropertyAssertion.of(ExceptionMethod.class).apply();
     }
 
     public static class Foo extends CallTraceable {

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/ForwardingTest.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.instrumentation;
 
 import net.bytebuddy.dynamic.DynamicType;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 import java.lang.reflect.Field;
@@ -58,8 +58,8 @@ public void testStaticFieldDelegation() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(Forwarding.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(Forwarding.class).apply();
     }
 
     @Test(expected = IllegalArgumentException.class)

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/InstrumentationCompoundTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.instrumentation.method.bytecode.ByteCodeAppender;
 import net.bytebuddy.instrumentation.type.InstrumentedType;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -59,7 +59,7 @@ public void testAppend() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(Instrumentation.Compound.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(Instrumentation.Compound.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/InstrumentationSimpleTest.java
Patch:
@@ -1,12 +1,12 @@
 package net.bytebuddy.instrumentation;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 public class InstrumentationSimpleTest {
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(Instrumentation.Simple.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(Instrumentation.Simple.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/LoadedTypeInitializerForStaticFieldTest.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.instrumentation;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 import static org.hamcrest.CoreMatchers.is;
@@ -37,8 +37,8 @@ public void testNonAccessibleFieldThrowsException() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(LoadedTypeInitializer.ForStaticField.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(LoadedTypeInitializer.ForStaticField.class).apply();
     }
 
     @SuppressWarnings("unused")

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/FieldAttributeAppenderCompoundTest.java
Patch:
@@ -1,12 +1,12 @@
 package net.bytebuddy.instrumentation.attribute;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 public class FieldAttributeAppenderCompoundTest {
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(FieldAttributeAppender.Compound.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(FieldAttributeAppender.Compound.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/FieldAttributeAppenderFactoryCompoundTest.java
Patch:
@@ -1,12 +1,12 @@
 package net.bytebuddy.instrumentation.attribute;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 public class FieldAttributeAppenderFactoryCompoundTest {
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(FieldAttributeAppender.Factory.Compound.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(FieldAttributeAppender.Factory.Compound.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/MethodAttributeAppenderCompoundTest.java
Patch:
@@ -1,12 +1,12 @@
 package net.bytebuddy.instrumentation.attribute;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 public class MethodAttributeAppenderCompoundTest {
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(MethodAttributeAppender.Compound.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(MethodAttributeAppender.Compound.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/MethodAttributeAppenderFactoryCompoundTest.java
Patch:
@@ -1,12 +1,12 @@
 package net.bytebuddy.instrumentation.attribute;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 public class MethodAttributeAppenderFactoryCompoundTest {
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(MethodAttributeAppender.Factory.Compound.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(MethodAttributeAppender.Factory.Compound.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/TypeAttributeAppenderCompoundTest.java
Patch:
@@ -1,12 +1,12 @@
 package net.bytebuddy.instrumentation.attribute;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 public class TypeAttributeAppenderCompoundTest {
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(TypeAttributeAppender.Compound.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(TypeAttributeAppender.Compound.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/annotation/AnnotationAppenderDefaultTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.dynamic.loading.ByteArrayClassLoader;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -132,8 +132,8 @@ private Class<?> makeTypeWithAnnotation(Annotation annotation) throws Exception
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(AnnotationAppender.Default.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(AnnotationAppender.Default.class).apply();
     }
 
     @Retention(RetentionPolicy.RUNTIME)

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/MethodLookupEngineDefaultTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.instrumentation.method.matcher.MethodMatcher;
 import net.bytebuddy.instrumentation.type.TypeDescription;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.JavaVersionRule;
 import net.bytebuddy.utility.PrecompiledTypeClassLoader;
 import org.hamcrest.CoreMatchers;
@@ -384,8 +384,8 @@ public void testAmbiguousManifestOverridingDefaultMethodLookup() throws Exceptio
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(MethodLookupEngine.Default.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(MethodLookupEngine.Default.class).apply();
     }
 
     private static interface SingleMethodInterface {

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/ByteCodeAppenderCompoundTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.instrumentation.Instrumentation;
 import net.bytebuddy.instrumentation.method.MethodDescription;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -62,7 +62,7 @@ public void testApplication() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(ByteCodeAppender.Compound.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(ByteCodeAppender.Compound.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/ByteCodeAppenderSimpleTest.java
Patch:
@@ -3,7 +3,7 @@
 import net.bytebuddy.instrumentation.Instrumentation;
 import net.bytebuddy.instrumentation.method.MethodDescription;
 import net.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -56,7 +56,7 @@ public void testApplication() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(ByteCodeAppender.Simple.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(ByteCodeAppender.Simple.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/ByteCodeAppenderSizeTest.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.instrumentation.method.bytecode;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 import static org.hamcrest.CoreMatchers.equalTo;
@@ -23,7 +23,7 @@ public void testMerge() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(ByteCodeAppender.Size.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(ByteCodeAppender.Size.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/AmbiguityResolverChainTest.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.instrumentation.method.bytecode.bind;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -45,6 +45,6 @@ public void testSecondResolves() throws Exception {
 
     @Test
     public void testEqualsHashCode() throws Exception {
-        HashCodeEqualsTester.of(MethodDelegationBinder.AmbiguityResolver.Chain.class).apply();
+        ObjectPropertyAssertion.of(MethodDelegationBinder.AmbiguityResolver.Chain.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/MethodDelegationBinderProcessorTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.instrumentation.Instrumentation;
 import net.bytebuddy.instrumentation.method.MethodDescription;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -145,7 +145,7 @@ public void testThreeBindableTargetsDominantBindableLast() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(MethodDelegationBinder.Processor.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(MethodDelegationBinder.Processor.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/StackManipulationCompoundTest.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.instrumentation.method.bytecode.stack;
 
 import net.bytebuddy.instrumentation.Instrumentation;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Rule;
 import org.junit.Test;
@@ -61,7 +61,7 @@ public void testApplication() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(StackManipulation.Compound.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(StackManipulation.Compound.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/StackManipulationSizeTest.java
Patch:
@@ -1,6 +1,6 @@
 package net.bytebuddy.instrumentation.method.bytecode.stack;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -36,7 +36,7 @@ public void testSizeGrowthAndReduction() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(StackManipulation.Size.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(StackManipulation.Size.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/TypeCreationTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.instrumentation.Instrumentation;
 import net.bytebuddy.instrumentation.type.TypeDescription;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
 import org.junit.Rule;
@@ -60,7 +60,7 @@ public void testTypeCreationAbstract() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(TypeCreation.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(TypeCreation.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/assign/reference/DownCastingTest.java
Patch:
@@ -3,7 +3,7 @@
 import net.bytebuddy.instrumentation.Instrumentation;
 import net.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import net.bytebuddy.instrumentation.type.TypeDescription;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Rule;
 import org.junit.Test;
@@ -50,8 +50,8 @@ public void testPrimitiveCastingThrowsException() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(DownCasting.class).refine(new HashCodeEqualsTester.Refinement<TypeDescription>() {
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(DownCasting.class).refine(new ObjectPropertyAssertion.Refinement<TypeDescription>() {
             @Override
             public void apply(TypeDescription mock) {
                 when((mock).getInternalName()).thenReturn(FOO + new Random().nextInt());

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/constant/TextConstantTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.bytebuddy.instrumentation.Instrumentation;
 import net.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Rule;
 import org.junit.Test;
@@ -37,7 +37,7 @@ public void testTextValue() throws Exception {
     }
 
     @Test
-    public void testHashCodeEquals() throws Exception {
-        HashCodeEqualsTester.of(TextConstant.class).apply();
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(TextConstant.class).apply();
     }
 }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/type/auxiliary/MethodCallProxyEqualsHashCodeTest.java
Patch:
@@ -1,17 +1,17 @@
 package net.bytebuddy.instrumentation.type.auxiliary;
 
-import net.bytebuddy.utility.HashCodeEqualsTester;
+import net.bytebuddy.utility.ObjectPropertyAssertion;
 import org.junit.Test;
 
 public class MethodCallProxyEqualsHashCodeTest {
 
     @Test
     public void testEqualsHashCode() throws Exception {
-        HashCodeEqualsTester.of(MethodCallProxy.class).apply();
+        ObjectPropertyAssertion.of(MethodCallProxy.class).apply();
     }
 
     @Test
     public void testAssignableSignatureCallEqualsHashCode() throws Exception {
-        HashCodeEqualsTester.of(MethodCallProxy.AssignableSignatureCall.class).apply();
+        ObjectPropertyAssertion.of(MethodCallProxy.AssignableSignatureCall.class).apply();
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/FieldAttributeAppender.java
Patch:
@@ -183,7 +183,7 @@ public ForLoadedField(Field field) {
         public void apply(FieldVisitor fieldVisitor, FieldDescription fieldDescription) {
             AnnotationAppender annotationAppender =
                     new AnnotationAppender.Default(new AnnotationAppender.Target.OnField(fieldVisitor));
-            for (AnnotationDescription annotation : fieldDescription.getDeclaredAnnotations()) {
+            for (AnnotationDescription annotation : this.fieldDescription.getDeclaredAnnotations()) {
                 annotationAppender.append(annotation, AnnotationAppender.AnnotationVisibility.RUNTIME);
             }
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/annotation/AnnotationDescription.java
Patch:
@@ -164,11 +164,11 @@ public Object getValue(MethodDescription methodDescription) {
                         ? ((MethodDescription.ForLoadedMethod) methodDescription).getLoadedMethod()
                         : annotation.annotationType().getDeclaredMethod(methodDescription.getName())).invoke(annotation)).apply();
             } catch (IllegalAccessException e) {
-                throw new IllegalStateException("Cannot access enum property " + methodDescription, e);
+                throw new IllegalStateException("Cannot access annotation property " + methodDescription, e);
             } catch (InvocationTargetException e) {
-                throw new IllegalArgumentException("Error on accessing enum property " + methodDescription, e);
+                throw new IllegalArgumentException("Error on accessing annotation property " + methodDescription, e);
             } catch (NoSuchMethodException e) {
-                throw new IllegalArgumentException("Cannot invoke property on enum " + methodDescription, e);
+                throw new IllegalArgumentException("Cannot invoke property on annotation " + methodDescription, e);
             }
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -70,8 +70,8 @@ public MethodBinding bind(Instrumentation.Target instrumentationTarget,
         if (IgnoreForBinding.Verifier.check(target)) {
             return MethodBinding.Illegal.INSTANCE;
         }
-        StackManipulation returningStackManipulation = terminationHandler.resolve(assigner, source, target);
-        if (!returningStackManipulation.isValid()) {
+        StackManipulation methodTermination = terminationHandler.resolve(assigner, source, target);
+        if (!methodTermination.isValid()) {
             return MethodBinding.Illegal.INSTANCE;
         }
         MethodBinding.Builder methodDelegationBindingBuilder = new MethodBinding.Builder(methodInvoker, target);
@@ -90,7 +90,7 @@ public MethodBinding bind(Instrumentation.Target instrumentationTarget,
                 return MethodBinding.Illegal.INSTANCE;
             }
         }
-        return methodDelegationBindingBuilder.build(returningStackManipulation);
+        return methodDelegationBindingBuilder.build(methodTermination);
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/auxiliary/TypeProxy.java
Patch:
@@ -116,13 +116,15 @@ public boolean equals(Object other) {
         return ignoreFinalizer == typeProxy.ignoreFinalizer
                 && serializableProxy == typeProxy.serializableProxy
                 && instrumentationTarget.equals(typeProxy.instrumentationTarget)
+                && invocationFactory.equals(typeProxy.invocationFactory)
                 && proxiedType.equals(typeProxy.proxiedType);
     }
 
     @Override
     public int hashCode() {
         int result = proxiedType.hashCode();
         result = 31 * result + instrumentationTarget.hashCode();
+        result = 31 * result + invocationFactory.hashCode();
         result = 31 * result + (ignoreFinalizer ? 1 : 0);
         result = 31 * result + (serializableProxy ? 1 : 0);
         return result;
@@ -133,6 +135,7 @@ public String toString() {
         return "TypeProxy{" +
                 "proxiedType=" + proxiedType +
                 ", instrumentationTarget=" + instrumentationTarget +
+                ", invocationFactory=" + invocationFactory +
                 ", ignoreFinalizer=" + ignoreFinalizer +
                 ", serializableProxy=" + serializableProxy +
                 '}';

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/AllArgumentsBinderTest.java
Patch:
@@ -54,6 +54,7 @@ public void testLegalStrictBindingRuntimeType() throws Exception {
     @Test
     public void testLegalStrictBindingNoRuntimeType() throws Exception {
         RuntimeType runtimeType = mock(RuntimeType.class);
+        doReturn(RuntimeType.class).when(runtimeType).annotationType();
         when(target.getParameterAnnotations()).thenReturn(AnnotationList.ForLoadedAnnotation.asList(new Annotation[][]{{}, {runtimeType}}));
         testLegalStrictBinding(new Annotation[][]{{}, {runtimeType}}, true);
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/type/auxiliary/TypeProxyTest.java
Patch:
@@ -99,6 +99,7 @@ private <T> Class<T> makeProxyType(Class<T> proxyType, Class<?> instrumentedType
         DynamicType dynamicType = new TypeProxy(
                 new TypeDescription.ForLoadedType(proxyType),
                 instrumentationTarget,
+                TypeProxy.InvocationFactory.ForSuperMethodCall.INSTANCE,
                 true,
                 false).make(auxiliaryTypeName, ClassFileVersion.forCurrentJavaVersion(), methodAccessorFactory);
         DynamicType.Unloaded<?> unloaded = (DynamicType.Unloaded<?>) dynamicType;

File: byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java
Patch:
@@ -1259,7 +1259,7 @@ public Object getValue(MethodDescription methodDescription) {
 
             @Override
             public TypeDescription getAnnotationType() {
-                return typePool.describe(annotationDescriptor);
+                return typePool.describe(annotationDescriptor.substring(1, annotationDescriptor.length() - 1).replace('/', '.'));
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/annotation/AnnotationAppender.java
Patch:
@@ -323,7 +323,7 @@ private void apply(AnnotationVisitor annotationVisitor, TypeDescription valueTyp
             if (valueType.isAnnotation()) {
                 handle(annotationVisitor.visitAnnotation(name, valueType.getDescriptor()), (AnnotationDescription) value);
             } else if (valueType.isEnum()) {
-                annotationVisitor.visitEnum(name, valueType.getDescriptor(), ((AnnotationDescription.EnumerationValue) value).getName());
+                annotationVisitor.visitEnum(name, valueType.getDescriptor(), ((AnnotationDescription.EnumerationValue) value).getValue());
             } else if (valueType.isAssignableFrom(Class.class)) {
                 annotationVisitor.visit(name, Type.getType(((TypeDescription) value).getDescriptor()));
             } else if (valueType.isArray()) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Argument.java
Patch:
@@ -200,7 +200,6 @@ private static Iterator<Integer> makeFreeIndexList(MethodDescription source, Met
                 AnnotationDescription.Loadable<Argument> annotation = parameterAnnotations.ofType(Argument.class);
                 if (annotation != null) {
                     results.remove(annotation.load().value());
-                    break;
                 }
             }
             return results.iterator();

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/annotation/AnnotationList.java
Patch:
@@ -32,7 +32,7 @@ public ForLoadedAnnotation(Annotation[] annotation) {
 
         @Override
         public AnnotationDescription get(int index) {
-            return null;
+            return AnnotationDescription.ForLoadedAnnotation.of(annotation[index]);
         }
 
         @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/NextUnboundAsDefaultBinderTest.java
Patch:
@@ -112,7 +112,8 @@ public void testFullyAnnotatedUnordered() throws Exception {
         Argument indexOneArgument = mock(Argument.class);
         when(indexOneArgument.value()).thenReturn(1);
         doReturn(Argument.class).when(indexOneArgument).annotationType();
-        when(target.getParameterAnnotations()).thenReturn(AnnotationList.ForLoadedAnnotation.asList(new Annotation[][]{{indexOneArgument}, {indexZeroArgument}}));
+        when(target.getParameterAnnotations()).thenReturn(AnnotationList.ForLoadedAnnotation
+                .asList(new Annotation[][]{{indexOneArgument}, {indexZeroArgument}}));
         Iterator<AnnotationDescription> iterator = Argument.NextUnboundAsDefaultsProvider.INSTANCE
                 .makeIterator(instrumentationTarget, source, target);
         assertThat(iterator.hasNext(), is(false));

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/TypeAttributeAppenderForSuperTypeTest.java
Patch:
@@ -1,5 +1,6 @@
 package net.bytebuddy.instrumentation.attribute;
 
+import net.bytebuddy.instrumentation.attribute.annotation.AnnotationList;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -17,7 +18,8 @@ public class TypeAttributeAppenderForSuperTypeTest extends AbstractTypeAttribute
     @Test
     public void testSuperTypeAnnotationAppender() throws Exception {
         when(typeDescription.getSupertype()).thenReturn(superType);
-        when(superType.getAnnotations()).thenReturn(new Annotation[]{new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()});
+        when(superType.getDeclaredAnnotations()).thenReturn(new AnnotationList
+                .ForLoadedAnnotation(new Annotation[]{new Qux.Instance(), new Baz.Instance(), new QuxBaz.Instance()}));
         TypeAttributeAppender.ForSuperType.INSTANCE.apply(classVisitor, typeDescription);
         verify(classVisitor).visitAnnotation(Type.getDescriptor(Baz.class), true);
         verify(classVisitor).visitAnnotation(Type.getDescriptor(QuxBaz.class), false);

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/attribute/annotation/AnnotationAppenderDefaultTest.java
Patch:
@@ -103,8 +103,9 @@ private Class<?> makeTypeWithAnnotation(Annotation annotation) throws Exception
                 null);
         AnnotationVisitor annotationVisitor = classWriter.visitAnnotation(Type.getDescriptor(annotation.annotationType()), true);
         when(target.visit(any(String.class), anyBoolean())).thenReturn(annotationVisitor);
-        AnnotationAppender.AnnotationVisibility annotationVisibility = AnnotationAppender.AnnotationVisibility.of(annotation);
-        annotationAppender.append(annotation, annotationVisibility);
+        AnnotationDescription annotationDescription = AnnotationDescription.ForLoadedAnnotation.of(annotation);
+        AnnotationAppender.AnnotationVisibility annotationVisibility = AnnotationAppender.AnnotationVisibility.of(annotationDescription);
+        annotationAppender.append(annotationDescription, annotationVisibility);
         switch (annotationVisibility) {
             case RUNTIME:
                 verify(target).visit(Type.getDescriptor(annotation.annotationType()), true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/PipeBinderTest.java
Patch:
@@ -44,7 +44,7 @@ public void testAnnotationType() throws Exception {
     @Test
     public void testParameterBinding() throws Exception {
         when(targetTypeList.get(0)).thenReturn(targetMethodType);
-        MethodDelegationBinder.ParameterBinding<?> parameterBinding = binder.bind(annotation,
+        MethodDelegationBinder.ParameterBinding<?> parameterBinding = binder.bind(annotationDescription,
                 0,
                 source,
                 target,
@@ -57,7 +57,7 @@ public void testParameterBinding() throws Exception {
     public void testCannotPipeStaticMethod() throws Exception {
         when(targetTypeList.get(0)).thenReturn(targetMethodType);
         when(source.isStatic()).thenReturn(true);
-        MethodDelegationBinder.ParameterBinding<?> parameterBinding = binder.bind(annotation,
+        MethodDelegationBinder.ParameterBinding<?> parameterBinding = binder.bind(annotationDescription,
                 0,
                 source,
                 target,
@@ -69,7 +69,7 @@ public void testCannotPipeStaticMethod() throws Exception {
     @Test(expected = IllegalStateException.class)
     public void testParameterBindingOnIllegalTargetTypeThrowsException() throws Exception {
         when(targetTypeList.get(0)).thenReturn(mock(TypeDescription.class));
-        binder.bind(annotation,
+        binder.bind(annotationDescription,
                 0,
                 source,
                 target,

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/SuperCallBinderTest.java
Patch:
@@ -38,7 +38,7 @@ public void testValidSuperMethodCall() throws Exception {
         when(targetParameterType.represents(any(Class.class))).thenReturn(true);
         when(specialMethodInvocation.isValid()).thenReturn(true);
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = SuperCall.Binder.INSTANCE
-                .bind(annotation, 0, source, target, instrumentationTarget, assigner);
+                .bind(annotationDescription, 0, source, target, instrumentationTarget, assigner);
         verify(instrumentationTarget).invokeSuper(source, Instrumentation.Target.MethodLookup.Default.EXACT);
         verifyNoMoreInteractions(instrumentationTarget);
         assertThat(parameterBinding.isValid(), is(true));
@@ -49,14 +49,14 @@ public void testInvalidSuperMethodCall() throws Exception {
         when(targetParameterType.represents(any(Class.class))).thenReturn(true);
         when(specialMethodInvocation.isValid()).thenReturn(false);
         MethodDelegationBinder.ParameterBinding<?> parameterBinding = SuperCall.Binder.INSTANCE
-                .bind(annotation, 0, source, target, instrumentationTarget, assigner);
+                .bind(annotationDescription, 0, source, target, instrumentationTarget, assigner);
         verify(instrumentationTarget).invokeSuper(source, Instrumentation.Target.MethodLookup.Default.EXACT);
         verifyNoMoreInteractions(instrumentationTarget);
         assertThat(parameterBinding.isValid(), is(false));
     }
 
     @Test(expected = IllegalStateException.class)
     public void testWrongTypeThrowsException() throws Exception {
-        SuperCall.Binder.INSTANCE.bind(annotation, 0, source, target, instrumentationTarget, assigner);
+        SuperCall.Binder.INSTANCE.bind(annotationDescription, 0, source, target, instrumentationTarget, assigner);
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/InlineInstrumentedType.java
Patch:
@@ -198,8 +198,8 @@ public AnnotationList getDeclaredAnnotations() {
     }
 
     @Override
-    public AnnotationList getAnnotations() {
-        return levelType.getAnnotations();
+    public AnnotationList getInheritedAnnotations() {
+        return levelType.getInheritedAnnotations();
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentedType.java
Patch:
@@ -11,6 +11,7 @@
 import net.bytebuddy.instrumentation.type.TypeList;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 import static net.bytebuddy.utility.ByteBuddyCommons.isValidTypeName;
@@ -203,8 +204,8 @@ public AnnotationList getDeclaredAnnotations() {
     }
 
     @Override
-    public AnnotationList getAnnotations() {
-        return null; // TODO
+    public AnnotationList getInheritedAnnotations() {
+        return getSupertype().getInheritedAnnotations().inherited(Collections.<TypeDescription>emptySet());
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/MethodDelegation.java
Patch:
@@ -138,7 +138,7 @@ public class MethodDelegation implements Instrumentation {
      * The {@link net.bytebuddy.instrumentation.method.bytecode.bind.annotation.TargetMethodAnnotationDrivenBinder.DefaultsProvider}
      * to be used by this method delegation.
      */
-    private final TargetMethodAnnotationDrivenBinder.DefaultsProvider<?> defaultsProvider;
+    private final TargetMethodAnnotationDrivenBinder.DefaultsProvider defaultsProvider;
 
     /**
      * The {@link net.bytebuddy.instrumentation.method.bytecode.bind.MethodDelegationBinder.AmbiguityResolver}
@@ -169,7 +169,7 @@ public class MethodDelegation implements Instrumentation {
      */
     protected MethodDelegation(InstrumentationDelegate instrumentationDelegate,
                                List<TargetMethodAnnotationDrivenBinder.ParameterBinder<?>> parameterBinders,
-                               TargetMethodAnnotationDrivenBinder.DefaultsProvider<?> defaultsProvider,
+                               TargetMethodAnnotationDrivenBinder.DefaultsProvider defaultsProvider,
                                MethodDelegationBinder.AmbiguityResolver ambiguityResolver,
                                Assigner assigner,
                                MethodList targetMethodCandidates) {
@@ -376,7 +376,7 @@ private static List<TargetMethodAnnotationDrivenBinder.ParameterBinder<?>> defau
      *
      * @return The defaults provider that is to be used if no other is specified explicitly.
      */
-    private static TargetMethodAnnotationDrivenBinder.DefaultsProvider<?> defaultDefaultsProvider() {
+    private static TargetMethodAnnotationDrivenBinder.DefaultsProvider defaultDefaultsProvider() {
         return Argument.NextUnboundAsDefaultsProvider.INSTANCE;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/FieldAttributeAppender.java
Patch:
@@ -183,7 +183,7 @@ public ForLoadedField(Field field) {
         public void apply(FieldVisitor fieldVisitor, FieldDescription fieldDescription) {
             AnnotationAppender annotationAppender =
                     new AnnotationAppender.Default(new AnnotationAppender.Target.OnField(fieldVisitor));
-            for (AnnotationDescription annotation : fieldDescription.getAnnotations()) {
+            for (AnnotationDescription annotation : fieldDescription.getDeclaredAnnotations()) {
                 annotationAppender.append(annotation, AnnotationAppender.AnnotationVisibility.RUNTIME);
             }
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/MethodAttributeAppender.java
Patch:
@@ -63,7 +63,7 @@ static enum ForInstrumentedMethod implements MethodAttributeAppender, Factory {
         public void apply(MethodVisitor methodVisitor, MethodDescription methodDescription) {
             AnnotationAppender methodAppender =
                     new AnnotationAppender.Default(new AnnotationAppender.Target.OnMethod(methodVisitor));
-            for (AnnotationDescription annotation : methodDescription.getAnnotations()) {
+            for (AnnotationDescription annotation : methodDescription.getDeclaredAnnotations()) {
                 methodAppender.append(annotation, AnnotationAppender.AnnotationVisibility.of(annotation));
             }
             int i = 0;

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/TypeAttributeAppender.java
Patch:
@@ -54,7 +54,7 @@ static enum ForSuperType implements TypeAttributeAppender {
         public void apply(ClassVisitor classVisitor, TypeDescription typeDescription) {
             AnnotationAppender annotationAppender =
                     new AnnotationAppender.Default(new AnnotationAppender.Target.OnType(classVisitor));
-            for (AnnotationDescription annotation : typeDescription.getSupertype().getAnnotations()) {
+            for (AnnotationDescription annotation : typeDescription.getSupertype().getDeclaredAnnotations()) {
                 annotationAppender.append(annotation, AnnotationAppender.AnnotationVisibility.of(annotation));
             }
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/annotation/AnnotatedElement.java
Patch:
@@ -3,6 +3,4 @@
 public interface AnnotatedElement {
 
     AnnotationList getDeclaredAnnotations();
-
-    AnnotationList getAnnotations();
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/annotation/AnnotationAppender.java
Patch:
@@ -74,7 +74,9 @@ private AnnotationVisibility(boolean visible, boolean suppressed) {
          * visibility of type {@link java.lang.annotation.RetentionPolicy#SOURCE} will be silently ignored.
          */
         public static AnnotationVisibility of(AnnotationDescription annotation) {
-            AnnotationDescription.Loadable<Retention> retention = annotation.getAnnotationType().getAnnotations().ofType(Retention.class);
+            AnnotationDescription.Loadable<Retention> retention = annotation.getAnnotationType()
+                    .getDeclaredAnnotations()
+                    .ofType(Retention.class);
             if (retention == null || retention.load().value() == RetentionPolicy.SOURCE) {
                 return INVISIBLE;
             } else if (retention.load().value() == RetentionPolicy.CLASS) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/AllArguments.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
 import net.bytebuddy.instrumentation.Instrumentation;
+import net.bytebuddy.instrumentation.attribute.annotation.AnnotationDescription;
 import net.bytebuddy.instrumentation.method.MethodDescription;
 import net.bytebuddy.instrumentation.method.bytecode.bind.MethodDelegationBinder;
 import net.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
@@ -110,7 +111,7 @@ public Class<AllArguments> getHandledType() {
         }
 
         @Override
-        public MethodDelegationBinder.ParameterBinding<?> bind(AllArguments annotation,
+        public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loadable<AllArguments> annotation,
                                                                int targetParameterIndex,
                                                                MethodDescription source,
                                                                MethodDescription target,
@@ -130,7 +131,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(AllArguments annotation,
                         assigner.assign(sourceParameter, arrayFactory.getComponentType(), considerRuntimeType));
                 if (stackManipulation.isValid()) {
                     stackManipulations.add(stackManipulation);
-                } else if (annotation.value().isStrict()) {
+                } else if (annotation.load().value().isStrict()) {
                     return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
                 }
                 offset += sourceParameter.getStackSize().getSize();

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/BindingPriority.java
Patch:
@@ -57,8 +57,8 @@ private static double resolve(AnnotationDescription.Loadable<BindingPriority> bi
         public Resolution resolve(MethodDescription source,
                                   MethodDelegationBinder.MethodBinding left,
                                   MethodDelegationBinder.MethodBinding right) {
-            double leftPriority = resolve(left.getTarget().getAnnotations().ofType(BindingPriority.class));
-            double rightPriority = resolve(right.getTarget().getAnnotations().ofType(BindingPriority.class));
+            double leftPriority = resolve(left.getTarget().getDeclaredAnnotations().ofType(BindingPriority.class));
+            double rightPriority = resolve(right.getTarget().getDeclaredAnnotations().ofType(BindingPriority.class));
             if (leftPriority == rightPriority) {
                 return Resolution.AMBIGUOUS;
             } else if (leftPriority < rightPriority) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/IgnoreForBinding.java
Patch:
@@ -34,7 +34,7 @@ private Verifier() {
          * @return {@code true} if the method should not be considered for binding.
          */
         public static boolean check(MethodDescription methodDescription) {
-            return methodDescription.getAnnotations().isAnnotationPresent(IgnoreForBinding.class);
+            return methodDescription.getDeclaredAnnotations().isAnnotationPresent(IgnoreForBinding.class);
         }
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Origin.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
 import net.bytebuddy.instrumentation.Instrumentation;
+import net.bytebuddy.instrumentation.attribute.annotation.AnnotationDescription;
 import net.bytebuddy.instrumentation.method.MethodDescription;
 import net.bytebuddy.instrumentation.method.bytecode.bind.MethodDelegationBinder;
 import net.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
@@ -84,7 +85,7 @@ public Class<Origin> getHandledType() {
         }
 
         @Override
-        public MethodDelegationBinder.ParameterBinding<?> bind(Origin annotation,
+        public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loadable<Origin> annotation,
                                                                int targetParameterIndex,
                                                                MethodDescription source,
                                                                MethodDescription target,
@@ -94,7 +95,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(Origin annotation,
             if (parameterType.represents(Class.class)) {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(ClassConstant.of(instrumentationTarget.getOriginType()));
             } else if (parameterType.represents(Method.class)) {
-                return new MethodDelegationBinder.ParameterBinding.Anonymous(annotation.cacheMethod()
+                return new MethodDelegationBinder.ParameterBinding.Anonymous(annotation.load().cacheMethod()
                         ? MethodConstant.forMethod(source).cached()
                         : MethodConstant.forMethod(source));
             } else if (parameterType.represents(String.class)) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Pipe.java
Patch:
@@ -5,6 +5,7 @@
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
 import net.bytebuddy.instrumentation.Instrumentation;
+import net.bytebuddy.instrumentation.attribute.annotation.AnnotationDescription;
 import net.bytebuddy.instrumentation.field.FieldDescription;
 import net.bytebuddy.instrumentation.field.FieldList;
 import net.bytebuddy.instrumentation.method.MethodDescription;
@@ -158,7 +159,7 @@ public Class<Pipe> getHandledType() {
         }
 
         @Override
-        public MethodDelegationBinder.ParameterBinding<?> bind(Pipe annotation,
+        public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loadable<Pipe> annotation,
                                                                int targetParameterIndex,
                                                                MethodDescription source,
                                                                MethodDescription target,
@@ -174,7 +175,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(Pipe annotation,
             return new MethodDelegationBinder.ParameterBinding.Anonymous(new Redirection(forwardingMethod.getDeclaringType(),
                     source,
                     assigner,
-                    annotation.serializableProxy(),
+                    annotation.load().serializableProxy(),
                     this));
         }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/SuperCall.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
 import net.bytebuddy.instrumentation.Instrumentation;
+import net.bytebuddy.instrumentation.attribute.annotation.AnnotationDescription;
 import net.bytebuddy.instrumentation.method.MethodDescription;
 import net.bytebuddy.instrumentation.method.bytecode.bind.MethodDelegationBinder;
 import net.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
@@ -54,7 +55,7 @@ public Class<SuperCall> getHandledType() {
         }
 
         @Override
-        public MethodDelegationBinder.ParameterBinding<?> bind(SuperCall annotation,
+        public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loadable<SuperCall> annotation,
                                                                int targetParameterIndex,
                                                                MethodDescription source,
                                                                MethodDescription target,
@@ -67,7 +68,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(SuperCall annotation,
             Instrumentation.SpecialMethodInvocation specialMethodInvocation = instrumentationTarget.invokeSuper(source,
                     Instrumentation.Target.MethodLookup.Default.EXACT);
             return specialMethodInvocation.isValid()
-                    ? new MethodDelegationBinder.ParameterBinding.Anonymous(new MethodCallProxy.AssignableSignatureCall(specialMethodInvocation, annotation.serializableProxy()))
+                    ? new MethodDelegationBinder.ParameterBinding.Anonymous(new MethodCallProxy.AssignableSignatureCall(specialMethodInvocation, annotation.load().serializableProxy()))
                     : MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/This.java
Patch:
@@ -1,6 +1,7 @@
 package net.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
 import net.bytebuddy.instrumentation.Instrumentation;
+import net.bytebuddy.instrumentation.attribute.annotation.AnnotationDescription;
 import net.bytebuddy.instrumentation.method.MethodDescription;
 import net.bytebuddy.instrumentation.method.bytecode.bind.MethodDelegationBinder;
 import net.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
@@ -49,7 +50,7 @@ public Class<This> getHandledType() {
         }
 
         @Override
-        public MethodDelegationBinder.ParameterBinding<?> bind(This annotation,
+        public MethodDelegationBinder.ParameterBinding<?> bind(AnnotationDescription.Loadable<This> annotation,
                                                                int targetParameterIndex,
                                                                MethodDescription source,
                                                                MethodDescription target,

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/matcher/MethodMatchers.java
Patch:
@@ -1935,7 +1935,7 @@ private AnnotationMethodMatcher(Class<? extends Annotation> annotationType) {
 
         @Override
         public boolean matches(MethodDescription methodDescription) {
-            return methodDescription.getAnnotations().isAnnotationPresent(annotationType);
+            return methodDescription.getDeclaredAnnotations().isAnnotationPresent(annotationType);
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/attribute/annotation/AnnotatedElement.java
Patch:
@@ -3,4 +3,6 @@
 public interface AnnotatedElement {
 
     AnnotationList getDeclaredAnnotations();
+
+    AnnotationList getAnnotations();
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/IgnoreForBinding.java
Patch:
@@ -34,7 +34,7 @@ private Verifier() {
          * @return {@code true} if the method should not be considered for binding.
          */
         public static boolean check(MethodDescription methodDescription) {
-            return methodDescription.isAnnotationPresent(IgnoreForBinding.class);
+            return methodDescription.getAnnotations().isAnnotationPresent(IgnoreForBinding.class);
         }
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/matcher/MethodMatchers.java
Patch:
@@ -1935,7 +1935,7 @@ private AnnotationMethodMatcher(Class<? extends Annotation> annotationType) {
 
         @Override
         public boolean matches(MethodDescription methodDescription) {
-            return methodDescription.isAnnotationPresent(annotationType);
+            return methodDescription.getAnnotations().isAnnotationPresent(annotationType);
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/depiction/TypePool.java
Patch:
@@ -349,7 +349,6 @@ protected UnloadedTypeDescription(TypePool typePool,
             }
             this.declarationContext = declarationContext;
             this.anonymousType = anonymousType;
-            int index = 0;
             declaredFields = new ArrayList<FieldDescription>(fieldTokens.size());
             for (FieldToken fieldToken : fieldTokens) {
                 declaredFields.add(fieldToken.toFieldDescription(this));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -2429,11 +2429,11 @@ public File toJar(File file, Manifest manifest) throws IOException {
             JarOutputStream outputStream = new JarOutputStream(new BufferedOutputStream(new FileOutputStream(file)), manifest);
             try {
                 for (Map.Entry<TypeDescription, byte[]> entry : getRawAuxiliaryTypes().entrySet()) {
-                    outputStream.putNextEntry(new JarEntry(entry.getKey().getInternalName()));
+                    outputStream.putNextEntry(new JarEntry(entry.getKey().getInternalName() + CLASS_FILE_EXTENSION));
                     outputStream.write(entry.getValue());
                     outputStream.closeEntry();
                 }
-                outputStream.putNextEntry(new JarEntry(typeDescription.getInternalName()));
+                outputStream.putNextEntry(new JarEntry(typeDescription.getInternalName() + CLASS_FILE_EXTENSION));
                 outputStream.write(binaryRepresentation);
                 outputStream.closeEntry();
             } finally {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -2429,11 +2429,11 @@ public File toJar(File file, Manifest manifest) throws IOException {
             JarOutputStream outputStream = new JarOutputStream(new BufferedOutputStream(new FileOutputStream(file)), manifest);
             try {
                 for (Map.Entry<TypeDescription, byte[]> entry : getRawAuxiliaryTypes().entrySet()) {
-                    outputStream.putNextEntry(new JarEntry(entry.getKey().getInternalName()));
+                    outputStream.putNextEntry(new JarEntry(entry.getKey().getInternalName() + CLASS_FILE_EXTENSION));
                     outputStream.write(entry.getValue());
                     outputStream.closeEntry();
                 }
-                outputStream.putNextEntry(new JarEntry(typeDescription.getInternalName()));
+                outputStream.putNextEntry(new JarEntry(typeDescription.getInternalName() + CLASS_FILE_EXTENSION);
                 outputStream.write(binaryRepresentation);
                 outputStream.closeEntry();
             } finally {

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoaderTest.java
Patch:
@@ -23,7 +23,7 @@
 public class ByteArrayClassLoaderTest {
 
     private static final ClassLoader BOOTSTRAP_CLASS_LOADER = null;
-    private static final String BAR = "bar";
+    private static final String BAR = "bar", CLASS_FILE = ".class";
     private final ByteArrayClassLoader.PersistenceHandler persistenceHandler;
     private final Matcher<InputStream> expectedResourceLookup;
     private ClassLoader classLoader;
@@ -56,7 +56,7 @@ public void testSuccessfulHit() throws Exception {
 
     @Test
     public void testResourceLookupBeforeLoading() throws Exception {
-        InputStream inputStream = classLoader.getResourceAsStream(Foo.class.getName());
+        InputStream inputStream = classLoader.getResourceAsStream(Foo.class.getName().replace('.', '/') + CLASS_FILE);
         try {
             assertThat(inputStream, expectedResourceLookup);
         } finally {
@@ -69,7 +69,7 @@ public void testResourceLookupBeforeLoading() throws Exception {
     @Test
     public void testResourceLookupAfterLoading() throws Exception {
         assertThat(classLoader.loadClass(Foo.class.getName()).getClassLoader(), is(classLoader));
-        InputStream inputStream = classLoader.getResourceAsStream(Foo.class.getName());
+        InputStream inputStream = classLoader.getResourceAsStream(Foo.class.getName().replace('.', '/') + CLASS_FILE);
         try {
             assertThat(inputStream, expectedResourceLookup);
         } finally {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/RebaseInstrumentationTarget.java
Patch:
@@ -117,8 +117,7 @@ private RebasedMethodSpecialMethodInvocation(MethodRebaseResolver.Resolution res
                                                      TypeDescription instrumentedType) {
             this.methodDescription = resolution.getResolvedMethod();
             this.instrumentedType = instrumentedType;
-            stackManipulation = new Compound(resolution.getAdditionalArguments(),
-                    MethodInvocation.invoke(resolution.getResolvedMethod()).special(instrumentedType));
+            stackManipulation = new Compound(resolution.getAdditionalArguments(), MethodInvocation.invoke(resolution.getResolvedMethod()));
         }
 
         /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/inline/RebaseInstrumentationTargetTest.java
Patch:
@@ -91,7 +91,7 @@ public void testRebasedMethodIsInvokable() throws Exception {
         MethodVisitor methodVisitor = mock(MethodVisitor.class);
         Instrumentation.Context instrumentationContext = mock(Instrumentation.Context.class);
         StackManipulation.Size size = specialMethodInvocation.apply(methodVisitor, instrumentationContext);
-        verify(methodVisitor).visitMethodInsn(Opcodes.INVOKESPECIAL, BAR, BAZ, FOOBAR, false);
+        verify(methodVisitor).visitMethodInsn(Opcodes.INVOKEVIRTUAL, BAR, BAZ, FOOBAR, false);
         verifyNoMoreInteractions(methodVisitor);
         verifyZeroInteractions(instrumentationContext);
         assertThat(size.getSizeImpact(), is(0));

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java
Patch:
@@ -2275,6 +2275,7 @@ public Map<TypeDescription, byte[]> getRawAuxiliaryTypes() {
         public Map<TypeDescription, File> saveIn(File folder) throws IOException {
             Map<TypeDescription, File> savedFiles = new HashMap<TypeDescription, File>();
             File target = new File(folder, typeDescription.getName().replace('.', File.separatorChar) + CLASS_FILE_EXTENSION);
+            target.getParentFile().mkdirs();
             FileOutputStream fileOutputStream = new FileOutputStream(target);
             try {
                 fileOutputStream.write(binaryRepresentation);

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/InliningDynamicTypeBuilder.java
Patch:
@@ -451,7 +451,7 @@ public ForRebaseInstrumentation(MethodMatcher ignoredMethods,
                             classFileVersion,
                             AuxiliaryType.MethodAccessorFactory.Illegal.INSTANCE);
                     this.methodRebaseResolver = new MethodRebaseResolver.Default(ignoredMethods,
-                            placeholderType.getDescription(),
+                            placeholderType.getTypeDescription(),
                             new MethodRebaseResolver.MethodNameTransformer.Suffixing(new RandomString()));
                 }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/member/MethodVariableAccess.java
Patch:
@@ -152,9 +152,9 @@ private static StackManipulation loadArguments(MethodDescription methodDescripti
             if (includeThisReference) {
                 stackManipulation[parameterIndex++] = MethodVariableAccess.REFERENCE.loadFromIndex(0);
             }
-            stackIndex = methodDescription.getDeclaringType().getStackSize().getSize();
+            stackIndex = StackSize.SINGLE.getSize();
         } else {
-            stackIndex = 0;
+            stackIndex = StackSize.ZERO.getSize();
         }
         for (TypeDescription parameterType : methodDescription.getParameterTypes()) {
             stackManipulation[parameterIndex++] = typeCastingHandler

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/DynamicTypeDefaultLoadedTest.java
Patch:
@@ -46,13 +46,13 @@ public void setUp() throws Exception {
                 mainLoadedTypeInitializer,
                 Collections.singletonList(auxiliaryType),
                 loadedTypes);
-        when(auxiliaryType.getDescription()).thenReturn(mainTypeDescription);
+        when(auxiliaryType.getTypeDescription()).thenReturn(mainTypeDescription);
     }
 
     @Test
     public void testLoadedTypeDescription() throws Exception {
         assertEquals(MAIN_TYPE, dynamicType.getLoaded());
-        assertThat(dynamicType.getDescription(), is(mainTypeDescription));
+        assertThat(dynamicType.getTypeDescription(), is(mainTypeDescription));
         assertThat(dynamicType.getLoadedAuxiliaryTypes().size(), is(1));
         assertThat(dynamicType.getLoadedAuxiliaryTypes().keySet(), hasItem(auxiliaryTypeDescription));
         assertEquals(AUXILIARY_TYPE, dynamicType.getLoadedAuxiliaryTypes().get(auxiliaryTypeDescription));

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/DynamicTypeDefaultUnloadedTest.java
Patch:
@@ -57,16 +57,16 @@ public void setUp() throws Exception {
         loadedTypes.put(typeDescription, MAIN_TYPE);
         loadedTypes.put(auxiliaryTypeDescription, AUXILIARY_TYPE);
         when(classLoadingStrategy.load(any(ClassLoader.class), any(LinkedHashMap.class))).thenReturn(loadedTypes);
-        when(auxiliaryType.getDescription()).thenReturn(auxiliaryTypeDescription);
+        when(auxiliaryType.getTypeDescription()).thenReturn(auxiliaryTypeDescription);
         when(auxiliaryType.getBytes()).thenReturn(auxiliaryTypeByte);
-        when(auxiliaryType.getTypeInitializers()).thenReturn(Collections.singletonMap(auxiliaryTypeDescription, auxiliaryLoadedTypeInitializer));
+        when(auxiliaryType.getLoadedTypeInitializers()).thenReturn(Collections.singletonMap(auxiliaryTypeDescription, auxiliaryLoadedTypeInitializer));
         when(auxiliaryType.getRawAuxiliaryTypes()).thenReturn(Collections.<TypeDescription, byte[]>emptyMap());
     }
 
     @Test
     public void testQueries() throws Exception {
         DynamicType.Loaded<?> loaded = unloaded.load(classLoader, classLoadingStrategy);
-        assertThat(loaded.getDescription(), is(typeDescription));
+        assertThat(loaded.getTypeDescription(), is(typeDescription));
         assertThat(loaded.getBytes(), is(binaryRepresentation));
         assertThat(loaded.getRawAuxiliaryTypes(), is(Collections.singletonMap(auxiliaryTypeDescription, auxiliaryTypeByte)));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterDefaultTest.java
Patch:
@@ -45,7 +45,7 @@ public class TypeWriterDefaultTest {
     public void setUp() throws Exception {
         explicitAuxiliaryTypes = Arrays.asList(firstAuxiliary);
         when(engine.create(any(Instrumentation.Context.ExtractableView.class))).thenReturn(MAIN);
-        when(firstAuxiliary.getDescription()).thenReturn(otherAuxiliaryDescription);
+        when(firstAuxiliary.getTypeDescription()).thenReturn(otherAuxiliaryDescription);
         when(firstAuxiliary.getBytes()).thenReturn(FIRST);
     }
 
@@ -57,8 +57,8 @@ public void testDynamicTypeCreation() throws Exception {
                 classFileVersion,
                 engine).make();
         assertThat(dynamicType.getBytes(), is(MAIN));
-        assertThat(dynamicType.getDescription(), is(instrumentedType));
-        assertThat(dynamicType.getTypeInitializers().get(instrumentedType), is(loadedTypeInitializer));
+        assertThat(dynamicType.getTypeDescription(), is(instrumentedType));
+        assertThat(dynamicType.getLoadedTypeInitializers().get(instrumentedType), is(loadedTypeInitializer));
         assertThat(dynamicType.getRawAuxiliaryTypes().size(), is(1));
         assertThat(dynamicType.getRawAuxiliaryTypes().get(otherAuxiliaryDescription), is(FIRST));
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/type/auxiliary/TrivialTypeTest.java
Patch:
@@ -28,9 +28,9 @@ public class TrivialTypeTest {
     @Test
     public void testCreation() throws Exception {
         DynamicType dynamicType = TrivialType.INSTANCE.make(FOO, classFileVersion, methodAccessorFactory);
-        assertThat(dynamicType.getDescription().getName(), is(FOO));
-        assertThat(dynamicType.getDescription().getModifiers(), is(Opcodes.ACC_SYNTHETIC));
+        assertThat(dynamicType.getTypeDescription().getName(), is(FOO));
+        assertThat(dynamicType.getTypeDescription().getModifiers(), is(Opcodes.ACC_SYNTHETIC));
         assertThat(dynamicType.getRawAuxiliaryTypes().size(), is(0));
-        assertThat(dynamicType.getTypeInitializers().get(dynamicType.getDescription()).isAlive(), is(false));
+        assertThat(dynamicType.getLoadedTypeInitializers().get(dynamicType.getTypeDescription()).isAlive(), is(false));
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/FlatDynamicTypeBuilder.java
Patch:
@@ -346,7 +346,7 @@ public ForRebaseInstrumentation(MethodMatcher ignoredMethods,
 
                 private static String trivialTypeNameFor(TypeDescription rawInstrumentedType) {
                     return String.format("%s$%s$%s",
-                            rawInstrumentedType.getInternalName(),
+                            rawInstrumentedType.getName(),
                             SUFFIX,
                             RandomString.make());
                 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/inline/FlatDynamicTypeBuilder.java
Patch:
@@ -218,6 +218,7 @@ public DynamicType.Unloaded<T> make() {
                 compiledMethodRegistry.getLoadedTypeInitializer(),
                 preparedTargetHandler.getAuxiliaryTypes(),
                 new TypeWriter.Engine.ForRedefinition(compiledMethodRegistry.getInstrumentedType(),
+                        targetType,
                         classFileVersion,
                         compiledMethodRegistry.getInvokableMethods().filter(isOverridable()
                                 .or(isDeclaredBy(compiledMethodRegistry.getInstrumentedType()))

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/Instrumentation.java
Patch:
@@ -193,7 +193,7 @@ private Simple(MethodDescription methodDescription,
             public static SpecialMethodInvocation of(MethodDescription methodDescription,
                                                      TypeDescription typeDescription) {
                 StackManipulation stackManipulation = MethodInvocation.invoke(methodDescription).special(typeDescription);
-                return stackManipulation.isValid()
+                return stackManipulation.isValid() && !methodDescription.isAbstract()
                         ? new Simple(methodDescription, typeDescription, stackManipulation)
                         : SpecialMethodInvocation.Illegal.INSTANCE;
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -847,7 +847,7 @@ public String toString() {
      *
      * @param <T> The type of the definable object.
      */
-    public static interface Definable<T> {
+    protected static interface Definable<T> {
 
         /**
          * Returns the value of this instance or the provided default value for an undefined definable.

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/DynamicTypeDefaultTest.java
Patch:
@@ -3,6 +3,7 @@
 import net.bytebuddy.instrumentation.LoadedTypeInitializer;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.utility.MockitoRule;
+import net.bytebuddy.utility.RandomString;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -14,7 +15,6 @@
 import java.io.IOException;
 import java.util.Collections;
 import java.util.Map;
-import java.util.Random;
 
 import static org.hamcrest.CoreMatchers.not;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -59,7 +59,7 @@ private static void assertFile(File file, byte[] binaryRepresentation) throws IO
     private static File makeTemporaryFolder() throws IOException {
         File file = File.createTempFile(TEMP, TEMP);
         try {
-            File folder = new File(file.getParentFile(), TEMP + Math.abs(new Random().nextInt()));
+            File folder = new File(file.getParentFile(), TEMP + RandomString.make());
             assertThat(folder.mkdir(), is(true));
             return folder;
         } finally {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -209,7 +209,7 @@ public void visit(int classFileVersionNumber,
                                   String genericSignature,
                                   String superTypeInternalName,
                                   String[] interfaceTypeInternalName) {
-                    super.visit(classFileVersion.getVersionNumber(), // TODO: Make optional override
+                    super.visit(classFileVersion.getVersionNumber(),
                             instrumentedType.getActualModifiers(),
                             instrumentedType.getInternalName(),
                             instrumentedType.getGenericSignature(),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ClassLoaderByteArrayInjector.java
Patch:
@@ -14,6 +14,8 @@
  */
 public class ClassLoaderByteArrayInjector {
 
+    private static final int FROM_BEGINNING = 0;
+
     /**
      * A storage for the reflection method representations that are obtained on loading this classes.
      */
@@ -68,7 +70,7 @@ public Class<?> inject(String name, byte[] binaryRepresentation) {
                     return (Class<?>) REFLECTION_STORE.getLoadByteArrayMethod().invoke(classLoader,
                             name,
                             binaryRepresentation,
-                            0,
+                            FROM_BEGINNING,
                             binaryRepresentation.length);
                 }
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -210,7 +210,7 @@ public DynamicType.Unloaded<T> make() {
                 .attributeType(attributeAppender)
                 .members()
                 .writeFields(preparedMethodRegistry.getInstrumentedType().getDeclaredFields(),
-                        fieldRegistry.compile(preparedMethodRegistry.getInstrumentedType(), TypeWriter.FieldPool.Entry.NoOp.INSTANCE))
+                        fieldRegistry.prepare(preparedMethodRegistry.getInstrumentedType()).compile(TypeWriter.FieldPool.Entry.NoOp.INSTANCE))
                 .writeMethods(compiledMethodRegistry.getInvokableMethods()
                                 .filter(isOverridable()
                                         .and(not(ignoredMethods))

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/TypeDescription.java
Patch:
@@ -239,11 +239,11 @@ public String getInternalName() {
         @Override
         public int getActualModifiers() {
             if (isPrivate()) {
-                return getModifiers() & ~Opcodes.ACC_PRIVATE;
+                return getModifiers() & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC);
             } else if (isProtected()) {
-                return getModifiers() & ~Opcodes.ACC_PROTECTED | Opcodes.ACC_PUBLIC;
+                return getModifiers() & ~(Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC) | Opcodes.ACC_PUBLIC;
             } else {
-                return getModifiers();
+                return getModifiers() & ~Opcodes.ACC_STATIC;
             }
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterBuilderTest.java
Patch:
@@ -16,6 +16,7 @@
 import net.bytebuddy.instrumentation.type.TypeList;
 import net.bytebuddy.utility.MockitoRule;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
@@ -34,6 +35,7 @@
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.*;
 
+@Ignore("TypeWriter is to be replaced")
 public class TypeWriterBuilderTest {
 
     private static final String FOO = "foo", BAR = "bar", QUX = "qux", BAZ = "baz";

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterBuilderTest.java
Patch:
@@ -136,7 +136,8 @@ public ClassVisitor answer(InvocationOnMock invocation) throws Throwable {
         typeWriter = new TypeWriter.Builder<Object>(instrumentedType,
                 loadedTypeInitializer,
                 instrumentationContext,
-                ClassFileVersion.forCurrentJavaVersion()).build(classVisitorWrapper);
+                ClassFileVersion.forCurrentJavaVersion(),
+                TypeWriter.Builder.ClassWriterProvider.CleanCopy.INSTANCE).build(classVisitorWrapper);
         verify(classVisitorWrapper).wrap(any(ClassWriter.class));
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/ByteCodeElement.java
Patch:
@@ -28,6 +28,8 @@ public interface ByteCodeElement {
      */
     String getDescriptor();
 
+    String getGenericSignature();
+
     /**
      * Checks if this element is visible from a given type.
      *

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/ByteCodeMethod.java
Patch:
@@ -9,8 +9,8 @@
 public interface ByteCodeMethod extends ByteCodeElement {
 
     /**
-     * Returns the unique signature of a byte code method. A unique signature is usually a concatenation of
-     * the internal internalName of the method / constructor and the method descriptor. Note that methods on byte code
+     * Returns the unique signature of a byte code method. A unique signature is defined as the concatenation of
+     * the internal name of the method / constructor and the method descriptor. Note that methods on byte code
      * level do consider two similar methods with different return type as distinct methods.
      *
      * @return A unique signature of this byte code level method.

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/FixedValue.java
Patch:
@@ -61,7 +61,9 @@ protected FixedValue(Assigner assigner, boolean considerRuntimeType) {
      * If possible, the constant pool value is substituted by a byte code instruction that creates the value. (This is
      * possible for integer types and types that are presented by integers inside the JVM ({@code boolean}, {@code byte},
      * {@code short}, {@code char}) and for the {@code null} value. Additionally, several common constants of
-     * the {@code float}, {@code double} and {@code long} types can be represented by opcode constants.
+     * the {@code float}, {@code double} and {@code long} types can be represented by opcode constants. Note that the
+     * Java 7 types {@link java.lang.invoke.MethodHandle} and {@link java.lang.invoke.MethodType} are are currently not
+     * supported for constant pool storage.
      *
      * @param fixedValue The fixed value to be returned by methods that are instrumented by this instrumentation.
      * @return An instrumentation for the given {@code fixedValue}.

File: byte-buddy-dep/src/main/java/net/bytebuddy/modifier/SyntheticState.java
Patch:
@@ -19,7 +19,7 @@ public enum SyntheticState implements ModifierContributor.ForType, ModifierContr
     NON_SYNTHETIC(EMPTY_MASK);
 
     /**
-     * The mask the modifier contributor.
+     * The mask of the modifier contributor.
      */
     private final int mask;
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderTest.java
Patch:
@@ -1,6 +1,5 @@
 package net.bytebuddy.dynamic.scaffold.subclass;
 
-import jdk.nashorn.internal.codegen.types.Type;
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.NamingStrategy;
 import net.bytebuddy.asm.ClassVisitorWrapper;
@@ -30,6 +29,7 @@
 import org.junit.Test;
 import org.junit.rules.TestRule;
 import org.mockito.Mock;
+import org.mockito.asm.Type;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.objectweb.asm.MethodVisitor;
@@ -145,7 +145,7 @@ public ByteCodeAppender.Size answer(InvocationOnMock invocation) throws Throwabl
                         methodVisitor.visitFieldInsn(Opcodes.PUTSTATIC,
                                 Type.getInternalName(Foo.class),
                                 FOO,
-                                Type.INT.getDescriptor());
+                                Type.getDescriptor(int.class));
                         methodVisitor.visitInsn(Opcodes.RETURN);
                         return new ByteCodeAppender.Size(1, methodDescription.getStackSize());
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -468,7 +468,7 @@ public DynamicType.Unloaded<T> make() {
                 );
         MethodLookupEngine.Finding finding = compiledMethodRegistry.getFinding();
         TypeExtensionDelegate typeExtensionDelegate = new TypeExtensionDelegate(finding.getTypeDescription(), classFileVersion);
-        return new TypeWriter.Builder<T>(finding.getTypeDescription(), compiledMethodRegistry.getTypeInitializer(), typeExtensionDelegate, classFileVersion)
+        return new TypeWriter.Builder<T>(finding.getTypeDescription(), compiledMethodRegistry.getLoadedTypeInitializer(), typeExtensionDelegate, classFileVersion)
                 .build(classVisitorWrapperChain)
                 .attributeType(attributeAppender)
                 .members()

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/FixedValue.java
Patch:
@@ -411,7 +411,7 @@ public Instrumentation withAssigner(Assigner assigner, boolean considerRuntimeTy
         public InstrumentedType prepare(InstrumentedType instrumentedType) {
             return instrumentedType
                     .withField(fieldName, fieldType, Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC)
-                    .withInitializer(TypeInitializer.ForStaticField.nonAccessible(fieldName, fixedValue));
+                    .withInitializer(LoadedTypeInitializer.ForStaticField.nonAccessible(fieldName, fixedValue));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/Forwarding.java
Patch:
@@ -240,7 +240,7 @@ public ForStaticInstance(Object target) {
             public InstrumentedType prepare(InstrumentedType instrumentedType, String fieldName, TypeDescription fieldType) {
                 return instrumentedType
                         .withField(fieldName, fieldType, Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC)
-                        .withInitializer(new TypeInitializer.ForStaticField<Object>(fieldName, target, true));
+                        .withInitializer(new LoadedTypeInitializer.ForStaticField<Object>(fieldName, target, true));
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/Instrumentation.java
Patch:
@@ -21,7 +21,7 @@
  * <ol>
  * <li>The instrumentation is able to prepare an instrumented type by adding fields and/or helper methods that are
  * required for the methods implemented by this instrumentation. Furthermore,
- * {@link net.bytebuddy.instrumentation.TypeInitializer}s can be registered for an instrumented
+ * {@link LoadedTypeInitializer}s can be registered for an instrumented
  * type.</li>
  * <li>An instrumentation is required to supply a byte code appender that is responsible for providing the byte code
  * to the instrumented methods that were delegated to this instrumentation. This byte code appender will also

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/InvocationHandlerAdapter.java
Patch:
@@ -214,7 +214,7 @@ public Instrumentation withMethodCache() {
         public InstrumentedType prepare(InstrumentedType instrumentedType) {
             return instrumentedType
                     .withField(fieldName, new TypeDescription.ForLoadedType(InvocationHandler.class), Opcodes.ACC_STATIC)
-                    .withInitializer(TypeInitializer.ForStaticField.nonAccessible(fieldName, invocationHandler));
+                    .withInitializer(LoadedTypeInitializer.ForStaticField.nonAccessible(fieldName, invocationHandler));
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/MethodDelegation.java
Patch:
@@ -670,7 +670,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
                 return instrumentedType.withField(fieldName,
                         new TypeDescription.ForLoadedType(delegate.getClass()),
                         Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC)
-                        .withInitializer(TypeInitializer.ForStaticField.nonAccessible(fieldName, delegate));
+                        .withInitializer(LoadedTypeInitializer.ForStaticField.nonAccessible(fieldName, delegate));
             }
 
             @Override

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/TypeWriterBuilderTest.java
Patch:
@@ -5,7 +5,7 @@
 import net.bytebuddy.dynamic.ClassLoadingStrategy;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.instrumentation.Instrumentation;
-import net.bytebuddy.instrumentation.TypeInitializer;
+import net.bytebuddy.instrumentation.LoadedTypeInitializer;
 import net.bytebuddy.instrumentation.attribute.FieldAttributeAppender;
 import net.bytebuddy.instrumentation.attribute.MethodAttributeAppender;
 import net.bytebuddy.instrumentation.attribute.TypeAttributeAppender;
@@ -72,7 +72,7 @@ public class TypeWriterBuilderTest {
     @Mock
     private ByteCodeAppender emptyImplementationByteCodeAppender, abstractImplementationByteCodeAppender;
     @Mock
-    private TypeInitializer typeInitializer;
+    private LoadedTypeInitializer loadedTypeInitializer;
 
     private TypeWriter.InGeneralPhase<?> typeWriter;
 
@@ -134,7 +134,7 @@ public ClassVisitor answer(InvocationOnMock invocation) throws Throwable {
             }
         });
         typeWriter = new TypeWriter.Builder<Object>(instrumentedType,
-                typeInitializer,
+                loadedTypeInitializer,
                 instrumentationContext,
                 ClassFileVersion.forCurrentJavaVersion()).build(classVisitorWrapper);
         verify(classVisitorWrapper).wrap(any(ClassWriter.class));

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/TypeInitializerNoOp.java
Patch:
@@ -9,6 +9,6 @@ public class TypeInitializerNoOp {
 
     @Test
     public void testIsNotAlive() throws Exception {
-        assertThat(TypeInitializer.NoOp.INSTANCE.isAlive(), is(false));
+        assertThat(LoadedTypeInitializer.NoOp.INSTANCE.isAlive(), is(false));
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/TypeDescription.java
Patch:
@@ -217,7 +217,9 @@ public String getInternalName() {
 
         @Override
         public boolean isVisibleTo(TypeDescription typeDescription) {
-            return isPublic() || typeDescription.getPackageName().equals(getPackageName());
+            return isPublic()
+                    || (isPackagePrivate() && typeDescription.getPackageName().equals(getPackageName()))
+                    || (isProtected() && getEnclosingClass() != null && getEnclosingClass().isAssignableFrom(typeDescription));
         }
 
         @Override

File: byte-buddy-benchmark/src/test/java/net/bytebuddy/benchmark/AbstractBlackHoleTest.java
Patch:
@@ -3,7 +3,7 @@
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.dynamic.ClassLoadingStrategy;
 import net.bytebuddy.instrumentation.MethodDelegation;
-import net.bytebuddy.modifier.MemberVisibility;
+import net.bytebuddy.modifier.Visibility;
 import org.junit.Before;
 import org.openjdk.jmh.infra.Blackhole;
 
@@ -27,7 +27,7 @@ public void setUpBlackHole() throws Exception {
         Class<?> blackHoleGenerator = new ByteBuddy()
                 .subclass(Object.class)
                 .name(String.format("C%d$generated", Math.abs(new Random().nextInt())))
-                .defineMethod(BLACK_HOLE_METHOD, Blackhole.class, Collections.<Class<?>>emptyList(), MemberVisibility.PUBLIC)
+                .defineMethod(BLACK_HOLE_METHOD, Blackhole.class, Collections.<Class<?>>emptyList(), Visibility.PUBLIC)
                 .intercept(MethodDelegation.toConstructor(Blackhole.class))
                 .make()
                 .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)

File: byte-buddy-dep/src/main/java/net/bytebuddy/NamingStrategy.java
Patch:
@@ -3,7 +3,7 @@
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.modifier.SyntheticState;
 import net.bytebuddy.modifier.TypeManifestation;
-import net.bytebuddy.modifier.TypeVisibility;
+import net.bytebuddy.modifier.Visibility;
 
 import java.util.Collection;
 import java.util.Random;
@@ -51,7 +51,7 @@ static interface UnnamedType {
          *
          * @return The visibility of this unnamed type.
          */
-        TypeVisibility getVisibility();
+        Visibility getVisibility();
 
         /**
          * Returns the manifestation of this unnamed type.

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Pipe.java
Patch:
@@ -24,7 +24,7 @@
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.instrumentation.type.TypeList;
 import net.bytebuddy.instrumentation.type.auxiliary.AuxiliaryType;
-import net.bytebuddy.modifier.MemberVisibility;
+import net.bytebuddy.modifier.Visibility;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
@@ -304,7 +304,7 @@ public DynamicType make(String auxiliaryTypeName,
                         .defineConstructor(new ArrayList<TypeDescription>(parameterFields.values()))
                         .intercept(ConstructorCall.INSTANCE);
                 for (Map.Entry<String, TypeDescription> field : parameterFields.entrySet()) {
-                    builder = builder.defineField(field.getKey(), field.getValue(), MemberVisibility.PRIVATE);
+                    builder = builder.defineField(field.getKey(), field.getValue(), Visibility.PRIVATE);
                 }
                 return builder.make();
             }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/auxiliary/AuxiliaryType.java
Patch:
@@ -6,7 +6,7 @@
 import net.bytebuddy.instrumentation.ModifierContributor;
 import net.bytebuddy.instrumentation.method.MethodDescription;
 import net.bytebuddy.modifier.SyntheticState;
-import net.bytebuddy.modifier.TypeVisibility;
+import net.bytebuddy.modifier.Visibility;
 
 /**
  * An auxiliary type that provides services to the instrumentation of another type. Implementations should provide
@@ -18,7 +18,7 @@ public interface AuxiliaryType {
     /**
      * The default type access of an auxiliary type. This array must not be mutated.
      */
-    static final ModifierContributor.ForType[] DEFAULT_TYPE_MODIFIER = {TypeVisibility.PACKAGE_PRIVATE, SyntheticState.SYNTHETIC};
+    static final ModifierContributor.ForType[] DEFAULT_TYPE_MODIFIER = {Visibility.PACKAGE_PRIVATE, SyntheticState.SYNTHETIC};
 
     /**
      * Creates a new auxiliary type.

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/auxiliary/MethodCallProxy.java
Patch:
@@ -25,7 +25,7 @@
 import net.bytebuddy.instrumentation.type.InstrumentedType;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.instrumentation.type.TypeList;
-import net.bytebuddy.modifier.MemberVisibility;
+import net.bytebuddy.modifier.Visibility;
 import org.objectweb.asm.MethodVisitor;
 
 import java.io.Serializable;
@@ -147,7 +147,7 @@ public DynamicType make(String auxiliaryTypeName,
                 .defineConstructor(new ArrayList<TypeDescription>(parameterFields.values()))
                 .intercept(ConstructorCall.INSTANCE);
         for (Map.Entry<String, TypeDescription> field : parameterFields.entrySet()) {
-            builder = builder.defineField(field.getKey(), field.getValue(), MemberVisibility.PRIVATE);
+            builder = builder.defineField(field.getKey(), field.getValue(), Visibility.PRIVATE);
         }
         return builder.make();
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/FieldAccessorTest.java
Patch:
@@ -1,7 +1,7 @@
 package net.bytebuddy.instrumentation;
 
 import net.bytebuddy.dynamic.DynamicType;
-import net.bytebuddy.modifier.MemberVisibility;
+import net.bytebuddy.modifier.Visibility;
 import net.bytebuddy.utility.CallTraceable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -133,7 +133,7 @@ public void testStaticGetterExplicit() throws Exception {
 
     @Test
     public void testDefineFieldGetter() throws Exception {
-        testGetter(instanceGetter, FieldAccessor.ofField(FOO).defineAs(propertyType, MemberVisibility.PUBLIC), true);
+        testGetter(instanceGetter, FieldAccessor.ofField(FOO).defineAs(propertyType, Visibility.PUBLIC), true);
     }
 
     @Test
@@ -158,7 +158,7 @@ public void testStaticSetterExplicit() throws Exception {
 
     @Test
     public void testDefineFieldSetter() throws Exception {
-        testSetter(instanceSetter, FieldAccessor.ofField(FOO).defineAs(propertyType, MemberVisibility.PUBLIC), true);
+        testSetter(instanceSetter, FieldAccessor.ofField(FOO).defineAs(propertyType, Visibility.PUBLIC), true);
     }
 
     @SuppressWarnings("unchecked")

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/ByteBuddyCommonsTest.java
Patch:
@@ -4,7 +4,7 @@
 import net.bytebuddy.instrumentation.method.MethodDescription;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.modifier.FieldManifestation;
-import net.bytebuddy.modifier.MemberVisibility;
+import net.bytebuddy.modifier.Visibility;
 import net.bytebuddy.modifier.Ownership;
 import org.junit.Before;
 import org.junit.Rule;
@@ -170,7 +170,7 @@ public void testResolveModifierContributors() throws Exception {
         assertThat(resolveModifierContributors(ByteBuddyCommons.FIELD_MODIFIER_MASK,
                 FieldManifestation.FINAL,
                 Ownership.STATIC,
-                MemberVisibility.PRIVATE), is(Opcodes.ACC_FINAL | Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE));
+                Visibility.PRIVATE), is(Opcodes.ACC_FINAL | Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE));
     }
 
     @Test(expected = IllegalArgumentException.class)

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/MethodDelegationBinder.java
Patch:
@@ -859,7 +859,8 @@ private MethodBinding resolve(MethodDescription source,
                             return right;
                         case AMBIGUOUS:
                         case UNKNOWN:
-                            throw new IllegalArgumentException("Could not resolve ambiguous delegation to " + left + " or " + right);
+                            throw new IllegalArgumentException(String.format("Could not resolve ambiguous delegation " +
+                                    "of %s: %s or %s", source, left, right));
                         default:
                             throw new AssertionError();
                     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentedType.java
Patch:
@@ -171,7 +171,7 @@ public TypeDescription detach() {
 
     @Override
     public TypeDescription getSupertype() {
-        return superClass;
+        return isInterface() ? null : superClass;
     }
 
     @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/NamingStrategy.java
Patch:
@@ -84,7 +84,8 @@ static interface UnnamedType {
      * </ol>
      * Between all these elements, a {@code $} sign is included into the name to improve readability. As an exception,
      * types that subclass classes from the {@code java.**} packages are prefixed with a given package. This is
-     * necessary as it is illegal to define non-bootstrap classes in this name space.
+     * necessary as it is illegal to define non-bootstrap classes in this name space. The same strategy is applied
+     * when subclassing a signed type which is equally illegal.
      */
     static class SuffixingRandom implements NamingStrategy {
 
@@ -142,7 +143,7 @@ public SuffixingRandom(String suffix, String javaLangPackagePrefix) {
         @Override
         public String name(UnnamedType unnamedType) {
             String superClassName = unnamedType.getSuperClass().getName();
-            if (superClassName.startsWith(JAVA_PACKAGE)) {
+            if (superClassName.startsWith(JAVA_PACKAGE) || unnamedType.getSuperClass().isSealed()) {
                 superClassName = javaLangPackagePrefix + "." + superClassName;
             }
             return String.format("%s$%s$%d", superClassName, suffix, Math.abs(random.nextInt()));

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Origin.java
Patch:
@@ -57,7 +57,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(Origin annotation,
                                                                Assigner assigner) {
             TypeDescription parameterType = target.getParameterTypes().get(targetParameterIndex);
             if (parameterType.represents(Class.class)) {
-                return new MethodDelegationBinder.ParameterBinding.Anonymous(new ClassConstant(instrumentationTarget.getTypeDescription()));
+                return new MethodDelegationBinder.ParameterBinding.Anonymous(ClassConstant.of(instrumentationTarget.getTypeDescription()));
             } else if (parameterType.represents(Method.class)) {
                 return new MethodDelegationBinder.ParameterBinding.Anonymous(MethodConstant.forMethod(source));
             } else {

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/constant/MethodConstant.java
Patch:
@@ -62,7 +62,7 @@ public static StackManipulation forMethod(MethodDescription methodDescription) {
     private static List<StackManipulation> typeConstantsFor(List<TypeDescription> parameterTypes) {
         List<StackManipulation> typeConstants = new ArrayList<StackManipulation>(parameterTypes.size());
         for (TypeDescription parameterType : parameterTypes) {
-            typeConstants.add(new ClassConstant(parameterType));
+            typeConstants.add(ClassConstant.of(parameterType));
         }
         return typeConstants;
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategy.java
Patch:
@@ -109,7 +109,7 @@ public MethodRegistry inject(MethodRegistry methodRegistry,
                 case DEFAULT_CONSTRUCTOR:
                 case IMITATE_SUPER_TYPE:
                 case IMITATE_SUPER_TYPE_FULLY:
-                    return methodRegistry.append(new MethodRegistry.LatentMethodMatcher.Simple(isConstructor()),
+                    return methodRegistry.prepend(new MethodRegistry.LatentMethodMatcher.Simple(isConstructor()),
                             SuperMethodCall.INSTANCE,
                             defaultMethodAttributeAppenderFactory);
                 default:

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentedTypeTest.java
Patch:
@@ -16,13 +16,13 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.IsNot.not;
 
-public class SubclassInstumentedTypeTest extends AbstractInstrumentedTypeTest {
+public class SubclassInstrumentedTypeTest extends AbstractInstrumentedTypeTest {
 
     private static final String FOO = "foo", BAR = "bar", FOOBAR = FOO + "." + BAR;
 
     @Override
     protected InstrumentedType makePlainInstrumentedType() {
-        return new SubclassInstumentedType(
+        return new SubclassInstrumentedType(
                 ClassFileVersion.forCurrentJavaVersion(),
                 new TypeDescription.ForLoadedType(Object.class),
                 new TypeList.ForLoadedType(Collections.<Class<?>>singletonList(Serializable.class)),

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/AllArgumentsAnnotationBinderTest.java
Patch:
@@ -53,6 +53,7 @@ public void testLegalBindingNoRuntimeType() throws Exception {
     }
 
     private void testLegalBinding(Annotation[][] targetAnnotations, boolean considerRuntimeType) throws Exception {
+        when(annotation.value()).thenReturn(AllArguments.Binding.STRICT);
         when(stackManipulation.isValid()).thenReturn(true);
         when(sourceTypeList.iterator()).thenReturn(Arrays.asList(firstSourceType, secondSourceType).iterator());
         when(source.isStatic()).thenReturn(false);
@@ -76,6 +77,7 @@ private void testLegalBinding(Annotation[][] targetAnnotations, boolean consider
 
     @Test
     public void testIllegalBinding() throws Exception {
+        when(annotation.value()).thenReturn(AllArguments.Binding.STRICT);
         when(stackManipulation.isValid()).thenReturn(false);
         when(sourceTypeList.iterator()).thenReturn(Arrays.asList(firstSourceType, secondSourceType).iterator());
         when(source.isStatic()).thenReturn(false);

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/DefaultCall.java
Patch:
@@ -15,8 +15,6 @@
 @Target(ElementType.PARAMETER)
 public @interface DefaultCall {
 
-    static final Class<?> IMPLICIT_TARGET = void.class;
-
     Class<?> targetType() default void.class;
 
     static enum Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder<DefaultCall> {
@@ -49,7 +47,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(DefaultCall annotation,
         }
 
         private static MethodLocator locate(Class<?> type) {
-            return type == IMPLICIT_TARGET
+            return type == void.class
                     ? MethodLocator.Implicit.INSTANCE
                     : new MethodLocator.Explicit(type);
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/auxiliary/MethodCallProxy.java
Patch:
@@ -5,7 +5,6 @@
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
 import net.bytebuddy.instrumentation.Instrumentation;
-import net.bytebuddy.instrumentation.ModifierContributor;
 import net.bytebuddy.instrumentation.field.FieldDescription;
 import net.bytebuddy.instrumentation.field.FieldList;
 import net.bytebuddy.instrumentation.method.MethodDescription;
@@ -104,7 +103,7 @@ public DynamicType make(String auxiliaryTypeName,
                 .subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS)
                 .methodLookupEngine(ProxyMethodLookupEngine.INSTANCE)
                 .name(auxiliaryTypeName)
-                .modifiers(DEFAULT_TYPE_MODIFIER.toArray(new ModifierContributor.ForType[DEFAULT_TYPE_MODIFIER.size()]))
+                .modifiers(DEFAULT_TYPE_MODIFIER)
                 .implement(Runnable.class)
                 .implement(Callable.class)
                 .method(not(isDeclaredBy(Object.class))).intercept(methodCall)

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/auxiliary/TypeProxy.java
Patch:
@@ -6,7 +6,6 @@
 import net.bytebuddy.dynamic.TargetType;
 import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
 import net.bytebuddy.instrumentation.Instrumentation;
-import net.bytebuddy.instrumentation.ModifierContributor;
 import net.bytebuddy.instrumentation.method.MethodDescription;
 import net.bytebuddy.instrumentation.method.bytecode.ByteCodeAppender;
 import net.bytebuddy.instrumentation.method.bytecode.stack.Duplication;
@@ -72,7 +71,7 @@ public DynamicType make(String auxiliaryTypeName,
         return new ByteBuddy(classFileVersion)
                 .subclass(proxiedType, ConstructorStrategy.Default.IMITATE_SUPER_TYPE)
                 .name(auxiliaryTypeName)
-                .modifiers(DEFAULT_TYPE_MODIFIER.toArray(new ModifierContributor.ForType[DEFAULT_TYPE_MODIFIER.size()]))
+                .modifiers(DEFAULT_TYPE_MODIFIER)
                 .method(finalizerMatcher)
                 .intercept(new MethodCall(methodAccessorFactory))
                 .defineMethod(REFLECTION_METHOD, TargetType.DESCRIPTION, Collections.<TypeDescription>emptyList(), Ownership.STATIC)

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/MethodDelegation.java
Patch:
@@ -316,7 +316,8 @@ private static List<TargetMethodAnnotationDrivenBinder.ParameterBinder<?>> defau
                 Origin.Binder.INSTANCE,
                 This.Binder.INSTANCE,
                 Super.Binder.INSTANCE,
-                SuperCall.Binder.INSTANCE);
+                SuperCall.Binder.INSTANCE,
+                DefaultCall.Binder.INSTANCE);
     }
 
     private static TargetMethodAnnotationDrivenBinder.DefaultsProvider<?> defaultDefaultsProvider() {

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/AllArguments.java
Patch:
@@ -29,7 +29,7 @@
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.PARAMETER})
+@Target(ElementType.PARAMETER)
 public @interface AllArguments {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Argument.java
Patch:
@@ -29,7 +29,7 @@
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.PARAMETER})
+@Target(ElementType.PARAMETER)
 public @interface Argument {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/BindingPriority.java
Patch:
@@ -11,7 +11,7 @@
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.METHOD})
+@Target(ElementType.METHOD)
 public @interface BindingPriority {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/IgnoreForBinding.java
Patch:
@@ -12,7 +12,7 @@
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.METHOD})
+@Target(ElementType.METHOD)
 public @interface IgnoreForBinding {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Origin.java
Patch:
@@ -27,7 +27,7 @@
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.PARAMETER})
+@Target(ElementType.PARAMETER)
 public @interface Origin {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/Super.java
Patch:
@@ -46,7 +46,7 @@
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.PARAMETER, ElementType.METHOD})
+@Target(ElementType.PARAMETER)
 public @interface Super {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/TargetMethodAnnotationDrivenBinder.java
Patch:
@@ -42,7 +42,9 @@ public TargetMethodAnnotationDrivenBinder(List<ParameterBinder<?>> parameterBind
     }
 
     @Override
-    public MethodBinding bind(Instrumentation.Target instrumentationTarget, MethodDescription source, MethodDescription target) {
+    public MethodBinding bind(Instrumentation.Target instrumentationTarget,
+                              MethodDescription source,
+                              MethodDescription target) {
         if (IgnoreForBinding.Verifier.check(target)) {
             return MethodBinding.Illegal.INSTANCE;
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/This.java
Patch:
@@ -21,7 +21,7 @@
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.PARAMETER})
+@Target(ElementType.PARAMETER)
 public @interface This {
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/MethodDescription.java
Patch:
@@ -23,6 +23,8 @@ public interface MethodDescription extends ModifierReviewable, ByteCodeMethod, D
      */
     static final String CONSTRUCTOR_INTERNAL_NAME = "<init>";
 
+    static final String STATIC_INITIALIZER_INTERNAL_NAME = "<clinit>";
+
     /**
      * Returns a description of the return type of the method described by this instance.
      *
@@ -485,7 +487,7 @@ public TypeList getExceptionTypes() {
 
         @Override
         public boolean isConstructor() {
-            return CONSTRUCTOR_INTERNAL_NAME.equals(internalName);
+            return CONSTRUCTOR_INTERNAL_NAME.equals(internalName) || STATIC_INITIALIZER_INTERNAL_NAME.equals(internalName);
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/InstrumentedType.java
Patch:
@@ -464,7 +464,7 @@ public TypeList getExceptionTypes() {
 
             @Override
             public boolean isConstructor() {
-                return CONSTRUCTOR_INTERNAL_NAME.equals(internalName);
+                return CONSTRUCTOR_INTERNAL_NAME.equals(internalName) || STATIC_INITIALIZER_INTERNAL_NAME.equals(internalName);
             }
 
             @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/MethodDescription.java
Patch:
@@ -168,7 +168,7 @@ public int getParameterOffset(int parameterIndex) {
 
         @Override
         public boolean isDefaultMethod() {
-            return !isAbstract() && getDeclaringType().isInterface();
+            return !isAbstract() && !isBridge() && getDeclaringType().isInterface();
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/SuperCall.java
Patch:
@@ -58,7 +58,8 @@ public MethodDelegationBinder.ParameterBinding<?> bind(SuperCall annotation,
             if (!targetType.represents(Runnable.class) && !targetType.represents(Callable.class) && !targetType.represents(Object.class)) {
                 throw new IllegalStateException("A method call proxy can only be assigned to Runnable or Callable types: " + target);
             } else {
-                Instrumentation.SpecialMethodInvocation specialMethodInvocation = instrumentationTarget.invokeSuper(source, Instrumentation.Target.MethodLookup.EXACT);
+                Instrumentation.SpecialMethodInvocation specialMethodInvocation = instrumentationTarget.invokeSuper(source,
+                        Instrumentation.Target.MethodLookup.Default.EXACT);
                 return specialMethodInvocation.isValid()
                         ? new MethodDelegationBinder.ParameterBinding.Anonymous(new MethodCallProxy.AssignableSignatureCall(specialMethodInvocation))
                         : MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/ExceptionMethod.java
Patch:
@@ -72,7 +72,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
     }
 
     @Override
-    public ByteCodeAppender appender(TypeDescription instrumentedType) {
+    public ByteCodeAppender appender(Target instrumentationTarget) {
         return this;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/FixedValue.java
Patch:
@@ -279,7 +279,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
         }
 
         @Override
-        public ByteCodeAppender appender(TypeDescription instrumentedType) {
+        public ByteCodeAppender appender(Target instrumentationTarget) {
             return this;
         }
 
@@ -371,8 +371,8 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
         }
 
         @Override
-        public ByteCodeAppender appender(TypeDescription instrumentedType) {
-            return new StaticFieldByteCodeAppender(instrumentedType);
+        public ByteCodeAppender appender(Target instrumentationTarget) {
+            return new StaticFieldByteCodeAppender(instrumentationTarget.getTypeDescription());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/StubMethod.java
Patch:
@@ -6,7 +6,6 @@
 import net.bytebuddy.instrumentation.method.bytecode.stack.constant.DefaultValue;
 import net.bytebuddy.instrumentation.method.bytecode.stack.member.MethodReturn;
 import net.bytebuddy.instrumentation.type.InstrumentedType;
-import net.bytebuddy.instrumentation.type.TypeDescription;
 import org.objectweb.asm.MethodVisitor;
 
 /**
@@ -33,7 +32,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
     }
 
     @Override
-    public ByteCodeAppender appender(TypeDescription instrumentedType) {
+    public ByteCodeAppender appender(Target instrumentationTarget) {
         return this;
     }
 

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/SuperMethodCall.java
Patch:
@@ -36,11 +36,11 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
     }
 
     @Override
-    public ByteCodeAppender appender(TypeDescription instrumentedType) {
-        if (instrumentedType.getSupertype() == null) {
+    public ByteCodeAppender appender(Target instrumentationTarget) {
+        if (instrumentationTarget.getTypeDescription().getSupertype() == null) {
             throw new IllegalArgumentException("The object type does not have a super type");
         }
-        return new SuperMethodCallAppender(instrumentedType.getSupertype());
+        return new SuperMethodCallAppender(instrumentationTarget.getTypeDescription().getSupertype());
     }
 
     private static class SuperMethodCallAppender implements ByteCodeAppender {

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTest.java
Patch:
@@ -362,7 +362,7 @@ public InstrumentedType prepare(InstrumentedType instrumentedType) {
         }
 
         @Override
-        public ByteCodeAppender appender(TypeDescription instrumentedType) {
+        public ByteCodeAppender appender(Target instrumentationTarget) {
             return SumMethod.INSTANCE;
         }
     }

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilderTest.java
Patch:
@@ -66,7 +66,7 @@ public InstrumentedType answer(InvocationOnMock invocation) throws Throwable {
                 return (InstrumentedType) invocation.getArguments()[0];
             }
         });
-        when(instrumentation.appender(any(TypeDescription.class))).thenReturn(byteCodeAppender);
+        when(instrumentation.appender(any(Instrumentation.Target.class))).thenReturn(byteCodeAppender);
         when(byteCodeAppender.appendsCode()).thenReturn(true);
         when(byteCodeAppender.apply(any(MethodVisitor.class), any(Instrumentation.Context.class), any(MethodDescription.class)))
                 .thenAnswer(new Answer<ByteCodeAppender.Size>() {
@@ -192,7 +192,7 @@ public void testSubclassWithDefinedMethod() throws Exception {
         assertThat(loaded.getDeclaredConstructors().length, is(1));
         assertThat(loaded.getDeclaredConstructor().newInstance(), notNullValue());
         verify(instrumentation).prepare(any(InstrumentedType.class));
-        verify(instrumentation).appender(any(TypeDescription.class));
+        verify(instrumentation).appender(any(Instrumentation.Target.class));
         verifyNoMoreInteractions(instrumentation);
         verify(byteCodeAppender).appendsCode();
         verify(byteCodeAppender).apply(any(MethodVisitor.class), any(Instrumentation.Context.class), any(MethodDescription.class));

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/auxiliary/MethodCallProxy.java
Patch:
@@ -157,7 +157,7 @@ public Finding process(TypeDescription typeDescription) {
             methodDescriptions.addAll(typeDescription.getDeclaredMethods());
             return new Finding.Default(typeDescription,
                     new MethodList.Explicit(methodDescriptions),
-                    Collections.<MethodDescription, TypeDescription>emptyMap());
+                    Collections.<TypeDescription, Set<MethodDescription>>emptyMap());
         }
 
         @Override

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -366,7 +366,7 @@ public DynamicType.Unloaded<T> make() {
                 interfaceTypes,
                 modifiers,
                 namingStrategy));
-        MethodLookupEngine methodLookupEngine = methodLookupEngineFactory.make();
+        MethodLookupEngine methodLookupEngine = methodLookupEngineFactory.make(classFileVersion);
         SubclassInstrumentationContextDelegate contextDelegate = new SubclassInstrumentationContextDelegate(instrumentedType,
                 methodLookupEngine,
                 bridgeMethodResolverFactory);

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/Instrumentation.java
Patch:
@@ -147,10 +147,10 @@ public TypeDescription register(AuxiliaryType auxiliaryType) {
             }
 
             @Override
-            public MethodDescription requireAccessorMethodFor(MethodDescription targetMethod) {
+            public MethodDescription requireAccessorMethodFor(MethodDescription targetMethod, LookupMode lookupMode) {
                 MethodDescription accessorMethod = registeredAccessorMethods.get(targetMethod);
                 if (accessorMethod == null) {
-                    accessorMethod = methodAccessorFactory.requireAccessorMethodFor(targetMethod);
+                    accessorMethod = methodAccessorFactory.requireAccessorMethodFor(targetMethod, lookupMode);
                     registeredAccessorMethods.put(targetMethod, accessorMethod);
                 }
                 return accessorMethod;

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/MethodDelegation.java
Patch:
@@ -335,7 +335,7 @@ private static Assigner defaultAssigner() {
     }
 
     private static MethodLookupEngine defaultMethodLookupEngine() {
-        return new MethodLookupEngine.Default();
+        return new MethodLookupEngine.Default(false);
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/auxiliary/MethodCallProxy.java
Patch:
@@ -100,7 +100,8 @@ private static String fieldName(int index) {
     public DynamicType make(String auxiliaryTypeName,
                             ClassFileVersion classFileVersion,
                             MethodAccessorFactory methodAccessorFactory) {
-        MethodDescription accessorMethod = methodAccessorFactory.requireAccessorMethodFor(targetMethod);
+        MethodDescription accessorMethod = methodAccessorFactory.requireAccessorMethodFor(targetMethod,
+                MethodAccessorFactory.LookupMode.Default.EXACT);
         LinkedHashMap<String, TypeDescription> parameterFields = extractFields(accessorMethod);
         Instrumentation methodCall = new MethodCall(accessorMethod, assigner);
         DynamicType.Builder<?> builder = new ByteBuddy(classFileVersion)
@@ -161,7 +162,7 @@ public MethodList getReachableMethods(TypeDescription typeDescription) {
         }
 
         @Override
-        public MethodLookupEngine make() {
+        public MethodLookupEngine make(ClassFileVersion classFileVersion) {
             return this;
         }
     }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/type/auxiliary/TypeProxy.java
Patch:
@@ -322,7 +322,8 @@ public boolean appendsCode() {
             public Size apply(MethodVisitor methodVisitor,
                               Context instrumentationContext,
                               MethodDescription instrumentedMethod) {
-                MethodDescription proxyMethod = methodAccessorFactory.requireAccessorMethodFor(instrumentedMethod);
+                MethodDescription proxyMethod = methodAccessorFactory.requireAccessorMethodFor(instrumentedMethod,
+                        MethodAccessorFactory.LookupMode.Default.BY_SIGNATURE);
                 StackManipulation.Size stackSize = new StackManipulation.Compound(
                         MethodVariableAccess.forType(instrumentedType).loadFromIndex(0),
                         fieldLoadingInstruction,

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/BridgeMethodResolverSimpleTest.java
Patch:
@@ -36,7 +36,7 @@ public class BridgeMethodResolverSimpleTest {
     @Test
     public void testFindsBridgeMethodSingleStep() throws Exception {
         TypeDescription target = new TypeDescription.ForLoadedType(Bar.class);
-        MethodList reachableMethods = new MethodLookupEngine.Default().getReachableMethods(target);
+        MethodList reachableMethods = new MethodLookupEngine.Default(false).getReachableMethods(target);
         MethodList relevantMethods = reachableMethods.filter(not(isConstructor().or(isDeclaredBy(Object.class))));
         assertThat(relevantMethods.size(), is(2));
         BridgeMethodResolver bridgeMethodResolver = new BridgeMethodResolver.Simple(reachableMethods, conflictHandler);
@@ -48,7 +48,7 @@ public void testFindsBridgeMethodSingleStep() throws Exception {
     @Test
     public void testFindsBridgeMethodTwoStep() throws Exception {
         TypeDescription target = new TypeDescription.ForLoadedType(Qux.class);
-        MethodList reachableMethods = new MethodLookupEngine.Default().getReachableMethods(target);
+        MethodList reachableMethods = new MethodLookupEngine.Default(false).getReachableMethods(target);
         MethodList relevantMethods = reachableMethods.filter(not(isConstructor().or(isDeclaredBy(Object.class))));
         assertThat(relevantMethods.size(), is(3));
         BridgeMethodResolver bridgeMethodResolver = new BridgeMethodResolver.Simple(reachableMethods, conflictHandler);
@@ -61,7 +61,7 @@ public void testFindsBridgeMethodTwoStep() throws Exception {
     @Test
     public void testFindsBridgeMethodConflictResolver() throws Exception {
         TypeDescription target = new TypeDescription.ForLoadedType(Baz.class);
-        MethodList reachableMethods = new MethodLookupEngine.Default().getReachableMethods(target);
+        MethodList reachableMethods = new MethodLookupEngine.Default(false).getReachableMethods(target);
         MethodList relevantMethods = reachableMethods.filter(not(isConstructor().or(isDeclaredBy(Object.class))));
         assertThat(relevantMethods.size(), is(3));
         when(conflictHandler.choose(any(MethodDescription.class), any(MethodList.class))).thenReturn(bridgeTarget);

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/type/auxiliary/TypeProxyTest.java
Patch:
@@ -28,6 +28,7 @@
 import static org.hamcrest.CoreMatchers.nullValue;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.when;
 
 @RunWith(Parameterized.class)
@@ -83,7 +84,8 @@ public void testMethodOfTypeProxy() throws Exception {
 
     @SuppressWarnings("unchecked")
     private <T> Class<T> makeProxyType(Class<T> proxyType, Class<?> instrumentedType) {
-        when(methodAccessorFactory.requireAccessorMethodFor(any(MethodDescription.class))).then(new SameSignatureAnswer());
+        when(methodAccessorFactory.requireAccessorMethodFor(any(MethodDescription.class),
+                eq(AuxiliaryType.MethodAccessorFactory.LookupMode.Default.BY_SIGNATURE))).then(new SameSignatureAnswer());
         String auxiliaryTypeName = instrumentedType.getName() + "$" + QUX;
         DynamicType dynamicType = new TypeProxy(
                 new TypeDescription.ForLoadedType(proxyType),

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/loading/ByteArrayClassLoader.java
Patch:
@@ -12,6 +12,9 @@
  */
 public class ByteArrayClassLoader extends ClassLoader {
 
+    /**
+     * A mutable map of type names mapped to their binary representation.
+     */
     private final Map<String, byte[]> typeDefinitions;
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -63,6 +63,7 @@ public class SubclassDynamicTypeBuilder<T> extends DynamicType.Builder.AbstractB
      * @param classVisitorWrapperChain              A chain of ASM class visitors to apply to the writing process.
      * @param fieldRegistry                         The field registry to apply to the dynamic type creation.
      * @param methodRegistry                        The method registry to apply to the dynamic type creation.
+     * @param methodLookupEngineFactory             The method lookup engine factory to apply to the dynamic type creation.
      * @param defaultFieldAttributeAppenderFactory  The field attribute appender factory that should be applied by default if
      *                                              no specific appender was specified for a given field.
      * @param defaultMethodAttributeAppenderFactory The method attribute appender factory that should be applied by default
@@ -116,6 +117,7 @@ public SubclassDynamicTypeBuilder(ClassFileVersion classFileVersion,
      * @param classVisitorWrapperChain              A chain of ASM class visitors to apply to the writing process.
      * @param fieldRegistry                         The field registry to apply to the dynamic type creation.
      * @param methodRegistry                        The method registry to apply to the dynamic type creation.
+     * @param methodLookupEngineFactory             The method lookup engine factory to apply to the dynamic type creation.
      * @param defaultFieldAttributeAppenderFactory  The field attribute appender factory that should be applied by default if
      *                                              no specific appender was specified for a given field.
      * @param defaultMethodAttributeAppenderFactory The method attribute appender factory that should be applied by default

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/SuperMethodCall.java
Patch:
@@ -71,7 +71,7 @@ public Size apply(MethodVisitor methodVisitor,
                 targetMethod = instrumentedMethod;
             }
             StackManipulation.Size stackSize = new StackManipulation.Compound(
-                    MethodVariableAccess.loadThisAndArguments(instrumentedMethod),
+                    MethodVariableAccess.loadThisReferenceAndArguments(instrumentedMethod),
                     MethodInvocation.invoke(targetMethod).special(targetType),
                     MethodReturn.returning(instrumentedMethod.getReturnType())
             ).apply(methodVisitor, instrumentationContext);

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/stack/member/MethodVariableAccess.java
Patch:
@@ -80,7 +80,7 @@ public static MethodVariableAccess forType(TypeDescription typeDescription) {
      * @return A stack manipulation representing the loading of all method arguments including a reference to the
      * instance if any.
      */
-    public static StackManipulation loadThisAndArguments(MethodDescription methodDescription) {
+    public static StackManipulation loadThisReferenceAndArguments(MethodDescription methodDescription) {
         return loadArguments(methodDescription, true);
     }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentationContextDelegateTest.java
Patch:
@@ -67,12 +67,14 @@ public void setUp() throws Exception {
         when(firstMethod.getDeclaringType()).thenReturn(superType);
         when(firstMethod.getInternalName()).thenReturn(QUX);
         when(firstMethod.getUniqueSignature()).thenReturn(FOO);
+        when(firstMethod.isSpecializableFor(superType)).thenReturn(true);
         when(firstMethodReturnType.getStackSize()).thenReturn(StackSize.ZERO);
         when(secondMethod.getReturnType()).thenReturn(secondMethodReturnType);
         when(secondMethod.getParameterTypes()).thenReturn(secondMethodParameters);
         when(secondMethod.getDeclaringType()).thenReturn(superType);
         when(secondMethod.getInternalName()).thenReturn(BAZ);
         when(secondMethod.getUniqueSignature()).thenReturn(BAZ);
+        when(secondMethod.isSpecializableFor(superType)).thenReturn(true);
         MethodDescription toStringMethod = new TypeDescription.ForLoadedType(Object.class)
                 .getDeclaredMethods().filter(named(TO_STRING)).getOnly();
         when(superType.isAssignableFrom(superType)).thenReturn(true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/SuperMethodCallPreparationAndExceptionTest.java
Patch:
@@ -63,7 +63,7 @@ public void testConstructor() throws Exception {
         SuperMethodCall.INSTANCE.appender(typeDescription).apply(methodVisitor, instrumentationContext, methodDescription);
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test(expected = IllegalArgumentException.class)
     public void testStaticMethod() throws Exception {
         when(typeDescription.getSupertype()).thenReturn(superType);
         when(methodDescription.isStatic()).thenReturn(true);

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/method/bytecode/stack/member/MethodArgumentDescriptionTest.java
Patch:
@@ -61,7 +61,7 @@ public void tearDown() throws Exception {
     @Test
     public void testStaticMethod() throws Exception {
         when(methodDescription.isStatic()).thenReturn(true);
-        StackManipulation stackManipulation = MethodVariableAccess.loadThisAndArguments(methodDescription);
+        StackManipulation stackManipulation = MethodVariableAccess.loadThisReferenceAndArguments(methodDescription);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, instrumentationContext);
         assertThat(size.getSizeImpact(), is(PARAMETER_STACK_SIZE));
@@ -73,7 +73,7 @@ public void testStaticMethod() throws Exception {
 
     @Test
     public void testNonStaticMethod() throws Exception {
-        StackManipulation stackManipulation = MethodVariableAccess.loadThisAndArguments(methodDescription);
+        StackManipulation stackManipulation = MethodVariableAccess.loadThisReferenceAndArguments(methodDescription);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, instrumentationContext);
         assertThat(size.getSizeImpact(), is(PARAMETER_STACK_SIZE + 1));

File: byte-buddy-dep/src/main/java/net/bytebuddy/asm/ClassVisitorWrapper.java
Patch:
@@ -27,6 +27,9 @@ public interface ClassVisitorWrapper {
      */
     static class Chain implements ClassVisitorWrapper {
 
+        /**
+         * The class visitor wrappers that are represented by this chain in their order. This list must not be mutated.
+         */
         private final List<ClassVisitorWrapper> classVisitorWrappers;
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/TypeInitializer.java
Patch:
@@ -58,6 +58,7 @@ static class ForStaticField<T> implements TypeInitializer, Serializable {
         private final String fieldName;
         private final T value;
         private final boolean makeAccessible;
+
         /**
          * Creates a new {@link net.bytebuddy.instrumentation.TypeInitializer} for setting a static field.
          *

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/MethodList.java
Patch:
@@ -52,7 +52,7 @@ public MethodDescription get(int index) {
             if (index < type.getDeclaredConstructors().length) {
                 return new MethodDescription.ForLoadedConstructor(type.getDeclaredConstructors()[index]);
             } else {
-                return new MethodDescription.ForLoadedMethod(type.getDeclaredMethods()[type.getDeclaredConstructors().length + index]);
+                return new MethodDescription.ForLoadedMethod(type.getDeclaredMethods()[index - type.getDeclaredConstructors().length]);
             }
         }
 

File: byte-buddy-dep/src/test/java/net/bytebuddy/instrumentation/AbstractInstrumentationTest.java
Patch:
@@ -13,6 +13,7 @@
 import net.bytebuddy.instrumentation.attribute.FieldAttributeAppender;
 import net.bytebuddy.instrumentation.attribute.MethodAttributeAppender;
 import net.bytebuddy.instrumentation.attribute.TypeAttributeAppender;
+import net.bytebuddy.instrumentation.method.MethodLookupEngine;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.instrumentation.type.TypeList;
 import org.objectweb.asm.Opcodes;
@@ -39,6 +40,7 @@ protected <T> DynamicType.Loaded<T> instrument(Class<T> target, Instrumentation
                 new ClassVisitorWrapper.Chain(),
                 new FieldRegistry.Default(),
                 new MethodRegistry.Default(),
+                MethodLookupEngine.Default.Factory.INSTANCE,
                 FieldAttributeAppender.NoOp.INSTANCE,
                 MethodAttributeAppender.NoOp.INSTANCE,
                 ConstructorStrategy.Default.IMITATE_SUPER_TYPE)

File: byte-buddy-benchmark/src/main/java/net/bytebuddy/benchmark/runner/QuickRunner.java
Patch:
@@ -32,6 +32,6 @@ public static void main(String[] args) throws RunnerException {
     }
 
     private QuickRunner() {
-        throw new AssertionError();
+        throw new UnsupportedOperationException();
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/IgnoreForBinding.java
Patch:
@@ -21,7 +21,7 @@
     static final class Verifier {
 
         private Verifier() {
-            throw new AssertionError();
+            throw new UnsupportedOperationException();
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/bytecode/bind/annotation/RuntimeType.java
Patch:
@@ -27,7 +27,7 @@
     static final class Verifier {
 
         private Verifier() {
-            throw new AssertionError();
+            throw new UnsupportedOperationException();
         }
 
         /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/instrumentation/method/matcher/MethodMatchers.java
Patch:
@@ -24,7 +24,7 @@
 public final class MethodMatchers {
 
     private MethodMatchers() {
-        throw new AssertionError();
+        throw new UnsupportedOperationException();
     }
 
     /**

File: byte-buddy-dep/src/main/java/net/bytebuddy/utility/ByteBuddyCommons.java
Patch:
@@ -65,7 +65,7 @@ public final class ByteBuddyCommons {
     );
 
     private ByteBuddyCommons() {
-        throw new AssertionError();
+        throw new UnsupportedOperationException();
     }
 
     /**

File: byte-buddy-dep/src/test/java/net/bytebuddy/utility/MoreOpcodes.java
Patch:
@@ -31,6 +31,6 @@ public final class MoreOpcodes {
     public static final int ALOAD_3 = 45;
 
     private MoreOpcodes() {
-        throw new AssertionError();
+        throw new UnsupportedOperationException();
     }
 }

File: byte-buddy-dep/src/main/java/net/bytebuddy/ClassFileVersion.java
Patch:
@@ -91,7 +91,7 @@ public static ClassFileVersion forKnownJavaVersion(int javaVersion) {
      */
     public static ClassFileVersion forCurrentJavaVersion() {
         String versionString = System.getProperty(JAVA_VERSION_PROPERTY);
-        int[] versionIndex = new int[]{ -1, 0, 0 };
+        int[] versionIndex = {-1, 0, 0};
         for (int i = 1; i < 3; i++) {
             versionIndex[i] = versionString.indexOf('.', versionIndex[i - 1] + 1);
             if (versionIndex[i] == -1) {

File: byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentationContextDelegate.java
Patch:
@@ -109,7 +109,9 @@ public MethodDescription requireAccessorMethodFor(MethodDescription targetMethod
                 targetMethod.getParameterTypes(),
                 (targetMethod.isStatic() ? Opcodes.ACC_STATIC : 0) | Opcodes.ACC_SYNTHETIC | Opcodes.ACC_FINAL);
         knownTargetMethodsToAccessorMethod.put(targetMethod, accessorMethod);
-        Entry methodCall = targetMethod.isAbstract() || targetMethod.getDeclaringType().equals(instrumentedType)
+        Entry methodCall = targetMethod.isAbstract()
+                || targetMethod.getDeclaringType().isInterface() // covers Java 8 default methods
+                || targetMethod.getDeclaringType().equals(instrumentedType)
                 ? AbstractMethodCall.INSTANCE
                 : new SameSignatureMethodCall(bridgeMethodResolver.resolve(targetMethod), instrumentedType);
         registeredAccessorMethodToTargetMethodCall.put(accessorMethod, methodCall);

File: byte-buddy-dep/src/test/java/net/bytebuddy/ByteBuddyTest.java
Patch:
@@ -393,6 +393,7 @@ public static interface Interceptor2 {
     @SuppressWarnings("unused")
     public static class HelloWorldInterceptor implements Interceptor2 {
 
+        @Override
         public String doSomethingElse() {
             return "Hello World!";
         }

File: byte-buddy-dep/src/main/java/net/bytebuddy/ByteBuddy.java
Patch:
@@ -15,6 +15,7 @@
 import net.bytebuddy.instrumentation.method.matcher.MethodMatcher;
 import net.bytebuddy.instrumentation.type.TypeDescription;
 import net.bytebuddy.instrumentation.type.TypeList;
+import net.bytebuddy.modifier.TypeManifestation;
 
 import java.lang.annotation.Annotation;
 import java.util.Collections;
@@ -314,7 +315,7 @@ public <T> DynamicType.Builder<T> subclass(TypeDescription superType, Constructo
                 namingStrategy,
                 actualSuperType,
                 interfaceTypes,
-                modifiers.resolve(superType.getModifiers()),
+                modifiers.resolve(superType.getModifiers() & ~TypeManifestation.INTERFACE.getMask()),
                 typeAttributeAppender.resolve(TypeAttributeAppender.NoOp.INSTANCE),
                 ignoredMethods,
                 bridgeMethodResolverFactory,

File: byte-buddy-dep/src/main/java/net/bytebuddy/modifier/TypeManifestation.java
Patch:
@@ -11,7 +11,7 @@ public enum TypeManifestation implements ModifierContributor.ForType {
     PLAIN(EMPTY_MASK),
     FINAL(Opcodes.ACC_FINAL),
     ABSTRACT(Opcodes.ACC_ABSTRACT),
-    INTERFACE(Opcodes.ACC_INTERFACE | Opcodes.ACC_INTERFACE),
+    INTERFACE(Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT),
     ENUM(Opcodes.ACC_ENUM | Opcodes.ACC_FINAL),
     ABSTRACT_ENUM(Opcodes.ACC_ENUM | Opcodes.ACC_ABSTRACT);
 

File: src/test/java/net/bytebuddy/dynamic/DynamicTypeDefaultTest.java
Patch:
@@ -52,14 +52,14 @@ public void setUp() throws Exception {
         when(auxiliaryType.saveIn(any(File.class))).thenReturn(Collections.<TypeDescription, File>emptyMap());
         when(auxiliaryTypeDescription.getName()).thenReturn(BAR);
         when(auxiliaryType.getDescription()).thenReturn(auxiliaryTypeDescription);
-        when(auxiliaryType.getByte()).thenReturn(auxiliaryTypeBinaryRepresentation);
+        when(auxiliaryType.getBytes()).thenReturn(auxiliaryTypeBinaryRepresentation);
         when(auxiliaryType.getTypeInitializers()).thenReturn(Collections.singletonMap(auxiliaryTypeDescription, auxiliaryTypeInitializer));
         when(auxiliaryType.getRawAuxiliaryTypes()).thenReturn(Collections.<TypeDescription, byte[]>emptyMap());
     }
 
     @Test
     public void testByteArray() throws Exception {
-        assertThat(dynamicType.getByte(), is(binaryRepresentation));
+        assertThat(dynamicType.getBytes(), is(binaryRepresentation));
     }
 
     @Test

File: src/test/java/net/bytebuddy/dynamic/DynamicTypeDefaultUnloadedTest.java
Patch:
@@ -58,7 +58,7 @@ public void setUp() throws Exception {
         loadedTypes.put(auxiliaryTypeDescription, AUXILIARY_TYPE);
         when(classLoadingStrategy.load(any(ClassLoader.class), any(LinkedHashMap.class))).thenReturn(loadedTypes);
         when(auxiliaryType.getDescription()).thenReturn(auxiliaryTypeDescription);
-        when(auxiliaryType.getByte()).thenReturn(auxiliaryTypeByte);
+        when(auxiliaryType.getBytes()).thenReturn(auxiliaryTypeByte);
         when(auxiliaryType.getTypeInitializers()).thenReturn(Collections.singletonMap(auxiliaryTypeDescription, auxiliaryTypeInitializer));
         when(auxiliaryType.getRawAuxiliaryTypes()).thenReturn(Collections.<TypeDescription, byte[]>emptyMap());
     }
@@ -67,7 +67,7 @@ public void setUp() throws Exception {
     public void testQueries() throws Exception {
         DynamicType.Loaded<?> loaded = unloaded.load(classLoader, classLoadingStrategy);
         assertThat(loaded.getDescription(), is(typeDescription));
-        assertThat(loaded.getByte(), is(binaryRepresentation));
+        assertThat(loaded.getBytes(), is(binaryRepresentation));
         assertThat(loaded.getRawAuxiliaryTypes(), is(Collections.singletonMap(auxiliaryTypeDescription, auxiliaryTypeByte)));
     }
 

File: src/main/java/net/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentationContextDelegate.java
Patch:
@@ -94,7 +94,7 @@ public String name(AuxiliaryType auxiliaryType) {
     public MethodDescription requireAccessorMethodFor(MethodDescription targetMethod) {
         targetMethod = reachableMethods.get(targetMethod.getUniqueSignature());
         if (targetMethod == null) {
-            throw new IllegalArgumentException("Method is not reachable from instrumented type: " + targetMethod);
+            throw new IllegalArgumentException("Method is not reachable from instrumented type");
         }
         MethodDescription accessorMethod = knownTargetMethodsToAccessorMethod.get(targetMethod);
         if (accessorMethod != null) {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/NamingStrategy.java
Patch:
@@ -10,7 +10,7 @@
 
 /**
  * A naming strategy for finding a fully qualified internalName for a Java type.
- * <p/>
+ * <p>&nbsp;</p>
  * Note that subclasses that lie within the same package as their superclass have improved access to overriding
  * package-private methods of their super type.
  */
@@ -118,7 +118,7 @@ public String getName(UnnamedType unnamedType) {
 
     /**
      * A naming strategy that applies a fixed internalName.
-     * <p/>
+     * <p>&nbsp;</p>
      * This strategy should only be used for one shot type generators since they will otherwise create types that
      * impose naming conflicts.
      */

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/dynamic/loading/ClassLoaderByteArrayInjector.java
Patch:
@@ -5,7 +5,7 @@
 
 /**
  * An injector that loads classes by reflectively invoking non-public methods on a given {@link java.lang.ClassLoader}.
- * <p/>
+ * <p>&nbsp;</p>
  * Note that the injector is only able to load classes in a linear manner. Thus, classes that refer to other classes
  * which are not yet loaded cannot be injected but will result in a {@link java.lang.NoClassDefFoundError}. This becomes
  * a problem when classes refer to each other using cyclic references. This injector can further not be applied to the

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/FieldRegistry.java
Patch:
@@ -12,7 +12,7 @@
  * A field registry represents an extendable collection of fields which are identified by their names that are mapped
  * to a given {@link com.blogspot.mydailyjava.bytebuddy.instrumentation.attribute.FieldAttributeAppender}. Fields
  * can be uniquely identified by their name for a given type since fields are never inherited.
- * <p/>
+ * <p>&nbsp;</p>
  * This registry is the counterpart of a {@link com.blogspot.mydailyjava.bytebuddy.dynamic.scaffold.MethodRegistry}.
  * However, a field registry is implemented simpler since it does not have to deal with complex signatures or
  * inheritance. For the sake of consistency, the field registry follows however a similar pattern without introducing
@@ -118,7 +118,7 @@ public FieldRegistry.Compiled compile(TypeDescription instrumentedType, TypeWrit
      * retrieval of {@link com.blogspot.mydailyjava.bytebuddy.instrumentation.attribute.FieldAttributeAppender}s for
      * known fields. Additionally, a fallback attribute appender is to be supplied which is returned if a requested
      * field cannot is not known to the compiled field registry.
-     * <p/>
+     * <p>&nbsp;</p>
      * If a field name is already registered, an exception will be thrown.
      *
      * @param instrumentedType The instrumented type for which this field registry is to be compiled.

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -20,7 +20,7 @@
 /**
  * A type writer allows an easier creation of a dynamic type by enforcing the writing order
  * (type, annotations, fields, methods) that is required by ASM in order to successfully creating a Java type.
- * <p/>
+ * <p>&nbsp;</p>
  * Note: This type represents a mutable data structure since it is a wrapper around an ASM
  * {@link org.objectweb.asm.ClassWriter}. Once a phase of this type writer is left the old instances must not longer
  * be used.

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/Instrumentation.java
Patch:
@@ -23,7 +23,7 @@
  * to the instrumented methods that were delegated to this instrumentation. This byte code appender will also
  * be responsible for providing implementations for the methods added in step <i>1</i>.</li>
  * </ol>
- * <p/>
+ * <p>&nbsp;</p>
  * An instrumentation implementation should provide meaningful implementations {@link java.lang.Object#equals(Object)}
  * and {@link Object#hashCode()} if it wants to avoid to be used twice within the creation of a dynamic type. For two
  * equal instrumentation implementations only one will be applied on the creation of a dynamic type.
@@ -163,7 +163,7 @@ public Size apply(MethodVisitor methodVisitor, Context instrumentationContext, M
 
     /**
      * A compound instrumentation that allows to combine several instrumentations.
-     * <p/>
+     * <p>&nbsp;</p>
      * Note that the combination of two instrumentations might break the contract for implementing
      * {@link java.lang.Object#equals(Object)} and {@link Object#hashCode()} as described for
      * {@link com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation}.

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/ModifierContributor.java
Patch:
@@ -3,7 +3,7 @@
 /**
  * An element that describes a type modifier as described in the
  * <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">JVMS</a>.
- * <p/>
+ * <p>&nbsp;</p>
  * This allows for a more expressive and type safe alternative of defining a type's or type member's modifiers.
  * However, note that modifier's that apply competing modifiers (such as {@code private} and {@code protected}
  * should not be combined and will result in invalid types. An exception is thrown when built-in modifiers that

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/SuperMethodCall.java
Patch:
@@ -19,7 +19,7 @@
  * considered to have a super method even if there is a method with a compatible signature. Constructors are
  * considered to have a "super method" if the direct super type defines a constructor with identical signature.
  * If a method is found to not have a super method, e.g. when instrumenting a static method, an exception is thrown.
- * <p/>
+ * <p>&nbsp;</p>
  * Besides implementing constructors, this instrumentation is useful when a method of a super type is not supposed
  * to be altered but should be equipped with additional annotations.
  */

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/MethodDescription.java
Patch:
@@ -481,13 +481,15 @@ public String toString() {
     /**
      * Verifies if a method description represents a given loaded method.
      *
+     * @param method The method to be checked.
      * @return {@code true} if this method description represents the given loaded method.
      */
     boolean represents(Method method);
 
     /**
      * Verifies if a method description represents a given loaded constructor.
      *
+     * @param constructor The constructor to be checked.
      * @return {@code true} if this method description represents the given loaded constructor.
      */
     boolean represents(Constructor<?> constructor);

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/ByteCodeAppender.java
Patch:
@@ -9,7 +9,7 @@
 /**
  * An appender that generates the byte code for a given method. This is done by writing the byte code instructions to
  * the given ASM {@link org.objectweb.asm.MethodVisitor}.
- * <p/>
+ * <p>&nbsp;</p>
  * The {@code ByteCodeAppender} is not allowed to write
  * annotations to the method or call the {@link org.objectweb.asm.MethodVisitor#visitCode()},
  * {@link org.objectweb.asm.MethodVisitor#visitMaxs(int, int)} or {@link org.objectweb.asm.MethodVisitor#visitEnd()}

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/MethodDelegationBinder.java
Patch:
@@ -12,7 +12,7 @@
 /**
  * A method delegation binder is responsible for creating a method binding for a <i>source method</i> to a
  * <i>target method</i>. Such a binding allows to implement the source method by calling the target method.
- * <p/>
+ * <p>&nbsp;</p>
  * Usually, an instrumentation will attempt to bind a specific source method to a set of target method candidates
  * where all legal bindings are considered for binding. To chose a specific candidate, an
  * {@link com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.MethodDelegationBinder.AmbiguityResolver}
@@ -370,7 +370,7 @@ public String toString() {
 
         /**
          * Returns the target method's parameter index for a given parameter binding token.
-         * <p/>
+         * <p>&nbsp;</p>
          * A binding token can be any object
          * that implements valid {@link Object#hashCode()} and {@link Object#equals(Object)} methods in order
          * to look up a given binding. This way, two bindings can be evaluated of having performed a similar type of
@@ -560,7 +560,7 @@ public String toString() {
      * A helper class that allows to identify a best binding for a given type and source method chosing from a list of given
      * target methods by using a given {@link com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.MethodDelegationBinder}
      * and an {@link com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.MethodDelegationBinder.AmbiguityResolver}.
-     * <p/>
+     * <p>&nbsp;</p>
      * The {@code Processor} will:
      * <ol>
      * <li>Try to bind the {@code source} method using the {@code MethodDelegationBinder}.</li>

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/MethodNameEqualityResolver.java
Patch:
@@ -7,7 +7,7 @@
  * {@link com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.MethodDelegationBinder.AmbiguityResolver}
  * that resolves conflicting bindings by considering equality of a target method's internalName as an indicator for a dominant
  * binding.
- * <p/>
+ * <p>&nbsp;</p>
  * For example, if method {@code source.foo} can be bound to methods {@code targetA.foo} and {@code targetB.bar},
  * {@code targetA.foo} will be considered as dominant.
  */

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/MostSpecificTypeResolver.java
Patch:
@@ -8,7 +8,7 @@
  * {@link com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.MethodDelegationBinder.AmbiguityResolver}
  * that resolves two conflicting bindings by considering most-specific types of target method parameters in the same manner
  * as the Java compiler resolves bindings of overloaded method.
- * <p/>
+ * <p>&nbsp;</p>
  * This ambiguity resolver:
  * <ol>
  * <li>Checks for each parameter of the source method if a one-to-one parameter binding to both of the target methods exist.</li>
@@ -20,7 +20,7 @@
  * consists of the most one-to-one parameter bindings is considered dominant.</li>
  * </ol>
  * Primitive types are considered dominant in the same manner as by the Java compiler.
- * <p/>
+ * <p>&nbsp;</p>
  * For example: If a source method only parameter was successfully bound one-to-one to the only parameters of the target
  * methods {@code foo(Object)} and {@code bar(String)}, this ambiguity resolver will detect that the {@code String} type
  * is more specific than the {@code Object} type and determine {@code bar(String)} as the dominant binding.

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/AllArguments.java
Patch:
@@ -18,7 +18,7 @@
  * <ul>
  * <li>Array</li>
  * </ul>
- * <p/>
+ * <p>&nbsp;</p>
  * If the parameters of the source method are not assignable to the collection's component type, the method with
  * the annotated parameter will not be considered as a possible binding target for the source method.
  *

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/Argument.java
Patch:
@@ -17,7 +17,7 @@
  * with the given parameter. For example, if source method {@code foo(String, Integer)} is bound to target method
  * {@code bar(@Argument(1) Integer)}, the second parameter of {@code foo} will be bound to the first argument of
  * {@code bar}.
- * <p/>
+ * <p>&nbsp;</p>
  * If a source method has less parameters than specified by {@link Argument#value()}, the method carrying this parameter
  * annotation is excluded from the list of possible binding candidates to this particular source method. The same happens,
  * if the source method parameter at the specified index is not assignable to the annotated parameter.

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/RuntimeType.java
Patch:
@@ -7,7 +7,7 @@
 /**
  * Parameters that are annotated with this annotation will be assigned by also considering the runtime type of the
  * target parameter. The same is true for a method's return type if a target method is annotated with this annotation.
- * <p/>
+ * <p>&nbsp;</p>
  * For example, if a source method {@code foo(@RuntimeType Object)} is attempted to be bound to
  * {@code bar(@RuntimeType String)}, the binding will attempt to cast the argument of {@code foo} to a {@code String}
  * type before calling {@code bar} with this argument. If this is not possible, a {@link java.lang.ClassCastException}

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/Super.java
Patch:
@@ -16,7 +16,7 @@
  * Parameters that are annotated with this annotation are assigned an instance of an auxiliary proxy type that allows calling
  * any {@code super} methods of the instrumented type where the parameter type must be a super type of the instrumented type.
  * The proxy type will be a direct subclass of the parameter's type such as for example a specific interface.
- * <p/>
+ * <p>&nbsp;</p>
  * Obviously, the proxy type must be instantiated before it is assigned to the intercepting method's parameter. For this
  * purpose, two strategies are available which can be specified by setting the {@link Super#strategy()} parameter which can
  * be assigned:
@@ -35,11 +35,11 @@
  * constructor on the proxy. This implies that an interception by some method {@code qux(@Super Baz baz, @Super Bar bar)}
  * would cause the creation of two super call proxies, one extending {@code Baz}, the other extending {@code Bar}, give
  * that both types are super types of {@code Foo}.
- * <p/>
+ * <p>&nbsp;</p>
  * As an exception, no method calls to {@link Object#finalize()} are delegated by calling this method on the {@code super}-call
  * proxy by default. If this is absolutely necessary, this can however be enabled by setting {@link Super#ignoreFinalizer()}
  * to {@code false}.
- * <p/>
+ * <p>&nbsp;</p>
  * If a method parameter is not a super type of the instrumented type, the method with the parameter that is annoted by
  * #{@code Super} is not considered a possible delegation target.
  */

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/SuperCall.java
Patch:
@@ -13,7 +13,7 @@
  * Parameters that are annotated with this annotation will be assigned a proxy for calling the instrumented method's
  * {@code super} implementation. If a method does not have a super implementation, calling the annotated proxy will
  * throw an exception.
- * <p/>
+ * <p>&nbsp;</p>
  * The proxy will both implement the {@link java.util.concurrent.Callable} and the {@link java.lang.Runnable} interfaces
  * such that the annotated parameter must be assignable to any of those interfaces or be of the {@link java.lang.Object}
  * type.

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/Assigner.java
Patch:
@@ -5,7 +5,7 @@
 
 /**
  * An assigner is responsible for converting some type {@code A} to another type {@code B} if possible.
- * <p/>
+ * <p>&nbsp;</p>
  * An assigner is for example responsible for type casting, auto boxing or unboxing or for the widening of primitive
  * types.
  */

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/constant/DoubleConstant.java
Patch:
@@ -55,7 +55,7 @@ public String toString() {
 
     /**
      * Creates a stack manipulation for loading a {@code double} value onto the operand stack.
-     * <p/>
+     * <p>&nbsp;</p>
      * This is achieved either by invoking a specific opcode, if any, or by creating a constant pool entry.
      *
      * @param value The {@code double} value to load onto the stack.

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/constant/FloatConstant.java
Patch:
@@ -55,7 +55,7 @@ public String toString() {
 
     /**
      * Creates a stack manipulation for loading a {@code float} value onto the operand stack.
-     * <p/>
+     * <p>&nbsp;</p>
      * This is achieved either by invoking a specific opcode, if any, or by creating a constant pool entry.
      *
      * @param value The {@code float} value to load onto the stack.

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/constant/IntegerConstant.java
Patch:
@@ -144,7 +144,7 @@ public static StackManipulation forValue(boolean value) {
 
     /**
      * Creates a stack manipulation for loading an {@code int} value onto the stack.
-     * <p/>
+     * <p>&nbsp;</p>
      * This is achieved either by invoking a constant opcode, if any, or by creating a binary push operation.
      *
      * @param value The {@code int} (or {@code byte}, {@code short}, {@code char}) value to load onto the stack.

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/constant/LongConstant.java
Patch:
@@ -54,7 +54,7 @@ public String toString() {
 
     /**
      * Creates a stack manipulation for loading a {@code long} value onto the operand stack.
-     * <p/>
+     * <p>&nbsp;</p>
      * This is achieved either by invoking a specific opcode, if any, or by creating a constant pool entry.
      *
      * @param value The {@code long} value to load onto the stack.

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/member/MethodVariableAccess.java
Patch:
@@ -131,7 +131,7 @@ public Size apply(MethodVisitor methodVisitor, Instrumentation.Context instrumen
 
     /**
      * Creates a stack assignment for a given index of the local variable array.
-     * <p/>
+     * <p>&nbsp;</p>
      * The index has to be relative to the method's local variable array size.
      *
      * @param variableOffset The offset of the variable where {@code double} and {@code long} types

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/InstrumentedType.java
Patch:
@@ -145,6 +145,7 @@ protected class MethodToken extends MethodDescription.AbstractMethodDescription
              * @param internalName   The internal internalName of the method or constructor.
              * @param returnType     A description of the return type of this method.
              * @param parameterTypes A list of descriptions of the parameter types of this method.
+             * @param exceptionTypes A list of descriptions of the exception types that are declared by this method.
              * @param modifiers      The modifiers of this method.
              */
             public MethodToken(String internalName,
@@ -516,6 +517,7 @@ InstrumentedType withField(String name,
      * @param name           The internalName of the new field.
      * @param returnType     A description of the return type of the new field.
      * @param parameterTypes A list of descriptions of the parameter types.
+     * @param exceptionTypes A list of descriptions of the exception types that are declared by this method.
      * @param modifiers      The modifier of the new field.
      * @return A new instrumented type that is equal to this instrumented type but with the additional field.
      */

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/TypeDescription.java
Patch:
@@ -62,9 +62,9 @@ public MethodList getReachableMethods() {
             MethodMatcher uniqueSignatureFilter = new UniqueSignatureFilter();
             methodDescriptions.addAll(getDeclaredMethods().filter(uniqueSignatureFilter));
             MethodMatcher subclassFilter = not(MethodMatchers.isPrivate())
-                    .and(not(MethodMatchers.isPackagePrivate()).or(isVisibleFromPackage(getPackageName())))
                     .and(isMethod())
                     .and(not(MethodMatchers.isStatic()))
+                    .and(not(MethodMatchers.isPackagePrivate()).or(MethodMatchers.isVisibleTo(this)))
                     .and(uniqueSignatureFilter);
             if (getSupertype() != null) {
                 methodDescriptions.addAll(getSupertype().getReachableMethods().filter(subclassFilter));
@@ -311,7 +311,7 @@ public String toString() {
      * Checks if this type is assignable from the type described by this instance, for example for
      * {@code class Foo} and {@code class Bar extends Foo}, this method would return {@code true} for
      * {@code Foo.class.isAssignableFrom(Bar.class)}.
-     * <p/>
+     * <p>&nbsp;</p>
      * Implementations of this methods are allowed to delegate to
      * {@link com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription#isAssignableFrom(Class)}
      *
@@ -334,7 +334,7 @@ public String toString() {
      * Checks if this type is assignable from the type described by this instance, for example for
      * {@code class Foo} and {@code class Bar extends Foo}, this method would return {@code true} for
      * {@code Bar.class.isAssignableFrom(Foo.class)}.
-     * <p/>
+     * <p>&nbsp;</p>
      * Implementations of this methods are allowed to delegate to
      * {@link com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription#isAssignableTo(Class)}
      *

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/auxiliary/MethodCallProxy.java
Patch:
@@ -38,7 +38,7 @@
  * A method call proxy represents a class that is compiled against a particular method which can then be called whenever
  * either its {@link java.util.concurrent.Callable#call()} or {@link Runnable#run()} method is called where the method
  * call proxy implements both interfaces.
- * <p/>
+ * <p>&nbsp;</p>
  * In order to do so, the method call proxy instances are constructed by providing all the necessary information for
  * calling a particular method:
  * <ol>

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/MethodDelegationExceptionTest.java
Patch:
@@ -28,7 +28,7 @@ public void testNoMethod() throws Exception {
         instrument(Foo.class, MethodDelegation.to(Bar.class));
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test(expected = IllegalArgumentException.class)
     public void testNoVisibleMethod() throws Exception {
         instrument(Foo.class, MethodDelegation.to(new PackagePrivateMethod()));
     }

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -172,7 +172,7 @@ private SubclassExceptionDeclarableMethodInterception(MethodToken methodToken) {
         }
 
         @Override
-        public MatchedMethodInterception<S> throwing(Class<? extends Throwable>... type) {
+        public MatchedMethodInterception<S> throwing(Class<?>... type) {
             return throwing(new TypeList.ForLoadedType(nonNull(type)).toArray(new TypeDescription[type.length]));
         }
 
@@ -181,7 +181,7 @@ public MatchedMethodInterception<S> throwing(TypeDescription... type) {
             return materialize(new MethodToken(methodToken.getInternalName(),
                     methodToken.getReturnType(),
                     methodToken.getParameterTypes(),
-                    uniqueTypes(Arrays.asList(nonNull(type))),
+                    uniqueTypes(isThrowable(Arrays.asList(nonNull(type)))),
                     methodToken.getModifiers()));
         }
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/MethodDelegationExceptionTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation;
 
-import com.blogspot.mydailyjava.bytebuddy.utility.PackagePrivateSample;
+import com.blogspot.mydailyjava.bytebuddy.utility.PackagePrivateMethod;
 import org.junit.Test;
 
 public class MethodDelegationExceptionTest extends AbstractInstrumentationTest {
@@ -30,7 +30,7 @@ public void testNoMethod() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testNoVisibleMethod() throws Exception {
-        instrument(Foo.class, MethodDelegation.to(new PackagePrivateSample()));
+        instrument(Foo.class, MethodDelegation.to(new PackagePrivateMethod()));
     }
 
     @Test(expected = IllegalArgumentException.class)

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/utility/PackagePrivateMethod.java
Patch:
@@ -1,7 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.utility;
 
 @SuppressWarnings("unused")
-public class PackagePrivateSample {
+public class PackagePrivateMethod {
 
     public static final String METHOD_NAME = "foo";
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/TypeDescription.java
Patch:
@@ -64,6 +64,7 @@ public MethodList getReachableMethods() {
             MethodMatcher subclassFilter = not(MethodMatchers.isPrivate())
                     .and(not(MethodMatchers.isPackagePrivate()).or(isVisibleFromPackage(getPackageName())))
                     .and(isMethod())
+                    .and(not(MethodMatchers.isStatic()))
                     .and(uniqueSignatureFilter);
             if (getSupertype() != null) {
                 methodDescriptions.addAll(getSupertype().getReachableMethods().filter(subclassFilter));

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentationContextDelegate.java
Patch:
@@ -87,7 +87,7 @@ public String name(AuxiliaryType auxiliaryType) {
     public MethodDescription requireAccessorMethodFor(MethodDescription targetMethod) {
         targetMethod = reachableMethods.get(targetMethod.getUniqueSignature());
         if (targetMethod == null) {
-            throw new IllegalArgumentException("Illegal method: " + targetMethod);
+            throw new IllegalArgumentException("Method is not reachable from instrumented type: " + targetMethod);
         }
         MethodDescription accessorMethod = knownTargetMethodsToAccessorMethod.get(targetMethod);
         if (accessorMethod != null) {

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/BridgeMethodResolverSimpleTest.java
Patch:
@@ -69,7 +69,7 @@ public void testFindsBridgeMethodSingleStep() throws Exception {
         TypeDescription target = new TypeDescription.ForLoadedType(Bar.class);
         MethodList relevantMethods = target.getReachableMethods().filter(not(isConstructor().or(isDeclaredBy(Object.class))));
         assertThat(relevantMethods.size(), is(2));
-        BridgeMethodResolver bridgeMethodResolver = new BridgeMethodResolver.Simple(target, conflictHandler);
+        BridgeMethodResolver bridgeMethodResolver = new BridgeMethodResolver.Simple(target.getReachableMethods(), conflictHandler);
         assertThat(bridgeMethodResolver.resolve(relevantMethods.filter(isBridge()).getOnly()),
                 is(relevantMethods.filter(not(isBridge())).getOnly()));
         verifyZeroInteractions(conflictHandler);
@@ -80,7 +80,7 @@ public void testFindsBridgeMethodTwoStep() throws Exception {
         TypeDescription target = new TypeDescription.ForLoadedType(Qux.class);
         MethodList relevantMethods = target.getReachableMethods().filter(not(isConstructor().or(isDeclaredBy(Object.class))));
         assertThat(relevantMethods.size(), is(3));
-        BridgeMethodResolver bridgeMethodResolver = new BridgeMethodResolver.Simple(target, conflictHandler);
+        BridgeMethodResolver bridgeMethodResolver = new BridgeMethodResolver.Simple(target.getReachableMethods(), conflictHandler);
         for (MethodDescription methodDescription : relevantMethods.filter(isBridge())) {
             assertThat(bridgeMethodResolver.resolve(methodDescription), is(relevantMethods.filter(not(isBridge())).getOnly()));
         }
@@ -95,7 +95,7 @@ public void testFindsBridgeMethodConflictResolver() throws Exception {
         when(conflictHandler.choose(any(MethodDescription.class), any(MethodList.class))).thenReturn(bridgeTarget);
         when(bridgeTarget.isResolved()).thenReturn(true);
         when(bridgeTarget.extract()).thenReturn(methodDescription);
-        BridgeMethodResolver bridgeMethodResolver = new BridgeMethodResolver.Simple(target, conflictHandler);
+        BridgeMethodResolver bridgeMethodResolver = new BridgeMethodResolver.Simple(target.getReachableMethods(), conflictHandler);
         assertThat(bridgeMethodResolver.resolve(relevantMethods.filter(isBridge()).getOnly()), is(methodDescription));
         verify(conflictHandler).choose(relevantMethods.filter(isBridge()).getOnly(), relevantMethods.filter(not(isBridge())));
         verifyNoMoreInteractions(conflictHandler);

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/attribute/MethodAttributeAppender.java
Patch:
@@ -229,7 +229,7 @@ public void apply(MethodVisitor methodVisitor, MethodDescription methodDescripti
                 throw new IllegalArgumentException("The constructor " + method + " has more parameters than the " +
                         "instrumented method " + methodDescription);
             }
-            ForInstrumentedMethod.INSTANCE.apply(methodVisitor, new MethodDescription.ForMethod(method));
+            ForInstrumentedMethod.INSTANCE.apply(methodVisitor, new MethodDescription.ForLoadedMethod(method));
         }
 
         @Override
@@ -279,7 +279,7 @@ public void apply(MethodVisitor methodVisitor, MethodDescription methodDescripti
                 throw new IllegalArgumentException("The constructor " + constructor + " has more parameters than the " +
                         "instrumented method " + methodDescription);
             }
-            ForInstrumentedMethod.INSTANCE.apply(methodVisitor, new MethodDescription.ForConstructor(constructor));
+            ForInstrumentedMethod.INSTANCE.apply(methodVisitor, new MethodDescription.ForLoadedConstructor(constructor));
         }
 
         @Override

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/member/MethodInvocation.java
Patch:
@@ -99,7 +99,7 @@ public StackManipulation virtual(TypeDescription invocationTarget) {
         public StackManipulation special(TypeDescription invocationTarget) {
             validateNonStaticAndTypeCompatibleCall(invocationTarget);
             if (methodDescription.isAbstract()) {
-                throw new IllegalStateException("Cannot call INVOKESPECIAL on abstract method");
+                throw new IllegalStateException("Cannot call INVOKESPECIAL on abstract method " + methodDescription);
             } else if ((methodDescription.isPrivate() || methodDescription.isConstructor())) {
                 if (this.typeDescription.equals(invocationTarget)) {
                     return this;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/TypeDescription.java
Patch:
@@ -188,9 +188,9 @@ public MethodDescription getEnclosingMethod() {
             Method enclosingMethod = type.getEnclosingMethod();
             Constructor<?> enclosingConstructor = type.getEnclosingConstructor();
             if (enclosingMethod != null) {
-                return new MethodDescription.ForMethod(enclosingMethod);
+                return new MethodDescription.ForLoadedMethod(enclosingMethod);
             } else if (enclosingConstructor != null) {
-                return new MethodDescription.ForConstructor(enclosingConstructor);
+                return new MethodDescription.ForLoadedConstructor(enclosingConstructor);
             } else {
                 return null;
             }

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/AbstractInstrumentationTest.java
Patch:
@@ -5,6 +5,7 @@
 import com.blogspot.mydailyjava.bytebuddy.asm.ClassVisitorWrapper;
 import com.blogspot.mydailyjava.bytebuddy.dynamic.ClassLoadingStrategy;
 import com.blogspot.mydailyjava.bytebuddy.dynamic.DynamicType;
+import com.blogspot.mydailyjava.bytebuddy.dynamic.scaffold.BridgeMethodResolver;
 import com.blogspot.mydailyjava.bytebuddy.dynamic.scaffold.FieldRegistry;
 import com.blogspot.mydailyjava.bytebuddy.dynamic.scaffold.MethodRegistry;
 import com.blogspot.mydailyjava.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
@@ -34,6 +35,7 @@ protected <T> DynamicType.Loaded<T> instrument(Class<T> target, Instrumentation
                 Opcodes.ACC_PUBLIC,
                 TypeAttributeAppender.NoOp.INSTANCE,
                 not(isDeclaredBy(target)).or(isSynthetic()),
+                BridgeMethodResolver.Simple.Factory.FAIL_FAST,
                 new ClassVisitorWrapper.Chain(),
                 new FieldRegistry.Default(),
                 new MethodRegistry.Default(),

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/MethodListForLoadedTypeTest.java
Patch:
@@ -38,7 +38,7 @@ public void testMethodListFilter() throws Exception {
         for (Method method : Object.class.getDeclaredMethods()) {
             MethodList methodList = this.methodList.filter(MethodMatchers.is(method));
             assertThat(methodList.size(), is(1));
-            assertThat(methodList.getOnly(), CoreMatchers.<MethodDescription>equalTo(new MethodDescription.ForMethod(method)));
+            assertThat(methodList.getOnly(), CoreMatchers.<MethodDescription>equalTo(new MethodDescription.ForLoadedMethod(method)));
         }
     }
 }

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/auxiliary/TypeProxyTest.java
Patch:
@@ -98,7 +98,7 @@ public MethodDescription answer(InvocationOnMock invocation) throws Throwable {
                 if (method.getName().equals(ACCESSOR
                         + source.getName().substring(0, 1).toUpperCase()
                         + source.getName().substring(1))) {
-                    return new MethodDescription.ForMethod(method);
+                    return new MethodDescription.ForLoadedMethod(method);
                 }
             }
             throw new AssertionError("Cannot find delegate for " + source);

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/NamingStrategy.java
Patch:
@@ -1,9 +1,9 @@
 package com.blogspot.mydailyjava.bytebuddy;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
+import com.blogspot.mydailyjava.bytebuddy.modifier.MemberVisibility;
 import com.blogspot.mydailyjava.bytebuddy.modifier.SyntheticState;
 import com.blogspot.mydailyjava.bytebuddy.modifier.TypeManifestation;
-import com.blogspot.mydailyjava.bytebuddy.modifier.Visibility;
 
 import java.util.Collection;
 import java.util.Random;
@@ -40,7 +40,7 @@ static interface UnnamedType {
          *
          * @return The visibility of this unnamed type.
          */
-        Visibility getVisibility();
+        MemberVisibility getVisibility();
 
         /**
          * Returns the manifestation of this unnamed type.

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/TypeDescription.java
Patch:
@@ -76,9 +76,7 @@ public MethodList getReachableMethods() {
 
         @Override
         public boolean isVisibleTo(TypeDescription typeDescription) {
-            return isPublic()
-                    || typeDescription.equals(this)
-                    || (!isPrivate() && typeDescription.getPackageName().equals(getPackageName()));
+            return isPublic() || typeDescription.getPackageName().equals(getPackageName());
         }
 
         @Override

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/auxiliary/AuxiliaryType.java
Patch:
@@ -6,7 +6,7 @@
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodList;
 import com.blogspot.mydailyjava.bytebuddy.modifier.SyntheticState;
-import com.blogspot.mydailyjava.bytebuddy.modifier.Visibility;
+import com.blogspot.mydailyjava.bytebuddy.modifier.TypeVisibility;
 
 import java.util.Arrays;
 import java.util.Collections;
@@ -25,7 +25,7 @@ public interface AuxiliaryType {
      * The default type access of an auxiliary type.
      */
     static final List<ModifierContributor.ForType> DEFAULT_TYPE_MODIFIER = Collections.unmodifiableList(
-            Arrays.<ModifierContributor.ForType>asList(Visibility.PACKAGE_PRIVATE, SyntheticState.SYNTHETIC));
+            Arrays.<ModifierContributor.ForType>asList(TypeVisibility.PACKAGE_PRIVATE, SyntheticState.SYNTHETIC));
 
 
     /**

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/auxiliary/MethodCallProxy.java
Patch:
@@ -24,7 +24,7 @@
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeList;
-import com.blogspot.mydailyjava.bytebuddy.modifier.Visibility;
+import com.blogspot.mydailyjava.bytebuddy.modifier.MemberVisibility;
 import org.objectweb.asm.MethodVisitor;
 
 import java.util.ArrayList;
@@ -322,7 +322,7 @@ public DynamicType make(String auxiliaryTypeName,
                 .defineConstructorDescriptive(new ArrayList<TypeDescription>(parameterFields.values()))
                 .intercept(new ConstructorCall());
         for (Map.Entry<String, TypeDescription> field : parameterFields.entrySet()) {
-            builder = builder.defineField(field.getKey(), field.getValue(), Visibility.PRIVATE);
+            builder = builder.defineField(field.getKey(), field.getValue(), MemberVisibility.PRIVATE);
         }
         return builder.make();
     }

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/modifier/MemberVisibility.java
Patch:
@@ -4,9 +4,9 @@
 import org.objectweb.asm.Opcodes;
 
 /**
- * Describes a type, fields or methods visibility.
+ * Describes a field's or a method's visibility.
  */
-public enum Visibility implements ModifierContributor.ForType, ModifierContributor.ForMethod, ModifierContributor.ForField {
+public enum MemberVisibility implements ModifierContributor.ForMethod, ModifierContributor.ForField {
 
     PUBLIC(Opcodes.ACC_PUBLIC),
     PACKAGE_PRIVATE(EMPTY_MASK),
@@ -15,7 +15,7 @@ public enum Visibility implements ModifierContributor.ForType, ModifierContribut
 
     private final int mask;
 
-    private Visibility(int mask) {
+    private MemberVisibility(int mask) {
         this.mask = mask;
     }
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/FieldAccessorTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation;
 
 import com.blogspot.mydailyjava.bytebuddy.dynamic.DynamicType;
-import com.blogspot.mydailyjava.bytebuddy.modifier.Visibility;
+import com.blogspot.mydailyjava.bytebuddy.modifier.MemberVisibility;
 import com.blogspot.mydailyjava.bytebuddy.utility.CallTraceable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -476,7 +476,7 @@ public void testStaticGetterExplicit() throws Exception {
 
     @Test
     public void testDefineFieldGetter() throws Exception {
-        testGetter(instanceGetter, FieldAccessor.ofField(FOO).defineAs(propertyType, Visibility.PUBLIC), true);
+        testGetter(instanceGetter, FieldAccessor.ofField(FOO).defineAs(propertyType, MemberVisibility.PUBLIC), true);
     }
 
     @Test
@@ -501,7 +501,7 @@ public void testStaticSetterExplicit() throws Exception {
 
     @Test
     public void testDefineFieldSetter() throws Exception {
-        testSetter(instanceSetter, FieldAccessor.ofField(FOO).defineAs(propertyType, Visibility.PUBLIC), true);
+        testSetter(instanceSetter, FieldAccessor.ofField(FOO).defineAs(propertyType, MemberVisibility.PUBLIC), true);
     }
 
     @SuppressWarnings("unchecked")

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/utility/ByteBuddyCommonsTest.java
Patch:
@@ -4,8 +4,8 @@
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.modifier.FieldManifestation;
+import com.blogspot.mydailyjava.bytebuddy.modifier.MemberVisibility;
 import com.blogspot.mydailyjava.bytebuddy.modifier.Ownership;
-import com.blogspot.mydailyjava.bytebuddy.modifier.Visibility;
 import org.junit.Test;
 import org.mockito.asm.Opcodes;
 
@@ -109,15 +109,15 @@ public void testIsNotEmpty() throws Exception {
 
     @Test(expected = IllegalArgumentException.class)
     public void testIsNotEmptyThrowsException() throws Exception {
-        isNotEmpty(Arrays.asList(), FOO);
+        isNotEmpty(Arrays.<String>asList(), FOO);
     }
 
     @Test
     public void testResolveModifierContributors() throws Exception {
         assertThat(resolveModifierContributors(ByteBuddyCommons.FIELD_MODIFIER_MASK,
                 FieldManifestation.FINAL,
                 Ownership.STATIC,
-                Visibility.PRIVATE), is(Opcodes.ACC_FINAL | Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE));
+                MemberVisibility.PRIVATE), is(Opcodes.ACC_FINAL | Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE));
     }
 
     @Test(expected = IllegalArgumentException.class)

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/InstrumentationContextDefaultTest.java
Patch:
@@ -47,9 +47,9 @@ public class InstrumentationContextDefaultTest {
     public void setUp() throws Exception {
         defaultContext = new Instrumentation.Context.Default(classFormatVersion, auxiliaryTypeNamingStrategy, methodAccessorFactory);
         when(firstAuxiliary.make(any(String.class), any(ClassFormatVersion.class), any(AuxiliaryType.MethodAccessorFactory.class)))
-                .thenReturn((DynamicType) firstDynamic);
+                .thenReturn(firstDynamic);
         when(secondAuxiliary.make(any(String.class), any(ClassFormatVersion.class), any(AuxiliaryType.MethodAccessorFactory.class)))
-                .thenReturn((DynamicType) secondDynamic);
+                .thenReturn(secondDynamic);
         when(firstDynamic.getDescription()).thenReturn(firstDescription);
         when(secondDynamic.getDescription()).thenReturn(secondDescription);
         when(auxiliaryTypeNamingStrategy.name(any(AuxiliaryType.class))).thenReturn(FOO, BAR);

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/MostSpecificTypeResolverPrimitiveTest.java
Patch:
@@ -44,11 +44,11 @@ public static Collection<Object[]> data() {
                 {short.class, float.class},
                 {short.class, double.class},
 
-                {char.class, int.class},
                 {char.class, long.class},
                 {char.class, float.class},
                 {char.class, double.class},
 
+                {int.class, char.class},
                 {int.class, long.class},
                 {int.class, float.class},
                 {int.class, double.class},
@@ -79,9 +79,9 @@ public void setUp() throws Exception {
         super.setUp();
         when(sourceType.isPrimitive()).thenReturn(true);
         when(firstPrimitive.isPrimitive()).thenReturn(true);
-        when(firstPrimitive.represents(int.class)).thenReturn(true);
+        when(firstPrimitive.represents(firstType)).thenReturn(true);
         when(secondPrimitive.isPrimitive()).thenReturn(true);
-        when(secondPrimitive.represents(long.class)).thenReturn(true);
+        when(secondPrimitive.represents(secondType)).thenReturn(true);
     }
 
     @Test

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/collection/AbstractArrayFactoryTest.java
Patch:
@@ -1,8 +1,8 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.collection;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;
 import org.junit.After;
@@ -18,7 +18,6 @@
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
-import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.*;
 
 public abstract class AbstractArrayFactoryTest {

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/utility/ByteBuddyCommonsTest.java
Patch:
@@ -109,7 +109,7 @@ public void testIsNotEmpty() throws Exception {
 
     @Test(expected = IllegalArgumentException.class)
     public void testIsNotEmptyThrowsException() throws Exception {
-        isNotEmpty(Arrays.<Object>asList(), FOO);
+        isNotEmpty(Arrays.asList(), FOO);
     }
 
     @Test

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/ByteBuddy.java
Patch:
@@ -18,7 +18,7 @@
 import java.lang.annotation.Annotation;
 import java.util.List;
 
-import static com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatchers.isDefaultFinalize;
+import static com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatchers.isDefaultFinalizer;
 import static com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatchers.isSynthetic;
 import static com.blogspot.mydailyjava.bytebuddy.utility.ByteBuddyCommons.*;
 
@@ -373,7 +373,7 @@ public ByteBuddy(ClassFormatVersion classFormatVersion) {
         this(classFormatVersion,
                 new NamingStrategy.SuffixingRandom(BYTE_BUDDY_DEFAULT_PREFIX),
                 new TypeList.Empty(),
-                isDefaultFinalize().or(isSynthetic()),
+                isDefaultFinalizer().or(isSynthetic()),
                 new ClassVisitorWrapper.Chain(),
                 new MethodRegistry.Default(),
                 new Definable.Undefined<Integer>(),

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategy.java
Patch:
@@ -44,7 +44,7 @@ public MethodList extractConstructors(TypeDescription superType) {
                     return new MethodList.Empty();
                 case DEFAULT_CONSTRUCTOR:
                     MethodList methodList = superType.getDeclaredMethods()
-                            .filter(isConstructor().and(takesArguments()).and(isPublic().or(isProtected())));
+                            .filter(isConstructor().and(takesArguments(0)).and(isPublic().or(isProtected())));
                     if (methodList.size() == 1) {
                         return methodList;
                     } else {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentationContextDelegate.java
Patch:
@@ -124,7 +124,7 @@ public Size apply(MethodVisitor methodVisitor,
                           Instrumentation.Context instrumentationContext,
                           MethodDescription instrumentedMethod) {
             StackManipulation.Size stackSize = new StackManipulation.Compound(
-                    MethodVariableAccess.loadAll(instrumentedMethod),
+                    MethodVariableAccess.loadThisAndArguments(instrumentedMethod),
                     MethodInvocation.invoke(targetDescription).special(instrumentedType.getSupertype()),
                     MethodReturn.returning(instrumentedMethod.getReturnType())
             ).apply(methodVisitor, instrumentationContext);

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/MethodDelegation.java
Patch:
@@ -382,6 +382,7 @@ private static List<TargetMethodAnnotationDrivenBinder.ParameterBinder<?>> defau
                 AllArguments.Binder.INSTANCE,
                 Origin.Binder.INSTANCE,
                 This.Binder.INSTANCE,
+                Super.Binder.INSTANCE,
                 SuperCall.Binder.INSTANCE);
     }
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/StubMethod.java
Patch:
@@ -43,7 +43,7 @@ public Size apply(MethodVisitor methodVisitor,
                       Context instrumentationContext,
                       MethodDescription instrumentedMethod) {
         StackManipulation.Size stackSize = new StackManipulation.Compound(
-                DefaultValue.load(instrumentedMethod.getReturnType()),
+                DefaultValue.of(instrumentedMethod.getReturnType()),
                 MethodReturn.returning(instrumentedMethod.getReturnType())
         ).apply(methodVisitor, instrumentationContext);
         return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/SuperMethodCall.java
Patch:
@@ -54,7 +54,7 @@ public Size apply(MethodVisitor methodVisitor,
                 targetMethod = instrumentedMethod;
             }
             StackManipulation.Size stackSize = new StackManipulation.Compound(
-                    MethodVariableAccess.loadAll(instrumentedMethod),
+                    MethodVariableAccess.loadThisAndArguments(instrumentedMethod),
                     MethodInvocation.invoke(targetMethod).special(targetType),
                     MethodReturn.returning(instrumentedMethod.getReturnType())
             ).apply(methodVisitor, instrumentationContext);

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/VoidAwareAssigner.java
Patch:
@@ -80,7 +80,7 @@ public StackManipulation assign(TypeDescription sourceType, TypeDescription targ
         if (sourceType.represents(void.class) && targetType.represents(void.class)) {
             return LegalTrivialStackManipulation.INSTANCE;
         } else if (sourceType.represents(void.class) /* && subType != void.class */) {
-            return returnDefaultValue ? DefaultValue.load(targetType) : IllegalStackManipulation.INSTANCE;
+            return returnDefaultValue ? DefaultValue.of(targetType) : IllegalStackManipulation.INSTANCE;
         } else if (/* superType != void.class && */ targetType.represents(void.class)) {
             return ValueRemovingStackManipulation.of(sourceType);
         } else /* superType != void.class && subType != void.class */ {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/constant/DefaultValue.java
Patch:
@@ -24,7 +24,7 @@ public enum DefaultValue implements StackManipulation {
      * @param typeDescription The type for which a default value should be loaded onto the operand stack.
      * @return A stack manipulation loading the default value for the given type.
      */
-    public static StackManipulation load(TypeDescription typeDescription) {
+    public static StackManipulation of(TypeDescription typeDescription) {
         if (typeDescription.isPrimitive()) {
             if (typeDescription.represents(long.class)) {
                 return LONG;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/auxiliary/MethodCallProxy.java
Patch:
@@ -24,7 +24,6 @@
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeList;
-import com.blogspot.mydailyjava.bytebuddy.modifier.SyntheticState;
 import com.blogspot.mydailyjava.bytebuddy.modifier.Visibility;
 import org.objectweb.asm.MethodVisitor;
 
@@ -81,7 +80,7 @@ public Size apply(MethodVisitor methodVisitor, Instrumentation.Context instrumen
             return new Compound(
                     TypeCreation.forType(auxiliaryType),
                     Duplication.SINGLE,
-                    MethodVariableAccess.loadAll(targetMethod),
+                    MethodVariableAccess.loadThisAndArguments(targetMethod),
                     MethodInvocation.invoke(auxiliaryType.getDeclaredMethods().filter(isConstructor()).getOnly())
             ).apply(methodVisitor, instrumentationContext);
         }
@@ -260,7 +259,6 @@ public DynamicType make(String auxiliaryTypeName,
                 .subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS)
                 .name(auxiliaryTypeName)
                 .modifiers(DEFAULT_TYPE_MODIFIER.toArray(new ModifierContributor.ForType[DEFAULT_TYPE_MODIFIER.size()]))
-                .modifiers(Visibility.PACKAGE_PRIVATE, SyntheticState.SYNTHETIC)
                 .implement(Runnable.class).intercept(new MethodCall(accessorMethod, assigner))
                 .implement(Callable.class).intercept(new MethodCall(accessorMethod, assigner))
                 .defineConstructorDescriptive(new ArrayList<TypeDescription>(parameterFields.values()))

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/utility/ByteBuddyCommons.java
Patch:
@@ -33,7 +33,7 @@ public final class ByteBuddyCommons {
      * A mask for modifiers that represents type members.
      */
     public static final int MEMBER_MODIFIER_MASK = VISIBILITY_MODIFIER_MASK | TYPE_MODIFIER_MASK
-            | Modifier.FINAL | Modifier.SYNCHRONIZED;
+            | Modifier.FINAL | Modifier.SYNCHRONIZED | Modifier.STATIC;
 
     /**
      * A mask for modifiers that represents fields.

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/subclass/ConstructorStrategyDefaultTest.java
Patch:
@@ -67,7 +67,7 @@ public void testImitateSuperTypeStrategy() throws Exception {
     @Test
     public void testDefaultConstructorStrategy() throws Exception {
         assertThat(ConstructorStrategy.Default.DEFAULT_CONSTRUCTOR.extractConstructors(stringType),
-                is(stringType.getDeclaredMethods().filter(isConstructor().and(takesArguments()).and(isProtected().or(isPublic())))));
+                is(stringType.getDeclaredMethods().filter(isConstructor().and(takesArguments(0)).and(isProtected().or(isPublic())))));
         assertThat(ConstructorStrategy.Default.DEFAULT_CONSTRUCTOR.inject(methodRegistry, methodAttributeAppenderFactory), is(methodRegistry));
         verify(methodRegistry).append(any(MethodRegistry.LatentMethodMatcher.class), any(Instrumentation.class), eq(methodAttributeAppenderFactory));
         verifyNoMoreInteractions(methodRegistry);

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/NextUnboundAsDefaultBinderTest.java
Patch:
@@ -19,7 +19,7 @@
 import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.*;
 
-public class NextUnboundAsDefaultHandlerTest {
+public class NextUnboundAsDefaultBinderTest {
 
     @Rule
     public TestRule mockitoRule = new MockitoRule(this);

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/constant/DefaultValueTest.java
Patch:
@@ -72,7 +72,7 @@ public void tearDown() throws Exception {
 
     @Test
     public void testDefaultValue() throws Exception {
-        StackManipulation stackManipulation = DefaultValue.load(typeDescription);
+        StackManipulation stackManipulation = DefaultValue.of(typeDescription);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, instrumentationContext);
         assertThat(size.getSizeImpact(), is(StackSize.of(type).getSize()));

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/member/MethodArgumentDescriptionTest.java
Patch:
@@ -61,7 +61,7 @@ public void tearDown() throws Exception {
     @Test
     public void testStaticMethod() throws Exception {
         when(methodDescription.isStatic()).thenReturn(true);
-        StackManipulation stackManipulation = MethodVariableAccess.loadAll(methodDescription);
+        StackManipulation stackManipulation = MethodVariableAccess.loadThisAndArguments(methodDescription);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, instrumentationContext);
         assertThat(size.getSizeImpact(), is(PARAMETER_STACK_SIZE));
@@ -73,7 +73,7 @@ public void testStaticMethod() throws Exception {
 
     @Test
     public void testNonStaticMethod() throws Exception {
-        StackManipulation stackManipulation = MethodVariableAccess.loadAll(methodDescription);
+        StackManipulation stackManipulation = MethodVariableAccess.loadThisAndArguments(methodDescription);
         assertThat(stackManipulation.isValid(), is(true));
         StackManipulation.Size size = stackManipulation.apply(methodVisitor, instrumentationContext);
         assertThat(size.getSizeImpact(), is(PARAMETER_STACK_SIZE + 1));

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/matcher/MethodMatchersTest.java
Patch:
@@ -439,9 +439,9 @@ public void testIsOverridable() throws Exception {
 
     @Test
     public void testIsDefaultFinalize() throws Exception {
-        assertThat(MethodMatchers.isDefaultFinalize().matches(testClassBase$foo), is(false));
-        assertThat(MethodMatchers.isDefaultFinalize().matches(object$finalize), is(true));
-        assertThat(MethodMatchers.isDefaultFinalize().matches(testModifier$finalize), is(false));
+        assertThat(MethodMatchers.isDefaultFinalizer().matches(testClassBase$foo), is(false));
+        assertThat(MethodMatchers.isDefaultFinalizer().matches(object$finalize), is(true));
+        assertThat(MethodMatchers.isDefaultFinalizer().matches(testModifier$finalize), is(false));
     }
 
     @Test

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/subclass/SubclassInstrumentationContextDelegateTest.java
Patch:
@@ -58,6 +58,7 @@ public void setUp() throws Exception {
         when(secondMethod.getReturnType()).thenReturn(secondMethodReturnType);
         when(secondMethod.getParameterTypes()).thenReturn(secondMethodParameters);
         when(secondMethod.isStatic()).thenReturn(true);
+        when(instrumentedType.detach()).thenReturn(instrumentedType);
     }
 
     @Test

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/ByteBuddy.java
Patch:
@@ -24,6 +24,9 @@
 
 public class ByteBuddy {
 
+    // TODO: create abstract delegation instead of using "extends ByteBuddy"
+    // TODO: Allow optional method interception also for the defaults.
+
     private static final String BYTE_BUDDY_DEFAULT_PREFIX = "ByteBuddy";
 
     protected static interface Definable<T> {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/TypeWriter.java
Patch:
@@ -368,7 +368,7 @@ protected AbstractTypeWriter(ClassWriter classWriter, ClassVisitor classVisitor)
             @Override
             public DynamicType.Unloaded<T> make() {
                 classVisitor.visitEnd();
-                return new DynamicType.Default.Unloaded<T>(instrumentedType.getName(),
+                return new DynamicType.Default.Unloaded<T>(instrumentedType.detach(),
                         classWriter.toByteArray(),
                         instrumentedType.getTypeInitializer(),
                         instrumentationContext.getRegisteredAuxiliaryTypes());

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/MethodDescription.java
Patch:
@@ -64,7 +64,7 @@ public int getParameterOffset(int parameterIndex) {
                     offset += parameterType.getStackSize().getSize();
                 }
             }
-            throw new IllegalArgumentException();
+            throw new IllegalArgumentException(this + " does not have a parameter of index " + parameterIndex);
         }
 
         @Override

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/SuperCall.java
Patch:
@@ -4,7 +4,7 @@
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.MethodDelegationBinder;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.auxiliary.MethodCallProxy0;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.auxiliary.MethodCallProxy;
 
 import java.lang.annotation.*;
 import java.util.concurrent.Callable;
@@ -56,7 +56,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(SuperCall annotation,
             } else if (target.isAbstract()) {
                 return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;
             } else {
-                return new MethodDelegationBinder.ParameterBinding.Anonymous(new MethodCallProxy0.AssignableSignatureCall(source));
+                return new MethodDelegationBinder.ParameterBinding.Anonymous(new MethodCallProxy.AssignableSignatureCall(source));
             }
         }
     }

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/FixedValueReferenceTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation;
 
 import com.blogspot.mydailyjava.bytebuddy.dynamic.DynamicType;
+import com.blogspot.mydailyjava.bytebuddy.utility.CallTraceable;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -43,7 +44,7 @@ public void testValueCall() throws Exception {
     }
 
     private void assertType(DynamicType.Loaded<Foo> loaded) throws Exception{
-        assertThat(loaded.getAuxiliaryTypes().size(), is(0));
+        assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(1));
         assertThat(loaded.getLoaded().getDeclaredFields().length, is(1));
         Foo instance = loaded.getLoaded().newInstance();

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/StubMethodTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation;
 
 import com.blogspot.mydailyjava.bytebuddy.dynamic.DynamicType;
+import com.blogspot.mydailyjava.bytebuddy.utility.CallTraceable;
 import org.hamcrest.Matcher;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -143,7 +144,7 @@ public StubMethodTest(Matcher<?> matcher,
     @SuppressWarnings("unchecked")
     public void testInstrumentedMethod() throws Exception {
         DynamicType.Loaded<Foo> loaded = instrument(Foo.class, StubMethod.INSTANCE);
-        assertThat(loaded.getAuxiliaryTypes().size(), is(0));
+        assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(11));
         Foo instance = loaded.getLoaded().newInstance();
         assertNotEquals(Foo.class, instance.getClass());

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/SuperMethodCallTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation;
 
 import com.blogspot.mydailyjava.bytebuddy.dynamic.DynamicType;
+import com.blogspot.mydailyjava.bytebuddy.utility.CallTraceable;
 import org.hamcrest.Matcher;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -133,7 +134,7 @@ public SuperMethodCallTest(Matcher<?> matcher,
     @SuppressWarnings("unchecked")
     public void testInstrumentedMethod() throws Exception {
         DynamicType.Loaded<Foo> loaded = instrument(Foo.class, SuperMethodCall.INSTANCE);
-        assertThat(loaded.getAuxiliaryTypes().size(), is(0));
+        assertThat(loaded.getLoadedAuxiliaryTypes().size(), is(0));
         assertThat(loaded.getLoaded().getDeclaredMethods().length, is(11));
         Foo instance = loaded.getLoaded().newInstance();
         assertNotEquals(Foo.class, instance.getClass());

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -473,7 +473,7 @@ public DynamicType.Unloaded<T> make() {
                 modifiers,
                 namingStrategy));
         SubclassInstrumentationContextDelegate contextDelegate = new SubclassInstrumentationContextDelegate(instrumentedType);
-        Instrumentation.Context instrumentationContext = new Instrumentation.Context.Default(contextDelegate, contextDelegate);
+        Instrumentation.Context instrumentationContext = new Instrumentation.Context.Default(classFormatVersion, contextDelegate, contextDelegate);
         MethodRegistry.Compiled compiledMethodRegistry = methodRegistry.compile(instrumentedType, MethodRegistry.Compiled.Entry.Skip.INSTANCE);
         instrumentedType = compiledMethodRegistry.getInstrumentedType();
         return new TypeWriter.Builder<T>(instrumentedType, instrumentationContext, classFormatVersion)

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/auxiliary/MethodCallProxy.java
Patch:
@@ -188,7 +188,7 @@ public MethodCallProxy(MethodDescription proxiedMethod, Assigner assigner) {
     }
 
     @Override
-    public DynamicType<?> make(String auxiliaryTypeName, MethodAccessorFactory methodAccessorFactory) {
+    public DynamicType<?> make(String auxiliaryTypeName, ClassFormatVersion classFormatVersion, MethodAccessorFactory methodAccessorFactory) {
         MethodDescription proxiedMethod = methodAccessorFactory.requireAccessorMethodFor(this.proxiedMethod);
         int fieldIndex = 0;
         InstrumentedType proxy = new SubclassInstumentedType(ClassFormatVersion.forCurrentJavaVersion(),
@@ -209,7 +209,7 @@ public DynamicType<?> make(String auxiliaryTypeName, MethodAccessorFactory metho
                 fieldTypes,
                 ModifierContributor.EMPTY_MASK);
         SubclassInstrumentationContextDelegate contextDelegate = new SubclassInstrumentationContextDelegate(proxy);
-        Instrumentation.Context instrumentationContext = new Instrumentation.Context.Default(contextDelegate, contextDelegate);
+        Instrumentation.Context instrumentationContext = new Instrumentation.Context.Default(classFormatVersion, contextDelegate, contextDelegate);
         MethodDelegate methodDelegate = new MethodDelegate(fieldAccess, proxiedMethod, assigner);
         ConstructorDelegate constructorDelegate = new ConstructorDelegate(fieldAccess);
         return new TypeWriter.Builder<Object>(proxy, instrumentationContext, ClassFormatVersion.forCurrentJavaVersion())

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/auxiliary/MethodCallProxy0.java
Patch:
@@ -1,5 +1,6 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.type.auxiliary;
 
+import com.blogspot.mydailyjava.bytebuddy.ClassFormatVersion;
 import com.blogspot.mydailyjava.bytebuddy.dynamic.DynamicType;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.TypeInitializer;
@@ -135,7 +136,7 @@ public MethodCallProxy0(MethodDescription proxiedMethod) {
     }
 
     @Override
-    public DynamicType<?> make(String auxiliaryTypeName, MethodAccessorFactory methodAccessorFactory) {
+    public DynamicType<?> make(String auxiliaryTypeName, ClassFormatVersion classFormatVersion, MethodAccessorFactory methodAccessorFactory) {
         String proxyTypeInternalName = auxiliaryTypeName.replace('.', '/');
         MethodDescription proxiedMethod = methodAccessorFactory.requireAccessorMethodFor(this.proxiedMethod);
         Map<String, TypeDescription> fields = new LinkedHashMap<String, TypeDescription>(1 + proxiedMethod.getParameterTypes().size());

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/auxiliary/MethodCallProxy0Test.java
Patch:
@@ -91,7 +91,7 @@ public void testMethodProxy() throws Exception {
         MethodDescription proxiedMethod = new MethodDescription.ForMethod
                 (proxiedType.getDeclaredMethod(FOO, proxiedMethodParameters));
         MethodCallProxy0 methodCallProxy = new MethodCallProxy0(proxiedMethod);
-        DynamicType<?> dynamicType = methodCallProxy.make(proxyName(proxiedType), null); // TODO
+        DynamicType<?> dynamicType = methodCallProxy.make(proxyName(proxiedType), null, null); // TODO
         ClassLoader proxyClassLoader = new ByteArrayClassLoader(getClass().getClassLoader(),
                 Collections.singletonMap(dynamicType.getName(), dynamicType.getBytes()));
         Class<?> proxyType = Class.forName(proxyName(proxiedType), false, proxyClassLoader);

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/auxiliary/MethodCallProxy.java
Patch:
@@ -188,8 +188,8 @@ public MethodCallProxy(MethodDescription proxiedMethod, Assigner assigner) {
     }
 
     @Override
-    public DynamicType<?> make(String auxiliaryTypeName, MethodProxyFactory methodProxyFactory) {
-        MethodDescription proxiedMethod = methodProxyFactory.requireProxyMethodFor(this.proxiedMethod);
+    public DynamicType<?> make(String auxiliaryTypeName, MethodAccessorFactory methodAccessorFactory) {
+        MethodDescription proxiedMethod = methodAccessorFactory.requireAccessorMethodFor(this.proxiedMethod);
         int fieldIndex = 0;
         InstrumentedType proxy = new SubclassInstumentedType(ClassFormatVersion.forCurrentJavaVersion(),
                 new TypeDescription.ForLoadedType(Object.class),

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/auxiliary/MethodCallProxy0.java
Patch:
@@ -135,9 +135,9 @@ public MethodCallProxy0(MethodDescription proxiedMethod) {
     }
 
     @Override
-    public DynamicType<?> make(String auxiliaryTypeName, MethodProxyFactory methodProxyFactory) {
+    public DynamicType<?> make(String auxiliaryTypeName, MethodAccessorFactory methodAccessorFactory) {
         String proxyTypeInternalName = auxiliaryTypeName.replace('.', '/');
-        MethodDescription proxiedMethod = methodProxyFactory.requireProxyMethodFor(this.proxiedMethod);
+        MethodDescription proxiedMethod = methodAccessorFactory.requireAccessorMethodFor(this.proxiedMethod);
         Map<String, TypeDescription> fields = new LinkedHashMap<String, TypeDescription>(1 + proxiedMethod.getParameterTypes().size());
         StringBuilder constructorDescriptor = new StringBuilder("(");
         int i = 0;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/NamingStrategy.java
Patch:
@@ -1,5 +1,6 @@
 package com.blogspot.mydailyjava.bytebuddy;
 
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.modifier.SyntheticState;
 import com.blogspot.mydailyjava.bytebuddy.modifier.TypeManifestation;
 import com.blogspot.mydailyjava.bytebuddy.modifier.Visibility;
@@ -25,14 +26,14 @@ static interface UnnamedType {
          *
          * @return The super class of the type to be named.
          */
-        Class<?> getSuperClass();
+        TypeDescription getSuperClass();
 
         /**
          * Returns a collection of this unnamed type's directly implemented interfaces.
          *
          * @return A collection of implemented interfaces.
          */
-        Collection<Class<?>> getDeclaredInterfaces();
+        Collection<TypeDescription> getDeclaredInterfaces();
 
         /**
          * Returns the visibility of this unnamed type.

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/TypeList.java
Patch:
@@ -28,6 +28,9 @@ static class ForLoadedType extends AbstractList<TypeDescription> implements Type
         public ForLoadedType(Class<?>[] type) {
             this.type = type;
         }
+        public ForLoadedType(List<Class<?>> types) {
+            type = types.toArray(new Class<?>[types.size()]);
+        }
 
         @Override
         public TypeDescription get(int index) {

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/NamingStrategyTest.java
Patch:
@@ -1,5 +1,6 @@
 package com.blogspot.mydailyjava.bytebuddy;
 
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;
 import org.junit.Rule;
 import org.junit.Test;
@@ -23,7 +24,7 @@ public class NamingStrategyTest {
 
     @Test
     public void testPrefixingRandomNonConflictingPackage() throws Exception {
-        doReturn(MethodVisitor.class).when(unnamedType).getSuperClass();
+        when(unnamedType.getSuperClass()).thenReturn(new TypeDescription.ForLoadedType(MethodVisitor.class));
         NamingStrategy namingStrategy = new NamingStrategy.SuffixingRandom(FOO);
         assertThat(namingStrategy.getName(unnamedType), startsWith(MethodVisitor.class.getName() + "$$" + FOO + "$$"));
         verify(unnamedType, atLeast(1)).getSuperClass();
@@ -32,7 +33,7 @@ public void testPrefixingRandomNonConflictingPackage() throws Exception {
 
     @Test
     public void testPrefixingRandomConflictingPackage() throws Exception {
-        doReturn(Object.class).when(unnamedType).getSuperClass();
+        when(unnamedType.getSuperClass()).thenReturn(new TypeDescription.ForLoadedType(Object.class));
         NamingStrategy namingStrategy = new NamingStrategy.SuffixingRandom(FOO, BAR);
         assertThat(namingStrategy.getName(unnamedType), startsWith(BAR + "." + Object.class.getName() + "$$" + FOO + "$$"));
         verify(unnamedType, atLeast(1)).getSuperClass();

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/ByteBuddy.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.List;
 
 import static com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatchers.isDefaultFinalize;
+import static com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatchers.isSynthetic;
 import static com.blogspot.mydailyjava.bytebuddy.utility.ByteBuddyCommons.*;
 
 public class ByteBuddy {
@@ -260,7 +261,7 @@ public ByteBuddy(ClassFormatVersion classFormatVersion) {
         this(classFormatVersion,
                 new NamingStrategy.SuffixingRandom(BYTE_BUDDY_DEFAULT_PREFIX),
                 Collections.<Class<?>>emptyList(),
-                isDefaultFinalize(),
+                isDefaultFinalize().or(isSynthetic()),
                 new ClassVisitorWrapper.Chain(),
                 new MethodRegistry.Default(),
                 new Definable.Undefined<Integer>(),

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/subclass/LoadedSuperclassDynamicTypeBuilder.java
Patch:
@@ -483,8 +483,8 @@ public DynamicType.Unloaded<T> make() {
                 .write(instrumentedType.getDeclaredFields(),
                         fieldRegistry.compile(instrumentedType, TypeWriter.FieldPool.Entry.NoOp.INSTANCE))
                 .methods()
-                .write(instrumentedType.getDeclaredMethods()
-                        .filter(not(ignoredMethods).and(isOverridable().or(isDeclaredBy(instrumentedType)))),
+                .write(instrumentedType.getReachableMethods()
+                        .filter(isOverridable().and(not(ignoredMethods)).or(isDeclaredBy(instrumentedType))),
                         compiledMethodRegistry)
                 .write(contextDelegate.getProxiedMethods(), contextDelegate)
                 .make();

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/attribute/FieldAttributeAppender.java
Patch:
@@ -101,7 +101,7 @@ static class ForAnnotation implements FieldAttributeAppender, Factory {
         /**
          * Creates a new field annotation appender.
          *
-         * @param annotation The annotation to be appended.
+         * @param annotation The annotations to be appended to the field.
          */
         public ForAnnotation(Annotation... annotation) {
             this.annotation = annotation;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/attribute/MethodAttributeAppender.java
Patch:
@@ -151,7 +151,7 @@ public String toString() {
         /**
          * Create a new annotation appender for a method.
          *
-         * @param annotation The annotation to append to the target method.
+         * @param annotation The annotations to append to the target method.
          */
         public ForAnnotation(Annotation... annotation) {
             this.annotation = annotation;
@@ -161,8 +161,8 @@ public ForAnnotation(Annotation... annotation) {
         /**
          * Create a new annotation appender for a method parameter.
          *
-         * @param annotation     The annotation to append to the target method parameter.
          * @param parameterIndex The index of the target parameter.
+         * @param annotation     The annotations to append to the target method parameter.
          */
         public ForAnnotation(int parameterIndex, Annotation... annotation) {
             this.annotation = annotation;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/attribute/TypeAttributeAppender.java
Patch:
@@ -35,7 +35,7 @@ static class ForAnnotation implements TypeAttributeAppender {
         /**
          * Creates a new single annotation attribute appender.
          *
-         * @param annotation The annotation to append.
+         * @param annotation The annotations to append.
          */
         public ForAnnotation(Annotation... annotation) {
             this.annotation = annotation;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/This.java
Patch:
@@ -61,7 +61,7 @@ public MethodDelegationBinder.ParameterBinding<?> bind(This annotation,
             StackManipulation stackManipulation = assigner.assign(instrumentedType, targetType, runtimeType);
             return new MethodDelegationBinder.ParameterBinding.Anonymous(
                     new StackManipulation.Compound(
-                            MethodVariableAccess.OBJECT_REFERENCE.loadFromIndex(THIS_REFERENCE_INDEX),
+                            MethodVariableAccess.REFERENCE.loadFromIndex(THIS_REFERENCE_INDEX),
                             stackManipulation));
         }
     }

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/ClassFormatVersionKnownVersionsTest.java
Patch:
@@ -38,6 +38,6 @@ public ClassFormatVersionKnownVersionsTest(int javaVersion, int byteCodeVersion)
 
     @Test
     public void testVersionIsAsExpected() throws Exception {
-        assertThat(ClassFormatVersion.forJavaVersion(javaVersion).getVersionNumber(), is(byteCodeVersion));
+        assertThat(ClassFormatVersion.forKnownJavaVersion(javaVersion).getVersionNumber(), is(byteCodeVersion));
     }
 }

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/member/MethodArgumentTest.java
Patch:
@@ -31,7 +31,6 @@ public class MethodArgumentTest {
     public static Collection<Object[]> data() {
         return Arrays.asList(new Object[][]{
                 {Object.class, Opcodes.ALOAD, 1},
-                {Object[].class, Opcodes.AALOAD, 1},
                 {boolean.class, Opcodes.ILOAD, 1},
                 {byte.class, Opcodes.ILOAD, 1},
                 {short.class, Opcodes.ILOAD, 1},
@@ -51,7 +50,6 @@ public MethodArgumentTest(Class<?> type, int opcode, int size) {
         this.typeDescription = mock(TypeDescription.class);
         when(typeDescription.isPrimitive()).thenReturn(type.isPrimitive());
         when(typeDescription.represents(type)).thenReturn(true);
-        when(typeDescription.isArray()).thenReturn(type.isArray());
         this.opcode = opcode;
         this.size = size;
     }

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/ModifierContributor.java
Patch:
@@ -6,7 +6,8 @@
  * <p/>
  * This allows for a more expressive and type safe alternative of defining a type's or type member's modifiers.
  * However, note that modifier's that apply competing modifiers (such as {@code private} and {@code protected}
- * should not be combined and will result in invalid types.
+ * should not be combined and will result in invalid types. An exception is thrown when built-in modifiers that
+ * cannot be combined are used together.
  */
 public interface ModifierContributor {
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/subclass/LoadedSuperclassDynamicTypeBuilder.java
Patch:
@@ -467,7 +467,7 @@ public MatchedMethodInterception<T> invokable(MethodMatcher methodMatcher) {
 
     @Override
     public DynamicType.Unloaded<T> make() {
-        InstrumentedType instrumentedType = applyRecordedMembersTo(new LoadedSuperclassTypeInstrumentation(classFormatVersion,
+        InstrumentedType instrumentedType = applyRecordedMembersTo(new LoadedSuperclassInstumentedType(classFormatVersion,
                 superType,
                 interfaceTypes,
                 modifiers,

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/auxiliary/MethodCallProxy.java
Patch:
@@ -7,7 +7,7 @@
 import com.blogspot.mydailyjava.bytebuddy.dynamic.scaffold.FieldRegistry;
 import com.blogspot.mydailyjava.bytebuddy.dynamic.scaffold.MethodRegistry;
 import com.blogspot.mydailyjava.bytebuddy.dynamic.scaffold.TypeWriter;
-import com.blogspot.mydailyjava.bytebuddy.dynamic.scaffold.subclass.LoadedSuperclassTypeInstrumentation;
+import com.blogspot.mydailyjava.bytebuddy.dynamic.scaffold.subclass.LoadedSuperclassInstumentedType;
 import com.blogspot.mydailyjava.bytebuddy.dynamic.scaffold.subclass.SubclassInstrumentationContextDelegate;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.ModifierContributor;
@@ -190,7 +190,7 @@ public MethodCallProxy(MethodDescription proxiedMethod, Assigner assigner) {
     public DynamicType<?> make(String auxiliaryTypeName, MethodProxyFactory methodProxyFactory) {
         MethodDescription proxiedMethod = methodProxyFactory.requireProxyMethodFor(this.proxiedMethod);
         int fieldIndex = 0;
-        InstrumentedType proxy = new LoadedSuperclassTypeInstrumentation(ClassFormatVersion.forCurrentJavaVersion(),
+        InstrumentedType proxy = new LoadedSuperclassInstumentedType(ClassFormatVersion.forCurrentJavaVersion(),
                 Object.class,
                 Arrays.<Class<?>>asList(Runnable.class, Callable.class),
                 Opcodes.ACC_PUBLIC,

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/subclass/LoadedSuperclassInstumentedTypeTest.java
Patch:
@@ -16,13 +16,13 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.IsNot.not;
 
-public class LoadedSuperclassTypeInstrumentationTest extends AbstractInstrumentedTypeTest {
+public class LoadedSuperclassInstumentedTypeTest extends AbstractInstrumentedTypeTest {
 
     private static final String FOO = "foo", BAR = "bar", FOOBAR = FOO + "." + BAR;
 
     @Override
     protected InstrumentedType makePlainInstrumentedType() {
-        return new LoadedSuperclassTypeInstrumentation(
+        return new LoadedSuperclassInstumentedType(
                 ClassFormatVersion.forCurrentJavaVersion(),
                 Object.class,
                 Collections.<Class<?>>singletonList(Serializable.class),

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/ByteBuddy.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.List;
 
 import static com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatchers.isDefaultFinalize;
-import static com.blogspot.mydailyjava.bytebuddy.utility.UserInput.*;
+import static com.blogspot.mydailyjava.bytebuddy.utility.ByteBuddyCommons.*;
 
 public class ByteBuddy {
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/subclass/SubclassDynamicTypeBuilder.java
Patch:
@@ -26,7 +26,7 @@
 
 import static com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatchers.isOverridable;
 import static com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatchers.not;
-import static com.blogspot.mydailyjava.bytebuddy.utility.UserInput.*;
+import static com.blogspot.mydailyjava.bytebuddy.utility.ByteBuddyCommons.*;
 
 public class SubclassDynamicTypeBuilder<T> extends DynamicType.Builder.AbstractBase<T> {
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/subclass/SubclassTypeInstrumentation.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.Collection;
 import java.util.List;
 
-import static com.blogspot.mydailyjava.bytebuddy.utility.UserInput.isValidIdentifier;
+import static com.blogspot.mydailyjava.bytebuddy.utility.ByteBuddyCommons.isValidIdentifier;
 
 public class SubclassTypeInstrumentation
         extends InstrumentedType.AbstractBase

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/MethodNameEqualityResolver.java
Patch:
@@ -16,8 +16,8 @@ public enum MethodNameEqualityResolver implements MethodDelegationBinder.Ambigui
 
     @Override
     public Resolution resolve(MethodDescription source,
-                              MethodDelegationBinder.Binding left,
-                              MethodDelegationBinder.Binding right) {
+                              MethodDelegationBinder.MethodBinding left,
+                              MethodDelegationBinder.MethodBinding right) {
         boolean leftEquals = left.getTarget().getName().equals(source.getName());
         boolean rightEquals = right.getTarget().getName().equals(source.getName());
         if (leftEquals ^ rightEquals) {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/matcher/JunctionMethodMatcher.java
Patch:
@@ -1,6 +1,5 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher;
 
-
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 
 public interface JunctionMethodMatcher extends MethodMatcher {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/utility/ByteBuddyCommons.java
Patch:
@@ -5,7 +5,7 @@
 /**
  * Represents a collection of common helper functions.
  */
-public final class UserInput {
+public final class ByteBuddyCommons {
 
     private static final Set<String> JAVA_KEYWORDS = Collections.unmodifiableSet(
             new HashSet<String>(Arrays.asList(
@@ -116,7 +116,7 @@ public static <T extends Collection<?>> T isNotEmpty(T collection, String except
         return collection;
     }
 
-    private UserInput() {
+    private ByteBuddyCommons() {
         throw new AssertionError();
     }
 }

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/AbstractAmbiguityResolverTest.java
Patch:
@@ -19,7 +19,7 @@ public abstract class AbstractAmbiguityResolverTest {
     @Mock
     protected MethodDescription leftMethod,rightMethod;
     @Mock
-    protected MethodDelegationBinder.Binding left, right;
+    protected MethodDelegationBinder.MethodBinding left, right;
 
     @Before
     public void setUp() throws Exception {

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/utility/ByteBuddyCommonsTest.java
Patch:
@@ -6,13 +6,13 @@
 import java.util.Arrays;
 import java.util.List;
 
-import static com.blogspot.mydailyjava.bytebuddy.utility.UserInput.*;
+import static com.blogspot.mydailyjava.bytebuddy.utility.ByteBuddyCommons.*;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
 import static org.hamcrest.core.IsSame.sameInstance;
 import static org.junit.Assert.assertEquals;
 
-public class UserInputTest {
+public class ByteBuddyCommonsTest {
 
     private static final String FOO = "foo", BAR = "bar", QUX = "qux";
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/constant/DoubleConstant.java
Patch:
@@ -11,7 +11,7 @@ public enum DoubleConstant implements StackManipulation {
     ZERO(Opcodes.DCONST_0),
     ONE(Opcodes.DCONST_1);
 
-    private static final StackManipulation.Size SIZE = StackSize.SINGLE.toIncreasingSize();
+    private static final StackManipulation.Size SIZE = StackSize.DOUBLE.toIncreasingSize();
 
     private static class ConstantPool implements StackManipulation {
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/ByteBuddyTest.java
Patch:
@@ -59,7 +59,7 @@ public static void test0(String a) {
 
     @Test
     public void demonstratingExampleToBeRemoved() throws Exception {
-        Bar object = ByteBuddy.make()
+        Bar object = new ByteBuddy()
 //                .withAppendedClassVisitorWrapper(new DebuggingWrapper(System.out))
                 .subclass(Bar.class)
 //                .method(named("utility")).intercept(MethodDelegation.to(Delegate.class))

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/Instrumentation.java
Patch:
@@ -89,11 +89,11 @@ public Size apply(MethodVisitor methodVisitor, Context instrumentationContext, M
         }
     }
 
-    static class Composite implements Instrumentation {
+    static class Compound implements Instrumentation {
 
         private final Instrumentation[] instrumentation;
 
-        public Composite(Instrumentation... instrumentation) {
+        public Compound(Instrumentation... instrumentation) {
             this.instrumentation = instrumentation;
         }
 
@@ -112,7 +112,7 @@ public ByteCodeAppender appender(TypeDescription instrumentedType) {
             for (Instrumentation instrumentation : this.instrumentation) {
                 byteCodeAppender[index++] = instrumentation.appender(instrumentedType);
             }
-            return new ByteCodeAppender.Composite(byteCodeAppender);
+            return new ByteCodeAppender.Compound(byteCodeAppender);
         }
     }
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/AllArguments.java
Patch:
@@ -1,9 +1,9 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.MethodArgument;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.member.MethodArgument;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.collection.ArrayFactory;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/Argument.java
Patch:
@@ -1,9 +1,9 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.MethodArgument;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.member.MethodArgument;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.MostSpecificTypeResolver;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 
@@ -59,7 +59,7 @@ private static IdentifiedBinding<?> makeBinding(TypeDescription sourceType,
         }
     }
 
-    static enum NextUnboundAsDefaultProvider implements AnnotationDrivenBinder.DefaultProvider {
+    static enum NextUnboundAsDefaultsProvider implements AnnotationDrivenBinder.DefaultsProvider {
         INSTANCE;
 
         private static class DefaultArgument implements Argument {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/SuperCall.java
Patch:
@@ -1,7 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.auxiliary.MethodCallProxy;
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/This.java
Patch:
@@ -1,9 +1,9 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.MethodArgument;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.member.MethodArgument;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 
 import java.lang.annotation.*;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/StackSize.java
Patch:
@@ -1,6 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode;
-
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack;
 
 public enum StackSize {
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/Assigner.java
Patch:
@@ -1,5 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign;
 
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 
 public interface Assigner {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveBoxingDelegate.java
Patch:
@@ -1,8 +1,8 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import org.objectweb.asm.MethodVisitor;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveTypeAwareAssigner.java
Patch:
@@ -1,6 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveUnboxingDelegate.java
Patch:
@@ -1,8 +1,8 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import org.objectweb.asm.MethodVisitor;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveWideningDelegate.java
Patch:
@@ -1,7 +1,7 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.IllegalStackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.LegalTrivialStackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/reference/ReferenceTypeAwareAssigner.java
Patch:
@@ -1,8 +1,8 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.reference;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.reference;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.IllegalStackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.LegalTrivialStackManipulation;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/collection/ArrayFactory.java
Patch:
@@ -1,9 +1,9 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.collection;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.IntegerConstant;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.constant.IntegerConstant;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/member/MethodArgument.java
Patch:
@@ -1,8 +1,9 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.member;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/member/MethodInvocation.java
Patch:
@@ -1,7 +1,8 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.member;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/member/MethodReturn.java
Patch:
@@ -1,7 +1,8 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.member;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/InstrumentedType.java
Patch:
@@ -5,7 +5,7 @@
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.field.FieldList;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodList;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
 import org.objectweb.asm.Opcodes;
 
 import java.lang.annotation.Annotation;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/TypeDescription.java
Patch:
@@ -5,7 +5,7 @@
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.field.FieldList;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodList;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatcher;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatchers;
 import org.objectweb.asm.Type;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/TypeList.java
Patch:
@@ -1,6 +1,6 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.type;
 
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
 import org.objectweb.asm.Type;
 
 import java.util.*;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/dynamic/scaffold/SubclassTypeInstrumentationTest.java
Patch:
@@ -6,7 +6,7 @@
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.AbstractInstrumentedTypeTest;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType;
 
-public class SubclassLoadedTypeInstrumentationTest extends AbstractInstrumentedTypeTest {
+public class SubclassTypeInstrumentationTest extends AbstractInstrumentedTypeTest {
 
     @Override
     protected InstrumentedType makeInstrumentedType(String name,
@@ -17,7 +17,7 @@ protected InstrumentedType makeInstrumentedType(String name,
                                                     SyntheticState syntheticState) {
 //        NamingStrategy namingStrategy = mock(NamingStrategy.class);
 //        when(namingStrategy.getName(any(NamingStrategy.UnnamedType.class))).thenReturn(name);
-//        SubclassLoadedTypeInstrumentation instrumentedType = new SubclassLoadedTypeInstrumentation(new ClassVersion(Opcodes.V1_6),
+//        SubclassTypeInstrumentation instrumentedType = new SubclassTypeInstrumentation(new ClassVersion(Opcodes.V1_6),
 //                Object.class,
 //                Arrays.<Class<?>>asList(Serializable.class),
 //                Visibility.PUBLIC,

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/StackSizeTest.java
Patch:
@@ -1,5 +1,6 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode;
 
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/MethodBindingBuilderTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation.AnnotationDrivenBinder;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/AbstractAnnotationBinderTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeList;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/AllArgumentsAnnotationBinderTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import org.junit.Test;
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/EmptyDefaultsProviderTest.java
Patch:
@@ -15,7 +15,7 @@
 import static org.hamcrest.core.Is.is;
 import static org.mockito.Mockito.verifyZeroInteractions;
 
-public class EmptyDefaultProviderTest {
+public class EmptyDefaultsProviderTest {
 
     @Rule
     public TestRule mockitoRule = new MockitoRule(this);
@@ -27,7 +27,7 @@ public class EmptyDefaultProviderTest {
 
     @Test(expected = NoSuchElementException.class)
     public void testEmptyIteration() throws Exception {
-        Iterator<?> iterator = AnnotationDrivenBinder.DefaultProvider.Empty.INSTANCE.makeIterator(typeDescription, left, right);
+        Iterator<?> iterator = AnnotationDrivenBinder.DefaultsProvider.Empty.INSTANCE.makeIterator(typeDescription, left, right);
         assertThat(iterator.hasNext(), is(false));
         verifyZeroInteractions(typeDescription);
         verifyZeroInteractions(left);

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/DefaultValueTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.constant.DefaultValue;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;
 import org.junit.After;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/IntegerConstantTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.constant.IntegerConstant;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;
 import org.junit.After;
 import org.junit.Rule;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/MethodArgumentDescriptionTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.member.MethodArgument;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeList;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/MethodArgumentShortcutTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.member.MethodArgument;
 import com.blogspot.mydailyjava.bytebuddy.utility.MoreOpcodes;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/MethodArgumentTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.member.MethodArgument;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;
 import org.junit.After;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/MethodArgumentVoidTest.java
Patch:
@@ -1,5 +1,6 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack;
 
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.member.MethodArgument;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import org.junit.Test;
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/MethodInvocationTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.member.MethodInvocation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;
 import org.junit.After;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/MethodReturnTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.member.MethodReturn;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;
 import org.junit.After;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveBoxingDelegateTest.java
Patch:
@@ -1,8 +1,8 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveTypeAwareAssignerBoxingTest.java
Patch:
@@ -1,6 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveTypeAwareAssignerImplicitUnboxingTest.java
Patch:
@@ -1,6 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveTypeAwareAssignerPrimitiveTest.java
Patch:
@@ -1,6 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveTypeAwareAssignerUnboxingTest.java
Patch:
@@ -1,6 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveUnboxingDelegateDirectTest.java
Patch:
@@ -1,8 +1,8 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveUnboxingDelegateWideningTest.java
Patch:
@@ -1,7 +1,7 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveWideningDelegateIllegalTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveWideningDelegateNontrivialTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/PrimitiveWideningDelegateTrivialTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/VoidAwareAssignerNonVoidToVoidTest.java
Patch:
@@ -1,8 +1,8 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/VoidAwareAssignerTest.java
Patch:
@@ -1,7 +1,7 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/primitive/VoidAwareAssignerVoidToNonVoidTest.java
Patch:
@@ -1,8 +1,8 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.primitive;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.primitive;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.Assigner;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/assign/reference/ReferenceTypeAwareAssignerTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.reference;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.assign.reference;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/stack/collection/AbstractArrayFactoryTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.collection;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.Instrumentation;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackManipulation;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.utility.MockitoRule;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/AbstractInstrumentedTypeTest.java
Patch:
@@ -5,7 +5,7 @@
 import com.blogspot.mydailyjava.bytebuddy.modifier.Visibility;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.field.FieldDescription;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
 import org.junit.Before;
 import org.junit.Test;
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/TypeDescriptionForLoadedTypeTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.type;
 
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.StackSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.stack.StackSize;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.asm.Type;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/scaffold/SubclassLoadedTypeInstrumentation.java
Patch:
@@ -9,7 +9,6 @@
 
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 
 public class SubclassLoadedTypeInstrumentation
@@ -34,7 +33,6 @@ public SubclassLoadedTypeInstrumentation(ClassVersion classVersion,
                                              TypeManifestation typeManifestation,
                                              SyntheticState syntheticState,
                                              NamingStrategy namingStrategy) {
-        super(Collections.<FieldDescription>emptyList(), Collections.<MethodDescription>emptyList());
         this.classVersion = classVersion;
         this.superClass = superClass;
         this.interfaces = interfaces;
@@ -53,7 +51,7 @@ private SubclassLoadedTypeInstrumentation(ClassVersion classVersion,
                                               String name,
                                               List<? extends FieldDescription> fieldDescriptions,
                                               List<? extends MethodDescription> methodDescriptions) {
-        super(fieldDescriptions, methodDescriptions);
+        super(name, fieldDescriptions, methodDescriptions);
         this.classVersion = classVersion;
         this.superClass = superClass;
         this.interfaces = interfaces;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/AbstractInstrumentedTypeTest.java
Patch:
@@ -134,6 +134,7 @@ public void testEquals() throws Exception {
     @Test
     public void testWithField() throws Exception {
         TypeDescription fieldType = mock(TypeDescription.class);
+        when(fieldType.getInternalName()).thenReturn(BAR);
         instrumentedType = instrumentedType.withField(QUX, fieldType, Modifier.PUBLIC, false);
         assertThat(instrumentedType.getDeclaredFields().size(), is(1));
         FieldDescription fieldDescription = instrumentedType.getDeclaredFields().get(0);
@@ -157,7 +158,9 @@ public void testWithFieldOfInstrumentedType() throws Exception {
     @Test
     public void testWithMethod() throws Exception {
         TypeDescription parameterType = mock(TypeDescription.class);
+        when(parameterType.getInternalName()).thenReturn(BAR);
         TypeDescription returnType = mock(TypeDescription.class);
+        when(returnType.getInternalName()).thenReturn(BAR);
         instrumentedType = instrumentedType.withMethod(QUX, returnType, Arrays.asList(parameterType), Modifier.PUBLIC, false);
         assertThat(instrumentedType.getDeclaredMethods().size(), is(1));
         MethodDescription methodDescription = instrumentedType.getDeclaredMethods().get(0);

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/ByteBuddy.java
Patch:
@@ -3,7 +3,7 @@
 import com.blogspot.mydailyjava.bytebuddy.asm.ClassVisitorWrapper;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatcher;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatchers;
-import com.blogspot.mydailyjava.bytebuddy.proxy.DynamicProxy;
+import com.blogspot.mydailyjava.bytebuddy.proxy.DynamicType;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.scaffold.SubclassDynamicProxyBuilder;
 import org.objectweb.asm.Opcodes;
 
@@ -159,7 +159,7 @@ public ClassVisitorWrapper.Chain getClassVisitorWrapperChain() {
         return classVisitorWrapperChain;
     }
 
-    public <T> DynamicProxy.Builder<T> subclass(Class<? extends T> type) {
+    public <T> DynamicType.Builder<T> subclass(Class<? extends T> type) {
         return SubclassDynamicProxyBuilder.of(type, this);
     }
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/MethodDescription.java
Patch:
@@ -13,6 +13,8 @@
 
 public interface MethodDescription extends ModifierReviewable, ByteCodeMethod, DeclaredInType, AnnotatedElement {
 
+    static final String CONSTRUCTOR_INTERNAL_NAME = "<init>";
+
     static abstract class AbstractMethodDescription extends AbstractModifierReviewable implements MethodDescription {
 
         @Override
@@ -65,8 +67,6 @@ public int hashCode() {
 
     static class ForConstructor extends AbstractMethodDescription {
 
-        private static final String DYNAMIC_CONSTRUCTOR_INTERNAL_NAME = "<init>";
-
         private final Constructor<?> constructor;
 
         public ForConstructor(Constructor<?> constructor) {
@@ -141,7 +141,7 @@ public boolean isSynthetic() {
 
         @Override
         public String getInternalName() {
-            return DYNAMIC_CONSTRUCTOR_INTERNAL_NAME;
+            return CONSTRUCTOR_INTERNAL_NAME;
         }
 
         @Override

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/loading/ByteArrayClassLoader.java
Patch:
@@ -1,15 +1,14 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.type.loading;
 
-import java.util.Collections;
 import java.util.Map;
 
 public class ByteArrayClassLoader extends ClassLoader {
 
     private final Map<String, byte[]> typeDefinitions;
 
-    public ByteArrayClassLoader(ClassLoader parent, String typeName, byte[] javaType) {
+    public ByteArrayClassLoader(ClassLoader parent, Map<String, byte[]> typeDefinitions) {
         super(parent);
-        this.typeDefinitions = Collections.singletonMap(typeName, javaType);
+        this.typeDefinitions = typeDefinitions;
     }
 
     @Override

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/ByteBuddyTest.java
Patch:
@@ -5,6 +5,7 @@
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation.Argument;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation.RuntimeType;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation.This;
+import com.blogspot.mydailyjava.bytebuddy.proxy.DynamicType;
 import org.junit.Test;
 
 import java.util.Arrays;
@@ -68,8 +69,8 @@ public void demonstratingExampleToBeRemoved() throws Exception {
                 .method(named("foo")).intercept(MethodDelegation.to(Delegate.class))
                 .method(named("test")).intercept(MethodDelegation.to(Delegate.class))
                 .make()
-                .load(getClass().getClassLoader())
-                .getProxyClass()
+                .load(getClass().getClassLoader(), DynamicType.ClassLoadingStrategy.WRAPPER)
+                .getMainType()
                 .newInstance();
         System.out.println(object.test("a", 10));
         System.out.println(object.foo(10, 3));

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/auxiliary/MethodCallProxyTest.java
Patch:
@@ -13,6 +13,7 @@
 import java.lang.reflect.Constructor;
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.concurrent.Callable;
 
 import static org.hamcrest.CoreMatchers.is;
@@ -91,10 +92,9 @@ public void testMethodProxy() throws Exception {
         MethodDescription proxiedMethod = new MethodDescription.ForMethod
                 (proxiedType.getDeclaredMethod(FOO, proxiedMethodParameters));
         MethodCallProxy methodCallProxy = new MethodCallProxy(proxiedMethod);
-        AuxiliaryClass.Named namedAuxiliaryClass = methodCallProxy.name(proxyName(proxiedType), CLASS_VERSION);
+        AuxiliaryType.Named namedAuxiliaryClass = methodCallProxy.name(proxyName(proxiedType), CLASS_VERSION);
         ClassLoader proxyClassLoader = new ByteArrayClassLoader(getClass().getClassLoader(),
-                proxyName(proxiedType),
-                namedAuxiliaryClass.make());
+                Collections.singletonMap(proxyName(proxiedType), namedAuxiliaryClass.make().getMainTypeByte()));
         Class<?> proxyType = Class.forName(proxyName(proxiedType), false, proxyClassLoader);
         Constructor<?> proxyConstructor = assertProxyType(proxyType, proxiedMethod);
         InvocationCountable invocationCountable = proxiedType.newInstance();

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/ByteBuddy.java
Patch:
@@ -3,7 +3,7 @@
 import com.blogspot.mydailyjava.bytebuddy.asm.ClassVisitorWrapper;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatcher;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatchers;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.instrumentation.DynamicProxy;
+import com.blogspot.mydailyjava.bytebuddy.proxy.DynamicProxy;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.scaffold.SubclassDynamicProxyBuilder;
 import org.objectweb.asm.Opcodes;
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/TypeManifestation.java
Patch:
@@ -1,6 +1,6 @@
 package com.blogspot.mydailyjava.bytebuddy;
 
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.ModifierContributor;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.ModifierContributor;
 import org.objectweb.asm.Opcodes;
 
 public enum TypeManifestation implements ModifierContributor {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/Visibility.java
Patch:
@@ -1,6 +1,6 @@
 package com.blogspot.mydailyjava.bytebuddy;
 
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.ModifierContributor;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.ModifierContributor;
 import org.objectweb.asm.Opcodes;
 
 public enum Visibility implements ModifierContributor {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/MethodList.java
Patch:
@@ -51,9 +51,9 @@ public MethodList filter(MethodMatcher methodMatcher) {
 
     static class Explicit extends AbstractList<MethodDescription> implements MethodList {
 
-        private final List<MethodDescription> methodDescriptions;
+        private final List<? extends MethodDescription> methodDescriptions;
 
-        public Explicit(List<MethodDescription> methodDescriptions) {
+        public Explicit(List<? extends MethodDescription> methodDescriptions) {
             this.methodDescriptions = Collections.unmodifiableList(methodDescriptions);
         }
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/MethodDelegation.java
Patch:
@@ -39,7 +39,8 @@ public static ByteCodeAppender.Factory to(Class<?> type) {
                                 This.Binder.INSTANCE,
                                 AllArguments.Binder.INSTANCE),
                         Argument.NextUnboundAsDefaultProvider.INSTANCE,
-                        new VoidAwareAssigner(new PrimitiveTypeAwareAssigner(ReferenceTypeAwareAssigner.INSTANCE), false)),
+                        new VoidAwareAssigner(new PrimitiveTypeAwareAssigner(ReferenceTypeAwareAssigner.INSTANCE), false),
+                        MethodDelegationBinder.MethodInvoker.Simple.INSTANCE),
                 new MethodDelegationBinder.AmbiguityResolver.Chain(
                         Arrays.<MethodDelegationBinder.AmbiguityResolver>asList(
                                 MethodNameEqualityResolver.INSTANCE,

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/Argument.java
Patch:
@@ -32,7 +32,7 @@ public IdentifiedBinding<?> bind(Argument sourceParameterIndex,
                                          TypeDescription instrumentedType,
                                          Assigner assigner) {
             if (sourceParameterIndex.value() < 0) {
-                throw new IllegalArgumentException(String.format("Argument annotation on %d's argument of " +
+                throw new IllegalArgumentException(String.format("Argument annotation on %d's argument virtual " +
                         "%s holds negative index", targetParameterIndex, target));
             } else if (source.getParameterTypes().size() <= sourceParameterIndex.value()) {
                 return IdentifiedBinding.makeIllegal();

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/This.java
Patch:
@@ -30,10 +30,10 @@ public IdentifiedBinding<?> bind(This annotation,
                                          Assigner assigner) {
             TypeDescription targetType = target.getParameterTypes().get(targetParameterIndex);
             if (targetType.isPrimitive()) {
-                throw new IllegalStateException(String.format("The %d. argument of %s is a primitive type " +
+                throw new IllegalStateException(String.format("The %d. argument virtual %s is a primitive type " +
                         "and can never be bound to an instance", targetParameterIndex, target));
             } else if(targetType.isArray()) {
-                throw new IllegalStateException(String.format("The %d. argument of %s is an array type " +
+                throw new IllegalStateException(String.format("The %d. argument virtual %s is an array type " +
                         "and can never be bound to an instance", targetParameterIndex, target));
             } else if (source.isStatic()) {
                 return IdentifiedBinding.makeIllegal();

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/auxiliary/AuxiliaryClass.java
Patch:
@@ -2,9 +2,12 @@
 
 import com.blogspot.mydailyjava.bytebuddy.ClassVersion;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.assign.Assignment;
+import org.objectweb.asm.Opcodes;
 
 public interface AuxiliaryClass {
 
+    static final int DEFAULT_TYPE_ACCESS = Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC;
+
     static interface Named extends Assignment {
 
         String getProxyTypeInternalName();

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/ByteBuddyTest.java
Patch:
@@ -48,7 +48,7 @@ public static String test(@Argument(1) int y, @Argument(0) Object x, @This Bar b
         }
 
         public static int x(@AllArguments @RuntimeType int[] i) {
-            for(int in : i) {
+            for (int in : i) {
                 System.out.println(in);
             }
             return i.length;
@@ -69,6 +69,7 @@ public void demonstratingExampleToBeRemoved() throws Exception {
                 .method(named("test")).intercept(MethodDelegation.to(Delegate.class))
                 .make()
                 .load(getClass().getClassLoader())
+                .getProxyClass()
                 .newInstance();
         System.out.println(object.test("a", 10));
         System.out.println(object.foo(10, 3));

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/MethodDescriptionForConstructorTest.java
Patch:
@@ -79,7 +79,7 @@ public void testHashCode() throws Exception {
     }
 
     private static int hashCode(Constructor<?> constructor) {
-        return (Type.getInternalName(constructor.getDeclaringClass()) + CONSTRUCTOR_INTERNAL_NAME + Type.getConstructorDescriptor(constructor)).hashCode();
+        return (Type.getInternalName(constructor.getDeclaringClass()) + "." + CONSTRUCTOR_INTERNAL_NAME + Type.getConstructorDescriptor(constructor)).hashCode();
     }
 
     @Test

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/MethodDescriptionForMethodTest.java
Patch:
@@ -80,7 +80,7 @@ public void testHashCode() throws Exception {
     }
 
     private static int hashCode(Method method) {
-        return (Type.getInternalName(method.getDeclaringClass()) + method.getName() + Type.getMethodDescriptor(method)).hashCode();
+        return (Type.getInternalName(method.getDeclaringClass()) + "." + method.getName() + Type.getMethodDescriptor(method)).hashCode();
     }
 
     @Test

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/ByteCodeAppenderFactoryTester.java
Patch:
@@ -1,7 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType0;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.loading.ByteArrayClassLoader;
 import org.objectweb.asm.ClassWriter;
 import org.objectweb.asm.MethodVisitor;
@@ -23,7 +23,7 @@ public class ByteCodeAppenderFactoryTester {
     private final Random random;
 
     public ByteCodeAppenderFactoryTester(ByteCodeAppender.Factory factory,
-                                         InstrumentedType typeDescription,
+                                         InstrumentedType0 typeDescription,
                                          Class<?> superClass) {
         appender = factory.make(typeDescription);
         this.superClass = superClass;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/MethodDelegationComplexTest.java
Patch:
@@ -4,7 +4,7 @@
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation.Argument;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation.This;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType0;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.asm.Opcodes;
@@ -30,11 +30,11 @@ public String foo(Void a, String b, int c) {
         }
     }
 
-    private InstrumentedType instrumentedType;
+    private InstrumentedType0 instrumentedType;
 
     @Before
     public void setUp() throws Exception {
-        instrumentedType = new InstrumentedType(new ClassVersion(Opcodes.V1_6),
+        instrumentedType = new InstrumentedType0(new ClassVersion(Opcodes.V1_6),
                 Source.class,
                 Collections.<Class<?>>emptySet(),
                 Visibility.PUBLIC,

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/MethodDelegationSimpleTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation.IgnoreForBinding;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType0;
 import org.hamcrest.Matcher;
 import org.junit.Before;
 import org.junit.Test;
@@ -23,11 +23,11 @@ public class MethodDelegationSimpleTest {
 
     private static final int ARGUMENT_VALUE = 21, MULTIPLICATOR = 2, RESULT = ARGUMENT_VALUE * MULTIPLICATOR;
 
-    private InstrumentedType instrumentedType;
+    private InstrumentedType0 instrumentedType;
 
     @Before
     public void setUp() throws Exception {
-        instrumentedType = mock(InstrumentedType.class);
+        instrumentedType = mock(InstrumentedType0.class);
         SimpleDelegationTarget.clearStackTraceRecord();
     }
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/StubMethodTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType0;
 import org.hamcrest.Matcher;
 import org.junit.Before;
 import org.junit.Test;
@@ -18,11 +18,11 @@ public class StubMethodTest {
     private static final int NON_DEFAULT_VALUE = 42;
     private static final int DEFAULT_VALUE = 0;
 
-    private InstrumentedType instrumentedType;
+    private InstrumentedType0 instrumentedType;
 
     @Before
     public void setUp() throws Exception {
-        instrumentedType = mock(InstrumentedType.class);
+        instrumentedType = mock(InstrumentedType0.class);
     }
 
     @SuppressWarnings("unused")

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/SuperClassDelegationTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType0;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import org.hamcrest.Matcher;
 import org.junit.Before;
@@ -18,11 +18,11 @@ public class SuperClassDelegationTest {
     private static final String FOO = "foo";
     private static final int NON_DEFAULT_VALUE = 42;
 
-    private InstrumentedType instrumentedType;
+    private InstrumentedType0 instrumentedType;
 
     @Before
     public void setUp() throws Exception {
-        instrumentedType = mock(InstrumentedType.class);
+        instrumentedType = mock(InstrumentedType0.class);
     }
 
     @SuppressWarnings("unused")

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/MethodDelegationBinderProcessorTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType0;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -14,7 +14,7 @@
 
 public class MethodDelegationBinderProcessorTest {
 
-    private InstrumentedType typeDescription;
+    private InstrumentedType0 typeDescription;
     private MethodDescription source;
 
     private MethodDescription bindableTarget, unbindableTarget, dominantBindableTarget;
@@ -25,7 +25,7 @@ public class MethodDelegationBinderProcessorTest {
 
     @Before
     public void setUp() throws Exception {
-        typeDescription = mock(InstrumentedType.class);
+        typeDescription = mock(InstrumentedType0.class);
         source = mock(MethodDescription.class);
         bindableTarget = mock(MethodDescription.class);
         unbindableTarget = mock(MethodDescription.class);

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/AbstractAnnotationBinderTest.java
Patch:
@@ -3,7 +3,7 @@
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.assign.Assignment;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType0;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeList;
 import org.junit.Before;
@@ -26,7 +26,7 @@ protected AbstractAnnotationBinderTest(Class<T> annotationType) {
     protected T annotation;
     protected MethodDescription source;
     protected MethodDescription target;
-    protected InstrumentedType typeDescription;
+    protected InstrumentedType0 typeDescription;
     protected Assigner assigner;
     protected Assignment assignment;
     protected TypeList sourceTypeList;
@@ -37,7 +37,7 @@ public void setUp() throws Exception {
         annotation = mock(annotationType);
         source = mock(MethodDescription.class);
         target = mock(MethodDescription.class);
-        typeDescription = mock(InstrumentedType.class);
+        typeDescription = mock(InstrumentedType0.class);
         assigner = mock(Assigner.class);
         assignment = mock(Assignment.class);
         sourceTypeList = mock(TypeList.class);

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/EmptyDefaultProviderTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType0;
 import org.junit.Test;
 
 import java.util.Iterator;
@@ -16,7 +16,7 @@ public class EmptyDefaultProviderTest {
 
     @Test(expected = NoSuchElementException.class)
     public void testEmptyIteration() throws Exception {
-        InstrumentedType typeDescription = mock(InstrumentedType.class);
+        InstrumentedType0 typeDescription = mock(InstrumentedType0.class);
         MethodDescription left = mock(MethodDescription.class);
         MethodDescription right = mock(MethodDescription.class);
         Iterator<?> iterator = AnnotationDrivenBinder.DefaultProvider.Empty.INSTANCE.makeIterator(typeDescription, left, right);

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/NextUnboundAsDefaultHandlerTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.InstrumentedType0;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeList;
 import org.junit.Before;
@@ -17,14 +17,14 @@
 
 public class NextUnboundAsDefaultHandlerTest {
 
-    private InstrumentedType typeDescription;
+    private InstrumentedType0 typeDescription;
     private MethodDescription source;
     private MethodDescription target;
     private TypeList typeList;
 
     @Before
     public void setUp() throws Exception {
-        typeDescription = mock(InstrumentedType.class);
+        typeDescription = mock(InstrumentedType0.class);
         source = mock(MethodDescription.class);
         target = mock(MethodDescription.class);
         typeList = mock(TypeList.class);

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/InstrumentedTypeTest.java
Patch:
@@ -19,13 +19,13 @@ public class InstrumentedTypeTest {
 
     private static final String FOO = "foo", BAR = "bar";
 
-    private InstrumentedType instrumentedType;
+    private InstrumentedType0 instrumentedType;
 
     @Before
     public void setUp() throws Exception {
         NamingStrategy namingStrategy = mock(NamingStrategy.class);
         when(namingStrategy.getName(any(NamingStrategy.UnnamedType.class))).thenReturn(FOO);
-        instrumentedType = new InstrumentedType(new ClassVersion(Opcodes.V1_6),
+        instrumentedType = new InstrumentedType0(new ClassVersion(Opcodes.V1_6),
                 Object.class,
                 Arrays.<Class<?>>asList(Serializable.class),
                 Visibility.PUBLIC,

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/TypeList.java
Patch:
@@ -32,7 +32,7 @@ public String[] toInternalNames() {
             for(Class<?> aType : type) {
                 internalNames[i++] = Type.getInternalName(aType);
             }
-            return internalNames;
+            return internalNames.length == 0 ? null : internalNames;
         }
 
         @Override

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/matcher/JunctionMethodMatcherTest.java
Patch:
@@ -12,7 +12,7 @@
 public class JunctionMethodMatcherTest {
 
     @SuppressWarnings("unused")
-    public static class TestClass {
+    public static class MatchedClass {
 
         public void foo() {
             /* empty */
@@ -25,7 +25,7 @@ public void foo() {
 
     @Before
     public void setUp() throws Exception {
-        testClass$foo = TestClass.class.getDeclaredMethod(FOO_METHOD_NAME);
+        testClass$foo = MatchedClass.class.getDeclaredMethod(FOO_METHOD_NAME);
     }
 
     @Test

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/NamingStrategy.java
Patch:
@@ -9,7 +9,7 @@ static interface UnnamedType {
 
         Class<?> getSuperClass();
 
-        Collection<Class<?>> getInterfaces();
+        Collection<Class<?>> getDeclaredInterfaces();
 
         Visibility getVisibility();
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/SyntheticState.java
Patch:
@@ -1,6 +1,6 @@
 package com.blogspot.mydailyjava.bytebuddy;
 
-import com.blogspot.mydailyjava.bytebuddy.type.ModifierContributor;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.ModifierContributor;
 import org.objectweb.asm.Opcodes;
 
 public enum SyntheticState implements ModifierContributor {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/TypeManifestation.java
Patch:
@@ -1,6 +1,6 @@
 package com.blogspot.mydailyjava.bytebuddy;
 
-import com.blogspot.mydailyjava.bytebuddy.type.ModifierContributor;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.ModifierContributor;
 import org.objectweb.asm.Opcodes;
 
 public enum TypeManifestation implements ModifierContributor {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/Visibility.java
Patch:
@@ -1,6 +1,6 @@
 package com.blogspot.mydailyjava.bytebuddy;
 
-import com.blogspot.mydailyjava.bytebuddy.type.ModifierContributor;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.ModifierContributor;
 import org.objectweb.asm.Opcodes;
 
 public enum Visibility implements ModifierContributor {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/ByteCodeAppender.java
Patch:
@@ -1,7 +1,7 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode;
 
-import com.blogspot.mydailyjava.bytebuddy.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.type.TypeDescription;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.TypeDescription;
 import org.objectweb.asm.MethodVisitor;
 
 public interface ByteCodeAppender {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/assign/Assignment.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.assign;
 
 import org.objectweb.asm.MethodVisitor;
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/assign/FieldAccess.java
Patch:
@@ -1,6 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.assign;
 
-import com.blogspot.mydailyjava.bytebuddy.method.bytecode.TypeSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.TypeSize;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/assign/IllegalAssignment.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.assign;
 
 import org.objectweb.asm.MethodVisitor;
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/assign/IntegerConstant.java
Patch:
@@ -1,6 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.assign;
 
-import com.blogspot.mydailyjava.bytebuddy.method.bytecode.TypeSize;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.TypeSize;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/assign/LegalTrivialAssignment.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.assign;
 
 import org.objectweb.asm.MethodVisitor;
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/IllegalMethodDelegation.java
Patch:
@@ -1,7 +1,7 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.bind;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind;
 
-import com.blogspot.mydailyjava.bytebuddy.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign.Assignment;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.assign.Assignment;
 import org.objectweb.asm.MethodVisitor;
 
 public enum IllegalMethodDelegation implements MethodDelegationBinder.Binding {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/MethodNameEqualityResolver.java
Patch:
@@ -1,6 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.bind;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind;
 
-import com.blogspot.mydailyjava.bytebuddy.method.MethodDescription;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 
 public enum MethodNameEqualityResolver implements MethodDelegationBinder.AmbiguityResolver {
     INSTANCE;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/IgnoreForBinding.java
Patch:
@@ -1,6 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.bind.annotation;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
-import com.blogspot.mydailyjava.bytebuddy.method.MethodDescription;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 
 import java.lang.annotation.*;
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/RuntimeType.java
Patch:
@@ -1,6 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.bind.annotation;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
-import com.blogspot.mydailyjava.bytebuddy.method.MethodDescription;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 
 import java.lang.annotation.*;
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/matcher/JunctionMethodMatcher.java
Patch:
@@ -1,7 +1,7 @@
-package com.blogspot.mydailyjava.bytebuddy.method.matcher;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher;
 
 
-import com.blogspot.mydailyjava.bytebuddy.method.MethodDescription;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 
 public abstract class JunctionMethodMatcher implements MethodMatcher {
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/matcher/MethodExtraction.java
Patch:
@@ -1,6 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.method.matcher;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher;
 
-import com.blogspot.mydailyjava.bytebuddy.method.MethodDescription;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/auxiliary/AuxiliaryClass.java
Patch:
@@ -1,7 +1,7 @@
-package com.blogspot.mydailyjava.bytebuddy.type.auxiliary;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.type.auxiliary;
 
 import com.blogspot.mydailyjava.bytebuddy.ClassVersion;
-import com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign.Assignment;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.assign.Assignment;
 
 public interface AuxiliaryClass {
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/instrumentation/ByteArrayDynamicProxy.java
Patch:
@@ -1,7 +1,7 @@
-package com.blogspot.mydailyjava.bytebuddy.type.instrumentation;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.type.instrumentation;
 
-import com.blogspot.mydailyjava.bytebuddy.type.loading.ByteArrayClassLoader;
-import com.blogspot.mydailyjava.bytebuddy.type.loading.ClassLoaderByteArrayInjector;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.loading.ByteArrayClassLoader;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.loading.ClassLoaderByteArrayInjector;
 
 public class ByteArrayDynamicProxy<T> implements DynamicProxy<T> {
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/instrumentation/DynamicProxy.java
Patch:
@@ -1,9 +1,9 @@
-package com.blogspot.mydailyjava.bytebuddy.type.instrumentation;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.type.instrumentation;
 
 import com.blogspot.mydailyjava.bytebuddy.TypeManifestation;
 import com.blogspot.mydailyjava.bytebuddy.Visibility;
-import com.blogspot.mydailyjava.bytebuddy.method.bytecode.ByteCodeAppender;
-import com.blogspot.mydailyjava.bytebuddy.method.matcher.MethodMatcher;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.ByteCodeAppender;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatcher;
 
 public interface DynamicProxy<T> {
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/loading/ByteArrayClassLoader.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.type.loading;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.type.loading;
 
 import java.util.Collections;
 import java.util.Map;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/loading/ClassLoaderByteArrayInjector.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.type.loading;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.type.loading;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/AbstractCallHistoryTraceable.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode;
 
 public abstract class AbstractCallHistoryTraceable {
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/MoreOpcodes.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode;
 
 public final class MoreOpcodes {
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/TypeSizeTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode;
 
 import org.junit.Test;
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/assign/IntegerConstantTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.assign;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -28,7 +28,7 @@ public void testConstant() throws Exception {
         testConstant(5, Opcodes.ICONST_5);
     }
 
-    public void testConstant(int value, int opcode) throws Exception {
+    private void testConstant(int value, int opcode) throws Exception {
         Assignment.Size size = IntegerConstant.forValue(value).apply(methodVisitor);
         assertThat(size.getSizeImpact(), is(1));
         assertThat(size.getMaximalSize(), is(1));

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/AbstractAmbiguityResolverTest.java
Patch:
@@ -1,6 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.bind;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind;
 
-import com.blogspot.mydailyjava.bytebuddy.method.MethodDescription;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 import org.junit.Before;
 
 import static org.mockito.Mockito.mock;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/MethodBindingAmbiguityResolutionTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.bind;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind;
 
 import org.junit.Test;
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/MethodNameEqualityResolverTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.bind;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind;
 
 import org.junit.Test;
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/AnnotationVisibilityTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.bind.annotation;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
 import org.junit.Test;
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/IdentifiedBindingTest.java
Patch:
@@ -1,6 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.bind.annotation;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
-import com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign.Assignment;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.assign.Assignment;
 import org.junit.Before;
 import org.junit.Test;
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/bytecode/bind/annotation/RuntimeTypeVerifierTest.java
Patch:
@@ -1,6 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.bind.annotation;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.bytecode.bind.annotation;
 
-import com.blogspot.mydailyjava.bytebuddy.method.MethodDescription;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 import org.junit.Before;
 import org.junit.Test;
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/matcher/JunctionMethodMatcherTest.java
Patch:
@@ -1,6 +1,6 @@
-package com.blogspot.mydailyjava.bytebuddy.method.matcher;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher;
 
-import com.blogspot.mydailyjava.bytebuddy.method.MethodDescription;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 import org.junit.Before;
 import org.junit.Test;
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/method/matcher/MethodExtractionTest.java
Patch:
@@ -1,14 +1,14 @@
-package com.blogspot.mydailyjava.bytebuddy.method.matcher;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher;
 
-import com.blogspot.mydailyjava.bytebuddy.method.MethodDescription;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
 import org.junit.Test;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.util.LinkedList;
 import java.util.List;
 
-import static com.blogspot.mydailyjava.bytebuddy.method.matcher.MethodMatchers.*;
+import static com.blogspot.mydailyjava.bytebuddy.instrumentation.method.matcher.MethodMatchers.*;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
 import static org.hamcrest.core.IsCollectionContaining.hasItems;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/instrumentation/type/auxiliary/MethodCallProxyTest.java
Patch:
@@ -1,8 +1,8 @@
-package com.blogspot.mydailyjava.bytebuddy.type.auxiliary;
+package com.blogspot.mydailyjava.bytebuddy.instrumentation.type.auxiliary;
 
 import com.blogspot.mydailyjava.bytebuddy.ClassVersion;
-import com.blogspot.mydailyjava.bytebuddy.method.MethodDescription;
-import com.blogspot.mydailyjava.bytebuddy.type.loading.ByteArrayClassLoader;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.method.MethodDescription;
+import com.blogspot.mydailyjava.bytebuddy.instrumentation.type.loading.ByteArrayClassLoader;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.mockito.asm.Opcodes;

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/bind/annotation/AllArgumentsAnnotationBinderTest.java
Patch:
@@ -82,8 +82,8 @@ public void testIllegalBinding() throws Exception {
         verifyNoMoreInteractions(assigner);
     }
 
-    @Test(expected = IllegalStateException.class)
-    public void testNegativeAnnotationValue() throws Exception {
+    @Test(expected = IllegalArgumentException.class)
+    public void testNonArrayTypeBinding() throws Exception {
         when(target.getParameterTypes()).thenReturn(new Class<?>[] {Object.class});
         AllArguments.Binder.INSTANCE.bind(annotation, 0, source, target, typeDescription, assigner);
     }

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/type/auxiliary/MethodCallProxyTest.java
Patch:
@@ -3,9 +3,11 @@
 import com.blogspot.mydailyjava.bytebuddy.ClassVersion;
 import com.blogspot.mydailyjava.bytebuddy.method.MethodDescription;
 import com.blogspot.mydailyjava.bytebuddy.type.loading.ByteArrayClassLoader;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.mockito.asm.Opcodes;
 
+@Ignore("Currently under development")
 public class MethodCallProxyTest {
 
     public static class Proxied {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/assign/Assigner.java
Patch:
@@ -2,5 +2,5 @@
 
 public interface Assigner {
 
-    Assignment assign(Class<?> superType, Class<?> subType, boolean considerRuntimeType);
+    Assignment assign(Class<?> sourceType, Class<?> targetType, boolean considerRuntimeType);
 }

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/assign/primitive/PrimitiveUnboxingDelegate.java
Patch:
@@ -134,7 +134,7 @@ public boolean isValid() {
 
     @Override
     public Size apply(MethodVisitor methodVisitor) {
-        methodVisitor.visitMethodInsn(Opcodes.INVOKEDYNAMIC, wrapperTypeName, unboxingMethodName, unboxingMethodDescriptor);
+        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, wrapperTypeName, unboxingMethodName, unboxingMethodDescriptor);
         return size;
     }
 }

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/bind/annotation/Argument.java
Patch:
@@ -40,7 +40,6 @@ public IdentifiedBinding<?> bind(Argument sourceParameterIndex,
             return makeBinding(source.getParameterTypes()[sourceParameterIndex.value()],
                     target.getParameterTypes()[targetParameterIndex],
                     sourceParameterIndex.value(),
-                    targetParameterIndex,
                     assigner,
                     RuntimeType.Verifier.check(target, targetParameterIndex),
                     source.isStatic() ? 0 : 1);
@@ -49,7 +48,6 @@ public IdentifiedBinding<?> bind(Argument sourceParameterIndex,
         private static IdentifiedBinding<?> makeBinding(Class<?> sourceType,
                                                         Class<?> targetType,
                                                         int sourceParameterIndex,
-                                                        int targetParameterIndex,
                                                         Assigner assigner,
                                                         boolean considerRuntimeType,
                                                         int sourceParameterOffset) {

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/assign/primitive/PrimitiveUnboxingDelegateTest.java
Patch:
@@ -72,7 +72,7 @@ public void testTrivialBoxing() throws Exception {
         Assignment.Size size = assignment.apply(methodVisitor);
         assertThat(size.getSizeImpact(), is(sizeChange));
         assertThat(size.getMaximalSize(), is(sizeChange));
-        verify(methodVisitor).visitMethodInsn(Opcodes.INVOKEDYNAMIC, Type.getInternalName(referenceType), unboxingMethodName, unboxingMethodDescriptor);
+        verify(methodVisitor).visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(referenceType), unboxingMethodName, unboxingMethodDescriptor);
         verifyNoMoreInteractions(methodVisitor);
         verifyZeroInteractions(chainedAssigner);
     }
@@ -84,7 +84,7 @@ public void testImplicitBoxing() throws Exception {
         Assignment.Size size = assignment.apply(methodVisitor);
         assertThat(size.getSizeImpact(), is(sizeChange));
         assertThat(size.getMaximalSize(), is(sizeChange));
-        verify(methodVisitor).visitMethodInsn(Opcodes.INVOKEDYNAMIC, Type.getInternalName(referenceType), unboxingMethodName, unboxingMethodDescriptor);
+        verify(methodVisitor).visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(referenceType), unboxingMethodName, unboxingMethodDescriptor);
         verifyNoMoreInteractions(methodVisitor);
         verify(chainedAssigner).assign(Object.class, referenceType, true);
         verifyNoMoreInteractions(chainedAssigner);

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/assign/primitive/PrimitiveUnboxingDelegateWideningTest.java
Patch:
@@ -74,7 +74,7 @@ public void testTrivialBoxing() throws Exception {
         Assignment.Size size = assignment.apply(methodVisitor);
         assertThat(size.getSizeImpact(), is(sizeChange));
         assertThat(size.getMaximalSize(), is(sizeChange));
-        verify(methodVisitor).visitMethodInsn(Opcodes.INVOKEDYNAMIC, Type.getInternalName(referenceType), unboxingMethodName, unboxingMethodDescriptor);
+        verify(methodVisitor).visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(referenceType), unboxingMethodName, unboxingMethodDescriptor);
         verify(methodVisitor).visitInsn(wideningOpcode);
         verifyNoMoreInteractions(methodVisitor);
         verifyZeroInteractions(chainedAssigner);

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/assign/reference/ReferenceTypeAwareAssignerTest.java
Patch:
@@ -32,7 +32,7 @@ public void testTrivialAssignment() throws Exception {
 
     @Test
     public void testUpcastAssignment() throws Exception {
-        Assignment assignment = ReferenceTypeAwareAssigner.INSTANCE.assign(Object.class, Integer.class, false);
+        Assignment assignment = ReferenceTypeAwareAssigner.INSTANCE.assign(Integer.class, Object.class, false);
         assertThat(assignment.isValid(), is(true));
         Assignment.Size size = assignment.apply(methodVisitor);
         assertThat(size.getSizeImpact(), is(0));
@@ -42,14 +42,14 @@ public void testUpcastAssignment() throws Exception {
 
     @Test(expected = IllegalStateException.class)
     public void testDowncastAssignmentWithoutRuntimeType() throws Exception {
-        Assignment assignment = ReferenceTypeAwareAssigner.INSTANCE.assign(Integer.class, Object.class, false);
+        Assignment assignment = ReferenceTypeAwareAssigner.INSTANCE.assign(Object.class, Integer.class, false);
         assertThat(assignment.isValid(), is(false));
         assignment.apply(methodVisitor);
     }
 
     @Test
     public void testDowncastAssignmentWithRuntimeType() throws Exception {
-        Assignment assignment = ReferenceTypeAwareAssigner.INSTANCE.assign(Integer.class, Object.class, true);
+        Assignment assignment = ReferenceTypeAwareAssigner.INSTANCE.assign(Object.class, Integer.class, true);
         assertThat(assignment.isValid(), is(true));
         Assignment.Size size = assignment.apply(methodVisitor);
         assertThat(size.getSizeImpact(), is(0));

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/bind/annotation/AnnotationDrivenBinder.java
Patch:
@@ -188,6 +188,7 @@ private Handler makeDelegate(ArgumentBinder<?> argumentBinder, Annotation annota
         }
     }
 
+    // TODO: Generic enough to extract from class into general package for possible reuse.
     private static class MethodDelegationBuilder {
 
         private static class Build implements BoundMethodDelegation {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/bind/annotation/AnnotationDrivenBinder.java
Patch:
@@ -279,7 +279,7 @@ public AnnotationDrivenBinder(List<ArgumentBinder<?>> argumentBinders,
     public BoundMethodDelegation bind(TypeDescription typeDescription, MethodDescription source, MethodDescription target) {
         Assignment returningAssignment = assigner.assign(target.getReturnType(),
                 source.getReturnType(),
-                target.isAnnotationPresent(RuntimeType.class));
+                RuntimeType.Verifier.check(target));
         if (!returningAssignment.isAssignable()) {
             return IllegalMethodDelegation.INSTANCE;
         }

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/assign/Assigner.java
Patch:
@@ -2,5 +2,5 @@
 
 public interface Assigner {
 
-    Assignment assign(Class<?> superType, Class subType, boolean considerRuntimeType);
+    Assignment assign(Class<?> superType, Class<?> subType, boolean considerRuntimeType);
 }

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/assign/primitive/PrimitiveTypeAwareAssigner.java
Patch:
@@ -12,7 +12,7 @@ public PrimitiveTypeAwareAssigner(Assigner nonPrimitiveAwareAssigner) {
     }
 
     @Override
-    public Assignment assign(Class<?> superType, Class subType, boolean considerRuntimeType) {
+    public Assignment assign(Class<?> superType, Class<?> subType, boolean considerRuntimeType) {
         if (superType.isPrimitive() && subType.isPrimitive()) {
             return PrimitiveWideningDelegate.forPrimitive(superType).widenTo(subType);
         } else if (superType.isPrimitive() /* && !subType.isPrimitive() */) {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/assign/primitive/VoidAwareAssigner.java
Patch:
@@ -51,7 +51,7 @@ public VoidAwareAssigner(Assigner nonVoidAwareAssigner, boolean returnDefaultVal
     }
 
     @Override
-    public Assignment assign(Class<?> superType, Class subType, boolean considerRuntimeType) {
+    public Assignment assign(Class<?> superType, Class<?> subType, boolean considerRuntimeType) {
         if (superType == void.class && subType == void.class) {
             return LegalTrivialAssignment.INSTANCE;
         } else if (superType == void.class /* && !(subType == void.class) */) {

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/StubMethod.java
Patch:
@@ -17,9 +17,9 @@ private static enum Appender implements ByteCodeAppender {
         @Override
         public Size apply(MethodVisitor methodVisitor, MethodDescription methodDescription) {
             return new Size(
-                    MethodReturn.returning(methodDescription.getReturnType())
-                            .returnAfter(DefaultValue.load(methodDescription.getReturnType()))
-                            .apply(methodVisitor).getMaximalSize(),
+                    DefaultValue.load(methodDescription.getReturnType()).apply(methodVisitor)
+                            .aggregate(MethodReturn.returning(methodDescription.getReturnType()).apply(methodVisitor))
+                            .getMaximalSize(),
                     TypeSize.sizeOf(Arrays.asList(methodDescription.getParameterTypes())) + 1);
         }
     }

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/assign/primitive/PrimitiveUnboxingDelegate.java
Patch:
@@ -115,7 +115,7 @@ public boolean isAssignable() {
         @Override
         public Size apply(MethodVisitor methodVisitor) {
             methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, wrapperTypeName, boxingMethodName, boxingMethodDescriptor);
-            return assignment.apply(methodVisitor).aggregateLeftFirst(typeSize.getSize() - 1);
+            return assignment.apply(methodVisitor).aggregate(typeSize.getSize() - 1, typeSize.getSize() - 1);
         }
     }
 
@@ -135,7 +135,7 @@ public boolean isAssignable() {
         @Override
         public Size apply(MethodVisitor methodVisitor) {
             methodVisitor.visitMethodInsn(Opcodes.INVOKEDYNAMIC, wrapperTypeName, unboxingMethodName, unboxingMethodDescriptor);
-            return wideningAssignment.apply(methodVisitor).aggregateRightFirst(typeSize.getSize() - 1);
+            return wideningAssignment.apply(methodVisitor).aggregate(typeSize.getSize() - 1, typeSize.getSize() - 1);
         }
     }
 
@@ -156,7 +156,7 @@ public boolean isAssignable() {
         public Size apply(MethodVisitor methodVisitor) {
             Size size = referenceTypeAdjustmentAssignment.apply(methodVisitor);
             methodVisitor.visitMethodInsn(Opcodes.INVOKEDYNAMIC, wrapperTypeName, unboxingMethodName, unboxingMethodDescriptor);
-            return size.aggregateLeftFirst(typeSize.getSize() - 1);
+            return size.aggregate(typeSize.getSize() - 1, typeSize.getSize() - 1);
         }
     }
 

File: src/test/java/com/blogspot/mydailyjava/bytebuddy/ByteBuddyTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.blogspot.mydailyjava.bytebuddy;
 
 import com.blogspot.mydailyjava.DebuggingWrapper;
-import com.blogspot.mydailyjava.bytebuddy.method.bytecode.StubMethod;
+import com.blogspot.mydailyjava.bytebuddy.method.bytecode.SuperClassDelegation;
 import com.blogspot.mydailyjava.bytebuddy.method.matcher.MethodMatchers;
 import org.junit.Test;
 
@@ -30,7 +30,7 @@ public void testSubclass() throws Exception {
         Object object = ByteBuddy.make()
                 .withAppendedClassVisitorWrapper(new DebuggingWrapper(System.out))
                 .subclass(Bar.class)
-                .method(MethodMatchers.returns(String.class)).intercept(StubMethod.INSTANCE)
+                .method(MethodMatchers.returns(String.class)).intercept(SuperClassDelegation.INSTANCE)
                 .make()
                 .load(getClass().getClassLoader())
                 .newInstance();

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/assign/Assigner.java
Patch:
@@ -1,6 +1,6 @@
 package com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign;
 
-public interface AssignmentExaminer {
+public interface Assigner {
 
     Assignment assign(String superTypeName, Class<?> subType, boolean considerRuntimeType);
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/assign/reference/AbstractRuntimeTypeAwareAssigner.java
Patch:
@@ -1,14 +1,14 @@
 package com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign.reference;
 
 import com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign.Assignment;
-import com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign.AssignmentExaminer;
+import com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign.Assigner;
 import com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign.IllegalAssignment;
 import com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign.LegalTrivialAssignment;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
 
-public abstract class AbstractRuntimeTypeAwareAssignmentExaminer implements AssignmentExaminer {
+public abstract class AbstractRuntimeTypeAwareAssigner implements Assigner {
 
     private static class DownCastAssignment implements Assignment {
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/assign/reference/ClassLoadingReferenceAssigner.java
Patch:
@@ -2,14 +2,14 @@
 
 import org.objectweb.asm.Type;
 
-public class ClassLoadingReferenceAssignmentExaminer extends AbstractRuntimeTypeAwareAssignmentExaminer {
+public class ClassLoadingReferenceAssigner extends AbstractRuntimeTypeAwareAssigner {
 
     private static final int REFERENCE_MEMORY_SIZE = 1;
     private static final int PRIMITIVE_TYPE_NAME_SIZE = 1;
 
     private final ClassLoader classLoader;
 
-    public ClassLoadingReferenceAssignmentExaminer(ClassLoader classLoader) {
+    public ClassLoadingReferenceAssigner(ClassLoader classLoader) {
         this.classLoader = classLoader;
     }
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/utility/MethodDescriptor.java
Patch:
@@ -94,7 +94,7 @@ public <T extends Visitor> T apply(T visitor) {
                     cursor++;
                     break;
                 default:
-                    throw new AssertionError();
+                    throw new IllegalStateException("Unknown type symbol found: " + argumentTypesInternalForm.charAt(cursor));
             }
         }
         return visitor;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/assign/AssignmentExaminer.java
Patch:
@@ -2,7 +2,7 @@
 
 public interface AssignmentExaminer {
 
-    Assignment assign(String superTypeName, Class<?> subType);
+    Assignment assign(String superTypeName, Class<?> subType, boolean considerRuntimeType);
 
-    Assignment assign(Class<?> superType, String subTypeName);
+    Assignment assign(Class<?> superType, String subTypeName, boolean considerRuntimeType);
 }

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/bind/annotation/AnnotationCallBinder.java
Patch:
@@ -37,7 +37,8 @@ public static interface Handler<T extends Annotation> {
 
         Class<T> getHandledType();
 
-        Assignment assign(Class<?> assignmentTarget, T argument, ClassContext classContext, MethodContext methodContext);
+        Assignment assign(Class<?> assignmentTarget, T argument, ClassContext classContext,
+                          MethodContext methodContext, boolean considerRuntimeType);
     }
 
     private final ClassContext classContext;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/matcher/MethodMatchers.java
Patch:
@@ -175,7 +175,7 @@ public ArgumentTypeMatcher(Class<?>[] argumentType) {
 
         @Override
         public boolean matches(ClassContext classContext, MethodContext methodContext) {
-            List<String> argumentTypes = methodContext.getArgumentType();
+            List<String> argumentTypes = methodContext.getArgumentTypes();
             if (this.argumentType.length != argumentTypes.size()) {
                 return false;
             }

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/ByteCodeBlockAppender.java
Patch:
@@ -6,7 +6,7 @@
 
 public interface ByteCodeBlockAppender {
 
-    static final class Size {
+    static class Size {
 
         private final int operandStackSize;
         private final int localVariableSize;

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/bytecode/assign/AssignmentExaminer.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.method.bytecode.assignment;
+package com.blogspot.mydailyjava.bytebuddy.method.bytecode.assign;
 
 public interface AssignmentExaminer {
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/context/ClassContext.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.extraction.context;
+package com.blogspot.mydailyjava.bytebuddy.context;
 
 public class ClassContext {
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/context/MethodContext.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.extraction.context;
+package com.blogspot.mydailyjava.bytebuddy.context;
 
 import org.objectweb.asm.Type;
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/matcher/MethodMatchers.java
Patch:
@@ -1,7 +1,7 @@
-package com.blogspot.mydailyjava.bytebuddy.interception.method.matching;
+package com.blogspot.mydailyjava.bytebuddy.method.matcher;
 
-import com.blogspot.mydailyjava.bytebuddy.extraction.context.ClassContext;
-import com.blogspot.mydailyjava.bytebuddy.extraction.context.MethodContext;
+import com.blogspot.mydailyjava.bytebuddy.context.ClassContext;
+import com.blogspot.mydailyjava.bytebuddy.context.MethodContext;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
 

File: src/main/java/com/blogspot/mydailyjava/bytebuddy/method/utility/MethodDescriptorIterator.java
Patch:
@@ -1,4 +1,4 @@
-package com.blogspot.mydailyjava.bytebuddy.utility;
+package com.blogspot.mydailyjava.bytebuddy.method.utility;
 
 public class MethodDescriptorIterator {
 

