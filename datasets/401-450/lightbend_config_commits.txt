File: config/src/main/java/com/typesafe/config/impl/OriginType.java
Patch:
@@ -5,5 +5,6 @@ enum OriginType {
     GENERIC,
     FILE,
     URL,
-    RESOURCE
+    RESOURCE,
+    ENV_VARIABLE
 }

File: config/src/main/java/com/typesafe/config/impl/PathParser.java
Patch:
@@ -258,8 +258,6 @@ private static boolean looksUnsafeForFastParser(String s) {
     private static Path fastPathBuild(Path tail, String s, int end) {
         // lastIndexOf takes last index it should look at, end - 1 not end
         int splitAt = s.lastIndexOf('.', end - 1);
-        ArrayList<Token> tokens = new ArrayList<Token>();
-        tokens.add(Tokens.newUnquotedText(null, s));
         // this works even if splitAt is -1; then we start the substring at 0
         Path withOneMoreElement = new Path(s.substring(splitAt + 1, end), tail);
         if (splitAt < 0) {

File: config/src/main/java/com/typesafe/config/impl/ConfigImpl.java
Patch:
@@ -371,7 +371,7 @@ public static void reloadEnvVariablesConfig() {
 
     private static AbstractConfigObject loadEnvVariablesOverrides() {
         Map<String, String> env = new HashMap(System.getenv());
-        Map<String, String> result = new HashMap(System.getenv());
+        Map<String, String> result = new HashMap();
 
         for (String key : env.keySet()) {
             if (key.startsWith(ENV_VAR_OVERRIDE_PREFIX)) {

File: config/src/main/java/com/typesafe/config/impl/ConfigImpl.java
Patch:
@@ -371,7 +371,7 @@ public static void reloadEnvVariablesConfig() {
 
     private static AbstractConfigObject loadEnvVariablesOverrides() {
         Map<String, String> env = new HashMap(System.getenv());
-        Map<String, String> result = new HashMap(System.getenv());
+        Map<String, String> result = new HashMap();
 
         for (String key : env.keySet()) {
             if (key.startsWith(ENV_VAR_OVERRIDE_PREFIX)) {

File: config/src/main/java/com/typesafe/config/impl/SimpleConfig.java
Patch:
@@ -285,7 +285,7 @@ public Object getAnyRef(String path) {
     public Long getBytes(String path) {
         BigInteger bytes = getBytesBigInteger(path);
         ConfigValue v = find(path, ConfigValueType.STRING);
-        return toLong(bytes,v.origin(), path);
+        return toLong(bytes, v.origin(), path);
     }
 
     private BigInteger getBytesBigInteger(String path) {

File: config/src/main/java/com/typesafe/config/impl/ConfigParser.java
Patch:
@@ -59,7 +59,7 @@ private AbstractConfigValue parseConcatenation(ConfigNodeConcatenation n) {
             if (flavor == ConfigSyntax.JSON)
                 throw new ConfigException.BugOrBroken("Found a concatenation node in JSON");
 
-            List<AbstractConfigValue> values = new ArrayList<AbstractConfigValue>();
+            List<AbstractConfigValue> values = new ArrayList<AbstractConfigValue>(n.children().size());
 
             for (AbstractConfigNode node : n.children()) {
                 AbstractConfigValue v = null;

File: config/src/main/java/com/typesafe/config/impl/SimpleConfigOrigin.java
Patch:
@@ -364,7 +364,7 @@ static ConfigOrigin mergeOrigins(Collection<? extends ConfigOrigin> stack) {
             Iterator<? extends ConfigOrigin> i = stack.iterator();
             return mergeTwo((SimpleConfigOrigin) i.next(), (SimpleConfigOrigin) i.next());
         } else {
-            List<SimpleConfigOrigin> remaining = new ArrayList<SimpleConfigOrigin>();
+            List<SimpleConfigOrigin> remaining = new ArrayList<SimpleConfigOrigin>(stack.size());
             for (ConfigOrigin o : stack) {
                 remaining.add((SimpleConfigOrigin) o);
             }

File: config/src/main/java/com/typesafe/config/impl/ConfigParser.java
Patch:
@@ -59,7 +59,7 @@ private AbstractConfigValue parseConcatenation(ConfigNodeConcatenation n) {
             if (flavor == ConfigSyntax.JSON)
                 throw new ConfigException.BugOrBroken("Found a concatenation node in JSON");
 
-            List<AbstractConfigValue> values = new ArrayList<AbstractConfigValue>();
+            List<AbstractConfigValue> values = new ArrayList<AbstractConfigValue>(n.children().size());
 
             for (AbstractConfigNode node : n.children()) {
                 AbstractConfigValue v = null;

File: config/src/main/java/com/typesafe/config/impl/SimpleConfigOrigin.java
Patch:
@@ -364,7 +364,7 @@ static ConfigOrigin mergeOrigins(Collection<? extends ConfigOrigin> stack) {
             Iterator<? extends ConfigOrigin> i = stack.iterator();
             return mergeTwo((SimpleConfigOrigin) i.next(), (SimpleConfigOrigin) i.next());
         } else {
-            List<SimpleConfigOrigin> remaining = new ArrayList<SimpleConfigOrigin>();
+            List<SimpleConfigOrigin> remaining = new ArrayList<SimpleConfigOrigin>(stack.size());
             for (ConfigOrigin o : stack) {
                 remaining.add((SimpleConfigOrigin) o);
             }

File: config/src/main/java/com/typesafe/config/impl/ConfigBeanImpl.java
Patch:
@@ -285,7 +285,7 @@ private static boolean hasAtLeastOneBeanProperty(Class<?> clazz) {
 
     private static boolean isOptionalProperty(Class beanClass, PropertyDescriptor beanProp) {
         Field field = getField(beanClass, beanProp.getName());
-        return field != null && (field.getAnnotationsByType(Optional.class).length > 0);
+        return field != null ? field.getAnnotationsByType(Optional.class).length > 0 : beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0;
     }
 
     private static Field getField(Class beanClass, String fieldName) {

File: config/src/main/java/com/typesafe/config/ConfigFactory.java
Patch:
@@ -28,7 +28,7 @@
  * from a resource and nothing else.
  *
  * <p> You can find an example app and library <a
- * href="https://github.com/typesafehub/config/tree/master/examples">on
+ * href="https://github.com/lightbend/config/tree/master/examples">on
  * GitHub</a>.  Also be sure to read the <a
  * href="package-summary.html#package_description">package
  * overview</a> which describes the big picture as shown in those
@@ -570,7 +570,7 @@ public static Config systemEnvironment() {
     /**
      * Converts a Java {@link java.util.Properties} object to a
      * {@link ConfigObject} using the rules documented in the <a
-     * href="https://github.com/typesafehub/config/blob/master/HOCON.md">HOCON
+     * href="https://github.com/lightbend/config/blob/master/HOCON.md">HOCON
      * spec</a>. The keys in the <code>Properties</code> object are split on the
      * period character '.' and treated as paths. The values will all end up as
      * string values. If you have both "a=foo" and "a.b=bar" in your properties

File: config/src/main/java/com/typesafe/config/ConfigMergeable.java
Patch:
@@ -27,7 +27,7 @@ public interface ConfigMergeable {
      * 
      * <p>
      * The semantics of merging are described in the <a
-     * href="https://github.com/typesafehub/config/blob/master/HOCON.md">spec
+     * href="https://github.com/lightbend/config/blob/master/HOCON.md">spec
      * for HOCON</a>. Merging typically occurs when either the same object is
      * created twice in the same file, or two config files are both loaded. For
      * example:

File: config/src/main/java/com/typesafe/config/ConfigResolveOptions.java
Patch:
@@ -6,7 +6,7 @@
 /**
  * A set of options related to resolving substitutions. Substitutions use the
  * <code>${foo.bar}</code> syntax and are documented in the <a
- * href="https://github.com/typesafehub/config/blob/master/HOCON.md">HOCON</a>
+ * href="https://github.com/lightbend/config/blob/master/HOCON.md">HOCON</a>
  * spec.
  * <p>
  * Typically this class would be used with the method

File: config/src/main/java/com/typesafe/config/ConfigSyntax.java
Patch:
@@ -5,7 +5,7 @@
 
 /**
  * The syntax of a character stream (<a href="http://json.org">JSON</a>, <a
- * href="https://github.com/typesafehub/config/blob/master/HOCON.md">HOCON</a>
+ * href="https://github.com/lightbend/config/blob/master/HOCON.md">HOCON</a>
  * aka ".conf", or <a href=
  * "http://download.oracle.com/javase/7/docs/api/java/util/Properties.html#load%28java.io.Reader%29"
  * >Java properties</a>).
@@ -21,7 +21,7 @@ public enum ConfigSyntax {
     JSON,
     /**
      * The JSON-superset <a
-     * href="https://github.com/typesafehub/config/blob/master/HOCON.md"
+     * href="https://github.com/lightbend/config/blob/master/HOCON.md"
      * >HOCON</a> format. Associated with the <code>.conf</code> file extension
      * and <code>application/hocon</code> Content-Type.
      */

File: config/src/main/java/com/typesafe/config/impl/ConfigParser.java
Patch:
@@ -192,7 +192,7 @@ private void parseInclude(Map<String, AbstractConfigValue> values, ConfigNodeInc
 
             // we really should make this work, but for now throwing an
             // exception is better than producing an incorrect result.
-            // See https://github.com/typesafehub/config/issues/160
+            // See https://github.com/lightbend/config/issues/160
             if (arrayCount > 0 && obj.resolveStatus() != ResolveStatus.RESOLVED)
                 throw parseError("Due to current limitations of the config parser, when an include statement is nested inside a list value, "
                         + "${} substitutions inside the included file cannot be resolved correctly. Either move the include outside of the list value or "
@@ -247,7 +247,7 @@ private AbstractConfigObject parseObject(ConfigNodeObject n) {
                         // we really should make this work, but for now throwing
                         // an exception is better than producing an incorrect
                         // result. See
-                        // https://github.com/typesafehub/config/issues/160
+                        // https://github.com/lightbend/config/issues/160
                         if (arrayCount > 0)
                             throw parseError("Due to current limitations of the config parser, += does not work nested inside a list. "
                                     + "+= expands to a ${} substitution and the path in ${} cannot currently refer to list elements. "

File: config/src/main/java/com/typesafe/config/parser/ConfigNode.java
Patch:
@@ -10,8 +10,8 @@
  * Note: at present there is no way to obtain an instance of this interface, so
  * please ignore it. A future release will make syntax tree nodes available in
  * the public API. If you are interested in working on it, please see: <a
- * href="https://github.com/typesafehub/config/issues/300"
- * >https://github.com/typesafehub/config/issues/300</a>
+ * href="https://github.com/lightbend/config/issues/300"
+ * >https://github.com/lightbend/config/issues/300</a>
  *
  * <p>
  * Because this object is immutable, it is safe to use from multiple threads and

File: config/src/main/java/com/typesafe/config/impl/ConfigBeanImpl.java
Patch:
@@ -277,7 +277,7 @@ private static boolean hasAtLeastOneBeanProperty(Class<?> clazz) {
 
     private static boolean isOptionalProperty(Class beanClass, PropertyDescriptor beanProp) {
         Field field = getField(beanClass, beanProp.getName());
-        return (field.getAnnotationsByType(Optional.class).length > 0);
+        return field != null && (field.getAnnotationsByType(Optional.class).length > 0);
     }
 
     private static Field getField(Class beanClass, String fieldName) {

File: config/src/main/java/com/typesafe/config/impl/ConfigBeanImpl.java
Patch:
@@ -69,7 +69,9 @@ public static <T> T createInternal(Config config, Class<T> clazz) {
         try {
             List<PropertyDescriptor> beanProps = new ArrayList<PropertyDescriptor>();
             for (PropertyDescriptor beanProp : beanInfo.getPropertyDescriptors()) {
-                if (beanProp.getReadMethod() == null || beanProp.getWriteMethod() == null) {
+                if (beanProp.getReadMethod() == null
+                        || beanProp.getWriteMethod() == null
+                        || getField(clazz, beanProp.getName()) == null) {
                     continue;
                 }
                 beanProps.add(beanProp);

File: config/src/main/java/com/typesafe/config/ConfigFactory.java
Patch:
@@ -1056,7 +1056,7 @@ private static ConfigLoadingStrategy getConfigLoadingStrategy() {
             try {
                 return ConfigLoadingStrategy.class.cast(Class.forName(className).newInstance());
             } catch (Throwable e) {
-                throw new IllegalArgumentException("Failed to load strategy: " + className, e);
+                throw new ConfigException.BugOrBroken("Failed to load strategy: " + className, e);
             }
         } else {
             return new DefaultConfigLoadingStrategy();

File: config/src/main/java/com/typesafe/config/impl/SimpleConfig.java
Patch:
@@ -610,7 +610,7 @@ public static long parseDuration(String input,
             // if the string is purely digits, parse as an integer to avoid
             // possible precision loss;
             // otherwise as a double.
-            if (numberString.matches("[0-9]+")) {
+            if (numberString.matches("[+-]?[0-9]+")) {
                 return units.toNanos(Long.parseLong(numberString));
             } else {
                 long nanosInUnit = units.toNanos(1);

File: config/src/main/java/com/typesafe/config/impl/Tokenizer.java
Patch:
@@ -295,7 +295,7 @@ private Token pullComment(int firstChar) {
         }
 
         // chars JSON allows a number to start with
-        static final String firstNumberChars = "0123456789-.";
+        static final String firstNumberChars = "0123456789-";
         // chars JSON allows to be part of a number
         static final String numberChars = "0123456789eE+-.";
         // chars that stop an unquoted string
@@ -350,7 +350,7 @@ else if (s.equals("null"))
         private Token pullNumber(int firstChar) throws ProblemException {
             StringBuilder sb = new StringBuilder();
             sb.appendCodePoint(firstChar);
-            boolean containedDecimalOrE = firstChar == '.';
+            boolean containedDecimalOrE = false;
             int c = nextCharRaw();
             while (c != -1 && numberChars.indexOf(c) >= 0) {
                 if (c == '.' || c == 'e' || c == 'E')

File: config/src/main/java/com/typesafe/config/impl/Tokenizer.java
Patch:
@@ -295,7 +295,7 @@ private Token pullComment(int firstChar) {
         }
 
         // chars JSON allows a number to start with
-        static final String firstNumberChars = "0123456789-";
+        static final String firstNumberChars = "0123456789-.";
         // chars JSON allows to be part of a number
         static final String numberChars = "0123456789eE+-.";
         // chars that stop an unquoted string
@@ -350,7 +350,7 @@ else if (s.equals("null"))
         private Token pullNumber(int firstChar) throws ProblemException {
             StringBuilder sb = new StringBuilder();
             sb.appendCodePoint(firstChar);
-            boolean containedDecimalOrE = false;
+            boolean containedDecimalOrE = firstChar == '.';
             int c = nextCharRaw();
             while (c != -1 && numberChars.indexOf(c) >= 0) {
                 if (c == '.' || c == 'e' || c == 'E')

File: config/src/main/java/com/typesafe/config/impl/Tokenizer.java
Patch:
@@ -38,7 +38,7 @@ else if (codepoint == '\t')
             return "tab";
         else if (codepoint == -1)
             return "end of file";
-        else if (Character.isISOControl(codepoint))
+        else if (ConfigImplUtil.isC0Control(codepoint))
             return String.format("control character 0x%x", codepoint);
         else
             return String.format("%c", codepoint);
@@ -498,7 +498,7 @@ private Token pullQuotedString() throws ProblemException {
                 } else if (c == '"') {
                     sbOrig.appendCodePoint(c);
                     break;
-                } else if (Character.isISOControl(c)) {
+                } else if (ConfigImplUtil.isC0Control(c)) {
                     throw problem(asString(c), "JSON does not allow unescaped " + asString(c)
                             + " in quoted strings, use a backslash escape");
                 } else {

File: config/src/main/java/com/typesafe/config/impl/ConfigNodeObject.java
Patch:
@@ -170,7 +170,7 @@ protected ConfigNodeObject addValueOnPath(ConfigNodePath desiredPath, AbstractCo
 
         // If the value we're inserting is a complex value, we'll need to indent it for insertion
         AbstractConfigNodeValue indentedValue;
-        if (value instanceof ConfigNodeComplexValue) {
+        if (value instanceof ConfigNodeComplexValue && !indentation.isEmpty()) {
             indentedValue = ((ConfigNodeComplexValue) value).indentText(indentation.get(indentation.size() - 1));
         } else {
             indentedValue = value;

File: config/src/main/java/com/typesafe/config/impl/ConfigNodeObject.java
Patch:
@@ -170,7 +170,7 @@ protected ConfigNodeObject addValueOnPath(ConfigNodePath desiredPath, AbstractCo
 
         // If the value we're inserting is a complex value, we'll need to indent it for insertion
         AbstractConfigNodeValue indentedValue;
-        if (value instanceof ConfigNodeComplexValue) {
+        if (value instanceof ConfigNodeComplexValue && !indentation.isEmpty()) {
             indentedValue = ((ConfigNodeComplexValue) value).indentText(indentation.get(indentation.size() - 1));
         } else {
             indentedValue = value;

File: config/src/main/java/com/typesafe/config/impl/ConfigDocumentParser.java
Patch:
@@ -629,7 +629,7 @@ AbstractConfigNodeValue parseSingleValue() {
 
             t = nextToken();
             if (Tokens.isIgnoredWhitespace(t) || Tokens.isNewline(t) || isUnquotedWhitespace(t) || Tokens.isComment(t)) {
-                throw parseError("The value from setValue cannot have leading or trailing newlines, whitespace, or comments");
+                throw parseError("The value from withValueText cannot have leading or trailing newlines, whitespace, or comments");
             }
             if (t == Tokens.END) {
                 throw parseError("Empty value");
@@ -640,7 +640,7 @@ AbstractConfigNodeValue parseSingleValue() {
                 if (t == Tokens.END) {
                     return node;
                 } else {
-                    throw parseError("Parsing JSON and the value set in setValue was either a concatenation or " +
+                    throw parseError("Parsing JSON and the value set in withValueText was either a concatenation or " +
                                         "had trailing whitespace, newlines, or comments");
                 }
             } else {
@@ -651,7 +651,7 @@ AbstractConfigNodeValue parseSingleValue() {
                 if (t == Tokens.END) {
                     return node;
                 } else {
-                    throw parseError("The value from setValue cannot have leading or trailing newlines, whitespace, or comments");
+                    throw parseError("The value from withValueText cannot have leading or trailing newlines, whitespace, or comments");
                 }
             }
         }

File: config/src/main/java/com/typesafe/config/impl/SimpleConfigDocument.java
Patch:
@@ -27,7 +27,7 @@ public ConfigDocument setValue(String path, String newValue) {
     }
 
     public ConfigDocument setValue(String path, ConfigValue newValue) {
-        return setValue(path, newValue.render());
+        return setValue(path, newValue.render().trim());
     }
 
     public ConfigDocument removeValue(String path) {

File: config/src/main/java/com/typesafe/config/impl/SimpleConfigDocument.java
Patch:
@@ -27,7 +27,7 @@ public ConfigDocument setValue(String path, String newValue) {
     }
 
     public ConfigDocument setValue(String path, ConfigValue newValue) {
-        return setValue(path, newValue.render());
+        return setValue(path, newValue.render().trim());
     }
 
     public ConfigDocument removeValue(String path) {

File: config/src/main/java/com/typesafe/config/impl/ConfigBeanImpl.java
Patch:
@@ -12,7 +12,6 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.TimeUnit;
 import java.time.Duration;
 
 import com.typesafe.config.Config;
@@ -79,7 +78,7 @@ public static <T> T createInternal(Config config, Class<T> clazz) {
             List<ConfigException.ValidationProblem> problems = new ArrayList<ConfigException.ValidationProblem>();
             for (PropertyDescriptor beanProp : beanProps) {
                 Method setter = beanProp.getWriteMethod();
-                Class parameterClass = setter.getParameterTypes()[0];
+                Class<?> parameterClass = setter.getParameterTypes()[0];
 
                 ConfigValueType expectedType = getValueTypeOrNull(parameterClass);
                 if (expectedType != null) {
@@ -127,7 +126,8 @@ public static <T> T createInternal(Config config, Class<T> clazz) {
     // setting. So, instead, we only support a limited number of
     // types plus you can always use Object, ConfigValue, Config,
     // ConfigObject, etc.  as an escape hatch.
-    private static Object getValue(Class beanClass, Type parameterType, Class<?> parameterClass, Config config, String configPropName) {
+    private static Object getValue(Class<?> beanClass, Type parameterType, Class<?> parameterClass, Config config,
+            String configPropName) {
         if (parameterClass == Boolean.class || parameterClass == boolean.class) {
             return config.getBoolean(configPropName);
         } else if (parameterClass == Integer.class || parameterClass == int.class) {

File: config/src/main/java/com/typesafe/config/impl/ConfigDocumentParser.java
Patch:
@@ -336,7 +336,6 @@ private ConfigNodeInclude parseInclude(ArrayList<AbstractConfigNode> children) {
                 t = nextTokenCollectingWhitespace(children);
 
                 // quoted string
-                String name;
                 if (!Tokens.isValueWithType(t, ConfigValueType.STRING)) {
                     throw parseError("expecting a quoted string inside file(), classpath(), or url(), rather than: "
                             + t);
@@ -399,7 +398,6 @@ private ConfigNodeComplexValue parseObject(boolean hadOpenCurly) {
                     Token afterKey = nextTokenCollectingWhitespace(keyValueNodes);
                     boolean insideEquals = false;
 
-                    Token valueToken;
                     AbstractConfigNodeValue nextValue;
                     if (flavor == ConfigSyntax.CONF && afterKey == Tokens.OPEN_CURLY) {
                         // can omit the ':' or '=' before an object value

File: config/src/main/java/com/typesafe/config/impl/ConfigNodeComplexValue.java
Patch:
@@ -9,7 +9,7 @@ abstract class ConfigNodeComplexValue extends AbstractConfigNodeValue {
     final protected ArrayList<AbstractConfigNode> children;
 
     ConfigNodeComplexValue(Collection<AbstractConfigNode> children) {
-        this.children = new ArrayList(children);
+        this.children = new ArrayList<AbstractConfigNode>(children);
     }
 
     final public Collection<AbstractConfigNode> children() {
@@ -18,7 +18,7 @@ final public Collection<AbstractConfigNode> children() {
 
     @Override
     protected Collection<Token> tokens() {
-        ArrayList<Token> tokens = new ArrayList();
+        ArrayList<Token> tokens = new ArrayList<Token>();
         for (AbstractConfigNode child : children) {
             tokens.addAll(child.tokens());
         }

File: config/src/main/java/com/typesafe/config/impl/ConfigNodeInclude.java
Patch:
@@ -18,7 +18,7 @@ final public Collection<AbstractConfigNode> children() {
 
     @Override
     protected Collection<Token> tokens() {
-        ArrayList<Token> tokens = new ArrayList();
+        ArrayList<Token> tokens = new ArrayList<Token>();
         for (AbstractConfigNode child : children) {
             tokens.addAll(child.tokens());
         }

File: config/src/main/java/com/typesafe/config/impl/PathBuilder.java
Patch:
@@ -3,8 +3,6 @@
  */
 package com.typesafe.config.impl;
 
-import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Stack;
 
 import com.typesafe.config.ConfigException;

File: config/src/main/java/com/typesafe/config/impl/SimpleConfigDocument.java
Patch:
@@ -1,7 +1,6 @@
 package com.typesafe.config.impl;
 
 import com.typesafe.config.parser.ConfigDocument;
-import com.typesafe.config.ConfigException;
 import com.typesafe.config.ConfigParseOptions;
 import com.typesafe.config.ConfigValue;
 

File: config/src/main/java/com/typesafe/config/impl/Tokens.java
Patch:
@@ -131,8 +131,6 @@ static private class IgnoredWhitespace extends Token {
             this.value = s;
         }
 
-        String value() { return value; }
-
         @Override
         public String toString() { return "'" + value + "' (WHITESPACE)"; }
 

File: config/src/main/java/com/typesafe/config/parser/ConfigDocument.java
Patch:
@@ -1,6 +1,5 @@
 package com.typesafe.config.parser;
 
-import com.typesafe.config.ConfigParseOptions;
 import com.typesafe.config.ConfigValue;
 
 /**

File: config/src/main/java/com/typesafe/config/parser/ConfigDocumentFactory.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.typesafe.config.ConfigParseOptions;
 
-import com.typesafe.config.impl.ConfigImpl;
 import com.typesafe.config.impl.Parseable;
 
 import java.io.File;

File: config/src/main/java/com/typesafe/config/impl/AbstractConfigNode.java
Patch:
@@ -3,7 +3,7 @@
  */
 package com.typesafe.config.impl;
 
-import com.typesafe.config.ConfigNode;
+import com.typesafe.config.parser.ConfigNode;
 import java.util.Collection;
 
 abstract class AbstractConfigNode implements ConfigNode {

File: config/src/main/java/com/typesafe/config/impl/Parseable.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.*;
 
 import com.typesafe.config.*;
+import com.typesafe.config.parser.*;
 
 /**
  * Internal implementation detail, not ABI stable, do not touch.

File: config/src/main/java/com/typesafe/config/impl/SimpleConfigDocument.java
Patch:
@@ -1,6 +1,6 @@
 package com.typesafe.config.impl;
 
-import com.typesafe.config.ConfigDocument;
+import com.typesafe.config.parser.ConfigDocument;
 import com.typesafe.config.ConfigException;
 import com.typesafe.config.ConfigParseOptions;
 import com.typesafe.config.ConfigValue;

File: config/src/main/java/com/typesafe/config/parser/ConfigNode.java
Patch:
@@ -1,11 +1,10 @@
 /**
  *   Copyright (C) 2015 Typesafe Inc. <http://typesafe.com>
  */
-package com.typesafe.config;
+package com.typesafe.config.parser;
 
 /**
- * An immutable node that makes up the ConfigDocument AST, and which can be
- * used to reproduce part or all of the original text of an input.
+ * A node in the syntax tree for a HOCON or JSON document.
  *
  * <p>
  * Because this object is immutable, it is safe to use from multiple threads and

File: config/src/main/java/com/typesafe/config/ConfigDocument.java
Patch:
@@ -21,7 +21,8 @@ public interface ConfigDocument {
      * Returns a new ConfigDocument that is a copy of the current ConfigDocument,
      * but with the desired value set at the desired path. If the path exists, it will
      * remove all duplicates before the final occurrence of the path, and replace the value
-     * at the final occurrence of the path. If the path does not exist, it will be added.
+     * at the final occurrence of the path. If the path does not exist, it will be added. If
+     * the document has an array as the root value, an exception will be thrown.
      *
      * @param path the path at which to set the desired value
      * @param newValue the value to set at the desired path, represented as a string. This

File: config/src/main/java/com/typesafe/config/impl/ConfigNodeSimpleValue.java
Patch:
@@ -3,6 +3,8 @@
  */
 package com.typesafe.config.impl;
 
+import com.typesafe.config.ConfigException;
+
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
@@ -32,6 +34,6 @@ else if (Tokens.isSubstitution(token)) {
 
             return new ConfigReference(token.origin(), new SubstitutionExpression(path, optional));
         }
-        return null;
+        throw new ConfigException.BugOrBroken("ConfigNodeSimpleValue did not contain a valid value token");
     }
 }

File: config/src/main/java/com/typesafe/config/impl/SimpleConfigDocument.java
Patch:
@@ -21,7 +21,7 @@ public ConfigDocument setValue(String path, String newValue) {
         SimpleConfigOrigin origin = SimpleConfigOrigin.newSimple("single value parsing");
         StringReader reader = new StringReader(newValue);
         Iterator<Token> tokens = Tokenizer.tokenize(origin, reader, parseOptions.getSyntax());
-        AbstractConfigNodeValue parsedValue = ConfigDocumentParser.parseValue(tokens, parseOptions);
+        AbstractConfigNodeValue parsedValue = ConfigDocumentParser.parseValue(tokens, origin, parseOptions);
         reader.close();
 
         return new SimpleConfigDocument(configNodeTree.setValue(path, parsedValue, parseOptions.getSyntax()), parseOptions);

File: config/src/main/java/com/typesafe/config/impl/ConfigDocumentParser.java
Patch:
@@ -405,7 +405,7 @@ private ConfigNodeComplexValue parseObject(boolean hadOpenCurly) {
             boolean lastInsideEquals = false;
             ArrayList<AbstractConfigNode> objectNodes = new ArrayList<AbstractConfigNode>();
             ArrayList<AbstractConfigNode> keyValueNodes;
-            HashMap<String, Boolean> keys  = new HashMap();
+            HashMap<String, Boolean> keys  = new HashMap<String, Boolean>();
             if (hadOpenCurly)
                 objectNodes.add(new ConfigNodeSingleToken(Tokens.OPEN_CURLY));
 
@@ -653,7 +653,7 @@ ConfigNodeRoot parse() {
             if (t == Tokens.END) {
                 if (missingCurly) {
                     // If there were no braces, the entire document should be treated as a single object
-                    return new ConfigNodeRoot(Collections.singletonList(new ConfigNodeObject(children)));
+                    return new ConfigNodeRoot(Collections.singletonList((AbstractConfigNode)new ConfigNodeObject(children)));
                 } else {
                     return new ConfigNodeRoot(children);
                 }
@@ -691,7 +691,7 @@ AbstractConfigNodeValue parseSingleValue() {
                 }
             } else {
                 putBack(t);
-                ArrayList<AbstractConfigNode> nodes = new ArrayList();
+                ArrayList<AbstractConfigNode> nodes = new ArrayList<AbstractConfigNode>();
                 AbstractConfigNodeValue node = consolidateValues(nodes);
                 t = nextToken();
                 if (t == Tokens.END) {

File: config/src/main/java/com/typesafe/config/impl/ConfigNodeField.java
Patch:
@@ -13,20 +13,20 @@ final class ConfigNodeField extends AbstractConfigNode {
     final private ArrayList<AbstractConfigNode> children;
 
     public ConfigNodeField(Collection<AbstractConfigNode> children) {
-        this.children = new ArrayList(children);
+        this.children = new ArrayList<AbstractConfigNode>(children);
     }
 
     @Override
     protected Collection<Token> tokens() {
-        ArrayList<Token> tokens = new ArrayList();
+        ArrayList<Token> tokens = new ArrayList<Token>();
         for (AbstractConfigNode child : children) {
             tokens.addAll(child.tokens());
         }
         return tokens;
     }
 
     public ConfigNodeField replaceValue(AbstractConfigNodeValue newValue) {
-        ArrayList<AbstractConfigNode> childrenCopy = new ArrayList(children);
+        ArrayList<AbstractConfigNode> childrenCopy = new ArrayList<AbstractConfigNode>(children);
         for (int i = 0; i < childrenCopy.size(); i++) {
             if (childrenCopy.get(i) instanceof AbstractConfigNodeValue) {
                 childrenCopy.set(i, newValue);

File: config/src/main/java/com/typesafe/config/impl/ConfigNodeRoot.java
Patch:
@@ -21,7 +21,7 @@ protected ConfigNodeComplexValue value() {
     }
 
     protected ConfigNodeRoot setValue(String desiredPath, AbstractConfigNodeValue value, ConfigSyntax flavor) {
-        ArrayList<AbstractConfigNode> childrenCopy = new ArrayList(children);
+        ArrayList<AbstractConfigNode> childrenCopy = new ArrayList<AbstractConfigNode>(children);
         for (int i = 0; i < childrenCopy.size(); i++) {
             AbstractConfigNode node = childrenCopy.get(i);
             if (node instanceof ConfigNodeComplexValue) {

File: config/src/main/java/com/typesafe/config/impl/Parseable.java
Patch:
@@ -211,7 +211,9 @@ final private ConfigDocument parseDocument(ConfigOrigin origin,
             return rawParseDocument(origin, finalOptions);
         } catch (IOException e) {
             if (finalOptions.getAllowMissing()) {
-                return new SimpleConfigDocument(new ConfigNodeRoot(Collections.singletonList(new ConfigNodeObject(new ArrayList<AbstractConfigNode>()))), finalOptions);
+                ArrayList<AbstractConfigNode> children = new ArrayList<AbstractConfigNode>();
+                children.add(new ConfigNodeObject(new ArrayList<AbstractConfigNode>()));
+                return new SimpleConfigDocument(new ConfigNodeRoot(children), finalOptions);
             } else {
                 trace("exception loading " + origin.description() + ": " + e.getClass().getName()
                         + ": " + e.getMessage());

File: config/src/main/java/com/typesafe/config/impl/ConfigDocumentParser.java
Patch:
@@ -104,7 +104,7 @@ private boolean checkElementSeparator(Collection<AbstractConfigNode> nodes) {
                 boolean sawSeparatorOrNewline = false;
                 Token t = nextToken();
                 while (true) {
-                    if (Tokens.isIgnoredWhitespace(t) || isUnquotedWhitespace(t)) {
+                    if (Tokens.isIgnoredWhitespace(t) || isUnquotedWhitespace(t) || Tokens.isComment(t)) {
                         //do nothing
                     } else if (Tokens.isNewline(t)) {
                         sawSeparatorOrNewline = true;

File: config/src/main/java/com/typesafe/config/Config.java
Patch:
@@ -427,7 +427,7 @@ public interface Config extends ConfigMergeable {
      * <p>
      * To handle all three cases (unset, null, and a non-null value)
      * the code might look like:
-     * <code><pre>
+     * <pre><code>
      * if (config.hasPathOrNull(path)) {
      *     if (config.getIsNull(path)) {
      *        // handle null setting
@@ -437,7 +437,7 @@ public interface Config extends ConfigMergeable {
      * } else {
      *     // handle entirely unset path
      * }
-     * </pre></code>
+     * </code></pre>
      *
      * <p> However, the usual thing is to allow entirely unset
      * paths to be a bug that throws an exception (because you set

File: config/src/main/java/com/typesafe/config/impl/ConfigDocumentParser.java
Patch:
@@ -56,7 +56,7 @@ private Token popToken() {
         private Token nextToken() {
             Token t = popToken();
             if (flavor == ConfigSyntax.JSON) {
-                if (Tokens.isUnquotedText(t)) {
+                if (Tokens.isUnquotedText(t) && !isUnquotedWhitespace(t)) {
                     throw parseError(addKeyName("Token not allowed in valid JSON: '"
                             + Tokens.getUnquotedText(t) + "'"));
                 } else if (Tokens.isSubstitution(t)) {
@@ -91,6 +91,7 @@ private boolean checkElementSeparator(Collection<AbstractConfigNode> nodes) {
             if (flavor == ConfigSyntax.JSON) {
                 Token t = nextTokenIgnoringWhitespace(nodes);
                 if (t == Tokens.COMMA) {
+                    nodes.add(new ConfigNodeSingleToken(t));
                     return true;
                 } else {
                     putBack(t);

File: config/src/main/java/com/typesafe/config/impl/DefaultTransformer.java
Patch:
@@ -110,9 +110,7 @@ static AbstractConfigValue transform(AbstractConfigValue value,
                             @Override
                             public int compare(Map.Entry<Integer, AbstractConfigValue> a,
                                     Map.Entry<Integer, AbstractConfigValue> b) {
-                                // Integer.compare was added in 1.7 so not using
-                                // it here yet
-                                return Integer.valueOf(a.getKey()).compareTo(b.getKey());
+                                return Integer.compare(a.getKey(), b.getKey());
                             }
                         });
                 // drop the indices (we allow gaps in the indices, for better or

File: config/src/main/java/com/typesafe/config/ConfigException.java
Patch:
@@ -394,6 +394,7 @@ private static String makeMessage(Iterable<ValidationProblem> problems) {
 
     /**
      * Some problem with a JavaBean we are trying to initialize.
+     * @since 1.3.0
      */
     public static class BadBean extends BugOrBroken {
         private static final long serialVersionUID = 1L;

File: config/src/main/java/com/typesafe/config/ConfigFactory.java
Patch:
@@ -639,7 +639,7 @@ public static Config parseProperties(Properties properties,
     }
 
     /**
-     * Like {@link parseProperties(Properties, ConfigParseOptions)} but uses default
+     * Like {@link #parseProperties(Properties, ConfigParseOptions)} but uses default
      * parse options.
      * @param properties
      *            a Java Properties object

File: config/src/main/java/com/typesafe/config/ConfigObject.java
Patch:
@@ -129,7 +129,7 @@ public interface ConfigObject extends ConfigValue, Map<String, ConfigValue> {
      * @return the new instance with the new map entry
      */
     ConfigObject withValue(String key, ConfigValue value);
-    
+
     @Override
     ConfigObject withOrigin(ConfigOrigin origin);
 }

File: config/src/main/java/com/typesafe/config/impl/Parseable.java
Patch:
@@ -594,8 +594,10 @@ ConfigParseable relativeTo(String filename) {
             if (sibling == null)
                 return null;
             if (sibling.exists()) {
+                trace(sibling + " exists, so loading it as a file");
                 return newFile(sibling, options().setOriginDescription(null));
             } else {
+                trace(sibling + " does not exist, so trying it as a classpath resource");
                 return super.relativeTo(filename);
             }
         }

File: config/src/main/java/com/typesafe/config/impl/SimpleIncludeContext.java
Patch:
@@ -24,6 +24,8 @@ SimpleIncludeContext withParseable(Parseable parseable) {
 
     @Override
     public ConfigParseable relativeTo(String filename) {
+        if (ConfigImpl.traceLoadsEnabled())
+            ConfigImpl.trace("Looking for '" + filename + "' relative to " + parseable);
         if (parseable != null)
             return parseable.relativeTo(filename);
         else

File: config/src/main/java/com/typesafe/config/ConfigIncluder.java
Patch:
@@ -23,7 +23,7 @@ public interface ConfigIncluder {
      * the fallback is the same one you already have. The same fallback may be
      * added repeatedly.
      *
-     * @param fallback
+     * @param fallback the previous includer for chaining
      * @return a new includer
      */
     ConfigIncluder withFallback(ConfigIncluder fallback);

File: config/src/main/java/com/typesafe/config/ConfigMemorySize.java
Patch:
@@ -23,6 +23,8 @@ private ConfigMemorySize(long bytes) {
      * Constructs a ConfigMemorySize representing the given
      * number of bytes.
      * @since 1.3.0
+     * @param bytes a number of bytes
+     * @return an instance representing the number of bytes
      */
     public static ConfigMemorySize ofBytes(long bytes) {
         return new ConfigMemorySize(bytes);
@@ -31,6 +33,7 @@ public static ConfigMemorySize ofBytes(long bytes) {
     /**
      * Gets the size in bytes.
      * @since 1.3.0
+     * @return how many bytes
      */
     public long toBytes() {
         return bytes;

File: config/src/main/java/com/typesafe/config/ConfigParseable.java
Patch:
@@ -24,19 +24,22 @@ public interface ConfigParseable {
      * @param options
      *            parse options, should be based on the ones from
      *            {@link ConfigParseable#options options()}
+     * @return the parsed object
      */
     ConfigObject parse(ConfigParseOptions options);
 
     /**
      * Returns a {@link ConfigOrigin} describing the origin of the parseable
      * item.
+     * @return the origin of the parseable item
      */
     ConfigOrigin origin();
 
     /**
      * Get the initial options, which can be modified then passed to parse().
      * These options will have the right description, includer, and other
      * parameters already set up.
+     * @return the initial options
      */
     ConfigParseOptions options();
 }

File: config/src/main/java/com/typesafe/config/ConfigValue.java
Patch:
@@ -40,6 +40,7 @@ public interface ConfigValue extends ConfigMergeable {
      * {@code List<Object>}, or {@code null}, matching the {@link #valueType()}
      * of this {@code ConfigValue}. If the value is a {@link ConfigObject} or
      * {@link ConfigList}, it is recursively unwrapped.
+     * @return a plain Java value corresponding to this ConfigValue
      */
     Object unwrapped();
 

File: config/src/main/java/com/typesafe/config/ConfigIncluder.java
Patch:
@@ -23,7 +23,7 @@ public interface ConfigIncluder {
      * the fallback is the same one you already have. The same fallback may be
      * added repeatedly.
      *
-     * @param fallback
+     * @param fallback the previous includer for chaining
      * @return a new includer
      */
     ConfigIncluder withFallback(ConfigIncluder fallback);

File: config/src/main/java/com/typesafe/config/ConfigMemorySize.java
Patch:
@@ -23,6 +23,8 @@ private ConfigMemorySize(long bytes) {
      * Constructs a ConfigMemorySize representing the given
      * number of bytes.
      * @since 1.3.0
+     * @param bytes a number of bytes
+     * @return an instance representing the number of bytes
      */
     public static ConfigMemorySize ofBytes(long bytes) {
         return new ConfigMemorySize(bytes);
@@ -31,6 +33,7 @@ public static ConfigMemorySize ofBytes(long bytes) {
     /**
      * Gets the size in bytes.
      * @since 1.3.0
+     * @return how many bytes
      */
     public long toBytes() {
         return bytes;

File: config/src/main/java/com/typesafe/config/ConfigParseOptions.java
Patch:
@@ -67,7 +67,7 @@ public ConfigSyntax getSyntax() {
      * library to come up with something automatically. This description is the
      * basis for the {@link ConfigOrigin} of the parsed values.
      *
-     * @param originDescription
+     * @param originDescription description to put in the {@link ConfigOrigin}
      * @return options with the origin description set
      */
     public ConfigParseOptions setOriginDescription(String originDescription) {
@@ -99,7 +99,7 @@ ConfigParseOptions withFallbackOriginDescription(String originDescription) {
      * a file) is missing. Set to true to just return an empty document in that
      * case.
      *
-     * @param allowMissing
+     * @param allowMissing true to silently ignore missing item
      * @return options with the "allow missing" flag set
      */
     public ConfigParseOptions setAllowMissing(boolean allowMissing) {
@@ -117,7 +117,7 @@ public boolean getAllowMissing() {
     /**
      * Set a ConfigIncluder which customizes how includes are handled.
      *
-     * @param includer
+     * @param includer the includer to use or null for default
      * @return new version of the parse options with different includer
      */
     public ConfigParseOptions setIncluder(ConfigIncluder includer) {

File: config/src/main/java/com/typesafe/config/ConfigParseable.java
Patch:
@@ -24,19 +24,22 @@ public interface ConfigParseable {
      * @param options
      *            parse options, should be based on the ones from
      *            {@link ConfigParseable#options options()}
+     * @return the parsed object
      */
     ConfigObject parse(ConfigParseOptions options);
 
     /**
      * Returns a {@link ConfigOrigin} describing the origin of the parseable
      * item.
+     * @return the origin of the parseable item
      */
     ConfigOrigin origin();
 
     /**
      * Get the initial options, which can be modified then passed to parse().
      * These options will have the right description, includer, and other
      * parameters already set up.
+     * @return the initial options
      */
     ConfigParseOptions options();
 }

File: config/src/main/java/com/typesafe/config/ConfigValue.java
Patch:
@@ -40,6 +40,7 @@ public interface ConfigValue extends ConfigMergeable {
      * {@code List<Object>}, or {@code null}, matching the {@link #valueType()}
      * of this {@code ConfigValue}. If the value is a {@link ConfigObject} or
      * {@link ConfigList}, it is recursively unwrapped.
+     * @return a plain Java value corresponding to this ConfigValue
      */
     Object unwrapped();
 

File: config/src/main/java/com/typesafe/config/impl/AbstractConfigValue.java
Patch:
@@ -312,7 +312,7 @@ public int hashCode() {
     }
 
     @Override
-    public final String toString() {
+    public String toString() {
         StringBuilder sb = new StringBuilder();
         render(sb, 0, true /* atRoot */, null /* atKey */, ConfigRenderOptions.concise());
         return getClass().getSimpleName() + "(" + sb.toString() + ")";

File: config/src/main/java/com/typesafe/config/impl/AbstractConfigValue.java
Patch:
@@ -312,7 +312,7 @@ public int hashCode() {
     }
 
     @Override
-    public final String toString() {
+    public String toString() {
         StringBuilder sb = new StringBuilder();
         render(sb, 0, true /* atRoot */, null /* atKey */, ConfigRenderOptions.concise());
         return getClass().getSimpleName() + "(" + sb.toString() + ")";

File: config/src/main/java/com/typesafe/config/impl/Parseable.java
Patch:
@@ -14,6 +14,7 @@
 import java.io.Reader;
 import java.io.StringReader;
 import java.io.UnsupportedEncodingException;
+import java.net.HttpURLConnection;
 import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URISyntaxException;

File: config/src/main/java/com/typesafe/config/impl/ConfigImpl.java
Patch:
@@ -227,7 +227,7 @@ static AbstractConfigValue fromAnyRef(Object object, ConfigOrigin origin,
                 return defaultFalseValue;
             }
         } else if (object instanceof String) {
-            return new ConfigString(origin, (String) object);
+            return new ConfigString.Quoted(origin, (String) object);
         } else if (object instanceof Number) {
             // here we always keep the same type that was passed to us,
             // rather than figuring out if a Long would fit in an Int
@@ -346,7 +346,7 @@ private static AbstractConfigObject loadEnvVariables() {
         for (Map.Entry<String, String> entry : env.entrySet()) {
             String key = entry.getKey();
             m.put(key,
-                    new ConfigString(SimpleConfigOrigin.newSimple("env var " + key), entry
+                    new ConfigString.Quoted(SimpleConfigOrigin.newSimple("env var " + key), entry
                             .getValue()));
         }
         return new SimpleConfigObject(SimpleConfigOrigin.newSimple("env variables"),

File: config/src/main/java/com/typesafe/config/impl/DefaultTransformer.java
Patch:
@@ -64,7 +64,7 @@ static AbstractConfigValue transform(AbstractConfigValue value,
             switch (value.valueType()) {
             case NUMBER: // FALL THROUGH
             case BOOLEAN:
-                return new ConfigString(value.origin(),
+                return new ConfigString.Quoted(value.origin(),
                         value.transformToString());
             case NULL:
                 // want to be sure this throws instead of returning "null" as a

File: config/src/main/java/com/typesafe/config/impl/Parser.java
Patch:
@@ -513,7 +513,7 @@ private AbstractConfigValue parseValue(TokenWithComments t) {
                 // or substitution already.
                 v = Tokens.getValue(t.token);
             } else if (Tokens.isUnquotedText(t.token)) {
-                v = new ConfigString(t.token.origin(), Tokens.getUnquotedText(t.token));
+                v = new ConfigString.Unquoted(t.token.origin(), Tokens.getUnquotedText(t.token));
             } else if (Tokens.isSubstitution(t.token)) {
                 v = new ConfigReference(t.token.origin(), tokenToSubstitutionExpression(t.token));
             } else if (t.token == Tokens.OPEN_CURLY) {

File: config/src/main/java/com/typesafe/config/impl/PropertiesParser.java
Patch:
@@ -143,7 +143,7 @@ private static AbstractConfigObject fromPathMap(ConfigOrigin origin,
             AbstractConfigValue value;
             if (convertedFromProperties) {
                 if (rawValue instanceof String) {
-                    value = new ConfigString(origin, (String) rawValue);
+                    value = new ConfigString.Quoted(origin, (String) rawValue);
                 } else {
                     // silently ignore non-string values in Properties
                     value = null;

File: config/src/main/java/com/typesafe/config/impl/SerializedConfigValue.java
Patch:
@@ -353,7 +353,7 @@ private static AbstractConfigValue readValueData(DataInput in, SimpleConfigOrigi
             String sd = in.readUTF();
             return new ConfigDouble(origin, vd, sd);
         case STRING:
-            return new ConfigString(origin, in.readUTF());
+            return new ConfigString.Quoted(origin, in.readUTF());
         case LIST:
             int listSize = in.readInt();
             List<AbstractConfigValue> list = new ArrayList<AbstractConfigValue>(listSize);

File: config/src/main/java/com/typesafe/config/impl/Tokens.java
Patch:
@@ -403,7 +403,7 @@ static Token newValue(AbstractConfigValue value) {
     }
 
     static Token newString(ConfigOrigin origin, String value) {
-        return newValue(new ConfigString(origin, value));
+        return newValue(new ConfigString.Quoted(origin, value));
     }
 
     static Token newInt(ConfigOrigin origin, int value, String originalText) {

File: config/src/main/java/com/typesafe/config/impl/ConfigImpl.java
Patch:
@@ -227,7 +227,7 @@ static AbstractConfigValue fromAnyRef(Object object, ConfigOrigin origin,
                 return defaultFalseValue;
             }
         } else if (object instanceof String) {
-            return new ConfigString(origin, (String) object);
+            return new ConfigString.Quoted(origin, (String) object);
         } else if (object instanceof Number) {
             // here we always keep the same type that was passed to us,
             // rather than figuring out if a Long would fit in an Int
@@ -346,7 +346,7 @@ private static AbstractConfigObject loadEnvVariables() {
         for (Map.Entry<String, String> entry : env.entrySet()) {
             String key = entry.getKey();
             m.put(key,
-                    new ConfigString(SimpleConfigOrigin.newSimple("env var " + key), entry
+                    new ConfigString.Quoted(SimpleConfigOrigin.newSimple("env var " + key), entry
                             .getValue()));
         }
         return new SimpleConfigObject(SimpleConfigOrigin.newSimple("env variables"),

File: config/src/main/java/com/typesafe/config/impl/DefaultTransformer.java
Patch:
@@ -64,7 +64,7 @@ static AbstractConfigValue transform(AbstractConfigValue value,
             switch (value.valueType()) {
             case NUMBER: // FALL THROUGH
             case BOOLEAN:
-                return new ConfigString(value.origin(),
+                return new ConfigString.Quoted(value.origin(),
                         value.transformToString());
             case NULL:
                 // want to be sure this throws instead of returning "null" as a

File: config/src/main/java/com/typesafe/config/impl/Parser.java
Patch:
@@ -513,7 +513,7 @@ private AbstractConfigValue parseValue(TokenWithComments t) {
                 // or substitution already.
                 v = Tokens.getValue(t.token);
             } else if (Tokens.isUnquotedText(t.token)) {
-                v = new ConfigString(t.token.origin(), Tokens.getUnquotedText(t.token));
+                v = new ConfigString.Unquoted(t.token.origin(), Tokens.getUnquotedText(t.token));
             } else if (Tokens.isSubstitution(t.token)) {
                 v = new ConfigReference(t.token.origin(), tokenToSubstitutionExpression(t.token));
             } else if (t.token == Tokens.OPEN_CURLY) {

File: config/src/main/java/com/typesafe/config/impl/PropertiesParser.java
Patch:
@@ -143,7 +143,7 @@ private static AbstractConfigObject fromPathMap(ConfigOrigin origin,
             AbstractConfigValue value;
             if (convertedFromProperties) {
                 if (rawValue instanceof String) {
-                    value = new ConfigString(origin, (String) rawValue);
+                    value = new ConfigString.Quoted(origin, (String) rawValue);
                 } else {
                     // silently ignore non-string values in Properties
                     value = null;

File: config/src/main/java/com/typesafe/config/impl/SerializedConfigValue.java
Patch:
@@ -342,7 +342,7 @@ private static AbstractConfigValue readValueData(DataInput in, SimpleConfigOrigi
             String sd = in.readUTF();
             return new ConfigDouble(origin, vd, sd);
         case STRING:
-            return new ConfigString(origin, in.readUTF());
+            return new ConfigString.Quoted(origin, in.readUTF());
         case LIST:
             int listSize = in.readInt();
             List<AbstractConfigValue> list = new ArrayList<AbstractConfigValue>(listSize);

File: config/src/main/java/com/typesafe/config/impl/Tokens.java
Patch:
@@ -403,7 +403,7 @@ static Token newValue(AbstractConfigValue value) {
     }
 
     static Token newString(ConfigOrigin origin, String value) {
-        return newValue(new ConfigString(origin, value));
+        return newValue(new ConfigString.Quoted(origin, value));
     }
 
     static Token newInt(ConfigOrigin origin, int value, String originalText) {

File: config/src/test/java/beanconfig/BooleansConfig.java
Patch:
@@ -7,7 +7,7 @@ public class BooleansConfig {
     Boolean falseVal;
     Boolean falseValAgain;
     Boolean on;
-    Boolean off;
+    boolean off;
 
     public Boolean getTrueVal() {
         return trueVal;
@@ -49,11 +49,11 @@ public void setOn(Boolean on) {
         this.on = on;
     }
 
-    public Boolean getOff() {
+    public boolean getOff() {
         return off;
     }
 
-    public void setOff(Boolean off) {
+    public void setOff(boolean off) {
         this.off = off;
     }
 }

File: config/src/main/java/com/typesafe/config/ConfigBeanFactory.java
Patch:
@@ -32,6 +32,8 @@ public class ConfigBeanFactory {
      * @return an instance of the class populated with data from the config
      * @throws ConfigException.BadBean
      *     If something is wrong with the JavaBean
+     * @throws ConfigException.ValidationFailed
+     *     If the config doesn't conform to the bean's implied schema
      * @throws ConfigException
      *     Can throw the same exceptions as the getters on <code>Config</code>
      */

File: config/src/main/java/com/typesafe/config/impl/ConfigImpl.java
Patch:
@@ -216,6 +216,8 @@ static AbstractConfigValue fromAnyRef(Object object, ConfigOrigin origin,
                 return new ConfigNull(origin);
             else
                 return defaultNullValue;
+        } else if(object instanceof AbstractConfigValue) {
+            return (AbstractConfigValue) object;
         } else if (object instanceof Boolean) {
             if (origin != defaultValueOrigin) {
                 return new ConfigBoolean(origin, (Boolean) object);

File: config/src/main/java/com/typesafe/config/impl/ConfigImpl.java
Patch:
@@ -6,6 +6,7 @@
 import java.io.File;
 import java.lang.ref.WeakReference;
 import java.net.URL;
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -241,6 +242,8 @@ static AbstractConfigValue fromAnyRef(Object object, ConfigOrigin origin,
                 return ConfigNumber.newNumber(origin,
                         ((Number) object).doubleValue(), null);
             }
+        } else if (object instanceof Duration) {
+            return new ConfigLong(origin, ((Duration) object).toMillis(), null);
         } else if (object instanceof Map) {
             if (((Map<?, ?>) object).isEmpty())
                 return emptyObject(origin);

File: config/src/main/java/com/typesafe/config/impl/ConfigImpl.java
Patch:
@@ -18,6 +18,7 @@
 import com.typesafe.config.Config;
 import com.typesafe.config.ConfigException;
 import com.typesafe.config.ConfigIncluder;
+import com.typesafe.config.ConfigMemorySize;
 import com.typesafe.config.ConfigObject;
 import com.typesafe.config.ConfigOrigin;
 import com.typesafe.config.ConfigParseOptions;
@@ -273,6 +274,8 @@ static AbstractConfigValue fromAnyRef(Object object, ConfigOrigin origin,
             }
 
             return new SimpleConfigList(origin, values);
+        } else if (object instanceof ConfigMemorySize) {
+            return new ConfigLong(origin, ((ConfigMemorySize) object).toBytes(), null);
         } else {
             throw new ConfigException.BugOrBroken(
                     "bug in method caller: not valid to create ConfigValue from: "

File: config/src/main/java/com/typesafe/config/impl/Parser.java
Patch:
@@ -553,7 +553,7 @@ private static AbstractConfigObject createValueUnderPath(Path path,
                 }
             }
 
-            // the setComments(null) is to ensure comments are only
+            // the withComments(null) is to ensure comments are only
             // on the exact leaf node they apply to.
             // a comment before "foo.bar" applies to the full setting
             // "foo.bar" not also to "foo"

File: config/src/main/java/com/typesafe/config/impl/ResolveContext.java
Patch:
@@ -146,7 +146,7 @@ private ResolveResult<? extends AbstractConfigValue> realResolve(AbstractConfigV
             throws NotPossibleToResolve {
         // a fully-resolved (no restrictToChild) object can satisfy a
         // request for a restricted object, so always check that first.
-        final MemoKey fullKey = new MemoKey(source.root, original, null);
+        final MemoKey fullKey = new MemoKey(original, null);
         MemoKey restrictedKey = null;
 
         AbstractConfigValue cached = memos.get(fullKey);
@@ -155,7 +155,7 @@ private ResolveResult<? extends AbstractConfigValue> realResolve(AbstractConfigV
         // compute the restrictToChild object so use a more limited
         // memo key
         if (cached == null && isRestrictedToChild()) {
-            restrictedKey = new MemoKey(source.root, original, restrictToChild());
+            restrictedKey = new MemoKey(original, restrictToChild());
             cached = memos.get(restrictedKey);
         }
 

File: config/src/main/java/com/typesafe/config/impl/ConfigDelayedMerge.java
Patch:
@@ -116,8 +116,7 @@ else if (end instanceof Unmergeable) {
                 sourceForEnd = sourceForEnd.resetParents();
             } else {
                 if (ConfigImpl.traceSubstitutionsEnabled())
-                    ConfigImpl
-.trace(newContext.depth(),
+                    ConfigImpl.trace(newContext.depth(),
                             "will resolve end against the original source with parent pushed");
 
                 sourceForEnd = source.pushParent(replaceable);

File: config/src/main/java/com/typesafe/config/ConfigRenderOptions.java
Patch:
@@ -115,7 +115,7 @@ public boolean getOriginComments() {
      * whitespace, enabling formatting makes things prettier but larger.
      *
      * @param value
-     *            true to include comments in the render
+     *            true to enable formatting
      * @return options with requested setting for formatting
      */
     public ConfigRenderOptions setFormatted(boolean value) {
@@ -129,7 +129,7 @@ public ConfigRenderOptions setFormatted(boolean value) {
      * Returns whether the options enable formatting. This method is mostly used
      * by the config lib internally, not by applications.
      *
-     * @return true if comments should be rendered
+     * @return true if the options enable formatting
      */
     public boolean getFormatted() {
         return formatted;

File: config/src/main/java/com/typesafe/config/ConfigResolveOptions.java
Patch:
@@ -83,7 +83,7 @@ public boolean getUseSystemEnvironment() {
      * default, unresolved substitutions are an error. If unresolved
      * substitutions are allowed, then a future attempt to use the unresolved
      * value may fail, but {@link Config#resolve(ConfigResolveOptions)} itself
-     * will now throw.
+     * will not throw.
      * 
      * @param value
      *            true to silently ignore unresolved substitutions.

File: config/src/main/java/com/typesafe/config/ConfigRenderOptions.java
Patch:
@@ -115,7 +115,7 @@ public boolean getOriginComments() {
      * whitespace, enabling formatting makes things prettier but larger.
      *
      * @param value
-     *            true to include comments in the render
+     *            true to enable formatting
      * @return options with requested setting for formatting
      */
     public ConfigRenderOptions setFormatted(boolean value) {
@@ -129,7 +129,7 @@ public ConfigRenderOptions setFormatted(boolean value) {
      * Returns whether the options enable formatting. This method is mostly used
      * by the config lib internally, not by applications.
      *
-     * @return true if comments should be rendered
+     * @return true if the options enable formatting
      */
     public boolean getFormatted() {
         return formatted;

File: config/src/main/java/com/typesafe/config/ConfigRenderOptions.java
Patch:
@@ -115,7 +115,7 @@ public boolean getOriginComments() {
      * whitespace, enabling formatting makes things prettier but larger.
      *
      * @param value
-     *            true to include comments in the render
+     *            true to enable formatting
      * @return options with requested setting for formatting
      */
     public ConfigRenderOptions setFormatted(boolean value) {
@@ -129,7 +129,7 @@ public ConfigRenderOptions setFormatted(boolean value) {
      * Returns whether the options enable formatting. This method is mostly used
      * by the config lib internally, not by applications.
      *
-     * @return true if comments should be rendered
+     * @return true if the options enable formatting
      */
     public boolean getFormatted() {
         return formatted;

File: config/src/main/java/com/typesafe/config/impl/Parser.java
Patch:
@@ -683,7 +683,9 @@ private void parseInclude(Map<String, AbstractConfigValue> values) {
             }
 
             if (!pathStack.isEmpty()) {
-                Path prefix = new Path(pathStack);
+                // The stack is in reverse order (most recent first on the
+                // iterator), so build the path from the reversed iterator.
+                Path prefix = new Path(pathStack.descendingIterator());
                 obj = obj.relativized(prefix);
             }
 

File: config/src/main/java/com/typesafe/config/Config.java
Patch:
@@ -107,7 +107,7 @@
  * <em>Substitutions</em> are the <code>${foo.bar}</code> syntax in config
  * files, described in the <a href=
  * "https://github.com/typesafehub/config/blob/master/HOCON.md#substitutions"
- * >here</a>. Resolving substitutions replaces these references with real
+ * >specification</a>. Resolving substitutions replaces these references with real
  * values.
  * 
  * <p>

File: config/src/main/java/com/typesafe/config/ConfigResolveOptions.java
Patch:
@@ -88,6 +88,7 @@ public boolean getUseSystemEnvironment() {
      * @param value
      *            true to silently ignore unresolved substitutions.
      * @return options with requested setting for whether to allow substitutions
+     * @since 1.2.0
      */
     public ConfigResolveOptions setAllowUnresolved(boolean value) {
         return new ConfigResolveOptions(useSystemEnvironment, value);
@@ -98,6 +99,7 @@ public ConfigResolveOptions setAllowUnresolved(boolean value) {
      * is mostly used by the config lib internally, not by applications.
      * 
      * @return true if unresolved substitutions are allowed
+     * @since 1.2.0
      */
     public boolean getAllowUnresolved() {
         return allowUnresolved;

File: config/src/main/java/com/typesafe/config/impl/AbstractConfigObject.java
Patch:
@@ -218,7 +218,7 @@ static ConfigOrigin mergeOrigins(AbstractConfigObject... stack) {
     public abstract AbstractConfigValue get(Object key);
 
     @Override
-    protected abstract void render(StringBuilder sb, int indent, ConfigRenderOptions options);
+    protected abstract void render(StringBuilder sb, int indent, boolean atRoot, ConfigRenderOptions options);
 
     private static UnsupportedOperationException weAreImmutable(String method) {
         return new UnsupportedOperationException("ConfigObject is immutable, you can't call Map."

File: config/src/main/java/com/typesafe/config/impl/ConfigConcatenation.java
Patch:
@@ -232,9 +232,9 @@ public int hashCode() {
     }
 
     @Override
-    protected void render(StringBuilder sb, int indent, ConfigRenderOptions options) {
+    protected void render(StringBuilder sb, int indent, boolean atRoot, ConfigRenderOptions options) {
         for (AbstractConfigValue p : pieces) {
-            p.render(sb, indent, options);
+            p.render(sb, indent, atRoot, options);
         }
     }
 

File: config/src/main/java/com/typesafe/config/impl/ConfigNull.java
Patch:
@@ -42,7 +42,7 @@ String transformToString() {
     }
 
     @Override
-    protected void render(StringBuilder sb, int indent, ConfigRenderOptions options) {
+    protected void render(StringBuilder sb, int indent, boolean atRoot, ConfigRenderOptions options) {
         sb.append("null");
     }
 

File: config/src/main/java/com/typesafe/config/impl/ConfigReference.java
Patch:
@@ -131,7 +131,7 @@ public int hashCode() {
     }
 
     @Override
-    protected void render(StringBuilder sb, int indent, ConfigRenderOptions options) {
+    protected void render(StringBuilder sb, int indent, boolean atRoot, ConfigRenderOptions options) {
         sb.append(expr.toString());
     }
 

File: config/src/main/java/com/typesafe/config/impl/ConfigString.java
Patch:
@@ -37,7 +37,7 @@ String transformToString() {
     }
 
     @Override
-    protected void render(StringBuilder sb, int indent, ConfigRenderOptions options) {
+    protected void render(StringBuilder sb, int indent, boolean atRoot, ConfigRenderOptions options) {
         String rendered;
         if (options.getJson())
             rendered = ConfigImplUtil.renderJsonString(value);

File: config/src/main/java/com/typesafe/config/impl/SimpleConfigList.java
Patch:
@@ -167,7 +167,7 @@ public int hashCode() {
     }
 
     @Override
-    protected void render(StringBuilder sb, int indent, ConfigRenderOptions options) {
+    protected void render(StringBuilder sb, int indent, boolean atRoot, ConfigRenderOptions options) {
         if (value.isEmpty()) {
             sb.append("[]");
         } else {
@@ -191,7 +191,7 @@ protected void render(StringBuilder sb, int indent, ConfigRenderOptions options)
                 }
                 indent(sb, indent + 1, options);
 
-                v.render(sb, indent + 1, options);
+                v.render(sb, indent + 1, atRoot, options);
                 sb.append(",");
                 if (options.getFormatted())
                     sb.append('\n');

File: config/src/main/java/com/typesafe/config/impl/AbstractConfigObject.java
Patch:
@@ -218,7 +218,7 @@ static ConfigOrigin mergeOrigins(AbstractConfigObject... stack) {
     public abstract AbstractConfigValue get(Object key);
 
     @Override
-    protected abstract void render(StringBuilder sb, int indent, ConfigRenderOptions options);
+    protected abstract void render(StringBuilder sb, int indent, boolean atRoot, ConfigRenderOptions options);
 
     private static UnsupportedOperationException weAreImmutable(String method) {
         return new UnsupportedOperationException("ConfigObject is immutable, you can't call Map."

File: config/src/main/java/com/typesafe/config/impl/ConfigConcatenation.java
Patch:
@@ -232,9 +232,9 @@ public int hashCode() {
     }
 
     @Override
-    protected void render(StringBuilder sb, int indent, ConfigRenderOptions options) {
+    protected void render(StringBuilder sb, int indent, boolean atRoot, ConfigRenderOptions options) {
         for (AbstractConfigValue p : pieces) {
-            p.render(sb, indent, options);
+            p.render(sb, indent, atRoot, options);
         }
     }
 

File: config/src/main/java/com/typesafe/config/impl/ConfigNull.java
Patch:
@@ -42,7 +42,7 @@ String transformToString() {
     }
 
     @Override
-    protected void render(StringBuilder sb, int indent, ConfigRenderOptions options) {
+    protected void render(StringBuilder sb, int indent, boolean atRoot, ConfigRenderOptions options) {
         sb.append("null");
     }
 

File: config/src/main/java/com/typesafe/config/impl/ConfigReference.java
Patch:
@@ -127,7 +127,7 @@ public int hashCode() {
     }
 
     @Override
-    protected void render(StringBuilder sb, int indent, ConfigRenderOptions options) {
+    protected void render(StringBuilder sb, int indent, boolean atRoot, ConfigRenderOptions options) {
         sb.append(expr.toString());
     }
 

File: config/src/main/java/com/typesafe/config/impl/ConfigString.java
Patch:
@@ -37,7 +37,7 @@ String transformToString() {
     }
 
     @Override
-    protected void render(StringBuilder sb, int indent, ConfigRenderOptions options) {
+    protected void render(StringBuilder sb, int indent, boolean atRoot, ConfigRenderOptions options) {
         String rendered;
         if (options.getJson())
             rendered = ConfigImplUtil.renderJsonString(value);

File: config/src/main/java/com/typesafe/config/impl/SimpleConfigList.java
Patch:
@@ -167,7 +167,7 @@ public int hashCode() {
     }
 
     @Override
-    protected void render(StringBuilder sb, int indent, ConfigRenderOptions options) {
+    protected void render(StringBuilder sb, int indent, boolean atRoot, ConfigRenderOptions options) {
         if (value.isEmpty()) {
             sb.append("[]");
         } else {
@@ -191,7 +191,7 @@ protected void render(StringBuilder sb, int indent, ConfigRenderOptions options)
                 }
                 indent(sb, indent + 1, options);
 
-                v.render(sb, indent + 1, options);
+                v.render(sb, indent + 1, atRoot, options);
                 sb.append(",");
                 if (options.getFormatted())
                     sb.append('\n');

File: config/src/main/java/com/typesafe/config/impl/SimpleConfigObject.java
Patch:
@@ -390,7 +390,9 @@ protected void render(StringBuilder sb, int indent, ConfigRenderOptions options)
                 if (options.getComments()) {
                     for (String comment : v.origin().comments()) {
                         indent(sb, indent + 1, options);
-                        sb.append("# ");
+                        sb.append("#");
+                        if (!comment.startsWith(" "))
+                            sb.append(' ');
                         sb.append(comment);
                         sb.append("\n");
                     }

File: config/src/main/java/com/typesafe/config/impl/SimpleConfigObject.java
Patch:
@@ -390,7 +390,9 @@ protected void render(StringBuilder sb, int indent, ConfigRenderOptions options)
                 if (options.getComments()) {
                     for (String comment : v.origin().comments()) {
                         indent(sb, indent + 1, options);
-                        sb.append("# ");
+                        sb.append("#");
+                        if (!comment.startsWith(" "))
+                            sb.append(' ');
                         sb.append(comment);
                         sb.append("\n");
                     }

File: config/src/main/java/com/typesafe/config/impl/DefaultTransformer.java
Patch:
@@ -7,7 +7,6 @@
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 
 import com.typesafe.config.ConfigValueType;

File: config/src/main/java/com/typesafe/config/impl/SimpleConfig.java
Patch:
@@ -408,7 +408,7 @@ public List<Long> getDurationList(String path, TimeUnit unit) {
                 l.add(n);
             } else {
                 throw new ConfigException.WrongType(v.origin(), path,
-                        "duration string or number of " + unit.name(),
+                        "duration string or number of milliseconds",
                         v.valueType().name());
             }
         }

File: config/src/main/java/com/typesafe/config/ConfigValueFactory.java
Patch:
@@ -90,7 +90,7 @@ public static ConfigObject fromMap(Map<String, ? extends Object> values,
 
     /**
      * See the fromAnyRef() documentation for details. This is a typesafe
-     * wrapper that only works on {@link java.util.Iterable} and returns
+     * wrapper that only works on {@link java.lang.Iterable} and returns
      * {@link ConfigList} rather than {@link ConfigValue}.
      *
      * @param values

File: config/src/main/java/com/typesafe/config/ConfigFactory.java
Patch:
@@ -166,7 +166,7 @@ public static Config load(ClassLoader loader, Config config, ConfigResolveOption
     }
 
     private static Config loadDefaultConfig(ClassLoader loader) {
-        return loadDefaultConfig(loader, ConfigParseOptions.defaults().setClassLoader(loader));
+        return loadDefaultConfig(loader, ConfigParseOptions.defaults());
     }
 
     private static Config loadDefaultConfig(ClassLoader loader, ConfigParseOptions parseOptions) {
@@ -298,7 +298,7 @@ public static Config load(ClassLoader loader, ConfigParseOptions parseOptions) {
     /**
      * Like {@link #load()} but allows specifying a class loader other than the
      * thread's current context class loader, and resolve options
-     * 
+     *
      * @param loader
      *            class loader for finding resources
      * @param resolveOptions

File: config/src/main/java/com/typesafe/config/ConfigParseOptions.java
Patch:
@@ -71,6 +71,7 @@ public ConfigSyntax getSyntax() {
      * @return options with the origin description set
      */
     public ConfigParseOptions setOriginDescription(String originDescription) {
+        // findbugs complains about == here but is wrong, do not "fix"
         if (this.originDescription == originDescription)
             return this;
         else if (this.originDescription != null && originDescription != null

File: config/src/main/java/com/typesafe/config/impl/ConfigNumber.java
Patch:
@@ -58,7 +58,7 @@ protected boolean canEqual(Object other) {
     @Override
     public boolean equals(Object other) {
         // note that "origin" is deliberately NOT part of equality
-        if (canEqual(other)) {
+        if (other instanceof ConfigNumber && canEqual(other)) {
             ConfigNumber n = (ConfigNumber) other;
             if (isWhole()) {
                 return n.isWhole() && this.longValue() == n.longValue();

File: config/src/main/java/com/typesafe/config/impl/ResolveSource.java
Patch:
@@ -48,7 +48,7 @@ AbstractConfigValue lookupSubst(ResolveContext context, SubstitutionExpression s
                 context.untrace();
                 context.trace(unprefixed);
 
-                if (result == null && prefixLength > 0) {
+                if (prefixLength > 0) {
                     result = findInObject(root, context, unprefixed);
                 }
 

File: config/src/main/java/com/typesafe/config/impl/AbstractConfigObject.java
Patch:
@@ -18,8 +18,6 @@
 
 abstract class AbstractConfigObject extends AbstractConfigValue implements ConfigObject {
 
-    private static final long serialVersionUID = 1L;
-
     final private SimpleConfig config;
 
     protected AbstractConfigObject(ConfigOrigin origin) {

File: config/src/main/java/com/typesafe/config/impl/ConfigReference.java
Patch:
@@ -13,7 +13,6 @@
  * kind of value.
  */
 final class ConfigReference extends AbstractConfigValue implements Unmergeable {
-    private static final long serialVersionUID = 1L;
 
     final private SubstitutionExpression expr;
     // the length of any prefixes added with relativized()

File: config/src/main/java/com/typesafe/config/impl/ConfigSubstitution.java
Patch:
@@ -5,6 +5,7 @@
 
 import java.io.IOException;
 import java.io.ObjectStreamException;
+import java.io.Serializable;
 import java.util.Collection;
 import java.util.List;
 
@@ -18,8 +19,7 @@
  * and ConfigConcatenation.
  */
 @Deprecated
-final class ConfigSubstitution extends AbstractConfigValue implements
-        Unmergeable {
+final class ConfigSubstitution extends AbstractConfigValue implements Unmergeable, Serializable {
 
     private static final long serialVersionUID = 1L;
 

File: config/src/main/java/com/typesafe/config/impl/OriginType.java
Patch:
@@ -1,5 +1,6 @@
 package com.typesafe.config.impl;
 
+// caution: ordinals used in serialization
 enum OriginType {
     GENERIC,
     FILE,

File: config/src/main/java/com/typesafe/config/impl/ResolveContext.java
Patch:
@@ -93,7 +93,6 @@ String traceString() {
     }
 
     AbstractConfigValue resolve(AbstractConfigValue original) throws NotPossibleToResolve {
-
         // a fully-resolved (no restrictToChild) object can satisfy a
         // request for a restricted object, so always check that first.
         final MemoKey fullKey = new MemoKey(original, null);

File: config/src/main/java/com/typesafe/config/impl/SimpleConfigObject.java
Patch:
@@ -159,8 +159,7 @@ public Map<String, Object> unwrapped() {
 
     @Override
     protected SimpleConfigObject mergedWithObject(AbstractConfigObject abstractFallback) {
-        if (ignoresFallbacks())
-            throw new ConfigException.BugOrBroken("should not be reached");
+        requireNotIgnoringFallbacks();
 
         if (!(abstractFallback instanceof SimpleConfigObject)) {
             throw new ConfigException.BugOrBroken(

File: config/src/main/java/com/typesafe/config/impl/AbstractConfigObject.java
Patch:
@@ -57,7 +57,7 @@ public AbstractConfigObject toFallbackValue() {
      * @param key
      * @return the unmodified raw value or null
      */
-    protected final AbstractConfigValue peekAssumingResolved(String key, String originalPath) {
+    protected final AbstractConfigValue peekAssumingResolved(String key, Path originalPath) {
         try {
             return attemptPeekWithPartialResolve(key);
         } catch (ConfigException.NotResolved e) {
@@ -138,7 +138,7 @@ private static AbstractConfigValue peekPath(AbstractConfigObject self, Path path
                 }
             }
         } catch (ConfigException.NotResolved e) {
-            throw ConfigImpl.improveNotResolved(path.render(), e);
+            throw ConfigImpl.improveNotResolved(path, e);
         }
     }
 

File: config/src/main/java/com/typesafe/config/impl/ConfigImpl.java
Patch:
@@ -526,9 +526,10 @@ public static void trace(String message) {
     // toplevel error message. the "original" exception may however have extra
     // detail about what happened. call this if you have a better "what" than
     // further down on the stack.
-    static ConfigException.NotResolved improveNotResolved(String what,
+    static ConfigException.NotResolved improveNotResolved(Path what,
             ConfigException.NotResolved original) {
-        String newMessage = what + " has not been resolved, you need to call Config#resolve(),"
+        String newMessage = what.render()
+                + " has not been resolved, you need to call Config#resolve(),"
                 + " see API docs for Config#resolve()";
         if (newMessage.equals(original.getMessage()))
             return original;

File: config/src/main/java/com/typesafe/config/impl/ConfigDelayedMergeObject.java
Patch:
@@ -75,8 +75,9 @@ AbstractConfigObject resolveSubstitutions(ResolveContext context)
     public ResolveReplacer makeReplacer(final int skipping) {
         return new ResolveReplacer() {
             @Override
-            protected AbstractConfigValue makeReplacement() throws Undefined {
-                return ConfigDelayedMerge.makeReplacement(stack, skipping);
+            protected AbstractConfigValue makeReplacement(ResolveContext context)
+                    throws NotPossibleToResolve {
+                return ConfigDelayedMerge.makeReplacement(context, stack, skipping);
             }
         };
     }

File: config/src/main/java/com/typesafe/config/impl/ResolveContext.java
Patch:
@@ -10,7 +10,6 @@
 
 import com.typesafe.config.ConfigException;
 import com.typesafe.config.ConfigResolveOptions;
-import com.typesafe.config.impl.AbstractConfigValue.NeedsFullResolve;
 import com.typesafe.config.impl.AbstractConfigValue.NotPossibleToResolve;
 import com.typesafe.config.impl.AbstractConfigValue.SelfReferential;
 import com.typesafe.config.impl.ResolveReplacer.Undefined;
@@ -71,11 +70,11 @@ private void untraverse(ConfigSubstitution value) {
     // this just exists to fix the "throws Exception" on Callable
     interface Resolver extends Callable<AbstractConfigValue> {
         @Override
-        AbstractConfigValue call() throws NotPossibleToResolve, NeedsFullResolve;
+        AbstractConfigValue call() throws NotPossibleToResolve;
     }
 
     AbstractConfigValue traversing(ConfigSubstitution value, SubstitutionExpression subst,
-            Resolver callable) throws NotPossibleToResolve, NeedsFullResolve {
+            Resolver callable) throws NotPossibleToResolve {
         try {
             traverse(value, subst);
         } catch (SelfReferential e) {

File: config/src/main/java/com/typesafe/config/impl/ResolveContext.java
Patch:
@@ -17,7 +17,7 @@
 
 final class ResolveContext {
     // Resolves that we have already begun (for cycle detection).
-    // SubstitutionResolve separately memoizes completed resolves.
+    // SubstitutionResolver separately memoizes completed resolves.
     // this set is unfortunately mutable and the user of ResolveContext
     // has to be sure it's only shared between ResolveContext that
     // are in the same traversal.

File: config/src/main/java/com/typesafe/config/impl/ConfigSubstitution.java
Patch:
@@ -23,6 +23,8 @@
 final class ConfigSubstitution extends AbstractConfigValue implements
         Unmergeable {
 
+    private static final long serialVersionUID = 1L;
+
     // this is a list of String and SubstitutionExpression where the
     // SubstitutionExpression has to be resolved to values, then if there's more
     // than one piece everything is stringified and concatenated

File: config/src/main/java/com/typesafe/config/ConfigFactory.java
Patch:
@@ -161,8 +161,8 @@ private static Config loadDefaultConfig() {
      * used rather than the default
      * <code>application.{conf,json,properties}</code> classpath resources.
      * These system properties should not be set in code (after all, you can
-     * just parse whatever you want manually and then use {@link #load(Config)
-     * if you don't want to use <code>application.conf</code>}). The properties
+     * just parse whatever you want manually and then use {@link #load(Config)}
+     * if you don't want to use <code>application.conf</code>). The properties
      * are intended for use by the person or script launching the application.
      * For example someone might have a <code>production.conf</code> that
      * include <code>application.conf</code> but then change a couple of values.

File: config/src/main/java/com/typesafe/config/ConfigException.java
Patch:
@@ -339,6 +339,9 @@ private static String makeMessage(Iterable<ValidationProblem> problems) {
                 sb.append(p.problem());
                 sb.append(", ");
             }
+            if (sb.length() == 0)
+                throw new ConfigException.BugOrBroken(
+                        "ValidationFailed must have a non-empty list of problems");
             sb.setLength(sb.length() - 2); // chop comma and space
 
             return sb.toString();

File: config/src/main/java/com/typesafe/config/impl/Tokenizer.java
Patch:
@@ -479,8 +479,9 @@ private Token pullNextToken(WhitespaceSaver saver) throws ProblemException {
                 return Tokens.END;
             } else if (c == '\n') {
                 // newline tokens have the just-ended line number
+                Token line = Tokens.newLine(lineOrigin()); // uses lineNumber
                 lineNumber += 1;
-                return Tokens.newLine(lineNumber - 1);
+                return line;
             } else {
                 Token t = null;
                 switch (c) {

File: config/src/main/java/com/typesafe/config/impl/TokenType.java
Patch:
@@ -17,5 +17,5 @@ enum TokenType {
     NEWLINE,
     UNQUOTED_TEXT,
     SUBSTITUTION,
-    RESERVED_CHAR;
+    PROBLEM;
 }

File: config/src/main/java/com/typesafe/config/impl/Tokenizer.java
Patch:
@@ -482,9 +482,7 @@ private Token pullNextToken(WhitespaceSaver saver) {
                     if (firstNumberChars.indexOf(c) >= 0) {
                         t = pullNumber(c);
                     } else if (notInUnquotedText.indexOf(c) >= 0) {
-                        throw parseError(String
-                                .format("Character '%c' is not the start of any valid token",
-                                        c));
+                        t = Tokens.newReservedChar(lineOrigin(), c);
                     } else {
                         putBack(c);
                         t = pullUnquotedText();

File: config/src/main/java/com/typesafe/config/impl/SimpleConfigList.java
Patch:
@@ -173,7 +173,7 @@ public boolean containsAll(Collection<?> c) {
     }
 
     @Override
-    public ConfigValue get(int index) {
+    public AbstractConfigValue get(int index) {
         return value.get(index);
     }
 

File: config/src/main/java/com/typesafe/config/impl/Parser.java
Patch:
@@ -110,7 +110,8 @@ private boolean checkElementSeparator() {
                 Token t = nextToken();
                 while (true) {
                     if (Tokens.isNewline(t)) {
-                        lineNumber = Tokens.getLineNumber(t);
+                        // newline number is the line just ended, so add one
+                        lineNumber = Tokens.getLineNumber(t) + 1;
                         sawSeparatorOrNewline = true;
                         // we want to continue to also eat
                         // a comma if there is one.

File: src/main/java/com/typesafe/config/impl/Parseable.java
Patch:
@@ -439,7 +439,7 @@ ConfigSyntax guessSyntax() {
         @Override
         ConfigParseable relativeTo(String filename) {
             // not using File.isAbsolute because resource paths always use '/'
-            // (?)
+            // on all platforms
             if (filename.startsWith("/"))
                 return null;
 
@@ -450,7 +450,7 @@ ConfigParseable relativeTo(String filename) {
             // search a classpath.
             File parent = new File(resource).getParentFile();
             if (parent == null)
-                return newResource(klass, "/" + filename, options()
+                return newResource(klass, filename, options()
                         .setOriginDescription(null));
             else
                 return newResource(klass, new File(parent, filename).getPath(),

File: src/main/java/com/typesafe/config/impl/RootConfig.java
Patch:
@@ -35,14 +35,14 @@ public RootConfig resolve(ConfigResolveOptions options) {
         // if the object is already resolved then we should end up returning
         // "this" here, since asRoot() should return this if the path
         // is unchanged.
-        SimpleConfig resolved = resolvedObject(options).toConfig();
-        return resolved.asRoot(rootPath);
+        AbstractConfigObject resolved = resolvedObject(options);
+        return newRootIfObjectChanged(this, resolved);
     }
 
     @Override
     public RootConfig withFallback(ConfigMergeable value) {
         // this can return "this" if the withFallback does nothing
-        return super.withFallback(value).asRoot(rootPath);
+        return newRootIfObjectChanged(this, super.withFallback(value).toObject());
     }
 
     Path rootPathObject() {

File: src/main/java/com/typesafe/config/impl/PropertiesParser.java
Patch:
@@ -180,11 +180,12 @@ public int compare(Path a, Path b) {
                     .get(parentPath) : root;
 
             AbstractConfigObject o = new SimpleConfigObject(origin, scope,
-                    ResolveStatus.RESOLVED);
+                    ResolveStatus.RESOLVED, false /* ignoresFallbacks */);
             parent.put(scopePath.last(), o);
         }
 
         // return root config object
-        return new SimpleConfigObject(origin, root, ResolveStatus.RESOLVED);
+        return new SimpleConfigObject(origin, root, ResolveStatus.RESOLVED,
+                false /* ignoresFallbacks */);
     }
 }

File: src/main/java/com/typesafe/config/impl/Tokenizer.java
Patch:
@@ -297,7 +297,8 @@ private Token pullNumber(int firstChar) {
                 }
             } catch (NumberFormatException e) {
                 throw parseError("Invalid number: '" + s
-                        + "' (if this is in a path, try quoting it)", e);
+                                + "' (if this is in a path, try quoting it with double quotes)",
+                        e);
             }
         }
 

File: src/main/java/com/typesafe/config/impl/Tokenizer.java
Patch:
@@ -95,7 +95,7 @@ private Token nextIsASimpleValue(ConfigOrigin baseOrigin,
             this.input = input;
             this.allowComments = allowComments;
             this.buffer = new LinkedList<Integer>();
-            lineNumber = 0;
+            lineNumber = 1;
             tokens = new LinkedList<Token>();
             tokens.add(Tokens.START);
             whitespaceSaver = new WhitespaceSaver();

File: src/main/java/com/typesafe/config/impl/DefaultTransformer.java
Patch:
@@ -5,10 +5,9 @@
 /**
  * Default automatic type transformations.
  */
-final class DefaultTransformer implements ConfigTransformer {
+final class DefaultTransformer {
 
-    @Override
-    public AbstractConfigValue transform(AbstractConfigValue value,
+    static AbstractConfigValue transform(AbstractConfigValue value,
             ConfigValueType requested) {
         if (value.valueType() == ConfigValueType.STRING) {
             String s = (String) value.unwrapped();

File: src/main/java/com/typesafe/config/impl/Parser.java
Patch:
@@ -711,6 +711,8 @@ private static void appendPathString(PathBuilder pb, String s) {
     // we just have something like "foo" or "foo.bar"
     private static Path speculativeFastParsePath(String path) {
         String s = ConfigUtil.unicodeTrim(path);
+        if (s.isEmpty())
+            return null;
         if (hasUnsafeChars(s))
             return null;
         if (s.startsWith(".") || s.endsWith(".") || s.contains(".."))

File: src/main/java/com/typesafe/config/impl/ConfigUtil.java
Patch:
@@ -79,7 +79,7 @@ public static String unicodeTrim(String s) {
             return s;
 
         int start = 0;
-        while (true) {
+        while (start < length) {
             char c = s.charAt(start);
             if (c == ' ' || c == '\n') {
                 start += 1;
@@ -93,7 +93,7 @@ public static String unicodeTrim(String s) {
         }
 
         int end = length;
-        while (true) {
+        while (end > start) {
             char c = s.charAt(end - 1);
             if (c == ' ' || c == '\n') {
                 --end;

File: src/main/java/com/typesafe/config/Config.java
Patch:
@@ -236,8 +236,8 @@ public static long parseDuration(String input,
                 return (long) (Double.parseDouble(numberString) * nanosInUnit);
             }
         } catch (NumberFormatException e) {
-            throw new ConfigException.BadValue(originForException, pathForException,
- "Could not parse duration number '"
+            throw new ConfigException.BadValue(originForException,
+                    pathForException, "Could not parse duration number '"
                             + numberString + "'");
         }
     }

File: src/main/java/com/typesafe/config/ConfigObject.java
Patch:
@@ -35,6 +35,9 @@ public interface ConfigObject extends ConfigValue, Map<String, ConfigValue> {
     @Override
     ConfigObject withFallback(ConfigValue other);
 
+    @Override
+    ConfigObject withFallbacks(ConfigValue... others);
+
     boolean getBoolean(String path);
 
     Number getNumber(String path);

File: src/main/java/com/typesafe/config/impl/SimpleConfigList.java
Patch:
@@ -9,6 +9,7 @@
 import com.typesafe.config.ConfigException;
 import com.typesafe.config.ConfigList;
 import com.typesafe.config.ConfigOrigin;
+import com.typesafe.config.ConfigResolveOptions;
 import com.typesafe.config.ConfigValue;
 import com.typesafe.config.ConfigValueType;
 
@@ -84,14 +85,14 @@ private SimpleConfigList modify(Modifier modifier,
 
     @Override
     SimpleConfigList resolveSubstitutions(final SubstitutionResolver resolver,
-            final int depth, final boolean withFallbacks) {
+            final int depth, final ConfigResolveOptions options) {
         if (resolved)
             return this;
 
         return modify(new Modifier() {
             @Override
             public AbstractConfigValue modifyChild(AbstractConfigValue v) {
-                return resolver.resolve(v, depth, withFallbacks);
+                return resolver.resolve(v, depth, options);
             }
 
         }, ResolveStatus.RESOLVED);

File: src/main/java/com/typesafe/config/impl/Tokenizer.java
Patch:
@@ -10,14 +10,15 @@
 
 import com.typesafe.config.ConfigException;
 import com.typesafe.config.ConfigOrigin;
+import com.typesafe.config.ConfigSyntax;
 
 final class Tokenizer {
     /**
      * Tokenizes a Reader. Does not close the reader; you have to arrange to do
      * that after you're done with the returned iterator.
      */
-    static Iterator<Token> tokenize(ConfigOrigin origin, Reader input, SyntaxFlavor flavor) {
-        return new TokenIterator(origin, input, flavor != SyntaxFlavor.JSON);
+    static Iterator<Token> tokenize(ConfigOrigin origin, Reader input, ConfigSyntax flavor) {
+        return new TokenIterator(origin, input, flavor != ConfigSyntax.JSON);
     }
 
     private static class TokenIterator implements Iterator<Token> {

File: src/main/java/com/typesafe/config/impl/DefaultTransformer.java
Patch:
@@ -16,13 +16,13 @@ public AbstractConfigValue transform(AbstractConfigValue value,
             case NUMBER:
                 try {
                     Long v = Long.parseLong(s);
-                    return new ConfigLong(value.origin(), v);
+                    return new ConfigLong(value.origin(), v, s);
                 } catch (NumberFormatException e) {
                     // try Double
                 }
                 try {
                     Double v = Double.parseDouble(s);
-                    return new ConfigDouble(value.origin(), v);
+                    return new ConfigDouble(value.origin(), v, s);
                 } catch (NumberFormatException e) {
                     // oh well.
                 }

File: src/main/java/com/typesafe/config/impl/Tokenizer.java
Patch:
@@ -271,11 +271,11 @@ private Token pullNumber(int firstChar) {
             try {
                 if (containedDecimalOrE) {
                     // force floating point representation
-                    return Tokens
-                            .newDouble(lineOrigin(), Double.parseDouble(s));
+                    return Tokens.newDouble(lineOrigin(),
+                            Double.parseDouble(s), s);
                 } else {
                     // this should throw if the integer is too large for Long
-                    return Tokens.newLong(lineOrigin(), Long.parseLong(s));
+                    return Tokens.newLong(lineOrigin(), Long.parseLong(s), s);
                 }
             } catch (NumberFormatException e) {
                 throw parseError("Invalid number: '" + s

File: src/main/java/com/typesafe/config/impl/AbstractConfigObject.java
Patch:
@@ -305,15 +305,15 @@ AbstractConfigObject resolveSubstitutions(SubstitutionResolver resolver,
     }
 
     @Override
-    public ConfigValue get(Object key) {
+    public AbstractConfigValue get(Object key) {
         if (key instanceof String)
             return peek((String) key);
         else
             return null;
     }
 
     @Override
-    public ConfigValue getValue(String path) {
+    public AbstractConfigValue getValue(String path) {
         return find(path, null, path);
     }
 

File: src/main/java/com/typesafe/config/impl/ConfigImpl.java
Patch:
@@ -128,6 +128,6 @@ private static AbstractConfigObject loadEnvVariables() {
                     new SimpleConfigOrigin("env var " + key), entry.getValue()));
         }
         return new SimpleConfigObject(new SimpleConfigOrigin("env variables"),
-                m);
+                m, ResolveStatus.RESOLVED);
     }
 }

File: src/main/java/com/typesafe/config/impl/ConfigDelayedMerge.java
Patch:
@@ -82,8 +82,7 @@ static AbstractConfigValue resolveSubstitutions(
             }
         }
 
-        return AbstractConfigObject.merge(toMerge.get(0).origin(), toMerge,
-                toMerge.get(0).transformer);
+        return AbstractConfigObject.merge(toMerge);
     }
 
     @Override
@@ -98,7 +97,8 @@ public AbstractConfigValue withFallback(ConfigValue other) {
                 newStack.addAll(((Unresolved) other).unmergedValues());
             else
                 newStack.add((AbstractConfigValue) other);
-            return new ConfigDelayedMerge(origin(), newStack);
+            return new ConfigDelayedMerge(
+                    AbstractConfigObject.mergeOrigins(newStack), newStack);
         } else {
             // if the other is not an object, there won't be anything
             // to merge with, so we are it even if we are an object.

File: src/main/java/com/typesafe/config/impl/ConfigSubstitution.java
Patch:
@@ -53,7 +53,8 @@ public AbstractConfigValue withFallback(ConfigValue other) {
                 newStack.addAll(((Unresolved) other).unmergedValues());
             else
                 newStack.add((AbstractConfigValue) other);
-            return new ConfigDelayedMerge(origin(), newStack);
+            return new ConfigDelayedMerge(
+                    AbstractConfigObject.mergeOrigins(newStack), newStack);
         } else {
             // if the other is not an object, there won't be anything
             // to merge with, so we are it even if we are an object.

File: src/main/java/com/typesafe/config/impl/Parser.java
Patch:
@@ -319,7 +319,8 @@ private AbstractConfigObject parseObject() {
                             + t);
                 }
             }
-            return new SimpleConfigObject(objectOrigin, null, values);
+            return new SimpleConfigObject(objectOrigin,
+                    ConfigImpl.defaultConfigTransformer(), values);
         }
 
         private SimpleConfigList parseArray() {

File: src/main/java/com/typesafe/config/impl/Tokenizer.java
Patch:
@@ -253,7 +253,8 @@ private Token pullNumber(int firstChar) {
                     return Tokens.newLong(lineOrigin(), Long.parseLong(s));
                 }
             } catch (NumberFormatException e) {
-                throw parseError("Invalid number", e);
+                throw parseError("Invalid number: '" + s
+                        + "' (if this is in a path, try quoting it)", e);
             }
         }
 

File: src/main/java/com/typesafe/config/impl/AbstractConfigObject.java
Patch:
@@ -25,9 +25,6 @@ protected AbstractConfigObject(ConfigOrigin origin,
         this.transformer = transformer;
     }
 
-    @Override
-    abstract public Map<String, Object> unwrapped();
-
     /**
      * This looks up the key with no transformation or type conversion of any
      * kind, and returns null if the key is not present.

File: src/main/java/com/typesafe/config/ConfigObject.java
Patch:
@@ -90,6 +90,8 @@ public interface ConfigObject extends ConfigValue {
 
     List<Double> getDoubleList(String path);
 
+    List<String> getStringList(String path);
+
     List<? extends ConfigObject> getObjectList(String path);
 
     List<? extends Object> getAnyList(String path);

File: src/main/java/com/typesafe/config/Config.java
Patch:
@@ -100,7 +100,7 @@ public static long parseDuration(String input,
                 return units.toNanos(Long.parseLong(numberString));
             } else {
                 long nanosInUnit = units.toNanos(1);
-                return (new Double(Double.parseDouble(numberString) * nanosInUnit)).longValue();
+                return (long) (Double.parseDouble(numberString) * nanosInUnit);
             }
         } catch (NumberFormatException e) {
             throw new ConfigException.BadValue(originForException, pathForException,
@@ -175,8 +175,7 @@ public static long parseMemorySize(String input,
             if (numberString.matches("[0-9]+")) {
                 return Long.parseLong(numberString) * units.bytes;
             } else {
-                return (new Double(Double.parseDouble(numberString)
-                        * units.bytes)).longValue();
+                return (long) (Double.parseDouble(numberString) * units.bytes);
             }
         } catch (NumberFormatException e) {
             throw new ConfigException.BadValue(originForException,

File: src/main/java/com/typesafe/config/impl/ConfigImpl.java
Patch:
@@ -174,9 +174,10 @@ synchronized static AbstractConfigObject envVariablesConfig() {
     private static AbstractConfigObject loadEnvVariables() {
         Map<String, String> env = System.getenv();
         Map<String, AbstractConfigValue> m = new HashMap<String, AbstractConfigValue>();
-        for (String key : env.keySet()) {
+        for (Map.Entry<String, String> entry : env.entrySet()) {
+            String key = entry.getKey();
             m.put(key, new ConfigString(
-                    new SimpleConfigOrigin("env var " + key), env.get(key)));
+                    new SimpleConfigOrigin("env var " + key), entry.getValue()));
         }
         return new SimpleConfigObject(new SimpleConfigOrigin("env variables"),
                 defaultConfigTransformer(), m);

File: src/main/java/com/typesafe/config/impl/Substitution.java
Patch:
@@ -26,7 +26,8 @@ boolean isPath() {
     public boolean equals(Object other) {
         if (other instanceof Substitution) {
             Substitution that = (Substitution) other;
-            return this.reference == that.reference && this.style == that.style;
+            return this.reference.equals(that.reference)
+                    && this.style == that.style;
         } else {
             return false;
         }

File: src/main/java/com/typesafe/config/impl/Tokens.java
Patch:
@@ -170,7 +170,7 @@ public boolean equals(Object other) {
         @Override
         public int hashCode() {
             return 41 * (41 * (41 + super.hashCode()) + value.hashCode())
-                    + new Boolean(isPath()).hashCode();
+                    + Boolean.valueOf(isPath()).hashCode();
         }
     }
 

File: src/main/java/com/typesafe/config/impl/ConfigInt.java
Patch:
@@ -22,6 +22,7 @@ public Integer unwrapped() {
         return value;
     }
 
+    @Override
     protected boolean canEqual(Object other) {
         return other instanceof ConfigInt || other instanceof ConfigLong;
     }
@@ -33,7 +34,7 @@ public boolean equals(Object other) {
             return this.value == ((ConfigInt) other).value;
         } else if (other instanceof ConfigLong) {
             Long l = ((ConfigLong) other).unwrapped();
-            return ((long) l.intValue()) == l && this.value == l.intValue();
+            return l.intValue() == l && this.value == l.intValue();
         } else {
             return false;
         }

File: src/main/java/com/typesafe/config/impl/ConfigList.java
Patch:
@@ -72,6 +72,7 @@ ConfigList resolveSubstitutions(SubstitutionResolver resolver, int depth,
         }
     }
 
+    @Override
     protected boolean canEqual(Object other) {
         return other instanceof ConfigList;
     }

File: src/main/java/com/typesafe/config/impl/ConfigLong.java
Patch:
@@ -22,6 +22,7 @@ public Long unwrapped() {
         return value;
     }
 
+    @Override
     protected boolean canEqual(Object other) {
         return other instanceof ConfigInt || other instanceof ConfigLong;
     }
@@ -33,7 +34,7 @@ public boolean equals(Object other) {
             return this.value == ((ConfigLong) other).value;
         } else if (other instanceof ConfigInt) {
             Long l = this.unwrapped();
-            return ((long) l.intValue()) == l
+            return l.intValue() == l
                     && ((ConfigInt) other).unwrapped() == l.intValue();
         } else {
             return false;

File: src/main/java/com/typesafe/config/impl/ConfigSubstitution.java
Patch:
@@ -133,6 +133,7 @@ AbstractConfigValue resolveSubstitutions(SubstitutionResolver resolver,
         return resolved;
     }
 
+    @Override
     protected boolean canEqual(Object other) {
         return other instanceof ConfigSubstitution;
     }

File: src/main/java/com/typesafe/config/impl/SimpleConfigObject.java
Patch:
@@ -70,6 +70,7 @@ private static int mapHash(Map<String, AbstractConfigValue> m) {
         return 41 * (41 + keys.hashCode()) + valuesHash;
     }
 
+    @Override
     protected boolean canEqual(Object other) {
         return other instanceof ConfigObject;
     }

