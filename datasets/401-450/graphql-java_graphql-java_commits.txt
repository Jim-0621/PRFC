File: src/test/groovy/readme/DirectivesExamples.java
Patch:
@@ -39,7 +39,7 @@ class AuthorisationDirective implements SchemaDirectiveWiring {
 
         @Override
         public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment<GraphQLFieldDefinition> environment) {
-            String targetAuthRole = (String) environment.getDirective().getArgument("role").getArgumentValue().getValue();
+            String targetAuthRole = (String) environment.getAppliedDirective().getArgument("role").getArgumentValue().getValue();
 
             //
             // build a data fetcher that first checks authorisation roles before then calling the original data fetcher

File: src/test/groovy/readme/DirectivesExamples.java
Patch:
@@ -48,8 +48,7 @@ public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment<GraphQLFi
             DataFetcher authDataFetcher = new DataFetcher() {
                 @Override
                 public Object get(DataFetchingEnvironment dataFetchingEnvironment) throws Exception {
-                    Map<String, Object> contextMap = dataFetchingEnvironment.getContext();
-                    AuthorisationCtx authContext = (AuthorisationCtx) contextMap.get("authContext");
+                    AuthorisationCtx authContext = dataFetchingEnvironment.getGraphQlContext().get("authContext");
 
                     if (authContext.hasRole(targetAuthRole)) {
                         return originalDataFetcher.get(dataFetchingEnvironment);
@@ -83,7 +82,7 @@ void contextWiring() {
 
         ExecutionInput executionInput = ExecutionInput.newExecutionInput()
                 .query(query)
-                .graphQLContext(builder -> builder.put("authCtx", authCtx))
+                .graphQLContext(builder -> builder.put("authContext", authCtx))
                 .build();
     }
 

File: src/main/java/graphql/GraphqlErrorHelper.java
Patch:
@@ -57,6 +57,9 @@ public static Object locations(List<SourceLocation> locations) {
     /**
      *  Positive integers starting from 1 required for error locations,
      *  from the spec <a href="https://spec.graphql.org/draft/#sec-Errors.Error-Result-Format">...</a>
+     *
+     * @param location the source location in play
+     * @return  a value for source location of the error
      */
     public static Object location(SourceLocation location) {
         int line = location.getLine();

File: src/main/java/graphql/parser/ParserOptions.java
Patch:
@@ -302,6 +302,8 @@ public int getMaxRuleDepth() {
     /**
      * Option to redact offending tokens in parser error messages.
      * By default, the parser will include the offending token in the error message, if possible.
+     *
+     * @return true if the token parser messages should be redacted
      */
     public boolean isRedactTokenParserErrorMessages() {
         return redactTokenParserErrorMessages;

File: src/main/java/graphql/execution/ResultPath.java
Patch:
@@ -149,8 +149,10 @@ public static ResultPath fromList(List<?> objects) {
         for (Object object : objects) {
             if (object instanceof String) {
                 path = path.segment(((String) object));
-            } else {
+            } else if (object instanceof Integer) {
                 path = path.segment((int) object);
+            } else if (object != null) {
+                path = path.segment(object.toString());
             }
         }
         return path;

File: src/main/java/graphql/schema/GraphQLCodeRegistry.java
Patch:
@@ -84,6 +84,7 @@ public boolean hasDataFetcher(FieldCoordinates coordinates) {
         return hasDataFetcherImpl(coordinates, dataFetcherMap, systemDataFetcherMap);
     }
 
+    @SuppressWarnings("deprecation")
     private static DataFetcher<?> getDataFetcherImpl(FieldCoordinates coordinates, GraphQLFieldDefinition fieldDefinition, Map<FieldCoordinates, DataFetcherFactory<?>> dataFetcherMap, Map<String, DataFetcherFactory<?>> systemDataFetcherMap, DataFetcherFactory<?> defaultDataFetcherFactory) {
         assertNotNull(coordinates);
         assertNotNull(fieldDefinition);
@@ -96,7 +97,7 @@ private static DataFetcher<?> getDataFetcherImpl(FieldCoordinates coordinates, G
             }
         }
         // call direct from the field - cheaper to not make a new environment object
-        DataFetcher<?> dataFetcher = dataFetcherFactory.getViaField(fieldDefinition);
+        DataFetcher<?> dataFetcher = dataFetcherFactory.get(fieldDefinition);
         if (dataFetcher == null) {
             DataFetcherFactoryEnvironment factoryEnvironment = newDataFetchingFactoryEnvironment()
                     .fieldDefinition(fieldDefinition)

File: src/main/java/graphql/schema/GraphQLCodeRegistry.java
Patch:
@@ -155,7 +155,7 @@ private static TypeResolver getTypeResolverForUnion(GraphQLUnionType parentType,
         if (typeResolver == null) {
             typeResolver = parentType.getTypeResolver();
         }
-        return assertNotNull(typeResolver, "There must be a type resolver for union %s",parentType.getName());
+        return assertNotNull(typeResolver, "There must be a type resolver for union %s", parentType.getName());
     }
 
     /**
@@ -195,7 +195,7 @@ public static class Builder {
         private final Map<String, DataFetcherFactory<?>> systemDataFetcherMap = new LinkedHashMap<>();
         private final Map<String, TypeResolver> typeResolverMap = new HashMap<>();
         private GraphqlFieldVisibility fieldVisibility = DEFAULT_FIELD_VISIBILITY;
-        private DataFetcherFactory<?> defaultDataFetcherFactory = PropertyDataFetcher.singletonFactory();
+        private DataFetcherFactory<?> defaultDataFetcherFactory = SingletonPropertyDataFetcher.singletonFactory();
         private boolean changed = false;
 
         private Builder() {

File: src/main/java/graphql/schema/idl/MockedWiringFactory.java
Patch:
@@ -8,6 +8,7 @@
 import graphql.schema.DataFetcher;
 import graphql.schema.GraphQLScalarType;
 import graphql.schema.PropertyDataFetcher;
+import graphql.schema.SingletonPropertyDataFetcher;
 import graphql.schema.TypeResolver;
 
 @PublicApi
@@ -44,7 +45,7 @@ public boolean providesDataFetcher(FieldWiringEnvironment environment) {
 
     @Override
     public DataFetcher getDataFetcher(FieldWiringEnvironment environment) {
-        return PropertyDataFetcher.singleton();
+        return SingletonPropertyDataFetcher.singleton();
     }
 
     @Override

File: src/main/java/graphql/schema/idl/SchemaGeneratorHelper.java
Patch:
@@ -57,6 +57,7 @@
 import graphql.schema.GraphQLUnionType;
 import graphql.schema.GraphqlTypeComparatorRegistry;
 import graphql.schema.PropertyDataFetcher;
+import graphql.schema.SingletonPropertyDataFetcher;
 import graphql.schema.TypeResolver;
 import graphql.schema.TypeResolverProxy;
 import graphql.schema.idl.errors.NotAnInputTypeError;
@@ -1094,7 +1095,7 @@ private Optional<OperationTypeDefinition> getOperationNamed(String name, Map<Str
     }
 
     private DataFetcher<?> dataFetcherOfLastResort() {
-        return PropertyDataFetcher.singleton();
+        return SingletonPropertyDataFetcher.singleton();
     }
 
     private List<Directive> directivesOf(List<? extends TypeDefinition<?>> typeDefinitions) {

File: src/main/java/graphql/schema/GraphQLCodeRegistry.java
Patch:
@@ -149,7 +149,7 @@ private static TypeResolver getTypeResolverForUnion(GraphQLUnionType parentType,
         if (typeResolver == null) {
             typeResolver = parentType.getTypeResolver();
         }
-        return assertNotNull(typeResolver, "There must be a type resolver for union %s",parentType.getName());
+        return assertNotNull(typeResolver, "There must be a type resolver for union %s", parentType.getName());
     }
 
     /**
@@ -189,7 +189,7 @@ public static class Builder {
         private final Map<String, DataFetcherFactory<?>> systemDataFetcherMap = new LinkedHashMap<>();
         private final Map<String, TypeResolver> typeResolverMap = new HashMap<>();
         private GraphqlFieldVisibility fieldVisibility = DEFAULT_FIELD_VISIBILITY;
-        private DataFetcherFactory<?> defaultDataFetcherFactory = PropertyDataFetcher.singletonFactory();
+        private DataFetcherFactory<?> defaultDataFetcherFactory = SingletonPropertyDataFetcher.singletonFactory();
         private boolean changed = false;
 
         private Builder() {

File: src/main/java/graphql/schema/idl/MockedWiringFactory.java
Patch:
@@ -8,6 +8,7 @@
 import graphql.schema.DataFetcher;
 import graphql.schema.GraphQLScalarType;
 import graphql.schema.PropertyDataFetcher;
+import graphql.schema.SingletonPropertyDataFetcher;
 import graphql.schema.TypeResolver;
 
 @PublicApi
@@ -44,7 +45,7 @@ public boolean providesDataFetcher(FieldWiringEnvironment environment) {
 
     @Override
     public DataFetcher getDataFetcher(FieldWiringEnvironment environment) {
-        return PropertyDataFetcher.singleton();
+        return SingletonPropertyDataFetcher.singleton();
     }
 
     @Override

File: src/main/java/graphql/schema/idl/SchemaGeneratorHelper.java
Patch:
@@ -57,6 +57,7 @@
 import graphql.schema.GraphQLUnionType;
 import graphql.schema.GraphqlTypeComparatorRegistry;
 import graphql.schema.PropertyDataFetcher;
+import graphql.schema.SingletonPropertyDataFetcher;
 import graphql.schema.TypeResolver;
 import graphql.schema.TypeResolverProxy;
 import graphql.schema.idl.errors.NotAnInputTypeError;
@@ -1088,7 +1089,7 @@ private Optional<OperationTypeDefinition> getOperationNamed(String name, Map<Str
     }
 
     private DataFetcher<?> dataFetcherOfLastResort() {
-        return PropertyDataFetcher.singleton();
+        return SingletonPropertyDataFetcher.singleton();
     }
 
     private List<Directive> directivesOf(List<? extends TypeDefinition<?>> typeDefinitions) {

File: src/main/java/graphql/schema/idl/MockedWiringFactory.java
Patch:
@@ -44,7 +44,7 @@ public boolean providesDataFetcher(FieldWiringEnvironment environment) {
 
     @Override
     public DataFetcher getDataFetcher(FieldWiringEnvironment environment) {
-        return new PropertyDataFetcher(environment.getFieldDefinition().getName());
+        return PropertyDataFetcher.singleton();
     }
 
     @Override

File: src/main/java/graphql/schema/GraphQLCodeRegistry.java
Patch:
@@ -189,7 +189,7 @@ public static class Builder {
         private final Map<String, DataFetcherFactory<?>> systemDataFetcherMap = new LinkedHashMap<>();
         private final Map<String, TypeResolver> typeResolverMap = new HashMap<>();
         private GraphqlFieldVisibility fieldVisibility = DEFAULT_FIELD_VISIBILITY;
-        private DataFetcherFactory<?> defaultDataFetcherFactory = env -> PropertyDataFetcher.fetching(env.getFieldDefinition().getName());
+        private DataFetcherFactory<?> defaultDataFetcherFactory = PropertyDataFetcher.singletonFactory();
         private boolean changed = false;
 
         private Builder() {

File: src/main/java/graphql/language/InterfaceTypeDefinition.java
Patch:
@@ -21,7 +21,7 @@
 import static graphql.language.NodeChildrenContainer.newNodeChildrenContainer;
 
 @PublicApi
-public class InterfaceTypeDefinition extends AbstractDescribedNode<InterfaceTypeDefinition> implements ImplementingTypeDefinition<InterfaceTypeDefinition>, DirectivesContainer<InterfaceTypeDefinition>, NamedNode<InterfaceTypeDefinition>, SDLExtensionDefinition {
+public class InterfaceTypeDefinition extends AbstractDescribedNode<InterfaceTypeDefinition> implements ImplementingTypeDefinition<InterfaceTypeDefinition>, DirectivesContainer<InterfaceTypeDefinition>, NamedNode<InterfaceTypeDefinition> {
 
     private final String name;
     private final ImmutableList<Type> implementz;

File: src/main/java/graphql/language/InterfaceTypeExtensionDefinition.java
Patch:
@@ -14,7 +14,7 @@
 import static graphql.collect.ImmutableKit.emptyList;
 
 @PublicApi
-public class InterfaceTypeExtensionDefinition extends InterfaceTypeDefinition {
+public class InterfaceTypeExtensionDefinition extends InterfaceTypeDefinition implements SDLExtensionDefinition {
 
     @Internal
     protected InterfaceTypeExtensionDefinition(String name,

File: src/main/java/graphql/language/InterfaceTypeDefinition.java
Patch:
@@ -21,7 +21,7 @@
 import static graphql.language.NodeChildrenContainer.newNodeChildrenContainer;
 
 @PublicApi
-public class InterfaceTypeDefinition extends AbstractDescribedNode<InterfaceTypeDefinition> implements ImplementingTypeDefinition<InterfaceTypeDefinition>, DirectivesContainer<InterfaceTypeDefinition>, NamedNode<InterfaceTypeDefinition>, SDLExtensionDefinition {
+public class InterfaceTypeDefinition extends AbstractDescribedNode<InterfaceTypeDefinition> implements ImplementingTypeDefinition<InterfaceTypeDefinition>, DirectivesContainer<InterfaceTypeDefinition>, NamedNode<InterfaceTypeDefinition> {
 
     private final String name;
     private final ImmutableList<Type> implementz;

File: src/main/java/graphql/schema/diffing/SchemaDiffing.java
Patch:
@@ -96,15 +96,17 @@ private DiffImpl.OptimalEdit diffImpl(SchemaGraph sourceGraph, SchemaGraph targe
             Multimaps.invertFrom(possibleMappings.possibleMappings, invertedPossibleOnes);
             possibleMappings.possibleMappings = invertedPossibleOnes;
 
+            sortVertices(nonMappedTarget, targetGraph, possibleMappings);
+
             List<Vertex> sourceVertices = new ArrayList<>();
             sourceVertices.addAll(possibleMappings.fixedOneToOneSources);
             sourceVertices.addAll(nonMappedSource);
 
+
             List<Vertex> targetVertices = new ArrayList<>();
             targetVertices.addAll(possibleMappings.fixedOneToOneTargets);
             targetVertices.addAll(nonMappedTarget);
 
-            sortVertices(nonMappedTarget, targetGraph, possibleMappings);
 
             DiffImpl diffImpl = new DiffImpl(possibleMappingsCalculator, targetGraph, sourceGraph, possibleMappings, runningCheck);
             DiffImpl.OptimalEdit optimalEdit = diffImpl.diffImpl(startMappingInverted, targetVertices, sourceVertices, algoIterationCount);

File: src/main/java/graphql/execution/ExecutionContext.java
Patch:
@@ -86,6 +86,7 @@ public class ExecutionContext {
         this.errors.set(builder.errors);
         this.localContext = builder.localContext;
         this.executionInput = builder.executionInput;
+        this.dataLoaderDispatcherStrategy = builder.dataLoaderDispatcherStrategy;
         this.queryTree = FpKit.interThreadMemoize(() -> ExecutableNormalizedOperationFactory.createExecutableNormalizedOperation(graphQLSchema, operationDefinition, fragmentsByName, coercedVariables));
     }
 

File: src/main/java/graphql/execution/ExecutionContext.java
Patch:
@@ -86,6 +86,7 @@ public class ExecutionContext {
         this.errors.set(builder.errors);
         this.localContext = builder.localContext;
         this.executionInput = builder.executionInput;
+        this.dataLoaderDispatcherStrategy = builder.dataLoaderDispatcherStrategy;
         this.queryTree = FpKit.interThreadMemoize(() -> ExecutableNormalizedOperationFactory.createExecutableNormalizedOperation(graphQLSchema, operationDefinition, fragmentsByName, coercedVariables));
     }
 

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -1153,15 +1153,15 @@ private static Supplier<ImmutableMapWithNullValues<String, Object>> getArgumentV
 
     // Errors that result from the execution of deferred fields are kept in the deferred context only.
     private static void addErrorToRightContext(GraphQLError error, ExecutionStrategyParameters parameters, ExecutionContext executionContext) {
-        if (parameters.getField() != null && parameters.getField().isDeferred()) {
+        if (parameters.getDeferredCallContext() != null) {
             parameters.getDeferredCallContext().addError(error);
         } else {
             executionContext.addError(error);
         }
     }
 
     private static void addErrorsToRightContext(List<GraphQLError> errors, ExecutionStrategyParameters parameters, ExecutionContext executionContext) {
-        if (parameters.getField() != null && parameters.getField().isDeferred()) {
+        if (parameters.getDeferredCallContext() != null) {
             parameters.getDeferredCallContext().addErrors(errors);
         } else {
             executionContext.addErrors(errors);

File: src/main/java/graphql/execution/NonNullableFieldValidator.java
Patch:
@@ -51,7 +51,7 @@ public <T> T validate(ExecutionStrategyParameters parameters, T result) throws N
 
                 NonNullableFieldWasNullException nonNullException = new NonNullableFieldWasNullException(executionStepInfo, path);
                 final GraphQLError error = new NonNullableFieldWasNullError(nonNullException);
-                if(parameters.getField() != null && parameters.getField().isDeferred()) {
+                if(parameters.getDeferredCallContext() != null) {
                     parameters.getDeferredCallContext().addError(error);
                 } else {
                     executionContext.addError(error, path);

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -619,7 +619,7 @@ String wrap(String start, String maybeString, String end) {
 
     private <T extends Node> String block(List<T> nodes) {
         if (isEmpty(nodes)) {
-            return "{}";
+            return "";
         }
         if (compactMode) {
             String joinedNodes = joinTight(nodes, " ", "", "");

File: src/main/java/graphql/parser/Parser.java
Patch:
@@ -301,7 +301,7 @@ public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int
                 String preview = AntlrHelper.createPreview(multiSourceReader, line);
                 String msgKey;
                 List<Object> args;
-                if (antlerMsg == null) {
+                if (antlerMsg == null || environment.getParserOptions().isRedactTokenParserErrorMessages()) {
                     msgKey = "InvalidSyntax.noMessage";
                     args = ImmutableList.of(sourceLocation.getLine(), sourceLocation.getColumn());
                 } else {

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -619,7 +619,7 @@ String wrap(String start, String maybeString, String end) {
 
     private <T extends Node> String block(List<T> nodes) {
         if (isEmpty(nodes)) {
-            return "{}";
+            return "";
         }
         if (compactMode) {
             String joinedNodes = joinTight(nodes, " ", "", "");

File: src/main/java/graphql/parser/Parser.java
Patch:
@@ -301,7 +301,7 @@ public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int
                 String preview = AntlrHelper.createPreview(multiSourceReader, line);
                 String msgKey;
                 List<Object> args;
-                if (antlerMsg == null) {
+                if (antlerMsg == null || environment.getParserOptions().isRedactTokenParserErrorMessages()) {
                     msgKey = "InvalidSyntax.noMessage";
                     args = ImmutableList.of(sourceLocation.getLine(), sourceLocation.getColumn());
                 } else {

File: src/main/java/graphql/schema/idl/errors/DirectiveIllegalArgumentTypeError.java
Patch:
@@ -16,7 +16,6 @@ public class DirectiveIllegalArgumentTypeError extends BaseError {
     public static final String NOT_A_VALID_SCALAR_LITERAL_MESSAGE = "Argument value is not a valid value of scalar '%s'.";
     public static final String MISSING_REQUIRED_FIELD_MESSAGE = "Missing required field '%s'.";
     public static final String EXPECTED_NON_NULL_MESSAGE = "Argument value is 'null', expected a non-null value.";
-    public static final String EXPECTED_LIST_MESSAGE = "Argument value is '%s', expected a list value.";
     public static final String EXPECTED_OBJECT_MESSAGE = "Argument value is of type '%s', expected an Object value.";
 
     public DirectiveIllegalArgumentTypeError(Node element, String elementName, String directiveName, String argumentName, String detailedMessaged) {

File: src/main/java/graphql/schema/idl/SchemaGeneratorHelper.java
Patch:
@@ -839,7 +839,7 @@ private DataFetcherFactory<?> buildDataFetcherFactory(BuildContext buildCtx,
                 dataFetcher = wiringFactory.getDataFetcher(wiringEnvironment);
                 assertNotNull(dataFetcher, () -> "The WiringFactory indicated it provides a data fetcher but then returned null");
             } else {
-                dataFetcher = runtimeWiring.getDataFetcherForType(parentTypeName).get(fieldName);
+                dataFetcher = runtimeWiring.getDataFetchersForType(parentTypeName).get(fieldName);
                 if (dataFetcher == null) {
                     dataFetcher = runtimeWiring.getDefaultDataFetcherForType(parentTypeName);
                     if (dataFetcher == null) {

File: src/main/java/graphql/schema/idl/TypeRuntimeWiring.java
Patch:
@@ -184,6 +184,9 @@ private void assertFieldStrictly(String fieldName) {
          */
         public Builder defaultDataFetcher(DataFetcher dataFetcher) {
             assertNotNull(dataFetcher);
+            if (strictMode && defaultDataFetcher != null) {
+                throw new StrictModeWiringException(format("The type %s has already has a default data fetcher defined", typeName));
+            }
             defaultDataFetcher = dataFetcher;
             return this;
         }

File: src/main/java/graphql/schema/validation/SchemaValidator.java
Patch:
@@ -26,6 +26,7 @@ public SchemaValidator() {
         rules.add(new AppliedDirectiveArgumentsAreValid());
         rules.add(new InputAndOutputTypesUsedAppropriately());
         rules.add(new OneOfInputObjectRules());
+        rules.add(new DeprecatedInputObjectAndArgumentsAreValid());
     }
 
     public List<GraphQLTypeVisitor> getRules() {

File: src/main/java/graphql/schema/idl/SchemaGeneratorHelper.java
Patch:
@@ -839,7 +839,7 @@ private DataFetcherFactory<?> buildDataFetcherFactory(BuildContext buildCtx,
                 dataFetcher = wiringFactory.getDataFetcher(wiringEnvironment);
                 assertNotNull(dataFetcher, () -> "The WiringFactory indicated it provides a data fetcher but then returned null");
             } else {
-                dataFetcher = runtimeWiring.getDataFetcherForType(parentTypeName).get(fieldName);
+                dataFetcher = runtimeWiring.getDataFetchersForType(parentTypeName).get(fieldName);
                 if (dataFetcher == null) {
                     dataFetcher = runtimeWiring.getDefaultDataFetcherForType(parentTypeName);
                     if (dataFetcher == null) {

File: src/main/java/graphql/schema/idl/TypeRuntimeWiring.java
Patch:
@@ -184,6 +184,9 @@ private void assertFieldStrictly(String fieldName) {
          */
         public Builder defaultDataFetcher(DataFetcher dataFetcher) {
             assertNotNull(dataFetcher);
+            if (strictMode && defaultDataFetcher != null) {
+                throw new StrictModeWiringException(format("The type %s has already has a default data fetcher defined", typeName));
+            }
             defaultDataFetcher = dataFetcher;
             return this;
         }

File: src/main/java/graphql/execution/reactive/CompletionStageOrderedSubscriber.java
Patch:
@@ -33,7 +33,7 @@ protected void whenNextFinished(CompletionStage<D> completionStage, D d, Throwab
             }
         } finally {
             boolean empty = inFlightQIsEmpty();
-            finallyAfterEachPromisesFinishes(empty);
+            finallyAfterEachPromiseFinishes(empty);
         }
     }
 

File: src/main/java/graphql/execution/reactive/CompletionStageSubscriber.java
Patch:
@@ -96,11 +96,11 @@ protected void whenNextFinished(CompletionStage<D> completionStage, D d, Throwab
             }
         } finally {
             boolean empty = removeFromInFlightQAndCheckIfEmpty(completionStage);
-            finallyAfterEachPromisesFinishes(empty);
+            finallyAfterEachPromiseFinishes(empty);
         }
     }
 
-    protected void finallyAfterEachPromisesFinishes(boolean isInFlightEmpty) {
+    protected void finallyAfterEachPromiseFinishes(boolean isInFlightEmpty) {
         //
         // if the runOnCompleteOrErrorRun runnable is set, the upstream has
         // called onComplete() already, but the CFs have not all completed

File: src/test/groovy/graphql/execution/reactive/tck/CompletionStageMappingPublisherRandomCompleteTckVerificationTest.java
Patch:
@@ -1,5 +1,6 @@
-package graphql.execution.reactive;
+package graphql.execution.reactive.tck;
 
+import graphql.execution.reactive.CompletionStageMappingPublisher;
 import io.reactivex.Flowable;
 import org.jetbrains.annotations.NotNull;
 import org.reactivestreams.Publisher;

File: src/test/groovy/graphql/execution/reactive/tck/CompletionStageMappingPublisherTckVerificationTest.java
Patch:
@@ -1,5 +1,6 @@
-package graphql.execution.reactive;
+package graphql.execution.reactive.tck;
 
+import graphql.execution.reactive.CompletionStageMappingPublisher;
 import io.reactivex.Flowable;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.tck.PublisherVerification;

File: src/test/groovy/graphql/execution/reactive/tck/SingleSubscriberPublisherTckVerificationTest.java
Patch:
@@ -1,5 +1,6 @@
-package graphql.execution.reactive;
+package graphql.execution.reactive.tck;
 
+import graphql.execution.reactive.SingleSubscriberPublisher;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.tck.PublisherVerification;
 import org.reactivestreams.tck.TestEnvironment;

File: src/main/java/graphql/incremental/DelayedIncrementalPartialResultImpl.java
Patch:
@@ -75,8 +75,8 @@ public Builder incrementalItems(List<IncrementalPayload> incrementalItems) {
             return this;
         }
 
-        public Builder extensions(boolean hasNext) {
-            this.hasNext = hasNext;
+        public Builder extensions(Map<Object, Object> extensions) {
+            this.extensions = extensions;
             return this;
         }
 

File: src/main/java/graphql/schema/GraphQLDirective.java
Patch:
@@ -15,6 +15,7 @@
 import java.util.function.Consumer;
 import java.util.function.UnaryOperator;
 
+import static graphql.Assert.assertNotEmpty;
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
 import static graphql.introspection.Introspection.DirectiveLocation;
@@ -52,6 +53,7 @@ private GraphQLDirective(String name,
                              DirectiveDefinition definition) {
         assertValidName(name);
         assertNotNull(arguments, () -> "arguments can't be null");
+        assertNotEmpty(locations, () -> "locations can't be empty");
         this.name = name;
         this.description = description;
         this.repeatable = repeatable;

File: src/main/java/graphql/normalized/ExecutableNormalizedOperationFactory.java
Patch:
@@ -34,7 +34,6 @@
 import graphql.schema.FieldCoordinates;
 import graphql.schema.GraphQLCompositeType;
 import graphql.schema.GraphQLFieldDefinition;
-import graphql.schema.GraphQLFieldsContainer;
 import graphql.schema.GraphQLInterfaceType;
 import graphql.schema.GraphQLNamedOutputType;
 import graphql.schema.GraphQLObjectType;
@@ -326,6 +325,7 @@ public static ExecutableNormalizedOperation createExecutableNormalizedOperation(
      * @param operationDefinition   the operation to be executed
      * @param fragments             a set of fragments associated with the operation
      * @param coercedVariableValues the coerced variables to use
+     * @param options               the options to use
      *
      * @return a runtime representation of the graphql operation.
      */

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -754,7 +754,7 @@ protected FieldValueInfo completeValueForList(ExecutionContext executionContext,
             if ((maxNodes = executionContext.getGraphQLContext().get(MAX_RESULT_NODES)) != null) {
                 if (resultNodesCount > maxNodes) {
                     executionContext.getResultNodesInfo().maxResultNodesExceeded();
-                    return new FieldValueInfo(NULL, completedFuture(null), fieldValueInfos);
+                    return new FieldValueInfo(NULL, null, fieldValueInfos);
                 }
             }
 

File: src/main/java/graphql/normalized/ExecutableNormalizedOperation.java
Patch:
@@ -42,6 +42,7 @@ public ExecutableNormalizedOperation(
             Map<ExecutableNormalizedField, MergedField> normalizedFieldToMergedField,
             Map<ExecutableNormalizedField, QueryDirectives> normalizedFieldToQueryDirectives,
             ImmutableListMultimap<FieldCoordinates, ExecutableNormalizedField> coordinatesToNormalizedFields,
+            int operationFieldCount,
             int operationDepth) {
         this.operation = operation;
         this.operationName = operationName;
@@ -50,7 +51,7 @@ public ExecutableNormalizedOperation(
         this.normalizedFieldToMergedField = normalizedFieldToMergedField;
         this.normalizedFieldToQueryDirectives = normalizedFieldToQueryDirectives;
         this.coordinatesToNormalizedFields = coordinatesToNormalizedFields;
-        this.operationFieldCount = fieldToNormalizedField.keySet().size();
+        this.operationFieldCount = operationFieldCount;
         this.operationDepth = operationDepth;
     }
 

File: src/main/java/graphql/execution/ExecutionContext.java
Patch:
@@ -86,7 +86,7 @@ public class ExecutionContext {
         this.errors.set(builder.errors);
         this.localContext = builder.localContext;
         this.executionInput = builder.executionInput;
-        queryTree = FpKit.interThreadMemoize(() -> ExecutableNormalizedOperationFactory.createExecutableNormalizedOperation(graphQLSchema, operationDefinition, fragmentsByName, coercedVariables));
+        this.queryTree = FpKit.interThreadMemoize(() -> ExecutableNormalizedOperationFactory.createExecutableNormalizedOperation(graphQLSchema, operationDefinition, fragmentsByName, coercedVariables));
     }
 
 

File: src/main/java/graphql/ErrorType.java
Patch:
@@ -11,6 +11,5 @@ public enum ErrorType implements ErrorClassification {
     DataFetchingException,
     NullValueInNonNullableField,
     OperationNotSupported,
-    IntrospectionDisabled,
     ExecutionAborted
 }

File: src/main/java/graphql/introspection/IntrospectionDisabledError.java
Patch:
@@ -30,6 +30,6 @@ public List<SourceLocation> getLocations() {
 
     @Override
     public ErrorClassification getErrorType() {
-        return ErrorType.IntrospectionDisabled;
+        return ErrorClassification.errorClassification("IntrospectionDisabled");
     }
 }

File: src/main/java/graphql/DirectivesUtil.java
Patch:
@@ -9,6 +9,7 @@
 import graphql.util.FpKit;
 
 import java.util.Collection;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -125,7 +126,7 @@ public static List<GraphQLAppliedDirective> toAppliedDirectives(Collection<Graph
      * A holder class that breaks a list of directives into maps to be more easily accessible in using classes
      */
     public static class DirectivesHolder {
-        private static final DirectivesHolder EMPTY_HOLDER = new DirectivesHolder();
+        private static final DirectivesHolder EMPTY_HOLDER = new DirectivesHolder(Collections.emptyList(), Collections.emptyList());
 
         private final ImmutableMap<String, List<GraphQLDirective>> allDirectivesByName;
         private final ImmutableMap<String, GraphQLDirective> nonRepeatableDirectivesByName;

File: src/main/java/graphql/schema/GraphQLTypeUtil.java
Patch:
@@ -184,6 +184,7 @@ public static <T extends GraphQLType> T unwrapOneAs(GraphQLType type) {
 
     /**
      * Unwraps all layers of the type or just returns the type again if it's not a wrapped type
+     * NOTE: This method does not support GraphQLTypeReference as input and will lead to a ClassCastException
      *
      * @param type the type to unwrapOne
      *

File: src/main/java/graphql/schema/GraphQLTypeUtil.java
Patch:
@@ -184,6 +184,7 @@ public static <T extends GraphQLType> T unwrapOneAs(GraphQLType type) {
 
     /**
      * Unwraps all layers of the type or just returns the type again if it's not a wrapped type
+     * NOTE: This method does not support GraphQLTypeReference as input and will lead to a ClassCastException
      *
      * @param type the type to unwrapOne
      *

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -420,7 +420,7 @@ public CompletableFuture<ExecutionResult> executeAsync(ExecutionInput executionI
                 InstrumentationExecutionParameters inputInstrumentationParameters = new InstrumentationExecutionParameters(executionInputWithId, this.graphQLSchema);
                 ExecutionInput instrumentedExecutionInput = instrumentation.instrumentExecutionInput(executionInputWithId, inputInstrumentationParameters, instrumentationState);
 
-                InstrumentationExecutionParameters instrumentationParameters = new InstrumentationExecutionParameters(instrumentedExecutionInput, this.graphQLSchema, instrumentationState);
+                InstrumentationExecutionParameters instrumentationParameters = new InstrumentationExecutionParameters(instrumentedExecutionInput, this.graphQLSchema);
                 InstrumentationContext<ExecutionResult> executionInstrumentation = nonNullCtx(instrumentation.beginExecution(instrumentationParameters, instrumentationState));
                 executionInstrumentation.onDispatched();
 
@@ -523,7 +523,7 @@ private ParseAndValidateResult parse(ExecutionInput executionInput, GraphQLSchem
     }
 
     private List<ValidationError> validate(ExecutionInput executionInput, Document document, GraphQLSchema graphQLSchema, InstrumentationState instrumentationState) {
-        InstrumentationContext<List<ValidationError>> validationCtx = nonNullCtx(instrumentation.beginValidation(new InstrumentationValidationParameters(executionInput, document, graphQLSchema, instrumentationState), instrumentationState));
+        InstrumentationContext<List<ValidationError>> validationCtx = nonNullCtx(instrumentation.beginValidation(new InstrumentationValidationParameters(executionInput, document, graphQLSchema), instrumentationState));
         validationCtx.onDispatched();
 
         Predicate<Class<?>> validationRulePredicate = executionInput.getGraphQLContext().getOrDefault(ParseAndValidate.INTERNAL_VALIDATION_PREDICATE_HINT, r -> true);

File: src/main/java/graphql/execution/preparsed/persisted/PersistedQuerySupport.java
Patch:
@@ -45,7 +45,7 @@ public PreparsedDocumentEntry getDocument(ExecutionInput executionInput, Functio
                 Object persistedQueryId = queryIdOption.get();
                 return persistedQueryCache.getPersistedQueryDocument(persistedQueryId, executionInput, (queryText) -> {
                     // we have a miss and they gave us nothing - bah!
-                    if (queryText == null || queryText.trim().length() == 0) {
+                    if (queryText == null || queryText.isBlank()) {
                         throw new PersistedQueryNotFound(persistedQueryId);
                     }
                     // validate the queryText hash before returning to the cache which we assume will set it

File: src/main/java/graphql/validation/ValidationErrorType.java
Patch:
@@ -27,6 +27,7 @@ public enum ValidationErrorType implements ValidationErrorClassification {
     UnknownDirective,
     MisplacedDirective,
     UndefinedVariable,
+    VariableNotAllowed,
     UnusedVariable,
     FragmentCycle,
     FieldsConflict,
@@ -37,6 +38,7 @@ public enum ValidationErrorType implements ValidationErrorClassification {
     DuplicateFragmentName,
     DuplicateDirectiveName,
     DuplicateArgumentNames,
+    DuplicateIncrementalLabel,
     DuplicateVariableName,
     NullValueForNonNullArgument,
     SubscriptionMultipleRootFields,

File: src/main/java/graphql/ExecutionInput.java
Patch:
@@ -3,7 +3,6 @@
 import graphql.collect.ImmutableKit;
 import graphql.execution.ExecutionId;
 import graphql.execution.RawVariables;
-import graphql.execution.instrumentation.dataloader.DataLoaderDispatcherInstrumentationState;
 import org.dataloader.DataLoaderRegistry;
 
 import java.util.Locale;
@@ -12,6 +11,7 @@
 import java.util.function.UnaryOperator;
 
 import static graphql.Assert.assertNotNull;
+import static graphql.execution.instrumentation.dataloader.EmptyDataLoaderRegistryInstance.EMPTY_DATALOADER_REGISTRY;
 
 /**
  * This represents the series of values that can be input on a graphql query execution
@@ -213,7 +213,7 @@ public static class Builder {
         // this is important - it allows code to later known if we never really set a dataloader and hence it can optimize
         // dataloader field tracking away.
         //
-        private DataLoaderRegistry dataLoaderRegistry = DataLoaderDispatcherInstrumentationState.EMPTY_DATALOADER_REGISTRY;
+        private DataLoaderRegistry dataLoaderRegistry = EMPTY_DATALOADER_REGISTRY;
         private Locale locale = Locale.getDefault();
         private ExecutionId executionId;
 
@@ -383,4 +383,4 @@ public ExecutionInput build() {
             return new ExecutionInput(this);
         }
     }
-}
\ No newline at end of file
+}

File: src/main/java/graphql/execution/AsyncSerialExecutionStrategy.java
Patch:
@@ -30,6 +30,7 @@ public AsyncSerialExecutionStrategy(DataFetcherExceptionHandler exceptionHandler
     @Override
     @SuppressWarnings({"TypeParameterUnusedInFormals", "FutureReturnValueIgnored"})
     public CompletableFuture<ExecutionResult> execute(ExecutionContext executionContext, ExecutionStrategyParameters parameters) throws NonNullableFieldWasNullException {
+        executionContext.getDataLoaderDispatcherStrategy().executionStrategy(executionContext, parameters);
 
         Instrumentation instrumentation = executionContext.getInstrumentation();
         InstrumentationExecutionStrategyParameters instrumentationParameters = new InstrumentationExecutionStrategyParameters(executionContext, parameters);
@@ -39,7 +40,7 @@ public CompletableFuture<ExecutionResult> execute(ExecutionContext executionCont
         MergedSelectionSet fields = parameters.getFields();
         ImmutableList<String> fieldNames = ImmutableList.copyOf(fields.keySet());
 
-        CompletableFuture<List<ExecutionResult>> resultsFuture = Async.eachSequentially(fieldNames, (fieldName, prevResults) -> {
+        CompletableFuture<List<Object>> resultsFuture = Async.eachSequentially(fieldNames, (fieldName, prevResults) -> {
             MergedField currentField = fields.getSubField(fieldName);
             ResultPath fieldPath = parameters.getPath().segment(mkNameForPath(currentField));
             ExecutionStrategyParameters newParameters = parameters

File: src/main/java/graphql/execution/MergedSelectionSet.java
Patch:
@@ -15,7 +15,7 @@ public class MergedSelectionSet {
 
     private final ImmutableMap<String, MergedField> subFields;
 
-    private MergedSelectionSet(Map<String, MergedField> subFields) {
+    protected MergedSelectionSet(Map<String, MergedField> subFields) {
         this.subFields = ImmutableMap.copyOf(Assert.assertNotNull(subFields));
     }
 

File: src/main/java/graphql/execution/SubscriptionExecutionStrategy.java
Patch:
@@ -135,7 +135,8 @@ private CompletableFuture<ExecutionResult> executeSubscriptionEvent(ExecutionCon
         FetchedValue fetchedValue = unboxPossibleDataFetcherResult(newExecutionContext, parameters, eventPayload);
         FieldValueInfo fieldValueInfo = completeField(newExecutionContext, newParameters, fetchedValue);
         CompletableFuture<ExecutionResult> overallResult = fieldValueInfo
-                .getFieldValue()
+                .getFieldValueFuture()
+                .thenApply(val -> new ExecutionResultImpl(val, newExecutionContext.getErrors()))
                 .thenApply(executionResult -> wrapWithRootFieldName(newParameters, executionResult));
 
         // dispatch instrumentation so they can know about each subscription event

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -534,7 +534,7 @@ private String description(Node<?> node) {
         if (description.isMultiLine()) {
             s = "\"\"\"" + (startNewLine ? "" : "\n") + description.getContent() + "\n\"\"\"\n";
         } else {
-            s = "\"" + description.getContent() + "\"\n";
+            s = "\"" + escapeJsonString(description.getContent()) + "\"\n";
         }
         return s;
     }

File: src/main/java/graphql/normalized/ENFMerger.java
Patch:
@@ -75,7 +75,7 @@ && isFieldInSharedInterface(field, fieldInGroup, schema)
 
                     if (deferSupport) {
                         // Move defer executions from removed field into the merged field's entry
-                        first.addDeferExecutions(next.getDeferExecutions());
+                        first.addDeferredExecutions(next.getDeferredExecutions());
                     }
                 }
                 first.setObjectTypeNames(mergedObjects);

File: src/main/java/graphql/validation/Validator.java
Patch:
@@ -30,6 +30,7 @@
 import graphql.validation.rules.UniqueArgumentNames;
 import graphql.validation.rules.UniqueDirectiveNamesPerLocation;
 import graphql.validation.rules.UniqueFragmentNames;
+import graphql.validation.rules.UniqueObjectFieldName;
 import graphql.validation.rules.UniqueOperationNames;
 import graphql.validation.rules.UniqueVariableNames;
 import graphql.validation.rules.VariableDefaultValuesOfCorrectType;

File: src/test/groovy/graphql/execution/BreadthFirstExecutionTestStrategy.java
Patch:
@@ -62,8 +62,8 @@ private FetchedValue fetchField(ExecutionContext executionContext, ExecutionStra
     }
 
     private void completeValue(ExecutionContext executionContext, Map<String, Object> results, String fieldName, FetchedValue fetchedValue, ExecutionStrategyParameters newParameters) {
-        ExecutionResult resolvedResult = completeField(executionContext, newParameters, fetchedValue).getFieldValue().join();
-        results.put(fieldName, resolvedResult != null ? resolvedResult.getData() : null);
+        Object resolvedResult = completeField(executionContext, newParameters, fetchedValue).getFieldValueFuture().join();
+        results.put(fieldName, resolvedResult);
     }
 
 }

File: src/test/groovy/graphql/execution/BreadthFirstTestStrategy.java
Patch:
@@ -63,8 +63,8 @@ private CompletableFuture<ExecutionResult> completeFields(ExecutionContext execu
 
             FetchedValue fetchedValue = fetchedValues.get(fieldName);
             try {
-                ExecutionResult resolvedResult = completeField(executionContext, newParameters, fetchedValue).getFieldValue().join();
-                results.put(fieldName, resolvedResult != null ? resolvedResult.getData() : null);
+                Object resolvedResult = completeField(executionContext, newParameters, fetchedValue).getFieldValueFuture().join();
+                results.put(fieldName, resolvedResult);
             } catch (NonNullableFieldWasNullException e) {
                 assertNonNullFieldPrecondition(e);
                 results = null;

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -534,7 +534,7 @@ private String description(Node<?> node) {
         if (description.isMultiLine()) {
             s = "\"\"\"" + (startNewLine ? "" : "\n") + description.getContent() + "\n\"\"\"\n";
         } else {
-            s = "\"" + description.getContent() + "\"\n";
+            s = "\"" + escapeJsonString(description.getContent()) + "\"\n";
         }
         return s;
     }

File: src/main/java/graphql/execution/incremental/DeferredExecutionSupport.java
Patch:
@@ -132,15 +132,15 @@ private Supplier<CompletableFuture<DeferredFragmentCall.FieldWithExecutionResult
                 DeferredCallContext deferredCallContext
         ) {
             Map<String, MergedField> fields = new LinkedHashMap<>();
-            fields.put(currentField.getName(), currentField);
+            fields.put(currentField.getResultKey(), currentField);
 
             ExecutionStrategyParameters callParameters = parameters.transform(builder ->
                     {
                         MergedSelectionSet mergedSelectionSet = MergedSelectionSet.newMergedSelectionSet().subFields(fields).build();
                         builder.deferredCallContext(deferredCallContext)
                                 .field(currentField)
                                 .fields(mergedSelectionSet)
-                                .path(parameters.getPath().segment(currentField.getName()))
+                                .path(parameters.getPath().segment(currentField.getResultKey()))
                                 .parent(null); // this is a break in the parent -> child chain - it's a new start effectively
                     }
             );
@@ -151,7 +151,7 @@ private Supplier<CompletableFuture<DeferredFragmentCall.FieldWithExecutionResult
             instrumentation.beginDeferredField(executionContext.getInstrumentationState());
 
             return dfCache.computeIfAbsent(
-                    currentField.getName(),
+                    currentField.getResultKey(),
                     // The same field can be associated with multiple defer executions, so
                     // we memoize the field resolution to avoid multiple calls to the same data fetcher
                     key -> FpKit.interThreadMemoize(() -> {

File: src/main/java/graphql/execution/instrumentation/dataloader/PerLevelDataLoaderDispatchStrategy.java
Patch:
@@ -96,7 +96,7 @@ public PerLevelDataLoaderDispatchStrategy(ExecutionContext executionContext) {
 
     @Override
     public void deferredField(ExecutionContext executionContext, MergedField currentField) {
-        throw new UnsupportedOperationException("Data Loaders cannot be used to resolve deferred fields at the moment");
+        throw new UnsupportedOperationException("Data Loaders cannot be used to resolve deferred fields");
     }
 
     @Override

File: src/main/java/graphql/execution/incremental/DeferredExecutionSupport.java
Patch:
@@ -165,7 +165,7 @@ private Supplier<CompletableFuture<DeferredFragmentCall.FieldWithExecutionResult
 
                                 return executionResultCF
                                         .thenApply(executionResult ->
-                                                new DeferredFragmentCall.FieldWithExecutionResult(currentField.getName(), executionResult)
+                                                new DeferredFragmentCall.FieldWithExecutionResult(currentField.getResultKey(), executionResult)
                                         );
                             }
                     )

File: src/main/java/graphql/execution/AsyncExecutionStrategy.java
Patch:
@@ -36,7 +36,7 @@ public AsyncExecutionStrategy(DataFetcherExceptionHandler exceptionHandler) {
     @Override
     @SuppressWarnings("FutureReturnValueIgnored")
     public CompletableFuture<ExecutionResult> execute(ExecutionContext executionContext, ExecutionStrategyParameters parameters) throws NonNullableFieldWasNullException {
-        dataLoaderDispatcherStrategy.executionStrategy(executionContext, parameters);
+        executionContext.getDataLoaderDispatcherStrategy().executionStrategy(executionContext, parameters);
 
         Instrumentation instrumentation = executionContext.getInstrumentation();
         InstrumentationExecutionStrategyParameters instrumentationParameters = new InstrumentationExecutionStrategyParameters(executionContext, parameters);
@@ -59,14 +59,14 @@ public CompletableFuture<ExecutionResult> execute(ExecutionContext executionCont
             for (FieldValueInfo completeValueInfo : completeValueInfos) {
                 fieldValuesFutures.add(completeValueInfo.getFieldValueFuture());
             }
-            dataLoaderDispatcherStrategy.executionStrategy_onFieldValuesInfo(completeValueInfos, parameters);
+            executionContext.getDataLoaderDispatcherStrategy().executionStrategy_onFieldValuesInfo(completeValueInfos, parameters);
             executionStrategyCtx.onFieldValuesInfo(completeValueInfos);
             fieldValuesFutures.await().whenComplete(handleResultsConsumer);
         }).exceptionally((ex) -> {
             // if there are any issues with combining/handling the field results,
             // complete the future at all costs and bubble up any thrown exception so
             // the execution does not hang.
-            dataLoaderDispatcherStrategy.executeObject_onFieldValuesException(ex, parameters);
+            executionContext.getDataLoaderDispatcherStrategy().executionStrategy_onFieldValuesException(ex, parameters);
             executionStrategyCtx.onFieldValuesException();
             overallResult.completeExceptionally(ex);
             return null;

File: src/main/java/graphql/execution/AsyncSerialExecutionStrategy.java
Patch:
@@ -30,7 +30,7 @@ public AsyncSerialExecutionStrategy(DataFetcherExceptionHandler exceptionHandler
     @Override
     @SuppressWarnings({"TypeParameterUnusedInFormals", "FutureReturnValueIgnored"})
     public CompletableFuture<ExecutionResult> execute(ExecutionContext executionContext, ExecutionStrategyParameters parameters) throws NonNullableFieldWasNullException {
-        dataLoaderDispatcherStrategy.executionStrategy(executionContext, parameters);
+        executionContext.getDataLoaderDispatcherStrategy().executionStrategy(executionContext, parameters);
 
         Instrumentation instrumentation = executionContext.getInstrumentation();
         InstrumentationExecutionStrategyParameters instrumentationParameters = new InstrumentationExecutionStrategyParameters(executionContext, parameters);

File: src/main/java/graphql/execution/AsyncExecutionStrategy.java
Patch:
@@ -213,7 +213,7 @@ public Set<DeferredCall> createCalls() {
 
                                         Instrumentation instrumentation = executionContext.getInstrumentation();
                                         DeferredFieldInstrumentationContext fieldCtx = instrumentation.beginDeferredField(
-                                                new InstrumentationDeferredFieldParameters(executionContext, parameters), executionContext.getInstrumentationState()
+                                                new InstrumentationDeferredFieldParameters(executionContext, callParameters), executionContext.getInstrumentationState()
                                         );
 
 
@@ -228,7 +228,6 @@ public Set<DeferredCall> createCalls() {
 
                                                             return fieldValueResult
                                                                     .thenApply(fieldValueInfo -> {
-                                                                        System.out.println("then apply: " + fieldValueInfo.getFieldValue().isDone());
                                                                         fieldCtx.onFieldValueInfo(fieldValueInfo);
                                                                         return fieldValueInfo;
                                                                     })

File: src/main/java/graphql/execution/instrumentation/DeferredFieldInstrumentationContext.java
Patch:
@@ -6,8 +6,6 @@
 public interface DeferredFieldInstrumentationContext extends InstrumentationContext<DeferredCall.FieldWithExecutionResult> {
 
     default void onFieldValueInfo(FieldValueInfo fieldValueInfo) {
-        System.out.println("DeferredFieldInstrumentationContext.onFieldValueInfo() [default]: " + fieldValueInfo);
-
     }
 
 }

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -43,6 +43,7 @@
 import graphql.schema.GraphQLType;
 import graphql.schema.LightDataFetcher;
 import graphql.util.FpKit;
+import org.jetbrains.annotations.NotNull;
 
 import java.util.ArrayList;
 import java.util.Collections;

File: src/main/java/graphql/execution/FieldValueInfo.java
Patch:
@@ -1,6 +1,5 @@
 package graphql.execution;
 
-import graphql.DeprecatedAt;
 import graphql.ExecutionResult;
 import graphql.ExecutionResultImpl;
 import graphql.PublicApi;
@@ -38,8 +37,7 @@ public CompleteValueType getCompleteValueType() {
         return completeValueType;
     }
 
-    @Deprecated
-    @DeprecatedAt("2023-09-11")
+    @Deprecated(since="2023-09-11" )
     public CompletableFuture<ExecutionResult> getFieldValue() {
         return fieldValue.thenApply(fv -> ExecutionResultImpl.newExecutionResult().data(fv).build());
     }

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -144,7 +144,7 @@ private CompletableFuture<ExecutionResult> executeOperation(ExecutionContext exe
         MergedSelectionSet fields = fieldCollector.collectFields(
                 collectorParameters,
                 operationDefinition.getSelectionSet(),
-                executionContext.getExecutionInput().isIncrementalSupport()
+                executionContext.isIncrementalSupport()
         );
 
         ResultPath path = ResultPath.rootPath();

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -372,7 +372,6 @@ protected <T> CompletableFuture<T> handleFetchingException(
                 .exception(e)
                 .build();
 
-        // TODO: not sure if this method call goes here, inside the try block below, or in the async method
         parameters.deferredErrorSupport().onFetchingException(parameters, e);
 
         try {
@@ -692,7 +691,7 @@ protected CompletableFuture<ExecutionResult> completeValueForObject(ExecutionCon
         MergedSelectionSet subFields = fieldCollector.collectFields(
                 collectorParameters,
                 parameters.getField(),
-                executionContext.getExecutionInput().isIncrementalSupport()
+                executionContext.isIncrementalSupport()
         );
 
         ExecutionStepInfo newExecutionStepInfo = executionStepInfo.changeTypeWithPreservedNonNull(resolvedObjectType);

File: src/main/java/graphql/execution/AsyncExecutionStrategy.java
Patch:
@@ -69,7 +69,7 @@ public CompletableFuture<ExecutionResult> execute(ExecutionContext executionCont
                     this::resolveFieldWithInfo
                 ) : DeferExecutionSupport.NOOP;
 
-        executionContext.getDefferContext().enqueue(deferExecutionSupport.createCalls());
+        executionContext.getIncrementalContext().enqueue(deferExecutionSupport.createCalls());
 
         Async.CombinedBuilder<FieldValueInfo> futures = Async.ofExpectedSize(fields.size() - deferExecutionSupport.deferredFieldsCount());
 

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -7,7 +7,7 @@
 import graphql.GraphQLContext;
 import graphql.GraphQLError;
 import graphql.Internal;
-import graphql.execution.defer.DeferContext;
+import graphql.execution.defer.IncrementalContext;
 import graphql.execution.instrumentation.Instrumentation;
 import graphql.execution.instrumentation.InstrumentationContext;
 import graphql.execution.instrumentation.InstrumentationState;
@@ -194,7 +194,7 @@ private CompletableFuture<ExecutionResult> executeOperation(ExecutionContext exe
      */
     private CompletableFuture<ExecutionResult> deferSupport(ExecutionContext executionContext, CompletableFuture<ExecutionResult> result) {
         return result.thenApply(er -> {
-            DeferContext deferSupport = executionContext.getDefferContext();
+            IncrementalContext deferSupport = executionContext.getIncrementalContext();
             if (deferSupport.isDeferDetected()) {
                 // we start the rest of the query now to maximize throughput.  We have the initial important results
                 // and now we can start the rest of the calls as early as possible (even before some one subscribes)

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -683,6 +683,7 @@ protected CompletableFuture<ExecutionResult> completeValueForObject(ExecutionCon
                 .objectType(resolvedObjectType)
                 .fragments(executionContext.getFragmentsByName())
                 .variables(executionContext.getCoercedVariables().toMap())
+                .graphQLContext(executionContext.getGraphQLContext())
                 .build();
 
         MergedSelectionSet subFields = fieldCollector.collectFields(collectorParameters, parameters.getField());

File: src/main/java/graphql/execution/defer/DeferredCall.java
Patch:
@@ -10,6 +10,7 @@
 import graphql.incremental.DelayedIncrementalExecutionResultImpl;
 
 import java.util.Collections;
+import java.util.Date;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;

File: src/main/java/graphql/execution/ExecutionContext.java
Patch:
@@ -6,10 +6,8 @@
 import graphql.ExecutionInput;
 import graphql.GraphQLContext;
 import graphql.GraphQLError;
-import graphql.Internal;
 import graphql.PublicApi;
 import graphql.collect.ImmutableKit;
-import graphql.cachecontrol.CacheControl;
 import graphql.execution.defer.DeferSupport;
 import graphql.execution.instrumentation.Instrumentation;
 import graphql.execution.instrumentation.InstrumentationState;

File: src/main/java/graphql/execution/defer/DeferredCall.java
Patch:
@@ -5,7 +5,7 @@
 import graphql.ExecutionResult;
 import graphql.GraphQLError;
 import graphql.Internal;
-import graphql.execution.ExecutionPath;
+import graphql.execution.ResultPath;
 
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
@@ -17,11 +17,11 @@
  */
 @Internal
 public class DeferredCall {
-    private final ExecutionPath path;
+    private final ResultPath path;
     private final Supplier<CompletableFuture<ExecutionResult>> call;
     private final DeferredErrorSupport errorSupport;
 
-    public DeferredCall(ExecutionPath path, Supplier<CompletableFuture<ExecutionResult>> call, DeferredErrorSupport deferredErrorSupport) {
+    public DeferredCall(ResultPath path, Supplier<CompletableFuture<ExecutionResult>> call, DeferredErrorSupport deferredErrorSupport) {
         this.path = path;
         this.call = call;
         this.errorSupport = deferredErrorSupport;

File: src/main/java/graphql/execution/instrumentation/Instrumentation.java
Patch:
@@ -230,7 +230,9 @@ default ExecutionStrategyInstrumentationContext beginExecutionStrategy(Instrumen
      *
      * @return a non null {@link InstrumentationContext} object that will be called back when the step ends
      */
-    DeferredFieldInstrumentationContext beginDeferredField(InstrumentationDeferredFieldParameters parameters);
+    default InstrumentationContext<ExecutionResult> beginDeferredField(InstrumentationDeferredFieldParameters parameters, InstrumentationState state) {
+        return noOp();
+    }
 
     /**
      * This is called each time a subscription field produces a new reactive stream event value and it needs to be mapped over via the graphql field subselection.

File: src/main/java/graphql/execution/instrumentation/dataloader/DataLoaderDispatcherInstrumentation.java
Patch:
@@ -137,8 +137,8 @@ private boolean isDataLoaderCompatibleExecution(ExecutionContext executionContex
     }
 
     @Override
-    public DeferredFieldInstrumentationContext beginDeferredField(InstrumentationDeferredFieldParameters parameters) {
-        DataLoaderDispatcherInstrumentationState state = parameters.getInstrumentationState();
+    public DeferredFieldInstrumentationContext beginDeferredField(InstrumentationDeferredFieldParameters parameters, InstrumentationState rawState) {
+        DataLoaderDispatcherInstrumentationState state = ofState(rawState);
         //
         // if there are no data loaders, there is nothing to do
         //
@@ -154,7 +154,7 @@ public void onCompleted(ExecutionResult result, Throwable t) {
             };
 
         }
-        return state.getApproach().beginDeferredField(parameters.withNewState(state.getState()));
+        return state.getApproach().beginDeferredField(parameters, state.getState());
     }
 
     @Override

File: src/main/java/graphql/execution/instrumentation/dataloader/FieldLevelTrackingApproach.java
Patch:
@@ -189,8 +189,9 @@ private int getCountForList(List<FieldValueInfo> fieldValueInfos) {
         return result;
     }
 
-    DeferredFieldInstrumentationContext beginDeferredField(InstrumentationDeferredFieldParameters parameters) {
-        CallStack callStack = parameters.getInstrumentationState();
+    DeferredFieldInstrumentationContext beginDeferredField(InstrumentationDeferredFieldParameters parameters, InstrumentationState state) {
+        // TODO: Is this cast safe?
+        CallStack callStack = (CallStack) state;
         int level = parameters.getExecutionStrategyParameters().getPath().getLevel();
         synchronized (callStack) {
             callStack.clearAndMarkCurrentLevelAsReady(level);

File: src/test/groovy/example/http/DeferHttpSupport.java
Patch:
@@ -3,11 +3,11 @@
 import graphql.DeferredExecutionResult;
 import graphql.ExecutionResult;
 import graphql.GraphQL;
+import jakarta.servlet.http.HttpServletResponse;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.UncheckedIOException;

File: src/test/groovy/readme/DeferredExamples.java
Patch:
@@ -6,11 +6,11 @@
 import graphql.ExecutionResult;
 import graphql.GraphQL;
 import graphql.schema.GraphQLSchema;
+import jakarta.servlet.http.HttpServletResponse;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 
-import javax.servlet.http.HttpServletResponse;
 import java.util.Map;
 
 @SuppressWarnings({"unused", "ConstantConditions", "UnusedAssignment", "unchecked"})

File: src/main/java/graphql/incremental/IncrementalExecutionResult.java
Patch:
@@ -61,7 +61,7 @@
  * }
  * </pre>
  *
- * <b>Response 3, contains the final stream payload. Note how "hasNext" is "false", indicating this is the final response.
+ * <b>Response 3, contains the final stream payload. Note how "hasNext" is "false", indicating this is the final response.</b>
  * <pre>
  * {
  *   "incremental": [
@@ -93,7 +93,7 @@ public interface IncrementalExecutionResult extends ExecutionResult {
     /**
      * Returns a list of defer and/or stream payloads that the execution engine decided (for whatever reason) to resolve at the same time as the initial payload.
      * <p>
-     * <quote>(...)this field may appear on both the initial and subsequent values.</quote>
+     * (...)this field may appear on both the initial and subsequent values.
      * <p>
      * <a href="https://github.com/graphql/graphql-spec/pull/742/files#diff-98d0cd153b72b63c417ad4238e8cc0d3385691ccbde7f7674bc0d2a718b896ecR271">source</a>
      *

File: src/main/java/graphql/TypeResolutionEnvironment.java
Patch:
@@ -94,8 +94,7 @@ public GraphQLSchema getSchema() {
      *
      * @deprecated use {@link #getGraphQLContext()} instead
      */
-    @Deprecated
-    @DeprecatedAt("2021-12-27")
+    @Deprecated(since = "2021-12-27")
     public <T> T getContext() {
         //noinspection unchecked
         return (T) context;

File: src/main/java/graphql/execution/DataFetcherExceptionHandler.java
Patch:
@@ -1,6 +1,5 @@
 package graphql.execution;
 
-import graphql.DeprecatedAt;
 import graphql.ExecutionResult;
 import graphql.PublicSpi;
 import graphql.schema.DataFetcher;

File: src/main/java/graphql/execution/DataFetcherResult.java
Patch:
@@ -1,7 +1,6 @@
 package graphql.execution;
 
 import com.google.common.collect.ImmutableList;
-import graphql.DeprecatedAt;
 import graphql.ExecutionResult;
 import graphql.GraphQLError;
 import graphql.Internal;
@@ -49,8 +48,7 @@ public class DataFetcherResult<T> {
      * @deprecated use the {@link #newResult()} builder instead
      */
     @Internal
-    @Deprecated
-    @DeprecatedAt("2019-01-11")
+    @Deprecated(since = "2019-01-11")
     public DataFetcherResult(T data, List<GraphQLError> errors) {
         this(data, errors, null, null);
     }

File: src/main/java/graphql/execution/ExecutionStepInfo.java
Patch:
@@ -1,6 +1,5 @@
 package graphql.execution;
 
-import graphql.DeprecatedAt;
 import graphql.PublicApi;
 import graphql.collect.ImmutableMapWithNullValues;
 import graphql.schema.GraphQLFieldDefinition;
@@ -84,8 +83,7 @@ private ExecutionStepInfo(Builder builder) {
      * @see ExecutionStepInfo#getObjectType()
      * @deprecated use {@link #getObjectType()} instead as it is named better
      */
-    @Deprecated
-    @DeprecatedAt("2022-02-03")
+    @Deprecated(since = "2022-02-03")
     public GraphQLObjectType getFieldContainer() {
         return fieldContainer;
     }

File: src/main/java/graphql/execution/instrumentation/SimpleInstrumentation.java
Patch:
@@ -1,6 +1,5 @@
 package graphql.execution.instrumentation;
 
-import graphql.DeprecatedAt;
 import graphql.PublicApi;
 
 /**
@@ -12,8 +11,7 @@
  * @deprecated use {@link SimplePerformantInstrumentation} instead as a base class.
  */
 @PublicApi
-@Deprecated
-@DeprecatedAt(value = "2022-10-05")
+@Deprecated(since = "2022-10-05")
 public class SimpleInstrumentation implements Instrumentation {
 
     /**

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationFieldFetchParameters.java
Patch:
@@ -1,6 +1,5 @@
 package graphql.execution.instrumentation.parameters;
 
-import graphql.DeprecatedAt;
 import graphql.PublicApi;
 import graphql.execution.ExecutionContext;
 import graphql.execution.ExecutionStrategyParameters;
@@ -42,8 +41,7 @@ private InstrumentationFieldFetchParameters(ExecutionContext getExecutionContext
      *
      * @deprecated state is now passed in direct to instrumentation methods
      */
-    @Deprecated
-    @DeprecatedAt("2022-07-26")
+    @Deprecated(since = "2022-07-26")
     @Override
     public InstrumentationFieldFetchParameters withNewState(InstrumentationState instrumentationState) {
         return new InstrumentationFieldFetchParameters(

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationValidationParameters.java
Patch:
@@ -1,6 +1,5 @@
 package graphql.execution.instrumentation.parameters;
 
-import graphql.DeprecatedAt;
 import graphql.ExecutionInput;
 import graphql.PublicApi;
 import graphql.execution.instrumentation.Instrumentation;
@@ -29,8 +28,7 @@ public InstrumentationValidationParameters(ExecutionInput executionInput, Docume
      *
      * @deprecated state is now passed in direct to instrumentation methods
      */
-    @Deprecated
-    @DeprecatedAt("2022-07-26")
+    @Deprecated(since = "2022-07-26")
     @Override
     public InstrumentationValidationParameters withNewState(InstrumentationState instrumentationState) {
         return new InstrumentationValidationParameters(

File: src/main/java/graphql/execution/preparsed/PreparsedDocumentProvider.java
Patch:
@@ -1,7 +1,6 @@
 package graphql.execution.preparsed;
 
 
-import graphql.DeprecatedAt;
 import graphql.ExecutionInput;
 import graphql.PublicSpi;
 
@@ -27,8 +26,7 @@ public interface PreparsedDocumentProvider {
      * <p>
      * @deprecated - use {@link #getDocumentAsync(ExecutionInput executionInput, Function parseAndValidateFunction)}
      */
-    @Deprecated
-    @DeprecatedAt("2021-12-06")
+    @Deprecated(since = "2021-12-06")
     PreparsedDocumentEntry getDocument(ExecutionInput executionInput, Function<ExecutionInput, PreparsedDocumentEntry> parseAndValidateFunction);
 
     /**

File: src/main/java/graphql/execution/preparsed/persisted/PersistedQueryCache.java
Patch:
@@ -1,6 +1,5 @@
 package graphql.execution.preparsed.persisted;
 
-import graphql.DeprecatedAt;
 import graphql.ExecutionInput;
 import graphql.PublicSpi;
 import graphql.execution.preparsed.PreparsedDocumentEntry;
@@ -32,8 +31,7 @@ public interface PersistedQueryCache {
      *
      * @deprecated - use {@link #getPersistedQueryDocumentAsync(Object persistedQueryId, ExecutionInput executionInput, PersistedQueryCacheMiss onCacheMiss)}
      */
-    @Deprecated
-    @DeprecatedAt("2021-12-06")
+    @Deprecated(since = "2021-12-06")
     PreparsedDocumentEntry getPersistedQueryDocument(Object persistedQueryId, ExecutionInput executionInput, PersistedQueryCacheMiss onCacheMiss) throws PersistedQueryNotFound;
 
     /**

File: src/main/java/graphql/schema/DataFetchingEnvironmentImpl.java
Patch:
@@ -2,7 +2,6 @@
 
 
 import com.google.common.collect.ImmutableMap;
-import graphql.DeprecatedAt;
 import graphql.GraphQLContext;
 import graphql.Internal;
 import graphql.collect.ImmutableKit;
@@ -306,8 +305,7 @@ public Builder arguments(Supplier<Map<String, Object>> arguments) {
             return this;
         }
 
-        @Deprecated
-        @DeprecatedAt("2021-07-05")
+        @Deprecated(since = "2021-07-05")
         public Builder context(Object context) {
             this.context = context;
             return this;

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -1,7 +1,6 @@
 package graphql.schema;
 
 
-import graphql.DeprecatedAt;
 import graphql.DirectivesUtil;
 import graphql.GraphQLContext;
 import graphql.PublicApi;
@@ -315,8 +314,7 @@ public Builder type(GraphQLInputType type) {
          *
          * @deprecated use {@link #defaultValueLiteral(Value)}
          */
-        @Deprecated
-        @DeprecatedAt("2021-05-10")
+        @Deprecated(since = "2021-05-10")
         public Builder defaultValue(Object defaultValue) {
             this.defaultValue = InputValueWithState.newInternalValue(defaultValue);
             return this;

File: src/main/java/graphql/schema/diff/DiffSet.java
Patch:
@@ -1,7 +1,6 @@
 package graphql.schema.diff;
 
 import graphql.Assert;
-import graphql.DeprecatedAt;
 import graphql.ExecutionResult;
 import graphql.GraphQL;
 import graphql.PublicApi;
@@ -16,8 +15,7 @@
  * {@link graphql.introspection.IntrospectionQuery}.
  */
 @PublicApi
-@Deprecated
-@DeprecatedAt("2023-10-04")
+@Deprecated(since = "2023-10-04")
 public class DiffSet {
 
     private final Map<String, Object> introspectionOld;

File: src/main/java/graphql/schema/diff/SchemaDiff.java
Patch:
@@ -1,7 +1,6 @@
 package graphql.schema.diff;
 
 import graphql.Assert;
-import graphql.DeprecatedAt;
 import graphql.PublicSpi;
 import graphql.introspection.IntrospectionResultToSchema;
 import graphql.language.Argument;
@@ -121,8 +120,7 @@ public SchemaDiff(Options options) {
      *
      * @return the number of API breaking changes
      */
-    @Deprecated
-    @DeprecatedAt("2023-10-04")
+    @Deprecated(since = "2023-10-04")
     @SuppressWarnings("unchecked")
     public int diffSchema(DiffSet diffSet, DifferenceReporter reporter) {
         CountingReporter countingReporter = new CountingReporter(reporter);

File: src/main/java/graphql/schema/idl/RuntimeWiring.java
Patch:
@@ -1,6 +1,5 @@
 package graphql.schema.idl;
 
-import graphql.DeprecatedAt;
 import graphql.PublicApi;
 import graphql.schema.DataFetcher;
 import graphql.schema.GraphQLCodeRegistry;
@@ -356,8 +355,7 @@ public Builder comparatorRegistry(GraphqlTypeComparatorRegistry comparatorRegist
          * @deprecated This mechanism can be achieved in a better way via {@link graphql.schema.SchemaTransformer}
          * after the schema is built
          */
-        @Deprecated
-        @DeprecatedAt(value = "2022-10-29")
+        @Deprecated(since = "2022-10-29")
         public Builder transformer(SchemaGeneratorPostProcessing schemaGeneratorPostProcessing) {
             this.schemaGeneratorPostProcessings.add(assertNotNull(schemaGeneratorPostProcessing));
             return this;

File: src/main/java/graphql/schema/idl/SchemaGeneratorPostProcessing.java
Patch:
@@ -1,6 +1,5 @@
 package graphql.schema.idl;
 
-import graphql.DeprecatedAt;
 import graphql.PublicSpi;
 import graphql.schema.GraphQLSchema;
 
@@ -12,8 +11,7 @@
  * after the schema is built
  */
 @PublicSpi
-@Deprecated
-@DeprecatedAt(value = "2022-10-29")
+@Deprecated(since = "2022-10-29")
 public interface SchemaGeneratorPostProcessing {
 
     /**

File: src/main/java/graphql/validation/ValidationError.java
Patch:
@@ -2,7 +2,6 @@
 
 
 import com.google.common.collect.ImmutableMap;
-import graphql.DeprecatedAt;
 import graphql.ErrorType;
 import graphql.GraphQLError;
 import graphql.GraphqlErrorHelper;

File: src/main/java/graphql/normalized/incremental/IncrementalNodes.java
Patch:
@@ -40,7 +40,7 @@ public DeferLabel getDeferLabel(
                 return new DeferLabel(null);
             }
 
-            Assert.assertTrue(label instanceof String, () -> String.format("The '%s' directive MUST have a value for the 'if' argument", DeferDirective.getName()));
+            Assert.assertTrue(label instanceof String, () -> String.format("The 'label' argument from the '%s' directive MUST contain a String value", DeferDirective.getName()));
 
             return new DeferLabel((String) label);
 

File: src/main/java/graphql/normalized/ExecutableNormalizedOperationToAstCompiler.java
Patch:
@@ -152,7 +152,7 @@ private static List<Selection<?>> subselectionsForNormalizedField(GraphQLSchema
                                                                       VariableAccumulator variableAccumulator) {
         ImmutableList.Builder<Selection<?>> selections = ImmutableList.builder();
 
-        // All conditional fields go here instead of directly to selections, so they can be grouped together
+        // All conditional and deferred fields go here instead of directly to selections, so they can be grouped together
         // in the same inline fragment in the output
         //
         Map<ExecutionFragmentDetails, List<Field>> fieldsByFragmentDetails = new LinkedHashMap<>();

File: src/main/java/graphql/execution/ValuesResolverConversion.java
Patch:
@@ -104,7 +104,6 @@ static Object valueToLiteralImpl(GraphqlFieldVisibility fieldVisibility,
      * @param type            the type of input value
      * @param graphqlContext  the GraphqlContext to use
      * @param locale          the Locale to use
-     *
      * @return a value converted to an internal value
      */
     static Object externalValueToInternalValue(GraphqlFieldVisibility fieldVisibility,
@@ -596,7 +595,6 @@ private static List externalValueToInternalValueForList(
      * @param coercedVariables the coerced variable values
      * @param graphqlContext   the GraphqlContext to use
      * @param locale           the Locale to use
-     *
      * @return literal converted to an internal value
      */
     static Object literalToInternalValue(

File: src/main/java/graphql/validation/rules/OverlappingFieldsCanBeMerged.java
Patch:
@@ -135,7 +135,7 @@ private void collectFieldsForField(Map<String, Set<FieldAndType>> fieldMap, Grap
             GraphQLFieldDefinition fieldDefinition = getVisibleFieldDefinition(fieldsContainer, field);
             fieldType = fieldDefinition != null ? fieldDefinition.getType() : null;
         }
-        fieldMap.get(responseName).add(new FieldAndType(field, fieldType, parentType));
+        fieldMap.get(responseName).add(new FieldAndType(field, fieldType, unwrappedParent));
     }
 
     private GraphQLFieldDefinition getVisibleFieldDefinition(GraphQLFieldsContainer fieldsContainer, Field field) {

File: src/main/java/graphql/validation/rules/OverlappingFieldsCanBeMerged.java
Patch:
@@ -135,7 +135,7 @@ private void collectFieldsForField(Map<String, Set<FieldAndType>> fieldMap, Grap
             GraphQLFieldDefinition fieldDefinition = getVisibleFieldDefinition(fieldsContainer, field);
             fieldType = fieldDefinition != null ? fieldDefinition.getType() : null;
         }
-        fieldMap.get(responseName).add(new FieldAndType(field, fieldType, parentType));
+        fieldMap.get(responseName).add(new FieldAndType(field, fieldType, unwrappedParent));
     }
 
     private GraphQLFieldDefinition getVisibleFieldDefinition(GraphQLFieldsContainer fieldsContainer, Field field) {

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -191,7 +191,7 @@ public static String mkNameForPath(List<Field> currentField) {
      * @param executionContext contains the top level execution parameters
      * @param parameters       contains the parameters holding the fields to be executed and source object
      *
-     * @return a promise to an {@link Map<String,Object>}
+     * @return a promise to a map of object field values
      *
      * @throws NonNullableFieldWasNullException in the future if a non-null field resolves to a null value
      */

File: src/main/java/graphql/execution/SubscriptionExecutionStrategy.java
Patch:
@@ -136,7 +136,7 @@ private CompletableFuture<ExecutionResult> executeSubscriptionEvent(ExecutionCon
         FieldValueInfo fieldValueInfo = completeField(newExecutionContext, newParameters, fetchedValue);
         CompletableFuture<ExecutionResult> overallResult = fieldValueInfo
                 .getFieldValueFuture()
-                .thenApply(val -> new ExecutionResultImpl(val, executionContext.getErrors()))
+                .thenApply(val -> new ExecutionResultImpl(val, newExecutionContext.getErrors()))
                 .thenApply(executionResult -> wrapWithRootFieldName(newParameters, executionResult));
 
         // dispatch instrumentation so they can know about each subscription event

File: src/main/java/graphql/schema/idl/SchemaPrinter.java
Patch:
@@ -6,6 +6,7 @@
 import graphql.PublicApi;
 import graphql.execution.ValuesResolver;
 import graphql.language.AstPrinter;
+import graphql.language.Comment;
 import graphql.language.Description;
 import graphql.language.DirectiveDefinition;
 import graphql.language.Document;
@@ -1158,7 +1159,7 @@ private String getAstDefinitionComments(Object commentHolder) {
         }
     }
 
-    String comments(java.util.List<graphql.language.Comment> comments) {
+    private String comments(List<Comment> comments) {
         if ( comments == null || comments.isEmpty() ) {
             return null;
         }

File: src/main/java/graphql/validation/rules/VariableTypesMatch.java
Patch:
@@ -75,6 +75,7 @@ public void checkVariable(VariableReference variableReference) {
         if (!variableDefMatches) {
             GraphQLType effectiveType = variablesTypesMatcher.effectiveType(variableType, variableDefinition.getDefaultValue());
             String message = i18n(VariableTypeMismatch, "VariableTypesMatchRule.unexpectedType",
+                    variableDefinition.getName(),
                     GraphQLTypeUtil.simplePrint(effectiveType),
                     GraphQLTypeUtil.simplePrint(locationType));
             addError(VariableTypeMismatch, variableReference.getSourceLocation(), message);

File: src/main/java/graphql/util/FpKit.java
Patch:
@@ -265,7 +265,7 @@ public static <T> CompletableFuture<List<T>> flatList(CompletableFuture<List<Lis
         return cf.thenApply(FpKit::flatList);
     }
 
-    public static <T> List<T> flatList(List<List<T>> listLists) {
+    public static <T> List<T> flatList(Collection<List<T>> listLists) {
         return listLists.stream()
                 .flatMap(List::stream)
                 .collect(ImmutableList.toImmutableList());

File: src/main/java/graphql/schema/PropertyFetchingImpl.java
Patch:
@@ -138,7 +138,7 @@ public Object getPropertyValue(String propertyName, Object object, GraphQLType g
         //
         // try by public getters name -  object.getPropertyName()
         try {
-            MethodFinder methodFinder = (rootClass, methodName) -> findPubliclyAccessibleMethod(cacheKey, rootClass, methodName, dfeInUse,false);
+            MethodFinder methodFinder = (rootClass, methodName) -> findPubliclyAccessibleMethod(cacheKey, rootClass, methodName, dfeInUse, false);
             return getPropertyViaGetterMethod(object, propertyName, graphQLType, methodFinder, singleArgumentValue);
         } catch (NoSuchMethodException ignored) {
         }
@@ -149,7 +149,7 @@ public Object getPropertyValue(String propertyName, Object object, GraphQLType g
             // in order to not break things we allow statics to be used.  In theory this double code check is not needed
             // because you CANT have a `static getFoo()` and a `getFoo()` in the same class hierarchy but to make the code read clearer
             // I have repeated the lookup.  Since we cache methods, this happens only once and does not slow us down
-            MethodFinder methodFinder = (rootClass, methodName) -> findPubliclyAccessibleMethod(cacheKey, rootClass, methodName, dfeInUse,true);
+            MethodFinder methodFinder = (rootClass, methodName) -> findPubliclyAccessibleMethod(cacheKey, rootClass, methodName, dfeInUse, true);
             return getPropertyViaGetterMethod(object, propertyName, graphQLType, methodFinder, singleArgumentValue);
         } catch (NoSuchMethodException ignored) {
         }

File: src/main/java/graphql/execution/DataFetcherResult.java
Patch:
@@ -127,6 +127,7 @@ public DataFetcherResult<T> transform(Consumer<Builder<T>> builderConsumer) {
      * All other values are left unmodified.
      *
      * @param transformation the transformation that should be applied to the data
+     * @param <R>            the result type
      *
      * @return a new instance with where the data value has been transformed
      */

File: src/main/java/graphql/normalized/ExecutableNormalizedField.java
Patch:
@@ -17,7 +17,7 @@
 import graphql.schema.GraphQLSchema;
 import graphql.schema.GraphQLUnionType;
 import graphql.util.FpKit;
-import graphql.util.Ref;
+import graphql.util.MutableRef;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
@@ -526,7 +526,7 @@ private Set<GraphQLInterfaceType> getInterfacesCommonToAllOutputTypes(GraphQLSch
             }
         }
 
-        Ref<Set<GraphQLInterfaceType>> commonInterfaces = new Ref<>();
+        MutableRef<Set<GraphQLInterfaceType>> commonInterfaces = new MutableRef<>();
         forEachFieldDefinition(schema, (fieldDef) -> {
             var outputType = unwrapAll(fieldDef.getType());
 

File: src/main/java/graphql/schema/diffing/PossibleMappingsCalculator.java
Patch:
@@ -1092,6 +1092,8 @@ private Map<Vertex, Vertex> getFixedParentRestrictions(SchemaGraph sourceGraph,
      * e.g. for an output {collar: Dog} then the collar vertex must be a child of Dog in the mapping.
      *
      * @param mapping the mapping to get non-fixed parent restrictions for
+     * @param sourceGraph the source graph
+     * @param targetGraph the target graph
      * @return Map where key is any vertex, and the value is the parent that vertex must map to
      */
     public Map<Vertex, Vertex> getNonFixedParentRestrictions(SchemaGraph sourceGraph,

File: src/main/java/graphql/schema/diffing/SchemaGraph.java
Patch:
@@ -260,6 +260,9 @@ public Vertex getAppliedDirectiveContainerForAppliedDirective(Vertex appliedDire
 
     /**
      * Gets the one inverse adjacent edge to the input and gets the other vertex.
+     *
+     * @param input  the vertex input
+     * @return a vertex
      */
     public Vertex getSingleAdjacentInverseVertex(Vertex input) {
         Collection<Edge> adjacentVertices = this.getAdjacentEdgesInverseNonCopy(input);

File: src/main/java/graphql/execution/DataFetcherResult.java
Patch:
@@ -127,6 +127,7 @@ public DataFetcherResult<T> transform(Consumer<Builder<T>> builderConsumer) {
      * All other values are left unmodified.
      *
      * @param transformation the transformation that should be applied to the data
+     * @param <R>            the result type
      *
      * @return a new instance with where the data value has been transformed
      */

File: src/main/java/graphql/normalized/ExecutableNormalizedField.java
Patch:
@@ -17,7 +17,7 @@
 import graphql.schema.GraphQLSchema;
 import graphql.schema.GraphQLUnionType;
 import graphql.util.FpKit;
-import graphql.util.Ref;
+import graphql.util.MutableRef;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
@@ -526,7 +526,7 @@ private Set<GraphQLInterfaceType> getInterfacesCommonToAllOutputTypes(GraphQLSch
             }
         }
 
-        Ref<Set<GraphQLInterfaceType>> commonInterfaces = new Ref<>();
+        MutableRef<Set<GraphQLInterfaceType>> commonInterfaces = new MutableRef<>();
         forEachFieldDefinition(schema, (fieldDef) -> {
             var outputType = unwrapAll(fieldDef.getType());
 

File: src/main/java/graphql/schema/diffing/PossibleMappingsCalculator.java
Patch:
@@ -1092,6 +1092,8 @@ private Map<Vertex, Vertex> getFixedParentRestrictions(SchemaGraph sourceGraph,
      * e.g. for an output {collar: Dog} then the collar vertex must be a child of Dog in the mapping.
      *
      * @param mapping the mapping to get non-fixed parent restrictions for
+     * @param sourceGraph the source graph
+     * @param targetGraph the target graph
      * @return Map where key is any vertex, and the value is the parent that vertex must map to
      */
     public Map<Vertex, Vertex> getNonFixedParentRestrictions(SchemaGraph sourceGraph,

File: src/main/java/graphql/schema/diffing/SchemaGraph.java
Patch:
@@ -260,6 +260,9 @@ public Vertex getAppliedDirectiveContainerForAppliedDirective(Vertex appliedDire
 
     /**
      * Gets the one inverse adjacent edge to the input and gets the other vertex.
+     *
+     * @param input  the vertex input
+     * @return a vertex
      */
     public Vertex getSingleAdjacentInverseVertex(Vertex input) {
         Collection<Edge> adjacentVertices = this.getAdjacentEdgesInverseNonCopy(input);

File: src/main/java/graphql/execution/AbstractAsyncExecutionStrategy.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.execution;
 
+import com.google.common.collect.Maps;
 import graphql.ExecutionResult;
 import graphql.ExecutionResultImpl;
 import graphql.PublicSpi;
@@ -28,10 +29,9 @@ protected BiConsumer<List<ExecutionResult>, Throwable> handleResults(ExecutionCo
                 handleNonNullException(executionContext, overallResult, exception);
                 return;
             }
-            Map<String, Object> resolvedValuesByField = new LinkedHashMap<>(fieldNames.size());
+            Map<String, Object> resolvedValuesByField = Maps.newLinkedHashMapWithExpectedSize(fieldNames.size());
             int ix = 0;
             for (ExecutionResult executionResult : results) {
-
                 String fieldName = fieldNames.get(ix++);
                 resolvedValuesByField.put(fieldName, executionResult.getData());
             }

File: src/main/java/graphql/execution/AsyncExecutionStrategy.java
Patch:
@@ -64,6 +64,7 @@ public CompletableFuture<ExecutionResult> execute(ExecutionContext executionCont
                 handleResultsConsumer.accept(null, throwable.getCause());
                 return;
             }
+
             Async.CombinedBuilder<ExecutionResult> executionResultFutures = Async.ofExpectedSize(completeValueInfos.size());
             for (FieldValueInfo completeValueInfo : completeValueInfos) {
                 executionResultFutures.add(completeValueInfo.getFieldValue());

File: src/main/java/graphql/schema/diffing/DiffImpl.java
Patch:
@@ -204,7 +204,7 @@ private void addChildToQueue(int fixedEditorialCost,
         double[][] costMatrix = new double[costMatrixSize][costMatrixSize];
 
         Map<Vertex, Double> isolatedVerticesCache = new LinkedHashMap<>();
-        Map<Vertex, Vertex> nonFixedParentRestrictions = possibleMappingsCalculator.getNonFixedParentRestrictions(parentPartialMapping);
+        Map<Vertex, Vertex> nonFixedParentRestrictions = possibleMappingsCalculator.getNonFixedParentRestrictions(completeSourceGraph, completeTargetGraph, parentPartialMapping);
 
         for (int i = parentLevel; i < allSources.size(); i++) {
             Vertex v = allSources.get(i);

File: src/main/java/graphql/schema/diffing/PossibleMappingsCalculator.java
Patch:
@@ -1094,7 +1094,9 @@ private Map<Vertex, Vertex> getFixedParentRestrictions(SchemaGraph sourceGraph,
      * @param mapping the mapping to get non-fixed parent restrictions for
      * @return Map where key is any vertex, and the value is the parent that vertex must map to
      */
-    public Map<Vertex, Vertex> getNonFixedParentRestrictions(Mapping mapping) {
+    public Map<Vertex, Vertex> getNonFixedParentRestrictions(SchemaGraph sourceGraph,
+                                                             SchemaGraph targetGraph,
+                                                             Mapping mapping) {
         Map<Vertex, Vertex> restrictions = new LinkedHashMap<>();
 
         mapping.forEachNonFixedSourceAndTarget((source, target) -> {

File: src/main/java/graphql/schema/diffing/DiffImpl.java
Patch:
@@ -146,9 +146,7 @@ OptimalEdit diffImpl(Mapping startMapping, List<Vertex> allSources, List<Vertex>
                 continue;
 
             }
-//            if (count % 1000 == 0) {
-//                System.out.println(mappingEntry.lowerBoundCost + " vs ged " + optimalEdit.ged + " count " + count);
-//            }
+//            System.out.println(mappingEntry.lowerBoundCost + " vs ged " + optimalEdit.ged + " count " + count);
 
             if (mappingEntry.level > 0 && !mappingEntry.siblingsFinished) {
                 addSiblingToQueue(

File: src/test/groovy/example/http/ExecutionResultJSONTesting.java
Patch:
@@ -20,7 +20,7 @@
 import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorType;
 
-import javax.servlet.http.HttpServletResponse;
+import jakarta.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;

File: src/test/groovy/example/http/HttpMain.java
Patch:
@@ -27,9 +27,9 @@
 import org.eclipse.jetty.server.handler.HandlerList;
 import org.eclipse.jetty.server.handler.ResourceHandler;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
+import jakarta.servlet.ServletException;
+import jakarta.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;

File: src/test/groovy/example/http/JsonKit.java
Patch:
@@ -3,8 +3,8 @@
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.reflect.TypeToken;
+import jakarta.servlet.http.HttpServletResponse;
 
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.Collections;
 import java.util.Map;

File: src/test/groovy/example/http/QueryParameters.java
Patch:
@@ -1,6 +1,6 @@
 package example.http;
 
-import javax.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpServletRequest;
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.util.Collections;

File: src/main/java/graphql/schema/diffing/SchemaDiffing.java
Patch:
@@ -23,7 +23,7 @@ public class SchemaDiffing {
 
     /**
      * Tries to stop the algorithm from execution ASAP by throwing a
-     * {@link SchemaDiffingJobCancelledException}.
+     * {@link SchemaDiffingCancelledException}.
      */
     public void stop() {
         runningCheck.stop();

File: src/main/java/graphql/language/SDLExtensionDefinition.java
Patch:
@@ -4,7 +4,7 @@
 import graphql.PublicApi;
 
 /**
- * An marker interface for Schema Definition Language (SDL) extension definitions.
+ * A marker interface for Schema Definition Language (SDL) extension definitions.
  */
 @PublicApi
 public interface SDLExtensionDefinition {

File: src/main/java/graphql/language/SDLExtensionDefinition.java
Patch:
@@ -4,7 +4,7 @@
 import graphql.PublicApi;
 
 /**
- * An marker interface for Schema Definition Language (SDL) extension definitions.
+ * A marker interface for Schema Definition Language (SDL) extension definitions.
  */
 @PublicApi
 public interface SDLExtensionDefinition {

File: src/main/java/graphql/execution/instrumentation/ExecutionStrategyInstrumentationContext.java
Patch:
@@ -4,8 +4,8 @@
 import graphql.Internal;
 import graphql.PublicSpi;
 import graphql.execution.FieldValueInfo;
+import org.jetbrains.annotations.NotNull;
 
-import javax.annotation.Nonnull;
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
 
@@ -27,7 +27,7 @@ default void onFieldValuesException() {
      *
      * @return a non null {@link InstrumentationContext} that maybe a no-op
      */
-    @Nonnull
+    @NotNull
     @Internal
     static ExecutionStrategyInstrumentationContext nonNullCtx(ExecutionStrategyInstrumentationContext nullableContext) {
         return nullableContext == null ? NOOP : nullableContext;

File: src/main/java/graphql/execution/instrumentation/SimpleInstrumentationContext.java
Patch:
@@ -1,8 +1,8 @@
 package graphql.execution.instrumentation;
 
 import graphql.PublicApi;
+import org.jetbrains.annotations.NotNull;
 
-import javax.annotation.Nonnull;
 import java.util.concurrent.CompletableFuture;
 import java.util.function.BiConsumer;
 import java.util.function.Consumer;
@@ -43,7 +43,7 @@ public static <T> InstrumentationContext<T> noOp() {
      *
      * @return a non null {@link InstrumentationContext} that maybe a no-op
      */
-    @Nonnull
+    @NotNull
     public static <T> InstrumentationContext<T> nonNullCtx(InstrumentationContext<T> nullableContext) {
         return nullableContext == null ? noOp() : nullableContext;
     }

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -1,6 +1,5 @@
 package graphql.parser;
 
-
 import com.google.common.collect.ImmutableList;
 import graphql.Assert;
 import graphql.Internal;
@@ -68,8 +67,8 @@
 import org.antlr.v4.runtime.ParserRuleContext;
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.tree.TerminalNode;
+import org.jetbrains.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.ArrayList;

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -1,6 +1,5 @@
 package graphql.schema;
 
-
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import graphql.DirectivesUtil;
@@ -14,8 +13,8 @@
 import graphql.util.FpKit;
 import graphql.util.TraversalControl;
 import graphql.util.TraverserContext;
+import org.jetbrains.annotations.NotNull;
 
-import javax.annotation.Nonnull;
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -149,7 +148,7 @@ private ImmutableMap<String, GraphQLEnumValueDefinition> buildMap(List<GraphQLEn
                 (fld1, fld2) -> assertShouldNeverHappen("Duplicated definition for field '%s' in type '%s'", fld1.getName(), this.name)));
     }
 
-    private Object getValueByName(@Nonnull Object value, GraphQLContext graphQLContext, Locale locale) {
+    private Object getValueByName(@NotNull Object value, GraphQLContext graphQLContext, Locale locale) {
         GraphQLEnumValueDefinition enumValueDefinition = valueDefinitionMap.get(value.toString());
         if (enumValueDefinition != null) {
             return enumValueDefinition.getValue();

File: src/main/java/graphql/schema/impl/SchemaUtil.java
Patch:
@@ -100,6 +100,7 @@ public static void replaceTypeReferences(GraphQLSchema schema) {
         final Map<String, GraphQLNamedType> typeMap = schema.getTypeMap();
         List<GraphQLSchemaElement> roots = new ArrayList<>(typeMap.values());
         roots.addAll(schema.getDirectives());
+        roots.addAll(schema.getSchemaAppliedDirectives());
         SchemaTraverser schemaTraverser = new SchemaTraverser(schemaElement -> schemaElement.getChildrenWithTypeReferences().getChildrenAsList());
         schemaTraverser.depthFirst(new GraphQLTypeResolvingVisitor(typeMap), roots);
     }

File: src/main/java/graphql/execution/instrumentation/fieldvalidation/FieldValidationInstrumentation.java
Patch:
@@ -43,6 +43,6 @@ public FieldValidationInstrumentation(FieldValidation fieldValidation) {
         if (errors != null && !errors.isEmpty()) {
             throw new AbortExecutionException(errors);
         }
-        return super.beginExecuteOperation(parameters);
+        return super.beginExecuteOperation(parameters, state);
     }
 }

File: src/main/java/graphql/schema/impl/SchemaUtil.java
Patch:
@@ -100,6 +100,7 @@ public static void replaceTypeReferences(GraphQLSchema schema) {
         final Map<String, GraphQLNamedType> typeMap = schema.getTypeMap();
         List<GraphQLSchemaElement> roots = new ArrayList<>(typeMap.values());
         roots.addAll(schema.getDirectives());
+        roots.addAll(schema.getSchemaAppliedDirectives());
         SchemaTraverser schemaTraverser = new SchemaTraverser(schemaElement -> schemaElement.getChildrenWithTypeReferences().getChildrenAsList());
         schemaTraverser.depthFirst(new GraphQLTypeResolvingVisitor(typeMap), roots);
     }

File: src/main/java/graphql/schema/GraphQLAppliedDirectiveArgument.java
Patch:
@@ -26,7 +26,7 @@
  * You can think of them as 'instances' of {@link GraphQLArgument}, when applied to a directive on a schema element
  */
 @PublicApi
-public class GraphQLAppliedDirectiveArgument implements GraphQLNamedSchemaElement {
+public class GraphQLAppliedDirectiveArgument implements GraphQLNamedSchemaElement, GraphQLInputSchemaElement {
 
     private final String name;
     private final InputValueWithState value;

File: src/main/java/graphql/schema/GraphQLInputType.java
Patch:
@@ -8,5 +8,5 @@
  * to {@link graphql.schema.GraphQLOutputType}s which can only be used as graphql response output.
  */
 @PublicApi
-public interface GraphQLInputType extends GraphQLType {
+public interface GraphQLInputType extends GraphQLType, GraphQLInputSchemaElement {
 }

File: src/main/java/graphql/schema/GraphQLInputValueDefinition.java
Patch:
@@ -11,7 +11,7 @@
  * @see graphql.schema.GraphQLArgument
  */
 @PublicApi
-public interface GraphQLInputValueDefinition extends GraphQLDirectiveContainer {
+public interface GraphQLInputValueDefinition extends GraphQLDirectiveContainer, GraphQLInputSchemaElement {
 
     <T extends GraphQLInputType> T getType();
 }

File: src/main/java/graphql/schema/usage/SchemaUsageSupport.java
Patch:
@@ -135,6 +135,7 @@ public TraversalControl visitGraphQLUnionType(GraphQLUnionType unionType, Traver
                 List<GraphQLNamedOutputType> members = unionType.getTypes();
                 for (GraphQLNamedOutputType member : members) {
                     builder.unionReferenceCount.compute(member.getName(), incCount());
+                    builder.unionReferences.computeIfAbsent(member.getName(), k -> new HashSet<>()).add(unionType.getName());
 
                     recordBackReference(unionType, member);
                 }

File: src/main/java/graphql/scalar/GraphqlStringCoercing.java
Patch:
@@ -28,7 +28,7 @@ private String toStringImpl(Object input) {
         return String.valueOf(input);
     }
 
-    private String parseValueImpl(@NotNull Object input, Locale locale) {
+    private String parseValueImpl(@NotNull Object input, @NotNull Locale locale) {
         if (!(input instanceof String)) {
             throw new CoercingParseValueException(
                     i18nMsg(locale, "String.unexpectedRawValueType", typeName(input))

File: src/main/java/graphql/execution/MergedSelectionSet.java
Patch:
@@ -5,7 +5,6 @@
 import graphql.Assert;
 import graphql.PublicApi;
 
-import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -53,7 +52,7 @@ public static Builder newMergedSelectionSet() {
     }
 
     public static class Builder {
-        private Map<String, MergedField> subFields = new LinkedHashMap<>();
+        private Map<String, MergedField> subFields = ImmutableMap.of();
 
         private Builder() {
 

File: src/main/java/graphql/GraphqlErrorBuilder.java
Patch:
@@ -4,8 +4,8 @@
 import graphql.execution.ResultPath;
 import graphql.language.SourceLocation;
 import graphql.schema.DataFetchingEnvironment;
-
 import org.jetbrains.annotations.Nullable;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -20,7 +20,7 @@
  */
 @SuppressWarnings("unchecked")
 @PublicApi
-public class GraphqlErrorBuilder<B extends GraphqlErrorBuilder<B>> {
+public class GraphqlErrorBuilder<B extends GraphqlErrorBuilder<B>> implements GraphQLError.Builder<B> {
 
     private String message;
     private List<Object> path;

File: src/main/java/graphql/schema/idl/ImplementingTypesChecker.java
Patch:
@@ -186,8 +186,9 @@ private void checkArgumentConsistency(
             if (objectArg == null) {
                 errors.add(new MissingInterfaceFieldArgumentsError(typeOfType, objectTypeDef, interfaceTypeDef, objectFieldDef));
             } else {
-                String interfaceArgStr = AstPrinter.printAstCompact(interfaceArg);
-                String objectArgStr = AstPrinter.printAstCompact(objectArg);
+                // we need to remove the not relevant  applied directives on the argument definitions to compare
+                String interfaceArgStr = AstPrinter.printAstCompact(interfaceArg.transform(builder -> builder.directives(emptyList())));
+                String objectArgStr = AstPrinter.printAstCompact(objectArg.transform(builder -> builder.directives(emptyList())));
                 if (!interfaceArgStr.equals(objectArgStr)) {
                     errors.add(new InterfaceFieldArgumentRedefinitionError(typeOfType, objectTypeDef, interfaceTypeDef, objectFieldDef, objectArgStr, interfaceArgStr));
                 }

File: src/main/java/graphql/schema/diffing/SchemaGraphFactory.java
Patch:
@@ -217,7 +217,7 @@ private void handleField(Vertex fieldVertex, GraphQLFieldDefinition fieldDefinit
 //        schemaGraph.addEdge(new Edge(fieldVertex, dummyTypeVertex));
         Vertex typeVertex = assertNotNull(schemaGraph.getType(graphQLUnmodifiedType.getName()));
         Edge typeEdge = new Edge(fieldVertex, typeVertex);
-        typeEdge.setLabel(GraphQLTypeUtil.simplePrint(type));
+        typeEdge.setLabel("type=" + GraphQLTypeUtil.simplePrint(type) + ";");
         schemaGraph.addEdge(typeEdge);
 
         for (GraphQLArgument graphQLArgument : fieldDefinition.getArguments()) {

File: src/test/groovy/graphql/TypeReferenceSchema.java
Patch:
@@ -318,6 +318,7 @@ public Boolean parseLiteral(Object input) {
     public static GraphQLCodeRegistry codeRegistry = GraphQLCodeRegistry.newCodeRegistry()
             .typeResolver("Pet", new TypeResolverProxy())
             .typeResolver("Addressable", new TypeResolverProxy())
+            .typeResolver("Named", GarfieldSchema.namedTypeResolver)
             .build();
 
     public static GraphQLSchema SchemaWithReferences = GraphQLSchema.newSchema()

File: src/test/groovy/graphql/StarWarsSchema.java
Patch:
@@ -55,7 +55,6 @@ public class StarWarsSchema {
                     .name("appearsIn")
                     .description("Which movies they appear in.")
                     .type(list(episodeEnum)))
-            .typeResolver(StarWarsData.getCharacterTypeResolver())
             .comparatorRegistry(BY_NAME_REGISTRY)
             .build();
 
@@ -180,6 +179,7 @@ public class StarWarsSchema {
             .dataFetcher(humanCoordinates, humanDataFetcher)
             .dataFetcher(droidCoordinates, droidDataFetcher)
             .dataFetcher(createHumanCoordinates, createHumanDataFetcher)
+            .typeResolver("Character", StarWarsData.getCharacterTypeResolver())
             .build();
 
     public static GraphQLSchema starWarsSchema = GraphQLSchema.newSchema()

File: src/main/java/graphql/execution/instrumentation/Instrumentation.java
Patch:
@@ -468,7 +468,7 @@ default GraphQLSchema instrumentSchema(GraphQLSchema schema, InstrumentationExec
      *
      * @return a non null instrumented ExecutionContext, the default is to return to the same object
      *
-     * @deprecated use {@link #instrumentExecutionContext(ExecutionContext, InstrumentationExecutionParameters)} instead
+     * @deprecated use {@link #instrumentExecutionContext(ExecutionContext, InstrumentationExecutionParameters, InstrumentationState)} instead
      */
     @Deprecated
     @DeprecatedAt("2022-07-26")

File: src/test/groovy/example/http/ExecutionResultJSONTesting.java
Patch:
@@ -70,7 +70,7 @@ private void testGson(HttpServletResponse response, Object er) throws IOExceptio
     private ExecutionResult createER() {
         List<GraphQLError> errors = new ArrayList<>();
 
-        errors.add(new ValidationError(ValidationErrorType.UnknownType, mkLocations(), "Test ValidationError"));
+        errors.add(new ValidationError(ValidationErrorType.UnknownType, mkLocations(), "Test ValidationError")); // Retain as there is no alternative constructor for ValidationError
         errors.add(new MissingRootTypeException("Mutations are not supported.", null));
         errors.add(new InvalidSyntaxError(mkLocations(), "Not good syntax m'kay"));
         errors.add(new NonNullableFieldWasNullError(new NonNullableFieldWasNullException(mkExecutionInfo(), mkPath())));

File: src/test/groovy/graphql/NestedInputSchema.java
Patch:
@@ -63,7 +63,7 @@ public static GraphQLObjectType rootType() {
                         .argument(GraphQLArgument.newArgument()
                                 .name("intialValue")
                                 .type(GraphQLInt)
-                                .defaultValue(5))
+                                .defaultValueProgrammatic(5))
                         .argument(GraphQLArgument.newArgument()
                                 .name("filter")
                                 .type(filterType())))

File: src/test/groovy/graphql/ScalarsQuerySchema.java
Patch:
@@ -22,7 +22,7 @@ public class ScalarsQuerySchema {
             .field(newFieldDefinition()
                     .name("floatNaN")
                     .type(Scalars.GraphQLFloat)
-                    .staticValue(Double.NaN))
+                    .staticValue(Double.NaN)) // Retain for test coverage
             // Scalars with input of same type, value echoed back
             .field(newFieldDefinition()
                     .name("floatNaNInput")

File: src/test/groovy/graphql/execution/instrumentation/dataloader/BatchCompareDataFetchers.java
Patch:
@@ -6,6 +6,7 @@
 import graphql.schema.DataFetcher;
 import org.dataloader.BatchLoader;
 import org.dataloader.DataLoader;
+import org.dataloader.DataLoaderFactory;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -99,7 +100,7 @@ private static List<List<Department>> getDepartmentsForShops(List<Shop> shops) {
         return completedFuture(getDepartmentsForShops(shopList));
     });
 
-    public DataLoader<String, List<Department>> departmentsForShopDataLoader = new DataLoader<>(departmentsForShopsBatchLoader);
+    public DataLoader<String, List<Department>> departmentsForShopDataLoader = DataLoaderFactory.newDataLoader(departmentsForShopsBatchLoader);
 
     public DataFetcher<CompletableFuture<List<Department>>> departmentsForShopDataLoaderDataFetcher = environment -> {
         Shop shop = environment.getSource();
@@ -136,7 +137,7 @@ private static List<List<Product>> getProductsForDepartments(List<Department> de
         return completedFuture(getProductsForDepartments(d));
     });
 
-    public DataLoader<String, List<Product>> productsForDepartmentDataLoader = new DataLoader<>(productsForDepartmentsBatchLoader);
+    public DataLoader<String, List<Product>> productsForDepartmentDataLoader = DataLoaderFactory.newDataLoader(productsForDepartmentsBatchLoader);
 
     public DataFetcher<CompletableFuture<List<Product>>> productsForDepartmentDataLoaderDataFetcher = environment -> {
         Department department = environment.getSource();

File: src/test/groovy/graphql/execution/instrumentation/dataloader/DataLoaderCompanyProductBackend.java
Patch:
@@ -3,9 +3,8 @@
 
 import com.google.common.collect.ImmutableList;
 import org.dataloader.DataLoader;
+import org.dataloader.DataLoaderFactory;
 
-import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
@@ -27,7 +26,7 @@ public DataLoaderCompanyProductBackend(int companyCount, int projectCount) {
             mkCompany(projectCount);
         }
 
-        projectsLoader = new DataLoader<>(keys -> getProjectsForCompanies(keys).thenApply(projects -> keys
+        projectsLoader = DataLoaderFactory.newDataLoader(keys -> getProjectsForCompanies(keys).thenApply(projects -> keys
                 .stream()
                 .map(companyId -> projects.stream()
                         .filter(project -> project.getCompanyId().equals(companyId))

File: src/main/java/graphql/schema/GraphQLDirectiveContainer.java
Patch:
@@ -9,15 +9,15 @@
 import static graphql.collect.ImmutableKit.emptyList;
 
 /**
- * Represents a graphql runtime type that can have {@link graphql.schema.GraphQLAppliedDirective}'s.
+ * Represents a graphql runtime type that can have {@link graphql.schema.GraphQLAppliedDirective}s.
  * <p>
  * Directives can be repeatable and (by default) non-repeatable.
  * <p>
  * There are access methods here that get the two different types.
  * <p>
  * The use of {@link GraphQLDirective} to represent a directive applied to an element is deprecated in favour of
- * {@link GraphQLAppliedDirective}.   A {@link GraphQLDirective} really should represent the definition of a directive in a schema not its use
- * on schema elements.  However, it has been left in place for legacy reasons and will be removed in a
+ * {@link GraphQLAppliedDirective}. A {@link GraphQLDirective} really should represent the definition of a directive in a schema, not its use
+ * on schema elements. However, it has been left in place for legacy reasons and will be removed in a
  * future version.
  *
  * @see graphql.language.DirectiveDefinition

File: src/main/java/graphql/schema/GraphQLDirectiveContainer.java
Patch:
@@ -9,15 +9,15 @@
 import static graphql.collect.ImmutableKit.emptyList;
 
 /**
- * Represents a graphql runtime type that can have {@link graphql.schema.GraphQLAppliedDirective}'s.
+ * Represents a graphql runtime type that can have {@link graphql.schema.GraphQLAppliedDirective}s.
  * <p>
  * Directives can be repeatable and (by default) non-repeatable.
  * <p>
  * There are access methods here that get the two different types.
  * <p>
  * The use of {@link GraphQLDirective} to represent a directive applied to an element is deprecated in favour of
- * {@link GraphQLAppliedDirective}.   A {@link GraphQLDirective} really should represent the definition of a directive in a schema not its use
- * on schema elements.  However, it has been left in place for legacy reasons and will be removed in a
+ * {@link GraphQLAppliedDirective}. A {@link GraphQLDirective} really should represent the definition of a directive in a schema, not its use
+ * on schema elements. However, it has been left in place for legacy reasons and will be removed in a
  * future version.
  *
  * @see graphql.language.DirectiveDefinition

File: src/main/java/graphql/schema/Coercing.java
Patch:
@@ -15,7 +15,7 @@
 import static graphql.Assert.assertNotNull;
 
 /**
- * The Coercing interface is used by {@link graphql.schema.GraphQLScalarType}s to parse and serialise object values.
+ * The Coercing interface is used by {@link graphql.schema.GraphQLScalarType}s to parse and serialize object values.
  * <p>
  * There are two major responsibilities, result coercion and input coercion.
  * <p>
@@ -41,7 +41,7 @@ public interface Coercing<I, O> {
      * Called to convert a Java object result of a DataFetcher to a valid runtime value for the scalar type.
      * <p>
      * Note : Throw {@link graphql.schema.CoercingSerializeException} if there is fundamental
-     * problem during serialisation, don't return null to indicate failure.
+     * problem during serialization, don't return null to indicate failure.
      * <p>
      * Note : You should not allow {@link java.lang.RuntimeException}s to come out of your serialize method, but rather
      * catch them and fire them as {@link graphql.schema.CoercingSerializeException} instead as per the method contract.
@@ -60,7 +60,7 @@ public interface Coercing<I, O> {
      * Called to convert a Java object result of a DataFetcher to a valid runtime value for the scalar type.
      * <p>
      * Note : Throw {@link graphql.schema.CoercingSerializeException} if there is fundamental
-     * problem during serialisation, don't return null to indicate failure.
+     * problem during serialization, don't return null to indicate failure.
      * <p>
      * Note : You should not allow {@link java.lang.RuntimeException}s to come out of your serialize method, but rather
      * catch them and fire them as {@link graphql.schema.CoercingSerializeException} instead as per the method contract.

File: src/main/java/graphql/schema/GraphQLAppliedDirectiveArgument.java
Patch:
@@ -76,7 +76,7 @@ public boolean hasSetValue() {
     }
 
     /**
-     * This swill give out an internal java value based on the semantics captured
+     * This will give out an internal java value based on the semantics captured
      * in the {@link InputValueWithState} from {@link GraphQLAppliedDirectiveArgument#getArgumentValue()}
      *
      * Note : You MUST only call this on a {@link GraphQLAppliedDirectiveArgument} that is part of a fully formed schema.  We need

File: src/main/java/graphql/schema/GraphQLSchema.java
Patch:
@@ -476,7 +476,7 @@ public List<GraphQLDirective> getSchemaDirectives() {
      * directives for all schema elements, whereas this is just for the schema
      * element itself
      *
-     * @return a map  of directives
+     * @return a map of directives
      *
      * @deprecated Use the {@link GraphQLAppliedDirective} methods instead
      */

File: src/main/java/graphql/schema/diff/SchemaDiff.java
Patch:
@@ -70,7 +70,7 @@ public static Options defaultOptions() {
 
     private static class CountingReporter implements DifferenceReporter {
         final DifferenceReporter delegate;
-        int breakingCount = 1;
+        int breakingCount = 0;
 
         private CountingReporter(DifferenceReporter delegate) {
             this.delegate = delegate;

File: src/main/java/graphql/util/NodeLocation.java
Patch:
@@ -33,7 +33,7 @@ public int getIndex() {
 
     @Override
     public String toString() {
-        return "NodeLocation{" +
+        return "{" +
             "name='" + name + '\'' +
             ", index=" + index +
             '}';

File: src/main/java/graphql/util/NodeLocation.java
Patch:
@@ -33,7 +33,7 @@ public int getIndex() {
 
     @Override
     public String toString() {
-        return "NodeLocation{" +
+        return "{" +
             "name='" + name + '\'' +
             ", index=" + index +
             '}';

File: src/main/java/graphql/schema/Coercing.java
Patch:
@@ -203,6 +203,7 @@ default I parseValue(@NotNull Object input, @NotNull GraphQLContext graphQLConte
      *
      * @param input          an external input value
      * @param graphQLContext the graphql context in place
+     * @param locale         the locale to use
      *
      * @return The literal matching the external input value.
      */

File: src/main/java/graphql/ExecutionInput.java
Patch:
@@ -44,7 +44,7 @@ private ExecutionInput(Builder builder) {
         this.dataLoaderRegistry = builder.dataLoaderRegistry;
         this.cacheControl = builder.cacheControl;
         this.executionId = builder.executionId;
-        this.locale = builder.locale;
+        this.locale = builder.locale != null ? builder.locale : Locale.getDefault(); // always have a locale in place
         this.localContext = builder.localContext;
         this.extensions = builder.extensions;
     }

File: src/main/java/graphql/analysis/QueryTraverser.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.analysis;
 
+import graphql.GraphQLContext;
 import graphql.PublicApi;
 import graphql.execution.CoercedVariables;
 import graphql.execution.RawVariables;
@@ -20,6 +21,7 @@
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 
 import static graphql.Assert.assertNotNull;
@@ -70,7 +72,7 @@ private QueryTraverser(GraphQLSchema schema,
         this.fragmentsByName = getOperationResult.fragmentsByName;
         this.roots = singletonList(getOperationResult.operationDefinition);
         this.rootParentType = getRootTypeFromOperation(getOperationResult.operationDefinition);
-        this.coercedVariables = ValuesResolver.coerceVariableValues(schema, variableDefinitions, rawVariables);
+        this.coercedVariables = ValuesResolver.coerceVariableValues(schema, variableDefinitions, rawVariables, GraphQLContext.getDefault(), Locale.getDefault());
     }
 
     private QueryTraverser(GraphQLSchema schema,

File: src/main/java/graphql/execution/ConditionalNodes.java
Patch:
@@ -1,11 +1,13 @@
 package graphql.execution;
 
 import graphql.Assert;
+import graphql.GraphQLContext;
 import graphql.Internal;
 import graphql.language.Directive;
 import graphql.language.NodeUtil;
 
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 
 import static graphql.Directives.IncludeDirective;
@@ -30,7 +32,7 @@ public boolean shouldInclude(Map<String, Object> variables, List<Directive> dire
     private boolean getDirectiveResult(Map<String, Object> variables, List<Directive> directives, String directiveName, boolean defaultValue) {
         Directive foundDirective = NodeUtil.findNodeByName(directives, directiveName);
         if (foundDirective != null) {
-            Map<String, Object> argumentValues = ValuesResolver.getArgumentValues(SkipDirective.getArguments(), foundDirective.getArguments(), CoercedVariables.of(variables));
+            Map<String, Object> argumentValues = ValuesResolver.getArgumentValues(SkipDirective.getArguments(), foundDirective.getArguments(), CoercedVariables.of(variables), GraphQLContext.getDefault(), Locale.getDefault());
             Object flag = argumentValues.get("if");
             Assert.assertTrue(flag instanceof Boolean, () -> String.format("The '%s' directive MUST have a value for the 'if' argument", directiveName));
             return (Boolean) flag;

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -63,7 +63,7 @@ public CompletableFuture<ExecutionResult> execute(Document document, GraphQLSche
 
         CoercedVariables coercedVariables;
         try {
-            coercedVariables = ValuesResolver.coerceVariableValues(graphQLSchema, variableDefinitions, inputVariables);
+            coercedVariables = ValuesResolver.coerceVariableValues(graphQLSchema, variableDefinitions, inputVariables, executionInput.getGraphQLContext(), executionInput.getLocale());
         } catch (RuntimeException rte) {
             if (rte instanceof GraphQLError) {
                 return completedFuture(new ExecutionResultImpl((GraphQLError) rte));

File: src/main/java/graphql/execution/directives/QueryAppliedDirectiveArgument.java
Patch:
@@ -2,6 +2,7 @@
 
 
 import graphql.Assert;
+import graphql.GraphQLContext;
 import graphql.PublicApi;
 import graphql.language.Argument;
 import graphql.language.Value;
@@ -12,6 +13,7 @@
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import java.util.Locale;
 import java.util.function.Consumer;
 
 import static graphql.Assert.assertNotNull;
@@ -83,7 +85,7 @@ public boolean hasSetValue() {
      */
     @Nullable
     public <T> T getValue() {
-        return getInputValueImpl(getType(), value);
+        return getInputValueImpl(getType(), value, GraphQLContext.getDefault(), Locale.getDefault());
     }
 
     /**

File: src/main/java/graphql/introspection/IntrospectionWithDirectivesSupport.java
Patch:
@@ -204,7 +204,7 @@ private GraphQLObjectType addAppliedDirectives(GraphQLObjectType originalType, G
         DataFetcher<?> argValueDF = env -> {
             final GraphQLAppliedDirectiveArgument argument = env.getSource();
             InputValueWithState value = argument.getArgumentValue();
-            Node<?> literal = ValuesResolver.valueToLiteral(value, argument.getType());
+            Node<?> literal = ValuesResolver.valueToLiteral(value, argument.getType(), env.getGraphQlContext(), env.getLocale());
             return AstPrinter.printAst(literal);
         };
         codeRegistry.dataFetcher(coordinates(objectType, "appliedDirectives"), df);

File: src/main/java/graphql/schema/GraphQLAppliedDirectiveArgument.java
Patch:
@@ -2,6 +2,7 @@
 
 
 import graphql.Assert;
+import graphql.GraphQLContext;
 import graphql.PublicApi;
 import graphql.collect.ImmutableKit;
 import graphql.language.Argument;
@@ -12,6 +13,7 @@
 import org.jetbrains.annotations.Nullable;
 
 import java.util.List;
+import java.util.Locale;
 import java.util.function.Consumer;
 
 import static graphql.Assert.assertNotNull;
@@ -86,7 +88,7 @@ public boolean hasSetValue() {
      * @return a value of type T which is the java value of the argument
      */
     public <T> T getValue() {
-        return getInputValueImpl(getType(), value);
+        return getInputValueImpl(getType(), value, GraphQLContext.getDefault(), Locale.getDefault());
     }
 
     /**

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -3,6 +3,7 @@
 
 import graphql.DeprecatedAt;
 import graphql.DirectivesUtil;
+import graphql.GraphQLContext;
 import graphql.PublicApi;
 import graphql.language.InputValueDefinition;
 import graphql.language.Value;
@@ -12,6 +13,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.function.Consumer;
 
@@ -107,7 +109,7 @@ public GraphQLInputType getType() {
      * @return a value of type T which is the java value of the input field default
      */
     public static <T> T getInputFieldDefaultValue(GraphQLInputObjectField inputObjectField) {
-        return getInputValueImpl(inputObjectField.getType(), inputObjectField.getInputFieldDefaultValue());
+        return getInputValueImpl(inputObjectField.getType(), inputObjectField.getInputFieldDefaultValue(), GraphQLContext.getDefault(), Locale.getDefault());
     }
 
 

File: src/main/java/graphql/schema/idl/SchemaPrinter.java
Patch:
@@ -2,6 +2,7 @@
 
 import graphql.Assert;
 import graphql.DirectivesUtil;
+import graphql.GraphQLContext;
 import graphql.PublicApi;
 import graphql.execution.ValuesResolver;
 import graphql.language.AstPrinter;
@@ -53,6 +54,7 @@
 import java.util.Comparator;
 import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
@@ -713,7 +715,7 @@ private void printAsAst(PrintWriter out, TypeDefinition<?> definition, List<? ex
     }
 
     private static String printAst(InputValueWithState value, GraphQLInputType type) {
-        return AstPrinter.printAst(ValuesResolver.valueToLiteral(value, type));
+        return AstPrinter.printAst(ValuesResolver.valueToLiteral(value, type, GraphQLContext.getDefault(), Locale.getDefault()));
     }
 
     private SchemaElementPrinter<GraphQLSchema> schemaPrinter() {

File: src/main/java/graphql/validation/rules/ArgumentsOfCorrectType.java
Patch:
@@ -10,6 +10,8 @@
 import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 
+import java.util.Locale;
+
 import static graphql.validation.ValidationErrorType.WrongType;
 
 @Internal
@@ -26,7 +28,7 @@ public void checkArgument(Argument argument) {
             return;
         }
         ArgumentValidationUtil validationUtil = new ArgumentValidationUtil(argument);
-        if (!validationUtil.isValidLiteralValue(argument.getValue(), fieldArgument.getType(), getValidationContext().getSchema())) {
+        if (!validationUtil.isValidLiteralValue(argument.getValue(), fieldArgument.getType(), getValidationContext().getSchema(), getValidationContext().getGraphQLContext(), Locale.getDefault())) {
             String message = i18n(WrongType, validationUtil.getMsgAndArgs());
             addError(ValidationError.newValidationError()
                     .validationErrorType(WrongType)

File: src/main/java/graphql/validation/rules/VariableDefaultValuesOfCorrectType.java
Patch:
@@ -7,6 +7,8 @@
 import graphql.validation.ValidationContext;
 import graphql.validation.ValidationErrorCollector;
 
+import java.util.Locale;
+
 import static graphql.schema.GraphQLTypeUtil.simplePrint;
 import static graphql.validation.ValidationErrorType.BadValueForDefaultArg;
 
@@ -25,7 +27,7 @@ public void checkVariableDefinition(VariableDefinition variableDefinition) {
             return;
         }
         if (variableDefinition.getDefaultValue() != null
-                && !getValidationUtil().isValidLiteralValue(variableDefinition.getDefaultValue(), inputType, getValidationContext().getSchema())) {
+                && !getValidationUtil().isValidLiteralValue(variableDefinition.getDefaultValue(), inputType, getValidationContext().getSchema(), getValidationContext().getGraphQLContext(), Locale.getDefault())) {
             String message = i18n(BadValueForDefaultArg, "VariableDefaultValuesOfCorrectType.badDefault", variableDefinition.getDefaultValue(), simplePrint(inputType));
             addError(BadValueForDefaultArg, variableDefinition.getSourceLocation(), message);
         }

File: src/main/java/graphql/validation/rules/VariableTypesMatch.java
Patch:
@@ -65,14 +65,14 @@ public void checkVariable(VariableReference variableReference) {
         if (schemaDefault.isPresent() && schemaDefault.get().isLiteral()) {
             schemaDefaultValue = (Value) schemaDefault.get().getValue();
         } else if (schemaDefault.isPresent() && schemaDefault.get().isSet()) {
-            schemaDefaultValue = ValuesResolver.valueToLiteral(schemaDefault.get(), expectedType);
+            schemaDefaultValue = ValuesResolver.valueToLiteral(schemaDefault.get(), expectedType, getValidationContext().getGraphQLContext(), getValidationContext().getI18n().getLocale());
         }
         if (expectedType == null) {
             // we must have a unknown variable say to not have a known type
             return;
         }
         if (!variablesTypesMatcher.doesVariableTypesMatch(variableType, variableDefinition.getDefaultValue(), expectedType) &&
-            !variablesTypesMatcher.doesVariableTypesMatch(variableType, schemaDefaultValue, expectedType)) {
+                !variablesTypesMatcher.doesVariableTypesMatch(variableType, schemaDefaultValue, expectedType)) {
             GraphQLType effectiveType = variablesTypesMatcher.effectiveType(variableType, variableDefinition.getDefaultValue());
             String message = i18n(VariableTypeMismatch, "VariableTypesMatchRule.unexpectedType",
                     GraphQLTypeUtil.simplePrint(effectiveType),

File: src/main/java/graphql/schema/idl/SchemaPrinter.java
Patch:
@@ -672,7 +672,7 @@ private SchemaElementPrinter<GraphQLInputObjectType> inputObjectPrinter() {
                                     String astValue = printAst(defaultValue, fd.getType());
                                     out.format(" = %s", astValue);
                                 }
-                                out.format(directivesString(GraphQLInputObjectField.class, fd.isDeprecated(), fd));
+                                out.print(directivesString(GraphQLInputObjectField.class, fd.isDeprecated(), fd));
                                 out.format("\n");
                             });
                     out.format("}");

File: src/main/java/graphql/Directives.java
Patch:
@@ -82,7 +82,7 @@ public class Directives {
 
     public static final GraphQLDirective SkipDirective = GraphQLDirective.newDirective()
             .name("skip")
-            .description("Directs the executor to skip this field or fragment when the `if`'argument is true.")
+            .description("Directs the executor to skip this field or fragment when the `if` argument is true.")
             .argument(newArgument()
                     .name("if")
                     .type(nonNull(GraphQLBoolean))

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -34,6 +34,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
@@ -625,7 +626,8 @@ private List<ValidationError> validate(ExecutionInput executionInput, Document d
         validationCtx.onDispatched(cf);
 
         Predicate<Class<?>> validationRulePredicate = executionInput.getGraphQLContext().getOrDefault(ParseAndValidate.INTERNAL_VALIDATION_PREDICATE_HINT, r -> true);
-        List<ValidationError> validationErrors = ParseAndValidate.validate(graphQLSchema, document, validationRulePredicate, executionInput.getLocale());
+        Locale locale = executionInput.getLocale() != null ? executionInput.getLocale() : Locale.getDefault();
+        List<ValidationError> validationErrors = ParseAndValidate.validate(graphQLSchema, document, validationRulePredicate, locale);
 
         validationCtx.onCompleted(validationErrors, null);
         cf.complete(validationErrors);

File: src/main/java/graphql/execution/AsyncExecutionStrategy.java
Patch:
@@ -42,7 +42,7 @@ public CompletableFuture<ExecutionResult> execute(ExecutionContext executionCont
         Instrumentation instrumentation = executionContext.getInstrumentation();
         InstrumentationExecutionStrategyParameters instrumentationParameters = new InstrumentationExecutionStrategyParameters(executionContext, parameters);
 
-        ExecutionStrategyInstrumentationContext executionStrategyCtx = instrumentation.beginExecutionStrategy(instrumentationParameters);
+        ExecutionStrategyInstrumentationContext executionStrategyCtx = ExecutionStrategyInstrumentationContext.nonNullCtx(instrumentation.beginExecutionStrategy(instrumentationParameters, executionContext.getInstrumentationState()));
 
         MergedSelectionSet fields = parameters.getFields();
         Set<String> fieldNames = fields.keySet();

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -30,6 +30,7 @@
 import static graphql.execution.ExecutionContextBuilder.newExecutionContextBuilder;
 import static graphql.execution.ExecutionStepInfo.newExecutionStepInfo;
 import static graphql.execution.ExecutionStrategyParameters.newParameters;
+import static graphql.execution.instrumentation.SimpleInstrumentationContext.nonNullCtx;
 import static graphql.language.OperationDefinition.Operation.MUTATION;
 import static graphql.language.OperationDefinition.Operation.QUERY;
 import static graphql.language.OperationDefinition.Operation.SUBSCRIPTION;
@@ -100,15 +101,15 @@ public CompletableFuture<ExecutionResult> execute(Document document, GraphQLSche
         InstrumentationExecutionParameters parameters = new InstrumentationExecutionParameters(
                 executionInput, graphQLSchema, instrumentationState
         );
-        executionContext = instrumentation.instrumentExecutionContext(executionContext, parameters);
+        executionContext = instrumentation.instrumentExecutionContext(executionContext, parameters, instrumentationState);
         return executeOperation(executionContext, executionInput.getRoot(), executionContext.getOperationDefinition());
     }
 
 
     private CompletableFuture<ExecutionResult> executeOperation(ExecutionContext executionContext, Object root, OperationDefinition operationDefinition) {
 
         InstrumentationExecuteOperationParameters instrumentationParams = new InstrumentationExecuteOperationParameters(executionContext);
-        InstrumentationContext<ExecutionResult> executeOperationCtx = instrumentation.beginExecuteOperation(instrumentationParams);
+        InstrumentationContext<ExecutionResult> executeOperationCtx = nonNullCtx(instrumentation.beginExecuteOperation(instrumentationParams, executionContext.getInstrumentationState()));
 
         OperationDefinition.Operation operation = operationDefinition.getOperation();
         GraphQLObjectType operationRootType;

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationFieldFetchParameters.java
Patch:
@@ -36,7 +36,10 @@ private InstrumentationFieldFetchParameters(ExecutionContext getExecutionContext
      * @param instrumentationState the new state for this parameters object
      *
      * @return a new parameters object with the new state
+     *
+     * @deprecated state is now passed in direct to instrumentation methods
      */
+    @Deprecated
     @Override
     public InstrumentationFieldFetchParameters withNewState(InstrumentationState instrumentationState) {
         return new InstrumentationFieldFetchParameters(

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationValidationParameters.java
Patch:
@@ -25,7 +25,10 @@ public InstrumentationValidationParameters(ExecutionInput executionInput, Docume
      * @param instrumentationState the new state for this parameters object
      *
      * @return a new parameters object with the new state
+     *
+     * @deprecated state is now passed in direct to instrumentation methods
      */
+    @Deprecated
     @Override
     public InstrumentationValidationParameters withNewState(InstrumentationState instrumentationState) {
         return new InstrumentationValidationParameters(

File: src/main/java/graphql/ExecutionInput.java
Patch:
@@ -225,7 +225,7 @@ public static class Builder {
         //
         private DataLoaderRegistry dataLoaderRegistry = DataLoaderDispatcherInstrumentationState.EMPTY_DATALOADER_REGISTRY;
         private CacheControl cacheControl = CacheControl.newCacheControl();
-        private Locale locale;
+        private Locale locale = Locale.getDefault();
         private ExecutionId executionId;
 
         public Builder query(String query) {

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -623,7 +623,7 @@ private List<ValidationError> validate(ExecutionInput executionInput, Document d
         validationCtx.onDispatched(cf);
 
         Predicate<Class<?>> validationRulePredicate = executionInput.getGraphQLContext().getOrDefault(ParseAndValidate.INTERNAL_VALIDATION_PREDICATE_HINT, r -> true);
-        List<ValidationError> validationErrors = ParseAndValidate.validate(graphQLSchema, document, validationRulePredicate);
+        List<ValidationError> validationErrors = ParseAndValidate.validate(graphQLSchema, document, validationRulePredicate, executionInput.getLocale());
 
         validationCtx.onCompleted(validationErrors, null);
         cf.complete(validationErrors);

File: src/main/java/graphql/nextgen/GraphQL.java
Patch:
@@ -265,7 +265,7 @@ private List<ValidationError> validate(ExecutionInput executionInput, Document d
         validationCtx.onDispatched(cf);
 
         Predicate<Class<?>> validationRulePredicate = executionInput.getGraphQLContext().getOrDefault(ParseAndValidate.INTERNAL_VALIDATION_PREDICATE_HINT, r -> true);
-        List<ValidationError> validationErrors = ParseAndValidate.validate(graphQLSchema, document, validationRulePredicate);
+        List<ValidationError> validationErrors = ParseAndValidate.validate(graphQLSchema, document, validationRulePredicate, executionInput.getLocale());
 
         validationCtx.onCompleted(validationErrors, null);
         cf.complete(validationErrors);

File: src/main/java/graphql/validation/ValidationErrorCollector.java
Patch:
@@ -59,7 +59,7 @@ public boolean containsValidationError(ValidationErrorType validationErrorType)
     public boolean containsValidationError(ValidationErrorType validationErrorType, String description) {
         for (ValidationError validationError : errors) {
             if (validationError.getValidationErrorType() == validationErrorType) {
-                return description == null || validationError.getDescription().equals(description);
+                return description == null || validationError.getDescription().contains(description);
             }
         }
         return false;

File: src/main/java/graphql/validation/ValidationErrorType.java
Patch:
@@ -10,8 +10,8 @@ public enum ValidationErrorType implements ValidationErrorClassification {
     DefaultForNonNullArgument,
     WrongType,
     UnknownType,
-    SubSelectionRequired,
-    SubSelectionNotAllowed,
+    SubselectionRequired,
+    SubselectionNotAllowed,
     InvalidSyntax,
     BadValueForDefaultArg,
     FieldUndefined,

File: src/test/java/benchmark/ValidatorBenchmark.java
Patch:
@@ -2,6 +2,7 @@
 
 import java.io.IOException;
 import java.net.URL;
+import java.util.Locale;
 import java.util.concurrent.TimeUnit;
 
 import com.google.common.base.Charsets;
@@ -73,6 +74,6 @@ private String readFromClasspath(String file) throws IOException {
     @Benchmark
     public void runValidator(MyState state) {
         Validator validator = new Validator();
-        validator.validateDocument(state.schema, state.document);
+        validator.validateDocument(state.schema, state.document, Locale.ENGLISH);
     }
 }

File: src/main/java/graphql/analysis/QueryTraverser.java
Patch:
@@ -70,7 +70,7 @@ private QueryTraverser(GraphQLSchema schema,
         this.fragmentsByName = getOperationResult.fragmentsByName;
         this.roots = singletonList(getOperationResult.operationDefinition);
         this.rootParentType = getRootTypeFromOperation(getOperationResult.operationDefinition);
-        this.coercedVariables = new ValuesResolver().coerceVariableValues(schema, variableDefinitions, rawVariables);
+        this.coercedVariables = ValuesResolver.coerceVariableValues(schema, variableDefinitions, rawVariables);
     }
 
     private QueryTraverser(GraphQLSchema schema,

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -40,7 +40,6 @@ public class Execution {
     private static final Logger logNotSafe = LogKit.getNotPrivacySafeLogger(Execution.class);
 
     private final FieldCollector fieldCollector = new FieldCollector();
-    private final ValuesResolver valuesResolver = new ValuesResolver();
     private final ExecutionStrategy queryStrategy;
     private final ExecutionStrategy mutationStrategy;
     private final ExecutionStrategy subscriptionStrategy;
@@ -66,7 +65,7 @@ public CompletableFuture<ExecutionResult> execute(Document document, GraphQLSche
 
         CoercedVariables coercedVariables;
         try {
-            coercedVariables = valuesResolver.coerceVariableValues(graphQLSchema, variableDefinitions, inputVariables);
+            coercedVariables = ValuesResolver.coerceVariableValues(graphQLSchema, variableDefinitions, inputVariables);
         } catch (RuntimeException rte) {
             if (rte instanceof GraphQLError) {
                 return completedFuture(new ExecutionResultImpl((GraphQLError) rte));

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -126,7 +126,6 @@ public abstract class ExecutionStrategy {
     private static final Logger log = LoggerFactory.getLogger(ExecutionStrategy.class);
     private static final Logger logNotSafe = LogKit.getNotPrivacySafeLogger(ExecutionStrategy.class);
 
-    protected final ValuesResolver valuesResolver = new ValuesResolver();
     protected final FieldCollector fieldCollector = new FieldCollector();
     protected final ExecutionStepInfoFactory executionStepInfoFactory = new ExecutionStepInfoFactory();
     private final ResolveType resolvedType = new ResolveType();
@@ -818,7 +817,7 @@ protected ExecutionStepInfo createExecutionStepInfo(ExecutionContext executionCo
         if (!fieldArgDefs.isEmpty()) {
             List<Argument> fieldArgs = field.getArguments();
             GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry();
-            argumentValues = FpKit.intraThreadMemoize(() -> valuesResolver.getArgumentValues(codeRegistry, fieldArgDefs, fieldArgs, executionContext.getCoercedVariables()));
+            argumentValues = FpKit.intraThreadMemoize(() -> ValuesResolver.getArgumentValues(codeRegistry, fieldArgDefs, fieldArgs, executionContext.getCoercedVariables()));
         }
 
 

File: src/main/java/graphql/execution/directives/DirectivesResolver.java
Patch:
@@ -20,8 +20,6 @@
 @Internal
 public class DirectivesResolver {
 
-    private final ValuesResolver valuesResolver = new ValuesResolver();
-
     public DirectivesResolver() {
     }
 
@@ -39,7 +37,7 @@ public Map<String, GraphQLDirective> resolveDirectives(List<Directive> directive
     }
 
     private void buildArguments(GraphQLDirective.Builder directiveBuilder, GraphQLCodeRegistry codeRegistry, GraphQLDirective protoType, Directive fieldDirective, Map<String, Object> variables) {
-        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, protoType.getArguments(), fieldDirective.getArguments(), CoercedVariables.of(variables));
+        Map<String, Object> argumentValues = ValuesResolver.getArgumentValues(codeRegistry, protoType.getArguments(), fieldDirective.getArguments(), CoercedVariables.of(variables));
         directiveBuilder.clearArguments();
         protoType.getArguments().forEach(protoArg -> {
             if (argumentValues.containsKey(protoArg.getName())) {

File: src/main/java/graphql/execution/nextgen/ExecutionHelper.java
Patch:
@@ -50,11 +50,10 @@ public ExecutionData createExecutionData(Document document,
         Map<String, FragmentDefinition> fragmentsByName = getOperationResult.fragmentsByName;
         OperationDefinition operationDefinition = getOperationResult.operationDefinition;
 
-        ValuesResolver valuesResolver = new ValuesResolver();
         RawVariables inputVariables = executionInput.getRawVariables();
         List<VariableDefinition> variableDefinitions = operationDefinition.getVariableDefinitions();
 
-        CoercedVariables coercedVariables = valuesResolver.coerceVariableValues(graphQLSchema, variableDefinitions, inputVariables);
+        CoercedVariables coercedVariables = ValuesResolver.coerceVariableValues(graphQLSchema, variableDefinitions, inputVariables);
 
         ExecutionContext executionContext = newExecutionContextBuilder()
                 .executionId(executionId)

File: src/main/java/graphql/schema/idl/SchemaGeneratorHelper.java
Patch:
@@ -96,7 +96,6 @@
 import static graphql.schema.GraphQLEnumValueDefinition.newEnumValueDefinition;
 import static graphql.schema.GraphQLTypeReference.typeRef;
 import static graphql.schema.idl.SchemaGeneratorAppliedDirectiveHelper.buildAppliedDirectives;
-import static graphql.schema.idl.SchemaGeneratorAppliedDirectiveHelper.buildDeprecationReason;
 import static graphql.schema.idl.SchemaGeneratorAppliedDirectiveHelper.buildDirectiveDefinitionFromAst;
 import static java.lang.String.format;
 import static java.util.stream.Collectors.toMap;
@@ -548,7 +547,7 @@ private void buildInterfaceTypeInterfaces(BuildContext buildCtx,
         });
 
         extensions.forEach(extension -> extension.getImplements().forEach(type -> {
-            GraphQLInterfaceType interfaceType = buildOutputType(buildCtx, type);
+            GraphQLNamedOutputType interfaceType = buildOutputType(buildCtx, type);
             if (!interfaces.containsKey(interfaceType.getName())) {
                 interfaces.put(interfaceType.getName(), interfaceType);
             }
@@ -658,7 +657,7 @@ private void buildObjectTypeInterfaces(BuildContext buildCtx,
         });
 
         extensions.forEach(extension -> extension.getImplements().forEach(type -> {
-            GraphQLInterfaceType interfaceType = buildOutputType(buildCtx, type);
+            GraphQLNamedOutputType interfaceType = buildOutputType(buildCtx, type);
             if (!interfaces.containsKey(interfaceType.getName())) {
                 interfaces.put(interfaceType.getName(), interfaceType);
             }

File: src/main/java/graphql/schema/idl/SchemaGeneratorHelper.java
Patch:
@@ -96,7 +96,6 @@
 import static graphql.schema.GraphQLEnumValueDefinition.newEnumValueDefinition;
 import static graphql.schema.GraphQLTypeReference.typeRef;
 import static graphql.schema.idl.SchemaGeneratorAppliedDirectiveHelper.buildAppliedDirectives;
-import static graphql.schema.idl.SchemaGeneratorAppliedDirectiveHelper.buildDeprecationReason;
 import static graphql.schema.idl.SchemaGeneratorAppliedDirectiveHelper.buildDirectiveDefinitionFromAst;
 import static java.lang.String.format;
 import static java.util.stream.Collectors.toMap;
@@ -548,7 +547,7 @@ private void buildInterfaceTypeInterfaces(BuildContext buildCtx,
         });
 
         extensions.forEach(extension -> extension.getImplements().forEach(type -> {
-            GraphQLInterfaceType interfaceType = buildOutputType(buildCtx, type);
+            GraphQLNamedOutputType interfaceType = buildOutputType(buildCtx, type);
             if (!interfaces.containsKey(interfaceType.getName())) {
                 interfaces.put(interfaceType.getName(), interfaceType);
             }
@@ -658,7 +657,7 @@ private void buildObjectTypeInterfaces(BuildContext buildCtx,
         });
 
         extensions.forEach(extension -> extension.getImplements().forEach(type -> {
-            GraphQLInterfaceType interfaceType = buildOutputType(buildCtx, type);
+            GraphQLNamedOutputType interfaceType = buildOutputType(buildCtx, type);
             if (!interfaces.containsKey(interfaceType.getName())) {
                 interfaces.put(interfaceType.getName(), interfaceType);
             }

File: src/main/java/graphql/validation/ValidationErrorCollector.java
Patch:
@@ -59,7 +59,7 @@ public boolean containsValidationError(ValidationErrorType validationErrorType)
     public boolean containsValidationError(ValidationErrorType validationErrorType, String description) {
         for (ValidationError validationError : errors) {
             if (validationError.getValidationErrorType() == validationErrorType) {
-                return description == null || validationError.getDescription().equals(description);
+                return description == null || validationError.getDescription().contains(description);
             }
         }
         return false;

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -589,7 +589,7 @@ private PreparsedDocumentEntry parseAndValidate(AtomicReference<ExecutionInput>
             final List<ValidationError> errors = validate(executionInput, document, graphQLSchema, instrumentationState);
             if (!errors.isEmpty()) {
                 logNotSafe.warn("Query did not validate : '{}'", query);
-                return new PreparsedDocumentEntry(errors);
+                return new PreparsedDocumentEntry(document, errors);
             }
 
             return new PreparsedDocumentEntry(document);

File: src/main/java/graphql/nextgen/GraphQL.java
Patch:
@@ -231,7 +231,7 @@ private PreparsedDocumentEntry parseAndValidate(AtomicReference<ExecutionInput>
             final List<ValidationError> errors = validate(executionInput, document, graphQLSchema, instrumentationState);
             if (!errors.isEmpty()) {
                 logNotSafe.warn("Query did not validate : '{}'", query);
-                return new PreparsedDocumentEntry(errors);
+                return new PreparsedDocumentEntry(document, errors);
             }
 
             return new PreparsedDocumentEntry(document);

File: src/test/groovy/readme/FieldSelectionExamples.java
Patch:
@@ -17,7 +17,7 @@ public Object get(DataFetchingEnvironment env) {
                 String userId = env.getArgument("userId");
 
                 DataFetchingFieldSelectionSet selectionSet = env.getSelectionSet();
-                if (selectionSet.contains("user/*")) {
+                if (selectionSet.contains("friends/*")) {
                     return getUserAndTheirFriends(userId);
                 } else {
                     return getUser(userId);

File: src/test/groovy/readme/FieldSelectionExamples.java
Patch:
@@ -17,7 +17,7 @@ public Object get(DataFetchingEnvironment env) {
                 String userId = env.getArgument("userId");
 
                 DataFetchingFieldSelectionSet selectionSet = env.getSelectionSet();
-                if (selectionSet.contains("user/*")) {
+                if (selectionSet.contains("friends/*")) {
                     return getUserAndTheirFriends(userId);
                 } else {
                     return getUser(userId);

File: src/main/java/graphql/execution/ExecutionContext.java
Patch:
@@ -116,6 +116,8 @@ public OperationDefinition getOperationDefinition() {
     }
 
     /**
+     * @return map of coerced variables
+     *
      * @deprecated use {@link #getCoercedVariables()} instead
      */
     @Deprecated

File: src/main/java/graphql/execution/ExecutionContextBuilder.java
Patch:
@@ -151,6 +151,9 @@ public ExecutionContextBuilder root(Object root) {
     }
 
     /**
+     * @param variables map of already coerced variables
+     * @return this builder
+     *
      * @deprecated use {@link #coercedVariables(CoercedVariables)} instead
      */
     @Deprecated

File: src/main/java/graphql/validation/ValidationErrorType.java
Patch:
@@ -38,5 +38,7 @@ public enum ValidationErrorType implements ValidationErrorClassification {
     DuplicateDirectiveName,
     DuplicateArgumentNames,
     DuplicateVariableName,
-    NullValueForNonNullArgument
+    NullValueForNonNullArgument,
+    SubscriptionMultipleRootFields,
+    SubscriptionIntrospectionRootField
 }

File: src/main/java/graphql/execution/AsyncSerialExecutionStrategy.java
Patch:
@@ -11,8 +11,8 @@
 import java.util.concurrent.CompletableFuture;
 
 /**
- * Async non-blocking execution, but serial: only one field at the the time will be resolved.
- * See {@link AsyncExecutionStrategy} for a non serial (parallel) execution of every field.
+ * Async non-blocking execution, but serial: only one field at the time will be resolved.
+ * See {@link AsyncExecutionStrategy} for a non-serial (parallel) execution of every field.
  */
 @PublicApi
 public class AsyncSerialExecutionStrategy extends AbstractAsyncExecutionStrategy {

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -683,4 +683,4 @@ private static Instrumentation checkInstrumentationDefaultState(Instrumentation
         }
         return new ChainedInstrumentation(instrumentationList);
     }
-}
\ No newline at end of file
+}

File: src/main/java/graphql/analysis/MaxQueryComplexityInstrumentation.java
Patch:
@@ -147,7 +147,7 @@ QueryTraverser newQueryTraverser(ExecutionContext executionContext) {
                 .schema(executionContext.getGraphQLSchema())
                 .document(executionContext.getDocument())
                 .operationName(executionContext.getExecutionInput().getOperationName())
-                .variables(executionContext.getVariables())
+                .coercedVariables(executionContext.getCoercedVariables())
                 .build();
     }
 

File: src/main/java/graphql/analysis/MaxQueryDepthInstrumentation.java
Patch:
@@ -84,7 +84,7 @@ QueryTraverser newQueryTraverser(ExecutionContext executionContext) {
                 .schema(executionContext.getGraphQLSchema())
                 .document(executionContext.getDocument())
                 .operationName(executionContext.getExecutionInput().getOperationName())
-                .variables(executionContext.getVariables())
+                .coercedVariables(executionContext.getCoercedVariables())
                 .build();
     }
 

File: src/main/java/graphql/execution/instrumentation/fieldvalidation/FieldValidationSupport.java
Patch:
@@ -33,7 +33,7 @@ static List<GraphQLError> validateFieldsAndArguments(FieldValidation fieldValida
                 .schema(executionContext.getGraphQLSchema())
                 .document(executionContext.getDocument())
                 .operationName(executionContext.getOperationDefinition().getName())
-                .variables(executionContext.getVariables())
+                .coercedVariables(executionContext.getCoercedVariables())
                 .build();
 
         queryTraverser.visitPreOrder(new QueryVisitorStub() {

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -53,7 +53,7 @@
  * and the {@link graphql.execution.ExecutionStrategy execution strategy}
  * <p>
  * Building this object is very cheap and can be done on each execution if necessary.  Building the schema is often not
- * as cheap, especially if its parsed from graphql IDL schema format via {@link graphql.schema.idl.SchemaParser}.
+ * as cheap, especially if it's parsed from graphql IDL schema format via {@link graphql.schema.idl.SchemaParser}.
  * <p>
  * The data for a query is returned via {@link ExecutionResult#getData()} and any errors encountered as placed in
  * {@link ExecutionResult#getErrors()}.
@@ -669,7 +669,7 @@ private static Instrumentation checkInstrumentationDefaultState(Instrumentation
 
         //
         // if we don't have a DataLoaderDispatcherInstrumentation in play, we add one.  We want DataLoader to be 1st class in graphql without requiring
-        // people to remember to wire it in.  Later we may decide to have more default instrumentations but for now its just the one
+        // people to remember to wire it in.  Later we may decide to have more default instrumentations but for now it's just the one
         //
         List<Instrumentation> instrumentationList = new ArrayList<>();
         if (instrumentation instanceof ChainedInstrumentation) {

File: src/main/java/graphql/GraphqlErrorHelper.java
Patch:
@@ -38,7 +38,7 @@ public static Map<String, Object> toSpecification(GraphQLError error) {
             } else {
                 extensions = new LinkedHashMap<>();
             }
-            // put in the classification unless its already there
+            // put in the classification unless it's already there
             if (!extensions.containsKey("classification")) {
                 extensions.put("classification", errorClassification.toSpecification(error));
             }

File: src/main/java/graphql/ParseAndValidate.java
Patch:
@@ -13,7 +13,7 @@
 
 /**
  * This class allows you to parse and validate a graphql query without executing it.  It will tell you
- * if its syntactically valid and also semantically valid according to the graphql specification
+ * if it's syntactically valid and also semantically valid according to the graphql specification
  * and the provided schema.
  */
 @PublicApi

File: src/main/java/graphql/execution/Async.java
Patch:
@@ -95,7 +95,7 @@ private static <T, U> void eachSequentiallyImpl(Iterator<T> iterator, CFFactory<
 
 
     /**
-     * Turns an object T into a CompletableFuture if its not already
+     * Turns an object T into a CompletableFuture if it's not already
      *
      * @param t   - the object to check
      * @param <T> for two

File: src/main/java/graphql/execution/ExecutionContext.java
Patch:
@@ -183,8 +183,8 @@ public void addError(GraphQLError error, ResultPath fieldPath) {
         synchronized (this) {
             //
             // see http://facebook.github.io/graphql/#sec-Errors-and-Non-Nullability about how per
-            // field errors should be handled - ie only once per field if its already there for nullability
-            // but unclear if its not that error path
+            // field errors should be handled - ie only once per field if it's already there for nullability
+            // but unclear if it's not that error path
             //
             if (!errorPaths.add(fieldPath)) {
                 return;

File: src/main/java/graphql/execution/ExecutionStepInfo.java
Patch:
@@ -170,7 +170,7 @@ public Map<String, Object> getArguments() {
      * @param name the name of the argument
      * @param <T>  you decide what type it is
      *
-     * @return the named argument or null if its not present
+     * @return the named argument or null if it's not present
      */
     @SuppressWarnings("unchecked")
     public <T> T getArgument(String name) {

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -97,7 +97,7 @@
  * <p>
  * The execution of a field has two phases, first a raw object must be fetched for a field via a {@link DataFetcher} which
  * is defined on the {@link GraphQLFieldDefinition}.  This object must then be 'completed' into a suitable value, either as a scalar/enum type via
- * coercion or if its a complex object type by recursively calling the execution strategy for the lower level fields.
+ * coercion or if it's a complex object type by recursively calling the execution strategy for the lower level fields.
  * <p>
  * The first phase (data fetching) is handled by the method {@link #fetchField(ExecutionContext, ExecutionStrategyParameters)}
  * <p>
@@ -686,7 +686,7 @@ private Object handleCoercionProblem(ExecutionContext context, ExecutionStrategy
      *
      * @return an Iterable from that object
      *
-     * @throws java.lang.ClassCastException if its not an Iterable
+     * @throws java.lang.ClassCastException if it's not an Iterable
      */
     protected Iterable<Object> toIterable(Object result) {
         return FpKit.toIterable(result);

File: src/main/java/graphql/execution/reactive/CompletionStageMappingPublisher.java
Patch:
@@ -159,7 +159,7 @@ private void offerToInFlightQ(CompletionStage<?> completionStage) {
         }
 
         private boolean removeFromInFlightQAndCheckIfEmpty(CompletionStage<?> completionStage) {
-            // uncontested locks in java are cheap - we dont expect much contention here
+            // uncontested locks in java are cheap - we don't expect much contention here
             synchronized (inFlightDataQ) {
                 inFlightDataQ.remove(completionStage);
                 return inFlightDataQ.isEmpty();

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -631,7 +631,7 @@ public static boolean isIntrospectionTypes(GraphQLNamedType type) {
      * @param schema     the schema to use
      * @param parentType the type of the parent object
      * @param fieldName  the field to look up
-     * @return a field definition otherwise throws an assertion exception if its null
+     * @return a field definition otherwise throws an assertion exception if it's null
      */
     public static GraphQLFieldDefinition getFieldDef(GraphQLSchema schema, GraphQLCompositeType parentType, String fieldName) {
 

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -887,7 +887,7 @@ protected List<Comment> getCommentOnChannel(List<Token> refChannel) {
         for (Token refTok : refChannel) {
             String text = refTok.getText();
             // we strip the leading hash # character but we don't trim because we don't
-            // know the "comment markup".  Maybe its space sensitive, maybe its not.  So
+            // know the "comment markup".  Maybe it's space sensitive, maybe it's not.  So
             // consumers can decide that
             if (text == null) {
                 continue;

File: src/main/java/graphql/parser/Parser.java
Patch:
@@ -253,7 +253,7 @@ public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int
             Token last = allTokens.get(allTokens.size() - 1);
             //
             // do we have more tokens in the stream than we consumed in the parse?
-            // if yes then its invalid.  We make sure its the same channel
+            // if yes then it's invalid.  We make sure it's the same channel
             boolean notEOF = last.getType() != Token.EOF;
             boolean lastGreaterThanDocument = last.getTokenIndex() > stop.getTokenIndex();
             boolean sameChannel = last.getChannel() == stop.getChannel();

File: src/main/java/graphql/schema/DataFetchingFieldSelectionSetImpl.java
Patch:
@@ -388,7 +388,7 @@ public DataFetchingFieldSelectionSet getSelectionSet() {
             return selectionSet;
         }
 
-        // a selected field is the same as another selected field if its the same ExecutableNF
+        // a selected field is the same as another selected field if it's the same ExecutableNF
         @Override
         public boolean equals(Object o) {
             if (this == o) {

File: src/main/java/graphql/schema/GraphQLSchemaElement.java
Patch:
@@ -52,7 +52,7 @@ default GraphQLSchemaElement withNewChildren(SchemaElementChildrenContainer newC
 
     /**
      * Each GraphQLSchemaElement should make a copy of itself when this is called.  The copy should
-     * be include its current contents as they currently exist into a new object.
+     * be included its current contents as they currently exist into a new object.
      *
      * @return a copy of this element
      */

File: src/main/java/graphql/schema/PropertyDataFetcher.java
Patch:
@@ -55,7 +55,7 @@ private <O> PropertyDataFetcher(Function<O, T> function) {
 
     /**
      * Returns a data fetcher that will use the property name to examine the {@link DataFetchingEnvironment#getSource()} object
-     * for a getter method or field with that name, or if its a map, it will look up a value using
+     * for a getter method or field with that name, or if it's a map, it will look up a value using
      * property name as a key.
      * <p>
      * For example :

File: src/main/java/graphql/schema/PropertyFetchingImpl.java
Patch:
@@ -73,7 +73,7 @@ public Object getPropertyValue(String propertyName, Object object, GraphQLType g
 
         //
         // if we have tried all strategies before and they have all failed then we negatively cache
-        // the cacheKey and assume that its never going to turn up.  This shortcuts the property lookup
+        // the cacheKey and assume that it's never going to turn up.  This shortcuts the property lookup
         // in systems where there was a `foo` graphql property but they never provided an POJO
         // version of `foo`.
         //

File: src/main/java/graphql/schema/idl/SchemaGeneratorDirectiveHelper.java
Patch:
@@ -40,7 +40,7 @@ public class SchemaGeneratorDirectiveHelper {
 
     /**
      * This will return true if something in the RuntimeWiring requires a {@link SchemaDirectiveWiring}.  This is to allow
-     * a shortcut to decide that that we dont need ANY SchemaDirectiveWiring post processing
+     * a shortcut to decide that we don't need ANY SchemaDirectiveWiring post processing
      *
      * @param directiveContainer the element that has directives
      * @param typeRegistry       the type registry

File: src/main/java/graphql/schema/idl/SchemaGeneratorHelper.java
Patch:
@@ -244,7 +244,7 @@ String buildDeprecationReason(List<Directive> directives) {
             if (args.isEmpty()) {
                 return NO_LONGER_SUPPORTED; // default value from spec
             } else {
-                // pre flight checks have ensured its valid
+                // pre flight checks have ensured it's valid
                 return args.get("reason");
             }
         }

File: src/main/java/graphql/schema/idl/SchemaParser.java
Patch:
@@ -114,7 +114,7 @@ public TypeDefinitionRegistry parseImpl(Reader schemaInput) {
     private TypeDefinitionRegistry parseImpl(Reader schemaInput, ParserOptions parseOptions) {
         try {
             if (parseOptions == null) {
-                // for SDL we dont stop how many parser tokens there are - its not the attack vector
+                // for SDL we don't stop how many parser tokens there are - it's not the attack vector
                 // to be prevented compared to queries
                 parseOptions = ParserOptions.getDefaultParserOptions().transform(opts -> opts.maxTokens(Integer.MAX_VALUE));
             }

File: src/main/java/graphql/schema/impl/SchemaUtil.java
Patch:
@@ -25,7 +25,7 @@
 public class SchemaUtil {
 
     /**
-     * Called to visit a partially build schema (during {@link GraphQLSchema} build phases) with a set of visitors
+     * Called to visit a partially built schema (during {@link GraphQLSchema} build phases) with a set of visitors
      *
      * Each visitor is expected to hold its own side effects that might be last used to construct a full schema
      *

File: src/main/java/graphql/schema/validation/TypesImplementInterfaces.java
Patch:
@@ -70,7 +70,7 @@ private void check(GraphQLImplementingType implementingType, SchemaValidationErr
 
     }
 
-    // this deliberately has open field visibility here since its validating the schema
+    // this deliberately has open field visibility here since it's validating the schema
     // when completely open
     private void checkObjectImplementsInterface(GraphQLImplementingType implementingType, GraphQLInterfaceType interfaceType, SchemaValidationErrorCollector validationErrorCollector) {
         List<GraphQLFieldDefinition> fieldDefinitions = interfaceType.getFieldDefinitions();

File: src/main/java/graphql/schema/visibility/GraphqlFieldVisibility.java
Patch:
@@ -31,7 +31,7 @@ public interface GraphqlFieldVisibility {
      * @param fieldsContainer the type in play
      * @param fieldName       the name of the desired field
      *
-     * @return a {@link graphql.schema.GraphQLFieldDefinition} or null if its not visible
+     * @return a {@link graphql.schema.GraphQLFieldDefinition} or null if it's not visible
      */
     GraphQLFieldDefinition getFieldDefinition(GraphQLFieldsContainer fieldsContainer, String fieldName);
 
@@ -53,7 +53,7 @@ default List<GraphQLInputObjectField> getFieldDefinitions(GraphQLInputFieldsCont
      * @param fieldsContainer the type in play
      * @param fieldName       the name of the desired field
      *
-     * @return a {@link graphql.schema.GraphQLInputObjectField} or null if its not visible
+     * @return a {@link graphql.schema.GraphQLInputObjectField} or null if it's not visible
      */
     default GraphQLInputObjectField getFieldDefinition(GraphQLInputFieldsContainer fieldsContainer, String fieldName) {
         return fieldsContainer.getFieldDefinition(fieldName);

File: src/main/java/graphql/util/FpKit.java
Patch:
@@ -84,7 +84,7 @@ public static <T> BinaryOperator<T> mergeFirst() {
      *
      * @return an Iterable from that object
      *
-     * @throws java.lang.ClassCastException if its not an Iterable
+     * @throws java.lang.ClassCastException if it's not an Iterable
      */
     @SuppressWarnings("unchecked")
     public static <T> Collection<T> toCollection(Object iterableResult) {
@@ -101,7 +101,7 @@ public static <T> Collection<T> toCollection(Object iterableResult) {
     }
 
     /**
-     * Converts a value into an list if its really a collection or array of things
+     * Converts a value into a list if it's really a collection or array of things
      * else it turns it into a singleton list containing that one value
      *
      * @param possibleIterable the possible
@@ -304,7 +304,7 @@ public static <K, V> Function<K, List<V>> newList() {
     /**
      * This will memoize the Supplier within the current thread's visibility, that is it does not
      * use volatile reads but rather use a sentinel check and re-reads the delegate supplier
-     * value if the read has not stuck to this thread.  This means that its possible that your delegate
+     * value if the read has not stuck to this thread.  This means that it's possible that your delegate
      * supplier MAY be called more than once across threads, but only once on the same thread.
      *
      * @param delegate the supplier to delegate to

File: src/main/java/graphql/validation/rules/KnownDirectives.java
Patch:
@@ -45,7 +45,7 @@ public void checkDirective(Directive directive, List<Node> ancestors) {
         }
     }
 
-    @SuppressWarnings("deprecation") // the suppression stands because its deprecated but still in graphql spec
+    @SuppressWarnings("deprecation") // the suppression stands because it's deprecated but still in graphql spec
     private boolean hasInvalidLocation(GraphQLDirective directive, Node ancestor) {
         EnumSet<DirectiveLocation> validLocations = directive.validLocations();
         if (ancestor instanceof OperationDefinition) {

File: src/test/groovy/readme/ReadmeExamples.java
Patch:
@@ -93,7 +93,7 @@ void listsAndNonNullLists() {
 
         GraphQLNonNull.nonNull(GraphQLString); // a non null String
 
-        // with static imports its even shorter
+        // with static imports it's even shorter
         newArgument()
                 .name("example")
                 .type(nonNull(list(GraphQLString)));

File: src/main/java/graphql/schema/diff/SchemaDiff.java
Patch:
@@ -477,7 +477,7 @@ private void checkEnumType(DiffCtx ctx, EnumTypeDefinition oldDef, EnumTypeDefin
                         .components(enumName)
                         .reasonMsg("The new API has added a new enum value '%s'", enumName)
                         .build());
-            } else if (isDeprecated(newDefinitionMap.get(enumName))) {
+            } else if (isDeprecated(newDefinitionMap.get(enumName)) && !isDeprecated(oldEnum)) {
                 ctx.report(DiffEvent.apiDanger()
                         .category(DiffCategory.DEPRECATION_ADDED)
                         .typeName(oldDef.getName())
@@ -917,4 +917,4 @@ private static String capitalize(String name) {
     private String mkDotName(String... objectNames) {
         return String.join(".", objectNames);
     }
-}
\ No newline at end of file
+}

File: src/main/java/graphql/normalized/ValueToVariableValueCompiler.java
Patch:
@@ -11,10 +11,10 @@
 import graphql.language.ObjectField;
 import graphql.language.ObjectValue;
 import graphql.language.StringValue;
-import graphql.language.TypeName;
 import graphql.language.Value;
 import graphql.language.VariableDefinition;
 import graphql.language.VariableReference;
+import graphql.parser.Parser;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
@@ -35,7 +35,7 @@ static VariableValueWithDefinition normalizedInputValueToVariable(NormalizedInpu
                 variableValue,
                 VariableDefinition.newVariableDefinition()
                         .name(varName)
-                        .type(TypeName.newTypeName(normalizedInputValue.getTypeName()).build())
+                        .type(Parser.parseType(normalizedInputValue.getTypeName()))
                         .build(),
                 VariableReference.newVariableReference().name(varName).build());
     }

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -294,7 +294,7 @@ private NodePrinter<OperationDefinition> operationDefinition() {
 
             // Anonymous queries with no directives or variable definitions can use
             // the query short form.
-            if (isEmpty(name) && isEmpty(directives) && isEmpty(varDefinitions) && op.equals("QUERY")) {
+            if (isEmpty(name) && isEmpty(directives) && isEmpty(varDefinitions) && op.equals("query")) {
                 out.append(selectionSet);
             } else {
                 out.append(spaced(op, smooshed(name, varDefinitions), directives, selectionSet));

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -163,7 +163,7 @@ private NodePrinter<FieldDefinition> fieldDefinition() {
         final String argSep = compactMode ? "," : ", ";
         return (out, node) -> {
             String args;
-            if (hasDescription(node.getInputValueDefinitions()) && !compactMode) {
+            if (hasDescription(Collections.singletonList(node)) && !compactMode) {
                 out.append(description(node));
                 args = join(node.getInputValueDefinitions(), "\n");
                 out.append(node.getName())

File: src/main/java/graphql/execution/instrumentation/ChainedInstrumentation.java
Patch:
@@ -1,6 +1,7 @@
 package graphql.execution.instrumentation;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Maps;
 import graphql.ExecutionInput;
 import graphql.ExecutionResult;
 import graphql.PublicApi;
@@ -210,7 +211,7 @@ private static class ChainedInstrumentationState implements InstrumentationState
 
 
         private ChainedInstrumentationState(List<Instrumentation> instrumentations, InstrumentationCreateStateParameters parameters) {
-            instrumentationStates = new LinkedHashMap<>(instrumentations.size());
+            instrumentationStates = Maps.newLinkedHashMapWithExpectedSize(instrumentations.size());
             instrumentations.forEach(i -> instrumentationStates.put(i, i.createState(parameters)));
         }
 

File: src/main/java/graphql/validation/rules/UniqueArgumentNamesRule.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.validation.rules;
 
+import com.google.common.collect.Sets;
 import graphql.Internal;
 import graphql.language.Argument;
 import graphql.language.Directive;
@@ -10,7 +11,6 @@
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
-import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
@@ -31,7 +31,7 @@ public void checkField(Field field) {
             return;
         }
 
-        Set<String> arguments = new HashSet<>();
+        Set<String> arguments = Sets.newHashSetWithExpectedSize(field.getArguments().size());
 
         for (Argument argument : field.getArguments()) {
             if (arguments.contains(argument.getName())) {
@@ -48,7 +48,7 @@ public void checkDirective(Directive directive, List<Node> ancestors) {
             return;
         }
 
-        Set<String> arguments = new HashSet<>(directive.getArguments().size());
+        Set<String> arguments = Sets.newHashSetWithExpectedSize(directive.getArguments().size());
 
         for (Argument argument : directive.getArguments()) {
             if (arguments.contains(argument.getName())) {

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -294,7 +294,7 @@ private NodePrinter<OperationDefinition> operationDefinition() {
 
             // Anonymous queries with no directives or variable definitions can use
             // the query short form.
-            if (isEmpty(name) && isEmpty(directives) && isEmpty(varDefinitions) && op.equals("QUERY")) {
+            if (isEmpty(name) && isEmpty(directives) && isEmpty(varDefinitions) && op.equals("query")) {
                 out.append(selectionSet);
             } else {
                 out.append(spaced(op, smooshed(name, varDefinitions), directives, selectionSet));

File: src/main/java/graphql/language/Comment.java
Patch:
@@ -4,6 +4,9 @@
 
 import java.io.Serializable;
 
+/**
+ * A single-line comment. These are comments that start with a {@code #} in source documents.
+ */
 @PublicApi
 public class Comment implements Serializable {
     public final String content;

File: src/main/java/graphql/schema/idl/TypeRuntimeWiring.java
Patch:
@@ -152,7 +152,7 @@ public Builder typeResolver(TypeResolver typeResolver) {
         }
 
         public Builder enumValues(EnumValuesProvider enumValuesProvider) {
-            assertNotNull(enumValuesProvider, () -> "you must provide a type resolver");
+            assertNotNull(enumValuesProvider, () -> "you must provide an enum values provider");
             this.enumValuesProvider = enumValuesProvider;
             return this;
         }

File: src/test/java/benchmark/ValidatorBenchmark.java
Patch:
@@ -35,8 +35,8 @@
 @State(Scope.Benchmark)
 @BenchmarkMode(Mode.AverageTime)
 @Threads(1)
-@Warmup(iterations = 4, time = 5)
-@Measurement(iterations = 8, time = 10)
+@Warmup(iterations = 5, time = 5)
+@Measurement(iterations = 10, time = 10)
 @Fork(1)
 @OutputTimeUnit(TimeUnit.MILLISECONDS)
 public class ValidatorBenchmark {

File: src/main/java/graphql/introspection/IntrospectionResultToSchema.java
Patch:
@@ -230,7 +230,7 @@ EnumTypeDefinition createEnum(Map<String, Object> input) {
         for (Map<String, Object> enumValue : enumValues) {
 
             EnumValueDefinition.Builder enumValueDefinition = EnumValueDefinition.newEnumValueDefinition().name((String) enumValue.get("name"));
-            enumTypeDefinition.description(toDescription(input));
+            enumValueDefinition.description(toDescription(enumValue));
 
             createDeprecatedDirective(enumValue, enumValueDefinition);
 

File: src/main/java/graphql/schema/idl/errors/NonSDLDefinitionError.java
Patch:
@@ -9,7 +9,7 @@
 public class NonSDLDefinitionError extends BaseError {
 
     public NonSDLDefinitionError(Definition definition) {
-        super(definition, format("The schema definition text contains a non schema definition language (SDL) element '%s'",
-                definition.getClass().getSimpleName(), lineCol(definition), lineCol(definition)));
+        super(definition, format("%s The schema definition text contains a non schema definition language (SDL) element '%s'",
+                lineCol(definition), definition.getClass().getSimpleName()));
     }
 }

File: src/main/java/graphql/util/Anonymizer.java
Patch:
@@ -702,7 +702,7 @@ private static List<GraphQLArgument> getMatchingArgumentDefinitions(
             Set<GraphQLFieldDefinition> fieldDefinitions) {
         List<GraphQLArgument> result = new ArrayList<>();
         for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {
-            Optional.ofNullable(fieldDefinition.getArgument(name)).map(result::add);
+            Optional.ofNullable(fieldDefinition.getArgument(name)).ifPresent(result::add);
         }
         return result;
     }
@@ -738,7 +738,7 @@ public void visitField(QueryVisitorFieldEnvironment env) {
 
                     for (Argument argument : directive.getArguments()) {
                         GraphQLArgument argumentDefinition = directiveDefinition.getArgument(argument.getName());
-                        String newArgumentName = assertNotNull(newNames.get(argumentDefinition), () -> format("%s no new name found for directive argument %s %s", directiveName, argument.getName()));
+                        String newArgumentName = assertNotNull(newNames.get(argumentDefinition), () -> format("No new name found for directive %s argument %s", directiveName, argument.getName()));
                         astNodeToNewName.put(argument, newArgumentName);
                         visitDirectiveArgumentValues(directive, argument.getValue());
                     }

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -418,6 +418,8 @@ private Map<String, Object> externalValueToInternalValueForVariables(GraphQLSche
                         .cause(e.getCause())
                         .sourceLocation(variableDefinition.getSourceLocation())
                         .build();
+            } catch (NonNullableValueCoercedAsNullException e) {
+                throw new NonNullableValueCoercedAsNullException(variableDefinition, e.getMessage());
             }
         }
 
@@ -495,7 +497,7 @@ private Object externalValueToInternalValue(GraphqlFieldVisibility fieldVisibili
             Object returnValue =
                     externalValueToInternalValue(fieldVisibility, unwrapOne(graphQLType), value);
             if (returnValue == null) {
-                throw new NonNullableValueCoercedAsNullException("", emptyList(), graphQLType);
+                throw new NonNullableValueCoercedAsNullException(graphQLType);
             }
             return returnValue;
         }

File: src/main/java/graphql/normalized/ExecutableNormalizedOperationToAstCompiler.java
Patch:
@@ -98,7 +98,7 @@ private static List<Selection<?>> subselectionsForNormalizedField(GraphQLSchema
         Map<String, List<Field>> fieldsByTypeCondition = new LinkedHashMap<>();
 
         for (ExecutableNormalizedField nf : executableNormalizedFields) {
-            if (nf.isConditional(schema, parentOutputType)) {
+            if (nf.isConditional(schema)) {
                 selectionForNormalizedField(schema, nf, variableAccumulator)
                         .forEach((objectTypeName, field) ->
                                 fieldsByTypeCondition

File: src/main/java/graphql/schema/DataFetchingFieldSelectionSetImpl.java
Patch:
@@ -244,8 +244,7 @@ private void traverseSubSelectedFields(ExecutableNormalizedField currentNormalis
             normalisedSelectionSetFields.computeIfAbsent(globQualifiedName, newList()).add(selectedField);
             normalisedSelectionSetFields.computeIfAbsent(globSimpleName, newList()).add(selectedField);
 
-            GraphQLType unwrappedType = GraphQLTypeUtil.unwrapAll(normalizedSubSelectedField.getType(schema));
-            if (!GraphQLTypeUtil.isLeaf(unwrappedType)) {
+            if (normalizedSubSelectedField.hasChildren()) {
                 traverseSubSelectedFields(normalizedSubSelectedField, immediateFieldsBuilder, globQualifiedName, globSimpleName, false);
             }
         }

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -30,6 +30,7 @@
 import static graphql.execution.ExecutionContextBuilder.newExecutionContextBuilder;
 import static graphql.execution.ExecutionStepInfo.newExecutionStepInfo;
 import static graphql.execution.ExecutionStrategyParameters.newParameters;
+import static graphql.execution.nextgen.Common.getOperationRootType;
 import static graphql.language.OperationDefinition.Operation.MUTATION;
 import static graphql.language.OperationDefinition.Operation.QUERY;
 import static graphql.language.OperationDefinition.Operation.SUBSCRIPTION;

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -30,6 +30,7 @@
 import static graphql.execution.ExecutionContextBuilder.newExecutionContextBuilder;
 import static graphql.execution.ExecutionStepInfo.newExecutionStepInfo;
 import static graphql.execution.ExecutionStrategyParameters.newParameters;
+import static graphql.execution.nextgen.Common.getOperationRootType;
 import static graphql.language.OperationDefinition.Operation.MUTATION;
 import static graphql.language.OperationDefinition.Operation.QUERY;
 import static graphql.language.OperationDefinition.Operation.SUBSCRIPTION;

File: src/main/java/graphql/schema/usage/SchemaUsage.java
Patch:
@@ -174,9 +174,9 @@ private boolean isReferencedImpl(GraphQLSchema schema, String elementName, Set<S
             return true;
         }
 
-        List<GraphQLDirective> directives = schema.getDirectives(elementName);
-        if (!directives.isEmpty()) {
-            String directiveName = directives.get(0).getName();
+        GraphQLDirective directive = schema.getDirective(elementName);
+        if (directive != null) {
+            String directiveName = directive.getName();
             if (DirectiveInfo.isGraphqlSpecifiedDirective(directiveName)) {
                 return true;
             }

File: src/main/java/graphql/validation/TraversalContext.java
Patch:
@@ -105,7 +105,7 @@ private void enterImpl(Field field) {
     }
 
     private void enterImpl(Directive directive) {
-        this.directive = DirectivesUtil.getFirstDirective(directive.getName(), schema.getAllDirectivesByName());
+        this.directive = schema.getDirective(directive.getName());
     }
 
     private void enterImpl(OperationDefinition operationDefinition) {

File: src/main/java/graphql/validation/rules/KnownDirectives.java
Patch:
@@ -31,7 +31,7 @@ public KnownDirectives(ValidationContext validationContext, ValidationErrorColle
 
     @Override
     public void checkDirective(Directive directive, List<Node> ancestors) {
-        GraphQLDirective graphQLDirective = getValidationContext().getSchema().getFirstDirective(directive.getName());
+        GraphQLDirective graphQLDirective = getValidationContext().getSchema().getDirective(directive.getName());
         if (graphQLDirective == null) {
             String message = String.format("Unknown directive %s", directive.getName());
             addError(ValidationErrorType.UnknownDirective, directive.getSourceLocation(), message);

File: src/main/java/graphql/validation/rules/UniqueDirectiveNamesPerLocation.java
Patch:
@@ -67,8 +67,8 @@ private void checkDirectivesUniqueness(Node<?> directivesContainer, List<Directi
         Set<String> directiveNames = new LinkedHashSet<>();
         for (Directive directive : directives) {
             String name = directive.getName();
-            Map<String, List<GraphQLDirective>> directivesByName = getValidationContext().getSchema().getAllDirectivesByName();
-            boolean nonRepeatable = DirectivesUtil.isAllNonRepeatable(directivesByName.getOrDefault(name, emptyList()));
+            GraphQLDirective graphQLDirective = getValidationContext().getSchema().getDirective(name);
+            boolean nonRepeatable = graphQLDirective != null && graphQLDirective.isNonRepeatable();
             if (directiveNames.contains(name) && nonRepeatable) {
                 addError(ValidationErrorType.DuplicateDirectiveName,
                         directive.getSourceLocation(),

File: src/test/groovy/readme/ReadmeExamples.java
Patch:
@@ -83,6 +83,9 @@ void creatingASchema() {
                 .query(queryType) // must be provided
                 .mutation(mutationType) // is optional
                 .build();
+
+        GraphQLUnionType.Builder description = newUnionType().description("");
+        description.definition(null).build();
     }
 
     void listsAndNonNullLists() {

File: src/main/java/graphql/schema/validation/SchemaValidationErrorCollector.java
Patch:
@@ -20,7 +20,7 @@ public Set<SchemaValidationError> getErrors() {
 
     public boolean containsValidationError(SchemaValidationErrorType validationErrorType) {
         for (SchemaValidationError validationError : errors) {
-            if (validationError.getErrorType() == validationErrorType) return true;
+            if (validationError.getClassification() == validationErrorType) return true;
         }
         return false;
     }

File: src/main/java/graphql/schema/validation/SchemaValidationErrorType.java
Patch:
@@ -3,7 +3,7 @@
 import graphql.Internal;
 
 @Internal
-public enum SchemaValidationErrorType {
+public enum SchemaValidationErrorType implements SchemaValidationErrorClassification{
 
     UnbrokenInputCycle,
     ObjectDoesNotImplementItsInterfaces,

File: src/main/java/graphql/GraphqlErrorBuilder.java
Patch:
@@ -20,7 +20,7 @@
  */
 @SuppressWarnings("unchecked")
 @PublicApi
-public class GraphqlErrorBuilder<B extends GraphqlErrorBuilder<?>> {
+public class GraphqlErrorBuilder<B extends GraphqlErrorBuilder<B>> {
 
     private String message;
     private List<Object> path;

File: src/main/java/graphql/schema/validation/SchemaValidationErrorType.java
Patch:
@@ -17,5 +17,7 @@ public enum SchemaValidationErrorType {
     RepetitiveElementError,
     InvalidDefaultValue,
     InvalidAppliedDirectiveArgument,
-    InvalidAppliedDirective
+    InvalidAppliedDirective,
+    OutputTypeUsedInInputTypeContext,
+    InputTypeUsedInOutputTypeContext,
 }

File: src/main/java/graphql/schema/validation/SchemaValidator.java
Patch:
@@ -24,6 +24,7 @@ public SchemaValidator() {
         rules.add(new DefaultValuesAreValid());
         rules.add(new AppliedDirectivesAreValid());
         rules.add(new AppliedDirectiveArgumentsAreValid());
+        rules.add(new InputAndOutputTypesUsedAppropriately());
     }
 
     public List<GraphQLTypeVisitor> getRules() {

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -692,7 +692,7 @@ protected Iterable<Object> toIterable(Object result) {
     }
 
     protected GraphQLObjectType resolveType(ExecutionContext executionContext, ExecutionStrategyParameters parameters, GraphQLType fieldType) {
-        return resolvedType.resolveType(executionContext, parameters.getField(), parameters.getSource(), parameters.getExecutionStepInfo(), fieldType);
+        return resolvedType.resolveType(executionContext, parameters.getField(), parameters.getSource(), parameters.getExecutionStepInfo(), fieldType, parameters.getLocalContext());
     }
 
 

File: src/main/java/graphql/execution/nextgen/ExecutionStrategyUtil.java
Patch:
@@ -77,7 +77,7 @@ public FieldSubSelection createFieldSubSelection(ExecutionContext executionConte
         Object localContext = resolvedValue.getLocalContext();
 
         GraphQLOutputType sourceType = executionInfo.getUnwrappedNonNullType();
-        GraphQLObjectType resolvedObjectType = resolveType.resolveType(executionContext, field, source, executionInfo, sourceType);
+        GraphQLObjectType resolvedObjectType = resolveType.resolveType(executionContext, field, source, executionInfo, sourceType, localContext);
         FieldCollectorParameters collectorParameters = newParameters()
                 .schema(executionContext.getGraphQLSchema())
                 .objectType(resolvedObjectType)

File: src/main/java/graphql/execution/nextgen/FetchedValueAnalyzer.java
Patch:
@@ -73,7 +73,7 @@ private FetchedValueAnalysis analyzeFetchedValueImpl(ExecutionContext executionC
                     .build();
         }
         try {
-            GraphQLObjectType resolvedObjectType = resolveType.resolveType(executionContext, field, toAnalyze, executionInfo, fieldType);
+            GraphQLObjectType resolvedObjectType = resolveType.resolveType(executionContext, field, toAnalyze, executionInfo, fieldType, fetchedValue.getLocalContext());
             return newFetchedValueAnalysis(OBJECT)
                     .fetchedValue(fetchedValue)
                     .executionStepInfo(executionInfo)

File: src/main/java/graphql/schema/idl/ImplementingTypesChecker.java
Patch:
@@ -66,8 +66,7 @@ void checkImplementingTypes(List<GraphQLError> errors, TypeDefinitionRegistry ty
         List<InterfaceTypeDefinition> interfaces = typeRegistry.getTypes(InterfaceTypeDefinition.class);
         List<ObjectTypeDefinition> objects = typeRegistry.getTypes(ObjectTypeDefinition.class);
 
-        Stream.of(interfaces.stream(), objects.stream())
-                .flatMap(Function.identity())
+        Stream.<ImplementingTypeDefinition<?>>concat(interfaces.stream(), objects.stream())
                 .forEach(type -> checkImplementingType(errors, typeRegistry, type));
     }
 

File: src/main/java/graphql/schema/idl/UnionTypesChecker.java
Patch:
@@ -16,7 +16,6 @@
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
-import java.util.function.Function;
 import java.util.stream.Stream;
 
 import static java.lang.String.format;
@@ -46,8 +45,7 @@ void checkUnionType(List<GraphQLError> errors, TypeDefinitionRegistry typeRegist
         List<UnionTypeDefinition> unionTypes = typeRegistry.getTypes(UnionTypeDefinition.class);
         List<UnionTypeExtensionDefinition> unionTypeExtensions = typeRegistry.getTypes(UnionTypeExtensionDefinition.class);
 
-        Stream.of(unionTypes.stream(), unionTypeExtensions.stream())
-                .flatMap(Function.identity())
+        Stream.concat(unionTypes.stream(), unionTypeExtensions.stream())
                 .forEach(type -> checkUnionType(typeRegistry, type, errors));
     }
 

File: src/main/java/graphql/schema/idl/SchemaPrinter.java
Patch:
@@ -636,7 +636,7 @@ private void printAsAst(PrintWriter out, TypeDefinition<?> definition, List<? ex
                 out.printf("\n%s\n", AstPrinter.printAst(extension));
             }
         }
-        out.println();
+        out.print('\n');
     }
 
     private static String printAst(InputValueWithState value, GraphQLInputType type) {
@@ -901,7 +901,7 @@ private <T> SchemaElementPrinter<T> printer(Class<?> clazz) {
             if (superClazz != Object.class) {
                 schemaElementPrinter = printer(superClazz);
             } else {
-                schemaElementPrinter = (out, type, visibility) -> out.println("Type not implemented : " + type);
+                schemaElementPrinter = (out, type, visibility) -> out.print("Type not implemented : " + type + "\n");
             }
             printers.put(clazz, schemaElementPrinter);
         }

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -431,7 +431,7 @@ public enum DirectiveLocation {
             .value("FRAGMENT_DEFINITION", DirectiveLocation.FRAGMENT_DEFINITION, "Indicates the directive is valid on fragment definitions.")
             .value("FRAGMENT_SPREAD", DirectiveLocation.FRAGMENT_SPREAD, "Indicates the directive is valid on fragment spreads.")
             .value("INLINE_FRAGMENT", DirectiveLocation.INLINE_FRAGMENT, "Indicates the directive is valid on inline fragments.")
-            .value("VARIABLE_DEFINITION", DirectiveLocation.INPUT_FIELD_DEFINITION, "Indicates the directive is valid on variable definitions.")
+            .value("VARIABLE_DEFINITION", DirectiveLocation.VARIABLE_DEFINITION, "Indicates the directive is valid on variable definitions.")
             //
             // from schema SDL PR  https://github.com/facebook/graphql/pull/90
             //

File: src/main/java/graphql/Directives.java
Patch:
@@ -99,7 +99,7 @@ public class Directives {
             .argument(newArgument()
                     .name("reason")
                     .type(GraphQLString)
-                    .defaultValue(NO_LONGER_SUPPORTED)
+                    .defaultValueProgrammatic(NO_LONGER_SUPPORTED)
                     .description("The reason for the deprecation"))
             .validLocations(FIELD_DEFINITION, ENUM_VALUE, ARGUMENT_DEFINITION, INPUT_FIELD_DEFINITION)
             .definition(DEPRECATED_DIRECTIVE_DEFINITION)

File: src/main/java/graphql/Directives.java
Patch:
@@ -99,7 +99,7 @@ public class Directives {
             .argument(newArgument()
                     .name("reason")
                     .type(GraphQLString)
-                    .defaultValue(NO_LONGER_SUPPORTED)
+                    .defaultValueProgrammatic(NO_LONGER_SUPPORTED)
                     .description("The reason for the deprecation"))
             .validLocations(FIELD_DEFINITION, ENUM_VALUE, ARGUMENT_DEFINITION, INPUT_FIELD_DEFINITION)
             .definition(DEPRECATED_DIRECTIVE_DEFINITION)

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -482,7 +482,7 @@ private String value(Value value) {
         } else if (value instanceof FloatValue) {
             return valueOf(((FloatValue) value).getValue());
         } else if (value instanceof StringValue) {
-            return wrap("\"", escapeJsonString(((StringValue) value).getValue()), "\"");
+            return "\"" + escapeJsonString(((StringValue) value).getValue()) + "\"";
         } else if (value instanceof EnumValue) {
             return valueOf(((EnumValue) value).getName());
         } else if (value instanceof BooleanValue) {

File: src/main/java/graphql/schema/diffing/SchemaGraphFactory.java
Patch:
@@ -343,7 +343,6 @@ private void newInputObject(GraphQLInputObjectType inputObject, SchemaGraph sche
             Vertex newInputField = newInputField(inputObjectField, schemaGraph, isIntrospectionNode);
             Edge newEdge = new Edge(inputObjectVertex, newInputField);
             schemaGraph.addEdge(newEdge);
-            cratedAppliedDirectives(inputObjectVertex, inputObjectField.getDirectives(), schemaGraph);
         }
         schemaGraph.addVertex(inputObjectVertex);
         schemaGraph.addType(inputObject.getName(), inputObjectVertex);

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -692,7 +692,7 @@ protected Iterable<Object> toIterable(Object result) {
     }
 
     protected GraphQLObjectType resolveType(ExecutionContext executionContext, ExecutionStrategyParameters parameters, GraphQLType fieldType) {
-        return resolvedType.resolveType(executionContext, parameters.getField(), parameters.getSource(), parameters.getExecutionStepInfo().getArguments(), fieldType);
+        return resolvedType.resolveType(executionContext, parameters.getField(), parameters.getSource(), parameters.getExecutionStepInfo(), fieldType);
     }
 
 

File: src/main/java/graphql/execution/nextgen/ExecutionStrategyUtil.java
Patch:
@@ -73,7 +73,7 @@ public FieldSubSelection createFieldSubSelection(ExecutionContext executionConte
         Object localContext = resolvedValue.getLocalContext();
 
         GraphQLOutputType sourceType = executionInfo.getUnwrappedNonNullType();
-        GraphQLObjectType resolvedObjectType = resolveType.resolveType(executionContext, field, source, executionInfo.getArguments(), sourceType);
+        GraphQLObjectType resolvedObjectType = resolveType.resolveType(executionContext, field, source, executionInfo, sourceType);
         FieldCollectorParameters collectorParameters = newParameters()
                 .schema(executionContext.getGraphQLSchema())
                 .objectType(resolvedObjectType)

File: src/main/java/graphql/execution/nextgen/FetchedValueAnalyzer.java
Patch:
@@ -69,7 +69,7 @@ private FetchedValueAnalysis analyzeFetchedValueImpl(ExecutionContext executionC
                     .build();
         }
         try {
-            GraphQLObjectType resolvedObjectType = resolveType.resolveType(executionContext, field, toAnalyze, executionInfo.getArguments(), fieldType);
+            GraphQLObjectType resolvedObjectType = resolveType.resolveType(executionContext, field, toAnalyze, executionInfo, fieldType);
             return newFetchedValueAnalysis(OBJECT)
                     .fetchedValue(fetchedValue)
                     .executionStepInfo(executionInfo)

File: src/main/java/graphql/schema/diffing/GraphPrinter.java
Patch:
@@ -14,8 +14,6 @@ public static String print(SchemaGraph schemaGraph) {
             dotfile.addNode("V" + Integer.toHexString(vertex.hashCode()), name, "blue");
         }
         for (Edge edge : schemaGraph.getEdges()) {
-            String nameOne = edge.getOne().get("name");
-            String nameTwo = edge.getTwo().get("name");
             dotfile.addEdge("V" + Integer.toHexString(edge.getOne().hashCode()), "V" + Integer.toHexString(edge.getTwo().hashCode()), edge.getLabel());
         }
         return dotfile.print();

File: src/main/java/graphql/schema/diffing/SchemaGraphFactory.java
Patch:
@@ -361,6 +361,7 @@ private void newDirective(GraphQLDirective directive, SchemaGraph schemaGraph) {
 
     private Vertex newInputField(GraphQLInputObjectField inputField, SchemaGraph schemaGraph, boolean isIntrospectionNode) {
         Vertex vertex = new Vertex(INPUT_FIELD, String.valueOf(counter++));
+        schemaGraph.addVertex(vertex);
         vertex.setBuiltInType(isIntrospectionNode);
         vertex.add("name", inputField.getName());
         vertex.add("description", desc(inputField.getDescription()));

File: src/main/java/graphql/execution/DataFetcherExceptionHandler.java
Patch:
@@ -27,7 +27,9 @@ public interface DataFetcherExceptionHandler {
      * version
      */
     @Deprecated
-    DataFetcherExceptionHandlerResult onException(DataFetcherExceptionHandlerParameters handlerParameters);
+    default DataFetcherExceptionHandlerResult onException(DataFetcherExceptionHandlerParameters handlerParameters) {
+        return SimpleDataFetcherExceptionHandler.defaultImpl.onException(handlerParameters);
+    }
 
     /**
      * When an exception occurs during a call to a {@link DataFetcher} then this handler

File: src/test/java/benchmark/IntMapBenchmark.java
Patch:
@@ -1,6 +1,6 @@
 package benchmark;
 
-import graphql.execution.instrumentation.dataloader.IntMap;
+import graphql.execution.instrumentation.dataloader.LevelMap;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Measurement;
@@ -33,7 +33,7 @@ public void benchmarkLinkedHashMap(Blackhole blackhole) {
 
 	@Benchmark
 	public void benchmarkIntMap(Blackhole blackhole) {
-		IntMap result = new IntMap(16);
+		LevelMap result = new LevelMap(16);
 		for (int i = 0; i < 30; i++) {
 			int level = i % 10;
 			int count = i * 2;

File: src/main/java/graphql/schema/GraphQLArgument.java
Patch:
@@ -300,7 +300,7 @@ public Builder(GraphQLArgument existing) {
             this.description = existing.getDescription();
             this.definition = existing.getDefinition();
             this.deprecationReason = existing.deprecationReason;
-            DirectivesUtil.enforceAddAll(this.directives, existing.getDirectives());
+            DirectivesUtil.addAll(this.directives, existing.getDirectives());
         }
 
         @Override
@@ -439,14 +439,14 @@ public Builder withDirectives(GraphQLDirective... directives) {
 
         public Builder withDirective(GraphQLDirective directive) {
             assertNotNull(directive, () -> "directive can't be null");
-            DirectivesUtil.enforceAdd(this.directives, directive);
+            DirectivesUtil.add(this.directives, directive);
             return this;
         }
 
         public Builder replaceDirectives(List<GraphQLDirective> directives) {
             assertNotNull(directives, () -> "directive can't be null");
             this.directives.clear();
-            DirectivesUtil.enforceAddAll(this.directives, directives);
+            DirectivesUtil.addAll(this.directives, directives);
             return this;
         }
 

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -288,7 +288,7 @@ public Builder(GraphQLEnumType existing) {
             this.definition = existing.getDefinition();
             this.extensionDefinitions = existing.getExtensionDefinitions();
             this.values.putAll(getByName(existing.getValues(), GraphQLEnumValueDefinition::getName));
-            DirectivesUtil.enforceAddAll(this.directives, existing.getDirectives());
+            DirectivesUtil.addAll(this.directives, existing.getDirectives());
         }
 
         @Override
@@ -385,14 +385,14 @@ public Builder withDirectives(GraphQLDirective... directives) {
 
         public Builder withDirective(GraphQLDirective directive) {
             assertNotNull(directive, () -> "directive can't be null");
-            DirectivesUtil.enforceAdd(this.directives, directive);
+            DirectivesUtil.add(this.directives, directive);
             return this;
         }
 
         public Builder replaceDirectives(List<GraphQLDirective> directives) {
             assertNotNull(directives, () -> "directive can't be null");
             this.directives.clear();
-            DirectivesUtil.enforceAddAll(this.directives, directives);
+            DirectivesUtil.addAll(this.directives, directives);
             return this;
         }
 

File: src/main/java/graphql/schema/GraphQLEnumValueDefinition.java
Patch:
@@ -184,7 +184,7 @@ public Builder(GraphQLEnumValueDefinition existing) {
             this.description = existing.getDescription();
             this.value = existing.getValue();
             this.deprecationReason = existing.getDeprecationReason();
-            DirectivesUtil.enforceAddAll(this.directives, existing.getDirectives());
+            DirectivesUtil.addAll(this.directives, existing.getDirectives());
         }
 
         @Override
@@ -231,14 +231,14 @@ public Builder withDirectives(GraphQLDirective... directives) {
 
         public Builder withDirective(GraphQLDirective directive) {
             assertNotNull(directive, () -> "directive can't be null");
-            DirectivesUtil.enforceAdd(this.directives, directive);
+            DirectivesUtil.add(this.directives, directive);
             return this;
         }
 
         public Builder replaceDirectives(List<GraphQLDirective> directives) {
             assertNotNull(directives, () -> "directive can't be null");
             this.directives.clear();
-            DirectivesUtil.enforceAddAll(this.directives, directives);
+            DirectivesUtil.addAll(this.directives, directives);
             return this;
         }
 

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -248,7 +248,7 @@ public Builder(GraphQLFieldDefinition existing) {
             this.deprecationReason = existing.getDeprecationReason();
             this.definition = existing.getDefinition();
             this.arguments.putAll(getByName(existing.getArguments(), GraphQLArgument::getName));
-            DirectivesUtil.enforceAddAll(this.directives, existing.getDirectives());
+            DirectivesUtil.addAll(this.directives, existing.getDirectives());
         }
 
 
@@ -442,14 +442,14 @@ public Builder withDirectives(GraphQLDirective... directives) {
 
         public Builder withDirective(GraphQLDirective directive) {
             assertNotNull(directive, () -> "directive can't be null");
-            DirectivesUtil.enforceAdd(this.directives, directive);
+            DirectivesUtil.add(this.directives, directive);
             return this;
         }
 
         public Builder replaceDirectives(List<GraphQLDirective> directives) {
             assertNotNull(directives, () -> "directive can't be null");
             this.directives.clear();
-            DirectivesUtil.enforceAddAll(this.directives, directives);
+            DirectivesUtil.addAll(this.directives, directives);
             return this;
         }
 

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -263,7 +263,7 @@ public Builder(GraphQLInputObjectField existing) {
             this.type = existing.originalType;
             this.definition = existing.getDefinition();
             this.deprecationReason = existing.deprecationReason;
-            DirectivesUtil.enforceAddAll(this.directives, existing.getDirectives());
+            DirectivesUtil.addAll(this.directives, existing.getDirectives());
         }
 
         @Override
@@ -344,14 +344,14 @@ public Builder withDirectives(GraphQLDirective... directives) {
 
         public Builder withDirective(GraphQLDirective directive) {
             assertNotNull(directive, () -> "directive can't be null");
-            DirectivesUtil.enforceAdd(this.directives, directive);
+            DirectivesUtil.add(this.directives, directive);
             return this;
         }
 
         public Builder replaceDirectives(List<GraphQLDirective> directives) {
             assertNotNull(directives, () -> "directive can't be null");
             this.directives.clear();
-            DirectivesUtil.enforceAddAll(this.directives, directives);
+            DirectivesUtil.addAll(this.directives, directives);
             return this;
         }
 

File: src/main/java/graphql/schema/GraphQLInputObjectType.java
Patch:
@@ -217,7 +217,7 @@ public Builder(GraphQLInputObjectType existing) {
             this.definition = existing.getDefinition();
             this.extensionDefinitions = existing.getExtensionDefinitions();
             this.fields.putAll(getByName(existing.getFields(), GraphQLInputObjectField::getName));
-            DirectivesUtil.enforceAddAll(this.directives, existing.getDirectives());
+            DirectivesUtil.addAll(this.directives, existing.getDirectives());
         }
 
         @Override
@@ -321,14 +321,14 @@ public Builder withDirectives(GraphQLDirective... directives) {
 
         public Builder withDirective(GraphQLDirective directive) {
             assertNotNull(directive, () -> "directive can't be null");
-            DirectivesUtil.enforceAdd(this.directives, directive);
+            DirectivesUtil.add(this.directives, directive);
             return this;
         }
 
         public Builder replaceDirectives(List<GraphQLDirective> directives) {
             assertNotNull(directives, () -> "directive can't be null");
             this.directives.clear();
-            DirectivesUtil.enforceAddAll(this.directives, directives);
+            DirectivesUtil.addAll(this.directives, directives);
             return this;
         }
 

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -262,7 +262,7 @@ public Builder(GraphQLInterfaceType existing) {
             this.extensionDefinitions = existing.getExtensionDefinitions();
             this.fields.putAll(getByName(existing.getFieldDefinitions(), GraphQLFieldDefinition::getName));
             this.interfaces.putAll(getByName(existing.originalInterfaces, GraphQLNamedType::getName));
-            DirectivesUtil.enforceAddAll(this.directives,existing.getDirectives());
+            DirectivesUtil.addAll(this.directives,existing.getDirectives());
         }
 
         @Override
@@ -376,14 +376,14 @@ public Builder withDirectives(GraphQLDirective... directives) {
 
         public Builder withDirective(GraphQLDirective directive) {
             assertNotNull(directive, () -> "directive can't be null");
-            DirectivesUtil.enforceAdd(this.directives, directive);
+            DirectivesUtil.add(this.directives, directive);
             return this;
         }
 
         public Builder replaceDirectives(List<GraphQLDirective> directives) {
             assertNotNull(directives, () -> "directive can't be null");
             this.directives.clear();
-            DirectivesUtil.enforceAddAll(this.directives, directives);
+            DirectivesUtil.addAll(this.directives, directives);
             return this;
         }
 

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -248,7 +248,7 @@ public Builder(GraphQLObjectType existing) {
             extensionDefinitions = existing.getExtensionDefinitions();
             fields.putAll(getByName(existing.getFieldDefinitions(), GraphQLFieldDefinition::getName));
             interfaces.putAll(getByName(existing.originalInterfaces, GraphQLNamedType::getName));
-            DirectivesUtil.enforceAddAll(this.directives, existing.getDirectives());
+            DirectivesUtil.addAll(this.directives, existing.getDirectives());
         }
 
         @Override
@@ -397,7 +397,7 @@ public Builder clearInterfaces() {
         public Builder replaceDirectives(List<GraphQLDirective> directives) {
             assertNotNull(directives, () -> "directive can't be null");
             this.directives.clear();
-            DirectivesUtil.enforceAddAll(this.directives, directives);
+            DirectivesUtil.addAll(this.directives, directives);
             return this;
         }
 
@@ -412,7 +412,7 @@ public Builder withDirectives(GraphQLDirective... directives) {
 
         public Builder withDirective(GraphQLDirective directive) {
             assertNotNull(directive, () -> "directive can't be null");
-            DirectivesUtil.enforceAdd(this.directives, directive);
+            DirectivesUtil.add(this.directives, directive);
             return this;
         }
 

File: src/main/java/graphql/schema/GraphQLScalarType.java
Patch:
@@ -212,7 +212,7 @@ public Builder(GraphQLScalarType existing) {
             definition = existing.getDefinition();
             extensionDefinitions = existing.getExtensionDefinitions();
             specifiedByUrl = existing.getSpecifiedByUrl();
-            DirectivesUtil.enforceAddAll(this.directives, existing.getDirectives());
+            DirectivesUtil.addAll(this.directives, existing.getDirectives());
         }
 
         @Override
@@ -264,14 +264,14 @@ public Builder withDirectives(GraphQLDirective... directives) {
 
         public Builder withDirective(GraphQLDirective directive) {
             assertNotNull(directive, () -> "directive can't be null");
-            DirectivesUtil.enforceAdd(this.directives, directive);
+            DirectivesUtil.add(this.directives, directive);
             return this;
         }
 
         public Builder replaceDirectives(List<GraphQLDirective> directives) {
             assertNotNull(directives, () -> "directive can't be null");
             this.directives.clear();
-            DirectivesUtil.enforceAddAll(this.directives, directives);
+            DirectivesUtil.addAll(this.directives, directives);
             return this;
         }
 

File: src/main/java/graphql/schema/GraphQLUnionType.java
Patch:
@@ -227,7 +227,7 @@ public Builder(GraphQLUnionType existing) {
             this.definition = existing.getDefinition();
             this.extensionDefinitions = existing.getExtensionDefinitions();
             this.types.putAll(getByName(existing.originalTypes, GraphQLNamedType::getName));
-            DirectivesUtil.enforceAddAll(this.directives,existing.getDirectives());
+            DirectivesUtil.addAll(this.directives,existing.getDirectives());
         }
 
         @Override
@@ -331,13 +331,13 @@ public Builder withDirectives(GraphQLDirective... directives) {
         public Builder replaceDirectives(List<GraphQLDirective> directives) {
             assertNotNull(directives, () -> "directive can't be null");
             this.directives.clear();
-            DirectivesUtil.enforceAddAll(this.directives, directives);
+            DirectivesUtil.addAll(this.directives, directives);
             return this;
         }
 
         public Builder withDirective(GraphQLDirective directive) {
             assertNotNull(directive, () -> "directive can't be null");
-            DirectivesUtil.enforceAdd(this.directives, directive);
+            DirectivesUtil.add(this.directives, directive);
             return this;
         }
 

File: src/main/java/graphql/schema/validation/SchemaValidationErrorType.java
Patch:
@@ -16,6 +16,6 @@ public enum SchemaValidationErrorType {
     NonNullWrapNonNullError,
     RepetitiveElementError,
     InvalidDefaultValue,
-    InvalidAppliedDirectiveArgument
-
+    InvalidAppliedDirectiveArgument,
+    InvalidAppliedDirective
 }

File: src/main/java/graphql/schema/validation/SchemaValidator.java
Patch:
@@ -22,6 +22,7 @@ public SchemaValidator() {
         rules.add(new TypesImplementInterfaces());
         rules.add(new TypeAndFieldRule());
         rules.add(new DefaultValuesAreValid());
+        rules.add(new AppliedDirectivesAreValid());
         rules.add(new AppliedDirectiveArgumentsAreValid());
     }
 

File: src/main/java/graphql/analysis/QueryTraverser.java
Patch:
@@ -129,7 +129,7 @@ public void visitField(QueryVisitorFieldEnvironment env) {
      * @param initialValue the initial value to pass to the reducer
      * @param <T>          the type of reduced value
      *
-     * @return the calucalated overall value
+     * @return the calculated overall value
      */
     @SuppressWarnings("unchecked")
     public <T> T reducePreOrder(QueryReducer<T> queryReducer, T initialValue) {

File: src/main/java/graphql/collect/ImmutableKit.java
Patch:
@@ -28,7 +28,7 @@ public static <K, V> ImmutableMap<K, V> emptyMap() {
     }
 
     /**
-     * ImmutableMaps are hard to build via {@link Map#computeIfAbsent(Object, Function)} style.  This methods
+     * ImmutableMaps are hard to build via {@link Map#computeIfAbsent(Object, Function)} style.  This method
      * allows you to take a mutable map with mutable list of keys and make it immutable.
      * <p>
      * This of course has a cost - if the map is very large you will be using more memory.  But for static
@@ -118,7 +118,7 @@ public static <T> ImmutableList<T> addToList(Collection<? extends T> existing, T
      * @param extraValues more values to add
      * @param <T>         for two
      *
-     * @return an Immutable Set with the extra itens.
+     * @return an Immutable Set with the extra items.
      */
     public static <T> ImmutableSet<T> addToSet(Collection<? extends T> existing, T newValue, T... extraValues) {
         assertNotNull(existing);

File: src/main/java/graphql/execution/ExecutionStepInfo.java
Patch:
@@ -26,7 +26,7 @@
 @PublicApi
 public class ExecutionStepInfo {
 
-    /**
+    /*
      * An ExecutionStepInfo represent either a field or a list element inside a list of objects/interfaces/unions.
      *
      * A StepInfo never represent a Scalar/Enum inside a list (e.g. [String]) because GraphQL execution doesn't descend down

File: src/main/java/graphql/execution/nextgen/FetchedValueAnalysis.java
Patch:
@@ -72,7 +72,7 @@ public FetchedValue getFetchedValue() {
         return fetchedValue;
     }
 
-    public FetchedValueAnalysis transfrom(Consumer<Builder> builderConsumer) {
+    public FetchedValueAnalysis transform(Consumer<Builder> builderConsumer) {
         Builder builder = new Builder(this);
         builderConsumer.accept(builder);
         return builder.build();

File: src/main/java/graphql/execution/preparsed/persisted/PersistedQuerySupport.java
Patch:
@@ -78,7 +78,7 @@ protected boolean persistedQueryIdIsInvalid(Object persistedQueryId, String quer
     }
 
     /**
-     * Allows you to customize the graphql error that is sent back on a missing persistend query
+     * Allows you to customize the graphql error that is sent back on a missing persisted query
      *
      * @param persistedQueryError the missing persistent query exception
      *

File: src/main/java/graphql/introspection/IntrospectionWithDirectivesSupport.java
Patch:
@@ -102,7 +102,7 @@ public IntrospectionWithDirectivesSupport(DirectivePredicate directivePredicate)
      * This version allows you to filter what directives are listed via the provided predicate
      *
      * Some graphql systems (graphql-js in 2021) cannot cope with extra types starting with `__`
-     * so we use a `_` as a prefx by default.   You can supply your own prefix via this constructor.
+     * so we use a `_` as a prefix by default.   You can supply your own prefix via this constructor.
      *
      * See: https://github.com/graphql-java/graphql-java/pull/2221 for more details
      *
@@ -251,7 +251,7 @@ public interface DirectivePredicateEnvironment {
 
         /**
          * A schema has two list of directives.  A list of directives that are defined
-         * in that schema and the list of direcives that are applied to a schema element.
+         * in that schema and the list of directives that are applied to a schema element.
          *
          * This returns true if this filtering represents the defined directives.
          *

File: src/main/java/graphql/normalized/ENFMerger.java
Patch:
@@ -66,7 +66,7 @@ && isFieldInSharedInterface(field, fieldInGroup, schema)
     }
 
     private static boolean isFieldInSharedInterface(ExecutableNormalizedField fieldOne, ExecutableNormalizedField fieldTwo, GraphQLSchema schema) {
-        /**
+        /*
          * we can get away with only checking one of the object names, because all object names in one ENF are guaranteed to be the same field.
          * This comes from how the ENFs are created in the factory before.
          */

File: src/main/java/graphql/relay/Connection.java
Patch:
@@ -19,7 +19,7 @@ public interface Connection<T> {
     List<Edge<T>> getEdges();
 
     /**
-     * @return {@link graphql.relay.PageInfo} pagination data about about that list of edges
+     * @return {@link graphql.relay.PageInfo} pagination data about that list of edges
      */
     PageInfo getPageInfo();
 

File: src/main/java/graphql/schema/GraphQLCodeRegistry.java
Patch:
@@ -260,7 +260,7 @@ public DataFetcher<?> getDataFetcher(FieldCoordinates coordinates, GraphQLFieldD
         }
 
         /**
-         * @return the default data fetcher facttory associated with this code registry
+         * @return the default data fetcher factory associated with this code registry
          */
         public DataFetcherFactory<?> getDefaultDataFetcherFactory() {
             return defaultDataFetcherFactory;

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -304,7 +304,7 @@ public Builder type(GraphQLInputType type) {
         }
 
         /**
-         * A legacy method for setting a defaulr value
+         * A legacy method for setting a default value
          *
          * @param defaultValue the value to set
          *

File: src/main/java/graphql/schema/SchemaTransformer.java
Patch:
@@ -63,7 +63,7 @@
  * <p>
  * To insert elements use either {@link GraphQLTypeVisitor#insertAfter(TraverserContext, GraphQLSchemaElement)} or
  * {@link GraphQLTypeVisitor#insertBefore(TraverserContext, GraphQLSchemaElement)}
- * which will insert the new node before or afgter the current node being visited
+ * which will insert the new node before or after the current node being visited
  * <pre>
  * {@code
  *  public TraversalControl visitGraphQLObjectType(GraphQLObjectType objectType, TraverserContext<GraphQLSchemaElement> context) {

File: src/main/java/graphql/schema/diff/SchemaDiff.java
Patch:
@@ -893,9 +893,9 @@ private Optional<OperationTypeDefinition> getOpDef(String opName, SchemaDefiniti
 
     // looks for a type called `Query|Mutation|Subscription` and if it exist then assumes it as an operation def
 
-    private Optional<OperationTypeDefinition> synthOperationTypeDefinition(Function<Type, Optional<ObjectTypeDefinition>> typeReteriver, String opName) {
+    private Optional<OperationTypeDefinition> synthOperationTypeDefinition(Function<Type, Optional<ObjectTypeDefinition>> typeRetriever, String opName) {
         TypeName type = TypeName.newTypeName().name(capitalize(opName)).build();
-        Optional<ObjectTypeDefinition> typeDef = typeReteriver.apply(type);
+        Optional<ObjectTypeDefinition> typeDef = typeRetriever.apply(type);
         return typeDef.map(objectTypeDefinition -> OperationTypeDefinition.newOperationTypeDefinition().name(opName).typeName(type).build());
     }
 

File: src/main/java/graphql/schema/idl/ScalarInfo.java
Patch:
@@ -49,7 +49,7 @@ public class ScalarInfo {
      *
      * @param scalarTypeName the name of the scalar type in question
      *
-     * @return true if the scalar type is is specified by the graphql specification
+     * @return true if the scalar type is specified by the graphql specification
      */
     public static boolean isGraphqlSpecifiedScalar(String scalarTypeName) {
         return inList(GRAPHQL_SPECIFICATION_SCALARS, scalarTypeName);
@@ -60,7 +60,7 @@ public static boolean isGraphqlSpecifiedScalar(String scalarTypeName) {
      *
      * @param scalarType the type in question
      *
-     * @return true if the scalar type is is specified by the graphql specification
+     * @return true if the scalar type is specified by the graphql specification
      */
     public static boolean isGraphqlSpecifiedScalar(GraphQLScalarType scalarType) {
         return inList(GRAPHQL_SPECIFICATION_SCALARS, scalarType.getName());

File: src/main/java/graphql/schema/idl/SchemaPrinter.java
Patch:
@@ -209,7 +209,7 @@ public Options includeSchemaDefinition(boolean flag) {
         /**
          * This flag controls whether schema printer will include directive definitions at the top of the schema, but does not remove them from the field or type usage.
          * <p>
-         * In some schema defintions, like Apollo Federation, the schema should be printed without the directive definitions.
+         * In some schema definitions, like Apollo Federation, the schema should be printed without the directive definitions.
          * This simplified schema is returned by a GraphQL query to other services, in a format that is different that the introspection query.
          * <p>
          * On by default.

File: src/main/java/graphql/schema/idl/SchemaTypeChecker.java
Patch:
@@ -322,7 +322,7 @@ static <T, E extends GraphQLError> void checkNamedUniqueness(List<GraphQLError>
 
     private void checkTypeResolversArePresent(List<GraphQLError> errors, TypeDefinitionRegistry typeRegistry, RuntimeWiring wiring) {
 
-        Predicate<InterfaceTypeDefinition> noDynamicResolverForInterface = interaceTypeDef -> !wiring.getWiringFactory().providesTypeResolver(new InterfaceWiringEnvironment(typeRegistry, interaceTypeDef));
+        Predicate<InterfaceTypeDefinition> noDynamicResolverForInterface = interfaceTypeDef -> !wiring.getWiringFactory().providesTypeResolver(new InterfaceWiringEnvironment(typeRegistry, interfaceTypeDef));
         Predicate<UnionTypeDefinition> noDynamicResolverForUnion = unionTypeDef -> !wiring.getWiringFactory().providesTypeResolver(new UnionWiringEnvironment(typeRegistry, unionTypeDef));
 
         Predicate<TypeDefinition> noTypeResolver = typeDefinition -> !wiring.getTypeResolvers().containsKey(typeDefinition.getName());

File: src/main/java/graphql/util/TraverserContext.java
Patch:
@@ -120,7 +120,7 @@ enum Phase {
      * Obtains all visited nodes and values received by the {@link TraverserVisitor#enter(graphql.util.TraverserContext) }
      * method
      *
-     * @return a map containg all nodes visited and values passed when visiting nodes for the first time
+     * @return a map containing all nodes visited and values passed when visiting nodes for the first time
      */
     Set<T> visitedNodes();
 
@@ -148,7 +148,7 @@ enum Phase {
     /**
      * Stores a variable in the context
      *
-     * @param <S>   type of a varable
+     * @param <S>   type of a variable
      * @param key   key to create bindings for the variable
      * @param value value of variable
      *

File: src/main/java/graphql/validation/rules/OverlappingFieldsCanBeMerged.java
Patch:
@@ -143,7 +143,7 @@ private GraphQLFieldDefinition getVisibleFieldDefinition(GraphQLFieldsContainer
 
 
     private List<Conflict> findConflicts(Map<String, Set<FieldAndType>> fieldMap) {
-        /**
+        /*
          * The algorithm implemented here is not the one from the Spec, but is based on
          * https://tech.xing.com/graphql-overlapping-fields-can-be-merged-fast-ea6e92e0a01
          * . It is not the final version (Listing 11), but Listing 10 adopted to this code base.

File: src/main/java/graphql/schema/idl/SchemaPrinter.java
Patch:
@@ -926,7 +926,7 @@ public String print(List<GraphQLSchemaElement> elements) {
             if (element instanceof GraphQLDirective) {
                 out.print(print(((GraphQLDirective) element)));
             } else if (element instanceof GraphQLType) {
-                printType(out, (GraphQLType) element, DEFAULT_FIELD_VISIBILITY);
+                printSchemaElement(out, element, DEFAULT_FIELD_VISIBILITY);
             } else {
                 Assert.assertShouldNeverHappen("How did we miss a %s", element.getClass());
             }

File: src/main/java/graphql/analysis/MaxQueryComplexityInstrumentation.java
Patch:
@@ -103,6 +103,7 @@ public void visitField(QueryVisitorFieldEnvironment env) {
             if (totalComplexity > maxComplexity) {
                 QueryComplexityInfo queryComplexityInfo = QueryComplexityInfo.newQueryComplexityInfo()
                         .complexity(totalComplexity)
+                        .instrumentationValidationParameters(parameters)
                         .build();
                 boolean throwAbortException = maxQueryComplexityExceededFunction.apply(queryComplexityInfo);
                 if (throwAbortException) {

File: src/main/java/graphql/validation/ValidationErrorType.java
Patch:
@@ -3,6 +3,7 @@
 
 public enum ValidationErrorType {
 
+    MaxValidationErrorsReached,
     DefaultForNonNullArgument,
     WrongType,
     UnknownType,

File: src/test/java/benchmark/TypeDefinitionParserVersusSerializeBenchMark.java
Patch:
@@ -2,7 +2,6 @@
 
 import graphql.schema.idl.SchemaParser;
 import graphql.schema.idl.TypeDefinitionRegistry;
-import org.jetbrains.annotations.NotNull;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Measurement;
@@ -62,7 +61,6 @@ static TypeDefinitionRegistry serialise() {
         });
     }
 
-    @NotNull
     private static ByteArrayOutputStream serialisedRegistryStream(TypeDefinitionRegistry registryOut) {
         return asRTE(() -> {
             ByteArrayOutputStream baOS = new ByteArrayOutputStream();

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -354,14 +354,14 @@ private Object externalValueToLiteralForObject(GraphqlFieldVisibility fieldVisib
                 if (valueMode == ValueMode.LITERAL) {
                     normalizedResult.put(fieldName, new NormalizedInputValue(simplePrint(fieldType), defaultValueLiteral));
                 } else {
-                    objectFields.add(newObjectField().value((Value) defaultValueLiteral).build());
+                    objectFields.add(newObjectField().name(fieldName).value((Value) defaultValueLiteral).build());
                 }
             } else if (hasValue) {
                 if (fieldValue == null) {
                     if (valueMode == NORMALIZED) {
                         normalizedResult.put(fieldName, new NormalizedInputValue(simplePrint(fieldType), null));
                     } else {
-                        objectFields.add(newObjectField().value(newNullValue().build()).build());
+                        objectFields.add(newObjectField().name(fieldName).value(newNullValue().build()).build());
                     }
                 } else {
                     Object literal = externalValueToLiteral(fieldVisibility,
@@ -371,7 +371,7 @@ private Object externalValueToLiteralForObject(GraphqlFieldVisibility fieldVisib
                     if (valueMode == NORMALIZED) {
                         normalizedResult.put(fieldName, new NormalizedInputValue(simplePrint(fieldType), literal));
                     } else {
-                        objectFields.add(newObjectField().value((Value) literal).build());
+                        objectFields.add(newObjectField().name(fieldName).value((Value) literal).build());
                     }
                 }
             }

File: src/main/java/graphql/language/ObjectField.java
Patch:
@@ -28,8 +28,8 @@ public class ObjectField extends AbstractNode<ObjectField> implements NamedNode<
     @Internal
     protected ObjectField(String name, Value value, SourceLocation sourceLocation, List<Comment> comments, IgnoredChars ignoredChars, Map<String, String> additionalData) {
         super(sourceLocation, comments, ignoredChars, additionalData);
-        this.name = name;
-        this.value = value;
+        this.name = assertNotNull(name);
+        this.value = assertNotNull(value);
     }
 
     /**

File: src/main/java/graphql/util/FpKit.java
Patch:
@@ -278,7 +278,7 @@ public static <T> List<T> filterList(Collection<T> list, Predicate<T> filter) {
                 .collect(Collectors.toList());
     }
 
-    public static <T> Set<T> filterSet(Set<T> input, Predicate<T> filter) {
+    public static <T> Set<T> filterSet(Collection<T> input, Predicate<T> filter) {
         LinkedHashSet<T> result = new LinkedHashSet<>();
         for (T t : input) {
             if (filter.test(t)) {

File: src/main/java/graphql/execution/AsyncExecutionStrategy.java
Patch:
@@ -76,6 +76,7 @@ public CompletableFuture<ExecutionResult> execute(ExecutionContext executionCont
             // if there are any issues with combining/handling the field results,
             // complete the future at all costs and bubble up any thrown exception so
             // the execution does not hang.
+            executionStrategyCtx.onFieldValuesException();
             overallResult.completeExceptionally(ex);
             return null;
         });

File: src/main/java/graphql/validation/AbstractRule.java
Patch:
@@ -18,6 +18,7 @@
 import graphql.language.VariableReference;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 
 import static graphql.validation.ValidationError.newValidationError;
@@ -51,7 +52,7 @@ public ValidationUtil getValidationUtil() {
         return validationUtil;
     }
 
-    public void addError(ValidationErrorType validationErrorType, List<? extends Node<?>> locations, String description) {
+    public void addError(ValidationErrorType validationErrorType, Collection<? extends Node<?>> locations, String description) {
         List<SourceLocation> locationList = new ArrayList<>();
         for (Node<?> node : locations) {
             locationList.add(node.getSourceLocation());

File: src/main/java/graphql/schema/DataFetcherFactoryEnvironment.java
Patch:
@@ -25,7 +25,7 @@ public static Builder newDataFetchingFactoryEnvironment() {
         return new Builder();
     }
 
-    static class Builder {
+    public static class Builder {
         GraphQLFieldDefinition fieldDefinition;
 
         public Builder fieldDefinition(GraphQLFieldDefinition fieldDefinition) {

File: src/main/java/graphql/schema/idl/TypeDefinitionRegistry.java
Patch:
@@ -28,6 +28,7 @@
 import graphql.schema.idl.errors.TypeRedefinitionError;
 import graphql.util.FpKit;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedHashMap;
@@ -47,7 +48,7 @@
  * a graphql schema definition file via {@link SchemaParser#parse(String)}
  */
 @PublicApi
-public class TypeDefinitionRegistry {
+public class TypeDefinitionRegistry implements Serializable {
 
     private final Map<String, List<ObjectTypeExtensionDefinition>> objectTypeExtensions = new LinkedHashMap<>();
     private final Map<String, List<InterfaceTypeExtensionDefinition>> interfaceTypeExtensions = new LinkedHashMap<>();
@@ -418,7 +419,7 @@ public boolean hasType(TypeName typeName) {
         return types.containsKey(name) || ScalarInfo.GRAPHQL_SPECIFICATION_SCALARS_DEFINITIONS.containsKey(name) || scalarTypes.containsKey(name) || objectTypeExtensions.containsKey(name);
     }
 
-    public Optional<TypeDefinition> getType(Type type) {
+    public Optional<TypeDefinition>     getType(Type type) {
         String typeName = TypeInfo.typeInfo(type).getName();
         return getType(typeName);
     }

File: src/main/java/graphql/parser/StringValueParsing.java
Patch:
@@ -2,6 +2,7 @@
 
 import graphql.Assert;
 import graphql.Internal;
+import graphql.language.SourceLocation;
 
 import java.io.StringWriter;
 import java.util.ArrayList;
@@ -102,7 +103,7 @@ private static boolean containsOnlyWhiteSpace(String str) {
         return leadingWhitespace(str) == str.length();
     }
 
-    public static String parseSingleQuotedString(String string) {
+    public static String parseSingleQuotedString(String string, SourceLocation sourceLocation) {
         StringWriter writer = new StringWriter(string.length() - 2);
         int end = string.length() - 1;
         for (int i = 1; i < end; i++) {
@@ -139,7 +140,7 @@ public static String parseSingleQuotedString(String string) {
                     writer.write('\t');
                     continue;
                 case 'u':
-                    i = UnicodeUtil.parseAndWriteUnicode(writer, string, i);
+                    i = UnicodeUtil.parseAndWriteUnicode(writer, string, i, sourceLocation);
                     continue;
                 default:
                     Assert.assertShouldNeverHappen();

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -693,7 +693,7 @@ private Object handleCoercionProblem(ExecutionContext context, ExecutionStrategy
      * @throws java.lang.ClassCastException if its not an Iterable
      */
     protected Iterable<Object> toIterable(Object result) {
-        return FpKit.toCollection(result);
+        return FpKit.toIterable(result);
     }
 
     protected GraphQLObjectType resolveType(ExecutionContext executionContext, ExecutionStrategyParameters parameters, GraphQLType fieldType) {

File: src/main/java/graphql/schema/idl/ArgValueOfAllowedTypeChecker.java
Patch:
@@ -46,6 +46,7 @@
 import static graphql.schema.idl.errors.DirectiveIllegalArgumentTypeError.MUST_BE_VALID_ENUM_VALUE_MESSAGE;
 import static graphql.schema.idl.errors.DirectiveIllegalArgumentTypeError.NOT_A_VALID_SCALAR_LITERAL_MESSAGE;
 import static graphql.schema.idl.errors.DirectiveIllegalArgumentTypeError.UNKNOWN_FIELDS_MESSAGE;
+import static java.lang.String.format;
 import static java.util.Collections.emptyList;
 import static java.util.stream.Collectors.counting;
 import static java.util.stream.Collectors.groupingBy;
@@ -113,7 +114,7 @@ void checkArgValueMatchesAllowedType(List<GraphQLError> errors, Value<?> instanc
     }
 
     private void addValidationError(List<GraphQLError> errors, String message, Object... args) {
-        errors.add(new DirectiveIllegalArgumentTypeError(element, elementName, directive.getName(), argument.getName(), String.format(message, args)));
+        errors.add(new DirectiveIllegalArgumentTypeError(element, elementName, directive.getName(), argument.getName(), format(message, args)));
     }
 
     private void checkArgValueMatchesAllowedTypeName(List<GraphQLError> errors, Value<?> instanceValue, Type<?> allowedArgType) {
@@ -123,7 +124,7 @@ private void checkArgValueMatchesAllowedTypeName(List<GraphQLError> errors, Valu
 
         String allowedTypeName = ((TypeName) allowedArgType).getName();
         TypeDefinition<?> allowedTypeDefinition = typeRegistry.getType(allowedTypeName)
-                .orElseThrow(() -> new AssertException("Directive unknown argument type '%s'. This should have been validated before."));
+                .orElseThrow(() -> new AssertException(format("Directive unknown argument type '%s'. This should have been validated before.", allowedTypeName)));
 
         if (allowedTypeDefinition instanceof ScalarTypeDefinition) {
             checkArgValueMatchesAllowedScalar(errors, instanceValue, allowedTypeName);

File: src/main/java/graphql/schema/idl/ArgValueOfAllowedTypeChecker.java
Patch:
@@ -46,6 +46,7 @@
 import static graphql.schema.idl.errors.DirectiveIllegalArgumentTypeError.MUST_BE_VALID_ENUM_VALUE_MESSAGE;
 import static graphql.schema.idl.errors.DirectiveIllegalArgumentTypeError.NOT_A_VALID_SCALAR_LITERAL_MESSAGE;
 import static graphql.schema.idl.errors.DirectiveIllegalArgumentTypeError.UNKNOWN_FIELDS_MESSAGE;
+import static java.lang.String.format;
 import static java.util.Collections.emptyList;
 import static java.util.stream.Collectors.counting;
 import static java.util.stream.Collectors.groupingBy;
@@ -113,7 +114,7 @@ void checkArgValueMatchesAllowedType(List<GraphQLError> errors, Value<?> instanc
     }
 
     private void addValidationError(List<GraphQLError> errors, String message, Object... args) {
-        errors.add(new DirectiveIllegalArgumentTypeError(element, elementName, directive.getName(), argument.getName(), String.format(message, args)));
+        errors.add(new DirectiveIllegalArgumentTypeError(element, elementName, directive.getName(), argument.getName(), format(message, args)));
     }
 
     private void checkArgValueMatchesAllowedTypeName(List<GraphQLError> errors, Value<?> instanceValue, Type<?> allowedArgType) {
@@ -123,7 +124,7 @@ private void checkArgValueMatchesAllowedTypeName(List<GraphQLError> errors, Valu
 
         String allowedTypeName = ((TypeName) allowedArgType).getName();
         TypeDefinition<?> allowedTypeDefinition = typeRegistry.getType(allowedTypeName)
-                .orElseThrow(() -> new AssertException("Directive unknown argument type '%s'. This should have been validated before."));
+                .orElseThrow(() -> new AssertException(format("Directive unknown argument type '%s'. This should have been validated before.", allowedTypeName)));
 
         if (allowedTypeDefinition instanceof ScalarTypeDefinition) {
             checkArgValueMatchesAllowedScalar(errors, instanceValue, allowedTypeName);

File: src/main/java/graphql/execution/preparsed/persisted/PersistedQueryNotFound.java
Patch:
@@ -1,6 +1,5 @@
 package graphql.execution.preparsed.persisted;
 
-import graphql.ErrorClassification;
 import graphql.PublicApi;
 
 import java.util.LinkedHashMap;
@@ -10,7 +9,7 @@
  * An exception that indicates the query id is not valid and can be found ever in cache
  */
 @PublicApi
-public class PersistedQueryNotFound extends RuntimeException implements ErrorClassification {
+public class PersistedQueryNotFound extends PersistedQueryError {
     private final Object persistedQueryId;
 
     public PersistedQueryNotFound(Object persistedQueryId) {
@@ -31,6 +30,7 @@ public String toString() {
         return "PersistedQueryNotFound";
     }
 
+    @Override
     public Map<String, Object> getExtensions() {
         LinkedHashMap<String, Object> extensions = new LinkedHashMap<>();
         extensions.put("persistedQueryId", persistedQueryId);

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -174,6 +174,9 @@ public Map<String, NormalizedInputValue> getNormalizedArgumentValues(List<GraphQ
         for (GraphQLArgument argumentDefinition : argumentTypes) {
             String argumentName = argumentDefinition.getName();
             Argument argument = argumentMap.get(argumentName);
+            if (argument == null) {
+                continue;
+            }
 
             // If a variable doesn't exist then we can't put it into the result Map
             if (isVariableAbsent(argument.getValue(), normalizedVariables)) {

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -24,7 +24,7 @@
 import graphql.execution.instrumentation.parameters.InstrumentationExecutionStrategyParameters;
 import graphql.execution.instrumentation.parameters.InstrumentationFieldFetchParameters;
 import graphql.execution.instrumentation.parameters.InstrumentationFieldParameters;
-import graphql.normalized.NormalizedField;
+import graphql.normalized.ExecutableNormalizedField;
 import graphql.schema.DataFetcher;
 import graphql.schema.DataFetchingEnvironment;
 import graphql.schema.DataFetchingFieldSelectionSet;
@@ -250,7 +250,7 @@ private CompletableFuture<FetchedValues> fetchData(ExecutionContext executionCon
 
         QueryDirectivesImpl queryDirectives = new QueryDirectivesImpl(fields, executionContext.getGraphQLSchema(), executionContext.getVariables());
 
-        Supplier<NormalizedField> normalizedFieldSupplier = getNormalizedField(executionContext, parameters, parameters::getExecutionStepInfo);
+        Supplier<ExecutableNormalizedField> normalizedFieldSupplier = getNormalizedField(executionContext, parameters, parameters::getExecutionStepInfo);
 
         GraphQLOutputType fieldType = fieldDef.getType();
         DataFetchingFieldSelectionSet fieldCollector = DataFetchingFieldSelectionSetImpl.newCollector(executionContext.getGraphQLSchema(), fieldType, normalizedFieldSupplier);

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -174,6 +174,9 @@ public Map<String, NormalizedInputValue> getNormalizedArgumentValues(List<GraphQ
         for (GraphQLArgument argumentDefinition : argumentTypes) {
             String argumentName = argumentDefinition.getName();
             Argument argument = argumentMap.get(argumentName);
+            if (argument == null) {
+                continue;
+            }
 
             // If a variable doesn't exist then we can't put it into the result Map
             if (isVariableAbsent(argument.getValue(), normalizedVariables)) {

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -24,7 +24,7 @@
 import graphql.execution.instrumentation.parameters.InstrumentationExecutionStrategyParameters;
 import graphql.execution.instrumentation.parameters.InstrumentationFieldFetchParameters;
 import graphql.execution.instrumentation.parameters.InstrumentationFieldParameters;
-import graphql.normalized.NormalizedField;
+import graphql.normalized.ExecutableNormalizedField;
 import graphql.schema.DataFetcher;
 import graphql.schema.DataFetchingEnvironment;
 import graphql.schema.DataFetchingFieldSelectionSet;
@@ -250,7 +250,7 @@ private CompletableFuture<FetchedValues> fetchData(ExecutionContext executionCon
 
         QueryDirectivesImpl queryDirectives = new QueryDirectivesImpl(fields, executionContext.getGraphQLSchema(), executionContext.getVariables());
 
-        Supplier<NormalizedField> normalizedFieldSupplier = getNormalizedField(executionContext, parameters, parameters::getExecutionStepInfo);
+        Supplier<ExecutableNormalizedField> normalizedFieldSupplier = getNormalizedField(executionContext, parameters, parameters::getExecutionStepInfo);
 
         GraphQLOutputType fieldType = fieldDef.getType();
         DataFetchingFieldSelectionSet fieldCollector = DataFetchingFieldSelectionSetImpl.newCollector(executionContext.getGraphQLSchema(), fieldType, normalizedFieldSupplier);

File: src/main/java/graphql/parser/UnicodeUtil.java
Patch:
@@ -59,6 +59,6 @@ private static boolean isNotBracedEscape(String string, int i) {
 
     private static boolean isValidUnicodeCodePoint(Integer value) {
         // TODO: Add bad surrogate checks
-        return value < MAX_UNICODE_CODE_POINT;
+        return value <= MAX_UNICODE_CODE_POINT;
     }
 }

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -893,9 +893,8 @@ protected List<Comment> getCommentOnChannel(List<Token> refChannel) {
     private List<Type> getImplementz(GraphqlParser.ImplementsInterfacesContext implementsInterfacesContext) {
         List<Type> implementz = new ArrayList<>();
         while (implementsInterfacesContext != null) {
-            List<TypeName> typeNames = map(implementsInterfacesContext.typeName(), this::createTypeName);
-
-            implementz.addAll(0, typeNames);
+            GraphqlParser.TypeNameContext typeName = implementsInterfacesContext.typeName();
+            implementz.add(0, createTypeName(typeName));
             implementsInterfacesContext = implementsInterfacesContext.implementsInterfaces();
         }
         return implementz;

File: src/main/java/graphql/ExecutionResultImpl.java
Patch:
@@ -45,7 +45,7 @@ private ExecutionResultImpl(boolean dataPresent, Object data, List<? extends Gra
         this.dataPresent = dataPresent;
         this.data = data;
 
-        if (errors != null && !errors.isEmpty()) {
+        if (errors != null) {
             this.errors = ImmutableList.copyOf(errors);
         } else {
             this.errors = ImmutableKit.emptyList();

File: src/main/java/graphql/schema/GraphQLDirective.java
Patch:
@@ -96,7 +96,7 @@ public DirectiveDefinition getDefinition() {
     public String toString() {
         return "GraphQLDirective{" +
                 "name='" + name + '\'' +
-                "repeatable='" + repeatable + '\'' +
+                ", repeatable='" + repeatable + '\'' +
                 ", arguments=" + arguments +
                 ", locations=" + locations +
                 '}';

File: src/main/java/graphql/schema/idl/FetchSchemaDirectiveWiring.java
Patch:
@@ -1,6 +1,7 @@
 package graphql.schema.idl;
 
 import graphql.Internal;
+import graphql.execution.ValuesResolver;
 import graphql.schema.DataFetcher;
 import graphql.schema.GraphQLArgument;
 import graphql.schema.GraphQLDirective;
@@ -35,7 +36,7 @@ public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment<GraphQLFi
     private String atFetchFromSupport(String fieldName, List<GraphQLDirective> directives) {
         // @fetch(from : "name")
         Optional<GraphQLArgument> from = directiveWithArg(directives, FETCH, "from");
-        return from.map(arg -> String.valueOf(arg.getValue())).orElse(fieldName);
+        return from.map(arg -> (String) ValuesResolver.valueToInternalValue(arg.getArgumentValue(), arg.getType())).orElse(fieldName);
     }
 
 }

File: src/main/java/graphql/schema/idl/SchemaGenerator.java
Patch:
@@ -89,7 +89,7 @@ private GraphQLSchema makeExecutableSchemaImpl(TypeDefinitionRegistry typeRegist
 
         GraphQLSchema.Builder schemaBuilder = GraphQLSchema.newSchema();
 
-        Set<GraphQLDirective> additionalDirectives = schemaGeneratorHelper.buildAdditionalDirectives(buildCtx);
+        Set<GraphQLDirective> additionalDirectives = schemaGeneratorHelper.buildAdditionalDirectiveDefinitions(buildCtx);
         schemaBuilder.additionalDirectives(additionalDirectives);
 
         schemaGeneratorHelper.buildSchemaDirectivesAndExtensions(buildCtx, schemaBuilder);

File: src/main/java/graphql/schema/validation/SchemaValidationErrorType.java
Patch:
@@ -14,6 +14,8 @@ public enum SchemaValidationErrorType {
     InvalidUnionMemberTypeError,
     InvalidCustomizedNameError,
     NonNullWrapNonNullError,
-    RepetitiveElementError
+    RepetitiveElementError,
+    InvalidDefaultValue,
+    InvalidAppliedDirectiveArgument
 
 }

File: src/main/java/graphql/validation/ValidationUtil.java
Patch:
@@ -159,7 +159,7 @@ private boolean isValidLiteralValue(Value<?> value, GraphQLInputObjectType type,
     private Set<String> getMissingFields(GraphQLInputObjectType type, Map<String, ObjectField> objectFieldMap, GraphqlFieldVisibility fieldVisibility) {
         return fieldVisibility.getFieldDefinitions(type).stream()
                 .filter(field -> isNonNull(field.getType()))
-                .filter(value -> (value.getDefaultValue() == null) && !objectFieldMap.containsKey(value.getName()))
+                .filter(value -> (value.getInputFieldDefaultValue().isNotSet()) && !objectFieldMap.containsKey(value.getName()))
                 .map(GraphQLInputObjectField::getName)
                 .collect(ImmutableSet.toImmutableSet());
     }

File: src/test/groovy/readme/DirectivesExamples.java
Patch:
@@ -39,7 +39,7 @@ class AuthorisationDirective implements SchemaDirectiveWiring {
 
         @Override
         public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment<GraphQLFieldDefinition> environment) {
-            String targetAuthRole = (String) environment.getDirective().getArgument("role").getValue();
+            String targetAuthRole = (String) environment.getDirective().getArgument("role").getArgumentValue().getValue();
 
             //
             // build a data fetcher that first checks authorisation roles before then calling the original data fetcher

File: src/main/java/graphql/schema/GraphQLArgument.java
Patch:
@@ -345,7 +345,7 @@ public Builder clearDefaultValue() {
          * @deprecated use {@link #valueLiteral(Value)} or {@link #valueProgrammatic(Object)}
          */
         @Deprecated
-        public Builder value(Object value) {
+        public Builder value(@Nullable Object value) {
             this.value = InputValueWithState.newInternalValue(value);
             return this;
         }

File: src/main/java/graphql/util/Anonymizer.java
Patch:
@@ -204,7 +204,7 @@ public TraversalControl visitGraphQLDirective(GraphQLDirective graphQLDirective,
                 if (Directives.DEPRECATED_DIRECTIVE_DEFINITION.getName().equals(graphQLDirective.getName())) {
                     GraphQLArgument reason = newArgument().name("reason")
                             .type(Scalars.GraphQLString)
-                            .value(null).build();
+                            .clearValue().build();
                     GraphQLDirective newElement = graphQLDirective.transform(builder -> {
                         builder.description(null).argument(reason);
                     });

File: src/main/java/graphql/analysis/NodeVisitorWithTypeTracking.java
Patch:
@@ -236,7 +236,8 @@ public TraversalControl visitObjectField(ObjectField node, TraverserContext<Node
     @Override
     protected TraversalControl visitValue(Value<?> value, TraverserContext<Node> context) {
         if (context.getParentNode() instanceof VariableDefinition) {
-            return TraversalControl.CONTINUE;
+            visitVariableDefinition(((VariableDefinition) context.getParentNode()), context);
+            return TraversalControl.ABORT;
         }
 
         QueryVisitorFieldArgumentEnvironment fieldArgEnv = context.getVarFromParents(QueryVisitorFieldArgumentEnvironment.class);

File: src/main/java/graphql/schema/validation/SchemaValidationErrorType.java
Patch:
@@ -14,6 +14,7 @@ public enum SchemaValidationErrorType {
     InvalidUnionMemberTypeError,
     InvalidCustomizedNameError,
     NonNullWrapNonNullError,
-    RepetitiveElementError
+    RepetitiveElementError,
+    InvalidDefaultValue
 
 }

File: src/main/java/graphql/schema/validation/SchemaValidator.java
Patch:
@@ -21,6 +21,7 @@ public SchemaValidator() {
         rules.add(new NoUnbrokenInputCycles());
         rules.add(new TypesImplementInterfaces());
         rules.add(new TypeAndFieldRule());
+        rules.add(new DefaultValuesAreValid());
     }
 
     public List<GraphQLTypeVisitor> getRules() {
@@ -30,6 +31,7 @@ public List<GraphQLTypeVisitor> getRules() {
     public Set<SchemaValidationError> validateSchema(GraphQLSchema schema) {
         SchemaValidationErrorCollector validationErrorCollector = new SchemaValidationErrorCollector();
         Map<Class<?>, Object> rootVars = new LinkedHashMap<>();
+        rootVars.put(GraphQLSchema.class, schema);
         rootVars.put(SchemaValidationErrorCollector.class, validationErrorCollector);
         new SchemaTraverser().depthFirstFullSchema(rules, schema, rootVars);
         return validationErrorCollector.getErrors();

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -155,7 +155,7 @@ public static Object valueToInternalValue(Object value, ValueState valueState, G
             return new ValuesResolver().literalToInternalValue(fieldVisibility, type, (Value<?>) value, emptyMap(), null, ValueMode.COERCED, false);
         }
         if (valueState == ValueState.EXTERNAL_VALUE) {
-            return new ValuesResolver().externalValueToLiteral(fieldVisibility, value, (GraphQLInputType) type);
+            return new ValuesResolver().externalValueToInternalValue(fieldVisibility, "value", (GraphQLInputType) type, value, ValueMode.COERCED);
         }
         return Assert.assertShouldNeverHappen("unexpected value state " + valueState);
     }

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -164,10 +164,10 @@ public enum TypeKind {
             Object type = environment.getSource();
             if (type instanceof GraphQLArgument) {
                 GraphQLArgument inputField = (GraphQLArgument) type;
-                return inputField.hasSetDefaultValue() ? printDefaultValue(inputField.getDefaultValue(), inputField.getDefaultValueState(), inputField.getType()) : null;
+                return inputField.hasSetDefaultValue() ? printDefaultValue(inputField.getArgumentDefaultValue(), inputField.getDefaultValueState(), inputField.getType()) : null;
             } else if (type instanceof GraphQLInputObjectField) {
                 GraphQLInputObjectField inputField = (GraphQLInputObjectField) type;
-                return inputField.hasSetDefaultValue() ? printDefaultValue(inputField.getDefaultValue(), inputField.getDefaultValueState(), inputField.getType()) : null;
+                return inputField.hasSetDefaultValue() ? printDefaultValue(inputField.getInputFieldDefaultValue(), inputField.getDefaultValueState(), inputField.getType()) : null;
             }
             return null;
         });

File: src/main/java/graphql/introspection/IntrospectionWithDirectivesSupport.java
Patch:
@@ -195,7 +195,7 @@ private GraphQLObjectType addAppliedDirectives(GraphQLObjectType originalType, G
         DataFetcher<?> argValueDF = env -> {
             final GraphQLArgument argument = env.getSource();
             if (argument.hasSetValue()) {
-                Object value = argument.getValue();
+                Object value = argument.getArgumentValue();
                 return AstPrinter.printAst(ValuesResolver.valueToLiteral(value, argument.getValueState(), argument.getType()));
             } else {
                 return null;

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -83,7 +83,7 @@ public GraphQLInputType getType() {
         return replacedType != null ? replacedType : originalType;
     }
 
-    public Object getDefaultValue() {
+    public Object getInputFieldDefaultValue() {
         return defaultValue;
     }
 
@@ -241,7 +241,7 @@ public Builder() {
         public Builder(GraphQLInputObjectField existing) {
             this.name = existing.getName();
             this.description = existing.getDescription();
-            this.defaultValue = existing.getDefaultValue();
+            this.defaultValue = existing.getInputFieldDefaultValue();
             this.defaultValueState = existing.getDefaultValueState();
             this.type = existing.originalType;
             this.definition = existing.getDefinition();

File: src/main/java/graphql/schema/idl/FetchSchemaDirectiveWiring.java
Patch:
@@ -36,7 +36,7 @@ public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment<GraphQLFi
     private String atFetchFromSupport(String fieldName, List<GraphQLDirective> directives) {
         // @fetch(from : "name")
         Optional<GraphQLArgument> from = directiveWithArg(directives, FETCH, "from");
-        return from.map(arg -> (String) ValuesResolver.valueToInternalValue(arg.getValue(), arg.getValueState(), arg.getType())).orElse(fieldName);
+        return from.map(arg -> (String) ValuesResolver.valueToInternalValue(arg.getArgumentValue(), arg.getValueState(), arg.getType())).orElse(fieldName);
     }
 
 }

File: src/main/java/graphql/schema/idl/SchemaGeneratorHelper.java
Patch:
@@ -286,7 +286,7 @@ private GraphQLArgument buildAppliedDArgument(BuildContext buildCtx, Argument ar
         GraphQLInputType inputType = directiveDefArgument.getType();
         builder.type(inputType);
         // we know it is a literal because it was created by SchemaGenerator
-        Value defaultValue = (Value) directiveDefArgument.getDefaultValue();
+        Value defaultValue = (Value) directiveDefArgument.getArgumentDefaultValue();
         if (defaultValue != null) {
             builder.defaultValueLiteral(defaultValue);
         }
@@ -314,10 +314,10 @@ private List<GraphQLArgument> transferMissingArguments(List<GraphQLArgument> arg
                         .type(directiveDefArg.getType());
 
                 if (directiveDefArg.hasSetDefaultValue()) {
-                    missingArg.defaultValueLiteral((Value) directiveDefArg.getDefaultValue());
+                    missingArg.defaultValueLiteral((Value) directiveDefArg.getArgumentDefaultValue());
                 }
                 if (directiveDefArg.hasSetValue()) {
-                    missingArg.valueLiteral((Value) directiveDefArg.getValue());
+                    missingArg.valueLiteral((Value) directiveDefArg.getArgumentValue());
                 }
                 argumentsOut.add(missingArg.build());
             }

File: src/main/java/graphql/schema/validation/TypesImplementInterfaces.java
Patch:
@@ -151,8 +151,8 @@ private void checkFieldArgumentEquivalence(GraphQLImplementingType implementingT
                         same = false;
                     }
                     if (objectArg.hasSetDefaultValue() && interfaceArg.hasSetDefaultValue()) {
-                        Value<?> objectDefaultValue = ValuesResolver.valueToLiteral(objectArg.getDefaultValue(), objectArg.getDefaultValueState(), objectArg.getType());
-                        Value<?> interfaceDefaultValue = ValuesResolver.valueToLiteral(interfaceArg.getDefaultValue(), interfaceArg.getDefaultValueState(), interfaceArg.getType());
+                        Value<?> objectDefaultValue = ValuesResolver.valueToLiteral(objectArg.getArgumentDefaultValue(), objectArg.getDefaultValueState(), objectArg.getType());
+                        Value<?> interfaceDefaultValue = ValuesResolver.valueToLiteral(interfaceArg.getArgumentDefaultValue(), interfaceArg.getDefaultValueState(), interfaceArg.getType());
                         if (!Objects.equals(printAst(objectDefaultValue), printAst(interfaceDefaultValue))) {
                             same = false;
                         }

File: src/main/java/graphql/util/Anonymizer.java
Patch:
@@ -147,7 +147,7 @@ public TraversalControl visitGraphQLArgument(GraphQLArgument graphQLArgument, Tr
                 GraphQLArgument newElement = graphQLArgument.transform(builder -> {
                     builder.name(newName).description(null).definition(null);
                     if (graphQLArgument.hasSetDefaultValue()) {
-                        Value<?> defaultValueLiteral = ValuesResolver.valueToLiteral(graphQLArgument.getDefaultValue(), graphQLArgument.getDefaultValueState(), graphQLArgument.getType());
+                        Value<?> defaultValueLiteral = ValuesResolver.valueToLiteral(graphQLArgument.getArgumentDefaultValue(), graphQLArgument.getDefaultValueState(), graphQLArgument.getType());
                         builder.defaultValueLiteral(replaceDefaultValue(defaultValueLiteral, defaultStringValueCounter, defaultIntValueCounter));
                     }
                 });
@@ -227,7 +227,7 @@ public TraversalControl visitGraphQLInputObjectField(GraphQLInputObjectField gra
 
                 Value<?> defaultValue = null;
                 if (graphQLInputObjectField.hasSetDefaultValue()) {
-                    defaultValue = ValuesResolver.valueToLiteral(graphQLInputObjectField.getDefaultValue(), graphQLInputObjectField.getDefaultValueState(), graphQLInputObjectField.getType());
+                    defaultValue = ValuesResolver.valueToLiteral(graphQLInputObjectField.getInputFieldDefaultValue(), graphQLInputObjectField.getDefaultValueState(), graphQLInputObjectField.getType());
                     defaultValue = replaceDefaultValue(defaultValue, defaultStringValueCounter, defaultIntValueCounter);
                 }
 

File: src/main/java/graphql/validation/ValidationUtil.java
Patch:
@@ -159,7 +159,7 @@ private boolean isValidLiteralValue(Value<?> value, GraphQLInputObjectType type,
     private Set<String> getMissingFields(GraphQLInputObjectType type, Map<String, ObjectField> objectFieldMap, GraphqlFieldVisibility fieldVisibility) {
         return fieldVisibility.getFieldDefinitions(type).stream()
                 .filter(field -> isNonNull(field.getType()))
-                .filter(value -> (value.getDefaultValue() == null) && !objectFieldMap.containsKey(value.getName()))
+                .filter(value -> (value.getInputFieldDefaultValue() == null) && !objectFieldMap.containsKey(value.getName()))
                 .map(GraphQLInputObjectField::getName)
                 .collect(ImmutableSet.toImmutableSet());
     }

File: src/main/java/graphql/validation/rules/ProvidedNonNullArguments.java
Patch:
@@ -38,7 +38,7 @@ public void checkField(Field field) {
         for (GraphQLArgument graphQLArgument : fieldDef.getArguments()) {
             Argument argument = argumentMap.get(graphQLArgument.getName());
             boolean nonNullType = isNonNull(graphQLArgument.getType());
-            boolean noDefaultValue = graphQLArgument.getDefaultValue() == null;
+            boolean noDefaultValue = graphQLArgument.getArgumentDefaultValue() == null;
             if (argument == null && nonNullType && noDefaultValue) {
                 String message = String.format("Missing field argument %s", graphQLArgument.getName());
                 addError(ValidationErrorType.MissingFieldArgument, field.getSourceLocation(), message);
@@ -64,7 +64,7 @@ public void checkDirective(Directive directive, List<Node> ancestors) {
         for (GraphQLArgument graphQLArgument : graphQLDirective.getArguments()) {
             Argument argument = argumentMap.get(graphQLArgument.getName());
             boolean nonNullType = isNonNull(graphQLArgument.getType());
-            boolean noDefaultValue = graphQLArgument.getDefaultValue() == null;
+            boolean noDefaultValue = graphQLArgument.getArgumentDefaultValue() == null;
             if (argument == null && nonNullType && noDefaultValue) {
                 String message = String.format("Missing directive argument %s", graphQLArgument.getName());
                 addError(ValidationErrorType.MissingDirectiveArgument, directive.getSourceLocation(), message);

File: src/test/groovy/readme/DirectivesExamples.java
Patch:
@@ -39,7 +39,7 @@ class AuthorisationDirective implements SchemaDirectiveWiring {
 
         @Override
         public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment<GraphQLFieldDefinition> environment) {
-            String targetAuthRole = (String) environment.getDirective().getArgument("role").getValue();
+            String targetAuthRole = (String) environment.getDirective().getArgument("role").getArgumentValue();
 
             //
             // build a data fetcher that first checks authorisation roles before then calling the original data fetcher

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -155,7 +155,7 @@ public static Object valueToInternalValue(Object value, ValueState valueState, G
             return new ValuesResolver().literalToInternalValue(fieldVisibility, type, (Value<?>) value, emptyMap(), null, ValueMode.COERCED, false);
         }
         if (valueState == ValueState.EXTERNAL_VALUE) {
-            return new ValuesResolver().externalValueToLiteral(fieldVisibility, value, (GraphQLInputType) type);
+            return new ValuesResolver().externalValueToInternalValue(fieldVisibility, "value", (GraphQLInputType) type, value, ValueMode.COERCED);
         }
         return Assert.assertShouldNeverHappen("unexpected value state " + valueState);
     }

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -164,10 +164,10 @@ public enum TypeKind {
             Object type = environment.getSource();
             if (type instanceof GraphQLArgument) {
                 GraphQLArgument inputField = (GraphQLArgument) type;
-                return inputField.hasSetDefaultValue() ? printDefaultValue(inputField.getDefaultValue(), inputField.getDefaultValueState(), inputField.getType()) : null;
+                return inputField.hasSetDefaultValue() ? printDefaultValue(inputField.getArgumentDefaultValue(), inputField.getDefaultValueState(), inputField.getType()) : null;
             } else if (type instanceof GraphQLInputObjectField) {
                 GraphQLInputObjectField inputField = (GraphQLInputObjectField) type;
-                return inputField.hasSetDefaultValue() ? printDefaultValue(inputField.getDefaultValue(), inputField.getDefaultValueState(), inputField.getType()) : null;
+                return inputField.hasSetDefaultValue() ? printDefaultValue(inputField.getInputFieldDefaultValue(), inputField.getDefaultValueState(), inputField.getType()) : null;
             }
             return null;
         });

File: src/main/java/graphql/introspection/IntrospectionWithDirectivesSupport.java
Patch:
@@ -195,7 +195,7 @@ private GraphQLObjectType addAppliedDirectives(GraphQLObjectType originalType, G
         DataFetcher<?> argValueDF = env -> {
             final GraphQLArgument argument = env.getSource();
             if (argument.hasSetValue()) {
-                Object value = argument.getValue();
+                Object value = argument.getArgumentValue();
                 return AstPrinter.printAst(ValuesResolver.valueToLiteral(value, argument.getValueState(), argument.getType()));
             } else {
                 return null;

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -83,7 +83,7 @@ public GraphQLInputType getType() {
         return replacedType != null ? replacedType : originalType;
     }
 
-    public Object getDefaultValue() {
+    public Object getInputFieldDefaultValue() {
         return defaultValue;
     }
 
@@ -241,7 +241,7 @@ public Builder() {
         public Builder(GraphQLInputObjectField existing) {
             this.name = existing.getName();
             this.description = existing.getDescription();
-            this.defaultValue = existing.getDefaultValue();
+            this.defaultValue = existing.getInputFieldDefaultValue();
             this.defaultValueState = existing.getDefaultValueState();
             this.type = existing.originalType;
             this.definition = existing.getDefinition();

File: src/main/java/graphql/schema/idl/FetchSchemaDirectiveWiring.java
Patch:
@@ -36,7 +36,7 @@ public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment<GraphQLFi
     private String atFetchFromSupport(String fieldName, List<GraphQLDirective> directives) {
         // @fetch(from : "name")
         Optional<GraphQLArgument> from = directiveWithArg(directives, FETCH, "from");
-        return from.map(arg -> (String) ValuesResolver.valueToInternalValue(arg.getValue(), arg.getValueState(), arg.getType())).orElse(fieldName);
+        return from.map(arg -> (String) ValuesResolver.valueToInternalValue(arg.getArgumentValue(), arg.getValueState(), arg.getType())).orElse(fieldName);
     }
 
 }

File: src/main/java/graphql/schema/idl/SchemaGeneratorHelper.java
Patch:
@@ -286,7 +286,7 @@ private GraphQLArgument buildAppliedDArgument(BuildContext buildCtx, Argument ar
         GraphQLInputType inputType = directiveDefArgument.getType();
         builder.type(inputType);
         // we know it is a literal because it was created by SchemaGenerator
-        Value defaultValue = (Value) directiveDefArgument.getDefaultValue();
+        Value defaultValue = (Value) directiveDefArgument.getArgumentDefaultValue();
         if (defaultValue != null) {
             builder.defaultValueLiteral(defaultValue);
         }
@@ -314,10 +314,10 @@ private List<GraphQLArgument> transferMissingArguments(List<GraphQLArgument> arg
                         .type(directiveDefArg.getType());
 
                 if (directiveDefArg.hasSetDefaultValue()) {
-                    missingArg.defaultValueLiteral((Value) directiveDefArg.getDefaultValue());
+                    missingArg.defaultValueLiteral((Value) directiveDefArg.getArgumentDefaultValue());
                 }
                 if (directiveDefArg.hasSetValue()) {
-                    missingArg.valueLiteral((Value) directiveDefArg.getValue());
+                    missingArg.valueLiteral((Value) directiveDefArg.getArgumentValue());
                 }
                 argumentsOut.add(missingArg.build());
             }

File: src/main/java/graphql/schema/validation/TypesImplementInterfaces.java
Patch:
@@ -149,8 +149,8 @@ private void checkFieldArgumentEquivalence(GraphQLImplementingType implementingT
                         same = false;
                     }
                     if (objectArg.hasSetDefaultValue() && interfaceArg.hasSetDefaultValue()) {
-                        Value<?> objectDefaultValue = ValuesResolver.valueToLiteral(objectArg.getDefaultValue(), objectArg.getDefaultValueState(), objectArg.getType());
-                        Value<?> interfaceDefaultValue = ValuesResolver.valueToLiteral(interfaceArg.getDefaultValue(), interfaceArg.getDefaultValueState(), interfaceArg.getType());
+                        Value<?> objectDefaultValue = ValuesResolver.valueToLiteral(objectArg.getArgumentDefaultValue(), objectArg.getDefaultValueState(), objectArg.getType());
+                        Value<?> interfaceDefaultValue = ValuesResolver.valueToLiteral(interfaceArg.getArgumentDefaultValue(), interfaceArg.getDefaultValueState(), interfaceArg.getType());
                         if (!Objects.equals(printAst(objectDefaultValue), printAst(interfaceDefaultValue))) {
                             same = false;
                         }

File: src/main/java/graphql/util/Anonymizer.java
Patch:
@@ -147,7 +147,7 @@ public TraversalControl visitGraphQLArgument(GraphQLArgument graphQLArgument, Tr
                 GraphQLArgument newElement = graphQLArgument.transform(builder -> {
                     builder.name(newName).description(null).definition(null);
                     if (graphQLArgument.hasSetDefaultValue()) {
-                        Value<?> defaultValueLiteral = ValuesResolver.valueToLiteral(graphQLArgument.getDefaultValue(), graphQLArgument.getDefaultValueState(), graphQLArgument.getType());
+                        Value<?> defaultValueLiteral = ValuesResolver.valueToLiteral(graphQLArgument.getArgumentDefaultValue(), graphQLArgument.getDefaultValueState(), graphQLArgument.getType());
                         builder.defaultValueLiteral(replaceDefaultValue(defaultValueLiteral, defaultStringValueCounter, defaultIntValueCounter));
                     }
                 });
@@ -227,7 +227,7 @@ public TraversalControl visitGraphQLInputObjectField(GraphQLInputObjectField gra
 
                 Value<?> defaultValue = null;
                 if (graphQLInputObjectField.hasSetDefaultValue()) {
-                    defaultValue = ValuesResolver.valueToLiteral(graphQLInputObjectField.getDefaultValue(), graphQLInputObjectField.getDefaultValueState(), graphQLInputObjectField.getType());
+                    defaultValue = ValuesResolver.valueToLiteral(graphQLInputObjectField.getInputFieldDefaultValue(), graphQLInputObjectField.getDefaultValueState(), graphQLInputObjectField.getType());
                     defaultValue = replaceDefaultValue(defaultValue, defaultStringValueCounter, defaultIntValueCounter);
                 }
 

File: src/main/java/graphql/validation/ValidationUtil.java
Patch:
@@ -159,7 +159,7 @@ private boolean isValidLiteralValue(Value<?> value, GraphQLInputObjectType type,
     private Set<String> getMissingFields(GraphQLInputObjectType type, Map<String, ObjectField> objectFieldMap, GraphqlFieldVisibility fieldVisibility) {
         return fieldVisibility.getFieldDefinitions(type).stream()
                 .filter(field -> isNonNull(field.getType()))
-                .filter(value -> (value.getDefaultValue() == null) && !objectFieldMap.containsKey(value.getName()))
+                .filter(value -> (value.getInputFieldDefaultValue() == null) && !objectFieldMap.containsKey(value.getName()))
                 .map(GraphQLInputObjectField::getName)
                 .collect(ImmutableSet.toImmutableSet());
     }

File: src/main/java/graphql/validation/rules/ProvidedNonNullArguments.java
Patch:
@@ -38,7 +38,7 @@ public void checkField(Field field) {
         for (GraphQLArgument graphQLArgument : fieldDef.getArguments()) {
             Argument argument = argumentMap.get(graphQLArgument.getName());
             boolean nonNullType = isNonNull(graphQLArgument.getType());
-            boolean noDefaultValue = graphQLArgument.getDefaultValue() == null;
+            boolean noDefaultValue = graphQLArgument.getArgumentDefaultValue() == null;
             if (argument == null && nonNullType && noDefaultValue) {
                 String message = String.format("Missing field argument %s", graphQLArgument.getName());
                 addError(ValidationErrorType.MissingFieldArgument, field.getSourceLocation(), message);
@@ -64,7 +64,7 @@ public void checkDirective(Directive directive, List<Node> ancestors) {
         for (GraphQLArgument graphQLArgument : graphQLDirective.getArguments()) {
             Argument argument = argumentMap.get(graphQLArgument.getName());
             boolean nonNullType = isNonNull(graphQLArgument.getType());
-            boolean noDefaultValue = graphQLArgument.getDefaultValue() == null;
+            boolean noDefaultValue = graphQLArgument.getArgumentDefaultValue() == null;
             if (argument == null && nonNullType && noDefaultValue) {
                 String message = String.format("Missing directive argument %s", graphQLArgument.getName());
                 addError(ValidationErrorType.MissingDirectiveArgument, directive.getSourceLocation(), message);

File: src/test/groovy/readme/DirectivesExamples.java
Patch:
@@ -39,7 +39,7 @@ class AuthorisationDirective implements SchemaDirectiveWiring {
 
         @Override
         public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment<GraphQLFieldDefinition> environment) {
-            String targetAuthRole = (String) environment.getDirective().getArgument("role").getValue();
+            String targetAuthRole = (String) environment.getDirective().getArgument("role").getArgumentValue();
 
             //
             // build a data fetcher that first checks authorisation roles before then calling the original data fetcher

File: src/main/java/graphql/normalized/NormalizedInputValue.java
Patch:
@@ -26,7 +26,7 @@ public String getType() {
     /**
      * Depending on the type it returns:
      * Scala or Enum: the value of the Scalar.
-     * InputObject: the value is a map of field-name => NormalizedInputValue
+     * InputObject: the value is a map of field-name to NormalizedInputValue
      *
      * @return
      */

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -505,7 +505,7 @@ private String description(Node<?> node) {
             return "";
         }
         String s;
-        boolean startNewLine = description.getContent().charAt(0) == '\n';
+        boolean startNewLine = description.getContent().length() > 0 && description.getContent().charAt(0) == '\n';
         if (description.isMultiLine()) {
             s = "\"\"\"" + (startNewLine ? "" : "\n") + description.getContent() + "\n\"\"\"\n";
         } else {

File: src/main/java/graphql/schema/FieldCoordinates.java
Patch:
@@ -33,6 +33,9 @@ public String getFieldName() {
         return fieldName;
     }
 
+    public boolean isSystemCoordinates() {
+        return systemCoordinates;
+    }
 
     /**
      * Checks the validity of the field coordinate names.  The validity checks vary by coordinate type.  Standard

File: src/main/java/graphql/schema/GraphQLSchema.java
Patch:
@@ -260,7 +260,7 @@ public GraphQLType getType(String typeName) {
      * Warning - your are inviting class cast errors if you the types are not what you expect.
      *
      * @param typeName the name of the type to retrieve
-     * @param <T> for two
+     * @param <T>      for two
      *
      * @return the type cast to the target type.
      */

File: src/main/java/graphql/analysis/NodeVisitorWithTypeTracking.java
Patch:
@@ -151,7 +151,7 @@ public TraversalControl visitField(Field field, TraverserContext<Node> context)
         QueryTraversalContext parentEnv = context.getVarFromParents(QueryTraversalContext.class);
 
         GraphQLFieldDefinition fieldDefinition = Introspection.getFieldDef(schema, (GraphQLCompositeType) unwrapAll(parentEnv.getOutputType()), field.getName());
-        boolean isTypeNameIntrospectionField = fieldDefinition == Introspection.TypeNameMetaFieldDef;
+        boolean isTypeNameIntrospectionField = fieldDefinition == schema.getIntrospectionTypenameFieldDefinition();
         GraphQLFieldsContainer fieldsContainer = !isTypeNameIntrospectionField ? (GraphQLFieldsContainer) unwrapAll(parentEnv.getOutputType()) : null;
         GraphQLCodeRegistry codeRegistry = schema.getCodeRegistry();
         Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDefinition.getArguments(), field.getArguments(), variables);

File: src/main/java/graphql/schema/SchemaUtil.java
Patch:
@@ -38,7 +38,7 @@ ImmutableMap<String, GraphQLNamedType> allTypes(final GraphQLSchema schema, fina
             roots.addAll(schema.getDirectives());
         }
 
-        roots.add(Introspection.__Schema);
+        roots.add(schema.getIntrospectionSchemaType());
 
         GraphQLTypeCollectingVisitor visitor = new GraphQLTypeCollectingVisitor();
         SchemaTraverser traverser;

File: src/main/java/graphql/execution/instrumentation/SimpleInstrumentation.java
Patch:
@@ -26,9 +26,6 @@ public class SimpleInstrumentation implements Instrumentation {
      */
     public static final SimpleInstrumentation INSTANCE = new SimpleInstrumentation();
 
-    public SimpleInstrumentation() {
-    }
-
     @Override
     public InstrumentationContext<ExecutionResult> beginExecution(InstrumentationExecutionParameters parameters) {
         return SimpleInstrumentationContext.noOp();

File: src/main/java/graphql/execution/instrumentation/SimpleInstrumentation.java
Patch:
@@ -26,9 +26,6 @@ public class SimpleInstrumentation implements Instrumentation {
      */
     public static final SimpleInstrumentation INSTANCE = new SimpleInstrumentation();
 
-    public SimpleInstrumentation() {
-    }
-
     @Override
     public InstrumentationContext<ExecutionResult> beginExecution(InstrumentationExecutionParameters parameters) {
         return SimpleInstrumentationContext.noOp();

File: src/main/java/graphql/introspection/IntrospectionResultToSchema.java
Patch:
@@ -34,6 +34,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 
 import static graphql.Assert.assertNotEmpty;
 import static graphql.Assert.assertNotNull;
@@ -144,6 +145,7 @@ private DirectiveDefinition createDirective(Map<String, Object> input) {
         List<Map<String, Object>> args = (List<Map<String, Object>>) input.get("args");
         List<InputValueDefinition> inputValueDefinitions = createInputValueDefinitions(args);
         directiveDefBuilder.inputValueDefinitions(inputValueDefinitions);
+        Optional.ofNullable((Boolean) input.get("isRepeatable")).ifPresent(value -> directiveDefBuilder.repeatable(value));
 
         return directiveDefBuilder.build();
     }

File: src/main/java/graphql/schema/validation/TypeAndFieldRule.java
Patch:
@@ -1,6 +1,5 @@
 package graphql.schema.validation;
 
-import graphql.language.TypeName;
 import graphql.schema.GraphQLArgument;
 import graphql.schema.GraphQLEnumType;
 import graphql.schema.GraphQLEnumValueDefinition;
@@ -130,12 +129,12 @@ private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector
             GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);
             if (!(graphQLNamedType instanceof GraphQLObjectType)) {
                 SchemaValidationError validationError =
-                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format("The member types of a Union type must all be Object base types. member type \"%s\" in Union \"%s\" is invalid.", ((TypeName) memberType).getName(), type.getName()));
+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format("The member types of a Union type must all be Object base types. member type \"%s\" in Union \"%s\" is invalid.", memberType.getName(), type.getName()));
                 errorCollector.addError(validationError);
             }
             if (typeNames.contains(typeName)) {
                 SchemaValidationError validationError =
-                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format("The member types of a Union type must be unique. member type \"%s\" in Union \"%s\" is not unique.", ((TypeName) memberType).getName(), type.getName()));
+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format("The member types of a Union type must be unique. member type \"%s\" in Union \"%s\" is not unique.", memberType.getName(), type.getName()));
                 errorCollector.addError(validationError);
             }
             typeNames.add(typeName);

File: src/main/java/graphql/schema/DataFetchingFieldSelectionSetImpl.java
Patch:
@@ -84,7 +84,7 @@ public static DataFetchingFieldSelectionSet newCollector(GraphQLOutputType field
 
     private final Supplier<NormalizedField> normalizedFieldSupplier;
 
-    private boolean computedValues;
+    private volatile boolean computedValues;
     private List<SelectedField> immediateFields;
     private Map<String, List<SelectedField>> normalisedSelectionSetFields;
     private Set<String> flattenedFieldsForGlobSearching;

File: src/main/java/graphql/execution/ExecutionContext.java
Patch:
@@ -54,6 +54,7 @@ public class ExecutionContext {
     private final Locale locale;
     private final ValueUnboxer valueUnboxer;
     private final ExecutionInput executionInput;
+    private final Supplier<NormalizedQueryTree> queryTree;
 
     ExecutionContext(ExecutionContextBuilder builder) {
         this.graphQLSchema = builder.graphQLSchema;
@@ -76,6 +77,7 @@ public class ExecutionContext {
         this.errors.addAll(builder.errors);
         this.localContext = builder.localContext;
         this.executionInput = builder.executionInput;
+        queryTree = FpKit.interThreadMemoize(() -> NormalizedQueryTreeFactory.createNormalizedQuery(graphQLSchema, operationDefinition, fragmentsByName, variables));
     }
 
 
@@ -204,7 +206,7 @@ public ExecutionStrategy getSubscriptionStrategy() {
     }
 
     public Supplier<NormalizedQueryTree> getNormalizedQueryTree() {
-        return FpKit.interThreadMemoize(() -> NormalizedQueryTreeFactory.createNormalizedQuery(graphQLSchema, operationDefinition, fragmentsByName, variables));
+        return queryTree;
     }
 
     /**

File: src/main/java/graphql/schema/validation/TypeAndFieldRule.java
Patch:
@@ -1,6 +1,5 @@
 package graphql.schema.validation;
 
-import graphql.language.TypeName;
 import graphql.schema.GraphQLArgument;
 import graphql.schema.GraphQLEnumType;
 import graphql.schema.GraphQLEnumValueDefinition;
@@ -130,12 +129,12 @@ private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector
             GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);
             if (!(graphQLNamedType instanceof GraphQLObjectType)) {
                 SchemaValidationError validationError =
-                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format("The member types of a Union type must all be Object base types. member type \"%s\" in Union \"%s\" is invalid.", ((TypeName) memberType).getName(), type.getName()));
+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format("The member types of a Union type must all be Object base types. member type \"%s\" in Union \"%s\" is invalid.", memberType.getName(), type.getName()));
                 errorCollector.addError(validationError);
             }
             if (typeNames.contains(typeName)) {
                 SchemaValidationError validationError =
-                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format("The member types of a Union type must be unique. member type \"%s\" in Union \"%s\" is not unique.", ((TypeName) memberType).getName(), type.getName()));
+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format("The member types of a Union type must be unique. member type \"%s\" in Union \"%s\" is not unique.", memberType.getName(), type.getName()));
                 errorCollector.addError(validationError);
             }
             typeNames.add(typeName);

File: src/main/java/graphql/introspection/IntrospectionResultToSchema.java
Patch:
@@ -34,6 +34,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 
 import static graphql.Assert.assertNotEmpty;
 import static graphql.Assert.assertNotNull;
@@ -144,6 +145,7 @@ private DirectiveDefinition createDirective(Map<String, Object> input) {
         List<Map<String, Object>> args = (List<Map<String, Object>>) input.get("args");
         List<InputValueDefinition> inputValueDefinitions = createInputValueDefinitions(args);
         directiveDefBuilder.inputValueDefinitions(inputValueDefinitions);
+        Optional.ofNullable((Boolean) input.get("isRepeatable")).ifPresent(value -> directiveDefBuilder.repeatable(value));
 
         return directiveDefBuilder.build();
     }

File: src/main/java/graphql/Directives.java
Patch:
@@ -62,6 +62,7 @@ public class Directives {
                                 .build())
                 .build();
     }
+
     public static final GraphQLDirective IncludeDirective = GraphQLDirective.newDirective()
             .name("include")
             .description("Directs the executor to include this field or fragment only when the `if` argument is true")

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -103,7 +103,8 @@ private NodePrinter<DirectiveDefinition> directiveDefinition() {
             out.printf("%s", description(node));
             String arguments = wrap("(", join(node.getInputValueDefinitions(), argSep), ")");
             String locations = join(node.getDirectiveLocations(), " | ");
-            out.printf("directive @%s%s on %s", node.getName(), arguments, locations);
+            String repeatable = node.isRepeatable() ? "repeatable " : "";
+            out.printf("directive @%s%s %son %s", node.getName(), arguments, repeatable, locations);
         };
     }
 

File: src/main/java/graphql/language/Directive.java
Patch:
@@ -65,7 +65,7 @@ public Map<String, Argument> getArgumentsByName() {
     }
 
     public Argument getArgument(String argumentName) {
-        return getArgumentByName(arguments, argumentName).orElse(null);
+        return NodeUtil.getArgumentByName(arguments, argumentName);
     }
 
     @Override

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -625,6 +625,9 @@ protected DirectiveDefinition createDirectiveDefinition(GraphqlParser.DirectiveD
         def.name(ctx.name().getText());
         addCommonData(def, ctx);
         def.description(newDescription(ctx.description()));
+
+        def.repeatable(ctx.REPEATABLE() != null);
+
         GraphqlParser.DirectiveLocationsContext directiveLocationsContext = ctx.directiveLocations();
         List<DirectiveLocation> directiveLocations = new ArrayList<>();
         while (directiveLocationsContext != null) {

File: src/main/java/graphql/schema/diff/SchemaDiff.java
Patch:
@@ -271,8 +271,8 @@ private void checkType(DiffCtx ctx, Type oldType, Type newType) {
         ctx.exitType();
     }
 
-    private boolean isDeprecated(DirectivesContainer node) {
-        return node.getDirective("deprecated") != null;
+    private boolean isDeprecated(DirectivesContainer<?> node) {
+        return node.hasDirective("deprecated");
     }
 
     private boolean isReservedType(String typeName) {

File: src/main/java/graphql/schema/idl/SchemaTypeDirectivesChecker.java
Patch:
@@ -188,7 +188,7 @@ private void commonCheck(Collection<DirectiveDefinition> directiveDefinitions, L
             directiveDefinition.getInputValueDefinitions().forEach(inputValueDefinition -> {
                 assertTypeName(inputValueDefinition, errors);
                 assertExistAndIsInputType(inputValueDefinition, errors);
-                if (inputValueDefinition.getDirective(directiveDefinition.getName()) != null) {
+                if (inputValueDefinition.hasDirective(directiveDefinition.getName())) {
                     errors.add(new DirectiveIllegalReferenceError(directiveDefinition, inputValueDefinition));
                 }
             });

File: src/main/java/graphql/validation/TraversalContext.java
Patch:
@@ -2,6 +2,7 @@
 
 
 import graphql.Assert;
+import graphql.DirectivesUtil;
 import graphql.Internal;
 import graphql.execution.TypeFromAST;
 import graphql.language.Argument;
@@ -107,7 +108,7 @@ private void enterImpl(Field field) {
     }
 
     private void enterImpl(Directive directive) {
-        this.directive = schema.getDirective(directive.getName());
+        this.directive = DirectivesUtil.getFirstDirective(directive.getName(), schema.getAllDirectivesByName());
     }
 
     private void enterImpl(OperationDefinition operationDefinition) {

File: src/main/java/graphql/validation/rules/KnownDirectives.java
Patch:
@@ -31,7 +31,7 @@ public KnownDirectives(ValidationContext validationContext, ValidationErrorColle
 
     @Override
     public void checkDirective(Directive directive, List<Node> ancestors) {
-        GraphQLDirective graphQLDirective = getValidationContext().getSchema().getDirective(directive.getName());
+        GraphQLDirective graphQLDirective = getValidationContext().getSchema().getFirstDirective(directive.getName());
         if (graphQLDirective == null) {
             String message = String.format("Unknown directive %s", directive.getName());
             addError(ValidationErrorType.UnknownDirective, directive.getSourceLocation(), message);

File: src/main/java/graphql/schema/idl/SchemaDirectiveWiringEnvironment.java
Patch:
@@ -71,7 +71,7 @@ public interface SchemaDirectiveWiringEnvironment<T extends GraphQLDirectiveCont
      *
      * @return hierarchical graphql language node information
      */
-    NodeParentTree<NamedNode> getNodeParentTree();
+    NodeParentTree<NamedNode<?>> getNodeParentTree();
 
     /**
      * The type hierarchy depends on the element in question.  For example {@link graphql.schema.GraphQLObjectType} elements
@@ -114,7 +114,7 @@ public interface SchemaDirectiveWiringEnvironment<T extends GraphQLDirectiveCont
      *
      * @throws graphql.AssertException if there is not field in context at the time of the directive wiring callback
      */
-    DataFetcher getFieldDataFetcher();
+    DataFetcher<?> getFieldDataFetcher();
 
     /**
      * This is a shortcut method to set a new data fetcher in the underlying {@link graphql.schema.GraphQLCodeRegistry}
@@ -129,6 +129,6 @@ public interface SchemaDirectiveWiringEnvironment<T extends GraphQLDirectiveCont
      *
      * @throws graphql.AssertException if there is not field in context at the time of the directive wiring callback
      */
-    GraphQLFieldDefinition setFieldDataFetcher(DataFetcher newDataFetcher);
+    GraphQLFieldDefinition setFieldDataFetcher(DataFetcher<?> newDataFetcher);
 
 }

File: src/main/java/graphql/schema/validation/SchemaValidationRule.java
Patch:
@@ -2,6 +2,7 @@
 
 import graphql.Internal;
 import graphql.schema.GraphQLFieldDefinition;
+import graphql.schema.GraphQLSchema;
 import graphql.schema.GraphQLType;
 
 @Internal
@@ -10,4 +11,6 @@ public interface SchemaValidationRule {
     void check(GraphQLFieldDefinition fieldDef, SchemaValidationErrorCollector validationErrorCollector);
 
     void check(GraphQLType type, SchemaValidationErrorCollector validationErrorCollector);
+
+    void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector);
 }

File: src/main/java/graphql/Directives.java
Patch:
@@ -3,7 +3,6 @@
 
 import graphql.language.Description;
 import graphql.language.DirectiveDefinition;
-import graphql.language.InputValueDefinition;
 import graphql.language.StringValue;
 import graphql.schema.GraphQLDirective;
 
@@ -16,7 +15,7 @@
 import static graphql.introspection.Introspection.DirectiveLocation.INLINE_FRAGMENT;
 import static graphql.introspection.Introspection.DirectiveLocation.SCALAR;
 import static graphql.language.DirectiveLocation.newDirectiveLocation;
-import static graphql.language.InputValueDefinition.*;
+import static graphql.language.InputValueDefinition.newInputValueDefinition;
 import static graphql.language.NonNullType.newNonNullType;
 import static graphql.language.TypeName.newTypeName;
 import static graphql.schema.GraphQLArgument.newArgument;

File: src/main/java/graphql/GraphqlErrorHelper.java
Patch:
@@ -7,7 +7,7 @@
 import java.util.Map;
 import java.util.Objects;
 
-import static java.util.stream.Collectors.toList;
+import static graphql.collect.ImmutableKit.map;
 
 /**
  * This little helper allows GraphQlErrors to implement
@@ -51,7 +51,7 @@ public static Map<String, Object> toSpecification(GraphQLError error) {
     }
 
     public static Object locations(List<SourceLocation> locations) {
-        return locations.stream().map(GraphqlErrorHelper::location).collect(toList());
+        return map(locations, GraphqlErrorHelper::location);
     }
 
     public static Object location(SourceLocation location) {

File: src/main/java/graphql/TypeResolutionEnvironment.java
Patch:
@@ -1,5 +1,6 @@
 package graphql;
 
+import graphql.collect.ImmutableMapWithNullValues;
 import graphql.execution.MergedField;
 import graphql.schema.GraphQLSchema;
 import graphql.schema.GraphQLType;
@@ -16,15 +17,15 @@
 public class TypeResolutionEnvironment {
 
     private final Object object;
-    private final Map<String, Object> arguments;
+    private final ImmutableMapWithNullValues<String, Object> arguments;
     private final MergedField field;
     private final GraphQLType fieldType;
     private final GraphQLSchema schema;
     private final Object context;
 
     public TypeResolutionEnvironment(Object object, Map<String, Object> arguments, MergedField field, GraphQLType fieldType, GraphQLSchema schema, final Object context) {
         this.object = object;
-        this.arguments = arguments;
+        this.arguments = ImmutableMapWithNullValues.copyOf(arguments);
         this.field = field;
         this.fieldType = fieldType;
         this.schema = schema;

File: src/main/java/graphql/execution/AsyncSerialExecutionStrategy.java
Patch:
@@ -1,12 +1,12 @@
 package graphql.execution;
 
+import com.google.common.collect.ImmutableList;
 import graphql.ExecutionResult;
 import graphql.PublicApi;
 import graphql.execution.instrumentation.Instrumentation;
 import graphql.execution.instrumentation.InstrumentationContext;
 import graphql.execution.instrumentation.parameters.InstrumentationExecutionStrategyParameters;
 
-import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
 
@@ -33,7 +33,7 @@ public CompletableFuture<ExecutionResult> execute(ExecutionContext executionCont
         InstrumentationExecutionStrategyParameters instrumentationParameters = new InstrumentationExecutionStrategyParameters(executionContext, parameters);
         InstrumentationContext<ExecutionResult> executionStrategyCtx = instrumentation.beginExecutionStrategy(instrumentationParameters);
         MergedSelectionSet fields = parameters.getFields();
-        List<String> fieldNames = new ArrayList<>(fields.keySet());
+        ImmutableList<String> fieldNames = ImmutableList.copyOf(fields.keySet());
 
         CompletableFuture<List<ExecutionResult>> resultsFuture = Async.eachSequentially(fieldNames, (fieldName, index, prevResults) -> {
             MergedField currentField = fields.getSubField(fieldName);

File: src/main/java/graphql/execution/DataFetcherResult.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.execution;
 
+import com.google.common.collect.ImmutableList;
 import graphql.GraphQLError;
 import graphql.Internal;
 import graphql.PublicApi;
@@ -10,7 +11,6 @@
 import java.util.function.Consumer;
 
 import static graphql.Assert.assertNotNull;
-import static java.util.Collections.unmodifiableList;
 
 
 /**
@@ -48,7 +48,7 @@ public DataFetcherResult(T data, List<GraphQLError> errors) {
 
     private DataFetcherResult(T data, List<GraphQLError> errors, Object localContext, boolean mapRelativeErrors) {
         this.data = data;
-        this.errors = unmodifiableList(assertNotNull(errors));
+        this.errors = ImmutableList.copyOf(assertNotNull(errors));
         this.localContext = localContext;
         this.mapRelativeErrors = mapRelativeErrors;
     }

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.execution;
 
+import com.google.common.collect.ImmutableList;
 import graphql.ExecutionResult;
 import graphql.ExecutionResultImpl;
 import graphql.GraphQLError;
@@ -756,7 +757,7 @@ protected void assertNonNullFieldPrecondition(NonNullableFieldWasNullException e
 
     protected ExecutionResult handleNonNullException(ExecutionContext executionContext, CompletableFuture<ExecutionResult> result, Throwable e) {
         ExecutionResult executionResult = null;
-        List<GraphQLError> errors = new ArrayList<>(executionContext.getErrors());
+        List<GraphQLError> errors = ImmutableList.copyOf(executionContext.getErrors());
         Throwable underlyingException = e;
         if (e instanceof CompletionException) {
             underlyingException = e.getCause();

File: src/main/java/graphql/execution/MergedField.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.execution;
 
+import com.google.common.collect.ImmutableList;
 import graphql.PublicApi;
 import graphql.language.Argument;
 import graphql.language.Field;
@@ -10,7 +11,6 @@
 import java.util.function.Consumer;
 
 import static graphql.Assert.assertNotEmpty;
-import static java.util.Collections.unmodifiableList;
 
 /**
  * This represent all Fields in a query which overlap and are merged into one.
@@ -60,14 +60,14 @@
 @PublicApi
 public class MergedField {
 
-    private final List<Field> fields;
+    private final ImmutableList<Field> fields;
     private final Field singleField;
     private final String name;
     private final String resultKey;
 
     private MergedField(List<Field> fields) {
         assertNotEmpty(fields);
-        this.fields = unmodifiableList(fields);
+        this.fields = ImmutableList.copyOf(fields);
         this.singleField = fields.get(0);
         this.name = singleField.getName();
         this.resultKey = singleField.getAlias() != null ? singleField.getAlias() : name;

File: src/main/java/graphql/execution/MergedSelectionSet.java
Patch:
@@ -1,9 +1,9 @@
 package graphql.execution;
 
+import com.google.common.collect.ImmutableList;
 import graphql.Assert;
 import graphql.PublicApi;
 
-import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -24,7 +24,7 @@ public Map<String, MergedField> getSubFields() {
     }
 
     public List<MergedField> getSubFieldsList() {
-        return new ArrayList<>(subFields.values());
+        return ImmutableList.copyOf(subFields.values());
     }
 
     public int size() {
@@ -40,7 +40,7 @@ public MergedField getSubField(String key) {
     }
 
     public List<String> getKeys() {
-        return new ArrayList<>(keySet());
+        return ImmutableList.copyOf(keySet());
     }
 
     public boolean isEmpty() {

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -28,9 +28,9 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.stream.Collectors;
 
 import static graphql.Assert.assertShouldNeverHappen;
+import static graphql.collect.ImmutableKit.map;
 import static graphql.schema.GraphQLTypeUtil.isList;
 import static graphql.schema.GraphQLTypeUtil.isNonNull;
 import static graphql.schema.GraphQLTypeUtil.unwrapOne;
@@ -48,7 +48,6 @@ public class ValuesResolver {
      * @param schema              the schema
      * @param variableDefinitions the variable definitions
      * @param variableValues      the supplied variables
-     *
      * @return coerced variable values as a map
      */
     public Map<String, Object> coerceVariableValues(GraphQLSchema schema, List<VariableDefinition> variableDefinitions, Map<String, Object> variableValues) {
@@ -193,7 +192,7 @@ private Object coerceValue(GraphqlFieldVisibility fieldVisibility, VariableDefin
     private Object coerceValueForInputObjectType(GraphqlFieldVisibility fieldVisibility, VariableDefinition variableDefinition, GraphQLInputObjectType inputObjectType, Map<String, Object> input) {
         Map<String, Object> result = new LinkedHashMap<>();
         List<GraphQLInputObjectField> fields = fieldVisibility.getFieldDefinitions(inputObjectType);
-        List<String> fieldNames = fields.stream().map(GraphQLInputObjectField::getName).collect(Collectors.toList());
+        List<String> fieldNames = map(fields, GraphQLInputObjectField::getName);
         for (String inputFieldName : input.keySet()) {
             if (!fieldNames.contains(inputFieldName)) {
                 throw new InputMapDefinesTooManyFieldsException(inputObjectType, inputFieldName);

File: src/main/java/graphql/execution/directives/DirectivesResolver.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.execution.directives;
 
+import com.google.common.collect.ImmutableMap;
 import graphql.Internal;
 import graphql.execution.ValuesResolver;
 import graphql.language.Directive;
@@ -33,7 +34,7 @@ public Map<String, GraphQLDirective> resolveDirectives(List<Directive> directive
                 directiveMap.put(newDirective.getName(), newDirective);
             }
         });
-        return directiveMap;
+        return ImmutableMap.copyOf(directiveMap);
     }
 
     private void buildArguments(GraphQLDirective.Builder directiveBuilder, GraphQLCodeRegistry codeRegistry, GraphQLDirective protoType, Directive fieldDirective, Map<String, Object> variables) {

File: src/main/java/graphql/execution/instrumentation/fieldvalidation/FieldValidationSupport.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.execution.instrumentation.fieldvalidation;
 
+import com.google.common.collect.ImmutableList;
 import graphql.ErrorType;
 import graphql.GraphQLError;
 import graphql.Internal;
@@ -20,7 +21,6 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.stream.Collectors;
 
 @Internal
 class FieldValidationSupport {
@@ -135,12 +135,12 @@ public FieldAndArguments getParentFieldAndArguments() {
     private static class FieldValidationEnvironmentImpl implements FieldValidationEnvironment {
         private final ExecutionContext executionContext;
         private final Map<ResultPath, List<FieldAndArguments>> fieldArgumentsMap;
-        private final List<FieldAndArguments> fieldArguments;
+        private final ImmutableList<FieldAndArguments> fieldArguments;
 
         FieldValidationEnvironmentImpl(ExecutionContext executionContext, Map<ResultPath, List<FieldAndArguments>> fieldArgumentsMap) {
             this.executionContext = executionContext;
             this.fieldArgumentsMap = fieldArgumentsMap;
-            this.fieldArguments = fieldArgumentsMap.values().stream().flatMap(List::stream).collect(Collectors.toList());
+            this.fieldArguments = fieldArgumentsMap.values().stream().flatMap(List::stream).collect(ImmutableList.toImmutableList());
         }
 
 

File: src/main/java/graphql/execution/instrumentation/fieldvalidation/SimpleFieldValidation.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.execution.instrumentation.fieldvalidation;
 
+import com.google.common.collect.ImmutableList;
 import graphql.GraphQLError;
 import graphql.PublicApi;
 import graphql.execution.ResultPath;
@@ -50,6 +51,6 @@ public List<GraphQLError> validateFields(FieldValidationEnvironment validationEn
                 }
             }
         }
-        return errors;
+        return ImmutableList.copyOf(errors);
     }
 }

File: src/main/java/graphql/execution/instrumentation/tracing/TracingSupport.java
Patch:
@@ -1,13 +1,13 @@
 package graphql.execution.instrumentation.tracing;
 
+import com.google.common.collect.ImmutableList;
 import graphql.PublicApi;
 import graphql.execution.ExecutionStepInfo;
 import graphql.execution.instrumentation.InstrumentationState;
 import graphql.schema.DataFetchingEnvironment;
 
 import java.time.Instant;
 import java.time.format.DateTimeFormatter;
-import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -145,7 +145,7 @@ private Object copyMap(Map<String, Object> map) {
 
     private Map<String, Object> executionData() {
         Map<String, Object> map = new LinkedHashMap<>();
-        List<Map<String, Object>> list = new ArrayList<>(fieldData);
+        List<Map<String, Object>> list = ImmutableList.copyOf(fieldData);
         map.put("resolvers", list);
         return map;
     }

File: src/main/java/graphql/execution/nextgen/BatchedExecutionStrategy.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.execution.nextgen;
 
+import com.google.common.collect.ImmutableList;
 import graphql.ExecutionResult;
 import graphql.Internal;
 import graphql.execution.Async;
@@ -25,9 +26,9 @@
 
 import static graphql.Assert.assertNotEmpty;
 import static graphql.Assert.assertTrue;
+import static graphql.collect.ImmutableKit.map;
 import static graphql.execution.nextgen.result.ResultNodeAdapter.RESULT_NODE_ADAPTER;
 import static graphql.util.FpKit.flatList;
-import static graphql.util.FpKit.map;
 import static graphql.util.FpKit.mapEntries;
 import static graphql.util.FpKit.transposeMatrix;
 import static java.util.concurrent.CompletableFuture.completedFuture;
@@ -84,7 +85,7 @@ private CompletableFuture<NodeMultiZipper<ExecutionResultNode>> resolveNodes(Exe
     }
 
     private List<NodeMultiZipper<ExecutionResultNode>> groupNodesIntoBatches(NodeMultiZipper<ExecutionResultNode> unresolvedZipper) {
-        Map<MergedField, List<NodeZipper<ExecutionResultNode>>> zipperBySubSelection = FpKit.groupingBy(unresolvedZipper.getZippers(),
+        Map<MergedField, ImmutableList<NodeZipper<ExecutionResultNode>>> zipperBySubSelection = FpKit.groupingBy(unresolvedZipper.getZippers(),
                 (executionResultZipper -> executionResultZipper.getCurNode().getMergedField()));
         return mapEntries(zipperBySubSelection, (key, value) -> new NodeMultiZipper<ExecutionResultNode>(unresolvedZipper.getCommonRoot(), value, RESULT_NODE_ADAPTER));
     }

File: src/main/java/graphql/execution/nextgen/DefaultExecutionStrategy.java
Patch:
@@ -15,9 +15,9 @@
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
 
+import static graphql.collect.ImmutableKit.map;
 import static graphql.execution.Async.each;
 import static graphql.execution.Async.mapCompose;
-import static graphql.util.FpKit.map;
 
 @Internal
 public class DefaultExecutionStrategy implements ExecutionStrategy {

File: src/main/java/graphql/execution/nextgen/ExecutionStrategyUtil.java
Patch:
@@ -15,11 +15,11 @@
 import graphql.execution.nextgen.result.ResolvedValue;
 import graphql.schema.GraphQLObjectType;
 import graphql.schema.GraphQLOutputType;
-import graphql.util.FpKit;
 
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
 
+import static graphql.collect.ImmutableKit.map;
 import static graphql.execution.FieldCollectorParameters.newParameters;
 
 @Internal
@@ -39,7 +39,7 @@ public List<CompletableFuture<ExecutionResultNode>> fetchSubSelection(ExecutionC
 
     private List<CompletableFuture<FetchedValueAnalysis>> fetchAndAnalyze(ExecutionContext context, FieldSubSelection fieldSubSelection) {
 
-        return FpKit.map(fieldSubSelection.getMergedSelectionSet().getSubFieldsList(),
+        return map(fieldSubSelection.getMergedSelectionSet().getSubFieldsList(),
                 mergedField -> fetchAndAnalyzeField(context, fieldSubSelection.getSource(), fieldSubSelection.getLocalContext(), mergedField, fieldSubSelection.getExecutionStepInfo()));
 
     }
@@ -58,7 +58,7 @@ private List<CompletableFuture<ExecutionResultNode>> fetchedValueAnalysisToNodes
     }
 
     public List<ExecutionResultNode> fetchedValueAnalysisToNodes(List<FetchedValueAnalysis> fetchedValueAnalysisList) {
-        return FpKit.map(fetchedValueAnalysisList, fetchedValueAnalysis -> resultNodesCreator.createResultNode(fetchedValueAnalysis));
+        return map(fetchedValueAnalysisList, fetchedValueAnalysis -> resultNodesCreator.createResultNode(fetchedValueAnalysis));
     }
 
 

File: src/main/java/graphql/execution/nextgen/result/ResultNodesUtil.java
Patch:
@@ -22,8 +22,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
-import java.util.stream.Collectors;
 
+import static graphql.collect.ImmutableKit.map;
 import static graphql.execution.nextgen.result.ResultNodeAdapter.RESULT_NODE_ADAPTER;
 import static java.util.Collections.emptyList;
 import static java.util.Collections.singleton;
@@ -122,7 +122,7 @@ public static Optional<NonNullableFieldWasNullException> getFirstNonNullableExce
     }
 
     public static NonNullableFieldWasNullException newNullableException(ExecutionStepInfo executionStepInfo, List<NamedResultNode> children) {
-        return newNullableException(executionStepInfo, children.stream().map(NamedResultNode::getNode).collect(Collectors.toList()));
+        return newNullableException(executionStepInfo, map(children, NamedResultNode::getNode));
     }
 
     public static Map<String, ExecutionResultNode> namedNodesToMap(List<NamedResultNode> namedResultNodes) {

File: src/main/java/graphql/language/AstSignature.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.language;
 
+import com.google.common.collect.ImmutableList;
 import graphql.PublicApi;
 import graphql.util.TraversalControl;
 import graphql.util.TraverserContext;
@@ -11,7 +12,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.stream.Collectors;
 
 import static graphql.util.TreeTransformerUtil.changeNode;
 
@@ -126,7 +126,7 @@ public TraversalControl visitDocument(Document node, TraverserContext<Node> cont
                             return d instanceof FragmentDefinition;
                             // SDL in a query makes no sense - its gone should it be present
                         })
-                        .collect(Collectors.toList());
+                        .collect(ImmutableList.toImmutableList());
 
                 Document changedNode = node.transform(builder -> {
                     builder.definitions(wantedDefinitions);

File: src/main/java/graphql/language/NodeChildrenContainer.java
Patch:
@@ -9,6 +9,7 @@
 import java.util.function.Consumer;
 
 import static graphql.Assert.assertNotNull;
+import static graphql.collect.ImmutableKit.emptyList;
 
 /**
  * Container of children of a {@link Node}.
@@ -23,11 +24,11 @@ private NodeChildrenContainer(Map<String, List<Node>> children) {
     }
 
     public <T extends Node> List<T> getChildren(String key) {
-        return (List<T>) children.getOrDefault(key, new ArrayList<>());
+        return (List<T>) children.getOrDefault(key, emptyList());
     }
 
     public <T extends Node> T getChildOrNull(String key) {
-        List<? extends Node> result = children.getOrDefault(key, new ArrayList<>());
+        List<? extends Node> result = children.getOrDefault(key, emptyList());
         if (result.size() > 1) {
             throw new IllegalStateException("children " + key + " is not a single value");
         }

File: src/main/java/graphql/language/NodeParentTree.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.language;
 
+import com.google.common.collect.ImmutableList;
 import graphql.Internal;
 import graphql.PublicApi;
 
@@ -8,7 +9,6 @@
 import java.util.Deque;
 import java.util.List;
 import java.util.Optional;
-import java.util.stream.Collectors;
 
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertTrue;
@@ -45,7 +45,7 @@ private List<String> mkPath(Deque<T> copy) {
         return copy.stream()
                 .filter(node1 -> node1 instanceof NamedNode)
                 .map(node1 -> ((NamedNode) node1).getName())
-                .collect(Collectors.toList());
+                .collect(ImmutableList.toImmutableList());
     }
 
 

File: src/main/java/graphql/language/ObjectTypeExtensionDefinition.java
Patch:
@@ -11,7 +11,8 @@
 import java.util.function.Consumer;
 
 import static graphql.Assert.assertNotNull;
-import static java.util.Collections.emptyMap;
+import static graphql.collect.ImmutableKit.emptyList;
+import static graphql.collect.ImmutableKit.emptyMap;
 
 @PublicApi
 public class ObjectTypeExtensionDefinition extends ObjectTypeDefinition {
@@ -36,7 +37,7 @@ protected ObjectTypeExtensionDefinition(String name,
      * @param name of the object type extension
      */
     public ObjectTypeExtensionDefinition(String name) {
-        this(name, new ArrayList<>(), new ArrayList<>(), new ArrayList<>(), null, null, new ArrayList<>(), IgnoredChars.EMPTY, emptyMap());
+        this(name, emptyList(), emptyList(), emptyList(), null, null, emptyList(), IgnoredChars.EMPTY, emptyMap());
     }
 
     @Override

File: src/main/java/graphql/relay/DefaultConnection.java
Patch:
@@ -1,20 +1,20 @@
 package graphql.relay;
 
+import com.google.common.collect.ImmutableList;
 import graphql.PublicApi;
 
 import java.util.Collections;
 import java.util.List;
 
 import static graphql.Assert.assertNotNull;
-import static java.util.Collections.unmodifiableList;
 
 /**
  * A default implementation of {@link graphql.relay.Connection}
  */
 @PublicApi
 public class DefaultConnection<T> implements Connection<T> {
 
-    private final List<Edge<T>> edges;
+    private final ImmutableList<Edge<T>> edges;
     private final PageInfo pageInfo;
 
     /**
@@ -26,7 +26,7 @@ public class DefaultConnection<T> implements Connection<T> {
      * @throws IllegalArgumentException if edges or page info is null. use {@link Collections#emptyList()} for empty edges.
      */
     public DefaultConnection(List<Edge<T>> edges, PageInfo pageInfo) {
-        this.edges = unmodifiableList(assertNotNull(edges, () -> "edges cannot be null"));
+        this.edges = ImmutableList.copyOf(assertNotNull(edges, () -> "edges cannot be null"));
         this.pageInfo = assertNotNull(pageInfo, () -> "page info cannot be null");
     }
 

File: src/main/java/graphql/schema/DataFetchingFieldSelectionSetImpl.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.schema;
 
+import com.google.common.collect.ImmutableList;
 import graphql.Internal;
 import graphql.normalized.NormalizedField;
 
@@ -154,7 +155,7 @@ public List<SelectedField> getFields(String fieldGlobPattern, String... fieldGlo
 
         return targetNames.stream()
                 .flatMap(name -> normalisedSelectionSetFields.getOrDefault(name, Collections.emptyList()).stream())
-                .collect(toList());
+                .collect(ImmutableList.toImmutableList());
     }
 
     @Override

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -1,6 +1,7 @@
 package graphql.schema;
 
 
+import com.google.common.collect.ImmutableList;
 import graphql.Internal;
 import graphql.PublicApi;
 import graphql.language.InputValueDefinition;
@@ -34,7 +35,7 @@ public class GraphQLInputObjectField implements GraphQLNamedSchemaElement, Graph
     private final GraphQLInputType originalType;
     private final Object defaultValue;
     private final InputValueDefinition definition;
-    private final List<GraphQLDirective> directives;
+    private final ImmutableList<GraphQLDirective> directives;
 
     private GraphQLInputType replacedType;
 
@@ -88,7 +89,7 @@ public GraphQLInputObjectField(String name, String description, GraphQLInputType
         this.originalType = type;
         this.defaultValue = defaultValue;
         this.description = description;
-        this.directives = directives;
+        this.directives =ImmutableList.copyOf(directives);
         this.definition = definition;
     }
 

File: src/main/java/graphql/schema/GraphqlTypeBuilder.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.schema;
 
+import com.google.common.collect.ImmutableList;
 import graphql.Internal;
 
 import java.util.Comparator;
@@ -37,7 +38,7 @@ <T extends GraphQLSchemaElement> List<T> sort(Map<String, T> types, Class<? exte
 
     <T extends GraphQLSchemaElement> List<T> sort(List<T> types, Class<? extends GraphQLSchemaElement> parentType, Class<? extends GraphQLSchemaElement> elementType) {
         Comparator<? super GraphQLSchemaElement> comparator = getComparatorImpl(comparatorRegistry, parentType, elementType);
-        return GraphqlTypeComparators.sortTypes(comparator, types);
+        return ImmutableList.copyOf(GraphqlTypeComparators.sortTypes(comparator, types));
     }
 
     Comparator<? super GraphQLSchemaElement> getComparator(Class<? extends GraphQLSchemaElement> parentType, Class<? extends GraphQLNamedSchemaElement> elementType) {

File: src/main/java/graphql/schema/GraphqlTypeComparators.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.schema;
 
+import com.google.common.collect.ImmutableList;
 import graphql.Internal;
 
 import java.util.ArrayList;
@@ -23,7 +24,7 @@ public class GraphqlTypeComparators {
     public static <T extends GraphQLSchemaElement> List<T> sortTypes(Comparator<? super GraphQLSchemaElement> comparator, Collection<T> types) {
         List<T> sorted = new ArrayList<>(types);
         sorted.sort(comparator);
-        return sorted;
+        return ImmutableList.copyOf(sorted);
     }
 
     /**

File: src/main/java/graphql/schema/SchemaElementChildrenContainer.java
Patch:
@@ -10,6 +10,7 @@
 import java.util.function.Consumer;
 
 import static graphql.Assert.assertNotNull;
+import static graphql.collect.ImmutableKit.emptyList;
 
 @PublicApi
 public class SchemaElementChildrenContainer {
@@ -21,7 +22,7 @@ private SchemaElementChildrenContainer(Map<String, List<GraphQLSchemaElement>> c
     }
 
     public <T extends GraphQLSchemaElement> List<T> getChildren(String key) {
-        return (List<T>) children.getOrDefault(key, new ArrayList<>());
+        return (List<T>) children.getOrDefault(key, emptyList());
     }
 
     public <T extends GraphQLSchemaElement> T getChildOrNull(String key) {

File: src/main/java/graphql/schema/idl/DirectiveInfo.java
Patch:
@@ -18,7 +18,7 @@ public class DirectiveInfo {
     /**
      * A set of directives which provided by graphql specification
      */
-    public static final Set<GraphQLDirective> GRAPHQL_SPECIFICATION_DIRECTIVES = new LinkedHashSet();
+    public static final Set<GraphQLDirective> GRAPHQL_SPECIFICATION_DIRECTIVES = new LinkedHashSet<>();
 
     /**
      * A map from directive name to directive which provided by specification

File: src/main/java/graphql/schema/validation/TypesImplementInterfaces.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.Objects;
 import java.util.stream.Collectors;
 
+import static graphql.collect.ImmutableKit.map;
 import static graphql.schema.GraphQLTypeUtil.isList;
 import static graphql.schema.GraphQLTypeUtil.isNonNull;
 import static graphql.schema.GraphQLTypeUtil.simplePrint;
@@ -111,7 +112,7 @@ private void checkFieldArgumentEquivalence(GraphQLImplementingType implementingT
         List<GraphQLArgument> objectArgs = objectFieldDef.getArguments();
 
         Map<String, GraphQLArgument> interfaceArgsByName = FpKit.getByName(interfaceArgs, GraphQLArgument::getName);
-        List<String> objectArgsNames = FpKit.map(objectArgs, GraphQLArgument::getName);
+        List<String> objectArgsNames = map(objectArgs, GraphQLArgument::getName);
 
         if (!objectArgsNames.containsAll(interfaceArgsByName.keySet())) {
             final String missingArgsNames = interfaceArgsByName.keySet().stream()

File: src/main/java/graphql/schema/visibility/BlockedFields.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.schema.visibility;
 
+import com.google.common.collect.ImmutableList;
 import graphql.Internal;
 import graphql.PublicApi;
 import graphql.schema.GraphQLFieldDefinition;
@@ -11,7 +12,6 @@
 import java.util.Collection;
 import java.util.List;
 import java.util.regex.Pattern;
-import java.util.stream.Collectors;
 
 /**
  * This helper class will take a list of regular expressions and match them against the fully qualified name
@@ -40,7 +40,7 @@ public BlockedFields(List<Pattern> patterns) {
     public List<GraphQLFieldDefinition> getFieldDefinitions(GraphQLFieldsContainer fieldsContainer) {
         return fieldsContainer.getFieldDefinitions().stream()
                 .filter(fieldDefinition -> !block(mkFQN(fieldsContainer.getName(), fieldDefinition.getName())))
-                .collect(Collectors.toList());
+                .collect(ImmutableList.toImmutableList());
     }
 
     @Override
@@ -58,7 +58,7 @@ public GraphQLFieldDefinition getFieldDefinition(GraphQLFieldsContainer fieldsCo
     public List<GraphQLInputObjectField> getFieldDefinitions(GraphQLInputFieldsContainer fieldsContainer) {
         return fieldsContainer.getFieldDefinitions().stream()
                 .filter(fieldDefinition -> !block(mkFQN(fieldsContainer.getName(), fieldDefinition.getName())))
-                .collect(Collectors.toList());
+                .collect(ImmutableList.toImmutableList());
     }
 
     @Override

File: src/main/java/graphql/util/NodeZipper.java
Patch:
@@ -1,9 +1,9 @@
 package graphql.util;
 
+import com.google.common.collect.ImmutableList;
 import graphql.PublicApi;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -37,7 +37,7 @@ public NodeZipper(T curNode, List<Breadcrumb<T>> breadcrumbs, NodeAdapter<T> nod
 
     public NodeZipper(T curNode, List<Breadcrumb<T>> breadcrumbs, NodeAdapter<T> nodeAdapter, ModificationType modificationType) {
         this.curNode = assertNotNull(curNode);
-        this.breadcrumbs = Collections.unmodifiableList(new ArrayList<>(assertNotNull(breadcrumbs)));
+        this.breadcrumbs = ImmutableList.copyOf(assertNotNull(breadcrumbs));
         this.nodeAdapter = nodeAdapter;
         this.modificationType = modificationType;
     }

File: src/main/java/graphql/validation/RulesVisitor.java
Patch:
@@ -8,6 +8,7 @@
 import java.util.Map;
 import java.util.Set;
 
+import com.google.common.collect.ImmutableList;
 import graphql.Internal;
 import graphql.language.Argument;
 import graphql.language.Directive;
@@ -26,7 +27,7 @@
 @Internal
 public class RulesVisitor implements DocumentVisitor {
 
-    private final List<AbstractRule> rules = new ArrayList<>();
+    private final ImmutableList<AbstractRule> rules;
     private final ValidationContext validationContext;
     private boolean subVisitor;
     private final List<AbstractRule> rulesVisitingFragmentSpreads = new ArrayList<>();
@@ -40,7 +41,7 @@ public RulesVisitor(ValidationContext validationContext, List<AbstractRule> rule
     public RulesVisitor(ValidationContext validationContext, List<AbstractRule> rules, boolean subVisitor) {
         this.validationContext = validationContext;
         this.subVisitor = subVisitor;
-        this.rules.addAll(rules);
+        this.rules = ImmutableList.copyOf(rules);
         this.subVisitor = subVisitor;
         findRulesVisitingFragmentSpreads();
     }

File: src/test/groovy/graphql/execution/instrumentation/dataloader/DataLoaderCompanyProductBackend.java
Patch:
@@ -1,6 +1,7 @@
 package graphql.execution.instrumentation.dataloader;
 
 
+import com.google.common.collect.ImmutableList;
 import org.dataloader.DataLoader;
 
 import java.util.ArrayList;
@@ -54,13 +55,13 @@ public CompletableFuture<List<Company>> getCompanies() {
     }
 
     private List<Company> companiesList() {
-        return Collections.unmodifiableList(new ArrayList<>(companies.values()));
+        return ImmutableList.copyOf(companies.values());
     }
 
     public CompletableFuture<List<Project>> getProjectsForCompanies(List<UUID> companyIds) {
         return CompletableFuture.supplyAsync(() -> projects.values().stream()
                 .filter(project -> companyIds.contains(project.getCompanyId()))
-                .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));
+                .collect(Collectors.collectingAndThen(Collectors.toList(), ImmutableList::copyOf)));
     }
 
     public CompletableFuture<Company> addCompany() {

File: src/main/java/graphql/schema/DataFetchingEnvironmentImpl.java
Patch:
@@ -12,6 +12,7 @@
 import graphql.language.Field;
 import graphql.language.FragmentDefinition;
 import graphql.language.OperationDefinition;
+import graphql.normalized.NormalizedQueryTree;
 import org.dataloader.DataLoader;
 import org.dataloader.DataLoaderRegistry;
 

File: src/main/java/graphql/execution/instrumentation/tracing/TracingInstrumentation.java
Patch:
@@ -77,10 +77,10 @@ public CompletableFuture<ExecutionResult> instrumentExecutionResult(ExecutionRes
         Map<Object, Object> currentExt = executionResult.getExtensions();
 
         TracingSupport tracingSupport = parameters.getInstrumentationState();
-        Map<Object, Object> tracingMap = new LinkedHashMap<>(currentExt == null ? Collections.emptyMap() : currentExt);
-        tracingMap.put("tracing", tracingSupport.snapshotTracingData());
+        Map<Object, Object> withTracingExt = new LinkedHashMap<>(currentExt == null ? Collections.emptyMap() : currentExt);
+        withTracingExt.put("tracing", tracingSupport.snapshotTracingData());
 
-        return CompletableFuture.completedFuture(new ExecutionResultImpl(executionResult.getData(), executionResult.getErrors(), tracingMap));
+        return CompletableFuture.completedFuture(new ExecutionResultImpl(executionResult.getData(), executionResult.getErrors(), withTracingExt));
     }
 
     @Override

File: src/main/java/graphql/schema/GraphQLTypeUtil.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.schema;
 
+import graphql.Assert;
 import graphql.PublicApi;
 
 import java.util.Stack;
@@ -21,6 +22,7 @@ public class GraphQLTypeUtil {
      * @return the type in graphql SDL format, eg [typeName!]!
      */
     public static String simplePrint(GraphQLType type) {
+        Assert.assertNotNull(type, () -> "type can't be null");
         StringBuilder sb = new StringBuilder();
         if (isNonNull(type)) {
             sb.append(simplePrint(unwrapOne(type)));

File: src/main/java/graphql/analysis/QueryTraverser.java
Patch:
@@ -35,7 +35,7 @@
  * visitField calls.
  */
 @PublicApi
-public class    QueryTraverser {
+public class QueryTraverser {
 
     private final Collection<? extends Node> roots;
     private final GraphQLSchema schema;

File: src/main/java/graphql/cachecontrol/CacheControl.java
Patch:
@@ -20,8 +20,8 @@
  * To best use this class you need to pass a CacheControl object to each {@link graphql.schema.DataFetcher} and have them decide on
  * the caching hint values.
  * <p>
- * The easiest why to do this is create a CacheControl object at query start and pass it in as a "context" object via {@link graphql.ExecutionInput#getContext()} and then have
- * each {@link graphql.schema.DataFetcher} thats wants to make cache control hints use that.
+ * The easiest way to do this is create a CacheControl object at query start and pass it in as a "context" object via {@link graphql.ExecutionInput#getContext()} and then have
+ * each {@link graphql.schema.DataFetcher} that wants to make cache control hints use that.
  * <p>
  * Then at the end of the query you would call {@link #addTo(graphql.ExecutionResult)} to record the cache control hints into the {@link graphql.ExecutionResult}
  * extensions map as per the specification.

File: src/main/java/graphql/schema/idl/errors/UnionTypeError.java
Patch:
@@ -1,7 +1,9 @@
 package graphql.schema.idl.errors;
 
+import graphql.Internal;
 import graphql.language.Node;
 
+@Internal
 public class UnionTypeError extends BaseError {
     public UnionTypeError(Node node, String msg) {
         super(node, msg);

File: src/main/java/graphql/TypeResolutionEnvironment.java
Patch:
@@ -9,7 +9,7 @@
 /**
  * This is passed to a {@link graphql.schema.TypeResolver} to help with object type resolution.
  *
- * See {@link graphql.schema.TypeResolver#getType(TypeResolutionEnvironment)} for how this is used
+ * See {@link graphql.schema.TypeResolver#getType} for how this is used
  */
 @SuppressWarnings("TypeParameterUnusedInFormals")
 @PublicApi

File: src/main/java/graphql/execution/directives/DirectivesResolver.java
Patch:
@@ -45,7 +45,7 @@ private void buildArguments(GraphQLDirective.Builder directiveBuilder, GraphQLCo
                 GraphQLArgument newArgument = protoArg.transform(argBuilder -> argBuilder.value(argValue));
                 directiveBuilder.argument(newArgument);
             } else {
-                // this means they can ask for the argument default value because the arugment on the directive
+                // this means they can ask for the argument default value because the argument on the directive
                 // object is present - but null
                 GraphQLArgument newArgument = protoArg.transform(argBuilder -> argBuilder.value(null));
                 directiveBuilder.argument(newArgument);

File: src/main/java/graphql/execution/ExecutionContext.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.ArrayList;
 import java.util.function.Consumer;
 
 @SuppressWarnings("TypeParameterUnusedInFormals")
@@ -40,7 +40,7 @@ public class ExecutionContext {
     private final Object context;
     private final Object localContext;
     private final Instrumentation instrumentation;
-    private final List<GraphQLError> errors = new CopyOnWriteArrayList<>();
+    private final List<GraphQLError> errors = Collections.synchronizedList(new ArrayList<>());
     private final Set<ResultPath> errorPaths = new HashSet<>();
     private final DataLoaderRegistry dataLoaderRegistry;
     private final CacheControl cacheControl;

File: src/main/java/graphql/parser/Parser.java
Patch:
@@ -99,7 +99,7 @@ public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int
     /**
      * Allows you to override the ANTLR to AST code.
      *
-     * @param tokens            the toke stream
+     * @param tokens            the token stream
      * @param multiSourceReader the source of the query document
      * @return a new GraphqlAntlrToLanguage instance
      */

File: src/main/java/graphql/schema/idl/SchemaTypeChecker.java
Patch:
@@ -64,9 +64,11 @@ public List<GraphQLError> checkTypeRegistry(TypeDefinitionRegistry typeRegistry,
         typeExtensionsChecker.checkTypeExtensions(errors, typeRegistry);
 
         ImplementingTypesChecker implementingTypesChecker = new ImplementingTypesChecker();
-
         implementingTypesChecker.checkImplementingTypes(errors, typeRegistry);
 
+        UnionTypesChecker unionTypesChecker = new UnionTypesChecker();
+        unionTypesChecker.checkUnionType(errors, typeRegistry);
+
         SchemaExtensionsChecker.checkSchemaInvariants(errors, typeRegistry);
 
         checkScalarImplementationsArePresent(errors, typeRegistry, wiring);

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -61,7 +61,7 @@ public Map<String, Object> coerceVariableValues(GraphQLSchema schema, List<Varia
             if (!variableValues.containsKey(variableName)) {
                 Value defaultValue = variableDefinition.getDefaultValue();
                 if (defaultValue != null) {
-                    Object coercedValue = coerceValueAst(fieldVisibility, variableType, variableDefinition.getDefaultValue(), null);
+                    Object coercedValue = coerceValueAst(fieldVisibility, variableType, defaultValue, null);
                     coercedValues.put(variableName, coercedValue);
                 } else if (isNonNull(variableType)) {
                     throw new NonNullableValueCoercedAsNullException(variableDefinition, variableType);

File: src/main/java/graphql/language/NullValue.java
Patch:
@@ -16,7 +16,6 @@
 import static graphql.Assert.assertNotNull;
 import static graphql.language.NodeChildrenContainer.newNodeChildrenContainer;
 import static graphql.language.NodeUtil.assertNewChildrenAreEmpty;
-import static java.util.Collections.emptyMap;
 
 @PublicApi
 public class NullValue extends AbstractNode<NullValue> implements Value<NullValue> {

File: src/main/java/graphql/language/InterfaceTypeDefinition.java
Patch:
@@ -178,6 +178,7 @@ private Builder(InterfaceTypeDefinition existing) {
             this.definitions = existing.getFieldDefinitions();
             this.ignoredChars = existing.getIgnoredChars();
             this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
+            this.implementz = existing.getImplements();
         }
 
 

File: src/main/java/graphql/language/InterfaceTypeDefinition.java
Patch:
@@ -178,6 +178,7 @@ private Builder(InterfaceTypeDefinition existing) {
             this.definitions = existing.getFieldDefinitions();
             this.ignoredChars = existing.getIgnoredChars();
             this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
+            this.implementz = existing.getImplements();
         }
 
 

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -61,7 +61,7 @@ public Map<String, Object> coerceVariableValues(GraphQLSchema schema, List<Varia
             if (!variableValues.containsKey(variableName)) {
                 Value defaultValue = variableDefinition.getDefaultValue();
                 if (defaultValue != null) {
-                    Object coercedValue = coerceValueAst(fieldVisibility, variableType, variableDefinition.getDefaultValue(), null);
+                    Object coercedValue = coerceValueAst(fieldVisibility, variableType, defaultValue, null);
                     coercedValues.put(variableName, coercedValue);
                 } else if (isNonNull(variableType)) {
                     throw new NonNullableValueCoercedAsNullException(variableDefinition, variableType);

File: src/main/java/graphql/language/NullValue.java
Patch:
@@ -16,7 +16,6 @@
 import static graphql.Assert.assertNotNull;
 import static graphql.language.NodeChildrenContainer.newNodeChildrenContainer;
 import static graphql.language.NodeUtil.assertNewChildrenAreEmpty;
-import static java.util.Collections.emptyMap;
 
 @PublicApi
 public class NullValue extends AbstractNode<NullValue> implements Value<NullValue> {

File: src/main/java/graphql/schema/GraphQLArgument.java
Patch:
@@ -236,7 +236,7 @@ public Builder(GraphQLArgument existing) {
             this.name = existing.getName();
             this.type = existing.originalType;
             this.value = existing.getValue();
-            this.defaultValue = existing.getDefaultValue();
+            this.defaultValue = existing.defaultValue;
             this.description = existing.getDescription();
             this.definition = existing.getDefinition();
             this.directives.putAll(FpKit.getByName(existing.getDirectives(), GraphQLDirective::getName));

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -297,4 +297,4 @@ public GraphQLInputObjectField build() {
                     definition);
         }
     }
-}
\ No newline at end of file
+}

File: src/main/java/graphql/schema/GraphQLArgument.java
Patch:
@@ -236,7 +236,7 @@ public Builder(GraphQLArgument existing) {
             this.name = existing.getName();
             this.type = existing.originalType;
             this.value = existing.getValue();
-            this.defaultValue = existing.getDefaultValue();
+            this.defaultValue = existing.defaultValue;
             this.description = existing.getDescription();
             this.definition = existing.getDefinition();
             this.directives.putAll(FpKit.getByName(existing.getDirectives(), GraphQLDirective::getName));

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -297,4 +297,4 @@ public GraphQLInputObjectField build() {
                     definition);
         }
     }
-}
\ No newline at end of file
+}

File: src/main/java/graphql/analysis/MaxQueryComplexityInstrumentation.java
Patch:
@@ -97,7 +97,9 @@ public void visitField(QueryVisitorFieldEnvironment env) {
                 }
             });
             int totalComplexity = valuesByParent.getOrDefault(null, 0);
-            log.debug("Query complexity: {}", totalComplexity);
+            if (log.isDebugEnabled()) {
+                log.debug("Query complexity: {}", totalComplexity);
+            }
             if (totalComplexity > maxComplexity) {
                 QueryComplexityInfo queryComplexityInfo = QueryComplexityInfo.newQueryComplexityInfo()
                         .complexity(totalComplexity)

File: src/main/java/graphql/analysis/MaxQueryDepthInstrumentation.java
Patch:
@@ -56,7 +56,9 @@ public InstrumentationContext<List<ValidationError>> beginValidation(Instrumenta
             }
             QueryTraverser queryTraverser = newQueryTraverser(parameters);
             int depth = queryTraverser.reducePreOrder((env, acc) -> Math.max(getPathLength(env.getParentEnvironment()), acc), 0);
-            log.debug("Query depth info: {}", depth);
+            if (log.isDebugEnabled()) {
+                log.debug("Query depth info: {}", depth);
+            }
             if (depth > maxDepth) {
                 QueryDepthInfo queryDepthInfo = QueryDepthInfo.newQueryDepthInfo()
                         .depth(depth)

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -163,7 +163,9 @@ private CompletableFuture<ExecutionResult> executeOperation(ExecutionContext exe
             } else {
                 executionStrategy = executionContext.getQueryStrategy();
             }
-            logNotSafe.debug("Executing '{}' query operation: '{}' using '{}' execution strategy", executionContext.getExecutionId(), operation, executionStrategy.getClass().getName());
+            if (logNotSafe.isDebugEnabled()) {
+                logNotSafe.debug("Executing '{}' query operation: '{}' using '{}' execution strategy", executionContext.getExecutionId(), operation, executionStrategy.getClass().getName());
+            }
             result = executionStrategy.execute(executionContext, parameters);
         } catch (NonNullableFieldWasNullException e) {
             // this means it was non null types all the way from an offending non null type

File: src/main/java/graphql/execution/instrumentation/dataloader/DataLoaderDispatcherInstrumentation.java
Patch:
@@ -188,7 +188,9 @@ public CompletableFuture<ExecutionResult> instrumentExecutionResult(ExecutionRes
         Map<Object, Object> dataLoaderStats = buildStatsMap(state);
         statsMap.put("dataloader", dataLoaderStats);
 
-        log.debug("Data loader stats : {}", dataLoaderStats);
+        if (log.isDebugEnabled()) {
+            log.debug("Data loader stats : {}", dataLoaderStats);
+        }
 
         return CompletableFuture.completedFuture(new ExecutionResultImpl(executionResult.getData(), executionResult.getErrors(), statsMap));
     }

File: src/main/java/graphql/execution/instrumentation/dataloader/FieldLevelTrackingApproach.java
Patch:
@@ -288,7 +288,9 @@ private boolean levelReady(CallStack callStack, int level) {
 
     void dispatch() {
         DataLoaderRegistry dataLoaderRegistry = getDataLoaderRegistry();
-        log.debug("Dispatching data loaders ({})", dataLoaderRegistry.getKeys());
+        if (log.isDebugEnabled()) {
+            log.debug("Dispatching data loaders ({})", dataLoaderRegistry.getKeys());
+        }
         dataLoaderRegistry.dispatchAll();
     }
 

File: src/main/java/graphql/schema/idl/ArgValueOfAllowedTypeChecker.java
Patch:
@@ -27,7 +27,6 @@
 import graphql.schema.idl.errors.DirectiveIllegalArgumentTypeError;
 import graphql.util.LogKit;
 import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.util.List;
 import java.util.Map;
@@ -264,7 +263,9 @@ private boolean isArgumentValueScalarLiteral(GraphQLScalarType scalarType, Value
             scalarType.getCoercing().parseLiteral(instanceValue);
             return true;
         } catch (CoercingParseLiteralException ex) {
-            logNotSafe.debug("Attempted parsing literal into '{}' but got the following error: ", scalarType.getName(), ex);
+            if (logNotSafe.isDebugEnabled()) {
+                logNotSafe.debug("Attempted parsing literal into '{}' but got the following error: ", scalarType.getName(), ex);
+            }
             return false;
         }
     }

File: src/main/java/graphql/ErrorType.java
Patch:
@@ -9,6 +9,7 @@ public enum ErrorType implements ErrorClassification {
     InvalidSyntax,
     ValidationError,
     DataFetchingException,
+    NullValueInNonNullableField,
     OperationNotSupported,
     ExecutionAborted
 }

File: src/main/java/graphql/execution/NonNullableFieldWasNullError.java
Patch:
@@ -39,7 +39,7 @@ public List<SourceLocation> getLocations() {
 
     @Override
     public ErrorType getErrorType() {
-        return ErrorType.DataFetchingException;
+        return ErrorType.NullValueInNonNullableField;
     }
 
     @Override

File: src/main/java/graphql/validation/rules/VariablesTypesMatcher.java
Patch:
@@ -2,6 +2,7 @@
 
 
 import graphql.Internal;
+import graphql.language.NullValue;
 import graphql.language.Value;
 import graphql.schema.GraphQLType;
 
@@ -18,7 +19,7 @@ public boolean doesVariableTypesMatch(GraphQLType variableType, Value variableDe
     }
 
     public GraphQLType effectiveType(GraphQLType variableType, Value defaultValue) {
-        if (defaultValue == null) {
+        if (defaultValue == null || defaultValue instanceof NullValue) {
             return variableType;
         }
         if (isNonNull(variableType)) {

File: src/main/java/graphql/GraphqlErrorBuilder.java
Patch:
@@ -92,7 +92,7 @@ public GraphqlErrorBuilder extensions(Map<String, Object> extensions) {
      * @return a newly built GraphqlError
      */
     public GraphQLError build() {
-        assertNotNull(message, "You must provide error message");
+        assertNotNull(message, () -> "You must provide error message");
         return new GraphqlErrorImpl(message, locations, errorType, path, extensions);
     }
 

File: src/main/java/graphql/analysis/MaxQueryComplexityInstrumentation.java
Patch:
@@ -72,7 +72,7 @@ public MaxQueryComplexityInstrumentation(int maxComplexity, FieldComplexityCalcu
     public MaxQueryComplexityInstrumentation(int maxComplexity, FieldComplexityCalculator fieldComplexityCalculator,
                                              Function<QueryComplexityInfo, Boolean> maxQueryComplexityExceededFunction) {
         this.maxComplexity = maxComplexity;
-        this.fieldComplexityCalculator = assertNotNull(fieldComplexityCalculator, "calculator can't be null");
+        this.fieldComplexityCalculator = assertNotNull(fieldComplexityCalculator, () -> "calculator can't be null");
         this.maxQueryComplexityExceededFunction = maxQueryComplexityExceededFunction;
     }
 

File: src/main/java/graphql/execution/Async.java
Patch:
@@ -49,7 +49,7 @@ public static <T, U> CompletableFuture<List<U>> each(Iterable<T> list, BiFunctio
             CompletableFuture<U> cf;
             try {
                 cf = cfFactory.apply(t, index++);
-                Assert.assertNotNull(cf, "cfFactory must return a non null value");
+                Assert.assertNotNull(cf, () -> "cfFactory must return a non null value");
             } catch (Exception e) {
                 cf = new CompletableFuture<>();
                 // Async.each makes sure that it is not a CompletionException inside a CompletionException
@@ -75,7 +75,7 @@ private static <T, U> void eachSequentiallyImpl(Iterator<T> iterator, CFFactory<
         CompletableFuture<U> cf;
         try {
             cf = cfFactory.apply(iterator.next(), index, tmpResult);
-            Assert.assertNotNull(cf, "cfFactory must return a non null value");
+            Assert.assertNotNull(cf, () -> "cfFactory must return a non null value");
         } catch (Exception e) {
             cf = new CompletableFuture<>();
             cf.completeExceptionally(new CompletionException(e));

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -87,6 +87,7 @@ public CompletableFuture<ExecutionResult> execute(Document document, GraphQLSche
                 .mutationStrategy(mutationStrategy)
                 .subscriptionStrategy(subscriptionStrategy)
                 .context(executionInput.getContext())
+                .localContext(executionInput.getLocalContext())
                 .root(executionInput.getRoot())
                 .fragmentsByName(fragmentsByName)
                 .variables(coercedVariables)
@@ -145,7 +146,7 @@ private CompletableFuture<ExecutionResult> executeOperation(ExecutionContext exe
         ExecutionStrategyParameters parameters = newParameters()
                 .executionStepInfo(executionStepInfo)
                 .source(root)
-                .localContext(null) // this is important to default as this
+                .localContext(executionContext.getLocalContext())
                 .fields(fields)
                 .nonNullFieldValidator(nonNullableFieldValidator)
                 .path(path)

File: src/main/java/graphql/execution/ExecutionId.java
Patch:
@@ -32,7 +32,7 @@ public static ExecutionId from(String id) {
     private final String id;
 
     private ExecutionId(String id) {
-        Assert.assertNotNull(id, "You must provided a non null id");
+        Assert.assertNotNull(id, () -> "You must provided a non null id");
         this.id = id;
     }
 

File: src/main/java/graphql/execution/ExecutionStepInfo.java
Patch:
@@ -77,7 +77,7 @@ private ExecutionStepInfo(GraphQLOutputType type,
         this.field = field;
         this.path = path;
         this.parent = parent;
-        this.type = assertNotNull(type, "you must provide a graphql type");
+        this.type = assertNotNull(type, () -> "you must provide a graphql type");
         this.arguments = arguments;
         this.fieldContainer = fieldsContainer;
     }
@@ -196,7 +196,7 @@ public boolean hasParent() {
      * @return a new type info with the same
      */
     public ExecutionStepInfo changeTypeWithPreservedNonNull(GraphQLOutputType newType) {
-        assertTrue(!GraphQLTypeUtil.isNonNull(newType), "newType can't be non null");
+        assertTrue(!GraphQLTypeUtil.isNonNull(newType), () -> "newType can't be non null");
         if (isNonNullType()) {
             return new ExecutionStepInfo(GraphQLNonNull.nonNull(newType), fieldDefinition, field, path, this.parent, arguments, this.fieldContainer);
         } else {

File: src/main/java/graphql/execution/ExecutionStrategyParameters.java
Patch:
@@ -40,9 +40,9 @@ private ExecutionStrategyParameters(ExecutionStepInfo executionStepInfo,
                                         ExecutionStrategyParameters parent,
                                         DeferredErrorSupport deferredErrorSupport) {
 
-        this.executionStepInfo = assertNotNull(executionStepInfo, "executionStepInfo is null");
+        this.executionStepInfo = assertNotNull(executionStepInfo, () -> "executionStepInfo is null");
         this.localContext = localContext;
-        this.fields = assertNotNull(fields, "fields is null");
+        this.fields = assertNotNull(fields, () -> "fields is null");
         this.source = source;
         this.arguments = arguments;
         this.nonNullableFieldValidator = nonNullableFieldValidator;
@@ -201,7 +201,7 @@ public Builder arguments(Map<String, Object> arguments) {
         }
 
         public Builder nonNullFieldValidator(NonNullableFieldValidator nonNullableFieldValidator) {
-            this.nonNullableFieldValidator = Assert.assertNotNull(nonNullableFieldValidator, "requires a NonNullValidator");
+            this.nonNullableFieldValidator = Assert.assertNotNull(nonNullableFieldValidator, () -> "requires a NonNullValidator");
             return this;
         }
 

File: src/main/java/graphql/execution/FieldCollectorParameters.java
Patch:
@@ -80,7 +80,7 @@ public Builder variables(Map<String, Object> variables) {
         }
 
         public FieldCollectorParameters build() {
-            Assert.assertNotNull(graphQLSchema, "You must provide a schema");
+            Assert.assertNotNull(graphQLSchema, () -> "You must provide a schema");
             return new FieldCollectorParameters(graphQLSchema, variables, fragmentsByName, objectType);
         }
 

File: src/main/java/graphql/execution/FieldValueInfo.java
Patch:
@@ -26,7 +26,7 @@ public enum CompleteValueType {
     private final List<FieldValueInfo> fieldValueInfos;
 
     private FieldValueInfo(CompleteValueType completeValueType, CompletableFuture<ExecutionResult> fieldValue, List<FieldValueInfo> fieldValueInfos) {
-        assertNotNull(fieldValueInfos, "fieldValueInfos can't be null");
+        assertNotNull(fieldValueInfos, () -> "fieldValueInfos can't be null");
         this.completeValueType = completeValueType;
         this.fieldValue = fieldValue;
         this.fieldValueInfos = fieldValueInfos;
@@ -78,7 +78,7 @@ public Builder fieldValue(CompletableFuture<ExecutionResult> executionResultFutu
         }
 
         public Builder fieldValueInfos(List<FieldValueInfo> listInfos) {
-            assertNotNull(listInfos, "fieldValueInfos can't be null");
+            assertNotNull(listInfos, () -> "fieldValueInfos can't be null");
             this.listInfos = listInfos;
             return this;
         }

File: src/main/java/graphql/execution/SubscriptionExecutionStrategy.java
Patch:
@@ -71,7 +71,7 @@ private CompletableFuture<Publisher<Object>> createSourceEventStream(ExecutionCo
         return fieldFetched.thenApply(fetchedValue -> {
             Object publisher = fetchedValue.getFetchedValue();
             if (publisher != null) {
-                assertTrue(publisher instanceof Publisher, "You data fetcher must return a Publisher of events when using graphql subscriptions");
+                assertTrue(publisher instanceof Publisher, () -> "Your data fetcher must return a Publisher of events when using graphql subscriptions");
             }
             //noinspection unchecked
             return (Publisher<Object>) publisher;

File: src/main/java/graphql/execution/nextgen/BatchedExecutionStrategy.java
Patch:
@@ -66,7 +66,7 @@ private CompletableFuture<NodeMultiZipper<ExecutionResultNode>> nextStep(Executi
 
     // all multizipper have the same root
     private CompletableFuture<NodeMultiZipper<ExecutionResultNode>> resolveNodes(ExecutionContext executionContext, List<NodeMultiZipper<ExecutionResultNode>> unresolvedNodes) {
-        assertNotEmpty(unresolvedNodes, "unresolvedNodes can't be empty");
+        assertNotEmpty(unresolvedNodes, () -> "unresolvedNodes can't be empty");
         ExecutionResultNode commonRoot = unresolvedNodes.get(0).getCommonRoot();
         CompletableFuture<List<List<NodeZipper<ExecutionResultNode>>>> listListCF = Async.flatMap(unresolvedNodes,
                 executionResultMultiZipper -> fetchAndAnalyze(executionContext, executionResultMultiZipper.getZippers()));
@@ -81,7 +81,7 @@ private List<NodeMultiZipper<ExecutionResultNode>> groupNodesIntoBatches(NodeMul
     }
 
     private CompletableFuture<List<NodeZipper<ExecutionResultNode>>> fetchAndAnalyze(ExecutionContext executionContext, List<NodeZipper<ExecutionResultNode>> unresolvedNodes) {
-        assertTrue(unresolvedNodes.size() > 0, "unresolvedNodes can't be empty");
+        assertTrue(unresolvedNodes.size() > 0, () -> "unresolvedNodes can't be empty");
 
         List<FieldSubSelection> fieldSubSelections = map(unresolvedNodes,
                 node -> util.createFieldSubSelection(executionContext, node.getCurNode().getExecutionStepInfo(), node.getCurNode().getResolvedValue()));

File: src/main/java/graphql/execution/nextgen/ValueFetcher.java
Patch:
@@ -76,7 +76,7 @@ public CompletableFuture<List<FetchedValue>> fetchBatchedValues(ExecutionContext
     @SuppressWarnings("unchecked")
     private List<FetchedValue> extractBatchedValues(FetchedValue fetchedValueContainingList, int expectedSize) {
         List<Object> list = (List<Object>) fetchedValueContainingList.getFetchedValue();
-        Assert.assertTrue(list.size() == expectedSize, "Unexpected result size");
+        Assert.assertTrue(list.size() == expectedSize, () -> "Unexpected result size");
         List<FetchedValue> result = new ArrayList<>();
         for (int i = 0; i < list.size(); i++) {
             List<GraphQLError> errors;

File: src/main/java/graphql/execution/nextgen/result/ResultNodeAdapter.java
Patch:
@@ -38,7 +38,7 @@ public ExecutionResultNode withNewChildren(ExecutionResultNode parentNode, Map<S
     public ExecutionResultNode removeChild(ExecutionResultNode parentNode, NodeLocation location) {
         int index = location.getIndex();
         List<ExecutionResultNode> childrenList = new ArrayList<>(parentNode.getChildren());
-        assertTrue(index >= 0 && index < childrenList.size(), "The remove index MUST be within the range of the children");
+        assertTrue(index >= 0 && index < childrenList.size(), () -> "The remove index MUST be within the range of the children");
         childrenList.remove(index);
         return parentNode.withNewChildren(childrenList);
     }

File: src/main/java/graphql/execution/reactive/NonBlockingMutexExecutor.java
Patch:
@@ -37,7 +37,7 @@ class NonBlockingMutexExecutor implements Executor {
 
     @Override
     public void execute(final Runnable command) {
-        final RunNode newNode = new RunNode(assertNotNull(command, "Runnable must not be null"));
+        final RunNode newNode = new RunNode(assertNotNull(command, () -> "Runnable must not be null"));
         final RunNode prevLast = last.getAndSet(newNode);
         if (prevLast != null)
             prevLast.lazySet(newNode);

File: src/main/java/graphql/execution/reactive/SingleSubscriberPublisher.java
Patch:
@@ -102,7 +102,7 @@ private void handleOnComplete() {
 
     @Override
     public void subscribe(Subscriber<? super T> subscriber) {
-        assertNotNullWithNPE(subscriber, "Subscriber passed to subscribe must not be null");
+        assertNotNullWithNPE(subscriber, () -> "Subscriber passed to subscribe must not be null");
         mutex.execute(() -> {
             if (this.subscriber == null) {
                 this.subscriber = subscriber;

File: src/main/java/graphql/language/AbstractNode.java
Patch:
@@ -27,9 +27,9 @@ public AbstractNode(SourceLocation sourceLocation, List<Comment> comments, Ignor
     }
 
     public AbstractNode(SourceLocation sourceLocation, List<Comment> comments, IgnoredChars ignoredChars, Map<String, String> additionalData) {
-        Assert.assertNotNull(comments, "comments can't be null");
-        Assert.assertNotNull(ignoredChars, "ignoredChars can't be null");
-        Assert.assertNotNull(additionalData, "additionalData can't be null");
+        Assert.assertNotNull(comments, () -> "comments can't be null");
+        Assert.assertNotNull(ignoredChars, () -> "ignoredChars can't be null");
+        Assert.assertNotNull(additionalData, () -> "additionalData can't be null");
 
         this.sourceLocation = sourceLocation;
         this.additionalData = unmodifiableMap(new LinkedHashMap<>(additionalData));

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -417,7 +417,7 @@ private String node(Node node) {
 
     private String node(Node node, Class startClass) {
         if (startClass != null) {
-            assertTrue(startClass.isInstance(node), "The starting class must be in the inherit tree");
+            assertTrue(startClass.isInstance(node), () -> "The starting class must be in the inherit tree");
         }
         StringWriter sw = new StringWriter();
         PrintWriter out = new PrintWriter(sw);

File: src/main/java/graphql/language/NodeParentTree.java
Patch:
@@ -28,8 +28,8 @@ public class NodeParentTree<T extends Node> {
 
     @Internal
     public NodeParentTree(Deque<T> nodeStack) {
-        assertNotNull(nodeStack, "You MUST have a non null stack of nodes");
-        assertTrue(!nodeStack.isEmpty(), "You MUST have a non empty stack of nodes");
+        assertNotNull(nodeStack, () -> "You MUST have a non null stack of nodes");
+        assertTrue(!nodeStack.isEmpty(), () -> "You MUST have a non empty stack of nodes");
 
         Deque<T> copy = new ArrayDeque<>(nodeStack);
         path = mkPath(copy);

File: src/main/java/graphql/relay/DefaultConnection.java
Patch:
@@ -26,8 +26,8 @@ public class DefaultConnection<T> implements Connection<T> {
      * @throws IllegalArgumentException if edges or page info is null. use {@link Collections#emptyList()} for empty edges.
      */
     public DefaultConnection(List<Edge<T>> edges, PageInfo pageInfo) {
-        this.edges = unmodifiableList(assertNotNull(edges, "edges cannot be null"));
-        this.pageInfo = assertNotNull(pageInfo, "page info cannot be null");
+        this.edges = unmodifiableList(assertNotNull(edges, () -> "edges cannot be null"));
+        this.pageInfo = assertNotNull(pageInfo, () -> "page info cannot be null");
     }
 
     @Override

File: src/main/java/graphql/relay/DefaultConnectionCursor.java
Patch:
@@ -11,7 +11,7 @@ public class DefaultConnectionCursor implements ConnectionCursor {
     private final String value;
 
     public DefaultConnectionCursor(String value) {
-        Assert.assertTrue(value != null && !value.isEmpty(), "connection value cannot be null or empty");
+        Assert.assertTrue(value != null && !value.isEmpty(), () -> "connection value cannot be null or empty");
         this.value = value;
     }
 

File: src/main/java/graphql/relay/DefaultEdge.java
Patch:
@@ -11,7 +11,7 @@ public class DefaultEdge<T> implements Edge<T> {
     private final ConnectionCursor cursor;
 
     public DefaultEdge(T node, ConnectionCursor cursor) {
-        this.cursor = assertNotNull(cursor, "cursor cannot be null");
+        this.cursor = assertNotNull(cursor, () -> "cursor cannot be null");
         this.node = node;
     }
 

File: src/main/java/graphql/relay/SimpleListConnection.java
Patch:
@@ -24,8 +24,8 @@ public class SimpleListConnection<T> implements DataFetcher<Connection<T>>, Triv
     private final List<T> data;
 
     public SimpleListConnection(List<T> data, String prefix) {
-        this.data = assertNotNull(data, " data cannot be null");
-        assertTrue(prefix != null && !prefix.isEmpty(), "prefix cannot be null or empty");
+        this.data = assertNotNull(data, () -> " data cannot be null");
+        assertTrue(prefix != null && !prefix.isEmpty(), () -> "prefix cannot be null or empty");
         this.prefix = prefix;
     }
 

File: src/main/java/graphql/schema/AsyncDataFetcher.java
Patch:
@@ -58,8 +58,8 @@ public AsyncDataFetcher(DataFetcher<T> wrappedDataFetcher) {
     }
 
     public AsyncDataFetcher(DataFetcher<T> wrappedDataFetcher, Executor executor) {
-        this.wrappedDataFetcher = assertNotNull(wrappedDataFetcher, "wrappedDataFetcher can't be null");
-        this.executor = assertNotNull(executor, "executor can't be null");
+        this.wrappedDataFetcher = assertNotNull(wrappedDataFetcher, () -> "wrappedDataFetcher can't be null");
+        this.executor = assertNotNull(executor, () -> "executor can't be null");
     }
 
     @Override

File: src/main/java/graphql/schema/FieldCoordinates.java
Patch:
@@ -44,7 +44,7 @@ public String getFieldName() {
     public void assertValidNames() throws AssertException {
         if (systemCoordinates) {
             assertTrue((null != fieldName) &&
-                    fieldName.startsWith("__"), "Only __ system fields can be addressed without a parent type");
+                    fieldName.startsWith("__"), () -> "Only __ system fields can be addressed without a parent type");
             assertValidName(fieldName);
         } else {
             assertValidName(typeName);

File: src/main/java/graphql/schema/GraphQLDirective.java
Patch:
@@ -55,7 +55,7 @@ private GraphQLDirective(String name,
                              List<GraphQLArgument> arguments,
                              DirectiveDefinition definition) {
         assertValidName(name);
-        assertNotNull(arguments, "arguments can't be null");
+        assertNotNull(arguments, () -> "arguments can't be null");
         this.name = name;
         this.description = description;
         this.locations = locations;
@@ -199,13 +199,13 @@ public Builder clearValidLocations() {
         }
 
         public Builder argument(GraphQLArgument argument) {
-            assertNotNull(argument, "argument must not be null");
+            assertNotNull(argument, () -> "argument must not be null");
             arguments.put(argument.getName(), argument);
             return this;
         }
 
         public Builder replaceArguments(List<GraphQLArgument> arguments) {
-            assertNotNull(arguments, "arguments must not be null");
+            assertNotNull(arguments, () -> "arguments must not be null");
             this.arguments.clear();
             for (GraphQLArgument argument : arguments) {
                 this.arguments.put(argument.getName(), argument);

File: src/main/java/graphql/schema/GraphQLList.java
Patch:
@@ -40,7 +40,7 @@ public static GraphQLList list(GraphQLType wrappedType) {
 
 
     public GraphQLList(GraphQLType wrappedType) {
-        assertNotNull(wrappedType, "wrappedType can't be null");
+        assertNotNull(wrappedType, () -> "wrappedType can't be null");
         this.originalWrappedType = wrappedType;
     }
 

File: src/main/java/graphql/schema/GraphQLTypeResolvingVisitor.java
Patch:
@@ -43,7 +43,7 @@ public TraversalControl visitGraphQLTypeReference(GraphQLTypeReference node, Tra
 
     public TraversalControl handleTypeReference(GraphQLTypeReference node, TraverserContext<GraphQLSchemaElement> context) {
         final GraphQLType resolvedType = typeMap.get(node.getName());
-        assertNotNull(resolvedType, "type %s not found in schema", node.getName());
+        assertNotNull(resolvedType, () -> String.format("type %s not found in schema", node.getName()));
         context.getParentContext().thisNode().accept(context, new TypeRefResolvingVisitor(resolvedType));
         return CONTINUE;
     }

File: src/main/java/graphql/schema/GraphqlElementParentTree.java
Patch:
@@ -25,8 +25,8 @@ public class GraphqlElementParentTree {
 
     @Internal
     public GraphqlElementParentTree(Deque<GraphQLSchemaElement> nodeStack) {
-        assertNotNull(nodeStack, "You MUST have a non null stack of elements");
-        assertTrue(!nodeStack.isEmpty(), "You MUST have a non empty stack of element");
+        assertNotNull(nodeStack, () -> "You MUST have a non null stack of elements");
+        assertTrue(!nodeStack.isEmpty(), () -> "You MUST have a non empty stack of element");
 
         Deque<GraphQLSchemaElement> copy = new ArrayDeque<>(nodeStack);
         element = copy.pop();

File: src/main/java/graphql/schema/GraphqlTypeComparatorEnvironment.java
Patch:
@@ -19,7 +19,7 @@ public class GraphqlTypeComparatorEnvironment {
     private Class<? extends GraphQLSchemaElement> elementType;
 
     private GraphqlTypeComparatorEnvironment(Class<? extends GraphQLSchemaElement> parentType, Class<? extends GraphQLSchemaElement> elementType) {
-        Assert.assertNotNull(elementType, "elementType can't be null");
+        Assert.assertNotNull(elementType, () -> "elementType can't be null");
         this.parentType = parentType;
         this.elementType = elementType;
     }

File: src/main/java/graphql/schema/SchemaTransformer.java
Patch:
@@ -287,7 +287,7 @@ private NodeZipper<GraphQLSchemaElement> moveUp(
             GraphQLSchemaElement parent,
             List<NodeZipper<GraphQLSchemaElement>> sameParent,
             Map<NodeZipper<GraphQLSchemaElement>, List<List<Breadcrumb<GraphQLSchemaElement>>>> breadcrumbsUsed) {
-        assertNotEmpty(sameParent, "expected at least one zipper");
+        assertNotEmpty(sameParent, () -> "expected at least one zipper");
 
         Map<String, List<GraphQLSchemaElement>> childrenMap = new HashMap<>(SCHEMA_ELEMENT_ADAPTER.getNamedChildren(parent));
         Map<String, Integer> indexCorrection = new HashMap<>();

File: src/main/java/graphql/schema/diff/DiffSet.java
Patch:
@@ -69,7 +69,7 @@ public static DiffSet diffSet(GraphQLSchema schemaOld, GraphQLSchema schemaNew)
     private static Map<String, Object> introspect(GraphQLSchema schema) {
         GraphQL gql = GraphQL.newGraphQL(schema).build();
         ExecutionResult result = gql.execute(IntrospectionQuery.INTROSPECTION_QUERY);
-        Assert.assertTrue(result.getErrors().size() == 0, "The schema has errors during Introspection");
+        Assert.assertTrue(result.getErrors().size() == 0, () -> "The schema has errors during Introspection");
         return result.getData();
     }
 }

File: src/main/java/graphql/schema/idl/CombinedWiringFactory.java
Patch:
@@ -19,7 +19,7 @@ public class CombinedWiringFactory implements WiringFactory {
     private final List<WiringFactory> factories;
 
     public CombinedWiringFactory(List<WiringFactory> factories) {
-        assertNotNull(factories, "You must provide a list of wiring factories");
+        assertNotNull(factories, () -> "You must provide a list of wiring factories");
         this.factories = new ArrayList<>(factories);
     }
 

File: src/main/java/graphql/schema/idl/MapEnumValuesProvider.java
Patch:
@@ -12,7 +12,7 @@ public class MapEnumValuesProvider implements EnumValuesProvider {
     private final Map<String, Object> values;
 
     public MapEnumValuesProvider(Map<String, Object> values) {
-        Assert.assertNotNull(values, "values can't be null");
+        Assert.assertNotNull(values, () -> "values can't be null");
         this.values = values;
     }
 

File: src/main/java/graphql/schema/idl/NaturalEnumValuesProvider.java
Patch:
@@ -13,7 +13,7 @@ public class NaturalEnumValuesProvider<T extends Enum<T>> implements EnumValuesP
     private final Class<T> enumType;
 
     public NaturalEnumValuesProvider(Class<T> enumType) {
-        Assert.assertNotNull(enumType, "enumType can't be null");
+        Assert.assertNotNull(enumType, () -> "enumType can't be null");
         this.enumType = enumType;
     }
 

File: src/main/java/graphql/schema/idl/RuntimeWiring.java
Patch:
@@ -142,7 +142,7 @@ private Builder() {
          * @return this outer builder
          */
         public Builder wiringFactory(WiringFactory wiringFactory) {
-            assertNotNull(wiringFactory, "You must provide a wiring factory");
+            assertNotNull(wiringFactory, () -> "You must provide a wiring factory");
             this.wiringFactory = wiringFactory;
             return this;
         }

File: src/main/java/graphql/schema/idl/SchemaExtensionsChecker.java
Patch:
@@ -30,7 +30,7 @@ public class SchemaExtensionsChecker {
     static Map<String, OperationTypeDefinition> gatherOperationDefs(TypeDefinitionRegistry typeRegistry) {
         List<GraphQLError> noErrors = new ArrayList<>();
         Map<String, OperationTypeDefinition> operationTypeDefinitionMap = gatherOperationDefs(noErrors, typeRegistry.schemaDefinition().orElse(null), typeRegistry.getSchemaExtensionDefinitions());
-        Assert.assertTrue(noErrors.isEmpty(), "If you call this method it MUST have previously been error checked");
+        Assert.assertTrue(noErrors.isEmpty(), () -> "If you call this method it MUST have previously been error checked");
         return operationTypeDefinitionMap;
     }
 
@@ -89,7 +89,7 @@ static List<OperationTypeDefinition> checkSchemaInvariants(List<GraphQLError> er
     static List<Directive> gatherSchemaDirectives(TypeDefinitionRegistry typeRegistry) {
         List<GraphQLError> noErrors = new ArrayList<>();
         List<Directive> directiveList = gatherSchemaDirectives(typeRegistry, noErrors);
-        Assert.assertTrue(noErrors.isEmpty(), "If you call this method it MUST have previously been error checked");
+        Assert.assertTrue(noErrors.isEmpty(), () -> "If you call this method it MUST have previously been error checked");
         return directiveList;
     }
 

File: src/main/java/graphql/schema/idl/SchemaGeneratorDirectiveHelper.java
Patch:
@@ -307,7 +307,7 @@ private <T extends GraphQLDirectiveContainer> T wireDirectives(
         // wiring factory is last (if present)
         env = envBuilder.apply(outputObject, allDirectives, null);
         if (wiringFactory.providesSchemaDirectiveWiring(env)) {
-            schemaDirectiveWiring = assertNotNull(wiringFactory.getSchemaDirectiveWiring(env), "Your WiringFactory MUST provide a non null SchemaDirectiveWiring");
+            schemaDirectiveWiring = assertNotNull(wiringFactory.getSchemaDirectiveWiring(env), () -> "Your WiringFactory MUST provide a non null SchemaDirectiveWiring");
             outputObject = invokeWiring(outputObject, invoker, schemaDirectiveWiring, env);
         }
 
@@ -316,7 +316,7 @@ private <T extends GraphQLDirectiveContainer> T wireDirectives(
 
     private <T extends GraphQLDirectiveContainer> T invokeWiring(T element, EnvInvoker<T> invoker, SchemaDirectiveWiring schemaDirectiveWiring, SchemaDirectiveWiringEnvironment<T> env) {
         T newElement = invoker.apply(schemaDirectiveWiring, env);
-        assertNotNull(newElement, "The SchemaDirectiveWiring MUST return a non null return value for element '" + element.getName() + "'");
+        assertNotNull(newElement, () -> "The SchemaDirectiveWiring MUST return a non null return value for element '" + element.getName() + "'");
         return newElement;
     }
 }

File: src/main/java/graphql/schema/idl/TypeInfo.java
Patch:
@@ -30,7 +30,7 @@ public static TypeInfo typeInfo(Type type) {
     private final Stack<Class<?>> decoration = new Stack<>();
 
     private TypeInfo(Type type) {
-        this.rawType = assertNotNull(type, "type must not be null");
+        this.rawType = assertNotNull(type, () -> "type must not be null");
         while (!(type instanceof TypeName)) {
             if (type instanceof NonNullType) {
                 decoration.push(NonNullType.class);

File: src/main/java/graphql/schema/validation/SchemaValidationError.java
Patch:
@@ -8,8 +8,8 @@ public class SchemaValidationError {
     private final String description;
 
     public SchemaValidationError(SchemaValidationErrorType errorType, String description) {
-        assertNotNull(errorType, "error type can not be null");
-        assertNotNull(description, "error description can not be null");
+        assertNotNull(errorType, () -> "error type can not be null");
+        assertNotNull(description, () -> "error description can not be null");
         this.errorType = errorType;
         this.description = description;
     }

File: src/main/java/graphql/util/TraverserState.java
Patch:
@@ -44,7 +44,7 @@ public void pushAll(TraverserContext<U> traverserContext, Function<? super U, Ma
                 childrenMap.keySet().forEach(key -> {
                     List<U> children = childrenMap.get(key);
                     for (int i = children.size() - 1; i >= 0; i--) {
-                        U child = assertNotNull(children.get(i), "null child for key " + key);
+                        U child = assertNotNull(children.get(i), () -> "null child for key " + key);
                         NodeLocation nodeLocation = new NodeLocation(key, i);
                         DefaultTraverserContext<U> context = super.newContext(child, traverserContext, nodeLocation);
                         super.state.push(context);
@@ -72,7 +72,7 @@ public void pushAll(TraverserContext<U> traverserContext, Function<? super U, Ma
                 childrenMap.keySet().forEach(key -> {
                     List<U> children = childrenMap.get(key);
                     for (int i = 0; i < children.size(); i++) {
-                        U child = assertNotNull(children.get(i), "null child for key " + key);
+                        U child = assertNotNull(children.get(i), () -> "null child for key " + key);
                         NodeLocation nodeLocation = new NodeLocation(key, i);
                         DefaultTraverserContext<U> context = super.newContext(child, traverserContext, nodeLocation);
                         childrenContextMap.computeIfAbsent(key, notUsed -> new ArrayList<>());

File: src/main/java/graphql/util/TreeParallelTraverser.java
Patch:
@@ -131,8 +131,8 @@ private EnterAction(CountedCompleter parent, DefaultTraverserContext currentCont
         public void compute() {
             currentContext.setPhase(TraverserContext.Phase.ENTER);
             TraversalControl traversalControl = visitor.enter(currentContext);
-            assertNotNull(traversalControl, "result of enter must not be null");
-            assertTrue(QUIT != traversalControl, "can't return QUIT for parallel traversing");
+            assertNotNull(traversalControl, () -> "result of enter must not be null");
+            assertTrue(QUIT != traversalControl, () -> "can't return QUIT for parallel traversing");
             if (traversalControl == ABORT) {
                 tryComplete();
                 return;
@@ -162,7 +162,7 @@ private List<DefaultTraverserContext> pushAll(TraverserContext<T> traverserConte
             childrenMap.keySet().forEach(key -> {
                 List<T> children = childrenMap.get(key);
                 for (int i = children.size() - 1; i >= 0; i--) {
-                    T child = assertNotNull(children.get(i), "null child for key %s", key);
+                    T child = assertNotNull(children.get(i), () -> String.format("null child for key %s", key));
                     NodeLocation nodeLocation = new NodeLocation(key, i);
                     DefaultTraverserContext<T> context = newContext(child, traverserContext, nodeLocation);
                     contexts.push(context);

File: src/main/java/graphql/util/TreeTransformerUtil.java
Patch:
@@ -50,7 +50,7 @@ public static <T> TraversalControl changeNode(TraverserContext<T> context, T cha
 
     private static <T> void replaceZipperForNode(List<NodeZipper<T>> zippers, T currentNode, T newNode) {
         int index = FpKit.findIndex(zippers, zipper -> zipper.getCurNode() == currentNode);
-        assertTrue(index >= 0, "No current zipper found for provided node");
+        assertTrue(index >= 0, () -> "No current zipper found for provided node");
         NodeZipper<T> newZipper = zippers.get(index).withNewNode(newNode);
         zippers.set(index, newZipper);
     }

File: src/main/java/graphql/validation/ValidationError.java
Patch:
@@ -4,13 +4,15 @@
 import graphql.ErrorType;
 import graphql.GraphQLError;
 import graphql.GraphqlErrorHelper;
+import graphql.PublicApi;
 import graphql.language.SourceLocation;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
+@PublicApi
 public class ValidationError implements GraphQLError {
 
     private final String message;

File: src/main/java/graphql/validation/ValidationErrorType.java
Patch:
@@ -35,5 +35,6 @@ public enum ValidationErrorType {
     DeferDirectiveOnNonNullField,
     DeferDirectiveNotOnQueryOperation,
     DeferMustBeOnAllFields,
+    DuplicateArgumentNames,
     DuplicateVariableName
 }

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -256,6 +256,9 @@ private static String print(Object value, GraphQLInputType type) {
         if (type instanceof GraphQLObjectType) {
             return ((GraphQLObjectType) type).getInterfaces();
         }
+        if (type instanceof GraphQLInterfaceType) {
+            return ((GraphQLInterfaceType) type).getInterfaces();
+        }
         return null;
     };
 

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -97,6 +97,7 @@ public CompletableFuture<ExecutionResult> execute(Document document, GraphQLSche
                 .cacheControl(executionInput.getCacheControl())
                 .locale(executionInput.getLocale())
                 .valueUnboxer(valueUnboxer)
+                .executionInput(executionInput)
                 .build();
 
 

File: src/test/groovy/graphql/execution/pubsub/ReactiveStreamsMessagePublisher.java
Patch:
@@ -9,7 +9,7 @@
 import java.util.function.Function;
 
 /**
- * This example publisher will create count "messages" and then terminate. Its
+ * This example publisher will create count "messages" and then terminate. It
  * uses the reactive streams TCK as its implementation
  */
 public class ReactiveStreamsMessagePublisher implements Publisher<Message> {

File: src/main/java/graphql/ExecutionInput.java
Patch:
@@ -32,7 +32,7 @@ public class ExecutionInput {
 
     @Internal
     private ExecutionInput(String query, String operationName, Object context, Object root, Map<String, Object> variables, DataLoaderRegistry dataLoaderRegistry, CacheControl cacheControl, ExecutionId executionId, Locale locale, Object localContext) {
-        this.query = assertNotNull(query, "query can't be null");
+        this.query = assertNotNull(query, () -> "query can't be null");
         this.operationName = operationName;
         this.context = context;
         this.root = root;
@@ -189,7 +189,7 @@ public static class Builder {
         private ExecutionId executionId;
 
         public Builder query(String query) {
-            this.query = assertNotNull(query, "query can't be null");
+            this.query = assertNotNull(query, () -> "query can't be null");
             return this;
         }
 
@@ -259,7 +259,7 @@ public Builder root(Object root) {
         }
 
         public Builder variables(Map<String, Object> variables) {
-            this.variables = assertNotNull(variables, "variables map can't be null");
+            this.variables = assertNotNull(variables, () -> "variables map can't be null");
             return this;
         }
 

File: src/main/java/graphql/GraphqlErrorBuilder.java
Patch:
@@ -92,7 +92,7 @@ public GraphqlErrorBuilder extensions(Map<String, Object> extensions) {
      * @return a newly built GraphqlError
      */
     public GraphQLError build() {
-        assertNotNull(message, "You must provide error message");
+        assertNotNull(message, () -> "You must provide error message");
         return new GraphqlErrorImpl(message, locations, errorType, path, extensions);
     }
 

File: src/main/java/graphql/analysis/MaxQueryComplexityInstrumentation.java
Patch:
@@ -72,7 +72,7 @@ public MaxQueryComplexityInstrumentation(int maxComplexity, FieldComplexityCalcu
     public MaxQueryComplexityInstrumentation(int maxComplexity, FieldComplexityCalculator fieldComplexityCalculator,
                                              Function<QueryComplexityInfo, Boolean> maxQueryComplexityExceededFunction) {
         this.maxComplexity = maxComplexity;
-        this.fieldComplexityCalculator = assertNotNull(fieldComplexityCalculator, "calculator can't be null");
+        this.fieldComplexityCalculator = assertNotNull(fieldComplexityCalculator, () -> "calculator can't be null");
         this.maxQueryComplexityExceededFunction = maxQueryComplexityExceededFunction;
     }
 

File: src/main/java/graphql/execution/Async.java
Patch:
@@ -49,7 +49,7 @@ public static <T, U> CompletableFuture<List<U>> each(Iterable<T> list, BiFunctio
             CompletableFuture<U> cf;
             try {
                 cf = cfFactory.apply(t, index++);
-                Assert.assertNotNull(cf, "cfFactory must return a non null value");
+                Assert.assertNotNull(cf, () -> "cfFactory must return a non null value");
             } catch (Exception e) {
                 cf = new CompletableFuture<>();
                 // Async.each makes sure that it is not a CompletionException inside a CompletionException
@@ -75,7 +75,7 @@ private static <T, U> void eachSequentiallyImpl(Iterator<T> iterator, CFFactory<
         CompletableFuture<U> cf;
         try {
             cf = cfFactory.apply(iterator.next(), index, tmpResult);
-            Assert.assertNotNull(cf, "cfFactory must return a non null value");
+            Assert.assertNotNull(cf, () -> "cfFactory must return a non null value");
         } catch (Exception e) {
             cf = new CompletableFuture<>();
             cf.completeExceptionally(new CompletionException(e));

File: src/main/java/graphql/execution/ExecutionContextBuilder.java
Patch:
@@ -181,7 +181,7 @@ public ExecutionContextBuilder valueUnboxer(ValueUnboxer valueUnboxer) {
 
     public ExecutionContext build() {
         // preconditions
-        assertNotNull(executionId, "You must provide a query identifier");
+        assertNotNull(executionId, () -> "You must provide a query identifier");
 
         return new ExecutionContext(
                 instrumentation,

File: src/main/java/graphql/execution/ExecutionId.java
Patch:
@@ -32,7 +32,7 @@ public static ExecutionId from(String id) {
     private final String id;
 
     private ExecutionId(String id) {
-        Assert.assertNotNull(id, "You must provided a non null id");
+        Assert.assertNotNull(id, () -> "You must provided a non null id");
         this.id = id;
     }
 

File: src/main/java/graphql/execution/ExecutionStepInfo.java
Patch:
@@ -77,7 +77,7 @@ private ExecutionStepInfo(GraphQLOutputType type,
         this.field = field;
         this.path = path;
         this.parent = parent;
-        this.type = assertNotNull(type, "you must provide a graphql type");
+        this.type = assertNotNull(type, () -> "you must provide a graphql type");
         this.arguments = arguments;
         this.fieldContainer = fieldsContainer;
     }
@@ -196,7 +196,7 @@ public boolean hasParent() {
      * @return a new type info with the same
      */
     public ExecutionStepInfo changeTypeWithPreservedNonNull(GraphQLOutputType newType) {
-        assertTrue(!GraphQLTypeUtil.isNonNull(newType), "newType can't be non null");
+        assertTrue(!GraphQLTypeUtil.isNonNull(newType), () -> "newType can't be non null");
         if (isNonNullType()) {
             return new ExecutionStepInfo(GraphQLNonNull.nonNull(newType), fieldDefinition, field, path, this.parent, arguments, this.fieldContainer);
         } else {

File: src/main/java/graphql/execution/ExecutionStrategyParameters.java
Patch:
@@ -40,9 +40,9 @@ private ExecutionStrategyParameters(ExecutionStepInfo executionStepInfo,
                                         ExecutionStrategyParameters parent,
                                         DeferredErrorSupport deferredErrorSupport) {
 
-        this.executionStepInfo = assertNotNull(executionStepInfo, "executionStepInfo is null");
+        this.executionStepInfo = assertNotNull(executionStepInfo, () -> "executionStepInfo is null");
         this.localContext = localContext;
-        this.fields = assertNotNull(fields, "fields is null");
+        this.fields = assertNotNull(fields, () -> "fields is null");
         this.source = source;
         this.arguments = arguments;
         this.nonNullableFieldValidator = nonNullableFieldValidator;
@@ -201,7 +201,7 @@ public Builder arguments(Map<String, Object> arguments) {
         }
 
         public Builder nonNullFieldValidator(NonNullableFieldValidator nonNullableFieldValidator) {
-            this.nonNullableFieldValidator = Assert.assertNotNull(nonNullableFieldValidator, "requires a NonNullValidator");
+            this.nonNullableFieldValidator = Assert.assertNotNull(nonNullableFieldValidator, () -> "requires a NonNullValidator");
             return this;
         }
 

File: src/main/java/graphql/execution/FieldCollectorParameters.java
Patch:
@@ -80,7 +80,7 @@ public Builder variables(Map<String, Object> variables) {
         }
 
         public FieldCollectorParameters build() {
-            Assert.assertNotNull(graphQLSchema, "You must provide a schema");
+            Assert.assertNotNull(graphQLSchema, () -> "You must provide a schema");
             return new FieldCollectorParameters(graphQLSchema, variables, fragmentsByName, objectType);
         }
 

File: src/main/java/graphql/execution/FieldValueInfo.java
Patch:
@@ -26,7 +26,7 @@ public enum CompleteValueType {
     private final List<FieldValueInfo> fieldValueInfos;
 
     private FieldValueInfo(CompleteValueType completeValueType, CompletableFuture<ExecutionResult> fieldValue, List<FieldValueInfo> fieldValueInfos) {
-        assertNotNull(fieldValueInfos, "fieldValueInfos can't be null");
+        assertNotNull(fieldValueInfos, () -> "fieldValueInfos can't be null");
         this.completeValueType = completeValueType;
         this.fieldValue = fieldValue;
         this.fieldValueInfos = fieldValueInfos;
@@ -78,7 +78,7 @@ public Builder fieldValue(CompletableFuture<ExecutionResult> executionResultFutu
         }
 
         public Builder fieldValueInfos(List<FieldValueInfo> listInfos) {
-            assertNotNull(listInfos, "fieldValueInfos can't be null");
+            assertNotNull(listInfos, () -> "fieldValueInfos can't be null");
             this.listInfos = listInfos;
             return this;
         }

File: src/main/java/graphql/execution/SubscriptionExecutionStrategy.java
Patch:
@@ -71,7 +71,7 @@ private CompletableFuture<Publisher<Object>> createSourceEventStream(ExecutionCo
         return fieldFetched.thenApply(fetchedValue -> {
             Object publisher = fetchedValue.getFetchedValue();
             if (publisher != null) {
-                assertTrue(publisher instanceof Publisher, "You data fetcher must return a Publisher of events when using graphql subscriptions");
+                assertTrue(publisher instanceof Publisher, () -> "Your data fetcher must return a Publisher of events when using graphql subscriptions");
             }
             //noinspection unchecked
             return (Publisher<Object>) publisher;

File: src/main/java/graphql/execution/nextgen/BatchedExecutionStrategy.java
Patch:
@@ -66,7 +66,7 @@ private CompletableFuture<NodeMultiZipper<ExecutionResultNode>> nextStep(Executi
 
     // all multizipper have the same root
     private CompletableFuture<NodeMultiZipper<ExecutionResultNode>> resolveNodes(ExecutionContext executionContext, List<NodeMultiZipper<ExecutionResultNode>> unresolvedNodes) {
-        assertNotEmpty(unresolvedNodes, "unresolvedNodes can't be empty");
+        assertNotEmpty(unresolvedNodes, () -> "unresolvedNodes can't be empty");
         ExecutionResultNode commonRoot = unresolvedNodes.get(0).getCommonRoot();
         CompletableFuture<List<List<NodeZipper<ExecutionResultNode>>>> listListCF = Async.flatMap(unresolvedNodes,
                 executionResultMultiZipper -> fetchAndAnalyze(executionContext, executionResultMultiZipper.getZippers()));
@@ -81,7 +81,7 @@ private List<NodeMultiZipper<ExecutionResultNode>> groupNodesIntoBatches(NodeMul
     }
 
     private CompletableFuture<List<NodeZipper<ExecutionResultNode>>> fetchAndAnalyze(ExecutionContext executionContext, List<NodeZipper<ExecutionResultNode>> unresolvedNodes) {
-        assertTrue(unresolvedNodes.size() > 0, "unresolvedNodes can't be empty");
+        assertTrue(unresolvedNodes.size() > 0, () -> "unresolvedNodes can't be empty");
 
         List<FieldSubSelection> fieldSubSelections = map(unresolvedNodes,
                 node -> util.createFieldSubSelection(executionContext, node.getCurNode().getExecutionStepInfo(), node.getCurNode().getResolvedValue()));

File: src/main/java/graphql/execution/nextgen/ValueFetcher.java
Patch:
@@ -76,7 +76,7 @@ public CompletableFuture<List<FetchedValue>> fetchBatchedValues(ExecutionContext
     @SuppressWarnings("unchecked")
     private List<FetchedValue> extractBatchedValues(FetchedValue fetchedValueContainingList, int expectedSize) {
         List<Object> list = (List<Object>) fetchedValueContainingList.getFetchedValue();
-        Assert.assertTrue(list.size() == expectedSize, "Unexpected result size");
+        Assert.assertTrue(list.size() == expectedSize, () -> "Unexpected result size");
         List<FetchedValue> result = new ArrayList<>();
         for (int i = 0; i < list.size(); i++) {
             List<GraphQLError> errors;

File: src/main/java/graphql/execution/nextgen/result/ResultNodeAdapter.java
Patch:
@@ -38,7 +38,7 @@ public ExecutionResultNode withNewChildren(ExecutionResultNode parentNode, Map<S
     public ExecutionResultNode removeChild(ExecutionResultNode parentNode, NodeLocation location) {
         int index = location.getIndex();
         List<ExecutionResultNode> childrenList = new ArrayList<>(parentNode.getChildren());
-        assertTrue(index >= 0 && index < childrenList.size(), "The remove index MUST be within the range of the children");
+        assertTrue(index >= 0 && index < childrenList.size(), () -> "The remove index MUST be within the range of the children");
         childrenList.remove(index);
         return parentNode.withNewChildren(childrenList);
     }

File: src/main/java/graphql/execution/reactive/NonBlockingMutexExecutor.java
Patch:
@@ -37,7 +37,7 @@ class NonBlockingMutexExecutor implements Executor {
 
     @Override
     public void execute(final Runnable command) {
-        final RunNode newNode = new RunNode(assertNotNull(command, "Runnable must not be null"));
+        final RunNode newNode = new RunNode(assertNotNull(command, () -> "Runnable must not be null"));
         final RunNode prevLast = last.getAndSet(newNode);
         if (prevLast != null)
             prevLast.lazySet(newNode);

File: src/main/java/graphql/execution/reactive/SingleSubscriberPublisher.java
Patch:
@@ -102,7 +102,7 @@ private void handleOnComplete() {
 
     @Override
     public void subscribe(Subscriber<? super T> subscriber) {
-        assertNotNullWithNPE(subscriber, "Subscriber passed to subscribe must not be null");
+        assertNotNullWithNPE(subscriber, () -> "Subscriber passed to subscribe must not be null");
         mutex.execute(() -> {
             if (this.subscriber == null) {
                 this.subscriber = subscriber;

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -550,7 +550,6 @@ public enum DirectiveLocation {
      * @param schema     the schema to use
      * @param parentType the type of the parent object
      * @param fieldName  the field to look up
-     *
      * @return a field definition otherwise throws an assertion exception if its null
      */
     public static GraphQLFieldDefinition getFieldDef(GraphQLSchema schema, GraphQLCompositeType parentType, String fieldName) {
@@ -567,10 +566,10 @@ public static GraphQLFieldDefinition getFieldDef(GraphQLSchema schema, GraphQLCo
             return TypeNameMetaFieldDef;
         }
 
-        assertTrue(parentType instanceof GraphQLFieldsContainer, "should not happen : parent type must be an object or interface %s", parentType);
+        assertTrue(parentType instanceof GraphQLFieldsContainer, () -> String.format("should not happen : parent type must be an object or interface %s", parentType));
         GraphQLFieldsContainer fieldsContainer = (GraphQLFieldsContainer) parentType;
         GraphQLFieldDefinition fieldDefinition = schema.getCodeRegistry().getFieldVisibility().getFieldDefinition(fieldsContainer, fieldName);
-        Assert.assertTrue(fieldDefinition != null, "Unknown field '%s'", fieldName);
+        Assert.assertTrue(fieldDefinition != null, () -> String.format("Unknown field '%s'", fieldName));
         return fieldDefinition;
     }
 }

File: src/main/java/graphql/language/AbstractNode.java
Patch:
@@ -27,9 +27,9 @@ public AbstractNode(SourceLocation sourceLocation, List<Comment> comments, Ignor
     }
 
     public AbstractNode(SourceLocation sourceLocation, List<Comment> comments, IgnoredChars ignoredChars, Map<String, String> additionalData) {
-        Assert.assertNotNull(comments, "comments can't be null");
-        Assert.assertNotNull(ignoredChars, "ignoredChars can't be null");
-        Assert.assertNotNull(additionalData, "additionalData can't be null");
+        Assert.assertNotNull(comments, () -> "comments can't be null");
+        Assert.assertNotNull(ignoredChars, () -> "ignoredChars can't be null");
+        Assert.assertNotNull(additionalData, () -> "additionalData can't be null");
 
         this.sourceLocation = sourceLocation;
         this.additionalData = unmodifiableMap(new LinkedHashMap<>(additionalData));

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -417,7 +417,7 @@ private String node(Node node) {
 
     private String node(Node node, Class startClass) {
         if (startClass != null) {
-            assertTrue(startClass.isInstance(node), "The starting class must be in the inherit tree");
+            assertTrue(startClass.isInstance(node), () -> "The starting class must be in the inherit tree");
         }
         StringWriter sw = new StringWriter();
         PrintWriter out = new PrintWriter(sw);

File: src/main/java/graphql/language/NodeParentTree.java
Patch:
@@ -28,8 +28,8 @@ public class NodeParentTree<T extends Node> {
 
     @Internal
     public NodeParentTree(Deque<T> nodeStack) {
-        assertNotNull(nodeStack, "You MUST have a non null stack of nodes");
-        assertTrue(!nodeStack.isEmpty(), "You MUST have a non empty stack of nodes");
+        assertNotNull(nodeStack, () -> "You MUST have a non null stack of nodes");
+        assertTrue(!nodeStack.isEmpty(), () -> "You MUST have a non empty stack of nodes");
 
         Deque<T> copy = new ArrayDeque<>(nodeStack);
         path = mkPath(copy);

File: src/main/java/graphql/relay/DefaultConnection.java
Patch:
@@ -26,8 +26,8 @@ public class DefaultConnection<T> implements Connection<T> {
      * @throws IllegalArgumentException if edges or page info is null. use {@link Collections#emptyList()} for empty edges.
      */
     public DefaultConnection(List<Edge<T>> edges, PageInfo pageInfo) {
-        this.edges = unmodifiableList(assertNotNull(edges, "edges cannot be null"));
-        this.pageInfo = assertNotNull(pageInfo, "page info cannot be null");
+        this.edges = unmodifiableList(assertNotNull(edges, () -> "edges cannot be null"));
+        this.pageInfo = assertNotNull(pageInfo, () -> "page info cannot be null");
     }
 
     @Override

File: src/main/java/graphql/relay/DefaultConnectionCursor.java
Patch:
@@ -11,7 +11,7 @@ public class DefaultConnectionCursor implements ConnectionCursor {
     private final String value;
 
     public DefaultConnectionCursor(String value) {
-        Assert.assertTrue(value != null && !value.isEmpty(), "connection value cannot be null or empty");
+        Assert.assertTrue(value != null && !value.isEmpty(), () -> "connection value cannot be null or empty");
         this.value = value;
     }
 

File: src/main/java/graphql/relay/DefaultEdge.java
Patch:
@@ -11,7 +11,7 @@ public class DefaultEdge<T> implements Edge<T> {
     private final ConnectionCursor cursor;
 
     public DefaultEdge(T node, ConnectionCursor cursor) {
-        this.cursor = assertNotNull(cursor, "cursor cannot be null");
+        this.cursor = assertNotNull(cursor, () -> "cursor cannot be null");
         this.node = node;
     }
 

File: src/main/java/graphql/relay/SimpleListConnection.java
Patch:
@@ -24,8 +24,8 @@ public class SimpleListConnection<T> implements DataFetcher<Connection<T>>, Triv
     private final List<T> data;
 
     public SimpleListConnection(List<T> data, String prefix) {
-        this.data = assertNotNull(data, " data cannot be null");
-        assertTrue(prefix != null && !prefix.isEmpty(), "prefix cannot be null or empty");
+        this.data = assertNotNull(data, () -> " data cannot be null");
+        assertTrue(prefix != null && !prefix.isEmpty(), () -> "prefix cannot be null or empty");
         this.prefix = prefix;
     }
 

File: src/main/java/graphql/schema/AsyncDataFetcher.java
Patch:
@@ -58,8 +58,8 @@ public AsyncDataFetcher(DataFetcher<T> wrappedDataFetcher) {
     }
 
     public AsyncDataFetcher(DataFetcher<T> wrappedDataFetcher, Executor executor) {
-        this.wrappedDataFetcher = assertNotNull(wrappedDataFetcher, "wrappedDataFetcher can't be null");
-        this.executor = assertNotNull(executor, "executor can't be null");
+        this.wrappedDataFetcher = assertNotNull(wrappedDataFetcher, () -> "wrappedDataFetcher can't be null");
+        this.executor = assertNotNull(executor, () -> "executor can't be null");
     }
 
     @Override

File: src/main/java/graphql/schema/FieldCoordinates.java
Patch:
@@ -44,7 +44,7 @@ public String getFieldName() {
     public void assertValidNames() throws AssertException {
         if (systemCoordinates) {
             assertTrue((null != fieldName) &&
-                    fieldName.startsWith("__"), "Only __ system fields can be addressed without a parent type");
+                    fieldName.startsWith("__"), () -> "Only __ system fields can be addressed without a parent type");
             assertValidName(fieldName);
         } else {
             assertValidName(typeName);

File: src/main/java/graphql/schema/GraphQLCodeRegistry.java
Patch:
@@ -124,7 +124,7 @@ private static TypeResolver getTypeResolverForInterface(GraphQLInterfaceType par
         if (typeResolver == null) {
             typeResolver = parentType.getTypeResolver();
         }
-        return assertNotNull(typeResolver, "There must be a type resolver for interface " + parentType.getName());
+        return assertNotNull(typeResolver, () -> "There must be a type resolver for interface " + parentType.getName());
     }
 
     private static TypeResolver getTypeResolverForUnion(GraphQLUnionType parentType, Map<String, TypeResolver> typeResolverMap) {
@@ -133,7 +133,7 @@ private static TypeResolver getTypeResolverForUnion(GraphQLUnionType parentType,
         if (typeResolver == null) {
             typeResolver = parentType.getTypeResolver();
         }
-        return assertNotNull(typeResolver, "There must be a type resolver for union " + parentType.getName());
+        return assertNotNull(typeResolver, () -> "There must be a type resolver for union " + parentType.getName());
     }
 
     /**

File: src/main/java/graphql/schema/GraphQLDirective.java
Patch:
@@ -55,7 +55,7 @@ private GraphQLDirective(String name,
                              List<GraphQLArgument> arguments,
                              DirectiveDefinition definition) {
         assertValidName(name);
-        assertNotNull(arguments, "arguments can't be null");
+        assertNotNull(arguments, () -> "arguments can't be null");
         this.name = name;
         this.description = description;
         this.locations = locations;
@@ -199,13 +199,13 @@ public Builder clearValidLocations() {
         }
 
         public Builder argument(GraphQLArgument argument) {
-            assertNotNull(argument, "argument must not be null");
+            assertNotNull(argument, () -> "argument must not be null");
             arguments.put(argument.getName(), argument);
             return this;
         }
 
         public Builder replaceArguments(List<GraphQLArgument> arguments) {
-            assertNotNull(arguments, "arguments must not be null");
+            assertNotNull(arguments, () -> "arguments must not be null");
             this.arguments.clear();
             for (GraphQLArgument argument : arguments) {
                 this.arguments.put(argument.getName(), argument);

File: src/main/java/graphql/schema/GraphQLList.java
Patch:
@@ -40,7 +40,7 @@ public static GraphQLList list(GraphQLType wrappedType) {
 
 
     public GraphQLList(GraphQLType wrappedType) {
-        assertNotNull(wrappedType, "wrappedType can't be null");
+        assertNotNull(wrappedType, () -> "wrappedType can't be null");
         this.originalWrappedType = wrappedType;
     }
 

File: src/main/java/graphql/schema/GraphQLTypeResolvingVisitor.java
Patch:
@@ -43,7 +43,7 @@ public TraversalControl visitGraphQLTypeReference(GraphQLTypeReference node, Tra
 
     public TraversalControl handleTypeReference(GraphQLTypeReference node, TraverserContext<GraphQLSchemaElement> context) {
         final GraphQLType resolvedType = typeMap.get(node.getName());
-        assertNotNull(resolvedType, "type %s not found in schema", node.getName());
+        assertNotNull(resolvedType, () -> String.format("type %s not found in schema", node.getName()));
         context.getParentContext().thisNode().accept(context, new TypeRefResolvingVisitor(resolvedType));
         return CONTINUE;
     }

File: src/main/java/graphql/schema/GraphqlElementParentTree.java
Patch:
@@ -25,8 +25,8 @@ public class GraphqlElementParentTree {
 
     @Internal
     public GraphqlElementParentTree(Deque<GraphQLSchemaElement> nodeStack) {
-        assertNotNull(nodeStack, "You MUST have a non null stack of elements");
-        assertTrue(!nodeStack.isEmpty(), "You MUST have a non empty stack of element");
+        assertNotNull(nodeStack, () -> "You MUST have a non null stack of elements");
+        assertTrue(!nodeStack.isEmpty(), () -> "You MUST have a non empty stack of element");
 
         Deque<GraphQLSchemaElement> copy = new ArrayDeque<>(nodeStack);
         element = copy.pop();

File: src/main/java/graphql/schema/GraphqlTypeComparatorEnvironment.java
Patch:
@@ -19,7 +19,7 @@ public class GraphqlTypeComparatorEnvironment {
     private Class<? extends GraphQLSchemaElement> elementType;
 
     private GraphqlTypeComparatorEnvironment(Class<? extends GraphQLSchemaElement> parentType, Class<? extends GraphQLSchemaElement> elementType) {
-        Assert.assertNotNull(elementType, "elementType can't be null");
+        Assert.assertNotNull(elementType, () -> "elementType can't be null");
         this.parentType = parentType;
         this.elementType = elementType;
     }

File: src/main/java/graphql/schema/SchemaTransformer.java
Patch:
@@ -287,7 +287,7 @@ private NodeZipper<GraphQLSchemaElement> moveUp(
             GraphQLSchemaElement parent,
             List<NodeZipper<GraphQLSchemaElement>> sameParent,
             Map<NodeZipper<GraphQLSchemaElement>, List<List<Breadcrumb<GraphQLSchemaElement>>>> breadcrumbsUsed) {
-        assertNotEmpty(sameParent, "expected at least one zipper");
+        assertNotEmpty(sameParent, () -> "expected at least one zipper");
 
         Map<String, List<GraphQLSchemaElement>> childrenMap = new HashMap<>(SCHEMA_ELEMENT_ADAPTER.getNamedChildren(parent));
         Map<String, Integer> indexCorrection = new HashMap<>();

File: src/main/java/graphql/schema/diff/DiffSet.java
Patch:
@@ -69,7 +69,7 @@ public static DiffSet diffSet(GraphQLSchema schemaOld, GraphQLSchema schemaNew)
     private static Map<String, Object> introspect(GraphQLSchema schema) {
         GraphQL gql = GraphQL.newGraphQL(schema).build();
         ExecutionResult result = gql.execute(IntrospectionQuery.INTROSPECTION_QUERY);
-        Assert.assertTrue(result.getErrors().size() == 0, "The schema has errors during Introspection");
+        Assert.assertTrue(result.getErrors().size() == 0, () -> "The schema has errors during Introspection");
         return result.getData();
     }
 }

File: src/main/java/graphql/schema/idl/CombinedWiringFactory.java
Patch:
@@ -19,7 +19,7 @@ public class CombinedWiringFactory implements WiringFactory {
     private final List<WiringFactory> factories;
 
     public CombinedWiringFactory(List<WiringFactory> factories) {
-        assertNotNull(factories, "You must provide a list of wiring factories");
+        assertNotNull(factories, () -> "You must provide a list of wiring factories");
         this.factories = new ArrayList<>(factories);
     }
 

File: src/main/java/graphql/schema/idl/MapEnumValuesProvider.java
Patch:
@@ -12,7 +12,7 @@ public class MapEnumValuesProvider implements EnumValuesProvider {
     private final Map<String, Object> values;
 
     public MapEnumValuesProvider(Map<String, Object> values) {
-        Assert.assertNotNull(values, "values can't be null");
+        Assert.assertNotNull(values, () -> "values can't be null");
         this.values = values;
     }
 

File: src/main/java/graphql/schema/idl/NaturalEnumValuesProvider.java
Patch:
@@ -13,7 +13,7 @@ public class NaturalEnumValuesProvider<T extends Enum<T>> implements EnumValuesP
     private final Class<T> enumType;
 
     public NaturalEnumValuesProvider(Class<T> enumType) {
-        Assert.assertNotNull(enumType, "enumType can't be null");
+        Assert.assertNotNull(enumType, () -> "enumType can't be null");
         this.enumType = enumType;
     }
 

File: src/main/java/graphql/schema/idl/RuntimeWiring.java
Patch:
@@ -142,7 +142,7 @@ private Builder() {
          * @return this outer builder
          */
         public Builder wiringFactory(WiringFactory wiringFactory) {
-            assertNotNull(wiringFactory, "You must provide a wiring factory");
+            assertNotNull(wiringFactory, () -> "You must provide a wiring factory");
             this.wiringFactory = wiringFactory;
             return this;
         }

File: src/main/java/graphql/schema/idl/SchemaExtensionsChecker.java
Patch:
@@ -30,7 +30,7 @@ public class SchemaExtensionsChecker {
     static Map<String, OperationTypeDefinition> gatherOperationDefs(TypeDefinitionRegistry typeRegistry) {
         List<GraphQLError> noErrors = new ArrayList<>();
         Map<String, OperationTypeDefinition> operationTypeDefinitionMap = gatherOperationDefs(noErrors, typeRegistry.schemaDefinition().orElse(null), typeRegistry.getSchemaExtensionDefinitions());
-        Assert.assertTrue(noErrors.isEmpty(), "If you call this method it MUST have previously been error checked");
+        Assert.assertTrue(noErrors.isEmpty(), () -> "If you call this method it MUST have previously been error checked");
         return operationTypeDefinitionMap;
     }
 
@@ -89,7 +89,7 @@ static List<OperationTypeDefinition> checkSchemaInvariants(List<GraphQLError> er
     static List<Directive> gatherSchemaDirectives(TypeDefinitionRegistry typeRegistry) {
         List<GraphQLError> noErrors = new ArrayList<>();
         List<Directive> directiveList = gatherSchemaDirectives(typeRegistry, noErrors);
-        Assert.assertTrue(noErrors.isEmpty(), "If you call this method it MUST have previously been error checked");
+        Assert.assertTrue(noErrors.isEmpty(), () -> "If you call this method it MUST have previously been error checked");
         return directiveList;
     }
 

File: src/main/java/graphql/schema/idl/SchemaGeneratorDirectiveHelper.java
Patch:
@@ -307,7 +307,7 @@ private <T extends GraphQLDirectiveContainer> T wireDirectives(
         // wiring factory is last (if present)
         env = envBuilder.apply(outputObject, allDirectives, null);
         if (wiringFactory.providesSchemaDirectiveWiring(env)) {
-            schemaDirectiveWiring = assertNotNull(wiringFactory.getSchemaDirectiveWiring(env), "Your WiringFactory MUST provide a non null SchemaDirectiveWiring");
+            schemaDirectiveWiring = assertNotNull(wiringFactory.getSchemaDirectiveWiring(env), () -> "Your WiringFactory MUST provide a non null SchemaDirectiveWiring");
             outputObject = invokeWiring(outputObject, invoker, schemaDirectiveWiring, env);
         }
 
@@ -316,7 +316,7 @@ private <T extends GraphQLDirectiveContainer> T wireDirectives(
 
     private <T extends GraphQLDirectiveContainer> T invokeWiring(T element, EnvInvoker<T> invoker, SchemaDirectiveWiring schemaDirectiveWiring, SchemaDirectiveWiringEnvironment<T> env) {
         T newElement = invoker.apply(schemaDirectiveWiring, env);
-        assertNotNull(newElement, "The SchemaDirectiveWiring MUST return a non null return value for element '" + element.getName() + "'");
+        assertNotNull(newElement, () -> "The SchemaDirectiveWiring MUST return a non null return value for element '" + element.getName() + "'");
         return newElement;
     }
 }

File: src/main/java/graphql/schema/idl/TypeInfo.java
Patch:
@@ -30,7 +30,7 @@ public static TypeInfo typeInfo(Type type) {
     private final Stack<Class<?>> decoration = new Stack<>();
 
     private TypeInfo(Type type) {
-        this.rawType = assertNotNull(type, "type must not be null");
+        this.rawType = assertNotNull(type, () -> "type must not be null");
         while (!(type instanceof TypeName)) {
             if (type instanceof NonNullType) {
                 decoration.push(NonNullType.class);

File: src/main/java/graphql/schema/validation/SchemaValidationError.java
Patch:
@@ -8,8 +8,8 @@ public class SchemaValidationError {
     private final String description;
 
     public SchemaValidationError(SchemaValidationErrorType errorType, String description) {
-        assertNotNull(errorType, "error type can not be null");
-        assertNotNull(description, "error description can not be null");
+        assertNotNull(errorType, () -> "error type can not be null");
+        assertNotNull(description, () -> "error description can not be null");
         this.errorType = errorType;
         this.description = description;
     }

File: src/main/java/graphql/util/TraverserState.java
Patch:
@@ -44,7 +44,7 @@ public void pushAll(TraverserContext<U> traverserContext, Function<? super U, Ma
                 childrenMap.keySet().forEach(key -> {
                     List<U> children = childrenMap.get(key);
                     for (int i = children.size() - 1; i >= 0; i--) {
-                        U child = assertNotNull(children.get(i), "null child for key " + key);
+                        U child = assertNotNull(children.get(i), () -> "null child for key " + key);
                         NodeLocation nodeLocation = new NodeLocation(key, i);
                         DefaultTraverserContext<U> context = super.newContext(child, traverserContext, nodeLocation);
                         super.state.push(context);
@@ -72,7 +72,7 @@ public void pushAll(TraverserContext<U> traverserContext, Function<? super U, Ma
                 childrenMap.keySet().forEach(key -> {
                     List<U> children = childrenMap.get(key);
                     for (int i = 0; i < children.size(); i++) {
-                        U child = assertNotNull(children.get(i), "null child for key " + key);
+                        U child = assertNotNull(children.get(i), () -> "null child for key " + key);
                         NodeLocation nodeLocation = new NodeLocation(key, i);
                         DefaultTraverserContext<U> context = super.newContext(child, traverserContext, nodeLocation);
                         childrenContextMap.computeIfAbsent(key, notUsed -> new ArrayList<>());

File: src/main/java/graphql/util/TreeParallelTraverser.java
Patch:
@@ -131,8 +131,8 @@ private EnterAction(CountedCompleter parent, DefaultTraverserContext currentCont
         public void compute() {
             currentContext.setPhase(TraverserContext.Phase.ENTER);
             TraversalControl traversalControl = visitor.enter(currentContext);
-            assertNotNull(traversalControl, "result of enter must not be null");
-            assertTrue(QUIT != traversalControl, "can't return QUIT for parallel traversing");
+            assertNotNull(traversalControl, () -> "result of enter must not be null");
+            assertTrue(QUIT != traversalControl, () -> "can't return QUIT for parallel traversing");
             if (traversalControl == ABORT) {
                 tryComplete();
                 return;
@@ -162,7 +162,7 @@ private List<DefaultTraverserContext> pushAll(TraverserContext<T> traverserConte
             childrenMap.keySet().forEach(key -> {
                 List<T> children = childrenMap.get(key);
                 for (int i = children.size() - 1; i >= 0; i--) {
-                    T child = assertNotNull(children.get(i), "null child for key %s", key);
+                    T child = assertNotNull(children.get(i), () -> String.format("null child for key %s", key));
                     NodeLocation nodeLocation = new NodeLocation(key, i);
                     DefaultTraverserContext<T> context = newContext(child, traverserContext, nodeLocation);
                     contexts.push(context);

File: src/main/java/graphql/util/TreeTransformerUtil.java
Patch:
@@ -50,7 +50,7 @@ public static <T> TraversalControl changeNode(TraverserContext<T> context, T cha
 
     private static <T> void replaceZipperForNode(List<NodeZipper<T>> zippers, T currentNode, T newNode) {
         int index = FpKit.findIndex(zippers, zipper -> zipper.getCurNode() == currentNode);
-        assertTrue(index >= 0, "No current zipper found for provided node");
+        assertTrue(index >= 0, () -> "No current zipper found for provided node");
         NodeZipper<T> newZipper = zippers.get(index).withNewNode(newNode);
         zippers.set(index, newZipper);
     }

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -87,6 +87,7 @@ public CompletableFuture<ExecutionResult> execute(Document document, GraphQLSche
                 .mutationStrategy(mutationStrategy)
                 .subscriptionStrategy(subscriptionStrategy)
                 .context(executionInput.getContext())
+                .localContext(executionInput.getLocalContext())
                 .root(executionInput.getRoot())
                 .fragmentsByName(fragmentsByName)
                 .variables(coercedVariables)
@@ -145,7 +146,7 @@ private CompletableFuture<ExecutionResult> executeOperation(ExecutionContext exe
         ExecutionStrategyParameters parameters = newParameters()
                 .executionStepInfo(executionStepInfo)
                 .source(root)
-                .localContext(null) // this is important to default as this
+                .localContext(executionContext.getLocalContext())
                 .fields(fields)
                 .nonNullFieldValidator(nonNullableFieldValidator)
                 .path(path)

File: src/main/java/graphql/validation/rules/VariablesTypesMatcher.java
Patch:
@@ -2,6 +2,7 @@
 
 
 import graphql.Internal;
+import graphql.language.NullValue;
 import graphql.language.Value;
 import graphql.schema.GraphQLType;
 
@@ -18,7 +19,7 @@ public boolean doesVariableTypesMatch(GraphQLType variableType, Value variableDe
     }
 
     public GraphQLType effectiveType(GraphQLType variableType, Value defaultValue) {
-        if (defaultValue == null) {
+        if (defaultValue == null || defaultValue instanceof NullValue) {
             return variableType;
         }
         if (isNonNull(variableType)) {

File: src/main/java/graphql/validation/Validator.java
Patch:
@@ -50,7 +50,7 @@ public List<ValidationError> validateDocument(GraphQLSchema schema, Document doc
         return validationErrorCollector.getErrors();
     }
 
-    private List<AbstractRule> createRules(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+    public List<AbstractRule> createRules(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
         List<AbstractRule> rules = new ArrayList<>();
 
         ExecutableDefinitions executableDefinitions = new ExecutableDefinitions(validationContext, validationErrorCollector);

File: src/main/java/graphql/language/ImplementingTypeDefinition.java
Patch:
@@ -11,7 +11,7 @@
  * @param <T>
  */
 @PublicApi
-public interface ImplementingTypeDefinition<T extends ImplementingTypeDefinition> extends TypeDefinition<T> {
+public interface ImplementingTypeDefinition<T extends TypeDefinition> extends TypeDefinition<T> {
 
     List<Type> getImplements();
 

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -60,6 +60,7 @@
 import graphql.language.VariableReference;
 import graphql.parser.antlr.GraphqlLexer;
 import graphql.parser.antlr.GraphqlParser;
+import graphql.util.FpKit;
 import org.antlr.v4.runtime.CommonTokenStream;
 import org.antlr.v4.runtime.ParserRuleContext;
 import org.antlr.v4.runtime.Token;
@@ -882,7 +883,8 @@ protected List<Comment> getCommentOnChannel(List<Token> refChannel) {
     private List<Type> getImplementz(GraphqlParser.ImplementsInterfacesContext implementsInterfacesContext) {
         List<Type> implementz = new ArrayList<>();
         while (implementsInterfacesContext != null) {
-            List<TypeName> typeNames = implementsInterfacesContext.typeName().stream().map(this::createTypeName).collect(toList());
+            List<TypeName> typeNames = FpKit.map(implementsInterfacesContext.typeName(), this::createTypeName);
+
             implementz.addAll(0, typeNames);
             implementsInterfacesContext = implementsInterfacesContext.implementsInterfaces();
         }

File: src/main/java/graphql/schema/DataFetchingEnvironmentImpl.java
Patch:
@@ -89,7 +89,6 @@ public static Builder newDataFetchingEnvironment(ExecutionContext executionConte
                 .dataLoaderRegistry(executionContext.getDataLoaderRegistry())
                 .cacheControl(executionContext.getCacheControl())
                 .locale(executionContext.getLocale())
-                .locale(executionContext.getLocale())
                 .document(executionContext.getDocument())
                 .operationDefinition(executionContext.getOperationDefinition())
                 .variables(executionContext.getVariables())
@@ -279,7 +278,7 @@ public Builder(DataFetchingEnvironmentImpl env) {
             this.executionStepInfo = env.executionStepInfo;
             this.dataLoaderRegistry = env.dataLoaderRegistry;
             this.cacheControl = env.cacheControl;
-            this.localContext = env.locale;
+            this.locale = env.locale;
             this.operationDefinition = env.operationDefinition;
             this.document = env.document;
             this.variables = env.variables;

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -150,14 +150,12 @@ protected FragmentSpread createFragmentSpread(GraphqlParser.FragmentSpreadContex
         fragmentSpread.directives(createDirectives(ctx.directives()));
         return fragmentSpread.build();
     }
-
     protected List<VariableDefinition> createVariableDefinitions(GraphqlParser.VariableDefinitionsContext ctx) {
         if (ctx == null) {
             return new ArrayList<>();
         }
         return ctx.variableDefinition().stream().map(this::createVariableDefinition).collect(toList());
     }
-
     protected VariableDefinition createVariableDefinition(GraphqlParser.VariableDefinitionContext ctx) {
         VariableDefinition.Builder variableDefinition = VariableDefinition.newVariableDefinition();
         addCommonData(variableDefinition, ctx);
@@ -167,6 +165,7 @@ protected VariableDefinition createVariableDefinition(GraphqlParser.VariableDefi
             variableDefinition.defaultValue(value);
         }
         variableDefinition.type(createType(ctx.type()));
+        variableDefinition.directives(createDirectives(ctx.directives()));
         return variableDefinition.build();
 
     }

File: src/main/java/graphql/validation/ValidationErrorType.java
Patch:
@@ -35,5 +35,6 @@ public enum ValidationErrorType {
     DeferDirectiveOnNonNullField,
     DeferDirectiveNotOnQueryOperation,
     DeferMustBeOnAllFields,
-    DuplicateArgumentNames
+    DuplicateArgumentNames,
+    DuplicateVariableName
 }

File: src/main/java/graphql/Directives.java
Patch:
@@ -76,11 +76,11 @@ public class Directives {
      */
     public static final GraphQLDirective SpecifiedByDirective = GraphQLDirective.newDirective()
             .name("specifiedBy")
-            .description("Specification details for a custom Scalar")
+            .description("Exposes a URL that specifies the behaviour of this scalar.")
             .argument(newArgument()
                     .name("url")
                     .type(nonNull(GraphQLString))
-                    .description("An URL which specifies the custom Scalar"))
+                    .description("The URL that specifies the behaviour of this scalar."))
             .validLocations(SCALAR)
             .build();
 

File: src/main/java/graphql/schema/idl/errors/MissingTransitiveInterfaceError.java
Patch:
@@ -9,8 +9,8 @@
 import static java.util.stream.Collectors.joining;
 
 public class MissingTransitiveInterfaceError extends BaseError {
-    public MissingTransitiveInterfaceError(String typeOfType, ImplementingTypeDefinition typeDefinition, InterfaceTypeDefinition implementedInterface, Collection<InterfaceTypeDefinition> missingInterfaces) {
-        super(typeDefinition, format("The %s type '%s' %s must implement %s because it is implemented by '%s' %s",
-                typeOfType, typeDefinition.getName(), lineCol(typeDefinition), "[" + missingInterfaces.stream().map(InterfaceTypeDefinition::getName).collect(joining()) + "]", implementedInterface.getName(), lineCol(implementedInterface)));
+    public MissingTransitiveInterfaceError(String typeOfType, ImplementingTypeDefinition typeDefinition, InterfaceTypeDefinition implementedInterface, InterfaceTypeDefinition missingInterface) {
+        super(typeDefinition, format("The %s type '%s' %s must implement '%s' %s because it is implemented by '%s' %s",
+                typeOfType, typeDefinition.getName(), lineCol(typeDefinition), missingInterface.getName(), lineCol(missingInterface), implementedInterface.getName(), lineCol(implementedInterface)));
     }
 }

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -292,7 +292,7 @@ private Object coerceValueAstForInputObject(GraphqlFieldVisibility fieldVisibili
                 }
 
                 if (fieldObject == null) {
-                    if (!field.getValue().isEqualTo(NullValue.Null)) {
+                    if (! (field.getValue() instanceof NullValue)) {
                         fieldObject = inputTypeField.getDefaultValue();
                     }
                 }

File: src/main/java/graphql/language/NullValue.java
Patch:
@@ -21,8 +21,6 @@
 @PublicApi
 public class NullValue extends AbstractNode<NullValue> implements Value<NullValue> {
 
-    public static final NullValue Null = new NullValue(null, Collections.emptyList(), IgnoredChars.EMPTY, emptyMap());
-
     @Internal
     protected NullValue(SourceLocation sourceLocation, List<Comment> comments, IgnoredChars ignoredChars, Map<String, String> additionalData) {
         super(sourceLocation, comments, ignoredChars, additionalData);

File: src/main/java/graphql/schema/PropertyDataFetcherHelper.java
Patch:
@@ -252,7 +252,7 @@ private static String mkKey(Object object, String propertyName) {
     }
 
     private static String mkKey(Class<?> clazz, String propertyName) {
-        return clazz.getCanonicalName() + "__" + propertyName;
+        return clazz.getName() + "__" + propertyName;
     }
 
     // by not filling out the stack trace, we gain speed when using the exception as flow control

File: src/main/java/graphql/introspection/IntrospectionResultToSchema.java
Patch:
@@ -132,7 +132,7 @@ private TypeDefinition createTypeDefinition(Map<String, Object> type) {
 
     private TypeDefinition createScalar(Map<String, Object> input) {
         String name = (String) input.get("name");
-        if (ScalarInfo.isStandardScalar(name)) {
+        if (ScalarInfo.isGraphqlSpecifiedScalar(name)) {
             return null;
         }
         return ScalarTypeDefinition.newScalarTypeDefinition().name(name).build();

File: src/main/java/graphql/schema/idl/RuntimeWiring.java
Patch:
@@ -129,7 +129,7 @@ public static class Builder {
         private GraphqlTypeComparatorRegistry comparatorRegistry = GraphqlTypeComparatorRegistry.AS_IS_REGISTRY;
 
         private Builder() {
-            ScalarInfo.STANDARD_SCALARS.forEach(this::scalar);
+            ScalarInfo.GRAPHQL_SPECIFICATION_SCALARS.forEach(this::scalar);
             // we give this out by default
             registeredDirectiveWiring.put(FetchSchemaDirectiveWiring.FETCH, new FetchSchemaDirectiveWiring());
         }

File: src/main/java/graphql/schema/idl/SchemaGenerator.java
Patch:
@@ -374,7 +374,7 @@ private Set<GraphQLType> buildAdditionalTypes(BuildContext buildCtx) {
             }
         });
         typeRegistry.scalars().values().forEach(scalarTypeDefinition -> {
-            if (ScalarInfo.isStandardScalar(scalarTypeDefinition.getName())) {
+            if (ScalarInfo.isGraphqlSpecifiedScalar(scalarTypeDefinition.getName())) {
                 return;
             }
             if (buildCtx.hasInputType(scalarTypeDefinition) == null && buildCtx.hasOutputType(scalarTypeDefinition) == null) {
@@ -690,7 +690,7 @@ private GraphQLScalarType buildScalar(BuildContext buildCtx, ScalarTypeDefinitio
             scalar = buildCtx.getWiring().getScalars().get(typeDefinition.getName());
         }
 
-        if (!ScalarInfo.isStandardScalar(scalar) && !ScalarInfo.isGraphqlSpecifiedScalar(scalar)) {
+        if (!ScalarInfo.isGraphqlSpecifiedScalar(scalar)) {
             scalar = scalar.transform(builder -> builder
                     .definition(typeDefinition)
                     .comparatorRegistry(buildCtx.getComparatorRegistry())

File: src/main/java/graphql/schema/idl/TypeDefinitionRegistry.java
Patch:
@@ -309,7 +309,7 @@ public Map<String, TypeDefinition> types() {
     }
 
     public Map<String, ScalarTypeDefinition> scalars() {
-        LinkedHashMap<String, ScalarTypeDefinition> scalars = new LinkedHashMap<>(ScalarInfo.STANDARD_SCALAR_DEFINITIONS);
+        LinkedHashMap<String, ScalarTypeDefinition> scalars = new LinkedHashMap<>(ScalarInfo.GRAPHQL_SPECIFICATION_SCALARS_DEFINITIONS);
         scalars.putAll(scalarTypes);
         return scalars;
     }
@@ -364,7 +364,7 @@ public Map<String, DirectiveDefinition> getDirectiveDefinitions() {
 
     public boolean hasType(TypeName typeName) {
         String name = typeName.getName();
-        return types.containsKey(name) || ScalarInfo.STANDARD_SCALAR_DEFINITIONS.containsKey(name) || scalarTypes.containsKey(name) || objectTypeExtensions.containsKey(name);
+        return types.containsKey(name) || ScalarInfo.GRAPHQL_SPECIFICATION_SCALARS_DEFINITIONS.containsKey(name) || scalarTypes.containsKey(name) || objectTypeExtensions.containsKey(name);
     }
 
     public Optional<TypeDefinition> getType(Type type) {

File: src/main/java/graphql/schema/idl/UnExecutableSchemaGenerator.java
Patch:
@@ -19,7 +19,7 @@ public static GraphQLSchema makeUnExecutableSchema(TypeDefinitionRegistry regist
         RuntimeWiring runtimeWiring = EchoingWiringFactory.newEchoingWiring(wiring -> {
             Map<String, ScalarTypeDefinition> scalars = registry.scalars();
             scalars.forEach((name, v) -> {
-                if (!ScalarInfo.isStandardScalar(name)) {
+                if (!ScalarInfo.isGraphqlSpecifiedScalar(name)) {
                     wiring.scalar(fakeScalar(name));
                 }
             });

File: src/main/java/graphql/introspection/IntrospectionResultToSchema.java
Patch:
@@ -132,7 +132,7 @@ private TypeDefinition createTypeDefinition(Map<String, Object> type) {
 
     private TypeDefinition createScalar(Map<String, Object> input) {
         String name = (String) input.get("name");
-        if (ScalarInfo.isStandardScalar(name)) {
+        if (ScalarInfo.isGraphqlSpecifiedScalar(name)) {
             return null;
         }
         return ScalarTypeDefinition.newScalarTypeDefinition().name(name).build();

File: src/main/java/graphql/schema/idl/RuntimeWiring.java
Patch:
@@ -129,7 +129,7 @@ public static class Builder {
         private GraphqlTypeComparatorRegistry comparatorRegistry = GraphqlTypeComparatorRegistry.AS_IS_REGISTRY;
 
         private Builder() {
-            ScalarInfo.STANDARD_SCALARS.forEach(this::scalar);
+            ScalarInfo.GRAPHQL_SPECIFICATION_SCALARS.forEach(this::scalar);
             // we give this out by default
             registeredDirectiveWiring.put(FetchSchemaDirectiveWiring.FETCH, new FetchSchemaDirectiveWiring());
         }

File: src/main/java/graphql/schema/idl/SchemaGenerator.java
Patch:
@@ -714,7 +714,7 @@ private GraphQLScalarType buildScalar(BuildContext buildCtx, ScalarTypeDefinitio
             scalar = buildCtx.getWiring().getScalars().get(typeDefinition.getName());
         }
 
-        if (!ScalarInfo.isStandardScalar(scalar) && !ScalarInfo.isGraphqlSpecifiedScalar(scalar)) {
+        if (!ScalarInfo.isGraphqlSpecifiedScalar(scalar)) {
             scalar = scalar.transform(builder -> builder
                     .definition(typeDefinition)
                     .comparatorRegistry(buildCtx.getComparatorRegistry())

File: src/main/java/graphql/schema/idl/TypeDefinitionRegistry.java
Patch:
@@ -309,7 +309,7 @@ public Map<String, TypeDefinition> types() {
     }
 
     public Map<String, ScalarTypeDefinition> scalars() {
-        LinkedHashMap<String, ScalarTypeDefinition> scalars = new LinkedHashMap<>(ScalarInfo.STANDARD_SCALAR_DEFINITIONS);
+        LinkedHashMap<String, ScalarTypeDefinition> scalars = new LinkedHashMap<>(ScalarInfo.GRAPHQL_SPECIFICATION_SCALARS_DEFINITIONS);
         scalars.putAll(scalarTypes);
         return scalars;
     }
@@ -364,7 +364,7 @@ public Map<String, DirectiveDefinition> getDirectiveDefinitions() {
 
     public boolean hasType(TypeName typeName) {
         String name = typeName.getName();
-        return types.containsKey(name) || ScalarInfo.STANDARD_SCALAR_DEFINITIONS.containsKey(name) || scalarTypes.containsKey(name) || objectTypeExtensions.containsKey(name);
+        return types.containsKey(name) || ScalarInfo.GRAPHQL_SPECIFICATION_SCALARS_DEFINITIONS.containsKey(name) || scalarTypes.containsKey(name) || objectTypeExtensions.containsKey(name);
     }
 
     public Optional<TypeDefinition> getType(Type type) {

File: src/main/java/graphql/schema/idl/UnExecutableSchemaGenerator.java
Patch:
@@ -19,7 +19,7 @@ public static GraphQLSchema makeUnExecutableSchema(TypeDefinitionRegistry regist
         RuntimeWiring runtimeWiring = EchoingWiringFactory.newEchoingWiring(wiring -> {
             Map<String, ScalarTypeDefinition> scalars = registry.scalars();
             scalars.forEach((name, v) -> {
-                if (!ScalarInfo.isStandardScalar(name)) {
+                if (!ScalarInfo.isGraphqlSpecifiedScalar(name)) {
                     wiring.scalar(fakeScalar(name));
                 }
             });

File: src/main/java/graphql/language/DirectiveDefinition.java
Patch:
@@ -17,7 +17,7 @@
 import static java.util.Collections.emptyMap;
 
 @PublicApi
-public class DirectiveDefinition extends AbstractNode<DirectiveDefinition> implements SDLDefinition<DirectiveDefinition>, NamedNode<DirectiveDefinition> {
+public class DirectiveDefinition extends AbstractDescribedNode<DirectiveDefinition> implements SDLDefinition<DirectiveDefinition>, NamedNode<DirectiveDefinition> {
     private final String name;
     private final Description description;
     private final List<InputValueDefinition> inputValueDefinitions;
@@ -35,7 +35,7 @@ protected DirectiveDefinition(String name,
                                   List<Comment> comments,
                                   IgnoredChars ignoredChars,
                                   Map<String, String> additionalData) {
-        super(sourceLocation, comments, ignoredChars, additionalData);
+        super(sourceLocation, comments, ignoredChars, additionalData, description);
         this.name = name;
         this.description = description;
         this.inputValueDefinitions = inputValueDefinitions;

File: src/main/java/graphql/language/EnumTypeDefinition.java
Patch:
@@ -16,7 +16,7 @@
 import static java.util.Collections.emptyMap;
 
 @PublicApi
-public class EnumTypeDefinition extends AbstractNode<EnumTypeDefinition> implements TypeDefinition<EnumTypeDefinition>, DirectivesContainer<EnumTypeDefinition>, NamedNode<EnumTypeDefinition> {
+public class EnumTypeDefinition extends AbstractDescribedNode<EnumTypeDefinition> implements TypeDefinition<EnumTypeDefinition>, DirectivesContainer<EnumTypeDefinition>, NamedNode<EnumTypeDefinition> {
     private final String name;
     private final Description description;
     private final List<EnumValueDefinition> enumValueDefinitions;
@@ -33,7 +33,7 @@ protected EnumTypeDefinition(String name,
                                  SourceLocation sourceLocation,
                                  List<Comment> comments,
                                  IgnoredChars ignoredChars, Map<String, String> additionalData) {
-        super(sourceLocation, comments, ignoredChars, additionalData);
+        super(sourceLocation, comments, ignoredChars, additionalData, description);
         this.name = name;
         this.description = description;
         this.directives = (null == directives) ? new ArrayList<>() : directives;

File: src/main/java/graphql/language/EnumValueDefinition.java
Patch:
@@ -17,7 +17,7 @@
 import static java.util.Collections.emptyMap;
 
 @PublicApi
-public class EnumValueDefinition extends AbstractNode<EnumValueDefinition> implements DirectivesContainer<EnumValueDefinition>, NamedNode<EnumValueDefinition> {
+public class EnumValueDefinition extends AbstractDescribedNode<EnumValueDefinition> implements DirectivesContainer<EnumValueDefinition>, NamedNode<EnumValueDefinition> {
     private final String name;
     private final Description description;
     private final List<Directive> directives;
@@ -31,7 +31,7 @@ protected EnumValueDefinition(String name,
                                   SourceLocation sourceLocation,
                                   List<Comment> comments,
                                   IgnoredChars ignoredChars, Map<String, String> additionalData) {
-        super(sourceLocation, comments, ignoredChars, additionalData);
+        super(sourceLocation, comments, ignoredChars, additionalData, description);
         this.name = name;
         this.description = description;
         this.directives = (null == directives) ? new ArrayList<>() : directives;

File: src/main/java/graphql/language/FieldDefinition.java
Patch:
@@ -17,7 +17,7 @@
 import static java.util.Collections.emptyMap;
 
 @PublicApi
-public class FieldDefinition extends AbstractNode<FieldDefinition> implements DirectivesContainer<FieldDefinition>, NamedNode<FieldDefinition> {
+public class FieldDefinition extends AbstractDescribedNode<FieldDefinition> implements DirectivesContainer<FieldDefinition>, NamedNode<FieldDefinition> {
     private final String name;
     private final Type type;
     private final Description description;
@@ -38,7 +38,7 @@ protected FieldDefinition(String name,
                               List<Comment> comments,
                               IgnoredChars ignoredChars,
                               Map<String, String> additionalData) {
-        super(sourceLocation, comments, ignoredChars, additionalData);
+        super(sourceLocation, comments, ignoredChars, additionalData, description);
         this.description = description;
         this.name = name;
         this.type = type;

File: src/main/java/graphql/language/InputObjectTypeDefinition.java
Patch:
@@ -16,7 +16,7 @@
 import static graphql.language.NodeChildrenContainer.newNodeChildrenContainer;
 
 @PublicApi
-public class InputObjectTypeDefinition extends AbstractNode<InputObjectTypeDefinition> implements TypeDefinition<InputObjectTypeDefinition>, DirectivesContainer<InputObjectTypeDefinition>, NamedNode<InputObjectTypeDefinition> {
+public class InputObjectTypeDefinition extends AbstractDescribedNode<InputObjectTypeDefinition> implements TypeDefinition<InputObjectTypeDefinition>, DirectivesContainer<InputObjectTypeDefinition>, NamedNode<InputObjectTypeDefinition> {
 
     private final String name;
     private final Description description;
@@ -35,7 +35,7 @@ protected InputObjectTypeDefinition(String name,
                                         List<Comment> comments,
                                         IgnoredChars ignoredChars,
                                         Map<String, String> additionalData) {
-        super(sourceLocation, comments, ignoredChars, additionalData);
+        super(sourceLocation, comments, ignoredChars, additionalData, description);
         this.name = name;
         this.description = description;
         this.directives = directives;

File: src/main/java/graphql/language/InputValueDefinition.java
Patch:
@@ -17,7 +17,7 @@
 import static java.util.Collections.emptyMap;
 
 @PublicApi
-public class InputValueDefinition extends AbstractNode<InputValueDefinition> implements DirectivesContainer<InputValueDefinition>, NamedNode<InputValueDefinition> {
+public class InputValueDefinition extends AbstractDescribedNode<InputValueDefinition> implements DirectivesContainer<InputValueDefinition>, NamedNode<InputValueDefinition>{
     private final String name;
     private final Type type;
     private final Value defaultValue;
@@ -38,7 +38,7 @@ protected InputValueDefinition(String name,
                                    List<Comment> comments,
                                    IgnoredChars ignoredChars,
                                    Map<String, String> additionalData) {
-        super(sourceLocation, comments, ignoredChars, additionalData);
+        super(sourceLocation, comments, ignoredChars, additionalData, description);
         this.name = name;
         this.type = type;
         this.defaultValue = defaultValue;

File: src/main/java/graphql/language/InterfaceTypeDefinition.java
Patch:
@@ -17,7 +17,7 @@
 import static java.util.Collections.emptyMap;
 
 @PublicApi
-public class InterfaceTypeDefinition extends AbstractNode<InterfaceTypeDefinition> implements TypeDefinition<InterfaceTypeDefinition>, DirectivesContainer<InterfaceTypeDefinition>, NamedNode<InterfaceTypeDefinition> {
+public class InterfaceTypeDefinition extends AbstractDescribedNode<InterfaceTypeDefinition> implements TypeDefinition<InterfaceTypeDefinition>, DirectivesContainer<InterfaceTypeDefinition>, NamedNode<InterfaceTypeDefinition> {
 
     private final String name;
     private final Description description;
@@ -36,7 +36,7 @@ protected InterfaceTypeDefinition(String name,
                                       List<Comment> comments,
                                       IgnoredChars ignoredChars,
                                       Map<String, String> additionalData) {
-        super(sourceLocation, comments, ignoredChars, additionalData);
+        super(sourceLocation, comments, ignoredChars, additionalData, description);
         this.name = name;
         this.definitions = definitions;
         this.directives = directives;

File: src/main/java/graphql/language/ObjectTypeDefinition.java
Patch:
@@ -17,7 +17,7 @@
 import static java.util.Collections.emptyMap;
 
 @PublicApi
-public class ObjectTypeDefinition extends AbstractNode<ObjectTypeDefinition> implements TypeDefinition<ObjectTypeDefinition>, DirectivesContainer<ObjectTypeDefinition>, NamedNode<ObjectTypeDefinition> {
+public class ObjectTypeDefinition extends AbstractDescribedNode<ObjectTypeDefinition> implements TypeDefinition<ObjectTypeDefinition>, DirectivesContainer<ObjectTypeDefinition>, NamedNode<ObjectTypeDefinition> {
     private final String name;
     private final Description description;
     private final List<Type> implementz;
@@ -38,7 +38,7 @@ protected ObjectTypeDefinition(String name,
                                    List<Comment> comments,
                                    IgnoredChars ignoredChars,
                                    Map<String, String> additionalData) {
-        super(sourceLocation, comments, ignoredChars, additionalData);
+        super(sourceLocation, comments, ignoredChars, additionalData, description);
         this.name = name;
         this.implementz = implementz;
         this.directives = directives;

File: src/main/java/graphql/language/ScalarTypeDefinition.java
Patch:
@@ -17,7 +17,7 @@
 import static java.util.Collections.emptyMap;
 
 @PublicApi
-public class ScalarTypeDefinition extends AbstractNode<ScalarTypeDefinition> implements TypeDefinition<ScalarTypeDefinition>, DirectivesContainer<ScalarTypeDefinition>, NamedNode<ScalarTypeDefinition> {
+public class ScalarTypeDefinition extends AbstractDescribedNode<ScalarTypeDefinition> implements TypeDefinition<ScalarTypeDefinition>, DirectivesContainer<ScalarTypeDefinition>, NamedNode<ScalarTypeDefinition> {
 
     private final String name;
     private final Description description;
@@ -33,7 +33,7 @@ protected ScalarTypeDefinition(String name,
                                    List<Comment> comments,
                                    IgnoredChars ignoredChars,
                                    Map<String, String> additionalData) {
-        super(sourceLocation, comments, ignoredChars, additionalData);
+        super(sourceLocation, comments, ignoredChars, additionalData, description);
         this.name = name;
         this.directives = directives;
         this.description = description;

File: src/main/java/graphql/language/UnionTypeDefinition.java
Patch:
@@ -17,7 +17,7 @@
 import static java.util.Collections.emptyMap;
 
 @PublicApi
-public class UnionTypeDefinition extends AbstractNode<UnionTypeDefinition> implements TypeDefinition<UnionTypeDefinition>, DirectivesContainer<UnionTypeDefinition>, NamedNode<UnionTypeDefinition> {
+public class UnionTypeDefinition extends AbstractDescribedNode<UnionTypeDefinition> implements TypeDefinition<UnionTypeDefinition>, DirectivesContainer<UnionTypeDefinition>, NamedNode<UnionTypeDefinition> {
 
     private final String name;
     private final Description description;
@@ -35,7 +35,7 @@ protected UnionTypeDefinition(String name,
                                   SourceLocation sourceLocation,
                                   List<Comment> comments,
                                   IgnoredChars ignoredChars, Map<String, String> additionalData) {
-        super(sourceLocation, comments, ignoredChars, additionalData);
+        super(sourceLocation, comments, ignoredChars, additionalData, description);
         this.name = name;
         this.directives = directives;
         this.memberTypes = memberTypes;

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -607,7 +607,7 @@ protected CompletableFuture<ExecutionResult> completeValueForScalar(ExecutionCon
     protected CompletableFuture<ExecutionResult> completeValueForEnum(ExecutionContext executionContext, ExecutionStrategyParameters parameters, GraphQLEnumType enumType, Object result) {
         Object serialized;
         try {
-            serialized = enumType.getCoercing().serialize(result);
+            serialized = enumType.serialize(result);
         } catch (CoercingSerializeException e) {
             serialized = handleCoercionProblem(executionContext, parameters, e);
         }

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -208,7 +208,7 @@ private Object coerceValueForScalar(GraphQLScalarType graphQLScalarType, Object
     }
 
     private Object coerceValueForEnum(GraphQLEnumType graphQLEnumType, Object value) {
-        return graphQLEnumType.getCoercing().parseValue(value);
+        return graphQLEnumType.parseValue(value);
     }
 
     private List coerceValueForList(GraphqlFieldVisibility fieldVisibility, VariableDefinition variableDefinition, String inputName, GraphQLList graphQLList, Object value) {
@@ -240,7 +240,7 @@ private Object coerceValueAst(GraphqlFieldVisibility fieldVisibility, GraphQLTyp
             return coerceValueAstForInputObject(fieldVisibility, (GraphQLInputObjectType) type, (ObjectValue) inputValue, variables);
         }
         if (type instanceof GraphQLEnumType) {
-            return parseLiteral(inputValue, ((GraphQLEnumType) type).getCoercing(), variables);
+            return ((GraphQLEnumType) type).parseLiteral(inputValue);
         }
         if (isList(type)) {
             return coerceValueAstForList(fieldVisibility, (GraphQLList) type, inputValue, variables);

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -468,7 +468,7 @@ private Object coerce(GraphQLType type, Object value) {
             return null;
         }
         if (type instanceof GraphQLEnumType) {
-            return ((GraphQLEnumType) type).getCoercing().serialize(value);
+            return ((GraphQLEnumType) type).serialize(value);
         } else {
             return ((GraphQLScalarType) type).getCoercing().serialize(value);
         }

File: src/main/java/graphql/execution/nextgen/FetchedValueAnalyzer.java
Patch:
@@ -189,7 +189,7 @@ private FetchedValueAnalysis analyzeEnumValue(FetchedValue fetchedValue, Object
         }
         Object serialized;
         try {
-            serialized = enumType.getCoercing().serialize(toAnalyze);
+            serialized = enumType.serialize(toAnalyze);
         } catch (CoercingSerializeException e) {
             SerializationError error = new SerializationError(executionInfo.getPath(), e);
             return newFetchedValueAnalysis(SCALAR)

File: src/main/java/graphql/language/AstValueHelper.java
Patch:
@@ -198,7 +198,7 @@ private static Object serialize(GraphQLType type, Object value) {
         if (type instanceof GraphQLScalarType) {
             return ((GraphQLScalarType) type).getCoercing().serialize(value);
         } else {
-            return ((GraphQLEnumType) type).getCoercing().serialize(value);
+            return ((GraphQLEnumType) type).serialize(value);
         }
     }
 

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -607,7 +607,7 @@ protected CompletableFuture<ExecutionResult> completeValueForScalar(ExecutionCon
     protected CompletableFuture<ExecutionResult> completeValueForEnum(ExecutionContext executionContext, ExecutionStrategyParameters parameters, GraphQLEnumType enumType, Object result) {
         Object serialized;
         try {
-            serialized = enumType.getCoercing().serialize(result);
+            serialized = enumType.serialize(result);
         } catch (CoercingSerializeException e) {
             serialized = handleCoercionProblem(executionContext, parameters, e);
         }

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -208,7 +208,7 @@ private Object coerceValueForScalar(GraphQLScalarType graphQLScalarType, Object
     }
 
     private Object coerceValueForEnum(GraphQLEnumType graphQLEnumType, Object value) {
-        return graphQLEnumType.getCoercing().parseValue(value);
+        return graphQLEnumType.parseValue(value);
     }
 
     private List coerceValueForList(GraphqlFieldVisibility fieldVisibility, VariableDefinition variableDefinition, String inputName, GraphQLList graphQLList, Object value) {
@@ -240,7 +240,7 @@ private Object coerceValueAst(GraphqlFieldVisibility fieldVisibility, GraphQLTyp
             return coerceValueAstForInputObject(fieldVisibility, (GraphQLInputObjectType) type, (ObjectValue) inputValue, variables);
         }
         if (type instanceof GraphQLEnumType) {
-            return parseLiteral(inputValue, ((GraphQLEnumType) type).getCoercing(), variables);
+            return ((GraphQLEnumType) type).parseLiteral(inputValue);
         }
         if (isList(type)) {
             return coerceValueAstForList(fieldVisibility, (GraphQLList) type, inputValue, variables);

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -468,7 +468,7 @@ private Object coerce(GraphQLType type, Object value) {
             return null;
         }
         if (type instanceof GraphQLEnumType) {
-            return ((GraphQLEnumType) type).getCoercing().serialize(value);
+            return ((GraphQLEnumType) type).serialize(value);
         } else {
             return ((GraphQLScalarType) type).getCoercing().serialize(value);
         }

File: src/main/java/graphql/execution/nextgen/FetchedValueAnalyzer.java
Patch:
@@ -189,7 +189,7 @@ private FetchedValueAnalysis analyzeEnumValue(FetchedValue fetchedValue, Object
         }
         Object serialized;
         try {
-            serialized = enumType.getCoercing().serialize(toAnalyze);
+            serialized = enumType.serialize(toAnalyze);
         } catch (CoercingSerializeException e) {
             SerializationError error = new SerializationError(executionInfo.getPath(), e);
             return newFetchedValueAnalysis(SCALAR)

File: src/main/java/graphql/language/AstValueHelper.java
Patch:
@@ -198,7 +198,7 @@ private static Object serialize(GraphQLType type, Object value) {
         if (type instanceof GraphQLScalarType) {
             return ((GraphQLScalarType) type).getCoercing().serialize(value);
         } else {
-            return ((GraphQLEnumType) type).getCoercing().serialize(value);
+            return ((GraphQLEnumType) type).serialize(value);
         }
     }
 

File: src/main/java/graphql/schema/idl/SchemaTypeChecker.java
Patch:
@@ -484,8 +484,8 @@ private void checkArgumentConsistency(String typeOfType, ObjectTypeDefinition ob
         for (int i = 0; i < interfaceArgs.size(); i++) {
             InputValueDefinition interfaceArg = interfaceArgs.get(i);
             InputValueDefinition objectArg = objectArgs.get(i);
-            String interfaceArgStr = AstPrinter.printAst(interfaceArg);
-            String objectArgStr = AstPrinter.printAst(objectArg);
+            String interfaceArgStr = AstPrinter.printAstCompact(interfaceArg);
+            String objectArgStr = AstPrinter.printAstCompact(objectArg);
             if (!interfaceArgStr.equals(objectArgStr)) {
                 errors.add(new InterfaceFieldArgumentRedefinitionError(typeOfType, objectTypeDef, interfaceTypeDef, objectFieldDef, objectArgStr, interfaceArgStr));
             }

File: src/main/java/graphql/language/AstValueHelper.java
Patch:
@@ -180,9 +180,6 @@ static String jsonStringify(String stringValue) {
                 case '\\':
                     sb.append("\\\\");
                     break;
-                case '/':
-                    sb.append("\\/");
-                    break;
                 case '\b':
                     sb.append("\\b");
                     break;

File: src/main/java/graphql/execution/PossibleOptionalUnboxer.java
Patch:
@@ -8,7 +8,7 @@ public interface PossibleOptionalUnboxer {
     PossibleOptionalUnboxer DEFAULT = new DefaultOptionalUnboxer();
 
     /**
-     * Unboxes 'object' if it is boxed in an {@link Optional } like
+     * Unboxes 'object' if it is boxed in an {@link java.util.Optional } like
      * type that this unboxer can handle. Otherwise returns its input
      * unmodified
      *

File: src/main/java/graphql/schema/SchemaUtil.java
Patch:
@@ -109,7 +109,8 @@ void replaceTypeReferences(GraphQLSchema schema) {
         final Map<String, GraphQLNamedType> typeMap = schema.getTypeMap();
         List<GraphQLSchemaElement> roots = new ArrayList<>(typeMap.values());
         roots.addAll(schema.getDirectives());
-        TRAVERSER.depthFirst(new GraphQLTypeResolvingVisitor(typeMap), roots);
+        SchemaTraverser schemaTraverser = new SchemaTraverser(schemaElement -> schemaElement.getChildrenWithTypeReferences().getChildrenAsList());
+        schemaTraverser.depthFirst(new GraphQLTypeResolvingVisitor(typeMap), roots);
     }
 
     void extractCodeFromTypes(GraphQLCodeRegistry.Builder codeRegistry, GraphQLSchema schema) {

File: src/main/java/graphql/schema/SchemaUtil.java
Patch:
@@ -109,7 +109,8 @@ void replaceTypeReferences(GraphQLSchema schema) {
         final Map<String, GraphQLNamedType> typeMap = schema.getTypeMap();
         List<GraphQLSchemaElement> roots = new ArrayList<>(typeMap.values());
         roots.addAll(schema.getDirectives());
-        TRAVERSER.depthFirst(new GraphQLTypeResolvingVisitor(typeMap), roots);
+        SchemaTraverser schemaTraverser = new SchemaTraverser(schemaElement -> schemaElement.getChildrenWithTypeReferences().getChildrenAsList());
+        schemaTraverser.depthFirst(new GraphQLTypeResolvingVisitor(typeMap), roots);
     }
 
     void extractCodeFromTypes(GraphQLCodeRegistry.Builder codeRegistry, GraphQLSchema schema) {

File: src/main/java/graphql/schema/SchemaTransformer.java
Patch:
@@ -163,6 +163,7 @@ public TraversalControl leave(TraverserContext<GraphQLSchemaElement> context) {
             public TraversalControl backRef(TraverserContext<GraphQLSchemaElement> context) {
                 NodeZipper<GraphQLSchemaElement> zipper = zipperByOriginalNode.get(context.thisNode());
                 breadcrumbsByZipper.get(zipper).add(context.getBreadcrumbs());
+                visitor.visitBackRef(context);
                 return TraversalControl.CONTINUE;
             }
         };

File: src/main/java/graphql/Scalars.java
Patch:
@@ -281,13 +281,13 @@ private String convertImpl(Object input) {
             if (input instanceof BigInteger) {
                 return String.valueOf(input);
             }
-            return null;
+            return String.valueOf(input);
 
         }
 
         @Override
         public String serialize(Object input) {
-            String result = convertImpl(input);
+            String result = String.valueOf(input);
             if (result == null) {
                 throw new CoercingSerializeException(
                         "Expected type 'ID' but was '" + typeName(input) + "'."

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -23,7 +23,6 @@
 import graphql.schema.GraphQLInterfaceType;
 import graphql.schema.GraphQLList;
 import graphql.schema.GraphQLModifiedType;
-import graphql.schema.GraphQLNamedDescriptionType;
 import graphql.schema.GraphQLNamedSchemaElement;
 import graphql.schema.GraphQLNonNull;
 import graphql.schema.GraphQLObjectType;
@@ -124,8 +123,8 @@ public enum TypeKind {
     };
     private static final DataFetcher descriptionDataFetcher = environment -> {
         Object type = environment.getSource();
-        if (type instanceof GraphQLNamedDescriptionType) {
-            return ((GraphQLNamedDescriptionType) type).getDescription();
+        if (type instanceof GraphQLNamedSchemaElement) {
+            return ((GraphQLNamedSchemaElement) type).getDescription();
         }
         return null;
     };

File: src/main/java/graphql/relay/DefaultConnectionCursor.java
Patch:
@@ -3,6 +3,8 @@
 import graphql.Assert;
 import graphql.PublicApi;
 
+import java.util.Objects;
+
 @PublicApi
 public class DefaultConnectionCursor implements ConnectionCursor {
 
@@ -27,7 +29,7 @@ public boolean equals(Object o) {
             return false;
         }
         DefaultConnectionCursor that = (DefaultConnectionCursor) o;
-        return value != null ? value.equals(that.value) : that.value == null;
+        return Objects.equals(value, that.value);
     }
 
     @Override

File: src/main/java/graphql/schema/Coercing.java
Patch:
@@ -41,7 +41,7 @@ public interface Coercing<I, O> {
     O serialize(Object dataFetcherResult) throws CoercingSerializeException;
 
     /**
-     * Called to resolve a input from a query variable into a Java object acceptable for the scalar type.
+     * Called to resolve an input from a query variable into a Java object acceptable for the scalar type.
      * <p>
      * Note : You should not allow {@link java.lang.RuntimeException}s to come out of your parseValue method, but rather
      * catch them and fire them as {@link graphql.schema.CoercingParseValueException} instead as per the method contract.
@@ -55,7 +55,7 @@ public interface Coercing<I, O> {
     I parseValue(Object input) throws CoercingParseValueException;
 
     /**
-     * Called during query validation to convert an query input AST node into a Java object acceptable for the scalar type.  The input
+     * Called during query validation to convert a query input AST node into a Java object acceptable for the scalar type.  The input
      * object will be an instance of {@link graphql.language.Value}.
      * <p>
      * Note : You should not allow {@link java.lang.RuntimeException}s to come out of your parseLiteral method, but rather
@@ -70,7 +70,7 @@ public interface Coercing<I, O> {
     I parseLiteral(Object input) throws CoercingParseLiteralException;
 
     /**
-     * Called during query execution to convert an query input AST node into a Java object acceptable for the scalar type.  The input
+     * Called during query execution to convert a query input AST node into a Java object acceptable for the scalar type.  The input
      * object will be an instance of {@link graphql.language.Value}.
      * <p>
      * Note : You should not allow {@link java.lang.RuntimeException}s to come out of your parseLiteral method, but rather

File: src/main/java/graphql/schema/GraphQLArgument.java
Patch:
@@ -38,7 +38,7 @@
  * specific value on that directive.
  */
 @PublicApi
-public class GraphQLArgument implements GraphQLNamedDescriptionType, GraphQLInputValueDefinition {
+public class GraphQLArgument implements GraphQLNamedSchemaElement, GraphQLInputValueDefinition {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -32,7 +32,7 @@
  * See http://graphql.org/learn/schema/#enumeration-types for more details
  */
 @PublicApi
-public class GraphQLEnumType implements GraphQLNamedDescriptionType, GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLEnumType implements GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLEnumValueDefinition.java
Patch:
@@ -28,7 +28,7 @@
  * @see graphql.schema.GraphQLEnumType
  */
 @PublicApi
-public class GraphQLEnumValueDefinition implements GraphQLNamedDescriptionType, GraphQLDirectiveContainer {
+public class GraphQLEnumValueDefinition implements GraphQLNamedSchemaElement, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -31,7 +31,7 @@
  * See http://graphql.org/learn/queries/#fields for more details on the concept.
  */
 @PublicApi
-public class GraphQLFieldDefinition implements GraphQLNamedDescriptionType, GraphQLDirectiveContainer {
+public class GraphQLFieldDefinition implements GraphQLNamedSchemaElement, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -27,7 +27,7 @@
  * See http://graphql.org/learn/schema/#input-types for more details on the concept.
  */
 @PublicApi
-public class GraphQLInputObjectField implements GraphQLNamedDescriptionType, GraphQLInputValueDefinition {
+public class GraphQLInputObjectField implements GraphQLNamedSchemaElement, GraphQLInputValueDefinition {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLInputObjectType.java
Patch:
@@ -28,7 +28,7 @@
  * See http://graphql.org/learn/schema/#input-types for more details on the concept
  */
 @PublicApi
-public class GraphQLInputObjectType implements GraphQLNamedDescriptionType, GraphQLNamedInputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLInputFieldsContainer, GraphQLDirectiveContainer {
+public class GraphQLInputObjectType implements GraphQLNamedInputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLInputFieldsContainer, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -33,7 +33,7 @@
  * See http://graphql.org/learn/schema/#interfaces for more details on the concept.
  */
 @PublicApi
-public class GraphQLInterfaceType implements GraphQLNamedDescriptionType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLInterfaceType implements GraphQLNamedType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -37,7 +37,7 @@
  * See http://graphql.org/learn/schema/#object-types-and-fields for more details on the concept.
  */
 @PublicApi
-public class GraphQLObjectType implements GraphQLNamedDescriptionType, GraphQLNamedOutputType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLObjectType implements GraphQLNamedOutputType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
 
     private final String name;

File: src/main/java/graphql/schema/GraphQLScalarType.java
Patch:
@@ -36,7 +36,7 @@
  *
  * @see graphql.Scalars
  */
-public class GraphQLScalarType implements GraphQLNamedDescriptionType, GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLScalarType implements GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -23,7 +23,6 @@
 import graphql.schema.GraphQLInterfaceType;
 import graphql.schema.GraphQLList;
 import graphql.schema.GraphQLModifiedType;
-import graphql.schema.GraphQLNamedDescriptionType;
 import graphql.schema.GraphQLNamedSchemaElement;
 import graphql.schema.GraphQLNonNull;
 import graphql.schema.GraphQLObjectType;
@@ -124,8 +123,8 @@ public enum TypeKind {
     };
     private static final DataFetcher descriptionDataFetcher = environment -> {
         Object type = environment.getSource();
-        if (type instanceof GraphQLNamedDescriptionType) {
-            return ((GraphQLNamedDescriptionType) type).getDescription();
+        if (type instanceof GraphQLNamedSchemaElement) {
+            return ((GraphQLNamedSchemaElement) type).getDescription();
         }
         return null;
     };

File: src/main/java/graphql/schema/GraphQLArgument.java
Patch:
@@ -38,7 +38,7 @@
  * specific value on that directive.
  */
 @PublicApi
-public class GraphQLArgument implements GraphQLNamedDescriptionType, GraphQLInputValueDefinition {
+public class GraphQLArgument implements GraphQLNamedSchemaElement, GraphQLInputValueDefinition {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLDirective.java
Patch:
@@ -27,7 +27,7 @@
  */
 @SuppressWarnings("DeprecatedIsStillUsed") // because the graphql spec still has some of these deprecated fields
 @PublicApi
-public class GraphQLDirective implements GraphQLNamedDescriptionType, GraphQLNamedSchemaElement {
+public class GraphQLDirective implements GraphQLNamedSchemaElement {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -32,7 +32,7 @@
  * See http://graphql.org/learn/schema/#enumeration-types for more details
  */
 @PublicApi
-public class GraphQLEnumType implements GraphQLNamedDescriptionType, GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLEnumType implements GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLEnumValueDefinition.java
Patch:
@@ -28,7 +28,7 @@
  * @see graphql.schema.GraphQLEnumType
  */
 @PublicApi
-public class GraphQLEnumValueDefinition implements GraphQLNamedDescriptionType, GraphQLDirectiveContainer {
+public class GraphQLEnumValueDefinition implements GraphQLNamedSchemaElement, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -31,7 +31,7 @@
  * See http://graphql.org/learn/queries/#fields for more details on the concept.
  */
 @PublicApi
-public class GraphQLFieldDefinition implements GraphQLNamedDescriptionType, GraphQLDirectiveContainer {
+public class GraphQLFieldDefinition implements GraphQLNamedSchemaElement, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -27,7 +27,7 @@
  * See http://graphql.org/learn/schema/#input-types for more details on the concept.
  */
 @PublicApi
-public class GraphQLInputObjectField implements GraphQLNamedDescriptionType, GraphQLInputValueDefinition {
+public class GraphQLInputObjectField implements GraphQLNamedSchemaElement, GraphQLInputValueDefinition {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLInputObjectType.java
Patch:
@@ -28,7 +28,7 @@
  * See http://graphql.org/learn/schema/#input-types for more details on the concept
  */
 @PublicApi
-public class GraphQLInputObjectType implements GraphQLNamedDescriptionType, GraphQLNamedInputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLInputFieldsContainer, GraphQLDirectiveContainer {
+public class GraphQLInputObjectType implements GraphQLNamedInputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLInputFieldsContainer, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -33,7 +33,7 @@
  * See http://graphql.org/learn/schema/#interfaces for more details on the concept.
  */
 @PublicApi
-public class GraphQLInterfaceType implements GraphQLNamedDescriptionType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLInterfaceType implements GraphQLNamedType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -37,7 +37,7 @@
  * See http://graphql.org/learn/schema/#object-types-and-fields for more details on the concept.
  */
 @PublicApi
-public class GraphQLObjectType implements GraphQLNamedDescriptionType, GraphQLNamedOutputType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLObjectType implements GraphQLNamedOutputType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
 
     private final String name;

File: src/main/java/graphql/schema/GraphQLScalarType.java
Patch:
@@ -36,7 +36,7 @@
  *
  * @see graphql.Scalars
  */
-public class GraphQLScalarType implements GraphQLNamedDescriptionType, GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLScalarType implements GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -23,7 +23,6 @@
 import graphql.schema.GraphQLInterfaceType;
 import graphql.schema.GraphQLList;
 import graphql.schema.GraphQLModifiedType;
-import graphql.schema.GraphQLNamedDescriptionType;
 import graphql.schema.GraphQLNamedSchemaElement;
 import graphql.schema.GraphQLNonNull;
 import graphql.schema.GraphQLObjectType;
@@ -124,8 +123,8 @@ public enum TypeKind {
     };
     private static final DataFetcher descriptionDataFetcher = environment -> {
         Object type = environment.getSource();
-        if (type instanceof GraphQLNamedDescriptionType) {
-            return ((GraphQLNamedDescriptionType) type).getDescription();
+        if (type instanceof GraphQLNamedSchemaElement) {
+            return ((GraphQLNamedSchemaElement) type).getDescription();
         }
         return null;
     };

File: src/main/java/graphql/schema/GraphQLArgument.java
Patch:
@@ -38,7 +38,7 @@
  * specific value on that directive.
  */
 @PublicApi
-public class GraphQLArgument implements GraphQLNamedDescriptionType, GraphQLInputValueDefinition {
+public class GraphQLArgument implements GraphQLNamedSchemaElement, GraphQLInputValueDefinition {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLDirective.java
Patch:
@@ -27,7 +27,7 @@
  */
 @SuppressWarnings("DeprecatedIsStillUsed") // because the graphql spec still has some of these deprecated fields
 @PublicApi
-public class GraphQLDirective implements GraphQLNamedDescriptionType, GraphQLNamedSchemaElement {
+public class GraphQLDirective implements GraphQLNamedSchemaElement {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -32,7 +32,7 @@
  * See http://graphql.org/learn/schema/#enumeration-types for more details
  */
 @PublicApi
-public class GraphQLEnumType implements GraphQLNamedDescriptionType, GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLEnumType implements GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLEnumValueDefinition.java
Patch:
@@ -28,7 +28,7 @@
  * @see graphql.schema.GraphQLEnumType
  */
 @PublicApi
-public class GraphQLEnumValueDefinition implements GraphQLNamedDescriptionType, GraphQLDirectiveContainer {
+public class GraphQLEnumValueDefinition implements GraphQLNamedSchemaElement, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -31,7 +31,7 @@
  * See http://graphql.org/learn/queries/#fields for more details on the concept.
  */
 @PublicApi
-public class GraphQLFieldDefinition implements GraphQLNamedDescriptionType, GraphQLDirectiveContainer {
+public class GraphQLFieldDefinition implements GraphQLNamedSchemaElement, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -27,7 +27,7 @@
  * See http://graphql.org/learn/schema/#input-types for more details on the concept.
  */
 @PublicApi
-public class GraphQLInputObjectField implements GraphQLNamedDescriptionType, GraphQLInputValueDefinition {
+public class GraphQLInputObjectField implements GraphQLNamedSchemaElement, GraphQLInputValueDefinition {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLInputObjectType.java
Patch:
@@ -28,7 +28,7 @@
  * See http://graphql.org/learn/schema/#input-types for more details on the concept
  */
 @PublicApi
-public class GraphQLInputObjectType implements GraphQLNamedDescriptionType, GraphQLNamedInputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLInputFieldsContainer, GraphQLDirectiveContainer {
+public class GraphQLInputObjectType implements GraphQLNamedInputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLInputFieldsContainer, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -33,7 +33,7 @@
  * See http://graphql.org/learn/schema/#interfaces for more details on the concept.
  */
 @PublicApi
-public class GraphQLInterfaceType implements GraphQLNamedDescriptionType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLInterfaceType implements GraphQLNamedType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -37,7 +37,7 @@
  * See http://graphql.org/learn/schema/#object-types-and-fields for more details on the concept.
  */
 @PublicApi
-public class GraphQLObjectType implements GraphQLNamedDescriptionType, GraphQLNamedOutputType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLObjectType implements GraphQLNamedOutputType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
 
     private final String name;

File: src/main/java/graphql/schema/GraphQLScalarType.java
Patch:
@@ -36,7 +36,7 @@
  *
  * @see graphql.Scalars
  */
-public class GraphQLScalarType implements GraphQLNamedDescriptionType, GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLScalarType implements GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/SchemaTransformer.java
Patch:
@@ -247,6 +247,8 @@ public TraversalControl backRef(TraverserContext<GraphQLSchemaElement> context)
         };
 
         Traverser<GraphQLSchemaElement> traverser = Traverser.depthFirstWithNamedChildren(SCHEMA_ELEMENT_ADAPTER::getNamedChildren, zippers, null);
+        GraphQLCodeRegistry.Builder builder = GraphQLCodeRegistry.newCodeRegistry(schema.getCodeRegistry());
+        traverser.rootVar(GraphQLCodeRegistry.Builder.class, builder);
         traverser.traverse(dummyRoot, nodeTraverserVisitor);
 
         toRootNode(zippers, breadcrumbsByZipper, zipperByNodeAfterTraversing);
@@ -257,7 +259,7 @@ public TraversalControl backRef(TraverserContext<GraphQLSchemaElement> context)
                 .subscription(dummyRoot.subscription)
                 .additionalTypes(dummyRoot.additionalTypes)
                 .additionalDirectives(dummyRoot.directives)
-                .codeRegistry(schema.getCodeRegistry())
+                .codeRegistry(builder.build())
                 .buildImpl(true);
         return newSchema;
     }

File: src/main/java/graphql/schema/Coercing.java
Patch:
@@ -41,7 +41,7 @@ public interface Coercing<I, O> {
     O serialize(Object dataFetcherResult) throws CoercingSerializeException;
 
     /**
-     * Called to resolve a input from a query variable into a Java object acceptable for the scalar type.
+     * Called to resolve an input from a query variable into a Java object acceptable for the scalar type.
      * <p>
      * Note : You should not allow {@link java.lang.RuntimeException}s to come out of your parseValue method, but rather
      * catch them and fire them as {@link graphql.schema.CoercingParseValueException} instead as per the method contract.

File: src/main/java/graphql/schema/Coercing.java
Patch:
@@ -55,7 +55,7 @@ public interface Coercing<I, O> {
     I parseValue(Object input) throws CoercingParseValueException;
 
     /**
-     * Called during query validation to convert an query input AST node into a Java object acceptable for the scalar type.  The input
+     * Called during query validation to convert a query input AST node into a Java object acceptable for the scalar type.  The input
      * object will be an instance of {@link graphql.language.Value}.
      * <p>
      * Note : You should not allow {@link java.lang.RuntimeException}s to come out of your parseLiteral method, but rather
@@ -70,7 +70,7 @@ public interface Coercing<I, O> {
     I parseLiteral(Object input) throws CoercingParseLiteralException;
 
     /**
-     * Called during query execution to convert an query input AST node into a Java object acceptable for the scalar type.  The input
+     * Called during query execution to convert a query input AST node into a Java object acceptable for the scalar type.  The input
      * object will be an instance of {@link graphql.language.Value}.
      * <p>
      * Note : You should not allow {@link java.lang.RuntimeException}s to come out of your parseLiteral method, but rather

File: src/main/java/graphql/schema/GraphQLArgument.java
Patch:
@@ -38,7 +38,7 @@
  * specific value on that directive.
  */
 @PublicApi
-public class GraphQLArgument implements GraphQLInputValueDefinition {
+public class GraphQLArgument implements GraphQLNamedDescriptionType, GraphQLInputValueDefinition {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLDirective.java
Patch:
@@ -26,7 +26,7 @@
  */
 @SuppressWarnings("DeprecatedIsStillUsed") // because the graphql spec still has some of these deprecated fields
 @PublicApi
-public class GraphQLDirective implements GraphQLNamedSchemaElement {
+public class GraphQLDirective implements GraphQLNamedDescriptionType, GraphQLNamedSchemaElement {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -32,7 +32,7 @@
  * See http://graphql.org/learn/schema/#enumeration-types for more details
  */
 @PublicApi
-public class GraphQLEnumType implements GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLEnumType implements GraphQLNamedDescriptionType, GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLEnumValueDefinition.java
Patch:
@@ -28,7 +28,7 @@
  * @see graphql.schema.GraphQLEnumType
  */
 @PublicApi
-public class GraphQLEnumValueDefinition implements GraphQLDirectiveContainer {
+public class GraphQLEnumValueDefinition implements GraphQLNamedDescriptionType, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -31,7 +31,7 @@
  * See http://graphql.org/learn/queries/#fields for more details on the concept.
  */
 @PublicApi
-public class GraphQLFieldDefinition implements GraphQLDirectiveContainer {
+public class GraphQLFieldDefinition implements GraphQLNamedDescriptionType, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -27,7 +27,7 @@
  * See http://graphql.org/learn/schema/#input-types for more details on the concept.
  */
 @PublicApi
-public class GraphQLInputObjectField implements GraphQLInputValueDefinition {
+public class GraphQLInputObjectField implements GraphQLNamedDescriptionType, GraphQLInputValueDefinition {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLInputObjectType.java
Patch:
@@ -28,7 +28,7 @@
  * See http://graphql.org/learn/schema/#input-types for more details on the concept
  */
 @PublicApi
-public class GraphQLInputObjectType implements GraphQLNamedInputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLInputFieldsContainer, GraphQLDirectiveContainer {
+public class GraphQLInputObjectType implements GraphQLNamedDescriptionType, GraphQLNamedInputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLInputFieldsContainer, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;
@@ -65,7 +65,7 @@ public GraphQLInputObjectType(String name, String description, List<GraphQLInput
     @Internal
     @Deprecated
     public GraphQLInputObjectType(String name, String description, List<GraphQLInputObjectField> fields, List<GraphQLDirective> directives, InputObjectTypeDefinition definition) {
-        this(name,description,fields,directives,definition,emptyList());
+        this(name, description, fields, directives, definition, emptyList());
     }
 
     public GraphQLInputObjectType(String name, String description, List<GraphQLInputObjectField> fields, List<GraphQLDirective> directives, InputObjectTypeDefinition definition, List<InputObjectTypeExtensionDefinition> extensionDefinitions) {

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -33,7 +33,7 @@
  * See http://graphql.org/learn/schema/#interfaces for more details on the concept.
  */
 @PublicApi
-public class GraphQLInterfaceType implements GraphQLNamedOutputType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLInterfaceType implements GraphQLNamedDescriptionType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -37,7 +37,7 @@
  * See http://graphql.org/learn/schema/#object-types-and-fields for more details on the concept.
  */
 @PublicApi
-public class GraphQLObjectType implements GraphQLNamedOutputType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLObjectType implements GraphQLNamedDescriptionType, GraphQLNamedOutputType, GraphQLFieldsContainer, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
 
     private final String name;

File: src/main/java/graphql/schema/GraphQLScalarType.java
Patch:
@@ -36,7 +36,7 @@
  *
  * @see graphql.Scalars
  */
-public class GraphQLScalarType implements GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLScalarType implements GraphQLNamedDescriptionType, GraphQLNamedInputType, GraphQLNamedOutputType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLUnionType.java
Patch:
@@ -34,7 +34,7 @@
  * See http://graphql.org/learn/schema/#union-types for more details on the concept.
  */
 @PublicApi
-public class GraphQLUnionType implements GraphQLNamedType, GraphQLOutputType, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
+public class GraphQLUnionType implements GraphQLNamedDescriptionType, GraphQLOutputType, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType, GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -142,7 +142,7 @@ private CompletableFuture<ExecutionResult> executeOperation(ExecutionContext exe
         ExecutionStrategyParameters parameters = newParameters()
                 .executionStepInfo(executionStepInfo)
                 .source(root)
-                .localContext(executionContext.getContext())
+                .localContext(null) // this is important to default as this
                 .fields(fields)
                 .nonNullFieldValidator(nonNullableFieldValidator)
                 .path(path)

File: src/main/java/graphql/schema/DelegatingDataFetchingEnvironment.java
Patch:
@@ -32,7 +32,6 @@ public class DelegatingDataFetchingEnvironment implements DataFetchingEnvironmen
      * Called to wrap an existing {@link graphql.schema.DataFetchingEnvironment}.
      *
      * @param delegateEnvironment the environment to wrap and delegate all method called to
-     * @return a wrapped environment
      */
     public DelegatingDataFetchingEnvironment(DataFetchingEnvironment delegateEnvironment) {
         this.delegateEnvironment = delegateEnvironment;

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -141,7 +141,7 @@ private CompletableFuture<ExecutionResult> executeOperation(ExecutionContext exe
         ExecutionStrategyParameters parameters = newParameters()
                 .executionStepInfo(executionStepInfo)
                 .source(root)
-                .localContext(executionContext.getContext())
+                .localContext(null) // this is important to default as this
                 .fields(fields)
                 .nonNullFieldValidator(nonNullableFieldValidator)
                 .path(path)

File: src/main/java/graphql/schema/DelegatingDataFetchingEnvironment.java
Patch:
@@ -32,7 +32,6 @@ public class DelegatingDataFetchingEnvironment implements DataFetchingEnvironmen
      * Called to wrap an existing {@link graphql.schema.DataFetchingEnvironment}.
      *
      * @param delegateEnvironment the environment to wrap and delegate all method called to
-     * @return a wrapped environment
      */
     public DelegatingDataFetchingEnvironment(DataFetchingEnvironment delegateEnvironment) {
         this.delegateEnvironment = delegateEnvironment;

File: src/main/java/graphql/Internal.java
Patch:
@@ -5,6 +5,7 @@
 import java.lang.annotation.Target;
 
 import static java.lang.annotation.ElementType.CONSTRUCTOR;
+import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.ElementType.TYPE;
 
@@ -15,6 +16,6 @@
  * In general unnecessary changes will be avoided but you should not depend on internal classes being stable
  */
 @Retention(RetentionPolicy.RUNTIME)
-@Target(value = {CONSTRUCTOR, METHOD, TYPE})
+@Target(value = {CONSTRUCTOR, METHOD, TYPE, FIELD})
 public @interface Internal {
 }

File: src/main/java/graphql/PublicApi.java
Patch:
@@ -6,6 +6,7 @@
 import java.lang.annotation.Target;
 
 import static java.lang.annotation.ElementType.CONSTRUCTOR;
+import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.ElementType.TYPE;
 
@@ -17,7 +18,7 @@
  * maybe be added which would break derivations but not callers.
  */
 @Retention(RetentionPolicy.RUNTIME)
-@Target(value = {CONSTRUCTOR, METHOD, TYPE})
+@Target(value = {CONSTRUCTOR, METHOD, TYPE, FIELD})
 @Documented
 public @interface PublicApi {
 }

File: src/main/java/graphql/execution/ExecutionContext.java
Patch:
@@ -98,8 +98,9 @@ public Map<String, Object> getVariables() {
         return variables;
     }
 
-    public Object getContext() {
-        return context;
+    @SuppressWarnings("unchecked")
+    public <T> T getContext() {
+        return (T) context;
     }
 
     @SuppressWarnings("unchecked")

File: src/main/java/graphql/language/Argument.java
Patch:
@@ -135,7 +135,7 @@ private Builder(Argument existing) {
             this.name = existing.getName();
             this.value = existing.getValue();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/language/ArrayValue.java
Patch:
@@ -115,7 +115,7 @@ private Builder(ArrayValue existing) {
             this.comments = existing.getComments();
             this.values = existing.getValues();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/language/BooleanValue.java
Patch:
@@ -119,7 +119,7 @@ private Builder(BooleanValue existing) {
             this.comments = existing.getComments();
             this.value = existing.isValue();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/Directive.java
Patch:
@@ -149,7 +149,7 @@ private Builder(Directive existing) {
             this.name = existing.getName();
             this.arguments = existing.getArguments();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/DirectiveDefinition.java
Patch:
@@ -163,7 +163,7 @@ private Builder(DirectiveDefinition existing) {
             this.inputValueDefinitions = existing.getInputValueDefinitions();
             this.directiveLocations = existing.getDirectiveLocations();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/language/DirectiveLocation.java
Patch:
@@ -112,7 +112,7 @@ private Builder(DirectiveLocation existing) {
             this.sourceLocation = existing.getSourceLocation();
             this.comments = existing.getComments();
             this.name = existing.getName();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/language/Document.java
Patch:
@@ -131,7 +131,7 @@ private Builder(Document existing) {
             this.comments = existing.getComments();
             this.definitions = existing.getDefinitions();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder definitions(List<Definition> definitions) {

File: src/main/java/graphql/language/EnumTypeDefinition.java
Patch:
@@ -162,7 +162,7 @@ private Builder(EnumTypeDefinition existing) {
             this.directives = existing.getDirectives();
             this.enumValueDefinitions = existing.getEnumValueDefinitions();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/language/EnumTypeExtensionDefinition.java
Patch:
@@ -78,7 +78,7 @@ private Builder(EnumTypeExtensionDefinition existing) {
             this.directives = existing.getDirectives();
             this.enumValueDefinitions = existing.getEnumValueDefinitions();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/language/EnumValue.java
Patch:
@@ -119,7 +119,7 @@ private Builder(EnumValue existing) {
             this.sourceLocation = existing.getSourceLocation();
             this.comments = existing.getComments();
             this.name = existing.getName();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/EnumValueDefinition.java
Patch:
@@ -153,7 +153,7 @@ private Builder(EnumValueDefinition existing) {
             this.description = existing.getDescription();
             this.directives = existing.getDirectives();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/language/FieldDefinition.java
Patch:
@@ -175,7 +175,7 @@ private Builder(FieldDefinition existing) {
             this.inputValueDefinitions = existing.getInputValueDefinitions();
             this.directives = existing.getDirectives();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/FloatValue.java
Patch:
@@ -118,7 +118,7 @@ private Builder(FloatValue existing) {
             this.sourceLocation = existing.getSourceLocation();
             this.comments = existing.getComments();
             this.value = existing.getValue();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/FragmentDefinition.java
Patch:
@@ -166,7 +166,7 @@ private Builder(FragmentDefinition existing) {
             this.directives = existing.getDirectives();
             this.selectionSet = existing.getSelectionSet();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/FragmentSpread.java
Patch:
@@ -136,7 +136,7 @@ private Builder(FragmentSpread existing) {
             this.name = existing.getName();
             this.directives = existing.getDirectives();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/language/InlineFragment.java
Patch:
@@ -178,7 +178,7 @@ private Builder(InlineFragment existing) {
             this.directives = existing.getDirectives();
             this.selectionSet = existing.getSelectionSet();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/InputObjectTypeDefinition.java
Patch:
@@ -155,7 +155,7 @@ private Builder(InputObjectTypeDefinition existing) {
             this.description = existing.getDescription();
             this.directives = existing.getDirectives();
             this.inputValueDefinitions = existing.getInputValueDefinitions();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/InputObjectTypeExtensionDefinition.java
Patch:
@@ -79,7 +79,7 @@ private Builder(InputObjectTypeDefinition existing) {
             this.directives = existing.getDirectives();
             this.inputValueDefinitions = existing.getInputValueDefinitions();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/InputValueDefinition.java
Patch:
@@ -199,7 +199,7 @@ private Builder(InputValueDefinition existing) {
             this.defaultValue = existing.getDefaultValue();
             this.description = existing.getDescription();
             this.directives = existing.getDirectives();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/IntValue.java
Patch:
@@ -118,7 +118,7 @@ private Builder(IntValue existing) {
             this.sourceLocation = existing.getSourceLocation();
             this.comments = existing.getComments();
             this.value = existing.getValue();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/language/InterfaceTypeDefinition.java
Patch:
@@ -167,7 +167,7 @@ private Builder(InterfaceTypeDefinition existing) {
             this.directives = existing.getDirectives();
             this.definitions = existing.getFieldDefinitions();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/InterfaceTypeExtensionDefinition.java
Patch:
@@ -79,7 +79,7 @@ private Builder(InterfaceTypeExtensionDefinition existing) {
             this.directives = existing.getDirectives();
             this.definitions = existing.getFieldDefinitions();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/language/ListType.java
Patch:
@@ -121,7 +121,7 @@ private Builder(ListType existing) {
             this.comments = existing.getComments();
             this.type = existing.getType();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/NonNullType.java
Patch:
@@ -122,7 +122,7 @@ private Builder(NonNullType existing) {
             this.comments = existing.getComments();
             this.type = existing.getType();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/ObjectField.java
Patch:
@@ -131,7 +131,7 @@ private Builder(ObjectField existing) {
             this.comments = existing.getComments();
             this.name = existing.getName();
             this.value = existing.getValue();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/ObjectTypeDefinition.java
Patch:
@@ -176,7 +176,7 @@ private Builder(ObjectTypeDefinition existing) {
             this.implementz = existing.getImplements();
             this.fieldDefinitions = existing.getFieldDefinitions();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/language/ObjectTypeExtensionDefinition.java
Patch:
@@ -96,7 +96,7 @@ private Builder(ObjectTypeExtensionDefinition existing) {
             this.implementz = existing.getImplements();
             this.fieldDefinitions = existing.getFieldDefinitions();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/language/ObjectValue.java
Patch:
@@ -119,7 +119,7 @@ private Builder(ObjectValue existing) {
             this.sourceLocation = existing.getSourceLocation();
             this.comments = existing.getComments();
             this.objectFields = existing.getObjectFields();
-            this.additionalData  =existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/language/OperationDefinition.java
Patch:
@@ -186,7 +186,7 @@ private Builder(OperationDefinition existing) {
             this.directives = existing.getDirectives();
             this.selectionSet = existing.getSelectionSet();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/OperationTypeDefinition.java
Patch:
@@ -7,7 +7,6 @@
 import graphql.util.TraverserContext;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -132,7 +131,7 @@ private Builder(OperationTypeDefinition existing) {
             this.name = existing.getName();
             this.typeName = existing.getTypeName();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/ScalarTypeDefinition.java
Patch:
@@ -143,7 +143,7 @@ private Builder(ScalarTypeDefinition existing) {
             this.description = existing.getDescription();
             this.directives = existing.getDirectives();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/ScalarTypeExtensionDefinition.java
Patch:
@@ -68,7 +68,7 @@ private Builder(ScalarTypeExtensionDefinition existing) {
             this.description = existing.getDescription();
             this.directives = existing.getDirectives();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/SchemaDefinition.java
Patch:
@@ -135,7 +135,7 @@ private Builder(SchemaDefinition existing) {
             this.directives = existing.getDirectives();
             this.operationTypeDefinitions = existing.getOperationTypeDefinitions();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/SelectionSet.java
Patch:
@@ -137,7 +137,7 @@ private Builder(SelectionSet existing) {
             this.comments = existing.getComments();
             this.selections = existing.getSelections();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder selections(Collection<? extends Selection> selections) {

File: src/main/java/graphql/language/StringValue.java
Patch:
@@ -119,7 +119,7 @@ private Builder(StringValue existing) {
             this.comments = existing.getComments();
             this.value = existing.getValue();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/TypeName.java
Patch:
@@ -118,7 +118,7 @@ private Builder(TypeName existing) {
             this.sourceLocation = existing.getSourceLocation();
             this.comments = existing.getComments();
             this.name = existing.getName();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
 

File: src/main/java/graphql/language/UnionTypeExtensionDefinition.java
Patch:
@@ -85,7 +85,7 @@ private Builder(UnionTypeExtensionDefinition existing) {
             this.directives = existing.getDirectives();
             this.memberTypes = existing.getMemberTypes();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/language/VariableDefinition.java
Patch:
@@ -185,7 +185,7 @@ private Builder(VariableDefinition existing) {
             this.type = existing.getType();
             this.defaultValue = existing.getDefaultValue();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/language/VariableReference.java
Patch:
@@ -114,7 +114,7 @@ private Builder(VariableReference existing) {
             this.comments = existing.getComments();
             this.name = existing.getName();
             this.ignoredChars = existing.getIgnoredChars();
-            this.additionalData = existing.getAdditionalData();
+            this.additionalData = new LinkedHashMap<>(existing.getAdditionalData());
         }
 
         public Builder sourceLocation(SourceLocation sourceLocation) {

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -151,11 +151,11 @@ private CompletableFuture<ExecutionResult> executeOperation(ExecutionContext exe
         try {
             ExecutionStrategy executionStrategy;
             if (operation == OperationDefinition.Operation.MUTATION) {
-                executionStrategy = mutationStrategy;
+                executionStrategy = executionContext.getMutationStrategy();
             } else if (operation == SUBSCRIPTION) {
-                executionStrategy = subscriptionStrategy;
+                executionStrategy = executionContext.getSubscriptionStrategy();
             } else {
-                executionStrategy = queryStrategy;
+                executionStrategy = executionContext.getQueryStrategy();
             }
             logNotSafe.debug("Executing '{}' query operation: '{}' using '{}' execution strategy", executionContext.getExecutionId(), operation, executionStrategy.getClass().getName());
             result = executionStrategy.execute(executionContext, parameters);

File: src/main/java/graphql/schema/idl/SchemaPrinter.java
Patch:
@@ -194,7 +194,7 @@ public Options useAstDefinitions(boolean flag) {
          * @return options
          */
         public Options setComparators(GraphqlTypeComparatorRegistry comparatorRegistry) {
-            return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, this.useAstDefinitions, this.includeDirectives,
+            return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, this.includeDirectives, this.useAstDefinitions,
                     comparatorRegistry);
         }
 

File: src/main/java/graphql/validation/ValidationUtil.java
Patch:
@@ -150,8 +150,8 @@ private boolean isValidLiteralValue(Value value, GraphQLInputObjectType type, Gr
     private Set<String> getMissingFields(GraphQLInputObjectType type, Map<String, ObjectField> objectFieldMap, GraphqlFieldVisibility fieldVisibility) {
         return fieldVisibility.getFieldDefinitions(type).stream()
                 .filter(field -> isNonNull(field.getType()))
+                .filter(value -> (value.getDefaultValue() == null) && !objectFieldMap.containsKey(value.getName()))
                 .map(GraphQLInputObjectField::getName)
-                .filter(((Predicate<String>) objectFieldMap::containsKey).negate())
                 .collect(Collectors.toSet());
     }
 

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -21,9 +21,9 @@
 import graphql.language.VariableDefinition;
 import graphql.schema.GraphQLObjectType;
 import graphql.schema.GraphQLSchema;
+import graphql.util.LogKit;
 import org.reactivestreams.Publisher;
 import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.util.Collections;
 import java.util.List;
@@ -41,7 +41,7 @@
 
 @Internal
 public class Execution {
-    private static final Logger log = LoggerFactory.getLogger(Execution.class);
+    private static final Logger logNotSafe = LogKit.getNotPrivacySafeLogger(Execution.class);
 
     private final FieldCollector fieldCollector = new FieldCollector();
     private final ValuesResolver valuesResolver = new ValuesResolver();
@@ -157,7 +157,7 @@ private CompletableFuture<ExecutionResult> executeOperation(ExecutionContext exe
             } else {
                 executionStrategy = queryStrategy;
             }
-            log.debug("Executing '{}' query operation: '{}' using '{}' execution strategy", executionContext.getExecutionId(), operation, executionStrategy.getClass().getName());
+            logNotSafe.debug("Executing '{}' query operation: '{}' using '{}' execution strategy", executionContext.getExecutionId(), operation, executionStrategy.getClass().getName());
             result = executionStrategy.execute(executionContext, parameters);
         } catch (NonNullableFieldWasNullException e) {
             // this means it was non null types all the way from an offending non null type

File: src/main/java/graphql/execution/SimpleDataFetcherExceptionHandler.java
Patch:
@@ -2,6 +2,7 @@
 
 import graphql.ExceptionWhileDataFetching;
 import graphql.language.SourceLocation;
+import graphql.util.LogKit;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -11,7 +12,7 @@
  */
 public class SimpleDataFetcherExceptionHandler implements DataFetcherExceptionHandler {
 
-    private static final Logger log = LoggerFactory.getLogger(SimpleDataFetcherExceptionHandler.class);
+    private static final Logger logNotSafe = LogKit.getNotPrivacySafeLogger(SimpleDataFetcherExceptionHandler.class);
 
     @Override
     public DataFetcherExceptionHandlerResult onException(DataFetcherExceptionHandlerParameters handlerParameters) {
@@ -20,7 +21,7 @@ public DataFetcherExceptionHandlerResult onException(DataFetcherExceptionHandler
         ExecutionPath path = handlerParameters.getPath();
 
         ExceptionWhileDataFetching error = new ExceptionWhileDataFetching(path, exception, sourceLocation);
-        log.warn(error.getMessage(), exception);
+        logNotSafe.warn(error.getMessage(), exception);
 
         return DataFetcherExceptionHandlerResult.newResult().error(error).build();
     }

File: src/main/java/graphql/schema/idl/ArgValueOfAllowedTypeChecker.java
Patch:
@@ -25,6 +25,7 @@
 import graphql.schema.CoercingParseLiteralException;
 import graphql.schema.GraphQLScalarType;
 import graphql.schema.idl.errors.DirectiveIllegalArgumentTypeError;
+import graphql.util.LogKit;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -53,7 +54,7 @@
 @Internal
 class ArgValueOfAllowedTypeChecker {
 
-    private static final Logger log = LoggerFactory.getLogger(ArgValueOfAllowedTypeChecker.class);
+    private static final Logger logNotSafe = LogKit.getNotPrivacySafeLogger(ArgValueOfAllowedTypeChecker.class);
 
     private final Directive directive;
     private final Node element;
@@ -263,7 +264,7 @@ private boolean isArgumentValueScalarLiteral(GraphQLScalarType scalarType, Value
             scalarType.getCoercing().parseLiteral(instanceValue);
             return true;
         } catch (CoercingParseLiteralException ex) {
-            log.debug("Attempted parsing literal into '{}' but got the following error: ", scalarType.getName(), ex);
+            logNotSafe.debug("Attempted parsing literal into '{}' but got the following error: ", scalarType.getName(), ex);
             return false;
         }
     }

File: src/main/java/graphql/schema/GraphQLArgument.java
Patch:
@@ -38,7 +38,7 @@
  * specific value on that directive.
  */
 @PublicApi
-public class GraphQLArgument implements GraphQLDirectiveContainer {
+public class GraphQLArgument implements GraphQLInputValue {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -27,7 +27,7 @@
  * See http://graphql.org/learn/schema/#input-types for more details on the concept.
  */
 @PublicApi
-public class GraphQLInputObjectField implements GraphQLDirectiveContainer {
+public class GraphQLInputObjectField implements GraphQLInputValue {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/util/TreeTransformerUtil.java
Patch:
@@ -25,7 +25,7 @@ public static <T> TraversalControl changeNode(TraverserContext<T> context, T cha
         if (context.isParallel()) {
             Queue<NodeZipper<T>> zippers = context.getSharedContextData();
             if (changed) {
-                throw new RuntimeException("multiple changes per node not supported for parallel");
+                throw new RuntimeException("multiple changes per node is not supported for parallel traversing");
             } else {
                 zippers.add(zipperWithChangedNode);
                 context.changeNode(changedNode);

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -197,8 +197,9 @@ public SchemaElementChildrenContainer getChildrenWithTypeReferences() {
                 .build();
     }
 
+    // Spock mocking fails with the real return type GraphQLFieldDefinition
     @Override
-    public GraphQLFieldDefinition withNewChildren(SchemaElementChildrenContainer newChildren) {
+    public GraphQLSchemaElement withNewChildren(SchemaElementChildrenContainer newChildren) {
         return transform(builder ->
                 builder.directives(newChildren.getChildren(CHILD_DIRECTIVES))
                         .replaceArguments(newChildren.getChildren(CHILD_ARGUMENTS))

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -208,8 +208,9 @@ public SchemaElementChildrenContainer getChildrenWithTypeReferences() {
                 .build();
     }
 
+    // Spock mocking fails with the real return type GraphQLObjectType
     @Override
-    public GraphQLObjectType withNewChildren(SchemaElementChildrenContainer newChildren) {
+    public GraphQLSchemaElement withNewChildren(SchemaElementChildrenContainer newChildren) {
         return transform(builder ->
                 builder.replaceDirectives(newChildren.getChildren(CHILD_DIRECTIVES))
                         .replaceFields(newChildren.getChildren(CHILD_FIELD_DEFINITIONS))

File: src/main/java/graphql/schema/SchemaUtil.java
Patch:
@@ -13,7 +13,7 @@
 @Internal
 public class SchemaUtil {
 
-    private static final TypeTraverser TRAVERSER = new TypeTraverser();
+    private static final SchemaTraverser TRAVERSER = new SchemaTraverser();
 
 
     Map<String, GraphQLNamedType> allTypes(final GraphQLSchema schema, final Set<GraphQLType> additionalTypes) {

File: src/main/java/graphql/schema/DefaultGraphqlTypeComparatorRegistry.java
Patch:
@@ -16,9 +16,7 @@
 @PublicApi
 public class DefaultGraphqlTypeComparatorRegistry implements GraphqlTypeComparatorRegistry {
 
-    public static final Comparator<GraphQLSchemaElement> DEFAULT_COMPARATOR = Comparator.comparing(graphQLSchemaElement -> {
-        return ((GraphQLNamedType) graphQLSchemaElement).getName();
-    });
+    public static final Comparator<GraphQLSchemaElement> DEFAULT_COMPARATOR = Comparator.comparing(graphQLSchemaElement -> ((GraphQLNamedSchemaElement) graphQLSchemaElement).getName());
 
     private Map<GraphqlTypeComparatorEnvironment, Comparator<?>> registry = new HashMap<>();
 

File: src/main/java/graphql/schema/GraphQLNamedType.java
Patch:
@@ -1,7 +1,6 @@
 package graphql.schema;
 
-public interface GraphQLNamedType extends GraphQLType {
+public interface GraphQLNamedType extends GraphQLType, GraphQLNamedSchemaElement {
 
-    String getName();
 
 }

File: src/main/java/graphql/schema/GraphqlTypeComparators.java
Patch:
@@ -41,7 +41,7 @@ public static Comparator<? super GraphQLSchemaElement> asIsOrder() {
      * @return a comparator that compares {@link graphql.schema.GraphQLType} objects by ascending name
      */
     public static Comparator<? super GraphQLSchemaElement> byNameAsc() {
-        return Comparator.comparing(graphQLSchemaElement -> ((GraphQLNamedType) graphQLSchemaElement).getName());
+        return Comparator.comparing(graphQLSchemaElement -> ((GraphQLNamedSchemaElement) graphQLSchemaElement).getName());
     }
 
 }

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -810,7 +810,7 @@ protected Description newDescription(GraphqlParser.DescriptionContext descriptio
     }
 
     protected SourceLocation getSourceLocation(Token token) {
-        return SourceLocationHelper.mkSourceLocation(multiSourceReader, token);
+        return AntlrHelper.createSourceLocation(multiSourceReader, token);
     }
 
     protected SourceLocation getSourceLocation(ParserRuleContext parserRuleContext) {

File: src/main/java/graphql/parser/Parser.java
Patch:
@@ -59,7 +59,9 @@ public Document parseDocument(Reader reader) throws InvalidSyntaxException {
         lexer.addErrorListener(new BaseErrorListener() {
             @Override
             public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
-                throw new InvalidSyntaxException(new SourceLocation(line, charPositionInLine), "Invalid syntax: " + msg, null, null, null);
+                SourceLocation sourceLocation = AntlrHelper.createSourceLocation(multiSourceReader, line, charPositionInLine);
+                String preview = AntlrHelper.createPreview(multiSourceReader, line);
+                throw new InvalidSyntaxException(sourceLocation, "Invalid syntax: " + msg, preview, null, null);
             }
         });
 

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -810,7 +810,7 @@ protected Description newDescription(GraphqlParser.DescriptionContext descriptio
     }
 
     protected SourceLocation getSourceLocation(Token token) {
-        return SourceLocationHelper.mkSourceLocation(multiSourceReader, token);
+        return AntlrHelper.createSourceLocation(multiSourceReader, token);
     }
 
     protected SourceLocation getSourceLocation(ParserRuleContext parserRuleContext) {

File: src/main/java/graphql/parser/Parser.java
Patch:
@@ -59,7 +59,9 @@ public Document parseDocument(Reader reader) throws InvalidSyntaxException {
         lexer.addErrorListener(new BaseErrorListener() {
             @Override
             public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
-                throw new InvalidSyntaxException(new SourceLocation(line, charPositionInLine), "Invalid syntax: " + msg, null, null, null);
+                SourceLocation sourceLocation = AntlrHelper.createSourceLocation(multiSourceReader, line, charPositionInLine);
+                String preview = AntlrHelper.createPreview(multiSourceReader, line);
+                throw new InvalidSyntaxException(sourceLocation, "Invalid syntax: " + msg, preview, null, null);
             }
         });
 

File: src/main/java/graphql/schema/idl/SchemaGeneratorDirectiveHelper.java
Patch:
@@ -33,7 +33,7 @@
  * to be invoked during schema generation.
  */
 @Internal
-class SchemaGeneratorDirectiveHelper {
+public class SchemaGeneratorDirectiveHelper {
 
     static class Parameters {
         private final TypeDefinitionRegistry typeRegistry;

File: src/main/java/graphql/execution/ExecutionContext.java
Patch:
@@ -53,10 +53,10 @@ public class ExecutionContext {
         this.queryStrategy = queryStrategy;
         this.mutationStrategy = mutationStrategy;
         this.subscriptionStrategy = subscriptionStrategy;
-        this.fragmentsByName = fragmentsByName;
+        this.fragmentsByName = Collections.unmodifiableMap(fragmentsByName);
+        this.variables = Collections.unmodifiableMap(variables);
         this.document = document;
         this.operationDefinition = operationDefinition;
-        this.variables = variables;
         this.context = context;
         this.root = root;
         this.instrumentation = instrumentation;

File: src/main/java/graphql/execution/ExecutionContextBuilder.java
Patch:
@@ -13,7 +13,6 @@
 import org.dataloader.DataLoaderRegistry;
 
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -75,8 +74,8 @@ public ExecutionContextBuilder() {
         root = other.getRoot();
         document = other.getDocument();
         operationDefinition = other.getOperationDefinition();
-        variables = new HashMap<>(other.getVariables());
-        fragmentsByName = new HashMap<>(other.getFragmentsByName());
+        variables = new LinkedHashMap<>(other.getVariables());
+        fragmentsByName = new LinkedHashMap<>(other.getFragmentsByName());
         dataLoaderRegistry = other.getDataLoaderRegistry();
         cacheControl = other.getCacheControl();
         errors = new ArrayList<>(other.getErrors());

File: src/main/java/graphql/execution/ExecutionContextBuilder.java
Patch:
@@ -147,7 +147,6 @@ public ExecutionContextBuilder operationDefinition(OperationDefinition operation
         return this;
     }
 
-
     public ExecutionContextBuilder dataLoaderRegistry(DataLoaderRegistry dataLoaderRegistry) {
         this.dataLoaderRegistry = assertNotNull(dataLoaderRegistry);
         return this;
@@ -181,4 +180,5 @@ public ExecutionContext build() {
                 errors
         );
     }
+
 }

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -332,6 +332,7 @@ private static String print(Object value, GraphQLInputType type) {
     public enum DirectiveLocation {
         QUERY,
         MUTATION,
+        SUBSCRIPTION,
         FIELD,
         FRAGMENT_DEFINITION,
         FRAGMENT_SPREAD,

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -1,6 +1,7 @@
 package graphql.execution;
 
 
+import graphql.DeferredExecutionResult;
 import graphql.ExecutionInput;
 import graphql.ExecutionResult;
 import graphql.ExecutionResultImpl;
@@ -186,7 +187,7 @@ private CompletableFuture<ExecutionResult> deferSupport(ExecutionContext executi
             if (deferSupport.isDeferDetected()) {
                 // we start the rest of the query now to maximize throughput.  We have the initial important results
                 // and now we can start the rest of the calls as early as possible (even before some one subscribes)
-                Publisher<ExecutionResult> publisher = deferSupport.startDeferredCalls();
+                Publisher<DeferredExecutionResult> publisher = deferSupport.startDeferredCalls();
                 return ExecutionResultImpl.newExecutionResult().from(er)
                         .addExtension(GraphQL.DEFERRED_RESULTS, publisher)
                         .build();

File: src/test/groovy/graphql/execution/reactive/SingleSubscriberPublisherTckVerificationTest.java
Patch:
@@ -3,12 +3,14 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.tck.PublisherVerification;
 import org.reactivestreams.tck.TestEnvironment;
+import org.testng.annotations.Test;
 
 import java.time.Duration;
 
 /**
  * This uses the reactive streams TCK to test that our implementation meets spec
  */
+@Test
 public class SingleSubscriberPublisherTckVerificationTest extends PublisherVerification<String> {
 
     public SingleSubscriberPublisherTckVerificationTest() {

File: src/main/java/graphql/schema/idl/SchemaGeneratorHelper.java
Patch:
@@ -29,6 +29,7 @@
 import graphql.schema.GraphQLScalarType;
 import graphql.schema.GraphQLType;
 import graphql.schema.GraphQLTypeUtil;
+import graphql.schema.GraphqlTypeComparatorRegistry;
 import graphql.util.FpKit;
 
 import java.util.ArrayList;
@@ -226,11 +227,12 @@ private Value getArrayValueWrappedType(ArrayValue value) {
     }
 
     // builds directives from a type and its extensions
-    public GraphQLDirective buildDirective(Directive directive, Set<GraphQLDirective> directiveDefinitions, DirectiveLocation directiveLocation) {
+    public GraphQLDirective buildDirective(Directive directive, Set<GraphQLDirective> directiveDefinitions, DirectiveLocation directiveLocation, GraphqlTypeComparatorRegistry comparatorRegistry) {
         Optional<GraphQLDirective> directiveDefinition = directiveDefinitions.stream().filter(dd -> dd.getName().equals(directive.getName())).findFirst();
         GraphQLDirective.Builder builder = GraphQLDirective.newDirective()
                 .name(directive.getName())
                 .description(buildDescription(directive, null))
+                .comparatorRegistry(comparatorRegistry)
                 .validLocations(directiveLocation);
 
         List<GraphQLArgument> arguments = directive.getArguments().stream()

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -309,6 +309,7 @@ FetchedValue unboxPossibleDataFetcherResult(ExecutionContext executionContext,
             return FetchedValue.newFetchedValue()
                     .fetchedValue(UnboxPossibleOptional.unboxPossibleOptional(result))
                     .rawFetchedValue(result)
+                    .localContext(parameters.getLocalContext())
                     .build();
         }
     }

File: src/main/java/graphql/schema/idl/TypeDefinitionRegistry.java
Patch:
@@ -205,7 +205,7 @@ public Optional<GraphQLError> add(SDLDefinition definition) {
     }
 
     public void remove(SDLDefinition definition) {
-        assertNotNull("definition to remove can't be null");
+        assertNotNull(definition, "definition to remove can't be null");
         if (definition instanceof ObjectTypeExtensionDefinition) {
             removeFromList(objectTypeExtensions, (TypeDefinition) definition);
         } else if (definition instanceof InterfaceTypeExtensionDefinition) {

File: src/main/java/graphql/util/NodeZipper.java
Patch:
@@ -60,7 +60,7 @@ public static <T> NodeZipper<T> rootZipper(T rootNode, NodeAdapter<T> nodeAdapte
     }
 
     public NodeZipper<T> modifyNode(Function<T, T> transform) {
-        return new NodeZipper<T>(transform.apply(curNode), breadcrumbs, nodeAdapter);
+        return new NodeZipper<T>(transform.apply(curNode), breadcrumbs, nodeAdapter, this.modificationType);
     }
 
     public NodeZipper<T> deleteNode() {
@@ -76,13 +76,13 @@ public NodeZipper<T> insertBefore(T toInsertBefore) {
     }
 
     public NodeZipper<T> withNewNode(T newNode) {
-        return new NodeZipper<T>(newNode, breadcrumbs, nodeAdapter);
+        return new NodeZipper<T>(newNode, breadcrumbs, nodeAdapter, this.modificationType);
     }
 
     public NodeZipper<T> moveUp() {
         T node = getParent();
         List<Breadcrumb<T>> newBreadcrumbs = breadcrumbs.subList(1, breadcrumbs.size());
-        return new NodeZipper<>(node, newBreadcrumbs, nodeAdapter);
+        return new NodeZipper<>(node, newBreadcrumbs, nodeAdapter, this.modificationType);
     }
 
     public T toRoot() {

File: src/main/java/graphql/util/TraverserContext.java
Patch:
@@ -149,7 +149,7 @@ public interface TraverserContext<T> {
     /**
      * Sets the new accumulate value.
      *
-     * Can be retrieved by getA
+     * Can be retrieved by {@link #getNewAccumulate()}
      *
      * @param accumulate to set
      */

File: src/main/java/graphql/ExecutionInput.java
Patch:
@@ -150,7 +150,7 @@ public static class Builder {
         private Object root;
         private Map<String, Object> variables = Collections.emptyMap();
         private DataLoaderRegistry dataLoaderRegistry = new DataLoaderRegistry();
-        private CacheControl cacheControl;
+        private CacheControl cacheControl = CacheControl.newCacheControl();
 
         public Builder query(String query) {
             this.query = query;
@@ -209,7 +209,7 @@ public Builder dataLoaderRegistry(DataLoaderRegistry dataLoaderRegistry) {
         }
 
         public Builder cacheControl(CacheControl cacheControl) {
-            this.cacheControl = cacheControl;
+            this.cacheControl = assertNotNull(cacheControl);
             return this;
         }
 

File: src/main/java/graphql/cachecontrol/CacheControl.java
Patch:
@@ -7,9 +7,11 @@
 import graphql.schema.DataFetchingEnvironment;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 import static graphql.Assert.assertNotNull;
 import static graphql.util.FpKit.map;
@@ -67,7 +69,7 @@ Map<String, Object> toMap() {
     private final List<Hint> hints;
 
     private CacheControl() {
-        hints = new ArrayList<>();
+        hints = new CopyOnWriteArrayList<>();
     }
 
 

File: src/main/java/graphql/execution/nextgen/result/UnresolvedObjectResultNode.java
Patch:
@@ -7,7 +7,7 @@
 public class UnresolvedObjectResultNode extends ObjectExecutionResultNode {
 
     public UnresolvedObjectResultNode(FetchedValueAnalysis fetchedValueAnalysis) {
-        super(fetchedValueAnalysis, Collections.emptyList());
+        super(fetchedValueAnalysis, Collections.emptyList(), Collections.emptyList());
     }
 
     @Override

File: src/main/java/graphql/ExecutionInput.java
Patch:
@@ -146,7 +146,7 @@ public static class Builder {
 
         private String query;
         private String operationName;
-        private Object context = GraphQLContext.newContext();
+        private Object context = GraphQLContext.newContext().build();
         private Object root;
         private Map<String, Object> variables = Collections.emptyMap();
         private DataLoaderRegistry dataLoaderRegistry = new DataLoaderRegistry();

File: src/main/java/graphql/execution/ExecutionStepInfo.java
Patch:
@@ -233,6 +233,7 @@ private Builder(ExecutionStepInfo existing) {
             this.type = existing.type;
             this.parentInfo = existing.parent;
             this.fieldDefinition = existing.fieldDefinition;
+            this.fieldContainer = existing.fieldContainer;
             this.field = existing.field;
             this.path = existing.path;
             this.arguments = existing.getArguments();

File: src/main/java/graphql/schema/GraphQLSchema.java
Patch:
@@ -290,7 +290,7 @@ public static class Builder {
         private Set<GraphQLType> additionalTypes = new LinkedHashSet<>();
         // we default these in
         private Set<GraphQLDirective> additionalDirectives = new LinkedHashSet<>(
-                asList(Directives.IncludeDirective, Directives.SkipDirective, Directives.DeferDirective)
+                asList(Directives.IncludeDirective, Directives.SkipDirective)
         );
 
         private SchemaUtil schemaUtil = new SchemaUtil();

File: src/main/java/graphql/validation/rules/FragmentsOnCompositeType.java
Patch:
@@ -36,7 +36,7 @@ public void checkFragmentDefinition(FragmentDefinition fragmentDefinition) {
         if (type == null) return;
         if (!(type instanceof GraphQLCompositeType)) {
             String message = "Fragment type condition is invalid, must be on Object/Interface/Union";
-            addError(ValidationErrorType.InlineFragmentTypeConditionInvalid, fragmentDefinition.getSourceLocation(), message);
+            addError(ValidationErrorType.FragmentTypeConditionInvalid, fragmentDefinition.getSourceLocation(), message);
         }
     }
 }

File: src/main/java/graphql/validation/rules/OverlappingFieldsCanBeMerged.java
Patch:
@@ -305,14 +305,14 @@ private void collectFieldsForFragmentSpread(Map<String, List<FieldAndType>> fiel
             return;
         }
         visitedFragmentSpreads.add(fragment.getName());
-        GraphQLOutputType graphQLType = (GraphQLOutputType) TypeFromAST.getTypeFromAST(getValidationContext().getSchema(),
+        GraphQLType graphQLType = TypeFromAST.getTypeFromAST(getValidationContext().getSchema(),
                 fragment.getTypeCondition());
         collectFields(fieldMap, fragment.getSelectionSet(), graphQLType, visitedFragmentSpreads);
     }
 
     private void collectFieldsForInlineFragment(Map<String, List<FieldAndType>> fieldMap, Set<String> visitedFragmentSpreads, GraphQLType parentType, InlineFragment inlineFragment) {
         GraphQLType graphQLType = inlineFragment.getTypeCondition() != null
-                ? (GraphQLOutputType) TypeFromAST.getTypeFromAST(getValidationContext().getSchema(), inlineFragment.getTypeCondition())
+                ? TypeFromAST.getTypeFromAST(getValidationContext().getSchema(), inlineFragment.getTypeCondition())
                 : parentType;
         collectFields(fieldMap, inlineFragment.getSelectionSet(), graphQLType, visitedFragmentSpreads);
     }

File: src/main/java/graphql/validation/rules/FragmentsOnCompositeType.java
Patch:
@@ -36,7 +36,7 @@ public void checkFragmentDefinition(FragmentDefinition fragmentDefinition) {
         if (type == null) return;
         if (!(type instanceof GraphQLCompositeType)) {
             String message = "Fragment type condition is invalid, must be on Object/Interface/Union";
-            addError(ValidationErrorType.InlineFragmentTypeConditionInvalid, fragmentDefinition.getSourceLocation(), message);
+            addError(ValidationErrorType.FragmentTypeConditionInvalid, fragmentDefinition.getSourceLocation(), message);
         }
     }
 }

File: src/main/java/graphql/validation/rules/OverlappingFieldsCanBeMerged.java
Patch:
@@ -305,14 +305,14 @@ private void collectFieldsForFragmentSpread(Map<String, List<FieldAndType>> fiel
             return;
         }
         visitedFragmentSpreads.add(fragment.getName());
-        GraphQLOutputType graphQLType = (GraphQLOutputType) TypeFromAST.getTypeFromAST(getValidationContext().getSchema(),
+        GraphQLType graphQLType = TypeFromAST.getTypeFromAST(getValidationContext().getSchema(),
                 fragment.getTypeCondition());
         collectFields(fieldMap, fragment.getSelectionSet(), graphQLType, visitedFragmentSpreads);
     }
 
     private void collectFieldsForInlineFragment(Map<String, List<FieldAndType>> fieldMap, Set<String> visitedFragmentSpreads, GraphQLType parentType, InlineFragment inlineFragment) {
         GraphQLType graphQLType = inlineFragment.getTypeCondition() != null
-                ? (GraphQLOutputType) TypeFromAST.getTypeFromAST(getValidationContext().getSchema(), inlineFragment.getTypeCondition())
+                ? TypeFromAST.getTypeFromAST(getValidationContext().getSchema(), inlineFragment.getTypeCondition())
                 : parentType;
         collectFields(fieldMap, inlineFragment.getSelectionSet(), graphQLType, visitedFragmentSpreads);
     }

File: src/main/java/graphql/ErrorClassification.java
Patch:
@@ -8,5 +8,5 @@
  * graphql-java ships with a standard set of error classifications via {@link graphql.ErrorType}
  */
 @PublicApi
-public interface ErrorTypeClassification {
+public interface ErrorClassification {
 }

File: src/main/java/graphql/ErrorType.java
Patch:
@@ -5,7 +5,7 @@
  * All the errors in graphql belong to one of these categories
  */
 @PublicApi
-public enum ErrorType implements ErrorTypeClassification {
+public enum ErrorType implements ErrorClassification {
     InvalidSyntax,
     ValidationError,
     DataFetchingException,

File: src/main/java/graphql/GraphQLError.java
Patch:
@@ -34,7 +34,7 @@ public interface GraphQLError extends Serializable {
     /**
      * @return an object classifying this error
      */
-    ErrorTypeClassification getErrorType();
+    ErrorClassification getErrorType();
 
     /**
      * The graphql spec says that the (optional) path field of any error should be a list

File: src/main/java/graphql/ErrorType.java
Patch:
@@ -5,7 +5,7 @@
  * All the errors in graphql belong to one of these categories
  */
 @PublicApi
-public enum ErrorType {
+public enum ErrorType implements ErrorTypeClassification {
     InvalidSyntax,
     ValidationError,
     DataFetchingException,

File: src/main/java/graphql/GraphQLError.java
Patch:
@@ -32,9 +32,9 @@ public interface GraphQLError extends Serializable {
     List<SourceLocation> getLocations();
 
     /**
-     * @return an enum classifying this error
+     * @return an object classifying this error
      */
-    ErrorType getErrorType();
+    ErrorTypeClassification getErrorType();
 
     /**
      * The graphql spec says that the (optional) path field of any error should be a list

File: src/main/java/graphql/execution/AbsoluteGraphQLError.java
Patch:
@@ -1,6 +1,7 @@
 package graphql.execution;
 
 import graphql.ErrorType;
+import graphql.ErrorTypeClassification;
 import graphql.GraphQLError;
 import graphql.Internal;
 import graphql.language.SourceLocation;
@@ -25,7 +26,7 @@ public class AbsoluteGraphQLError implements GraphQLError {
     private final List<SourceLocation> locations;
     private final List<Object> absolutePath;
     private final String message;
-    private final ErrorType errorType;
+    private final ErrorTypeClassification errorType;
     private final Map<String, Object> extensions;
 
     public AbsoluteGraphQLError(ExecutionStrategyParameters executionStrategyParameters, GraphQLError relativeError) {
@@ -68,7 +69,7 @@ public List<SourceLocation> getLocations() {
     }
 
     @Override
-    public ErrorType getErrorType() {
+    public ErrorTypeClassification getErrorType() {
         return errorType;
     }
 

File: src/main/java/graphql/relay/Relay.java
Patch:
@@ -27,6 +27,7 @@
 import static graphql.schema.GraphQLList.list;
 import static graphql.schema.GraphQLNonNull.nonNull;
 import static graphql.schema.GraphQLObjectType.newObject;
+import static graphql.schema.GraphQLTypeReference.typeRef;
 
 /**
  * This can be used to compose graphql runtime types that implement
@@ -39,7 +40,7 @@ public class Relay {
 
     public static final String NODE = "Node";
 
-    private final GraphQLObjectType pageInfoType = newObject()
+    public static final GraphQLObjectType pageInfoType = newObject()
             .name("PageInfo")
             .description("Information about pagination in a connection.")
             .field(newFieldDefinition()
@@ -167,7 +168,7 @@ public GraphQLObjectType connectionType(String name, GraphQLObjectType edgeType,
                 .field(newFieldDefinition()
                         .name("pageInfo")
                         .description("details about this specific page")
-                        .type(nonNull(pageInfoType)))
+                        .type(nonNull(typeRef("PageInfo"))))
                 .fields(connectionFields)
                 .build();
     }

File: src/test/groovy/readme/DirectivesExamples.java
Patch:
@@ -64,8 +64,7 @@ public Object get(DataFetchingEnvironment dataFetchingEnvironment) throws Except
             };
             //
             // now change the field definition to have the new authorising data fetcher
-            FieldCoordinates coordinates = FieldCoordinates.coordinates(parentType, field);
-            environment.getCodeRegistry().dataFetcher(coordinates, authDataFetcher);
+            environment.getCodeRegistry().dataFetcher(parentType, field, authDataFetcher);
             return field;
         }
     }

File: src/main/java/graphql/util/NodeZipper.java
Patch:
@@ -48,7 +48,7 @@ public NodeZipper<T> withNewNode(T newNode) {
         return new NodeZipper<T>(newNode, breadcrumbs, nodeAdapter);
     }
 
-    public NodeZipper moveUp() {
+    public NodeZipper<T> moveUp() {
         T node = getParent();
         List<Breadcrumb<T>> newBreadcrumbs = breadcrumbs.subList(1, breadcrumbs.size());
         return new NodeZipper<>(node, newBreadcrumbs, nodeAdapter);

File: src/main/java/graphql/util/NodeZipper.java
Patch:
@@ -48,7 +48,7 @@ public NodeZipper<T> withNewNode(T newNode) {
         return new NodeZipper<T>(newNode, breadcrumbs, nodeAdapter);
     }
 
-    public NodeZipper moveUp() {
+    public NodeZipper<T> moveUp() {
         T node = getParent();
         List<Breadcrumb<T>> newBreadcrumbs = breadcrumbs.subList(1, breadcrumbs.size());
         return new NodeZipper<>(node, newBreadcrumbs, nodeAdapter);

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -768,6 +768,7 @@ protected ExecutionResult handleNonNullException(ExecutionContext executionConte
      * @param executionContext the execution context  in play
      * @param parameters       contains the parameters holding the fields to be executed and source object
      * @param fieldDefinition  the field definition to build type info for
+     * @param fieldContainer  the field container
      *
      * @return a new type info
      */

File: src/main/java/graphql/util/Breadcrumb.java
Patch:
@@ -10,7 +10,7 @@
  *
  * A list of Breadcrumbs is used to identify the exact location of a specific node inside a tree.
  *
- * @param <T>
+ * @param <T> the generic type of object
  */
 @PublicApi
 public class Breadcrumb<T> {

File: src/main/java/graphql/util/NodeAdapter.java
Patch:
@@ -9,7 +9,7 @@
  * Adapts an arbitrary class to behave as a node.
  * We are using an Adapter because we don't want to require Nodes to implement a certain Interface.
  *
- * @param <T>
+ * @param <T> the generic type of object
  */
 @PublicApi
 public interface NodeAdapter<T> {

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -211,7 +211,9 @@ private NodePrinter<FragmentSpread> fragmentSpread() {
 
     private NodePrinter<InlineFragment> inlineFragment() {
         return (out, node) -> {
-            String typeCondition = wrap("on ", type(node.getTypeCondition()), "");
+            TypeName typeName = node.getTypeCondition();
+            //Inline fragments may not have a type condition
+            String typeCondition = typeName == null ? "" : wrap("on ", type(typeName), "");
             String directives = directives(node.getDirectives());
             String selectionSet = node(node.getSelectionSet());
 

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -211,7 +211,9 @@ private NodePrinter<FragmentSpread> fragmentSpread() {
 
     private NodePrinter<InlineFragment> inlineFragment() {
         return (out, node) -> {
-            String typeCondition = wrap("on ", type(node.getTypeCondition()), "");
+            TypeName typeName = node.getTypeCondition();
+            //Inline fragments may not have a type condition
+            String typeCondition = typeName == null ? "" : wrap("on ", type(typeName), "");
             String directives = directives(node.getDirectives());
             String selectionSet = node(node.getSelectionSet());
 

File: src/main/java/graphql/validation/ValidationErrorType.java
Patch:
@@ -29,6 +29,6 @@ public enum ValidationErrorType {
     InvalidFragmentType,
     LoneAnonymousOperationViolation,
     NonExecutableDefinition,
-    DuplicateOperationName
-
+    DuplicateOperationName,
+    DuplicateDirectiveName
 }

File: src/main/java/graphql/execution/ExecutionIdProvider.java
Patch:
@@ -5,6 +5,9 @@
  */
 public interface ExecutionIdProvider {
 
+    ExecutionIdProvider DEFAULT_EXECUTION_ID_PROVIDER = (query, operationName, context) -> ExecutionId.generate();
+
+
     /**
      * Allows provision of a unique identifier per query execution.
      *

File: src/main/java/graphql/language/NodeTraverser.java
Patch:
@@ -75,7 +75,6 @@ public TraversalControl leave(TraverserContext<Node> context) {
                 context.setVar(LeaveOrEnter.class, LeaveOrEnter.LEAVE);
                 return context.thisNode().accept(context, nodeVisitor);
             }
-
         };
         return doTraverse(roots, nodeTraverserVisitor);
     }

File: src/main/java/graphql/util/Breadcrumb.java
Patch:
@@ -7,7 +7,7 @@
 /**
  * A specific {@link NodeLocation} inside a node. This means  {@link #getNode()} returns a Node which has a child
  * at {@link #getLocation()}
- * <p/>
+ *
  * A list of Breadcrumbs is used to identify the exact location of a specific node inside a tree.
  *
  * @param <T>

File: src/main/java/graphql/language/NodeTraverser.java
Patch:
@@ -73,7 +73,7 @@ public TraversalControl enter(TraverserContext<Node> context) {
             @Override
             public TraversalControl leave(TraverserContext<Node> context) {
                 context.setVar(LeaveOrEnter.class, LeaveOrEnter.LEAVE);
-                return  context.thisNode().accept(context, nodeVisitor);
+                return context.thisNode().accept(context, nodeVisitor);
             }
         };
         return doTraverse(roots, nodeTraverserVisitor);

File: src/main/java/graphql/util/Breadcrumb.java
Patch:
@@ -7,7 +7,7 @@
 /**
  * A specific {@link NodeLocation} inside a node. This means  {@link #getNode()} returns a Node which has a child
  * at {@link #getLocation()}
- * <p/>
+ *
  * A list of Breadcrumbs is used to identify the exact location of a specific node inside a tree.
  *
  * @param <T>

File: src/main/java/graphql/language/NodeTraverser.java
Patch:
@@ -75,7 +75,6 @@ public TraversalControl leave(TraverserContext<Node> context) {
                 context.setVar(LeaveOrEnter.class, LeaveOrEnter.LEAVE);
                 return  context.thisNode().accept(context, nodeVisitor);
             }
-
         };
         return doTraverse(roots, nodeTraverserVisitor);
     }

File: src/main/java/graphql/language/NodeTraverser.java
Patch:
@@ -73,7 +73,7 @@ public TraversalControl enter(TraverserContext<Node> context) {
             @Override
             public TraversalControl leave(TraverserContext<Node> context) {
                 context.setVar(LeaveOrEnter.class, LeaveOrEnter.LEAVE);
-                return context.thisNode().accept(context, nodeVisitor);
+                return  context.thisNode().accept(context, nodeVisitor);
             }
 
         };

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -139,6 +139,7 @@ private CompletableFuture<ExecutionResult> executeOperation(ExecutionContext exe
         ExecutionStrategyParameters parameters = newParameters()
                 .executionStepInfo(executionStepInfo)
                 .source(root)
+                .localContext(executionContext.getContext())
                 .fields(fields)
                 .nonNullFieldValidator(nonNullableFieldValidator)
                 .path(path)

File: src/main/java/graphql/execution/nextgen/BatchedExecutionStrategy.java
Patch:
@@ -5,6 +5,7 @@
 import graphql.execution.ExecutionContext;
 import graphql.execution.ExecutionStepInfo;
 import graphql.execution.ExecutionStepInfoFactory;
+import graphql.execution.FetchedValue;
 import graphql.execution.MergedField;
 import graphql.execution.MergedSelectionSet;
 import graphql.execution.nextgen.result.ExecutionResultMultiZipper;

File: src/main/java/graphql/execution/nextgen/FetchedValueAnalysis.java
Patch:
@@ -3,6 +3,7 @@
 import graphql.GraphQLError;
 import graphql.Internal;
 import graphql.execution.ExecutionStepInfo;
+import graphql.execution.FetchedValue;
 import graphql.execution.MergedField;
 import graphql.schema.GraphQLObjectType;
 

File: src/main/java/graphql/execution/nextgen/FetchedValueAnalyzer.java
Patch:
@@ -7,6 +7,7 @@
 import graphql.execution.ExecutionContext;
 import graphql.execution.ExecutionStepInfo;
 import graphql.execution.ExecutionStepInfoFactory;
+import graphql.execution.FetchedValue;
 import graphql.execution.MergedField;
 import graphql.execution.NonNullableFieldWasNullException;
 import graphql.execution.ResolveType;

File: src/main/java/graphql/introspection/IntrospectionResultToSchema.java
Patch:
@@ -75,22 +75,22 @@ public Document createSchemaDefinition(Map<String, Object> introspectionResult)
         boolean nonDefaultQueryName = !"Query".equals(query.getName());
 
         SchemaDefinition.Builder schemaDefinition = SchemaDefinition.newSchemaDefinition();
-        schemaDefinition.operationTypeDefinition(OperationTypeDefinition.newOperationTypeDefinition().name("query").type(query).build());
+        schemaDefinition.operationTypeDefinition(OperationTypeDefinition.newOperationTypeDefinition().name("query").typeName(query).build());
 
         Map<String, Object> mutationType = (Map<String, Object>) schema.get("mutationType");
         boolean nonDefaultMutationName = false;
         if (mutationType != null) {
             TypeName mutation = TypeName.newTypeName().name((String) mutationType.get("name")).build();
             nonDefaultMutationName = !"Mutation".equals(mutation.getName());
-            schemaDefinition.operationTypeDefinition(OperationTypeDefinition.newOperationTypeDefinition().name("mutation").type(mutation).build());
+            schemaDefinition.operationTypeDefinition(OperationTypeDefinition.newOperationTypeDefinition().name("mutation").typeName(mutation).build());
         }
 
         Map<String, Object> subscriptionType = (Map<String, Object>) schema.get("subscriptionType");
         boolean nonDefaultSubscriptionName = false;
         if (subscriptionType != null) {
             TypeName subscription = TypeName.newTypeName().name(((String) subscriptionType.get("name"))).build();
             nonDefaultSubscriptionName = !"Subscription".equals(subscription.getName());
-            schemaDefinition.operationTypeDefinition(OperationTypeDefinition.newOperationTypeDefinition().name("subscription").type(subscription).build());
+            schemaDefinition.operationTypeDefinition(OperationTypeDefinition.newOperationTypeDefinition().name("subscription").typeName(subscription).build());
         }
 
         Document.Builder document = Document.newDocument();

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -293,7 +293,7 @@ private NodePrinter<OperationDefinition> operationDefinition() {
 
     private NodePrinter<OperationTypeDefinition> operationTypeDefinition() {
         String nameTypeSep = compactMode ? ":" : ": ";
-        return (out, node) -> out.printf("%s%s%s", node.getName(), nameTypeSep, type(node.getType()));
+        return (out, node) -> out.printf("%s%s%s", node.getName(), nameTypeSep, type(node.getTypeName()));
     }
 
     private NodePrinter<ObjectTypeDefinition> objectTypeDefinition() {

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -374,7 +374,7 @@ protected SchemaDefinition createSchemaDefinition(GraphqlParser.SchemaDefinition
     protected OperationTypeDefinition createOperationTypeDefinition(GraphqlParser.OperationTypeDefinitionContext ctx) {
         OperationTypeDefinition.Builder def = OperationTypeDefinition.newOperationTypeDefinition();
         def.name(ctx.operationType().getText());
-        def.type(createTypeName(ctx.typeName()));
+        def.typeName(createTypeName(ctx.typeName()));
         addCommonData(def, ctx);
         return def.build();
     }

File: src/main/java/graphql/schema/diff/SchemaDiff.java
Patch:
@@ -184,14 +184,14 @@ private void checkOperation(DiffCtx ctx, String opName, Optional<SchemaDefinitio
         OperationTypeDefinition oldOpTypeDefinition = oldOpTypeDef.get();
         OperationTypeDefinition newOpTypeDefinition = newOpTypeDef.get();
 
-        Type oldType = oldOpTypeDefinition.getType();
+        Type oldType = oldOpTypeDefinition.getTypeName();
         //
         // if we have no old op, then it must have been added (which is ok)
         Optional<TypeDefinition> oldTD = ctx.getOldTypeDef(oldType, TypeDefinition.class);
         if (!oldTD.isPresent()) {
             return;
         }
-        checkType(ctx, oldType, newOpTypeDefinition.getType());
+        checkType(ctx, oldType, newOpTypeDefinition.getTypeName());
     }
 
     private void checkType(DiffCtx ctx, Type oldType, Type newType) {
@@ -835,7 +835,7 @@ private Optional<OperationTypeDefinition> getOpDef(String opName, SchemaDefiniti
     private Optional<OperationTypeDefinition> synthOperationTypeDefinition(Function<Type, Optional<ObjectTypeDefinition>> typeReteriver, String opName) {
         TypeName type = TypeName.newTypeName().name(capitalize(opName)).build();
         Optional<ObjectTypeDefinition> typeDef = typeReteriver.apply(type);
-        return typeDef.map(objectTypeDefinition -> OperationTypeDefinition.newOperationTypeDefinition().name(opName).type(type).build());
+        return typeDef.map(objectTypeDefinition -> OperationTypeDefinition.newOperationTypeDefinition().name(opName).typeName(type).build());
     }
 
     private <T> Map<String, T> sortedMap(List<T> listOfNamedThings, Function<T, String> nameFunc) {

File: src/main/java/graphql/schema/idl/SchemaGenerator.java
Patch:
@@ -356,7 +356,7 @@ private GraphQLSchema makeExecutableSchemaImpl(BuildContext buildCtx) {
     }
 
     private GraphQLObjectType buildOperation(BuildContext buildCtx, OperationTypeDefinition operation) {
-        Type type = operation.getType();
+        Type type = operation.getTypeName();
 
         return buildOutputType(buildCtx, type);
     }

File: src/main/java/graphql/schema/idl/SchemaTypeChecker.java
Patch:
@@ -528,7 +528,7 @@ private void checkArgumentConsistency(String typeOfType, ObjectTypeDefinition ob
 
     private Consumer<OperationTypeDefinition> checkOperationTypesExist(TypeDefinitionRegistry typeRegistry, List<GraphQLError> errors) {
         return op -> {
-            TypeName unwrapped = TypeInfo.typeInfo(op.getType()).getTypeName();
+            TypeName unwrapped = TypeInfo.typeInfo(op.getTypeName()).getTypeName();
             if (!typeRegistry.hasType(unwrapped)) {
                 errors.add(new MissingTypeError("operation", op, op.getName(), unwrapped));
             }
@@ -538,7 +538,7 @@ private Consumer<OperationTypeDefinition> checkOperationTypesExist(TypeDefinitio
     private Consumer<OperationTypeDefinition> checkOperationTypesAreObjects(TypeDefinitionRegistry typeRegistry, List<GraphQLError> errors) {
         return op -> {
             // make sure it is defined as a ObjectTypeDef
-            Type queryType = op.getType();
+            Type queryType = op.getTypeName();
             Optional<TypeDefinition> type = typeRegistry.getType(queryType);
             type.ifPresent(typeDef -> {
                 if (!(typeDef instanceof ObjectTypeDefinition)) {

File: src/main/java/graphql/language/SDLDefinition.java
Patch:
@@ -6,7 +6,7 @@
 /**
  * All Schema Definition Language (SDL) Definitions.
  *
- * @param <T> for two
+ * @param <T> the actual Node type
  */
 @PublicApi
 public interface SDLDefinition<T extends SDLDefinition> extends Definition<T> {

File: src/main/java/graphql/language/SDLDefinition.java
Patch:
@@ -6,7 +6,7 @@
 /**
  * All Schema Definition Language (SDL) Definitions.
  *
- * @param <T> for two
+ * @param <T> the actual Node type
  */
 @PublicApi
 public interface SDLDefinition<T extends SDLDefinition> extends Definition<T> {

File: src/main/java/graphql/schema/idl/RuntimeWiring.java
Patch:
@@ -19,7 +19,7 @@
 import static graphql.schema.visibility.DefaultGraphqlFieldVisibility.DEFAULT_FIELD_VISIBILITY;
 
 /**
- * A runtime wiring is a specification of data fetchers, type resolves and custom scalars that are needed
+ * A runtime wiring is a specification of data fetchers, type resolvers and custom scalars that are needed
  * to wire together a functional {@link GraphQLSchema}
  */
 @PublicApi

File: src/main/java/graphql/schema/idl/RuntimeWiring.java
Patch:
@@ -19,7 +19,7 @@
 import static graphql.schema.visibility.DefaultGraphqlFieldVisibility.DEFAULT_FIELD_VISIBILITY;
 
 /**
- * A runtime wiring is a specification of data fetchers, type resolves and custom scalars that are needed
+ * A runtime wiring is a specification of data fetchers, type resolvers and custom scalars that are needed
  * to wire together a functional {@link GraphQLSchema}
  */
 @PublicApi

File: src/main/java/graphql/execution/nextgen/DefaultExecutionStrategy.java
Patch:
@@ -65,12 +65,12 @@ private List<CompletableFuture<NamedResultNode>> fetchedValueAnalysisToNodes(Lis
 
     private List<CompletableFuture<FetchedValueAnalysis>> fetchAndAnalyze(FieldSubSelection fieldSubSelection) {
         List<CompletableFuture<FetchedValueAnalysis>> fetchedValues = fieldSubSelection.getSubFields().entrySet().stream()
-                .map(entry -> mapmergedField(fieldSubSelection.getSource(), entry.getKey(), entry.getValue(), fieldSubSelection.getExecutionStepInfo()))
+                .map(entry -> mapMergedField(fieldSubSelection.getSource(), entry.getKey(), entry.getValue(), fieldSubSelection.getExecutionStepInfo()))
                 .collect(toList());
         return fetchedValues;
     }
 
-    private CompletableFuture<FetchedValueAnalysis> mapmergedField(Object source, String key, MergedField mergedField, ExecutionStepInfo executionStepInfo) {
+    private CompletableFuture<FetchedValueAnalysis> mapMergedField(Object source, String key, MergedField mergedField, ExecutionStepInfo executionStepInfo) {
         ExecutionStepInfo newExecutionStepInfo = executionInfoFactory.newExecutionStepInfoForSubField(executionContext, mergedField, executionStepInfo);
         return valueFetcher
                 .fetchValue(source, mergedField, newExecutionStepInfo)

File: src/main/java/graphql/language/DirectivesContainer.java
Patch:
@@ -9,13 +9,13 @@
 import static graphql.language.NodeUtil.directivesByName;
 
 /**
- * Represents a language node that has a name
+ * Represents a language node that can contain Directives.
  */
 @PublicApi
 public interface DirectivesContainer<T extends DirectivesContainer> extends NamedNode<T> {
 
     /**
-     * @return a list of directives associated with the type or field
+     * @return a list of directives associated with this Node
      */
     List<Directive> getDirectives();
 
@@ -27,7 +27,7 @@ default Map<String, Directive> getDirectivesByName() {
     }
 
     /**
-     * Returns a named directive
+     * Returns a directive with the provided name
      *
      * @param directiveName the name of the directive to retrieve
      *

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -651,7 +651,7 @@ protected Iterable<Object> toIterable(Object result) {
     }
 
     protected GraphQLObjectType resolveType(ExecutionContext executionContext, ExecutionStrategyParameters parameters, GraphQLType fieldType) {
-        return resolvedType.resolveType(executionContext, parameters.getField().getSingleField(), parameters.getSource(), parameters.getArguments(), fieldType);
+        return resolvedType.resolveType(executionContext, parameters.getField(), parameters.getSource(), parameters.getArguments(), fieldType);
     }
 
 

File: src/main/java/graphql/execution/ResolveType.java
Patch:
@@ -2,7 +2,6 @@
 
 import graphql.Internal;
 import graphql.TypeResolutionEnvironment;
-import graphql.language.Field;
 import graphql.schema.GraphQLInterfaceType;
 import graphql.schema.GraphQLObjectType;
 import graphql.schema.GraphQLType;
@@ -15,7 +14,7 @@
 public class ResolveType {
 
 
-    public GraphQLObjectType resolveType(ExecutionContext executionContext, Field field, Object source, Map<String, Object> arguments, GraphQLType fieldType) {
+    public GraphQLObjectType resolveType(ExecutionContext executionContext, MergedFields field, Object source, Map<String, Object> arguments, GraphQLType fieldType) {
         GraphQLObjectType resolvedType;
         if (fieldType instanceof GraphQLInterfaceType) {
             TypeResolutionParameters resolutionParams = TypeResolutionParameters.newParameters()

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -23,7 +23,6 @@
 import graphql.execution.instrumentation.parameters.InstrumentationExecutionStrategyParameters;
 import graphql.execution.instrumentation.parameters.InstrumentationFieldFetchParameters;
 import graphql.execution.instrumentation.parameters.InstrumentationFieldParameters;
-import graphql.language.Field;
 import graphql.schema.DataFetcher;
 import graphql.schema.DataFetchingEnvironment;
 import graphql.schema.DataFetchingFieldSelectionSet;
@@ -401,7 +400,7 @@ private List<ExecutionNode> handleObject(ExecutionContext executionContext, Map<
             }
             MapOrList childResult = mapOrList.createAndPutMap(fieldName);
 
-            GraphQLObjectType resolvedType = getGraphQLObjectType(executionContext, fields.getSingleField(), executionStepInfo.getUnwrappedNonNullType(), value.getValue(), argumentValues);
+            GraphQLObjectType resolvedType = getGraphQLObjectType(executionContext, fields, executionStepInfo.getUnwrappedNonNullType(), value.getValue(), argumentValues);
             resultsByType.putIfAbsent(resolvedType, new ArrayList<>());
             resultsByType.get(resolvedType).add(childResult);
 
@@ -446,7 +445,7 @@ private Map<String, MergedFields> getChildFields(ExecutionContext executionConte
         return fieldCollector.collectFields(collectorParameters, fields);
     }
 
-    private GraphQLObjectType getGraphQLObjectType(ExecutionContext executionContext, Field field, GraphQLType fieldType, Object value, Map<String, Object> argumentValues) {
+    private GraphQLObjectType getGraphQLObjectType(ExecutionContext executionContext, MergedFields field, GraphQLType fieldType, Object value, Map<String, Object> argumentValues) {
         return resolveType.resolveType(executionContext, field, value, argumentValues, fieldType);
     }
 

File: src/main/java/graphql/execution/nextgen/FetchedValueAnalyzer.java
Patch:
@@ -86,7 +86,7 @@ private FetchedValueAnalysis analyzeFetchedValueImpl(FetchedValue fetchedValue,
                         .nullValue()
                         .build();
             }
-            resolvedObjectType = resolveType.resolveType(executionContext, field.getSingleField(), toAnalyze, executionInfo.getArguments(), fieldType);
+            resolvedObjectType = resolveType.resolveType(executionContext, field, toAnalyze, executionInfo.getArguments(), fieldType);
             return analyzeObject(fetchedValue, toAnalyze, name, resolvedObjectType, executionInfo);
         } catch (UnresolvedTypeException ex) {
             return handleUnresolvedTypeProblem(fetchedValue, name, executionInfo, ex);

File: src/main/java/graphql/language/Node.java
Patch:
@@ -30,7 +30,7 @@ public interface Node<T extends Node> extends Serializable {
      * Alternative to {@link #getChildren()} where the children are not all in one list regardless of type
      * but grouped by name/type of the child.
      *
-     * @return
+     * @return a container of the child nodes
      */
     NodeChildrenContainer getNamedChildren();
 

File: src/main/java/graphql/language/AstZipper.java
Patch:
@@ -11,7 +11,8 @@
 
 /**
  * A zipper is a specific node inside a tree together with a list of breadcrumbs to pinpoint
- * the exact location of this node inside the tree from the root.<p/>
+ * the exact location of this node inside the tree from the root.
+ * <p>
  * It is used by {@link AstMultiZipper} and {@link AstTransformer} to allow for an easy way to "manipulate" the
  * immutable Ast.
  */

File: src/main/java/graphql/schema/CoercingParseLiteralException.java
Patch:
@@ -10,7 +10,7 @@
 import graphql.language.SourceLocation;
 
 @PublicApi
-public class CoercingParseLiteralException extends GraphQLException implements GraphQLError {
+public class    CoercingParseLiteralException extends GraphQLException implements GraphQLError {
     private List<SourceLocation> sourceLocations;
 
     public CoercingParseLiteralException() {

File: src/main/java/graphql/analysis/QueryTraversal.java
Patch:
@@ -17,6 +17,7 @@
 import graphql.language.OperationDefinition;
 import graphql.language.Selection;
 import graphql.language.TypeName;
+import graphql.schema.GraphQLCodeRegistry;
 import graphql.schema.GraphQLCompositeType;
 import graphql.schema.GraphQLFieldDefinition;
 import graphql.schema.GraphQLFieldsContainer;
@@ -256,7 +257,8 @@ public TraversalControl visitField(Field field, TraverserContext<Node> context)
             GraphQLFieldDefinition fieldDefinition = Introspection.getFieldDef(schema, parentEnv.getRawType(), field.getName());
             boolean isTypeNameIntrospectionField = fieldDefinition == Introspection.TypeNameMetaFieldDef;
             GraphQLFieldsContainer fieldsContainer = !isTypeNameIntrospectionField ? (GraphQLFieldsContainer) unwrapAll(parentEnv.getOutputType()) : null;
-            Map<String, Object> argumentValues = valuesResolver.getArgumentValues(schema.getCodeRegistry().getFieldVisibility(), fieldDefinition.getArguments(), field.getArguments(), variables);
+            GraphQLCodeRegistry codeRegistry = schema.getCodeRegistry();
+            Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDefinition.getArguments(), field.getArguments(), variables);
             QueryVisitorFieldEnvironment environment = new QueryVisitorFieldEnvironmentImpl(isTypeNameIntrospectionField,
                     field,
                     fieldDefinition,

File: src/main/java/graphql/execution/ExecutionStepInfoFactory.java
Patch:
@@ -4,6 +4,7 @@
 import graphql.introspection.Introspection;
 import graphql.language.Argument;
 import graphql.language.Field;
+import graphql.schema.GraphQLCodeRegistry;
 import graphql.schema.GraphQLFieldDefinition;
 import graphql.schema.GraphQLList;
 import graphql.schema.GraphQLObjectType;
@@ -26,8 +27,8 @@ public ExecutionStepInfo newExecutionStepInfoForSubField(ExecutionContext execut
         GraphQLFieldDefinition fieldDefinition = Introspection.getFieldDef(executionContext.getGraphQLSchema(), parentType, field.getName());
         GraphQLOutputType fieldType = fieldDefinition.getType();
         List<Argument> fieldArgs = field.getArguments();
-        GraphqlFieldVisibility fieldVisibility = executionContext.getGraphQLSchema().getFieldVisibility();
-        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(fieldVisibility, fieldDefinition.getArguments(), fieldArgs, executionContext.getVariables());
+        GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry();
+        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDefinition.getArguments(), fieldArgs, executionContext.getVariables());
 
         ExecutionPath newPath = parentInfo.getPath().segment(mkNameForPath(sameFields));
 

File: src/main/java/graphql/execution/nextgen/ValueFetcher.java
Patch:
@@ -24,7 +24,6 @@
 import graphql.schema.GraphQLFieldsContainer;
 import graphql.schema.GraphQLOutputType;
 import graphql.schema.GraphQLTypeUtil;
-import graphql.schema.visibility.GraphqlFieldVisibility;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -104,10 +103,9 @@ public CompletableFuture<FetchedValue> fetchValue(Object source, List<Field> sam
         GraphQLFieldDefinition fieldDef = executionInfo.getFieldDefinition();
 
         GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry();
-        GraphqlFieldVisibility fieldVisibility = codeRegistry.getFieldVisibility();
         GraphQLFieldsContainer parentType = getFieldsContainer(executionInfo);
 
-        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(fieldVisibility, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables());
+        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables());
 
         GraphQLOutputType fieldType = fieldDef.getType();
         DataFetchingFieldSelectionSet fieldCollector = DataFetchingFieldSelectionSetImpl.newCollector(executionContext, fieldType, sameFields);

File: src/main/java/graphql/schema/PropertyDataFetcher.java
Patch:
@@ -283,7 +283,7 @@ private Method findPubliclyAccessibleMethod(Class root, String methodName) throw
     }
 
     private Method findViaSetAccessible(Class aClass, String methodName) throws NoSuchMethodException {
-        if (! USE_SET_ACCESSIBLE.get()) {
+        if (!USE_SET_ACCESSIBLE.get()) {
             throw new FastNoSuchMethodException(methodName);
         }
         String key = mkKey(aClass, propertyName);
@@ -335,7 +335,7 @@ private Object getPropertyViaFieldAccess(Object object) {
             }
             return field.get(object);
         } catch (NoSuchFieldException e) {
-            if (! USE_SET_ACCESSIBLE.get()) {
+            if (!USE_SET_ACCESSIBLE.get()) {
                 return null;
             }
             // if not public fields then try via setAccessible

File: src/main/java/graphql/language/AstMultiZipper.java
Patch:
@@ -7,6 +7,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.function.Function;
 import java.util.stream.Collectors;
 
@@ -43,6 +44,8 @@ public Node toRootNode() {
             List<AstZipper> newZippers = new ArrayList<>();
             for (Map.Entry<Node, List<AstZipper>> entry : sameParent.entrySet()) {
                 AstZipper newZipper = moveUp(entry.getKey(), entry.getValue());
+                Optional<AstZipper> zipperToBeReplaced = curZippers.stream().filter(zipper -> zipper.getCurNode() == entry.getKey()).findFirst();
+                zipperToBeReplaced.ifPresent(curZippers::remove);
                 newZippers.add(newZipper);
             }
             curZippers.removeAll(deepestZippers);

File: src/main/java/graphql/util/Traverser.java
Patch:
@@ -139,7 +139,6 @@ public TraverserResult traverse(Collection<? extends T> roots, TraverserVisitor<
                 currentContext.setCurAccValue(currentAccValue);
                 TraversalControl traversalControl = visitor.enter(currentContext);
                 currentAccValue = currentContext.getNewAccumulate();
-                assertNotNull(traversalControl, "result of leave must not be null");
                 assertNotNull(traversalControl, "result of enter must not be null");
                 this.traverserState.addVisited((T) currentContext.thisNode());
                 switch (traversalControl) {

File: src/main/java/graphql/util/TraverserState.java
Patch:
@@ -23,6 +23,7 @@ public abstract class TraverserState<T> {
     private final Set<T> visited = new LinkedHashSet<>();
 
 
+    // used for depth first traversal
     private static class StackTraverserState<U> extends TraverserState<U> {
 
         private StackTraverserState(Object sharedContextData) {
@@ -45,6 +46,7 @@ public void pushAll(TraverserContext<U> traverserContext, Function<? super U, Ma
         }
     }
 
+    // used for breadth first traversal
     private static class QueueTraverserState<U> extends TraverserState<U> {
 
         private QueueTraverserState(Object sharedContextData) {

File: src/main/java/graphql/language/AstMultiZipper.java
Patch:
@@ -44,7 +44,7 @@ public Node toRootNode() {
             curZippers.removeAll(deepestZippers);
             curZippers.addAll(newZippers);
         }
-        assertTrue(curZippers.size() == 1, "illegal state");
+        assertTrue(curZippers.size() == 1, "unexpected state: all zippers must share the same root node");
         return curZippers.get(0).toRoot();
     }
 

File: src/main/java/graphql/schema/DataFetcher.java
Patch:
@@ -18,7 +18,7 @@ public interface DataFetcher<T> {
 
     /**
      * This is called by the graphql engine to fetch the value.  The {@link graphql.schema.DataFetchingEnvironment} is a composite
-     * context object that tells you all you need to know about who to fetch a data value in graphql type terms.
+     * context object that tells you all you need to know about how to fetch a data value in graphql type terms.
      *
      * @param environment this is the data fetching environment which contains all the context you need to fetch a value
      *

File: src/main/java/graphql/execution2/FetchedValueAnalyzer.java
Patch:
@@ -55,7 +55,7 @@ public FetchedValueAnalyzer(ExecutionContext executionContext) {
     private static final Logger log = LoggerFactory.getLogger(FetchedValueAnalyzer.class);
 
 
-    /**
+    /*
      * scalar: the value, null and/or error
      * enum: same as scalar
      * list: list of X: X can be list again, list of scalars or enum or objects

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -271,7 +271,7 @@ public Builder dataFetcher(DataFetcher<?> dataFetcher) {
         /**
          * Sets the {@link graphql.schema.DataFetcherFactory} to use with this field.
          *
-         *
+         * @param dataFetcherFactory the data fetcher factory
          * @return this builder
          *
          * @deprecated use {@link graphql.schema.GraphQLCodeRegistry} instead

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -29,6 +29,7 @@
 import graphql.schema.GraphQLScalarType;
 import graphql.schema.GraphQLSchema;
 import graphql.schema.GraphQLType;
+import graphql.schema.GraphQLUnionType;
 import graphql.schema.visibility.GraphqlFieldVisibility;
 import graphql.util.FpKit;
 import org.slf4j.Logger;
@@ -242,7 +243,7 @@ protected CompletableFuture<Object> fetchField(ExecutionContext executionContext
                 .selectionSet(fieldCollector)
                 .build();
 
-        DataFetcher dataFetcher = fieldDef.getDataFetcher();
+        DataFetcher dataFetcher = executionContext.getGraphQLSchema().getCodeRegistry().getDataFetcher(parentType, fieldDef);
 
         Instrumentation instrumentation = executionContext.getInstrumentation();
 

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -260,7 +260,7 @@ private CompletableFuture<FetchedValues> fetchData(ExecutionContext executionCon
                 .selectionSet(fieldCollector)
                 .build();
 
-        DataFetcher supplied = fieldDef.getDataFetcher();
+        DataFetcher supplied = executionContext.getGraphQLSchema().getCodeRegistry().getDataFetcher(parentType,fieldDef);
         boolean trivialDataFetcher = supplied instanceof TrivialDataFetcher;
         BatchedDataFetcher batchedDataFetcher = batchingFactory.create(supplied);
 

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -70,7 +70,6 @@ public GraphQLInterfaceType(String name, String description, List<GraphQLFieldDe
     @Deprecated
     public GraphQLInterfaceType(String name, String description, List<GraphQLFieldDefinition> fieldDefinitions, TypeResolver typeResolver, List<GraphQLDirective> directives, InterfaceTypeDefinition definition) {
         assertValidName(name);
-        assertNotNull(typeResolver, "typeResolver can't null");
         assertNotNull(fieldDefinitions, "fieldDefinitions can't null");
         assertNotNull(directives, "directives cannot be null");
 
@@ -111,7 +110,8 @@ public String getDescription() {
         return description;
     }
 
-    public TypeResolver getTypeResolver() {
+    // to be removed in a future version when all code is in the code registry
+    TypeResolver getTypeResolver() {
         return typeResolver;
     }
 
@@ -264,6 +264,7 @@ public Builder clearFields() {
         }
 
 
+        @Deprecated
         public Builder typeResolver(TypeResolver typeResolver) {
             this.typeResolver = typeResolver;
             return this;

File: src/main/java/graphql/schema/GraphQLUnionType.java
Patch:
@@ -72,7 +72,6 @@ public GraphQLUnionType(String name, String description, List<GraphQLOutputType>
         assertValidName(name);
         assertNotNull(types, "types can't be null");
         assertNotEmpty(types, "A Union type must define one or more member types.");
-        assertNotNull(typeResolver, "typeResolver can't be null");
         assertNotNull(directives, "directives cannot be null");
 
         this.name = name;
@@ -96,7 +95,8 @@ public List<GraphQLOutputType> getTypes() {
         return new ArrayList<>(types);
     }
 
-    public TypeResolver getTypeResolver() {
+    // to be removed in a future version when all code is in the code registry
+    TypeResolver getTypeResolver() {
         return typeResolver;
     }
 
@@ -189,6 +189,7 @@ public Builder definition(UnionTypeDefinition definition) {
         }
 
 
+        @Deprecated
         public Builder typeResolver(TypeResolver typeResolver) {
             this.typeResolver = typeResolver;
             return this;

File: src/main/java/graphql/schema/idl/FetchSchemaDirectiveWiring.java
Patch:
@@ -26,7 +26,8 @@ public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment<GraphQLFi
         String fetchName = atFetchFromSupport(field.getName(), field.getDirectives());
         DataFetcher dataFetcher = new PropertyDataFetcher(fetchName);
 
-        return field.transform(builder -> builder.dataFetcher(dataFetcher));
+        environment.getCodeRegistry().dataFetcher(environment.getFieldsContainer(), field, dataFetcher);
+        return field;
     }
 
 

File: src/main/java/graphql/util/FpKit.java
Patch:
@@ -7,6 +7,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.function.BinaryOperator;
@@ -26,7 +27,8 @@ public static <T> Map<String, T> getByName(List<T> namedObjects, Function<T, Str
         return namedObjects.stream().collect(Collectors.toMap(
                 nameFn,
                 identity(),
-                mergeFunc)
+                mergeFunc,
+                LinkedHashMap::new)
         );
     }
 

File: src/main/java/graphql/execution/UnboxPossibleOptional.java
Patch:
@@ -1,4 +1,4 @@
-package graphql.execution2;
+package graphql.execution;
 
 import graphql.Internal;
 

File: src/main/java/graphql/execution2/FetchedValueAnalyzer.java
Patch:
@@ -10,6 +10,7 @@
 import graphql.execution.FieldCollector;
 import graphql.execution.FieldCollectorParameters;
 import graphql.execution.NonNullableFieldWasNullException;
+import graphql.execution.ResolveType;
 import graphql.execution.UnresolvedTypeException;
 import graphql.language.Field;
 import graphql.schema.CoercingSerializeException;
@@ -47,7 +48,7 @@ public class FetchedValueAnalyzer {
 
     public FetchedValueAnalyzer(ExecutionContext executionContext) {
         this.executionContext = executionContext;
-        this.resolveType = new ResolveType(executionContext);
+        this.resolveType = new ResolveType();
         this.executionInfoFactory = new ExecutionStepInfoFactory();
     }
 
@@ -87,7 +88,7 @@ public FetchedValueAnalysis analyzeFetchedValue(Object toAnalyze, String name, L
                         .nullValue()
                         .build();
             }
-            resolvedObjectType = resolveType.resolveType(field.get(0), toAnalyze, executionInfo.getArguments(), fieldType);
+            resolvedObjectType = resolveType.resolveType(executionContext, field.get(0), toAnalyze, executionInfo.getArguments(), fieldType);
             return analyzeObject(toAnalyze, name, resolvedObjectType, executionInfo);
         } catch (UnresolvedTypeException ex) {
             return handleUnresolvedTypeProblem(name, executionInfo, ex);

File: src/main/java/graphql/execution2/ValueFetcher.java
Patch:
@@ -12,6 +12,7 @@
 import graphql.execution.ExecutionId;
 import graphql.execution.ExecutionPath;
 import graphql.execution.ExecutionStepInfo;
+import graphql.execution.UnboxPossibleOptional;
 import graphql.execution.ValuesResolver;
 import graphql.language.Field;
 import graphql.schema.DataFetcher;

File: src/main/java/graphql/execution/ExecutionStepInfoFactory.java
Patch:
@@ -8,7 +8,6 @@
 import graphql.schema.GraphQLList;
 import graphql.schema.GraphQLObjectType;
 import graphql.schema.GraphQLOutputType;
-import graphql.schema.GraphQLType;
 import graphql.schema.visibility.GraphqlFieldVisibility;
 
 import java.util.List;
@@ -43,7 +42,7 @@ public ExecutionStepInfo newExecutionStepInfoForSubField(ExecutionContext execut
 
     public ExecutionStepInfo newExecutionStepInfoForListElement(ExecutionStepInfo executionInfo, int index) {
         GraphQLList fieldType = (GraphQLList) executionInfo.getUnwrappedNonNullType();
-        GraphQLType typeInList = fieldType.getWrappedType();
+        GraphQLOutputType typeInList = (GraphQLOutputType) fieldType.getWrappedType();
         ExecutionPath indexedPath = executionInfo.getPath().segment(index);
         return executionInfo.transform(builder -> builder
                 .parentInfo(executionInfo)

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -376,7 +376,7 @@ private List<ExecutionNode> handleList(ExecutionContext executionContext, Map<St
             }
         }
         GraphQLOutputType innerSubType = (GraphQLOutputType) listType.getWrappedType();
-        ExecutionStepInfo newExecutionStepInfo = executionStepInfo.changeTypeWithPreservedNonNull(GraphQLTypeUtil.unwrapNonNull(innerSubType));
+        ExecutionStepInfo newExecutionStepInfo = executionStepInfo.changeTypeWithPreservedNonNull((GraphQLOutputType) GraphQLTypeUtil.unwrapNonNull(innerSubType));
         FetchedValues flattenedFetchedValues = new FetchedValues(flattenedValues, newExecutionStepInfo, fetchedValues.getPath());
 
         return completeValues(executionContext, flattenedFetchedValues, newExecutionStepInfo, fieldName, fields, argumentValues);

File: src/main/java/graphql/execution2/DefaultExecutionStrategy.java
Patch:
@@ -112,12 +112,12 @@ private CompletableFuture<List<FetchedValueAnalysis>> fetchAndAnalyze(FieldSubSe
                     List<Field> sameFields = entry.getValue();
                     String name = entry.getKey();
                     ExecutionStepInfo newExecutionStepInfo = executionInfoFactory.newExecutionStepInfoForSubField(sameFields, fieldSubSelection.getExecutionStepInfo());
+                    //
                     return valueFetcher
                             .fetchValue(fieldSubSelection.getSource(), sameFields, newExecutionStepInfo)
                             .thenApply(fetchValue -> analyseValue(fetchValue, name, sameFields, newExecutionStepInfo));
                 })
                 .collect(toList());
-
         return Async.each(fetchedValues);
     }
 

File: src/main/java/graphql/execution2/FetchedValueAnalysis.java
Patch:
@@ -13,7 +13,8 @@ public enum FetchedValueType {
         OBJECT,
         LIST,
         SCALAR,
-        ENUM
+        ENUM,
+        DEFER
     }
 
 

File: src/main/java/graphql/execution2/ResultNodesCreator.java
Patch:
@@ -24,15 +24,15 @@ public ExecutionResultNode createResultNode(FetchedValueAnalysis fetchedValueAna
             return new LeafExecutionResultNode(fetchedValueAnalysis, null);
         }
         if (fetchedValueAnalysis.getValueType() == FetchedValueAnalysis.FetchedValueType.OBJECT) {
-            return createObjectResultNode(fetchedValueAnalysis);
+            return createUnresolvedNode(fetchedValueAnalysis);
         }
         if (fetchedValueAnalysis.getValueType() == FetchedValueAnalysis.FetchedValueType.LIST) {
             return createListResultNode(fetchedValueAnalysis);
         }
         return new LeafExecutionResultNode(fetchedValueAnalysis, null);
     }
 
-    private ExecutionResultNode createObjectResultNode(FetchedValueAnalysis fetchedValueAnalysis) {
+    private ExecutionResultNode createUnresolvedNode(FetchedValueAnalysis fetchedValueAnalysis) {
         return new ObjectExecutionResultNode.UnresolvedObjectResultNode(fetchedValueAnalysis);
     }
 

File: src/main/java/graphql/tuples/Tuple2.java
Patch:
@@ -139,7 +139,7 @@ public Object[] toArray() {
      *
      * @return An unmodifiable {@link Iterator} over the elements in this Tuple.
      *
-     * @implNote As an {@link Iterator} is always tied to its {@link Iterable} source by
+     * implNote: As an {@link Iterator} is always tied to its {@link Iterable} source by
      * definition, the iterator cannot be mutable without the iterable also being mutable.
      * Since {@link Tuples} are <strong>immutable</strong>, so is the {@link Iterator}
      * returned by this method.

File: src/main/java/graphql/GraphQLContext.java
Patch:
@@ -13,16 +13,17 @@
  * This context object can be used to contain key values that can be useful as "context" when executing
  * {@link graphql.schema.DataFetcher}s
  *
- * {@code
  * <pre>
+ * {@code
  *     DataFetcher df = new DataFetcher() {
  *        public Object get(DataFetchingEnvironment env) {
  *            GraphQLContext ctx = env.getContext()
  *            User currentUser = ctx.getOrDefault("userKey",new AnonymousUser())
  *            ...
  *        }
- * </pre>
+ *     }
  * }
+ * </pre>
  *
  * You can set this up via {@link ExecutionInput.Builder#context(graphql.GraphQLContext.Builder)}
  */

File: src/main/java/graphql/schema/GraphQLArgument.java
Patch:
@@ -17,6 +17,7 @@
 
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
+import static graphql.schema.GraphqlTypeComparators.sortGraphQLTypes;
 import static graphql.util.FpKit.valuesToList;
 
 /**
@@ -97,7 +98,7 @@ private GraphQLArgument(String name, String description, GraphQLInputType type,
         this.defaultValue = defaultValue;
         this.value = value;
         this.definition = definition;
-        this.directives = directives;
+        this.directives = sortGraphQLTypes(directives);
     }
 
 

File: src/main/java/graphql/schema/GraphQLDirective.java
Patch:
@@ -18,6 +18,7 @@
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
 import static graphql.introspection.Introspection.DirectiveLocation;
+import static graphql.schema.GraphqlTypeComparators.sortGraphQLTypes;
 import static graphql.util.FpKit.getByName;
 import static graphql.util.FpKit.valuesToList;
 
@@ -45,7 +46,7 @@ public GraphQLDirective(String name, String description, EnumSet<DirectiveLocati
         this.name = name;
         this.description = description;
         this.locations = locations;
-        this.arguments.addAll(arguments);
+        this.arguments.addAll(sortGraphQLTypes(arguments));
         this.onOperation = onOperation;
         this.onFragment = onFragment;
         this.onField = onField;

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -17,6 +17,7 @@
 
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
+import static graphql.schema.GraphqlTypeComparators.sortGraphQLTypes;
 import static graphql.util.FpKit.getByName;
 import static graphql.util.FpKit.valuesToList;
 import static java.util.Collections.emptyList;
@@ -106,8 +107,8 @@ public GraphQLEnumType(String name, String description, List<GraphQLEnumValueDef
         this.name = name;
         this.description = description;
         this.definition = definition;
-        this.directives = directives;
-        buildMap(values);
+        this.directives = GraphqlTypeComparators.sortGraphQLTypes(directives);
+        buildMap(sortGraphQLTypes(values));
     }
 
     public List<GraphQLEnumValueDefinition> getValues() {

File: src/main/java/graphql/schema/GraphQLEnumValueDefinition.java
Patch:
@@ -15,6 +15,7 @@
 
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
+import static graphql.schema.GraphqlTypeComparators.sortGraphQLTypes;
 import static graphql.util.FpKit.getByName;
 import static graphql.util.FpKit.valuesToList;
 import static java.util.Collections.emptyList;
@@ -81,7 +82,7 @@ public GraphQLEnumValueDefinition(String name, String description, Object value,
         this.description = description;
         this.value = value;
         this.deprecationReason = deprecationReason;
-        this.directives = directives;
+        this.directives = sortGraphQLTypes(directives);
     }
 
     @Override

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -18,6 +18,7 @@
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
 import static graphql.schema.DataFetcherFactoryEnvironment.newDataFetchingFactoryEnvironment;
+import static graphql.schema.GraphqlTypeComparators.sortGraphQLTypes;
 import static graphql.util.FpKit.getByName;
 import static graphql.util.FpKit.valuesToList;
 
@@ -75,7 +76,6 @@ public GraphQLFieldDefinition(String name, String description, GraphQLOutputType
     @Internal
     @Deprecated
     public GraphQLFieldDefinition(String name, String description, GraphQLOutputType type, DataFetcherFactory dataFetcherFactory, List<GraphQLArgument> arguments, String deprecationReason, List<GraphQLDirective> directives, FieldDefinition definition) {
-        this.directives = directives;
         assertValidName(name);
         assertNotNull(dataFetcherFactory, "you have to provide a DataFetcher (or DataFetcherFactory)");
         assertNotNull(type, "type can't be null");
@@ -84,7 +84,8 @@ public GraphQLFieldDefinition(String name, String description, GraphQLOutputType
         this.description = description;
         this.type = type;
         this.dataFetcherFactory = dataFetcherFactory;
-        this.arguments = Collections.unmodifiableList(new ArrayList<>(arguments));
+        this.arguments = Collections.unmodifiableList(sortGraphQLTypes(arguments));
+        this.directives = sortGraphQLTypes(directives);
         this.deprecationReason = deprecationReason;
         this.definition = definition;
     }

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -15,6 +15,7 @@
 
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
+import static graphql.schema.GraphqlTypeComparators.sortGraphQLTypes;
 import static graphql.util.FpKit.getByName;
 import static graphql.util.FpKit.valuesToList;
 import static java.util.Collections.emptyList;
@@ -84,7 +85,7 @@ public GraphQLInputObjectField(String name, String description, GraphQLInputType
         this.type = type;
         this.defaultValue = defaultValue;
         this.description = description;
-        this.directives = directives;
+        this.directives = sortGraphQLTypes(directives);
         this.definition = definition;
     }
 

File: src/main/java/graphql/schema/GraphQLInputObjectType.java
Patch:
@@ -16,6 +16,7 @@
 
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
+import static graphql.schema.GraphqlTypeComparators.sortGraphQLTypes;
 import static graphql.util.FpKit.getByName;
 import static graphql.util.FpKit.valuesToList;
 import static java.util.Collections.emptyList;
@@ -67,8 +68,8 @@ public GraphQLInputObjectType(String name, String description, List<GraphQLInput
         this.name = name;
         this.description = description;
         this.definition = definition;
-        this.directives = directives;
-        buildMap(fields);
+        this.directives = sortGraphQLTypes(directives);
+        buildMap(sortGraphQLTypes(fields));
     }
 
     private void buildMap(List<GraphQLInputObjectField> fields) {

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -17,6 +17,7 @@
 
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
+import static graphql.schema.GraphqlTypeComparators.sortGraphQLTypes;
 import static graphql.util.FpKit.getByName;
 import static graphql.util.FpKit.valuesToList;
 import static java.lang.String.format;
@@ -75,10 +76,10 @@ public GraphQLInterfaceType(String name, String description, List<GraphQLFieldDe
 
         this.name = name;
         this.description = description;
-        buildDefinitionMap(fieldDefinitions);
+        buildDefinitionMap(sortGraphQLTypes(fieldDefinitions));
         this.typeResolver = typeResolver;
         this.definition = definition;
-        this.directives = directives;
+        this.directives = sortGraphQLTypes(directives);
     }
 
     private void buildDefinitionMap(List<GraphQLFieldDefinition> fieldDefinitions) {

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -16,6 +16,7 @@
 
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
+import static graphql.schema.GraphqlTypeComparators.sortGraphQLTypes;
 import static graphql.util.FpKit.getByName;
 import static graphql.util.FpKit.valuesToList;
 import static java.lang.String.format;
@@ -75,10 +76,10 @@ public GraphQLObjectType(String name, String description, List<GraphQLFieldDefin
         assertNotNull(interfaces, "interfaces can't be null");
         this.name = name;
         this.description = description;
-        this.interfaces = interfaces;
+        this.interfaces = sortGraphQLTypes(interfaces);
         this.definition = definition;
         this.directives = assertNotNull(directives);
-        buildDefinitionMap(fieldDefinitions);
+        buildDefinitionMap(sortGraphQLTypes(fieldDefinitions));
     }
 
     void replaceInterfaces(List<GraphQLOutputType> interfaces) {

File: src/main/java/graphql/schema/GraphQLScalarType.java
Patch:
@@ -15,6 +15,7 @@
 
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
+import static graphql.schema.GraphqlTypeComparators.sortGraphQLTypes;
 import static graphql.util.FpKit.getByName;
 import static graphql.util.FpKit.valuesToList;
 import static java.util.Collections.emptyList;
@@ -75,7 +76,7 @@ public GraphQLScalarType(String name, String description, Coercing coercing, Lis
         this.description = description;
         this.coercing = coercing;
         this.definition = definition;
-        this.directives = directives;
+        this.directives = sortGraphQLTypes(directives);
     }
 
     @Override

File: src/main/java/graphql/schema/GraphQLUnionType.java
Patch:
@@ -16,6 +16,7 @@
 import static graphql.Assert.assertNotEmpty;
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
+import static graphql.schema.GraphqlTypeComparators.sortGraphQLTypes;
 import static graphql.util.FpKit.getByName;
 import static graphql.util.FpKit.valuesToList;
 import static java.util.Collections.emptyList;
@@ -76,10 +77,10 @@ public GraphQLUnionType(String name, String description, List<GraphQLOutputType>
 
         this.name = name;
         this.description = description;
-        this.types = types;
+        this.types = sortGraphQLTypes(types);
         this.typeResolver = typeResolver;
         this.definition = definition;
-        this.directives = directives;
+        this.directives = sortGraphQLTypes(directives);
     }
 
     void replaceTypes(List<GraphQLOutputType> types) {

File: src/main/java/graphql/language/TypeName.java
Patch:
@@ -11,7 +11,7 @@
 import java.util.function.Consumer;
 
 @PublicApi
-public class TypeName extends AbstractNode<TypeName> implements Type<TypeName> {
+public class TypeName extends AbstractNode<TypeName> implements Type<TypeName>, NamedNode<TypeName> {
 
     private final String name;
 

File: src/main/java/graphql/execution/instrumentation/tracing/TracingSupport.java
Patch:
@@ -32,6 +32,8 @@ public class TracingSupport implements InstrumentationState {
 
     /**
      * The timer starts as soon as you create this object
+     *
+     * @param includeTrivialDataFetchers whether the trace trivial data fetchers
      */
     public TracingSupport(boolean includeTrivialDataFetchers) {
         this.includeTrivialDataFetchers = includeTrivialDataFetchers;
@@ -55,6 +57,7 @@ public interface TracingContext {
      * end the call.
      *
      * @param dataFetchingEnvironment the data fetching that is occurring
+     * @param trivialDataFetcher      if the data fetcher is considered trivial
      *
      * @return a context to call end on
      */

File: src/main/java/graphql/analysis/MaxQueryComplexityInstrumentation.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * Prevents execution if the query complexity is greater than the specified maxComplexity.
  *
- * Use the {@link Function<QueryComplexityInfo, Boolean>} parameter to supply a function to perform a custom action when the max complexity
+ * Use the {@code Function<QueryComplexityInfo, Boolean>} parameter to supply a function to perform a custom action when the max complexity
  * is exceeded. If the function returns {@code true} a {@link AbortExecutionException} is thrown.
  */
 @PublicApi

File: src/main/java/graphql/analysis/MaxQueryDepthInstrumentation.java
Patch:
@@ -17,7 +17,7 @@
 /**
  * Prevents execution if the query depth is greater than the specified maxDepth.
  *
- * Use the {@link Function<QueryDepthInfo, Boolean>} parameter to supply a function to perform a custom action when the max depth is
+ * Use the {@code Function<QueryDepthInfo, Boolean>} parameter to supply a function to perform a custom action when the max depth is
  * exceeded. If the function returns {@code true} a {@link AbortExecutionException} is thrown.
  */
 @PublicApi

File: src/main/java/graphql/execution/ExecutionStepInfo.java
Patch:
@@ -156,10 +156,10 @@ public ExecutionStepInfo changeTypeWithPreservedNonNull(GraphQLType newType) {
 
 
     /**
-     * @return the type in graphql AST format, eg [typeName!]!
+     * @return the type in graphql SDL format, eg [typeName!]!
      */
-    public String toAst() {
-        return GraphQLTypeUtil.getUnwrappedTypeName(type);
+    public String simplePrint() {
+        return GraphQLTypeUtil.simplePrint(type);
     }
 
     @Override

File: src/main/java/graphql/execution/InputMapDefinesTooManyFieldsException.java
Patch:
@@ -19,7 +19,7 @@
 public class InputMapDefinesTooManyFieldsException extends GraphQLException implements GraphQLError {
 
     public InputMapDefinesTooManyFieldsException(GraphQLType graphQLType, String fieldName) {
-        super(String.format("The variables input contains a field name '%s' that is not defined for input object type '%s' ", fieldName, GraphQLTypeUtil.getUnwrappedTypeName(graphQLType)));
+        super(String.format("The variables input contains a field name '%s' that is not defined for input object type '%s' ", fieldName, GraphQLTypeUtil.simplePrint(graphQLType)));
     }
 
     @Override

File: src/main/java/graphql/execution/NonNullableValueCoercedAsNullException.java
Patch:
@@ -24,19 +24,19 @@ public class NonNullableValueCoercedAsNullException extends GraphQLException imp
 
     public NonNullableValueCoercedAsNullException(VariableDefinition variableDefinition, GraphQLType graphQLType) {
         super(format("Variable '%s' has coerced Null value for NonNull type '%s'",
-                variableDefinition.getName(), GraphQLTypeUtil.getUnwrappedTypeName(graphQLType)));
+                variableDefinition.getName(), GraphQLTypeUtil.simplePrint(graphQLType)));
         this.sourceLocations = Collections.singletonList(variableDefinition.getSourceLocation());
     }
 
     public NonNullableValueCoercedAsNullException(VariableDefinition variableDefinition, String fieldName, GraphQLType graphQLType) {
         super(format("Field '%s' of variable '%s' has coerced Null value for NonNull type '%s'",
-                fieldName, variableDefinition.getName(), GraphQLTypeUtil.getUnwrappedTypeName(graphQLType)));
+                fieldName, variableDefinition.getName(), GraphQLTypeUtil.simplePrint(graphQLType)));
         this.sourceLocations = Collections.singletonList(variableDefinition.getSourceLocation());
     }
 
     public NonNullableValueCoercedAsNullException(GraphQLInputObjectField inputTypeField) {
         super(format("Input field '%s' has coerced Null value for NonNull type '%s'",
-                inputTypeField.getName(), GraphQLTypeUtil.getUnwrappedTypeName(inputTypeField.getType())));
+                inputTypeField.getName(), GraphQLTypeUtil.simplePrint(inputTypeField.getType())));
     }
 
     @Override

File: src/main/java/graphql/execution/instrumentation/tracing/TracingSupport.java
Patch:
@@ -67,7 +67,7 @@ public TracingContext beginField(DataFetchingEnvironment dataFetchingEnvironment
             Map<String, Object> fetchMap = new LinkedHashMap<>();
             fetchMap.put("path", executionStepInfo.getPath().toList());
             fetchMap.put("parentType", executionStepInfo.getParent().getUnwrappedNonNullType().getName());
-            fetchMap.put("returnType", executionStepInfo.toAst());
+            fetchMap.put("returnType", executionStepInfo.simplePrint());
             fetchMap.put("fieldName", executionStepInfo.getFieldDefinition().getName());
             fetchMap.put("startOffset", startOffset);
             fetchMap.put("duration", duration);

File: src/main/java/graphql/schema/GraphQLList.java
Patch:
@@ -7,7 +7,6 @@
 
 import java.util.Collections;
 import java.util.List;
-import java.util.Map;
 
 import static graphql.Assert.assertNotNull;
 
@@ -82,7 +81,7 @@ public List<GraphQLType> getChildren() {
 
     @Override
     public String toString() {
-        return GraphQLTypeUtil.getUnwrappedTypeName(this);
+        return GraphQLTypeUtil.simplePrint(this);
     }
 
 }

File: src/main/java/graphql/schema/GraphQLNonNull.java
Patch:
@@ -43,7 +43,7 @@ public GraphQLNonNull(GraphQLType wrappedType) {
 
     private void assertNonNullWrapping(GraphQLType wrappedType) {
         assertTrue(!GraphQLTypeUtil.isNonNull(wrappedType), String.format("A non null type cannot wrap an existing non null type '%s'",
-                GraphQLTypeUtil.getUnwrappedTypeName(wrappedType)));
+                GraphQLTypeUtil.simplePrint(wrappedType)));
     }
 
     @Override
@@ -75,7 +75,7 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return GraphQLTypeUtil.getUnwrappedTypeName(this);
+        return GraphQLTypeUtil.simplePrint(this);
     }
 
     @Override

File: src/main/java/graphql/schema/idl/SchemaPrinter.java
Patch:
@@ -400,7 +400,7 @@ private TypePrinter<GraphQLSchema> schemaPrinter() {
     }
 
     String typeString(GraphQLType rawType) {
-        return GraphQLTypeUtil.getUnwrappedTypeName(rawType);
+        return GraphQLTypeUtil.simplePrint(rawType);
     }
 
     String argsString(List<GraphQLArgument> arguments) {

File: src/main/java/graphql/validation/rules/VariableTypesMatchRule.java
Patch:
@@ -60,8 +60,8 @@ public void checkVariable(VariableReference variableReference) {
         if (!variablesTypesMatcher.doesVariableTypesMatch(variableType, variableDefinition.getDefaultValue(), expectedType)) {
             GraphQLType effectiveType = variablesTypesMatcher.effectiveType(variableType, variableDefinition.getDefaultValue());
             String message = String.format("Variable type '%s' doesn't match expected type '%s'",
-                    GraphQLTypeUtil.getUnwrappedTypeName(effectiveType),
-                    GraphQLTypeUtil.getUnwrappedTypeName(expectedType));
+                    GraphQLTypeUtil.simplePrint(effectiveType),
+                    GraphQLTypeUtil.simplePrint(expectedType));
             addError(ValidationErrorType.VariableTypeMismatch, variableReference.getSourceLocation(), message);
         }
     }

File: src/main/java/graphql/UnresolvedTypeError.java
Patch:
@@ -28,7 +28,7 @@ private String mkMessage(ExecutionPath path, UnresolvedTypeException exception,
         return format("Can't resolve '%s'. Abstract type '%s' must resolve to an Object type at runtime for field '%s.%s'. %s",
                 path,
                 exception.getInterfaceOrUnionType().getName(),
-                info.getParent().getUnwrapNonNullType().getName(),
+                info.getParent().getUnwrappedNonNullType().getName(),
                 info.getFieldDefinition().getName(),
                 exception.getMessage());
     }

File: src/main/java/graphql/execution/ExecutionStepInfo.java
Patch:
@@ -57,7 +57,7 @@ public GraphQLType getType() {
      *
      * @return the graphql type in question
      */
-    public GraphQLType getUnwrapNonNullType() {
+    public GraphQLType getUnwrappedNonNullType() {
         return GraphQLTypeUtil.unwrapNonNull(this.type);
     }
 

File: src/main/java/graphql/execution/NonNullableFieldWasNullException.java
Patch:
@@ -38,9 +38,9 @@ public NonNullableFieldWasNullException(NonNullableFieldWasNullException previou
 
 
     private static String mkMessage(ExecutionStepInfo executionStepInfo, ExecutionPath path) {
-        GraphQLType unwrappedTyped = executionStepInfo.getUnwrapNonNullType();
+        GraphQLType unwrappedTyped = executionStepInfo.getUnwrappedNonNullType();
         if (executionStepInfo.hasParent()) {
-            GraphQLType unwrappedParentType = executionStepInfo.getParent().getUnwrapNonNullType();
+            GraphQLType unwrappedParentType = executionStepInfo.getParent().getUnwrappedNonNullType();
             return String.format("Cannot return null for non-nullable type: '%s' within parent '%s' (%s)", unwrappedTyped.getName(), unwrappedParentType.getName(), path);
         }
         return String.format("Cannot return null for non-nullable type: '%s' (%s)", unwrappedTyped.getName(), path);

File: src/main/java/graphql/execution/instrumentation/tracing/TracingSupport.java
Patch:
@@ -66,7 +66,7 @@ public TracingContext beginField(DataFetchingEnvironment dataFetchingEnvironment
 
             Map<String, Object> fetchMap = new LinkedHashMap<>();
             fetchMap.put("path", executionStepInfo.getPath().toList());
-            fetchMap.put("parentType", executionStepInfo.getParent().getUnwrapNonNullType().getName());
+            fetchMap.put("parentType", executionStepInfo.getParent().getUnwrappedNonNullType().getName());
             fetchMap.put("returnType", executionStepInfo.toAst());
             fetchMap.put("fieldName", executionStepInfo.getFieldDefinition().getName());
             fetchMap.put("startOffset", startOffset);

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -837,14 +837,14 @@ protected GraphQLFieldDefinition getFieldDef(GraphQLSchema schema, GraphQLObject
      */
     protected void assertNonNullFieldPrecondition(NonNullableFieldWasNullException e) throws NonNullableFieldWasNullException {
         ExecutionInfo executionInfo = e.getExecutionInfo();
-        if (executionInfo.hasParentType() && executionInfo.getParent().isNonNullType()) {
+        if (executionInfo.hasParent() && executionInfo.getParent().isNonNullType()) {
             throw new NonNullableFieldWasNullException(e);
         }
     }
 
     protected void assertNonNullFieldPrecondition(NonNullableFieldWasNullException e, CompletableFuture<?> completableFuture) throws NonNullableFieldWasNullException {
         ExecutionInfo executionInfo = e.getExecutionInfo();
-        if (executionInfo.hasParentType() && executionInfo.getParent().isNonNullType()) {
+        if (executionInfo.hasParent() && executionInfo.getParent().isNonNullType()) {
             completableFuture.completeExceptionally(new NonNullableFieldWasNullException(e));
         }
     }

File: src/main/java/graphql/execution/NonNullableFieldWasNullException.java
Patch:
@@ -36,7 +36,7 @@ public NonNullableFieldWasNullException(NonNullableFieldWasNullException previou
 
 
     private static String mkMessage(ExecutionInfo executionInfo, ExecutionPath path) {
-        if (executionInfo.hasParentType()) {
+        if (executionInfo.hasParent()) {
             return String.format("Cannot return null for non-nullable type: '%s' within parent '%s' (%s)", executionInfo.getType().getName(), executionInfo.getParent().getType().getName(), path);
         }
         return String.format("Cannot return null for non-nullable type: '%s' (%s)", executionInfo.getType().getName(), path);

File: src/main/java/graphql/language/Argument.java
Patch:
@@ -26,8 +26,8 @@ protected Argument(String name, Value value, SourceLocation sourceLocation, List
     /**
      * alternative to using a Builder for convenience
      *
-     * @param name
-     * @param value
+     * @param name of the argument
+     * @param value of the argument
      */
     public Argument(String name, Value value) {
         this(name, value, null, new ArrayList<>());

File: src/main/java/graphql/language/ArrayValue.java
Patch:
@@ -24,7 +24,7 @@ protected ArrayValue(List<Value> values, SourceLocation sourceLocation, List<Com
     /**
      * alternative to using a Builder for convenience
      *
-     * @param values
+     * @param values of the array
      */
     public ArrayValue(List<Value> values) {
         super(null, new ArrayList<>());

File: src/main/java/graphql/language/BooleanValue.java
Patch:
@@ -24,7 +24,7 @@ protected BooleanValue(boolean value, SourceLocation sourceLocation, List<Commen
     /**
      * alternative to using a Builder for convenience
      *
-     * @param value
+     * @param value of the Boolean
      */
     public BooleanValue(boolean value) {
         super(null, new ArrayList<>());

File: src/main/java/graphql/language/DirectiveLocation.java
Patch:
@@ -30,6 +30,8 @@ protected DirectiveLocation(String name, SourceLocation sourceLocation, List<Com
 
     /**
      * alternative to using a Builder for convenience
+     *
+     * @param name of the directive location
      */
     public DirectiveLocation(String name) {
         this(name, null, new ArrayList<>());

File: src/main/java/graphql/language/Document.java
Patch:
@@ -23,6 +23,8 @@ protected Document(List<Definition> definitions, SourceLocation sourceLocation,
 
     /**
      * alternative to using a Builder for convenience
+     *
+     * @param definitions the definitions that make up this document
      */
     public Document(List<Definition> definitions) {
         this(definitions, null, new ArrayList<>());

File: src/main/java/graphql/language/EnumValue.java
Patch:
@@ -25,7 +25,7 @@ protected EnumValue(String name, SourceLocation sourceLocation, List<Comment> co
     /**
      * alternative to using a Builder for convenience
      *
-     * @param name
+     * @param name of the enum value
      */
     public EnumValue(String name) {
         super(null, new ArrayList<>());

File: src/main/java/graphql/language/FloatValue.java
Patch:
@@ -24,6 +24,8 @@ protected FloatValue(BigDecimal value, SourceLocation sourceLocation, List<Comme
 
     /**
      * alternative to using a Builder for convenience
+     *
+     * @param value of the Float
      */
     public FloatValue(BigDecimal value) {
         this(value, null, new ArrayList<>());

File: src/main/java/graphql/language/FragmentSpread.java
Patch:
@@ -25,6 +25,8 @@ protected FragmentSpread(String name, List<Directive> directives, SourceLocation
 
     /**
      * alternative to using a Builder for convenience
+     *
+     * @param name of the fragment
      */
     public FragmentSpread(String name) {
         this(name, new ArrayList<>(), null, new ArrayList<>());

File: src/main/java/graphql/language/IntValue.java
Patch:
@@ -25,7 +25,7 @@ protected IntValue(BigInteger value, SourceLocation sourceLocation, List<Comment
     /**
      * alternative to using a Builder for convenience
      *
-     * @param value
+     * @param value of the Int
      */
     public IntValue(BigInteger value) {
         super(null, new ArrayList<>());

File: src/main/java/graphql/language/ListType.java
Patch:
@@ -23,6 +23,8 @@ protected ListType(Type type, SourceLocation sourceLocation, List<Comment> comme
 
     /**
      * alternative to using a Builder for convenience
+     *
+     * @param type the wrapped type
      */
     public ListType(Type type) {
         super(null, new ArrayList<>());

File: src/main/java/graphql/language/NonNullType.java
Patch:
@@ -25,7 +25,7 @@ protected NonNullType(Type type, SourceLocation sourceLocation, List<Comment> co
     /**
      * alternative to using a Builder for convenience
      *
-     * @param type
+     * @param type the wrapped type
      */
     public NonNullType(Type type) {
         super(null, new ArrayList<>());

File: src/main/java/graphql/language/ObjectField.java
Patch:
@@ -25,6 +25,9 @@ protected ObjectField(String name, Value value, SourceLocation sourceLocation, L
 
     /**
      * alternative to using a Builder for convenience
+     *
+     * @param name  of the field
+     * @param value of the field
      */
     public ObjectField(String name, Value value) {
         this(name, value, null, new ArrayList<>());

File: src/main/java/graphql/language/ObjectValue.java
Patch:
@@ -23,6 +23,8 @@ protected ObjectValue(List<ObjectField> objectFields, SourceLocation sourceLocat
 
     /**
      * alternative to using a Builder for convenience
+     *
+     * @param objectFields the list of field that make up this object value
      */
     public ObjectValue(List<ObjectField> objectFields) {
         this(objectFields, null, new ArrayList<>());

File: src/main/java/graphql/language/OperationTypeDefinition.java
Patch:
@@ -25,6 +25,9 @@ protected OperationTypeDefinition(String name, Type type, SourceLocation sourceL
 
     /**
      * alternative to using a Builder for convenience
+     *
+     * @param name of the operation
+     * @param type the type in play
      */
     public OperationTypeDefinition(String name, Type type) {
         this(name, type, null, new ArrayList<>());

File: src/main/java/graphql/language/SDLDefinition.java
Patch:
@@ -6,7 +6,7 @@
 /**
  * All Schema Definition Language (SDL) Definitions.
  *
- * @param <T>
+ * @param <T> for two
  */
 @PublicApi
 public interface SDLDefinition<T extends SDLDefinition> extends Definition<T> {

File: src/main/java/graphql/language/ScalarTypeDefinition.java
Patch:
@@ -27,6 +27,8 @@ protected ScalarTypeDefinition(String name, List<Directive> directives, Descript
 
     /**
      * alternative to using a Builder for convenience
+     *
+     * @param name of the scalar
      */
     public ScalarTypeDefinition(String name) {
         this(name, new ArrayList<>(), null, null, new ArrayList<>());

File: src/main/java/graphql/language/SelectionSet.java
Patch:
@@ -23,6 +23,8 @@ protected SelectionSet(List<Selection> selections, SourceLocation sourceLocation
 
     /**
      * alternative to using a Builder for convenience
+     *
+     * @param selections the list of selection in this selection set
      */
     public SelectionSet(List<Selection> selections) {
         this(selections, null, new ArrayList<>());

File: src/main/java/graphql/language/StringValue.java
Patch:
@@ -24,7 +24,7 @@ protected StringValue(String value, SourceLocation sourceLocation, List<Comment>
     /**
      * alternative to using a Builder for convenience
      *
-     * @param value
+     * @param value of the String
      */
     public StringValue(String value) {
         super(null, new ArrayList<>());

File: src/main/java/graphql/language/TypeName.java
Patch:
@@ -24,7 +24,7 @@ protected TypeName(String name, SourceLocation sourceLocation, List<Comment> com
     /**
      * alternative to using a Builder for convenience
      *
-     * @param name
+     * @param name of the type
      */
     public TypeName(String name) {
         super(null, new ArrayList<>());

File: src/main/java/graphql/language/VariableReference.java
Patch:
@@ -23,6 +23,8 @@ protected VariableReference(String name, SourceLocation sourceLocation, List<Com
 
     /**
      * alternative to using a Builder for convenience
+     *
+     * @param name of the variable
      */
     public VariableReference(String name) {
         super(null, new ArrayList<>());

File: src/main/java/graphql/execution/AsyncExecutionStrategy.java
Patch:
@@ -126,7 +126,7 @@ private Supplier<CompletableFuture<ExecutionResult>> deferredExecutionResult(Exe
 
             Instrumentation instrumentation = executionContext.getInstrumentation();
             DeferredFieldInstrumentationContext fieldCtx = instrumentation.beginDeferredField(
-                    new InstrumentationDeferredFieldParameters(executionContext, parameters, fieldDef, fieldTypeInfo(parameters, fieldDef))
+                    new InstrumentationDeferredFieldParameters(executionContext, parameters, fieldDef, executionInfo(executionContext, parameters, fieldDef))
             );
             CompletableFuture<ExecutionResult> result = new CompletableFuture<>();
             fieldCtx.onDispatched(result);

File: src/main/java/graphql/execution/instrumentation/dataloader/FieldLevelTrackingApproach.java
Patch:
@@ -236,7 +236,7 @@ public void onFieldValueInfo(FieldValueInfo fieldValueInfo) {
 
     public InstrumentationContext<Object> beginFieldFetch(InstrumentationFieldFetchParameters parameters) {
         CallStack callStack = parameters.getInstrumentationState();
-        ExecutionPath path = parameters.getEnvironment().getFieldTypeInfo().getPath();
+        ExecutionPath path = parameters.getEnvironment().getExecutionInfo().getPath();
         int level = path.getLevel();
         return new InstrumentationContext<Object>() {
 

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationFieldFetchParameters.java
Patch:
@@ -15,13 +15,13 @@ public class InstrumentationFieldFetchParameters extends InstrumentationFieldPar
     private final ExecutionStrategyParameters executionStrategyParameters;
 
     public InstrumentationFieldFetchParameters(ExecutionContext getExecutionContext, GraphQLFieldDefinition fieldDef, DataFetchingEnvironment environment, ExecutionStrategyParameters executionStrategyParameters) {
-        super(getExecutionContext, fieldDef, environment.getFieldTypeInfo());
+        super(getExecutionContext, fieldDef, environment.getExecutionInfo());
         this.environment = environment;
         this.executionStrategyParameters = executionStrategyParameters;
     }
 
     private InstrumentationFieldFetchParameters(ExecutionContext getExecutionContext, GraphQLFieldDefinition fieldDef, DataFetchingEnvironment environment, InstrumentationState instrumentationState, ExecutionStrategyParameters executionStrategyParameters) {
-        super(getExecutionContext, fieldDef, environment.getFieldTypeInfo(), instrumentationState);
+        super(getExecutionContext, fieldDef, environment.getExecutionInfo(), instrumentationState);
         this.environment = environment;
         this.executionStrategyParameters = executionStrategyParameters;
     }

File: src/main/java/graphql/schema/DataFetchingEnvironment.java
Patch:
@@ -3,7 +3,7 @@
 import graphql.PublicApi;
 import graphql.execution.ExecutionContext;
 import graphql.execution.ExecutionId;
-import graphql.execution.ExecutionTypeInfo;
+import graphql.execution.ExecutionInfo;
 import graphql.language.Field;
 import graphql.language.FragmentDefinition;
 import org.dataloader.DataLoader;
@@ -123,9 +123,9 @@ public interface DataFetchingEnvironment {
 
 
     /**
-     * @return the field {@link ExecutionTypeInfo} for the current data fetch operation
+     * @return the field {@link graphql.execution.ExecutionInfo} for the current data fetch operation
      */
-    ExecutionTypeInfo getFieldTypeInfo();
+    ExecutionInfo getExecutionInfo();
 
     /**
      * @return the type of the parent of the current field

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -90,6 +90,7 @@ public CompletableFuture<ExecutionResult> execute(Document document, GraphQLSche
                 .variables(coercedVariables)
                 .document(document)
                 .operationDefinition(operationDefinition)
+                .dataLoaderRegistry(executionInput.getDataLoaderRegistry())
                 .build();
 
 

File: src/main/java/graphql/execution/instrumentation/InstrumentationState.java
Patch:
@@ -4,7 +4,7 @@
  * An {@link Instrumentation} implementation can create this as a stateful object that is then passed
  * to each instrumentation method, allowing state to be passed down with the request execution
  *
- * @see Instrumentation#createState()
+ * @see Instrumentation#createState(graphql.execution.instrumentation.parameters.InstrumentationCreateStateParameters)
  */
 public interface InstrumentationState {
 }

File: src/test/groovy/graphql/execution/instrumentation/dataloader/BatchCompare.java
Patch:
@@ -48,10 +48,11 @@ void dataLoaderRun() {
         dataLoaderRegistry.register("products", BatchCompareDataFetchers.productsForDepartmentDataLoader);
         GraphQL graphQL = GraphQL
                 .newGraphQL(schema)
-                .instrumentation(new DataLoaderDispatcherInstrumentation(dataLoaderRegistry))
+                .instrumentation(new DataLoaderDispatcherInstrumentation())
                 .build();
         ExecutionInput executionInput = ExecutionInput.newExecutionInput()
                 .query("query { shops { id name departments { id name products { id name } } } }")
+                .dataLoaderRegistry(dataLoaderRegistry)
                 .build();
         ExecutionResult result = graphQL.execute(executionInput);
         System.out.println("\nExecutionResult: " + result.toSpecification());

File: src/main/java/graphql/schema/idl/SchemaPrinter.java
Patch:
@@ -478,9 +478,8 @@ private String directiveString(GraphQLDirective directive) {
                 if (arg.getValue() != null) {
                     sb.append(" : ");
                     sb.append(printAst(arg.getValue(), arg.getType()));
-                }
-                if (arg.getDefaultValue() != null) {
-                    sb.append(" = ");
+                } else if (arg.getDefaultValue() != null) {
+                    sb.append(" : ");
                     sb.append(printAst(arg.getDefaultValue(), arg.getType()));
                 }
                 if (i < args.size() - 1) {

File: src/main/java/graphql/execution/batched/BatchAssertionFailed.java
Patch:
@@ -3,6 +3,7 @@
 import graphql.GraphQLException;
 
 
+@Deprecated
 public class BatchAssertionFailed extends GraphQLException {
     public BatchAssertionFailed() {
         super();

File: src/main/java/graphql/execution/batched/Batched.java
Patch:
@@ -51,8 +51,11 @@
  * }
  * </code>
  * </pre>
+ *
+ * @deprecated This has been deprecated in favour of using {@link graphql.execution.AsyncExecutionStrategy} and {@link graphql.execution.instrumentation.dataloader.DataLoaderDispatcherInstrumentation}
  */
 @Target(ElementType.METHOD)
 @Retention(RetentionPolicy.RUNTIME)
+@Deprecated
 public @interface Batched {
 }

File: src/main/java/graphql/execution/batched/BatchedDataFetcher.java
Patch:
@@ -4,7 +4,9 @@
 
 /**
  * See {@link Batched}.
+ * @deprecated This has been deprecated in favour of using {@link graphql.execution.AsyncExecutionStrategy} and {@link graphql.execution.instrumentation.dataloader.DataLoaderDispatcherInstrumentation}
  */
+@Deprecated
 public interface BatchedDataFetcher extends DataFetcher {
     // Marker interface
 }

File: src/main/java/graphql/execution/batched/BatchedDataFetcherFactory.java
Patch:
@@ -12,8 +12,10 @@
  * Otherwise we wrap the fetcher in a BatchedDataFetcher that iterates over the sources and invokes the delegate
  * on each source. Note that this forgoes any performance benefits of batching,
  * so regular DataFetchers should normally only be used if they are in-memory.
+ *
+ * @deprecated This has been deprecated in favour of using {@link graphql.execution.AsyncExecutionStrategy} and {@link graphql.execution.instrumentation.dataloader.DataLoaderDispatcherInstrumentation}
  */
-
+@Deprecated
 public class BatchedDataFetcherFactory {
     public BatchedDataFetcher create(final DataFetcher supplied) {
         if (supplied instanceof BatchedDataFetcher) {

File: src/main/java/graphql/execution/batched/ExecutionNode.java
Patch:
@@ -7,6 +7,7 @@
 import java.util.List;
 import java.util.Map;
 
+@Deprecated
 class ExecutionNode {
 
     private final GraphQLObjectType type;

File: src/main/java/graphql/execution/batched/FetchedValue.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.execution.batched;
 
+@Deprecated
 public class FetchedValue {
 
     private final MapOrList mapOrList;

File: src/main/java/graphql/execution/batched/FetchedValues.java
Patch:
@@ -5,6 +5,7 @@
 
 import java.util.List;
 
+@Deprecated
 public class FetchedValues {
 
     private final List<FetchedValue> fetchedValues;

File: src/main/java/graphql/execution/batched/MapOrList.java
Patch:
@@ -8,6 +8,7 @@
 import java.util.Map;
 
 @Internal
+@Deprecated
 public class MapOrList {
 
 

File: src/main/java/graphql/execution/batched/UnbatchedDataFetcher.java
Patch:
@@ -15,7 +15,10 @@
  * Given a normal data fetcher as a delegate,
  * uses that fetcher in a batched context by iterating through each source value and calling
  * the delegate.
+ *
+ * @deprecated This has been deprecated in favour of using {@link graphql.execution.AsyncExecutionStrategy} and {@link graphql.execution.instrumentation.dataloader.DataLoaderDispatcherInstrumentation}
  */
+@Deprecated
 public class UnbatchedDataFetcher implements BatchedDataFetcher {
 
     private final DataFetcher delegate;

File: src/main/java/graphql/schema/idl/SchemaPrinter.java
Patch:
@@ -478,9 +478,8 @@ private String directiveString(GraphQLDirective directive) {
                 if (arg.getValue() != null) {
                     sb.append(" : ");
                     sb.append(printAst(arg.getValue(), arg.getType()));
-                }
-                if (arg.getDefaultValue() != null) {
-                    sb.append(" = ");
+                } else if (arg.getDefaultValue() != null) {
+                    sb.append(" : ");
                     sb.append(printAst(arg.getDefaultValue(), arg.getType()));
                 }
                 if (i < args.size() - 1) {

File: src/main/java/graphql/execution/AsyncExecutionStrategy.java
Patch:
@@ -58,7 +58,7 @@ public CompletableFuture<ExecutionResult> execute(ExecutionContext executionCont
         for (String fieldName : fieldNames) {
             List<Field> currentField = fields.get(fieldName);
 
-            ExecutionPath fieldPath = parameters.getPath().segment(fieldName);
+            ExecutionPath fieldPath = parameters.getPath().segment(mkNameForPath(currentField));
             ExecutionStrategyParameters newParameters = parameters
                     .transform(builder -> builder.field(currentField).path(fieldPath).parent(parameters));
 

File: src/main/java/graphql/execution/AsyncSerialExecutionStrategy.java
Patch:
@@ -37,7 +37,7 @@ public CompletableFuture<ExecutionResult> execute(ExecutionContext executionCont
 
         CompletableFuture<List<ExecutionResult>> resultsFuture = Async.eachSequentially(fieldNames, (fieldName, index, prevResults) -> {
             List<Field> currentField = fields.get(fieldName);
-            ExecutionPath fieldPath = parameters.getPath().segment(fieldName);
+            ExecutionPath fieldPath = parameters.getPath().segment(mkNameForPath(currentField));
             ExecutionStrategyParameters newParameters = parameters
                     .transform(builder -> builder.field(currentField).path(fieldPath));
             return resolveField(executionContext, newParameters);

File: src/main/java/graphql/execution/ExecutorServiceExecutionStrategy.java
Patch:
@@ -75,7 +75,7 @@ public CompletableFuture<ExecutionResult> execute(final ExecutionContext executi
         for (String fieldName : fields.keySet()) {
             final List<Field> currentField = fields.get(fieldName);
 
-            ExecutionPath fieldPath = parameters.getPath().segment(fieldName);
+            ExecutionPath fieldPath = parameters.getPath().segment(mkNameForPath(currentField));
             ExecutionStrategyParameters newParameters = parameters
                     .transform(builder -> builder.field(currentField).path(fieldPath));
 

File: src/main/java/graphql/execution/SubscriptionExecutionStrategy.java
Patch:
@@ -121,7 +121,7 @@ private ExecutionStrategyParameters firstFieldOfSubscriptionSelection(ExecutionS
 
         List<Field> firstField = fields.get(fieldNames.get(0));
 
-        ExecutionPath fieldPath = parameters.getPath().segment(firstField.get(0).getName());
+        ExecutionPath fieldPath = parameters.getPath().segment(mkNameForPath(firstField));
         return parameters.transform(builder -> builder.field(firstField).path(fieldPath));
     }
 

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -163,7 +163,7 @@ private void executeImpl(ExecutionContext executionContext,
                 .parentInfo(currentParentTypeInfo.getParentTypeInfo())
                 .build();
 
-        ExecutionPath fieldPath = curNode.getTypeInfo().getPath().segment(fieldName);
+        ExecutionPath fieldPath = curNode.getTypeInfo().getPath().segment(mkNameForPath(currentField));
         GraphQLFieldDefinition fieldDefinition = getFieldDef(executionContext.getGraphQLSchema(), curNode.getType(), currentField.get(0));
 
         ExecutionTypeInfo typeInfo = newTypeInfo()

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -153,7 +153,7 @@ public GraphQL(GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, Exe
     }
 
     private GraphQL(GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy, ExecutionStrategy subscriptionStrategy, ExecutionIdProvider idProvider, Instrumentation instrumentation, PreparsedDocumentProvider preparsedDocumentProvider) {
-        this.graphQLSchema = assertNotNull(graphQLSchema, "queryStrategy must be non null");
+        this.graphQLSchema = assertNotNull(graphQLSchema, "graphQLSchema must be non null");
         this.queryStrategy = queryStrategy != null ? queryStrategy : new AsyncExecutionStrategy();
         this.mutationStrategy = mutationStrategy != null ? mutationStrategy : new AsyncSerialExecutionStrategy();
         this.subscriptionStrategy = subscriptionStrategy != null ? subscriptionStrategy : new SubscriptionExecutionStrategy();
@@ -251,7 +251,7 @@ public Builder executionIdProvider(ExecutionIdProvider executionIdProvider) {
         }
 
         public GraphQL build() {
-            assertNotNull(graphQLSchema, "queryStrategy must be non null");
+            assertNotNull(graphQLSchema, "graphQLSchema must be non null");
             assertNotNull(queryExecutionStrategy, "queryStrategy must be non null");
             assertNotNull(idProvider, "idProvider must be non null");
             return new GraphQL(graphQLSchema, queryExecutionStrategy, mutationExecutionStrategy, subscriptionExecutionStrategy, idProvider, instrumentation, preparsedDocumentProvider);

File: src/main/java/graphql/schema/GraphQLTypeResolvingVisitor.java
Patch:
@@ -1,13 +1,14 @@
 package graphql.schema;
 
-import static graphql.Assert.assertNotNull;
 import graphql.Internal;
 import graphql.util.TraversalControl;
 import graphql.util.TraverserContext;
 
 import java.util.Map;
 import java.util.stream.Collectors;
 
+import static graphql.Assert.assertNotNull;
+
 @Internal
 public class GraphQLTypeResolvingVisitor extends GraphQLTypeVisitorStub {
     protected final Map<String, GraphQLType> typeMap;
@@ -38,7 +39,7 @@ public TraversalControl visitGraphQLUnionType(GraphQLUnionType node, TraverserCo
     public TraversalControl visitGraphQLTypeReference(GraphQLTypeReference node, TraverserContext<GraphQLType> context) {
 
         final GraphQLType resolvedType = typeMap.get(node.getName());
-        assertNotNull(resolvedType != null, "type %s not found in schema", node.getName());
+        assertNotNull(resolvedType, "type %s not found in schema", node.getName());
         context.getParentContext().thisNode().accept(context, new TypeRefResolvingVisitor(resolvedType));
         return super.visitGraphQLTypeReference(node, context);
     }

File: src/main/java/graphql/schema/GraphQLTypeVisitor.java
Patch:
@@ -1,10 +1,10 @@
 package graphql.schema;
 
-import graphql.Internal;
+import graphql.PublicApi;
 import graphql.util.TraversalControl;
 import graphql.util.TraverserContext;
 
-@Internal
+@PublicApi
 public interface GraphQLTypeVisitor {
     TraversalControl visitGraphQLArgument(GraphQLArgument node, TraverserContext<GraphQLType> context);
 

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -151,7 +151,7 @@ private Object coerceValue(GraphqlFieldVisibility fieldVisibility, VariableDefin
                 Object returnValue =
                         coerceValue(fieldVisibility, variableDefinition, inputName, unwrapOne(graphQLType), value);
                 if (returnValue == null) {
-                    throw new NonNullableValueCoercedAsNullException(variableDefinition, graphQLType);
+                    throw new NonNullableValueCoercedAsNullException(variableDefinition, inputName, graphQLType);
                 }
                 return returnValue;
             }

File: src/main/java/graphql/language/InputValueDefinition.java
Patch:
@@ -81,7 +81,9 @@ public List<Directive> getDirectives() {
     public List<Node> getChildren() {
         List<Node> result = new ArrayList<>();
         result.add(type);
-        result.add(defaultValue);
+        if (defaultValue != null) {
+            result.add(defaultValue);
+        }
         result.addAll(directives);
         return result;
     }

File: src/main/java/graphql/util/Traverser.java
Patch:
@@ -23,6 +23,8 @@ public class Traverser<T> {
     private final Function<? super T, ? extends List<T>> getChildren;
     private final Map<Class<?>, Object> rootVars = new ConcurrentHashMap<>();
 
+    private final TraverserContext<T> BARRIER = new SimpleTraverserContext<>(null);
+
     private static final List<TraversalControl> CONTINUE_OR_QUIT = Arrays.asList(CONTINUE, QUIT);
 
     private Traverser(TraverserState<T> traverserState, Function<? super T, ? extends List<T>> getChildren) {
@@ -62,14 +64,13 @@ public TraverserResult traverse(T root, TraverserVisitor<? super T> visitor) {
         return traverse(Collections.singleton(root), visitor);
     }
 
-
     public TraverserResult traverse(Collection<? extends T> roots, TraverserVisitor<? super T> visitor) {
         assertNotNull(roots);
         assertNotNull(visitor);
 
         traverserState.addNewContexts(roots, traverserState.newContext(null, null, rootVars));
 
-        TraverserContext currentContext = null;
+        TraverserContext currentContext = BARRIER;
         traverseLoop:
         while (!traverserState.isEmpty()) {
             Object top = traverserState.pop();

File: src/main/java/graphql/language/BooleanValue.java
Patch:
@@ -11,7 +11,7 @@
 import java.util.function.Consumer;
 
 @PublicApi
-public class BooleanValue extends AbstractNode<BooleanValue> implements Value<BooleanValue> {
+public class BooleanValue extends AbstractNode<BooleanValue> implements ScalarValue<BooleanValue> {
 
     private final boolean value;
 

File: src/main/java/graphql/language/FloatValue.java
Patch:
@@ -12,7 +12,7 @@
 import java.util.function.Consumer;
 
 @PublicApi
-public class FloatValue extends AbstractNode<FloatValue> implements Value<FloatValue> {
+public class FloatValue extends AbstractNode<FloatValue> implements ScalarValue<FloatValue> {
 
     private final BigDecimal value;
 

File: src/main/java/graphql/language/IntValue.java
Patch:
@@ -12,7 +12,7 @@
 import java.util.function.Consumer;
 
 @PublicApi
-public class IntValue extends AbstractNode<IntValue> implements Value<IntValue> {
+public class IntValue extends AbstractNode<IntValue> implements ScalarValue<IntValue> {
 
     private final BigInteger value;
 

File: src/main/java/graphql/language/StringValue.java
Patch:
@@ -11,7 +11,7 @@
 import java.util.function.Consumer;
 
 @PublicApi
-public class StringValue extends AbstractNode<StringValue> implements Value<StringValue> {
+public class StringValue extends AbstractNode<StringValue> implements ScalarValue<StringValue> {
 
     private final String value;
 

File: src/main/java/graphql/schema/TypeTraverser.java
Patch:
@@ -2,6 +2,7 @@
 
 
 import graphql.Internal;
+import graphql.PublicApi;
 import graphql.util.TraversalControl;
 import graphql.util.Traverser;
 import graphql.util.TraverserContext;
@@ -17,7 +18,7 @@
 
 import static graphql.util.TraversalControl.CONTINUE;
 
-@Internal
+@PublicApi
 public class TypeTraverser {
 
 

File: src/main/java/graphql/introspection/IntrospectionResultToSchema.java
Patch:
@@ -74,7 +74,7 @@ public Document createSchemaDefinition(Map<String, Object> introspectionResult)
         TypeName query = TypeName.newTypeName().name((String) queryType.get("name")).build();
         boolean nonDefaultQueryName = !"Query".equals(query.getName());
 
-        SchemaDefinition.Builder schemaDefinition = SchemaDefinition.newSchemaDefintion();
+        SchemaDefinition.Builder schemaDefinition = SchemaDefinition.newSchemaDefinition();
         schemaDefinition.operationTypeDefinition(OperationTypeDefinition.newOperationTypeDefinition().name("query").type(query).build());
 
         Map<String, Object> mutationType = (Map<String, Object>) schema.get("mutationType");

File: src/main/java/graphql/language/SchemaDefinition.java
Patch:
@@ -88,7 +88,7 @@ public SchemaDefinition transform(Consumer<Builder> builderConsumer) {
         return builder.build();
     }
 
-    public static Builder newSchemaDefintion() {
+    public static Builder newSchemaDefinition() {
         return new Builder();
     }
 

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -350,7 +350,7 @@ protected Directive createDirective(GraphqlParser.DirectiveContext ctx) {
     }
 
     protected SchemaDefinition createSchemaDefinition(GraphqlParser.SchemaDefinitionContext ctx) {
-        SchemaDefinition.Builder def = SchemaDefinition.newSchemaDefintion();
+        SchemaDefinition.Builder def = SchemaDefinition.newSchemaDefinition();
         addCommonData(def, ctx);
         def.directives(createDirectives(ctx.directives()));
         def.operationTypeDefinitions(ctx.operationTypeDefinition().stream()

File: src/main/java/graphql/analysis/QueryVisitor.java
Patch:
@@ -10,7 +10,7 @@
 @PublicApi
 public interface QueryVisitor {
 
-    void visitField(QueryVisitorFieldEnvironment QueryVisitorFieldEnvironment);
+    void visitField(QueryVisitorFieldEnvironment queryVisitorFieldEnvironment);
 
     void visitInlineFragment(QueryVisitorInlineFragmentEnvironment queryVisitorInlineFragmentEnvironment);
 

File: src/main/java/graphql/analysis/QueryVisitorStub.java
Patch:
@@ -7,7 +7,7 @@ public class QueryVisitorStub implements QueryVisitor {
 
 
     @Override
-    public void visitField(QueryVisitorFieldEnvironment QueryVisitorFieldEnvironment) {
+    public void visitField(QueryVisitorFieldEnvironment queryVisitorFieldEnvironment) {
 
     }
 

File: src/main/java/graphql/execution/instrumentation/fieldvalidation/FieldValidationSupport.java
Patch:
@@ -106,7 +106,7 @@ public GraphQLFieldDefinition getFieldDefinition() {
 
         @Override
         public GraphQLCompositeType getParentType() {
-            return traversalEnv.getParentType();
+            return traversalEnv.getUnmodifiedParentType();
         }
 
         @Override

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -2,6 +2,7 @@
 
 
 import graphql.Assert;
+import graphql.PublicApi;
 import graphql.language.AstPrinter;
 import graphql.language.AstValueHelper;
 import graphql.schema.DataFetcher;
@@ -40,6 +41,7 @@
 import static graphql.schema.GraphQLObjectType.newObject;
 import static graphql.schema.GraphQLTypeReference.typeRef;
 
+@PublicApi
 public class Introspection {
 
     public enum TypeKind {

File: src/main/java/graphql/schema/GraphQLTypeReference.java
Patch:
@@ -1,12 +1,15 @@
 package graphql.schema;
 
 
+import graphql.PublicApi;
+
 import static graphql.Assert.assertValidName;
 
 /**
  * A special type to allow a object/interface types to reference itself. It's replaced with the real type
  * object when the schema is built.
  */
+@PublicApi
 public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType, GraphQLInputType {
 
     /**

File: src/main/java/graphql/language/Argument.java
Patch:
@@ -28,9 +28,7 @@ private Argument(String name, Value value, SourceLocation sourceLocation, List<C
      * @param value
      */
     public Argument(String name, Value value) {
-        super(null, new ArrayList<>());
-        this.name = name;
-        this.value = value;
+        this(name, value, null, new ArrayList<>());
     }
 
     @Override

File: src/main/java/graphql/language/OperationTypeDefinition.java
Patch:
@@ -76,6 +76,7 @@ public static Builder newOperationTypeDefinition() {
         return new Builder();
     }
 
+
     public static final class Builder implements NodeBuilder {
         private SourceLocation sourceLocation;
         private List<Comment> comments = Collections.emptyList();

File: src/main/java/graphql/language/InlineFragment.java
Patch:
@@ -29,6 +29,9 @@ private InlineFragment(TypeName typeCondition,
         this.selectionSet = selectionSet;
     }
 
+    public InlineFragment(TypeName typeCondition) {
+        this(typeCondition, new ArrayList<>(), null, null, new ArrayList<>());
+    }
 
     public TypeName getTypeCondition() {
         return typeCondition;

File: src/main/java/graphql/language/FieldDefinition.java
Patch:
@@ -51,12 +51,12 @@ public Description getDescription() {
     }
 
     public List<InputValueDefinition> getInputValueDefinitions() {
-        return inputValueDefinitions;
+        return new ArrayList<>(inputValueDefinitions);
     }
 
     @Override
     public List<Directive> getDirectives() {
-        return directives;
+        return new ArrayList<>(directives);
     }
 
     @Override

File: src/main/java/graphql/language/EnumTypeDefinition.java
Patch:
@@ -36,7 +36,7 @@ public EnumTypeDefinition(String name) {
     }
 
     public List<EnumValueDefinition> getEnumValueDefinitions() {
-        return enumValueDefinitions;
+        return new ArrayList<>(enumValueDefinitions);
     }
 
     @Override

File: src/main/java/graphql/language/IntValue.java
Patch:
@@ -61,6 +61,9 @@ public static Builder newIntValue() {
         return new Builder();
     }
 
+    public static Builder newIntValue(BigInteger value) {
+        return new Builder().value(value);
+    }
 
     public static final class Builder implements NodeBuilder {
         private SourceLocation sourceLocation;

File: src/main/java/graphql/schema/GraphQLNonNull.java
Patch:
@@ -13,6 +13,7 @@
  * See http://graphql.org/learn/schema/#lists-and-non-null for more details on the concept
  */
 @PublicApi
+
 public class GraphQLNonNull implements GraphQLType, GraphQLInputType, GraphQLOutputType, GraphQLModifiedType {
 
     /**

File: src/main/java/graphql/language/Argument.java
Patch:
@@ -71,6 +71,9 @@ public static Builder newArgument() {
         return new Builder();
     }
 
+    public static Builder newArgument(String name, Value value) {
+        return new Builder().name(name).value(value);
+    }
 
     public static final class Builder implements NodeBuilder {
         private SourceLocation sourceLocation;

File: src/main/java/graphql/language/EnumTypeDefinition.java
Patch:
@@ -97,8 +97,8 @@ public static final class Builder implements NodeBuilder {
         private List<Comment> comments = Collections.emptyList();
         private String name;
         private Description description;
-        private List<EnumValueDefinition> enumValueDefinitions;
-        private List<Directive> directives;
+        private List<EnumValueDefinition> enumValueDefinitions = new ArrayList<>();
+        private List<Directive> directives = new ArrayList<>();
 
         private Builder() {
         }

File: src/main/java/graphql/execution/ConditionalNodes.java
Patch:
@@ -18,7 +18,8 @@ public ConditionalNodes() {
         valuesResolver = new ValuesResolver();
     }
 
-    public boolean shouldInclude(Map<String, Object> variables, List<Directive> directives) {
+    public boolean
+    shouldInclude(Map<String, Object> variables, List<Directive> directives) {
         boolean skip = getDirectiveResult(variables, directives, SkipDirective.getName(), false);
         boolean include = getDirectiveResult(variables, directives, IncludeDirective.getName(), true);
         return !skip && include;

File: src/main/java/graphql/language/Document.java
Patch:
@@ -66,7 +66,7 @@ public static Builder newDocument() {
 
 
     public static final class Builder implements NodeBuilder {
-        private List<Definition> definitions;
+        private List<Definition> definitions = new ArrayList<>();
         private SourceLocation sourceLocation;
         private List<Comment> comments = Collections.emptyList();
 

File: src/main/java/graphql/language/FragmentDefinition.java
Patch:
@@ -109,7 +109,7 @@ public TraversalControl accept(TraverserContext<Node> context, NodeVisitor nodeV
         return nodeVisitor.visitFragmentDefinition(this, context);
     }
 
-    public static Builder newBuilder() {
+    public static Builder newFragmentDefinition() {
         return new Builder();
     }
 

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage2.java
Patch:
@@ -202,7 +202,7 @@ private VariableDefinition createVariableDefinition(GraphqlParser.VariableDefini
     }
 
     public FragmentDefinition createFragmentDefinition(GraphqlParser.FragmentDefinitionContext ctx) {
-        FragmentDefinition.Builder fragmentDefinition = FragmentDefinition.newBuilder();
+        FragmentDefinition.Builder fragmentDefinition = FragmentDefinition.newFragmentDefinition();
         newNode(fragmentDefinition, ctx);
         fragmentDefinition.name(ctx.fragmentName().getText());
         fragmentDefinition.typeCondition(new TypeName(ctx.typeCondition().typeName().getText()));

File: src/main/java/graphql/language/DirectiveDefinition.java
Patch:
@@ -94,8 +94,8 @@ public static final class Builder implements NodeBuilder {
         private List<Comment> comments = Collections.emptyList();
         private String name;
         private Description description;
-        private List<InputValueDefinition> inputValueDefinitions;
-        private List<DirectiveLocation> directiveLocations;
+        private List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
+        private List<DirectiveLocation> directiveLocations = new ArrayList<>();
 
         private Builder() {
         }

File: src/main/java/graphql/language/ScalarTypeDefinition.java
Patch:
@@ -85,7 +85,7 @@ public static final class Builder implements NodeBuilder {
         private List<Comment> comments = Collections.emptyList();
         private String name;
         private Description description;
-        private List<Directive> directives;
+        private List<Directive> directives = new ArrayList<>();
 
         private Builder() {
         }

File: src/main/java/graphql/language/InlineFragment.java
Patch:
@@ -120,7 +120,7 @@ public static final class Builder implements NodeBuilder {
         private SourceLocation sourceLocation;
         private List<Comment> comments = Collections.emptyList();
         private TypeName typeCondition;
-        private List<Directive> directives;
+        private List<Directive> directives = new ArrayList<>();
         private SelectionSet selectionSet;
 
         private Builder() {

File: src/main/java/graphql/schema/idl/TypeInfo.java
Patch:
@@ -11,6 +11,7 @@
 import java.util.Objects;
 import java.util.Stack;
 
+import static graphql.Assert.assertNotNull;
 import static graphql.schema.GraphQLList.list;
 import static graphql.schema.GraphQLNonNull.nonNull;
 
@@ -29,7 +30,7 @@ public static TypeInfo typeInfo(Type type) {
     private final Stack<Class<?>> decoration = new Stack<>();
 
     private TypeInfo(Type type) {
-        this.rawType = type;
+        this.rawType = assertNotNull(type, "type must not be null");
         while (!(type instanceof TypeName)) {
             if (type instanceof NonNullType) {
                 decoration.push(NonNullType.class);

File: src/main/java/graphql/language/FieldDefinition.java
Patch:
@@ -113,8 +113,8 @@ public static final class Builder implements NodeBuilder {
         private List<Comment> comments = Collections.emptyList();
         private Type type;
         private Description description;
-        private List<InputValueDefinition> inputValueDefinitions;
-        private List<Directive> directives;
+        private List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
+        private List<Directive> directives = new ArrayList<>();
 
         private Builder() {
         }

File: src/main/java/graphql/language/ObjectTypeDefinition.java
Patch:
@@ -107,9 +107,9 @@ public static final class Builder implements NodeBuilder {
         private List<Comment> comments = Collections.emptyList();
         private String name;
         private Description description;
-        private List<Type> implementz;
-        private List<Directive> directives;
-        private List<FieldDefinition> fieldDefinitions;
+        private List<Type> implementz = new ArrayList<>();
+        private List<Directive> directives = new ArrayList<>();
+        private List<FieldDefinition> fieldDefinitions = new ArrayList<>();
 
         private Builder() {
         }

File: src/main/java/graphql/language/InputValueDefinition.java
Patch:
@@ -122,7 +122,7 @@ public static final class Builder implements NodeBuilder {
         private Type type;
         private Value defaultValue;
         private Description description;
-        private List<Directive> directives;
+        private List<Directive> directives = new ArrayList<>();
 
         private Builder() {
         }

File: src/main/java/graphql/Assert.java
Patch:
@@ -4,6 +4,7 @@
 
 import static java.lang.String.format;
 
+@SuppressWarnings("TypeParameterUnusedInFormals")
 @Internal
 public class Assert {
 

File: src/main/java/graphql/ExecutionResult.java
Patch:
@@ -8,6 +8,7 @@
  * This simple value class represents the result of performing a graphql query.
  */
 @PublicApi
+@SuppressWarnings("TypeParameterUnusedInFormals")
 public interface ExecutionResult {
 
     /**

File: src/main/java/graphql/ExecutionResultImpl.java
Patch:
@@ -52,6 +52,7 @@ public boolean isDataPresent() {
     }
 
     @Override
+    @SuppressWarnings("TypeParameterUnusedInFormals")
     public <T> T getData() {
         //noinspection unchecked
         return (T) data;

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -556,7 +556,7 @@ private CompletableFuture<ExecutionResult> execute(ExecutionInput executionInput
 
         log.debug("Executing '{}'. operation name: '{}'. query: '{}'. variables '{}'", executionId, executionInput.getOperationName(), executionInput.getQuery(), executionInput.getVariables());
         CompletableFuture<ExecutionResult> future = execution.execute(document, graphQLSchema, executionId, executionInput, instrumentationState);
-        future.whenComplete((result, throwable) -> {
+        future = future.whenComplete((result, throwable) -> {
             if (throwable != null) {
                 log.error(String.format("Execution '%s' threw exception when executing : query : '%s'. variables '%s'", executionId, executionInput.getQuery(), executionInput.getVariables()), throwable);
             } else {

File: src/main/java/graphql/TypeResolutionEnvironment.java
Patch:
@@ -11,6 +11,7 @@
  *
  * See {@link graphql.schema.TypeResolver#getType(TypeResolutionEnvironment)} for how this is used
  */
+@SuppressWarnings("TypeParameterUnusedInFormals")
 public class TypeResolutionEnvironment {
 
     private final Object object;

File: src/main/java/graphql/execution/Async.java
Patch:
@@ -13,6 +13,7 @@
 import java.util.function.Supplier;
 
 @Internal
+@SuppressWarnings("FutureReturnValueIgnored")
 public class Async {
 
     @FunctionalInterface

File: src/main/java/graphql/execution/AsyncExecutionStrategy.java
Patch:
@@ -43,6 +43,7 @@ public AsyncExecutionStrategy(DataFetcherExceptionHandler exceptionHandler) {
     }
 
     @Override
+    @SuppressWarnings("FutureReturnValueIgnored")
     public CompletableFuture<ExecutionResult> execute(ExecutionContext executionContext, ExecutionStrategyParameters parameters) throws NonNullableFieldWasNullException {
 
         Instrumentation instrumentation = executionContext.getInstrumentation();
@@ -112,6 +113,7 @@ private boolean isDeferred(ExecutionContext executionContext, ExecutionStrategyP
         return false;
     }
 
+    @SuppressWarnings("FutureReturnValueIgnored")
     private Supplier<CompletableFuture<ExecutionResult>> deferredExecutionResult(ExecutionContext executionContext, ExecutionStrategyParameters parameters) {
         return () -> {
             GraphQLFieldDefinition fieldDef = getFieldDef(executionContext, parameters, parameters.getField().get(0));
@@ -128,7 +130,7 @@ private Supplier<CompletableFuture<ExecutionResult>> deferredExecutionResult(Exe
                 fieldCtx.onFieldValueInfo(fieldValueInfo);
 
                 CompletableFuture<ExecutionResult> execResultFuture = fieldValueInfo.getFieldValue();
-                execResultFuture.whenComplete(fieldCtx::onCompleted);
+                execResultFuture = execResultFuture.whenComplete(fieldCtx::onCompleted);
                 Async.copyResults(execResultFuture, result);
             });
             return result;

File: src/main/java/graphql/execution/AsyncSerialExecutionStrategy.java
Patch:
@@ -26,6 +26,7 @@ public AsyncSerialExecutionStrategy(DataFetcherExceptionHandler exceptionHandler
     }
 
     @Override
+    @SuppressWarnings({"TypeParameterUnusedInFormals","FutureReturnValueIgnored"})
     public CompletableFuture<ExecutionResult> execute(ExecutionContext executionContext, ExecutionStrategyParameters parameters) throws NonNullableFieldWasNullException {
 
         Instrumentation instrumentation = executionContext.getInstrumentation();

File: src/main/java/graphql/execution/ExecutionContext.java
Patch:
@@ -17,6 +17,7 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Consumer;
 
+@SuppressWarnings("TypeParameterUnusedInFormals")
 @PublicApi
 public class ExecutionContext {
 

File: src/main/java/graphql/execution/ExecutionPath.java
Patch:
@@ -59,7 +59,7 @@ public int getLevel() {
     }
 
     public ExecutionPath getPathWithoutListEnd() {
-        if(this == ROOT_PATH) {
+        if(ROOT_PATH.equals(this)) {
             return ROOT_PATH;
         }
         if (segment instanceof StringPathSegment) {
@@ -180,7 +180,7 @@ public String toString() {
             return "";
         }
 
-        if (parent == ROOT_PATH) {
+        if (ROOT_PATH.equals(parent)) {
             return segment.toString();
         }
 

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -111,6 +111,7 @@
  * {@link #execute(ExecutionContext, ExecutionStrategyParameters)} is the entry point of the execution strategy.
  */
 @PublicSpi
+@SuppressWarnings("FutureReturnValueIgnored")
 public abstract class ExecutionStrategy {
 
     private static final Logger log = LoggerFactory.getLogger(ExecutionStrategy.class);

File: src/main/java/graphql/execution/ExecutorServiceExecutionStrategy.java
Patch:
@@ -95,7 +95,7 @@ public CompletableFuture<ExecutionResult> execute(final ExecutionContext executi
             ExecutionResultImpl executionResult = new ExecutionResultImpl(results, executionContext.getErrors());
             overallResult.complete(executionResult);
 
-            overallResult.whenComplete(executionStrategyCtx::onCompleted);
+            overallResult = overallResult.whenComplete(executionStrategyCtx::onCompleted);
             return overallResult;
         } catch (InterruptedException | ExecutionException e) {
             executionStrategyCtx.onCompleted(null, e);

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -98,6 +98,7 @@ public BatchedExecutionStrategy(DataFetcherExceptionHandler dataFetcherException
     }
 
     @Override
+    @SuppressWarnings("FutureReturnValueIgnored")
     public CompletableFuture<ExecutionResult> execute(ExecutionContext executionContext, ExecutionStrategyParameters parameters) {
         InstrumentationContext<ExecutionResult> executionStrategyCtx = executionContext.getInstrumentation()
                 .beginExecutionStrategy(new InstrumentationExecutionStrategyParameters(executionContext, parameters));
@@ -126,6 +127,7 @@ public CompletableFuture<ExecutionResult> execute(ExecutionContext executionCont
         return result;
     }
 
+    @SuppressWarnings("FutureReturnValueIgnored")
     private void executeImpl(ExecutionContext executionContext,
                              ExecutionStrategyParameters parameters,
                              ExecutionNode root,
@@ -219,7 +221,7 @@ private CompletableFuture<List<ExecutionNode>> resolveField(ExecutionContext exe
             return completeValues(executionContext, fetchedValues, typeInfo, fieldName, fields, argumentValues);
         });
         fieldCtx.onDispatched(null);
-        result.whenComplete((nodes, throwable) -> fieldCtx.onCompleted(null, throwable));
+        result = result.whenComplete((nodes, throwable) -> fieldCtx.onCompleted(null, throwable));
         return result;
 
     }

File: src/main/java/graphql/execution/defer/DeferSupport.java
Patch:
@@ -33,6 +33,7 @@ public boolean checkForDeferDirective(List<Field> currentField) {
         return false;
     }
 
+    @SuppressWarnings("FutureReturnValueIgnored")
     private void drainDeferredCalls() {
         if (deferredCalls.isEmpty()) {
             publisher.noMoreData();

File: src/main/java/graphql/execution/instrumentation/fieldvalidation/FieldAndArguments.java
Patch:
@@ -55,5 +55,6 @@ public interface FieldAndArguments {
      *
      * @return a cast object of type T
      */
+    @SuppressWarnings("TypeParameterUnusedInFormals")
     <T> T getArgumentValue(String argumentName);
 }

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationExecuteOperationParameters.java
Patch:
@@ -7,6 +7,7 @@
 /**
  * Parameters sent to {@link Instrumentation} methods
  */
+@SuppressWarnings("TypeParameterUnusedInFormals")
 public class InstrumentationExecuteOperationParameters {
     private final ExecutionContext executionContext;
     private final InstrumentationState instrumentationState;

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationExecutionParameters.java
Patch:
@@ -55,7 +55,7 @@ public String getOperation() {
         return operation;
     }
 
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "TypeParameterUnusedInFormals"})
     public <T> T getContext() {
         return (T) context;
     }
@@ -64,6 +64,7 @@ public Map<String, Object> getVariables() {
         return variables;
     }
 
+    @SuppressWarnings("TypeParameterUnusedInFormals")
     public <T extends InstrumentationState> T getInstrumentationState() {
         //noinspection unchecked
         return (T) instrumentationState;
@@ -72,6 +73,4 @@ public <T extends InstrumentationState> T getInstrumentationState() {
     public GraphQLSchema getSchema() {
         return this.schema;
     }
-
-
 }

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationExecutionStrategyParameters.java
Patch:
@@ -42,6 +42,7 @@ public ExecutionStrategyParameters getExecutionStrategyParameters() {
         return executionStrategyParameters;
     }
 
+    @SuppressWarnings("TypeParameterUnusedInFormals")
     public <T extends InstrumentationState> T getInstrumentationState() {
         //noinspection unchecked
         return (T) instrumentationState;

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationFieldCompleteParameters.java
Patch:
@@ -63,6 +63,7 @@ public Object getFetchedValue() {
         return fetchedValue;
     }
 
+    @SuppressWarnings("TypeParameterUnusedInFormals")
     public <T extends InstrumentationState> T getInstrumentationState() {
         //noinspection unchecked
         return (T) instrumentationState;

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationFieldParameters.java
Patch:
@@ -51,6 +51,7 @@ public ExecutionTypeInfo getTypeInfo() {
         return typeInfo;
     }
 
+    @SuppressWarnings("TypeParameterUnusedInFormals")
     public <T extends InstrumentationState> T getInstrumentationState() {
         //noinspection unchecked
         return (T) instrumentationState;

File: src/main/java/graphql/language/NodeTraverser.java
Patch:
@@ -60,6 +60,7 @@ public TraversalControl leave(TraverserContext<Node> context) {
         nodeTraverser.traverse(roots, traverserVisitor);
     }
 
+    @SuppressWarnings("TypeParameterUnusedInFormals")
     public static <T> T oneVisitWithResult(Node node, NodeVisitor nodeVisitor) {
         SimpleTraverserContext<Node> context = new SimpleTraverserContext<>(node);
         node.accept(context, nodeVisitor);

File: src/main/java/graphql/schema/DataFetchingEnvironment.java
Patch:
@@ -10,10 +10,12 @@
 import java.util.List;
 import java.util.Map;
 
+
 /**
  * A DataFetchingEnvironment instance of passed to a {@link DataFetcher} as a execution context and its
  * the place where you can find out information to help you resolve a data value given a graphql field input
  */
+@SuppressWarnings("TypeParameterUnusedInFormals")
 @PublicApi
 public interface DataFetchingEnvironment {
 

File: src/main/java/graphql/schema/DataFetchingEnvironmentImpl.java
Patch:
@@ -13,7 +13,7 @@
 
 import static graphql.Assert.assertNotNull;
 
-@SuppressWarnings("unchecked")
+@SuppressWarnings({"unchecked","TypeParameterUnusedInFormals"})
 @Internal
 public class DataFetchingEnvironmentImpl implements DataFetchingEnvironment {
     private final Object source;

File: src/main/java/graphql/schema/diff/DiffCtx.java
Patch:
@@ -6,7 +6,9 @@
 import graphql.language.TypeDefinition;
 import graphql.schema.diff.reporting.DifferenceReporter;
 
+import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Deque;
 import java.util.List;
 import java.util.Optional;
 import java.util.Stack;
@@ -17,7 +19,7 @@
 @Internal
 class DiffCtx {
     final List<String> examinedTypes = new ArrayList<>();
-    final Stack<String> currentTypes = new Stack<>();
+    final Deque<String> currentTypes = new ArrayDeque<>();
     private final DifferenceReporter reporter;
     final Document oldDoc;
     final Document newDoc;

File: src/main/java/graphql/schema/diff/SchemaDiff.java
Patch:
@@ -66,7 +66,7 @@ public static Options defaultOptions() {
 
     }
 
-    private class CountingReporter implements DifferenceReporter {
+    private static class CountingReporter implements DifferenceReporter {
         final DifferenceReporter delegate;
         int breakingCount = 1;
 

File: src/main/java/graphql/schema/idl/EchoingWiringFactory.java
Patch:
@@ -103,9 +103,9 @@ private static Object fakeScalarValue(String fieldName, GraphQLScalarType scalar
         } else if (scalarType.equals(Scalars.GraphQLBigInteger)) {
             return new BigInteger("1");
         } else if (scalarType.equals(Scalars.GraphQLByte)) {
-            return new Byte("1");
+            return Byte.valueOf("1");
         } else if (scalarType.equals(Scalars.GraphQLShort)) {
-            return new Short("1");
+            return Short.valueOf("1");
         } else {
             return null;
         }

File: src/main/java/graphql/schema/idl/TypeInfo.java
Patch:
@@ -76,6 +76,7 @@ public boolean isPlain() {
      *
      * @return the decorated type
      */
+    @SuppressWarnings("TypeParameterUnusedInFormals")
     public <T extends GraphQLType> T decorate(GraphQLType objectType) {
 
         GraphQLType out = objectType;

File: src/test/groovy/example/http/HttpMain.java
Patch:
@@ -33,6 +33,7 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -267,12 +268,13 @@ private List<Object> loadCharactersViaHTTP(List<String> keys) {
     @SuppressWarnings("SameParameterValue")
     private Reader loadSchemaFile(String name) {
         InputStream stream = getClass().getClassLoader().getResourceAsStream(name);
-        return new InputStreamReader(stream);
+        return new InputStreamReader(stream, Charset.defaultCharset());
     }
 
     // Lots of the data happens to be maps of objects and this allows us to get back into type safety land
     // with less boiler plat and casts
     //
+    @SuppressWarnings("TypeParameterUnusedInFormals")
     private <T> T asMapGet(Object mapObj, Object mapKey) {
         Map<Object, ?> map = (Map<Object, ?>) mapObj;
         return (T) map.get(mapKey);

File: src/test/groovy/graphql/validation/SpecValidationSchemaPojos.java
Patch:
@@ -6,6 +6,7 @@
  *
  * @author dwinsor
  */
+@SuppressWarnings("ClassCanBeStatic")
 public class SpecValidationSchemaPojos {
     public class Human {
         public String name;

File: src/test/groovy/readme/BatchingExamples.java
Patch:
@@ -13,7 +13,7 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
 
-@SuppressWarnings({"unused", "Convert2Lambda", "ConstantConditions"})
+@SuppressWarnings({"unused", "Convert2Lambda", "ConstantConditions", "ClassCanBeStatic"})
 public class BatchingExamples {
 
 

File: src/test/groovy/readme/DirectivesExamples.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
-@SuppressWarnings({"Convert2Lambda", "unused"})
+@SuppressWarnings({"Convert2Lambda", "unused", "ClassCanBeStatic"})
 public class DirectivesExamples {
 
     static class AuthorisationCtx {

File: src/test/groovy/readme/ExecutionExamples.java
Patch:
@@ -34,7 +34,7 @@
 
 import static graphql.StarWarsSchema.queryType;
 
-@SuppressWarnings({"unused", "UnnecessaryLocalVariable", "Convert2Lambda"})
+@SuppressWarnings({"unused", "UnnecessaryLocalVariable", "Convert2Lambda", "unused", "ClassCanBeStatic", "TypeParameterUnusedInFormals"})
 public class ExecutionExamples {
 
     public static void main(String[] args) throws Exception {
@@ -58,7 +58,7 @@ private void simpleQueryExecution() throws Exception {
         List<GraphQLError> errors = executionResult.getErrors();
     }
 
-    @SuppressWarnings("Convert2MethodRef")
+    @SuppressWarnings({"Convert2MethodRef","unused","FutureReturnValueIgnored"})
     private void simpleAsyncQueryExecution() throws Exception {
         GraphQL graphQL = buildSchema();
 

File: src/test/groovy/readme/InstrumentationExamples.java
Patch:
@@ -31,7 +31,7 @@
 
 import static graphql.StarWarsSchema.queryType;
 
-@SuppressWarnings({"unused", "MismatchedQueryAndUpdateOfCollection", "Convert2Lambda"})
+@SuppressWarnings({"unused", "MismatchedQueryAndUpdateOfCollection", "Convert2Lambda", "ClassCanBeStatic"})
 public class InstrumentationExamples {
 
     private void specifyInstrumentation() {

File: src/test/groovy/readme/MappingExamples.java
Patch:
@@ -11,7 +11,7 @@
 import java.util.List;
 import java.util.Map;
 
-@SuppressWarnings({"Convert2Lambda", "unused"})
+@SuppressWarnings({"Convert2Lambda", "unused", "ClassCanBeStatic"})
 public class MappingExamples {
 
     interface ProductInfo {

File: src/test/groovy/readme/ReadmeExamples.java
Patch:
@@ -68,7 +68,7 @@
  * You should place these examples into the README.next.md and NOT the main README.md.  This allows
  * 'master' to progress yet shows consumers the released information about the project.
  */
-@SuppressWarnings({"unused", "Convert2Lambda", "UnnecessaryLocalVariable", "ConstantConditions", "SameParameterValue"})
+@SuppressWarnings({"unused", "Convert2Lambda", "UnnecessaryLocalVariable", "ConstantConditions", "SameParameterValue", "ClassCanBeStatic"})
 public class ReadmeExamples {
 
 
@@ -435,7 +435,7 @@ class Witch {
     }
 
     private void typeResolverExample() {
-        new TypeResolver() {
+        TypeResolver typeResolver = new TypeResolver() {
             @Override
             public GraphQLObjectType getType(TypeResolutionEnvironment env) {
                 Object javaObject = env.getObject();

File: src/main/java/graphql/ExceptionWhileDataFetching.java
Patch:
@@ -68,6 +68,7 @@ public List<SourceLocation> getLocations() {
         return locations;
     }
 
+    @Override
     public List<Object> getPath() {
         return path;
     }

File: src/main/java/graphql/SerializationError.java
Patch:
@@ -47,6 +47,7 @@ public ErrorType getErrorType() {
         return ErrorType.DataFetchingException;
     }
 
+    @Override
     public List<Object> getPath() {
         return path;
     }

File: src/main/java/graphql/TypeMismatchError.java
Patch:
@@ -74,6 +74,7 @@ public ErrorType getErrorType() {
         return ErrorType.DataFetchingException;
     }
 
+    @Override
     public List<Object> getPath() {
         return path;
     }

File: src/main/java/graphql/UnresolvedTypeError.java
Patch:
@@ -53,6 +53,7 @@ public ErrorType getErrorType() {
         return ErrorType.DataFetchingException;
     }
 
+    @Override
     public List<Object> getPath() {
         return path;
     }

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationDeferredFieldParameters.java
Patch:
@@ -29,6 +29,7 @@ public InstrumentationDeferredFieldParameters(ExecutionContext executionContext,
      *
      * @return a new parameters object with the new state
      */
+    @Override
     public InstrumentationDeferredFieldParameters withNewState(InstrumentationState instrumentationState) {
         return new InstrumentationDeferredFieldParameters(
                 this.getExecutionContext(), this.executionStrategyParameters, this.getField(), this.getTypeInfo(), instrumentationState);

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationFieldFetchParameters.java
Patch:
@@ -33,6 +33,7 @@ private InstrumentationFieldFetchParameters(ExecutionContext getExecutionContext
      *
      * @return a new parameters object with the new state
      */
+    @Override
     public InstrumentationFieldFetchParameters withNewState(InstrumentationState instrumentationState) {
         return new InstrumentationFieldFetchParameters(
                 this.getExecutionContext(), this.getField(), this.getEnvironment(),

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationValidationParameters.java
Patch:
@@ -24,6 +24,7 @@ public InstrumentationValidationParameters(ExecutionInput executionInput, Docume
      *
      * @return a new parameters object with the new state
      */
+    @Override
     public InstrumentationValidationParameters withNewState(InstrumentationState instrumentationState) {
         return new InstrumentationValidationParameters(
                 this.getExecutionInput(), document, getSchema(), instrumentationState);

File: src/main/java/graphql/language/AbstractNode.java
Patch:
@@ -22,6 +22,7 @@ public SourceLocation getSourceLocation() {
         return sourceLocation;
     }
 
+    @Override
     public List<Comment> getComments() {
         return comments;
     }

File: src/main/java/graphql/language/Argument.java
Patch:
@@ -17,6 +17,7 @@ public Argument(String name, Value value) {
         this.value = value;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/Definition.java
Patch:
@@ -6,5 +6,6 @@ public interface Definition<T extends Definition> extends Node<T> {
     /**
      * @return a deep copy of this definition
      */
+    @Override
     T deepCopy();
 }

File: src/main/java/graphql/language/Directive.java
Patch:
@@ -37,6 +37,7 @@ public Argument getArgument(String argumentName) {
         return getArgumentsByName().get(argumentName);
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/DirectiveDefinition.java
Patch:
@@ -23,6 +23,7 @@ public DirectiveDefinition(String name, List<InputValueDefinition> inputValueDef
         this.directiveLocations = directiveLocations;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/DirectiveLocation.java
Patch:
@@ -22,6 +22,7 @@ public DirectiveLocation(String name) {
         this.name = name;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/EnumTypeDefinition.java
Patch:
@@ -30,6 +30,7 @@ public List<EnumValueDefinition> getEnumValueDefinitions() {
         return enumValueDefinitions;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/EnumTypeExtensionDefinition.java
Patch:
@@ -15,6 +15,7 @@ public EnumTypeExtensionDefinition(String name, List<EnumValueDefinition> enumVa
         super(name, enumValueDefinitions, directives);
     }
 
+    @Override
     public EnumTypeExtensionDefinition deepCopy() {
         return new EnumTypeExtensionDefinition(getName(),
                 deepCopy(getEnumValueDefinitions()),

File: src/main/java/graphql/language/EnumValue.java
Patch:
@@ -15,6 +15,7 @@ public EnumValue(String name) {
         this.name = name;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/EnumValueDefinition.java
Patch:
@@ -21,6 +21,7 @@ public EnumValueDefinition(String name, List<Directive> directives) {
         this.directives = (null == directives) ? new ArrayList<>() : directives;
     }
 
+    @Override
     public String getName() {
         return name;
     }
@@ -33,6 +34,7 @@ public void setDescription(Description description) {
         this.description = description;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/Field.java
Patch:
@@ -64,6 +64,7 @@ public List<Node> getChildren() {
     }
 
 
+    @Override
     public String getName() {
         return name;
     }
@@ -88,6 +89,7 @@ public void setArguments(List<Argument> arguments) {
         this.arguments = arguments;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }
@@ -96,6 +98,7 @@ public void setDirectives(List<Directive> directives) {
         this.directives = directives;
     }
 
+    @Override
     public SelectionSet getSelectionSet() {
         return selectionSet;
     }

File: src/main/java/graphql/language/FieldDefinition.java
Patch:
@@ -37,6 +37,7 @@ public void setType(Type type) {
         this.type = type;
     }
 
+    @Override
     public String getName() {
         return name;
     }
@@ -53,6 +54,7 @@ public List<InputValueDefinition> getInputValueDefinitions() {
         return inputValueDefinitions;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/FragmentDefinition.java
Patch:
@@ -38,6 +38,7 @@ public FragmentDefinition(String name, TypeName typeCondition, List<Directive> d
         this.selectionSet = selectionSet;
     }
 
+    @Override
     public String getName() {
         return name;
     }
@@ -54,6 +55,7 @@ public void setTypeCondition(TypeName typeCondition) {
         this.typeCondition = typeCondition;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }
@@ -62,6 +64,7 @@ public void setDirectives(List<Directive> directives) {
         this.directives = directives;
     }
 
+    @Override
     public SelectionSet getSelectionSet() {
         return selectionSet;
     }

File: src/main/java/graphql/language/FragmentSpread.java
Patch:
@@ -24,6 +24,7 @@ public FragmentSpread(String name, List<Directive> directives) {
         this.directives = directives;
     }
 
+    @Override
     public String getName() {
         return name;
     }
@@ -32,6 +33,7 @@ public void setName(String name) {
         this.name = name;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/InlineFragment.java
Patch:
@@ -59,6 +59,7 @@ public void setDirectives(List<Directive> directives) {
         this.directives = directives;
     }
 
+    @Override
     public SelectionSet getSelectionSet() {
         return selectionSet;
     }

File: src/main/java/graphql/language/InputObjectTypeDefinition.java
Patch:
@@ -23,6 +23,7 @@ public InputObjectTypeDefinition(String name, List<Directive> directives, List<I
         this.inputValueDefinitions = inputValueDefinitions;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/InputValueDefinition.java
Patch:
@@ -41,6 +41,7 @@ public void setType(Type type) {
         this.type = type;
     }
 
+    @Override
     public String getName() {
         return name;
     }
@@ -61,6 +62,7 @@ public void setDefaultValue(Value defaultValue) {
         this.defaultValue = defaultValue;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/InterfaceTypeDefinition.java
Patch:
@@ -27,6 +27,7 @@ public List<FieldDefinition> getFieldDefinitions() {
         return definitions;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/InterfaceTypeExtensionDefinition.java
Patch:
@@ -12,6 +12,7 @@ public InterfaceTypeExtensionDefinition(String name, List<FieldDefinition> defin
         super(name, definitions, directives);
     }
 
+    @Override
     public InterfaceTypeExtensionDefinition deepCopy() {
         return new InterfaceTypeExtensionDefinition(getName(),
                 deepCopy(getFieldDefinitions()),

File: src/main/java/graphql/language/NodeTraverser.java
Patch:
@@ -45,11 +45,13 @@ private void doTraverse(NodeVisitor nodeVisitor, Collection<? extends Node> root
         nodeTraverser.rootVars(rootVars);
         TraverserVisitor<Node> traverserVisitor = new TraverserVisitor<Node>() {
 
+            @Override
             public TraversalControl enter(TraverserContext<Node> context) {
                 context.setVar(LeaveOrEnter.class, LeaveOrEnter.ENTER);
                 return context.thisNode().accept(context, nodeVisitor);
             }
 
+            @Override
             public TraversalControl leave(TraverserContext<Node> context) {
                 context.setVar(LeaveOrEnter.class, LeaveOrEnter.LEAVE);
                 return context.thisNode().accept(context, nodeVisitor);

File: src/main/java/graphql/language/ObjectField.java
Patch:
@@ -17,6 +17,7 @@ public ObjectField(String name, Value value) {
         this.value = value;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/ObjectTypeDefinition.java
Patch:
@@ -29,6 +29,7 @@ public List<Type> getImplements() {
         return implementz;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/ObjectTypeExtensionDefinition.java
Patch:
@@ -16,6 +16,7 @@ public ObjectTypeExtensionDefinition(String name, List<Type> implementz, List<Di
         super(name, implementz, directives, fieldDefinitions);
     }
 
+    @Override
     public ObjectTypeExtensionDefinition deepCopy() {
         return new ObjectTypeExtensionDefinition(getName(),
                 deepCopy(getImplements()),

File: src/main/java/graphql/language/OperationDefinition.java
Patch:
@@ -86,6 +86,7 @@ public void setDirectives(List<Directive> directives) {
         this.directives = directives;
     }
 
+    @Override
     public SelectionSet getSelectionSet() {
         return selectionSet;
     }

File: src/main/java/graphql/language/OperationTypeDefinition.java
Patch:
@@ -34,6 +34,7 @@ public void setType(Type type) {
         this.type = type;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/ScalarTypeDefinition.java
Patch:
@@ -21,6 +21,7 @@ public ScalarTypeDefinition(String name, List<Directive> directives) {
         this.directives = directives;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/ScalarTypeExtensionDefinition.java
Patch:
@@ -12,6 +12,7 @@ public ScalarTypeExtensionDefinition(String name, List<Directive> directives) {
         super(name, directives);
     }
 
+    @Override
     public ScalarTypeExtensionDefinition deepCopy() {
         return new ScalarTypeExtensionDefinition(getName(), deepCopy(getDirectives()));
     }

File: src/main/java/graphql/language/Type.java
Patch:
@@ -6,5 +6,6 @@ public interface Type<T extends Type> extends Node<T> {
     /**
      * @return a deep copy of this type
      */
+    @Override
     T deepCopy();
 }

File: src/main/java/graphql/language/TypeDefinition.java
Patch:
@@ -17,5 +17,6 @@ public interface TypeDefinition<T extends TypeDefinition> extends Definition<T>{
     /**
      * @return a deep copy of this type definition
      */
+    @Override
     T deepCopy();
 }

File: src/main/java/graphql/language/UnionTypeDefinition.java
Patch:
@@ -23,6 +23,7 @@ public UnionTypeDefinition(String name, List<Directive> directives, List<Type> m
         this.memberTypes = memberTypes;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/UnionTypeExtensionDefinition.java
Patch:
@@ -11,6 +11,7 @@ public UnionTypeExtensionDefinition(String name, List<Directive> directives, Lis
         super(name, directives, memberTypes);
     }
 
+    @Override
     public UnionTypeExtensionDefinition deepCopy() {
         return new UnionTypeExtensionDefinition(getName(),
                 deepCopy(getDirectives()),

File: src/main/java/graphql/language/Value.java
Patch:
@@ -6,5 +6,6 @@ public interface Value<T extends Value> extends Node<T> {
     /**
      * @return a deep copy of this value
      */
+    @Override
     T deepCopy();
 }

File: src/main/java/graphql/language/VariableDefinition.java
Patch:
@@ -35,6 +35,7 @@ public void setDefaultValue(Value defaultValue) {
         this.defaultValue = defaultValue;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/VariableReference.java
Patch:
@@ -15,6 +15,7 @@ public VariableReference(String name) {
         this.name = name;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/DataFetchingFieldSelectionSet.java
Patch:
@@ -39,6 +39,7 @@ public interface DataFetchingFieldSelectionSet extends Supplier<Map<String, List
     /**
      * @return a map of the fields that represent the selection set
      */
+    @Override
     Map<String, List<Field>> get();
 
     /**

File: src/main/java/graphql/schema/DataFetchingFieldSelectionSetImpl.java
Patch:
@@ -88,11 +88,13 @@ public Map<String, List<Field>> get() {
         return selectionSetFields;
     }
 
+    @Override
     public Map<String, Map<String, Object>> getArguments() {
         computeValuesLazily();
         return selectionSetFieldArgs;
     }
 
+    @Override
     public Map<String, GraphQLFieldDefinition> getDefinitions() {
         computeValuesLazily();
         return selectionSetFieldDefinitions;

File: src/main/java/graphql/schema/GraphQLArgument.java
Patch:
@@ -75,6 +75,7 @@ void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
         type = (GraphQLInputType) new SchemaUtil().resolveTypeReference(type, typeMap);
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -139,6 +139,7 @@ private Object getNameByValue(Object value) {
         throw new CoercingSerializeException("Invalid input for Enum '" + name + "'. Unknown value '" + value + "'");
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -69,6 +69,7 @@ void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
         this.type = (GraphQLOutputType) new SchemaUtil().resolveTypeReference(this.type, typeMap);
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -63,6 +63,7 @@ void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
         type = (GraphQLInputType) new SchemaUtil().resolveTypeReference(type, typeMap);
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLInputObjectType.java
Patch:
@@ -60,6 +60,7 @@ private void buildMap(List<GraphQLInputObjectField> fields) {
         }
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -68,15 +68,18 @@ private void buildDefinitionMap(List<GraphQLFieldDefinition> fieldDefinitions) {
         }
     }
 
+    @Override
     public GraphQLFieldDefinition getFieldDefinition(String name) {
         return fieldDefinitionsByName.get(name);
     }
 
 
+    @Override
     public List<GraphQLFieldDefinition> getFieldDefinitions() {
         return new ArrayList<>(fieldDefinitionsByName.values());
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLList.java
Patch:
@@ -36,6 +36,7 @@ public GraphQLList(GraphQLType wrappedType) {
     }
 
 
+    @Override
     public GraphQLType getWrappedType() {
         return wrappedType;
     }

File: src/main/java/graphql/schema/GraphQLNonNull.java
Patch:
@@ -35,6 +35,7 @@ public GraphQLNonNull(GraphQLType wrappedType) {
         this.wrappedType = wrappedType;
     }
 
+    @Override
     public GraphQLType getWrappedType() {
         return wrappedType;
     }

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -80,10 +80,12 @@ public List<GraphQLDirective> getDirectives() {
         return new ArrayList<>(directives);
     }
 
+    @Override
     public GraphQLFieldDefinition getFieldDefinition(String name) {
         return fieldDefinitionsByName.get(name);
     }
 
+    @Override
     public List<GraphQLFieldDefinition> getFieldDefinitions() {
         return new ArrayList<>(fieldDefinitionsByName.values());
     }
@@ -103,6 +105,7 @@ public String getDescription() {
     }
 
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLScalarType.java
Patch:
@@ -58,6 +58,7 @@ public GraphQLScalarType(String name, String description, Coercing coercing, Lis
         this.directives = directives;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLTypeReference.java
Patch:
@@ -29,6 +29,7 @@ public GraphQLTypeReference(String name) {
         this.name = name;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/util/TraverserState.java
Patch:
@@ -32,6 +32,7 @@ private StackTraverserState(Object initialData) {
             super(initialData);
         }
 
+        @Override
         public void pushAll(TraverserContext<U> o, Function<? super U, ? extends List<U>> getChildren) {
             super.state.push(o);
             super.state.push(Marker.END_LIST);
@@ -45,6 +46,7 @@ private QueueTraverserState(Object initialData) {
             super(initialData);
         }
 
+        @Override
         public void pushAll(TraverserContext<U> o, Function<? super U, ? extends List<U>> getChildren) {
             getChildren.apply(o.thisNode()).iterator().forEachRemaining((e) -> super.state.add(newContext(e, o)));
             super.state.add(Marker.END_LIST);

File: src/main/java/graphql/ExceptionWhileDataFetching.java
Patch:
@@ -68,7 +68,6 @@ public List<SourceLocation> getLocations() {
         return locations;
     }
 
-    @Override
     public List<Object> getPath() {
         return path;
     }

File: src/main/java/graphql/SerializationError.java
Patch:
@@ -47,7 +47,6 @@ public ErrorType getErrorType() {
         return ErrorType.DataFetchingException;
     }
 
-    @Override
     public List<Object> getPath() {
         return path;
     }

File: src/main/java/graphql/TypeMismatchError.java
Patch:
@@ -74,7 +74,6 @@ public ErrorType getErrorType() {
         return ErrorType.DataFetchingException;
     }
 
-    @Override
     public List<Object> getPath() {
         return path;
     }

File: src/main/java/graphql/UnresolvedTypeError.java
Patch:
@@ -53,7 +53,6 @@ public ErrorType getErrorType() {
         return ErrorType.DataFetchingException;
     }
 
-    @Override
     public List<Object> getPath() {
         return path;
     }

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationDeferredFieldParameters.java
Patch:
@@ -29,7 +29,6 @@ public InstrumentationDeferredFieldParameters(ExecutionContext executionContext,
      *
      * @return a new parameters object with the new state
      */
-    @Override
     public InstrumentationDeferredFieldParameters withNewState(InstrumentationState instrumentationState) {
         return new InstrumentationDeferredFieldParameters(
                 this.getExecutionContext(), this.executionStrategyParameters, this.getField(), this.getTypeInfo(), instrumentationState);

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationFieldFetchParameters.java
Patch:
@@ -33,7 +33,6 @@ private InstrumentationFieldFetchParameters(ExecutionContext getExecutionContext
      *
      * @return a new parameters object with the new state
      */
-    @Override
     public InstrumentationFieldFetchParameters withNewState(InstrumentationState instrumentationState) {
         return new InstrumentationFieldFetchParameters(
                 this.getExecutionContext(), this.getField(), this.getEnvironment(),

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationValidationParameters.java
Patch:
@@ -24,7 +24,6 @@ public InstrumentationValidationParameters(ExecutionInput executionInput, Docume
      *
      * @return a new parameters object with the new state
      */
-    @Override
     public InstrumentationValidationParameters withNewState(InstrumentationState instrumentationState) {
         return new InstrumentationValidationParameters(
                 this.getExecutionInput(), document, getSchema(), instrumentationState);

File: src/main/java/graphql/language/AbstractNode.java
Patch:
@@ -22,7 +22,6 @@ public SourceLocation getSourceLocation() {
         return sourceLocation;
     }
 
-    @Override
     public List<Comment> getComments() {
         return comments;
     }

File: src/main/java/graphql/language/Argument.java
Patch:
@@ -17,7 +17,6 @@ public Argument(String name, Value value) {
         this.value = value;
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/Definition.java
Patch:
@@ -6,6 +6,5 @@ public interface Definition<T extends Definition> extends Node<T> {
     /**
      * @return a deep copy of this definition
      */
-    @Override
     T deepCopy();
 }

File: src/main/java/graphql/language/Directive.java
Patch:
@@ -37,7 +37,6 @@ public Argument getArgument(String argumentName) {
         return getArgumentsByName().get(argumentName);
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/DirectiveDefinition.java
Patch:
@@ -23,7 +23,6 @@ public DirectiveDefinition(String name, List<InputValueDefinition> inputValueDef
         this.directiveLocations = directiveLocations;
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/DirectiveLocation.java
Patch:
@@ -22,7 +22,6 @@ public DirectiveLocation(String name) {
         this.name = name;
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/EnumTypeDefinition.java
Patch:
@@ -30,7 +30,6 @@ public List<EnumValueDefinition> getEnumValueDefinitions() {
         return enumValueDefinitions;
     }
 
-    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/EnumTypeExtensionDefinition.java
Patch:
@@ -15,7 +15,6 @@ public EnumTypeExtensionDefinition(String name, List<EnumValueDefinition> enumVa
         super(name, enumValueDefinitions, directives);
     }
 
-    @Override
     public EnumTypeExtensionDefinition deepCopy() {
         return new EnumTypeExtensionDefinition(getName(),
                 deepCopy(getEnumValueDefinitions()),

File: src/main/java/graphql/language/EnumValue.java
Patch:
@@ -15,7 +15,6 @@ public EnumValue(String name) {
         this.name = name;
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/EnumValueDefinition.java
Patch:
@@ -21,7 +21,6 @@ public EnumValueDefinition(String name, List<Directive> directives) {
         this.directives = (null == directives) ? new ArrayList<>() : directives;
     }
 
-    @Override
     public String getName() {
         return name;
     }
@@ -34,7 +33,6 @@ public void setDescription(Description description) {
         this.description = description;
     }
 
-    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/Field.java
Patch:
@@ -64,7 +64,6 @@ public List<Node> getChildren() {
     }
 
 
-    @Override
     public String getName() {
         return name;
     }
@@ -89,7 +88,6 @@ public void setArguments(List<Argument> arguments) {
         this.arguments = arguments;
     }
 
-    @Override
     public List<Directive> getDirectives() {
         return directives;
     }
@@ -98,7 +96,6 @@ public void setDirectives(List<Directive> directives) {
         this.directives = directives;
     }
 
-    @Override
     public SelectionSet getSelectionSet() {
         return selectionSet;
     }

File: src/main/java/graphql/language/FieldDefinition.java
Patch:
@@ -37,7 +37,6 @@ public void setType(Type type) {
         this.type = type;
     }
 
-    @Override
     public String getName() {
         return name;
     }
@@ -54,7 +53,6 @@ public List<InputValueDefinition> getInputValueDefinitions() {
         return inputValueDefinitions;
     }
 
-    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/FragmentDefinition.java
Patch:
@@ -38,7 +38,6 @@ public FragmentDefinition(String name, TypeName typeCondition, List<Directive> d
         this.selectionSet = selectionSet;
     }
 
-    @Override
     public String getName() {
         return name;
     }
@@ -55,7 +54,6 @@ public void setTypeCondition(TypeName typeCondition) {
         this.typeCondition = typeCondition;
     }
 
-    @Override
     public List<Directive> getDirectives() {
         return directives;
     }
@@ -64,7 +62,6 @@ public void setDirectives(List<Directive> directives) {
         this.directives = directives;
     }
 
-    @Override
     public SelectionSet getSelectionSet() {
         return selectionSet;
     }

File: src/main/java/graphql/language/FragmentSpread.java
Patch:
@@ -24,7 +24,6 @@ public FragmentSpread(String name, List<Directive> directives) {
         this.directives = directives;
     }
 
-    @Override
     public String getName() {
         return name;
     }
@@ -33,7 +32,6 @@ public void setName(String name) {
         this.name = name;
     }
 
-    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/InlineFragment.java
Patch:
@@ -59,7 +59,6 @@ public void setDirectives(List<Directive> directives) {
         this.directives = directives;
     }
 
-    @Override
     public SelectionSet getSelectionSet() {
         return selectionSet;
     }

File: src/main/java/graphql/language/InputObjectTypeDefinition.java
Patch:
@@ -23,7 +23,6 @@ public InputObjectTypeDefinition(String name, List<Directive> directives, List<I
         this.inputValueDefinitions = inputValueDefinitions;
     }
 
-    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/InputValueDefinition.java
Patch:
@@ -41,7 +41,6 @@ public void setType(Type type) {
         this.type = type;
     }
 
-    @Override
     public String getName() {
         return name;
     }
@@ -62,7 +61,6 @@ public void setDefaultValue(Value defaultValue) {
         this.defaultValue = defaultValue;
     }
 
-    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/InterfaceTypeDefinition.java
Patch:
@@ -27,7 +27,6 @@ public List<FieldDefinition> getFieldDefinitions() {
         return definitions;
     }
 
-    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/InterfaceTypeExtensionDefinition.java
Patch:
@@ -12,7 +12,6 @@ public InterfaceTypeExtensionDefinition(String name, List<FieldDefinition> defin
         super(name, definitions, directives);
     }
 
-    @Override
     public InterfaceTypeExtensionDefinition deepCopy() {
         return new InterfaceTypeExtensionDefinition(getName(),
                 deepCopy(getFieldDefinitions()),

File: src/main/java/graphql/language/NodeTraverser.java
Patch:
@@ -45,13 +45,11 @@ private void doTraverse(NodeVisitor nodeVisitor, Collection<? extends Node> root
         nodeTraverser.rootVars(rootVars);
         TraverserVisitor<Node> traverserVisitor = new TraverserVisitor<Node>() {
 
-            @Override
             public TraversalControl enter(TraverserContext<Node> context) {
                 context.setVar(LeaveOrEnter.class, LeaveOrEnter.ENTER);
                 return context.thisNode().accept(context, nodeVisitor);
             }
 
-            @Override
             public TraversalControl leave(TraverserContext<Node> context) {
                 context.setVar(LeaveOrEnter.class, LeaveOrEnter.LEAVE);
                 return context.thisNode().accept(context, nodeVisitor);

File: src/main/java/graphql/language/ObjectField.java
Patch:
@@ -17,7 +17,6 @@ public ObjectField(String name, Value value) {
         this.value = value;
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/ObjectTypeDefinition.java
Patch:
@@ -29,7 +29,6 @@ public List<Type> getImplements() {
         return implementz;
     }
 
-    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/ObjectTypeExtensionDefinition.java
Patch:
@@ -16,7 +16,6 @@ public ObjectTypeExtensionDefinition(String name, List<Type> implementz, List<Di
         super(name, implementz, directives, fieldDefinitions);
     }
 
-    @Override
     public ObjectTypeExtensionDefinition deepCopy() {
         return new ObjectTypeExtensionDefinition(getName(),
                 deepCopy(getImplements()),

File: src/main/java/graphql/language/OperationDefinition.java
Patch:
@@ -86,7 +86,6 @@ public void setDirectives(List<Directive> directives) {
         this.directives = directives;
     }
 
-    @Override
     public SelectionSet getSelectionSet() {
         return selectionSet;
     }

File: src/main/java/graphql/language/OperationTypeDefinition.java
Patch:
@@ -34,7 +34,6 @@ public void setType(Type type) {
         this.type = type;
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/ScalarTypeDefinition.java
Patch:
@@ -21,7 +21,6 @@ public ScalarTypeDefinition(String name, List<Directive> directives) {
         this.directives = directives;
     }
 
-    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/ScalarTypeExtensionDefinition.java
Patch:
@@ -12,7 +12,6 @@ public ScalarTypeExtensionDefinition(String name, List<Directive> directives) {
         super(name, directives);
     }
 
-    @Override
     public ScalarTypeExtensionDefinition deepCopy() {
         return new ScalarTypeExtensionDefinition(getName(), deepCopy(getDirectives()));
     }

File: src/main/java/graphql/language/Type.java
Patch:
@@ -6,6 +6,5 @@ public interface Type<T extends Type> extends Node<T> {
     /**
      * @return a deep copy of this type
      */
-    @Override
     T deepCopy();
 }

File: src/main/java/graphql/language/TypeDefinition.java
Patch:
@@ -17,6 +17,5 @@ public interface TypeDefinition<T extends TypeDefinition> extends Definition<T>{
     /**
      * @return a deep copy of this type definition
      */
-    @Override
     T deepCopy();
 }

File: src/main/java/graphql/language/UnionTypeDefinition.java
Patch:
@@ -23,7 +23,6 @@ public UnionTypeDefinition(String name, List<Directive> directives, List<Type> m
         this.memberTypes = memberTypes;
     }
 
-    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/UnionTypeExtensionDefinition.java
Patch:
@@ -11,7 +11,6 @@ public UnionTypeExtensionDefinition(String name, List<Directive> directives, Lis
         super(name, directives, memberTypes);
     }
 
-    @Override
     public UnionTypeExtensionDefinition deepCopy() {
         return new UnionTypeExtensionDefinition(getName(),
                 deepCopy(getDirectives()),

File: src/main/java/graphql/language/Value.java
Patch:
@@ -6,6 +6,5 @@ public interface Value<T extends Value> extends Node<T> {
     /**
      * @return a deep copy of this value
      */
-    @Override
     T deepCopy();
 }

File: src/main/java/graphql/language/VariableDefinition.java
Patch:
@@ -35,7 +35,6 @@ public void setDefaultValue(Value defaultValue) {
         this.defaultValue = defaultValue;
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/VariableReference.java
Patch:
@@ -15,7 +15,6 @@ public VariableReference(String name) {
         this.name = name;
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/DataFetchingFieldSelectionSet.java
Patch:
@@ -39,7 +39,6 @@ public interface DataFetchingFieldSelectionSet extends Supplier<Map<String, List
     /**
      * @return a map of the fields that represent the selection set
      */
-    @Override
     Map<String, List<Field>> get();
 
     /**

File: src/main/java/graphql/schema/DataFetchingFieldSelectionSetImpl.java
Patch:
@@ -88,13 +88,11 @@ public Map<String, List<Field>> get() {
         return selectionSetFields;
     }
 
-    @Override
     public Map<String, Map<String, Object>> getArguments() {
         computeValuesLazily();
         return selectionSetFieldArgs;
     }
 
-    @Override
     public Map<String, GraphQLFieldDefinition> getDefinitions() {
         computeValuesLazily();
         return selectionSetFieldDefinitions;

File: src/main/java/graphql/schema/GraphQLArgument.java
Patch:
@@ -75,7 +75,6 @@ void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
         type = (GraphQLInputType) new SchemaUtil().resolveTypeReference(type, typeMap);
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -139,7 +139,6 @@ private Object getNameByValue(Object value) {
         throw new CoercingSerializeException("Invalid input for Enum '" + name + "'. Unknown value '" + value + "'");
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -69,7 +69,6 @@ void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
         this.type = (GraphQLOutputType) new SchemaUtil().resolveTypeReference(this.type, typeMap);
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -63,7 +63,6 @@ void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
         type = (GraphQLInputType) new SchemaUtil().resolveTypeReference(type, typeMap);
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLInputObjectType.java
Patch:
@@ -60,7 +60,6 @@ private void buildMap(List<GraphQLInputObjectField> fields) {
         }
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -68,18 +68,15 @@ private void buildDefinitionMap(List<GraphQLFieldDefinition> fieldDefinitions) {
         }
     }
 
-    @Override
     public GraphQLFieldDefinition getFieldDefinition(String name) {
         return fieldDefinitionsByName.get(name);
     }
 
 
-    @Override
     public List<GraphQLFieldDefinition> getFieldDefinitions() {
         return new ArrayList<>(fieldDefinitionsByName.values());
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLList.java
Patch:
@@ -36,7 +36,6 @@ public GraphQLList(GraphQLType wrappedType) {
     }
 
 
-    @Override
     public GraphQLType getWrappedType() {
         return wrappedType;
     }

File: src/main/java/graphql/schema/GraphQLNonNull.java
Patch:
@@ -35,7 +35,6 @@ public GraphQLNonNull(GraphQLType wrappedType) {
         this.wrappedType = wrappedType;
     }
 
-    @Override
     public GraphQLType getWrappedType() {
         return wrappedType;
     }

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -80,12 +80,10 @@ public List<GraphQLDirective> getDirectives() {
         return new ArrayList<>(directives);
     }
 
-    @Override
     public GraphQLFieldDefinition getFieldDefinition(String name) {
         return fieldDefinitionsByName.get(name);
     }
 
-    @Override
     public List<GraphQLFieldDefinition> getFieldDefinitions() {
         return new ArrayList<>(fieldDefinitionsByName.values());
     }
@@ -105,7 +103,6 @@ public String getDescription() {
     }
 
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLScalarType.java
Patch:
@@ -58,7 +58,6 @@ public GraphQLScalarType(String name, String description, Coercing coercing, Lis
         this.directives = directives;
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLTypeReference.java
Patch:
@@ -29,7 +29,6 @@ public GraphQLTypeReference(String name) {
         this.name = name;
     }
 
-    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/util/TraverserState.java
Patch:
@@ -32,7 +32,6 @@ private StackTraverserState(Object initialData) {
             super(initialData);
         }
 
-        @Override
         public void pushAll(TraverserContext<U> o, Function<? super U, ? extends List<U>> getChildren) {
             super.state.push(o);
             super.state.push(Marker.END_LIST);
@@ -46,7 +45,6 @@ private QueueTraverserState(Object initialData) {
             super(initialData);
         }
 
-        @Override
         public void pushAll(TraverserContext<U> o, Function<? super U, ? extends List<U>> getChildren) {
             getChildren.apply(o.thisNode()).iterator().forEachRemaining((e) -> super.state.add(newContext(e, o)));
             super.state.add(Marker.END_LIST);

File: src/main/java/graphql/ExceptionWhileDataFetching.java
Patch:
@@ -68,6 +68,7 @@ public List<SourceLocation> getLocations() {
         return locations;
     }
 
+    @Override
     public List<Object> getPath() {
         return path;
     }

File: src/main/java/graphql/SerializationError.java
Patch:
@@ -47,6 +47,7 @@ public ErrorType getErrorType() {
         return ErrorType.DataFetchingException;
     }
 
+    @Override
     public List<Object> getPath() {
         return path;
     }

File: src/main/java/graphql/TypeMismatchError.java
Patch:
@@ -74,6 +74,7 @@ public ErrorType getErrorType() {
         return ErrorType.DataFetchingException;
     }
 
+    @Override
     public List<Object> getPath() {
         return path;
     }

File: src/main/java/graphql/UnresolvedTypeError.java
Patch:
@@ -53,6 +53,7 @@ public ErrorType getErrorType() {
         return ErrorType.DataFetchingException;
     }
 
+    @Override
     public List<Object> getPath() {
         return path;
     }

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationDeferredFieldParameters.java
Patch:
@@ -29,6 +29,7 @@ public InstrumentationDeferredFieldParameters(ExecutionContext executionContext,
      *
      * @return a new parameters object with the new state
      */
+    @Override
     public InstrumentationDeferredFieldParameters withNewState(InstrumentationState instrumentationState) {
         return new InstrumentationDeferredFieldParameters(
                 this.getExecutionContext(), this.executionStrategyParameters, this.getField(), this.getTypeInfo(), instrumentationState);

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationFieldFetchParameters.java
Patch:
@@ -33,6 +33,7 @@ private InstrumentationFieldFetchParameters(ExecutionContext getExecutionContext
      *
      * @return a new parameters object with the new state
      */
+    @Override
     public InstrumentationFieldFetchParameters withNewState(InstrumentationState instrumentationState) {
         return new InstrumentationFieldFetchParameters(
                 this.getExecutionContext(), this.getField(), this.getEnvironment(),

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationValidationParameters.java
Patch:
@@ -24,6 +24,7 @@ public InstrumentationValidationParameters(ExecutionInput executionInput, Docume
      *
      * @return a new parameters object with the new state
      */
+    @Override
     public InstrumentationValidationParameters withNewState(InstrumentationState instrumentationState) {
         return new InstrumentationValidationParameters(
                 this.getExecutionInput(), document, getSchema(), instrumentationState);

File: src/main/java/graphql/language/AbstractNode.java
Patch:
@@ -22,6 +22,7 @@ public SourceLocation getSourceLocation() {
         return sourceLocation;
     }
 
+    @Override
     public List<Comment> getComments() {
         return comments;
     }

File: src/main/java/graphql/language/Argument.java
Patch:
@@ -17,6 +17,7 @@ public Argument(String name, Value value) {
         this.value = value;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/Definition.java
Patch:
@@ -6,5 +6,6 @@ public interface Definition<T extends Definition> extends Node<T> {
     /**
      * @return a deep copy of this definition
      */
+    @Override
     T deepCopy();
 }

File: src/main/java/graphql/language/Directive.java
Patch:
@@ -37,6 +37,7 @@ public Argument getArgument(String argumentName) {
         return getArgumentsByName().get(argumentName);
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/DirectiveDefinition.java
Patch:
@@ -23,6 +23,7 @@ public DirectiveDefinition(String name, List<InputValueDefinition> inputValueDef
         this.directiveLocations = directiveLocations;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/DirectiveLocation.java
Patch:
@@ -22,6 +22,7 @@ public DirectiveLocation(String name) {
         this.name = name;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/EnumTypeDefinition.java
Patch:
@@ -30,6 +30,7 @@ public List<EnumValueDefinition> getEnumValueDefinitions() {
         return enumValueDefinitions;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/EnumTypeExtensionDefinition.java
Patch:
@@ -15,6 +15,7 @@ public EnumTypeExtensionDefinition(String name, List<EnumValueDefinition> enumVa
         super(name, enumValueDefinitions, directives);
     }
 
+    @Override
     public EnumTypeExtensionDefinition deepCopy() {
         return new EnumTypeExtensionDefinition(getName(),
                 deepCopy(getEnumValueDefinitions()),

File: src/main/java/graphql/language/EnumValue.java
Patch:
@@ -15,6 +15,7 @@ public EnumValue(String name) {
         this.name = name;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/EnumValueDefinition.java
Patch:
@@ -21,6 +21,7 @@ public EnumValueDefinition(String name, List<Directive> directives) {
         this.directives = (null == directives) ? new ArrayList<>() : directives;
     }
 
+    @Override
     public String getName() {
         return name;
     }
@@ -33,6 +34,7 @@ public void setDescription(Description description) {
         this.description = description;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/Field.java
Patch:
@@ -64,6 +64,7 @@ public List<Node> getChildren() {
     }
 
 
+    @Override
     public String getName() {
         return name;
     }
@@ -88,6 +89,7 @@ public void setArguments(List<Argument> arguments) {
         this.arguments = arguments;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }
@@ -96,6 +98,7 @@ public void setDirectives(List<Directive> directives) {
         this.directives = directives;
     }
 
+    @Override
     public SelectionSet getSelectionSet() {
         return selectionSet;
     }

File: src/main/java/graphql/language/FieldDefinition.java
Patch:
@@ -37,6 +37,7 @@ public void setType(Type type) {
         this.type = type;
     }
 
+    @Override
     public String getName() {
         return name;
     }
@@ -53,6 +54,7 @@ public List<InputValueDefinition> getInputValueDefinitions() {
         return inputValueDefinitions;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/FragmentDefinition.java
Patch:
@@ -38,6 +38,7 @@ public FragmentDefinition(String name, TypeName typeCondition, List<Directive> d
         this.selectionSet = selectionSet;
     }
 
+    @Override
     public String getName() {
         return name;
     }
@@ -54,6 +55,7 @@ public void setTypeCondition(TypeName typeCondition) {
         this.typeCondition = typeCondition;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }
@@ -62,6 +64,7 @@ public void setDirectives(List<Directive> directives) {
         this.directives = directives;
     }
 
+    @Override
     public SelectionSet getSelectionSet() {
         return selectionSet;
     }

File: src/main/java/graphql/language/FragmentSpread.java
Patch:
@@ -24,6 +24,7 @@ public FragmentSpread(String name, List<Directive> directives) {
         this.directives = directives;
     }
 
+    @Override
     public String getName() {
         return name;
     }
@@ -32,6 +33,7 @@ public void setName(String name) {
         this.name = name;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/InlineFragment.java
Patch:
@@ -59,6 +59,7 @@ public void setDirectives(List<Directive> directives) {
         this.directives = directives;
     }
 
+    @Override
     public SelectionSet getSelectionSet() {
         return selectionSet;
     }

File: src/main/java/graphql/language/InputObjectTypeDefinition.java
Patch:
@@ -23,6 +23,7 @@ public InputObjectTypeDefinition(String name, List<Directive> directives, List<I
         this.inputValueDefinitions = inputValueDefinitions;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/InputValueDefinition.java
Patch:
@@ -41,6 +41,7 @@ public void setType(Type type) {
         this.type = type;
     }
 
+    @Override
     public String getName() {
         return name;
     }
@@ -61,6 +62,7 @@ public void setDefaultValue(Value defaultValue) {
         this.defaultValue = defaultValue;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/InterfaceTypeDefinition.java
Patch:
@@ -27,6 +27,7 @@ public List<FieldDefinition> getFieldDefinitions() {
         return definitions;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/InterfaceTypeExtensionDefinition.java
Patch:
@@ -12,6 +12,7 @@ public InterfaceTypeExtensionDefinition(String name, List<FieldDefinition> defin
         super(name, definitions, directives);
     }
 
+    @Override
     public InterfaceTypeExtensionDefinition deepCopy() {
         return new InterfaceTypeExtensionDefinition(getName(),
                 deepCopy(getFieldDefinitions()),

File: src/main/java/graphql/language/NodeTraverser.java
Patch:
@@ -45,11 +45,13 @@ private void doTraverse(NodeVisitor nodeVisitor, Collection<? extends Node> root
         nodeTraverser.rootVars(rootVars);
         TraverserVisitor<Node> traverserVisitor = new TraverserVisitor<Node>() {
 
+            @Override
             public TraversalControl enter(TraverserContext<Node> context) {
                 context.setVar(LeaveOrEnter.class, LeaveOrEnter.ENTER);
                 return context.thisNode().accept(context, nodeVisitor);
             }
 
+            @Override
             public TraversalControl leave(TraverserContext<Node> context) {
                 context.setVar(LeaveOrEnter.class, LeaveOrEnter.LEAVE);
                 return context.thisNode().accept(context, nodeVisitor);

File: src/main/java/graphql/language/ObjectField.java
Patch:
@@ -17,6 +17,7 @@ public ObjectField(String name, Value value) {
         this.value = value;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/ObjectTypeDefinition.java
Patch:
@@ -29,6 +29,7 @@ public List<Type> getImplements() {
         return implementz;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/ObjectTypeExtensionDefinition.java
Patch:
@@ -16,6 +16,7 @@ public ObjectTypeExtensionDefinition(String name, List<Type> implementz, List<Di
         super(name, implementz, directives, fieldDefinitions);
     }
 
+    @Override
     public ObjectTypeExtensionDefinition deepCopy() {
         return new ObjectTypeExtensionDefinition(getName(),
                 deepCopy(getImplements()),

File: src/main/java/graphql/language/OperationDefinition.java
Patch:
@@ -86,6 +86,7 @@ public void setDirectives(List<Directive> directives) {
         this.directives = directives;
     }
 
+    @Override
     public SelectionSet getSelectionSet() {
         return selectionSet;
     }

File: src/main/java/graphql/language/OperationTypeDefinition.java
Patch:
@@ -34,6 +34,7 @@ public void setType(Type type) {
         this.type = type;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/ScalarTypeDefinition.java
Patch:
@@ -21,6 +21,7 @@ public ScalarTypeDefinition(String name, List<Directive> directives) {
         this.directives = directives;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/ScalarTypeExtensionDefinition.java
Patch:
@@ -12,6 +12,7 @@ public ScalarTypeExtensionDefinition(String name, List<Directive> directives) {
         super(name, directives);
     }
 
+    @Override
     public ScalarTypeExtensionDefinition deepCopy() {
         return new ScalarTypeExtensionDefinition(getName(), deepCopy(getDirectives()));
     }

File: src/main/java/graphql/language/Type.java
Patch:
@@ -6,5 +6,6 @@ public interface Type<T extends Type> extends Node<T> {
     /**
      * @return a deep copy of this type
      */
+    @Override
     T deepCopy();
 }

File: src/main/java/graphql/language/TypeDefinition.java
Patch:
@@ -17,5 +17,6 @@ public interface TypeDefinition<T extends TypeDefinition> extends Definition<T>{
     /**
      * @return a deep copy of this type definition
      */
+    @Override
     T deepCopy();
 }

File: src/main/java/graphql/language/UnionTypeDefinition.java
Patch:
@@ -23,6 +23,7 @@ public UnionTypeDefinition(String name, List<Directive> directives, List<Type> m
         this.memberTypes = memberTypes;
     }
 
+    @Override
     public List<Directive> getDirectives() {
         return directives;
     }

File: src/main/java/graphql/language/UnionTypeExtensionDefinition.java
Patch:
@@ -11,6 +11,7 @@ public UnionTypeExtensionDefinition(String name, List<Directive> directives, Lis
         super(name, directives, memberTypes);
     }
 
+    @Override
     public UnionTypeExtensionDefinition deepCopy() {
         return new UnionTypeExtensionDefinition(getName(),
                 deepCopy(getDirectives()),

File: src/main/java/graphql/language/Value.java
Patch:
@@ -6,5 +6,6 @@ public interface Value<T extends Value> extends Node<T> {
     /**
      * @return a deep copy of this value
      */
+    @Override
     T deepCopy();
 }

File: src/main/java/graphql/language/VariableDefinition.java
Patch:
@@ -35,6 +35,7 @@ public void setDefaultValue(Value defaultValue) {
         this.defaultValue = defaultValue;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/language/VariableReference.java
Patch:
@@ -15,6 +15,7 @@ public VariableReference(String name) {
         this.name = name;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/DataFetchingFieldSelectionSet.java
Patch:
@@ -39,6 +39,7 @@ public interface DataFetchingFieldSelectionSet extends Supplier<Map<String, List
     /**
      * @return a map of the fields that represent the selection set
      */
+    @Override
     Map<String, List<Field>> get();
 
     /**

File: src/main/java/graphql/schema/DataFetchingFieldSelectionSetImpl.java
Patch:
@@ -88,11 +88,13 @@ public Map<String, List<Field>> get() {
         return selectionSetFields;
     }
 
+    @Override
     public Map<String, Map<String, Object>> getArguments() {
         computeValuesLazily();
         return selectionSetFieldArgs;
     }
 
+    @Override
     public Map<String, GraphQLFieldDefinition> getDefinitions() {
         computeValuesLazily();
         return selectionSetFieldDefinitions;

File: src/main/java/graphql/schema/GraphQLArgument.java
Patch:
@@ -75,6 +75,7 @@ void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
         type = (GraphQLInputType) new SchemaUtil().resolveTypeReference(type, typeMap);
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -139,6 +139,7 @@ private Object getNameByValue(Object value) {
         throw new CoercingSerializeException("Invalid input for Enum '" + name + "'. Unknown value '" + value + "'");
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -69,6 +69,7 @@ void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
         this.type = (GraphQLOutputType) new SchemaUtil().resolveTypeReference(this.type, typeMap);
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -63,6 +63,7 @@ void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
         type = (GraphQLInputType) new SchemaUtil().resolveTypeReference(type, typeMap);
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLInputObjectType.java
Patch:
@@ -60,6 +60,7 @@ private void buildMap(List<GraphQLInputObjectField> fields) {
         }
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -68,15 +68,18 @@ private void buildDefinitionMap(List<GraphQLFieldDefinition> fieldDefinitions) {
         }
     }
 
+    @Override
     public GraphQLFieldDefinition getFieldDefinition(String name) {
         return fieldDefinitionsByName.get(name);
     }
 
 
+    @Override
     public List<GraphQLFieldDefinition> getFieldDefinitions() {
         return new ArrayList<>(fieldDefinitionsByName.values());
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLList.java
Patch:
@@ -36,6 +36,7 @@ public GraphQLList(GraphQLType wrappedType) {
     }
 
 
+    @Override
     public GraphQLType getWrappedType() {
         return wrappedType;
     }

File: src/main/java/graphql/schema/GraphQLNonNull.java
Patch:
@@ -35,6 +35,7 @@ public GraphQLNonNull(GraphQLType wrappedType) {
         this.wrappedType = wrappedType;
     }
 
+    @Override
     public GraphQLType getWrappedType() {
         return wrappedType;
     }

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -80,10 +80,12 @@ public List<GraphQLDirective> getDirectives() {
         return new ArrayList<>(directives);
     }
 
+    @Override
     public GraphQLFieldDefinition getFieldDefinition(String name) {
         return fieldDefinitionsByName.get(name);
     }
 
+    @Override
     public List<GraphQLFieldDefinition> getFieldDefinitions() {
         return new ArrayList<>(fieldDefinitionsByName.values());
     }
@@ -103,6 +105,7 @@ public String getDescription() {
     }
 
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLScalarType.java
Patch:
@@ -58,6 +58,7 @@ public GraphQLScalarType(String name, String description, Coercing coercing, Lis
         this.directives = directives;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLTypeReference.java
Patch:
@@ -29,6 +29,7 @@ public GraphQLTypeReference(String name) {
         this.name = name;
     }
 
+    @Override
     public String getName() {
         return name;
     }

File: src/main/java/graphql/util/TraverserState.java
Patch:
@@ -32,6 +32,7 @@ private StackTraverserState(Object initialData) {
             super(initialData);
         }
 
+        @Override
         public void pushAll(TraverserContext<U> o, Function<? super U, ? extends List<U>> getChildren) {
             super.state.push(o);
             super.state.push(Marker.END_LIST);
@@ -45,6 +46,7 @@ private QueueTraverserState(Object initialData) {
             super(initialData);
         }
 
+        @Override
         public void pushAll(TraverserContext<U> o, Function<? super U, ? extends List<U>> getChildren) {
             getChildren.apply(o.thisNode()).iterator().forEachRemaining((e) -> super.state.add(newContext(e, o)));
             super.state.add(Marker.END_LIST);

File: src/main/java/graphql/analysis/QueryTraversal.java
Patch:
@@ -22,7 +22,6 @@
 import graphql.schema.GraphQLObjectType;
 import graphql.schema.GraphQLSchema;
 import graphql.schema.GraphQLUnmodifiedType;
-import graphql.schema.SchemaUtil;
 import graphql.util.TraversalControl;
 import graphql.util.TraverserContext;
 
@@ -35,6 +34,7 @@
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertShouldNeverHappen;
 import static graphql.language.NodeTraverser.LeaveOrEnter.LEAVE;
+import static graphql.schema.GraphQLTypeUtil.unwrapAll;
 
 /**
  * Helps to traverse (or reduce) a Document (or parts of it) and tracks at the same time the corresponding Schema types.
@@ -55,7 +55,6 @@ public class QueryTraversal {
 
     private final ConditionalNodes conditionalNodes = new ConditionalNodes();
     private final ValuesResolver valuesResolver = new ValuesResolver();
-    private final SchemaUtil schemaUtil = new SchemaUtil();
     private final ChildrenOfSelectionProvider childrenOfSelectionProvider;
     private final GraphQLObjectType rootParentType;
 
@@ -268,7 +267,7 @@ public TraversalControl visitField(Field field, TraverserContext<Node> context)
 
             preOrderCallback.visitField(environment);
 
-            GraphQLUnmodifiedType unmodifiedType = schemaUtil.getUnmodifiedType(fieldDefinition.getType());
+            GraphQLUnmodifiedType unmodifiedType = unwrapAll(fieldDefinition.getType());
             QueryTraversalContext fieldEnv = (unmodifiedType instanceof GraphQLCompositeType)
                     ? new QueryTraversalContext((GraphQLCompositeType) unmodifiedType, environment, field)
                     : new QueryTraversalContext(null, environment, field);// Terminal (scalar) node, EMPTY FRAME

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -54,6 +54,7 @@
 import static graphql.execution.FieldValueInfo.CompleteValueType.OBJECT;
 import static graphql.execution.FieldValueInfo.CompleteValueType.SCALAR;
 import static graphql.schema.DataFetchingEnvironmentBuilder.newDataFetchingEnvironment;
+import static graphql.schema.GraphQLTypeUtil.isList;
 import static java.util.concurrent.CompletableFuture.completedFuture;
 
 /**
@@ -166,7 +167,7 @@ protected ExecutionStrategy(DataFetcherExceptionHandler dataFetcherExceptionHand
      * @throws NonNullableFieldWasNullException in the future if a non null field resolves to a null value
      */
     protected CompletableFuture<ExecutionResult> resolveField(ExecutionContext executionContext, ExecutionStrategyParameters parameters) {
-        return resolveFieldWithInfo(executionContext,parameters).thenCompose(FieldValueInfo::getFieldValue);
+        return resolveFieldWithInfo(executionContext, parameters).thenCompose(FieldValueInfo::getFieldValue);
     }
 
     /**
@@ -391,7 +392,7 @@ protected FieldValueInfo completeValue(ExecutionContext executionContext, Execut
         if (result == null) {
             fieldValue = completeValueForNull(parameters);
             return FieldValueInfo.newFieldValueInfo(NULL).fieldValue(fieldValue).build();
-        } else if (fieldType instanceof GraphQLList) {
+        } else if (isList(fieldType)) {
             return completeValueForList(executionContext, parameters, result);
         } else if (fieldType instanceof GraphQLScalarType) {
             fieldValue = completeValueForScalar(executionContext, parameters, (GraphQLScalarType) fieldType, result);

File: src/main/java/graphql/relay/Relay.java
Patch:
@@ -7,8 +7,6 @@
 import graphql.schema.GraphQLInputObjectField;
 import graphql.schema.GraphQLInputObjectType;
 import graphql.schema.GraphQLInterfaceType;
-import graphql.schema.GraphQLList;
-import graphql.schema.GraphQLNonNull;
 import graphql.schema.GraphQLObjectType;
 import graphql.schema.GraphQLOutputType;
 import graphql.schema.TypeResolver;
@@ -26,7 +24,7 @@
 import static graphql.schema.GraphQLInputObjectField.newInputObjectField;
 import static graphql.schema.GraphQLInputObjectType.newInputObject;
 import static graphql.schema.GraphQLInterfaceType.newInterface;
-import static graphql.schema.GraphQLList.*;
+import static graphql.schema.GraphQLList.list;
 import static graphql.schema.GraphQLNonNull.nonNull;
 import static graphql.schema.GraphQLObjectType.newObject;
 

File: src/main/java/graphql/validation/rules/VariableDefaultValuesOfCorrectType.java
Patch:
@@ -2,12 +2,13 @@
 
 import graphql.language.VariableDefinition;
 import graphql.schema.GraphQLInputType;
-import graphql.schema.GraphQLNonNull;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
+import static graphql.schema.GraphQLTypeUtil.isNonNull;
+
 
 public class VariableDefaultValuesOfCorrectType extends AbstractRule {
 
@@ -21,7 +22,7 @@ public VariableDefaultValuesOfCorrectType(ValidationContext validationContext, V
     public void checkVariableDefinition(VariableDefinition variableDefinition) {
         GraphQLInputType inputType = getValidationContext().getInputType();
         if (inputType == null) return;
-        if (inputType instanceof GraphQLNonNull && variableDefinition.getDefaultValue() != null) {
+        if (isNonNull(inputType) && variableDefinition.getDefaultValue() != null) {
             String message = "Missing value for non null type";
             addError(ValidationErrorType.DefaultForNonNullArgument, variableDefinition.getSourceLocation(), message);
         }

File: src/main/java/graphql/Scalars.java
Patch:
@@ -191,7 +191,7 @@ public String parseValue(Object input) {
         public String parseLiteral(Object input) {
             if (!(input instanceof StringValue)) {
                 throw new CoercingParseLiteralException(
-                        "Expected AST type 'IntValue' but was '" + typeName(input) + "'."
+                        "Expected AST type 'StringValue' but was '" + typeName(input) + "'."
                 );
             }
             return ((StringValue) input).getValue();

File: src/test/groovy/graphql/validation/SpecValidationSchema.java
Patch:
@@ -152,6 +152,7 @@ public GraphQLObjectType getType(TypeResolutionEnvironment env) {
     public static final GraphQLObjectType queryRoot = GraphQLObjectType.newObject()
             .name("QueryRoot")
             .field(newFieldDefinition().name("dog").type(dog))
+            .field(newFieldDefinition().name("pet").type(pet))
             .build();
 
     @SuppressWarnings("serial")

File: src/main/java/graphql/execution/SubscriptionExecutionStrategy.java
Patch:
@@ -98,7 +98,7 @@ private CompletableFuture<ExecutionResult> executeSubscriptionEvent(ExecutionCon
 
         ExecutionStrategyParameters newParameters = firstFieldOfSubscriptionSelection(parameters);
 
-        return completeField(newExecutionContext, newParameters, eventPayload)
+        return completeField(newExecutionContext, newParameters, eventPayload).getFieldValue()
                 .thenApply(executionResult -> wrapWithRootFieldName(newParameters, executionResult));
     }
 

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -254,7 +254,7 @@ private CompletableFuture<FetchedValues> fetchData(ExecutionContext executionCon
 
         Instrumentation instrumentation = executionContext.getInstrumentation();
         InstrumentationFieldFetchParameters instrumentationFieldFetchParameters =
-                new InstrumentationFieldFetchParameters(executionContext, fieldDef, environment);
+                new InstrumentationFieldFetchParameters(executionContext, fieldDef, environment, parameters);
         InstrumentationContext<Object> fetchCtx = instrumentation.beginFieldFetch(instrumentationFieldFetchParameters);
 
         CompletableFuture<Object> fetchedValue;

File: src/main/java/graphql/execution/instrumentation/dataloader/DataLoaderDispatcherInstrumentationOptions.java
Patch:
@@ -27,7 +27,9 @@ public DataLoaderDispatcherInstrumentationOptions includeStatistics(boolean flag
         return new DataLoaderDispatcherInstrumentationOptions(flag);
     }
 
+
     public boolean isIncludeStatistics() {
         return includeStatistics;
     }
+
 }

File: src/test/groovy/graphql/execution/BreadthFirstExecutionTestStrategy.java
Patch:
@@ -64,7 +64,7 @@ private Object fetchField(ExecutionContext executionContext, ExecutionStrategyPa
     }
 
     private void completeValue(ExecutionContext executionContext, Map<String, Object> results, String fieldName, Object fetchedValue, ExecutionStrategyParameters newParameters) {
-        ExecutionResult resolvedResult = completeField(executionContext, newParameters, fetchedValue).join();
+        ExecutionResult resolvedResult = completeField(executionContext, newParameters, fetchedValue).getFieldValue().join();
         results.put(fieldName, resolvedResult != null ? resolvedResult.getData() : null);
     }
 

File: src/test/groovy/graphql/execution/BreadthFirstTestStrategy.java
Patch:
@@ -66,7 +66,7 @@ private CompletableFuture<ExecutionResult> completeFields(ExecutionContext execu
 
             Object fetchedValue = fetchedValues.get(fieldName);
             try {
-                ExecutionResult resolvedResult = completeField(executionContext, newParameters, fetchedValue).join();
+                ExecutionResult resolvedResult = completeField(executionContext, newParameters, fetchedValue).getFieldValue().join();
                 results.put(fieldName, resolvedResult != null ? resolvedResult.getData() : null);
             } catch (NonNullableFieldWasNullException e) {
                 assertNonNullFieldPrecondition(e);

File: src/test/groovy/graphql/execution/instrumentation/dataloader/BatchCompare.java
Patch:
@@ -78,12 +78,15 @@ GraphQLSchema buildDataLoaderSchema() {
         RuntimeWiring runtimeWiring = RuntimeWiring.newRuntimeWiring()
                 .type(TypeRuntimeWiring.newTypeWiring("Query")
                         .dataFetcher("shops", BatchCompareDataFetchers.shopsDataFetcher)
+                        .dataFetcher("expensiveShops", BatchCompareDataFetchers.expensiveShopsDataFetcher)
                 )
                 .type(TypeRuntimeWiring.newTypeWiring("Shop")
                         .dataFetcher("departments", BatchCompareDataFetchers.departmentsForShopDataLoaderDataFetcher)
+                        .dataFetcher("expensiveDepartments", BatchCompareDataFetchers.departmentsForShopDataLoaderDataFetcher)
                 )
                 .type(TypeRuntimeWiring.newTypeWiring("Department")
                         .dataFetcher("products", BatchCompareDataFetchers.productsForDepartmentDataLoaderDataFetcher)
+                        .dataFetcher("expensiveProducts", BatchCompareDataFetchers.productsForDepartmentDataLoaderDataFetcher)
                 )
                 .build();
 

File: src/test/groovy/graphql/execution/instrumentation/dataloader/models/Company.java
Patch:
@@ -1,4 +1,4 @@
-package graphql.execution.instrumentation.dataloader;
+package graphql.execution.instrumentation.dataloader.models;
 
 public class Company {
 

File: src/test/groovy/graphql/execution/instrumentation/dataloader/models/Department.java
Patch:
@@ -1,4 +1,4 @@
-package graphql.execution.instrumentation.dataloader;
+package graphql.execution.instrumentation.dataloader.models;
 
 import java.util.List;
 

File: src/test/groovy/graphql/execution/instrumentation/dataloader/models/Person.java
Patch:
@@ -1,4 +1,4 @@
-package graphql.execution.instrumentation.dataloader;
+package graphql.execution.instrumentation.dataloader.models;
 
 public class Person {
 

File: src/test/groovy/graphql/execution/instrumentation/dataloader/models/Product.java
Patch:
@@ -1,4 +1,4 @@
-package graphql.execution.instrumentation.dataloader;
+package graphql.execution.instrumentation.dataloader.models;
 
 import java.util.ArrayList;
 import java.util.Collections;

File: src/test/groovy/graphql/execution/instrumentation/dataloader/models/Shop.java
Patch:
@@ -1,4 +1,4 @@
-package graphql.execution.instrumentation.dataloader;
+package graphql.execution.instrumentation.dataloader.models;
 
 import java.util.List;
 

File: src/main/java/graphql/analysis/QueryVisitor.java
Patch:
@@ -3,8 +3,8 @@
 import graphql.PublicApi;
 
 /**
- * User by {@link QueryTraversal} to visit the nodes of a Query.
- * <p/>
+ * Used by {@link QueryTraversal} to visit the nodes of a Query.
+ * <p>
  * How this happens in detail (pre vs post-order for example) is defined by {@link QueryTraversal}.
  */
 @PublicApi

File: src/main/java/graphql/execution/AsyncExecutionStrategy.java
Patch:
@@ -46,6 +46,7 @@ public CompletableFuture<ExecutionResult> execute(ExecutionContext executionCont
         Map<String, List<Field>> fields = parameters.getFields();
         List<String> fieldNames = new ArrayList<>(fields.keySet());
         List<CompletableFuture<ExecutionResult>> futures = new ArrayList<>();
+        List<String> resolvedFields = new ArrayList<>();
         for (String fieldName : fieldNames) {
             List<Field> currentField = fields.get(fieldName);
 
@@ -56,14 +57,15 @@ public CompletableFuture<ExecutionResult> execute(ExecutionContext executionCont
             if (isDeferred(executionContext, newParameters, currentField)) {
                 continue;
             }
+            resolvedFields.add(fieldName);
             CompletableFuture<ExecutionResult> future = resolveField(executionContext, newParameters);
             futures.add(future);
         }
 
         CompletableFuture<ExecutionResult> overallResult = new CompletableFuture<>();
         executionStrategyCtx.onDispatched(overallResult);
 
-        Async.each(futures).whenComplete(handleResults(executionContext, fieldNames, overallResult));
+        Async.each(futures).whenComplete(handleResults(executionContext, resolvedFields, overallResult));
 
         overallResult.whenComplete(executionStrategyCtx::onCompleted);
         return overallResult;

File: src/main/java/graphql/schema/GraphQLArgument.java
Patch:
@@ -155,6 +155,7 @@ public Builder() {
         public Builder(GraphQLArgument existing) {
             this.name = existing.getName();
             this.type = existing.getType();
+            this.value = existing.getValue();
             this.defaultValue = existing.getDefaultValue();
             this.description = existing.getDescription();
             this.definition = existing.getDefinition();

File: src/main/java/graphql/schema/GraphQLEnumValueDefinition.java
Patch:
@@ -25,7 +25,7 @@
  * @see graphql.schema.GraphQLEnumType
  */
 @PublicApi
-public class GraphQLEnumValueDefinition {
+public class GraphQLEnumValueDefinition implements GraphQLDirectiveContainer {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -829,7 +829,9 @@ private Description newDescription(GraphqlParser.DescriptionContext descriptionC
 
 
     private SourceLocation getSourceLocation(ParserRuleContext parserRuleContext) {
-        return new SourceLocation(parserRuleContext.getStart().getLine(), parserRuleContext.getStart().getCharPositionInLine() + 1);
+        Token startToken = parserRuleContext.getStart();
+        String sourceName = startToken.getTokenSource().getSourceName();
+        return new SourceLocation(startToken.getLine(), startToken.getCharPositionInLine() + 1, sourceName);
     }
 
     private List<Comment> getComments(ParserRuleContext ctx) {

File: src/main/java/graphql/DirectivesUtil.java
Patch:
@@ -27,7 +27,7 @@ public static Optional<GraphQLArgument> directiveWithArg(List<GraphQLDirective>
     public static String atFetchFromSupport(String fieldName, List<GraphQLDirective> directives) {
         // @fetch(from : "name")
         Optional<GraphQLArgument> from = directiveWithArg(directives, Directives.FetchDirective.getName(), "from");
-        return from.map(arg -> String.valueOf(arg.getDefaultValue())).orElse(fieldName);
+        return from.map(arg -> String.valueOf(arg.getValue())).orElse(fieldName);
     }
 
 }

File: src/main/java/graphql/validation/TraversalContext.java
Patch:
@@ -142,7 +142,7 @@ private void enterImpl(FragmentDefinition fragmentDefinition) {
 
     private void enterImpl(VariableDefinition variableDefinition) {
         GraphQLType type = TypeFromAST.getTypeFromAST(schema, variableDefinition.getType());
-        addInputType(type != null ? (GraphQLInputType) type : null);
+        addInputType(type instanceof GraphQLInputType ? (GraphQLInputType) type : null);
     }
 
     private void enterImpl(Argument argument) {

File: src/test/groovy/graphql/execution/batched/FunWithStringsSchemaFactory.java
Patch:
@@ -26,6 +26,7 @@
 import static graphql.schema.GraphQLFieldDefinition.newFieldDefinition;
 import static graphql.schema.GraphQLInterfaceType.newInterface;
 import static graphql.schema.GraphQLObjectType.newObject;
+import static graphql.schema.GraphQLTypeReference.typeRef;
 
 public class FunWithStringsSchemaFactory {
 
@@ -389,6 +390,7 @@ GraphQLSchema createSchema() {
 
         GraphQLObjectType simpleObjectType = newObject()
                 .name("SimpleObject")
+                .withInterface(typeRef("InterfaceType"))
                 .field(newFieldDefinition()
                         .name("value")
                         .type(GraphQLString))
@@ -434,6 +436,7 @@ GraphQLSchema createSchema() {
 
         return GraphQLSchema.newSchema()
                 .query(queryType)
+                .additionalType(simpleObjectType)
                 .build();
 
     }

File: src/main/java/graphql/validation/rules/PossibleFragmentSpreads.java
Patch:
@@ -34,7 +34,7 @@ public void checkInlineFragment(InlineFragment inlineFragment) {
         if (fragType == null || parentType == null) return;
         if (!doTypesOverlap(fragType, parentType)) {
             String message = String.format("Fragment cannot be spread here as objects of " +
-                    "type %s can never be of type %s", parentType, fragType);
+                    "type %s can never be of type %s", parentType.getName(), fragType.getName());
             addError(ValidationErrorType.InvalidFragmentType, inlineFragment.getSourceLocation(), message);
 
         }
@@ -50,7 +50,7 @@ public void checkFragmentSpread(FragmentSpread fragmentSpread) {
 
         if (!doTypesOverlap(typeCondition, parentType)) {
             String message = String.format("Fragment %s cannot be spread here as objects of " +
-                    "type %s can never be of type %s", fragmentSpread.getName(), parentType, typeCondition);
+                    "type %s can never be of type %s", fragmentSpread.getName(), parentType.getName(), typeCondition.getName());
             addError(ValidationErrorType.InvalidFragmentType, fragmentSpread.getSourceLocation(), message);
         }
     }

File: src/main/java/graphql/schema/idl/SchemaGenerator.java
Patch:
@@ -307,7 +307,7 @@ private <T extends GraphQLOutputType> T buildOutputType(BuildContext buildCtx, T
             outputType = buildScalar(buildCtx, (ScalarTypeDefinition) typeDefinition);
         } else {
             // typeDefinition is not a valid output type
-            throw new NotAnOutputTypeError(typeDefinition);
+            throw new NotAnOutputTypeError(rawType, typeDefinition);
         }
 
         buildCtx.put(outputType);
@@ -340,7 +340,7 @@ private GraphQLInputType buildInputType(BuildContext buildCtx, Type rawType) {
             inputType = buildScalar(buildCtx, (ScalarTypeDefinition) typeDefinition);
         } else {
             // typeDefinition is not a valid InputType
-            throw new NotAnInputTypeError(typeDefinition);
+            throw new NotAnInputTypeError(rawType, typeDefinition);
         }
 
         buildCtx.put(inputType);

File: src/main/java/graphql/schema/idl/errors/NotAnInputTypeError.java
Patch:
@@ -1,12 +1,13 @@
 package graphql.schema.idl.errors;
 
+import graphql.language.Type;
 import graphql.language.TypeDefinition;
 
 import static java.lang.String.format;
 
 public class NotAnInputTypeError extends BaseError {
 
-    public NotAnInputTypeError(TypeDefinition typeDefinition) {
-        super(typeDefinition, format("expected InputType, but found %s type %s", typeDefinition.getName(), lineCol(typeDefinition)));
+    public NotAnInputTypeError(Type rawType, TypeDefinition typeDefinition) {
+        super(rawType, format("The type '%s' %s is not an input type, but was used as an input type %s", typeDefinition.getName(), lineCol(typeDefinition), lineCol(rawType)));
     }
 }

File: src/main/java/graphql/schema/idl/errors/NotAnOutputTypeError.java
Patch:
@@ -1,12 +1,13 @@
 package graphql.schema.idl.errors;
 
+import graphql.language.Type;
 import graphql.language.TypeDefinition;
 
 import static java.lang.String.format;
 
 public class NotAnOutputTypeError extends BaseError {
 
-    public NotAnOutputTypeError(TypeDefinition typeDefinition) {
-        super(typeDefinition, format("expected OutputType, but found %s type %s", typeDefinition.getName(), lineCol(typeDefinition)));
+    public NotAnOutputTypeError(Type rawType, TypeDefinition typeDefinition) {
+        super(rawType, format("The type '%s' %s is not an output type, but was used to declare the output type of a field %s", typeDefinition.getName(), lineCol(typeDefinition), lineCol(rawType)));
     }
 }

File: src/main/java/graphql/schema/idl/NoopWiringFactory.java
Patch:
@@ -51,6 +51,6 @@ public DataFetcher getDataFetcher(FieldWiringEnvironment environment) {
 
     @Override
     public DataFetcher getDefaultDataFetcher(FieldWiringEnvironment environment) {
-        return new PropertyDataFetcher(environment.getFieldDefinition().getName());
+        return null;
     }
 }

File: src/main/java/graphql/validation/ValidationErrorType.java
Patch:
@@ -27,6 +27,7 @@ public enum ValidationErrorType {
     FragmentCycle,
     FieldsConflict,
     InvalidFragmentType,
-    LoneAnonymousOperationViolation
+    LoneAnonymousOperationViolation,
+    NonExecutableDefinition
 
 }

File: src/main/java/graphql/execution/Async.java
Patch:
@@ -66,6 +66,7 @@ public static <T, U> CompletableFuture<List<U>> eachSequentially(Iterable<T> lis
     private static <T, U> void eachSequentiallyImpl(Iterator<T> iterator, CFFactory<T, U> cfFactory, int index, List<U> tmpResult, CompletableFuture<List<U>> overallResult) {
         if (!iterator.hasNext()) {
             overallResult.complete(tmpResult);
+            return;
         }
         CompletableFuture<U> cf;
         try {

File: src/main/java/graphql/language/AstValueHelper.java
Patch:
@@ -157,13 +157,13 @@ private static Value handleNonNull(Object _value, GraphQLNonNull type) {
     }
 
     private static String jsonStringify(String stringValue) {
-        stringValue = stringValue.replace("\"", "\\\"");
         stringValue = stringValue.replace("\\", "\\\\");
-        stringValue = stringValue.replace("/", "\\/");
+        stringValue = stringValue.replace("\"", "\\\"");
         stringValue = stringValue.replace("\f", "\\f");
         stringValue = stringValue.replace("\n", "\\n");
         stringValue = stringValue.replace("\r", "\\r");
         stringValue = stringValue.replace("\t", "\\t");
+        stringValue = stringValue.replace("\b", "\\b");
         return stringValue;
     }
 

File: src/main/java/graphql/execution/defer/DeferredErrorSupport.java
Patch:
@@ -17,7 +17,7 @@ public class DeferredErrorSupport {
     private final List<GraphQLError> errors = new CopyOnWriteArrayList<>();
 
     public void onFetchingException(ExecutionStrategyParameters parameters, Throwable e) {
-        ExceptionWhileDataFetching error = new ExceptionWhileDataFetching(parameters.path(), e, parameters.field().get(0).getSourceLocation());
+        ExceptionWhileDataFetching error = new ExceptionWhileDataFetching(parameters.getPath(), e, parameters.getField().get(0).getSourceLocation());
         onError(error);
     }
 

File: src/main/java/graphql/validation/rules/ArgumentsOfCorrectType.java
Patch:
@@ -6,7 +6,6 @@
 import graphql.validation.AbstractRule;
 import graphql.validation.ArgumentValidationUtil;
 import graphql.validation.ValidationContext;
-import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
@@ -22,7 +21,7 @@ public void checkArgument(Argument argument) {
         if (fieldArgument == null) return;
         ArgumentValidationUtil validationUtil = new ArgumentValidationUtil(argument);
         if (!validationUtil.isValidLiteralValue(argument.getValue(), fieldArgument.getType(), getValidationContext().getSchema())) {
-            addError(new ValidationError(ValidationErrorType.WrongType, argument.getSourceLocation(), validationUtil.getMessage()));
+            addError(ValidationErrorType.WrongType, argument.getSourceLocation(), validationUtil.getMessage());
         }
     }
 }

File: src/main/java/graphql/validation/rules/FieldsOnCorrectType.java
Patch:
@@ -6,7 +6,6 @@
 import graphql.schema.GraphQLFieldDefinition;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
-import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
@@ -26,7 +25,7 @@ public void checkField(Field field) {
         GraphQLFieldDefinition fieldDef = getValidationContext().getFieldDef();
         if (fieldDef == null) {
             String message = String.format("Field '%s' in type '%s' is undefined", field.getName(), parentType.getName());
-            addError(new ValidationError(ValidationErrorType.FieldUndefined, field.getSourceLocation(), message));
+            addError(ValidationErrorType.FieldUndefined, field.getSourceLocation(), message);
         }
 
     }

File: src/main/java/graphql/validation/rules/FragmentsOnCompositeType.java
Patch:
@@ -7,7 +7,6 @@
 import graphql.schema.GraphQLType;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
-import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
@@ -27,7 +26,7 @@ public void checkInlineFragment(InlineFragment inlineFragment) {
         if (type == null) return;
         if (!(type instanceof GraphQLCompositeType)) {
             String message = "Inline fragment type condition is invalid, must be on Object/Interface/Union";
-            addError(new ValidationError(ValidationErrorType.InlineFragmentTypeConditionInvalid, inlineFragment.getSourceLocation(), message));
+            addError(ValidationErrorType.InlineFragmentTypeConditionInvalid, inlineFragment.getSourceLocation(), message);
         }
     }
 
@@ -37,7 +36,7 @@ public void checkFragmentDefinition(FragmentDefinition fragmentDefinition) {
         if (type == null) return;
         if (!(type instanceof GraphQLCompositeType)) {
             String message = "Fragment type condition is invalid, must be on Object/Interface/Union";
-            addError(new ValidationError(ValidationErrorType.InlineFragmentTypeConditionInvalid, fragmentDefinition.getSourceLocation(), message));
+            addError(ValidationErrorType.InlineFragmentTypeConditionInvalid, fragmentDefinition.getSourceLocation(), message);
         }
     }
 }

File: src/main/java/graphql/validation/rules/KnownArgumentNames.java
Patch:
@@ -6,7 +6,6 @@
 import graphql.schema.GraphQLFieldDefinition;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
-import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
@@ -25,7 +24,7 @@ public void checkArgument(Argument argument) {
             GraphQLArgument directiveArgument = directiveDef.getArgument(argument.getName());
             if (directiveArgument == null) {
                 String message = String.format("Unknown directive argument %s", argument.getName());
-                addError(new ValidationError(ValidationErrorType.UnknownDirective, argument.getSourceLocation(), message));
+                addError(ValidationErrorType.UnknownDirective, argument.getSourceLocation(), message);
             }
 
             return;
@@ -36,7 +35,7 @@ public void checkArgument(Argument argument) {
         GraphQLArgument fieldArgument = fieldDef.getArgument(argument.getName());
         if (fieldArgument == null) {
             String message = String.format("Unknown field argument %s", argument.getName());
-            addError(new ValidationError(ValidationErrorType.UnknownArgument, argument.getSourceLocation(), message));
+            addError(ValidationErrorType.UnknownArgument, argument.getSourceLocation(), message);
         }
     }
 }

File: src/main/java/graphql/validation/rules/KnownDirectives.java
Patch:
@@ -13,7 +13,6 @@
 import graphql.schema.GraphQLDirective;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
-import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
@@ -31,14 +30,14 @@ public void checkDirective(Directive directive, List<Node> ancestors) {
         GraphQLDirective graphQLDirective = getValidationContext().getSchema().getDirective(directive.getName());
         if (graphQLDirective == null) {
             String message = String.format("Unknown directive %s", directive.getName());
-            addError(new ValidationError(ValidationErrorType.UnknownDirective, directive.getSourceLocation(), message));
+            addError(ValidationErrorType.UnknownDirective, directive.getSourceLocation(), message);
             return;
         }
 
         Node ancestor = ancestors.get(ancestors.size() - 1);
         if (hasInvalidLocation(graphQLDirective, ancestor)) {
             String message = String.format("Directive %s not allowed here", directive.getName());
-            addError(new ValidationError(ValidationErrorType.MisplacedDirective, directive.getSourceLocation(), message));
+            addError(ValidationErrorType.MisplacedDirective, directive.getSourceLocation(), message);
         }
     }
 

File: src/main/java/graphql/validation/rules/KnownFragmentNames.java
Patch:
@@ -5,7 +5,6 @@
 import graphql.language.FragmentSpread;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
-import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
@@ -20,7 +19,7 @@ public void checkFragmentSpread(FragmentSpread fragmentSpread) {
         FragmentDefinition fragmentDefinition = getValidationContext().getFragment(fragmentSpread.getName());
         if (fragmentDefinition == null) {
             String message = String.format("Undefined fragment %s", fragmentSpread.getName());
-            addError(new ValidationError(ValidationErrorType.UndefinedFragment, fragmentSpread.getSourceLocation(), message));
+            addError(ValidationErrorType.UndefinedFragment, fragmentSpread.getSourceLocation(), message);
         }
     }
 }

File: src/main/java/graphql/validation/rules/KnownTypeNames.java
Patch:
@@ -4,7 +4,6 @@
 import graphql.language.TypeName;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
-import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
@@ -19,7 +18,7 @@ public KnownTypeNames(ValidationContext validationContext, ValidationErrorCollec
     public void checkTypeName(TypeName typeName) {
         if ((getValidationContext().getSchema().getType(typeName.getName())) == null) {
             String message = String.format("Unknown type %s", typeName.getName());
-            addError(new ValidationError(ValidationErrorType.UnknownType, typeName.getSourceLocation(), message));
+            addError(ValidationErrorType.UnknownType, typeName.getSourceLocation(), message);
         }
     }
 }

File: src/main/java/graphql/validation/rules/LoneAnonymousOperation.java
Patch:
@@ -4,7 +4,6 @@
 import graphql.language.OperationDefinition;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
-import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
@@ -35,7 +34,7 @@ public void checkOperationDefinition(OperationDefinition operationDefinition) {
         }
         count++;
         if (message != null) {
-            addError(new ValidationError(ValidationErrorType.LoneAnonymousOperationViolation, operationDefinition.getSourceLocation(), message));
+            addError(ValidationErrorType.LoneAnonymousOperationViolation, operationDefinition.getSourceLocation(), message);
         }
     }
 

File: src/main/java/graphql/validation/rules/NoFragmentCycles.java
Patch:
@@ -7,7 +7,6 @@
 import graphql.language.Node;
 import graphql.validation.AbstractRule;
 import graphql.validation.DocumentVisitor;
-import graphql.validation.ErrorFactory;
 import graphql.validation.LanguageTraversal;
 import graphql.validation.ValidationContext;
 import graphql.validation.ValidationErrorCollector;
@@ -78,7 +77,7 @@ private void detectCycleRecursive(String fragmentName, String initialName, List<
 
             if (fragmentSpread.getName().equals(initialName)) {
                 String message = "Fragment cycles not allowed";
-                addError(new ErrorFactory().newError(ValidationErrorType.FragmentCycle, spreadPath, message));
+                addError(ValidationErrorType.FragmentCycle, spreadPath, message);
                 continue;
             }
             for (FragmentSpread spread : spreadPath) {

File: src/main/java/graphql/validation/rules/NoUndefinedVariables.java
Patch:
@@ -7,7 +7,6 @@
 import graphql.language.VariableReference;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
-import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
@@ -37,7 +36,7 @@ public void checkFragmentDefinition(FragmentDefinition fragmentDefinition) {
     public void checkVariable(VariableReference variableReference) {
         if (!variableNames.contains(variableReference.getName())) {
             String message = String.format("Undefined variable %s", variableReference.getName());
-            addError(new ValidationError(ValidationErrorType.UndefinedVariable, variableReference.getSourceLocation(), message));
+            addError(ValidationErrorType.UndefinedVariable, variableReference.getSourceLocation(), message);
         }
     }
 

File: src/main/java/graphql/validation/rules/NoUnusedFragments.java
Patch:
@@ -7,7 +7,6 @@
 import graphql.language.OperationDefinition;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
-import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
@@ -61,7 +60,7 @@ public void documentFinished(Document document) {
         for (FragmentDefinition fragmentDefinition : allDeclaredFragments) {
             if (!allUsedFragments.contains(fragmentDefinition.getName())) {
                 String message = String.format("Unused fragment %s", fragmentDefinition.getName());
-                addError(new ValidationError(ValidationErrorType.UnusedFragment, fragmentDefinition.getSourceLocation(), message));
+                addError(ValidationErrorType.UnusedFragment, fragmentDefinition.getSourceLocation(), message);
             }
         }
 

File: src/main/java/graphql/validation/rules/NoUnusedVariables.java
Patch:
@@ -30,7 +30,7 @@ public void leaveOperationDefinition(OperationDefinition operationDefinition) {
         for (VariableDefinition variableDefinition : variableDefinitions) {
             if (!usedVariables.contains(variableDefinition.getName())) {
                 String message = String.format("Unused variable %s", variableDefinition.getName());
-                addError(new ValidationError(ValidationErrorType.UnusedVariable, variableDefinition.getSourceLocation(), message));
+                addError(ValidationErrorType.UnusedVariable, variableDefinition.getSourceLocation(), message);
             }
         }
     }

File: src/main/java/graphql/validation/rules/ProvidedNonNullArguments.java
Patch:
@@ -11,7 +11,6 @@
 import graphql.schema.GraphQLNonNull;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
-import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
@@ -36,7 +35,7 @@ public void checkField(Field field) {
             if (argument == null
                     && (graphQLArgument.getType() instanceof GraphQLNonNull)) {
                 String message = String.format("Missing field argument %s", graphQLArgument.getName());
-                addError(new ValidationError(ValidationErrorType.MissingFieldArgument, field.getSourceLocation(), message));
+                addError(ValidationErrorType.MissingFieldArgument, field.getSourceLocation(), message);
             }
         }
     }
@@ -61,7 +60,7 @@ public void checkDirective(Directive directive, List<Node> ancestors) {
             if (argument == null
                     && (graphQLArgument.getType() instanceof GraphQLNonNull)) {
                 String message = String.format("Missing directive argument %s", graphQLArgument.getName());
-                addError(new ValidationError(ValidationErrorType.MissingDirectiveArgument, directive.getSourceLocation(), message));
+                addError(ValidationErrorType.MissingDirectiveArgument, directive.getSourceLocation(), message);
             }
         }
     }

File: src/main/java/graphql/validation/rules/ScalarLeafs.java
Patch:
@@ -6,7 +6,6 @@
 import graphql.schema.SchemaUtil;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
-import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
@@ -25,12 +24,12 @@ public void checkField(Field field) {
         if (schemaUtil.isLeafType(type)) {
             if (field.getSelectionSet() != null) {
                 String message = String.format("Sub selection not allowed on leaf type %s of field %s", type.getName(), field.getName());
-                addError(new ValidationError(ValidationErrorType.SubSelectionNotAllowed, field.getSourceLocation(), message));
+                addError(ValidationErrorType.SubSelectionNotAllowed, field.getSourceLocation(), message);
             }
         } else {
             if (field.getSelectionSet() == null) {
                 String message = String.format("Sub selection required for type %s of field %s", type.getName(), field.getName());
-                addError(new ValidationError(ValidationErrorType.SubSelectionRequired, field.getSourceLocation(), message));
+                addError(ValidationErrorType.SubSelectionRequired, field.getSourceLocation(), message);
             }
         }
     }

File: src/main/java/graphql/validation/rules/VariableDefaultValuesOfCorrectType.java
Patch:
@@ -5,7 +5,6 @@
 import graphql.schema.GraphQLNonNull;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
-import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
@@ -24,12 +23,12 @@ public void checkVariableDefinition(VariableDefinition variableDefinition) {
         if (inputType == null) return;
         if (inputType instanceof GraphQLNonNull && variableDefinition.getDefaultValue() != null) {
             String message = "Missing value for non null type";
-            addError(new ValidationError(ValidationErrorType.DefaultForNonNullArgument, variableDefinition.getSourceLocation(), message));
+            addError(ValidationErrorType.DefaultForNonNullArgument, variableDefinition.getSourceLocation(), message);
         }
         if (variableDefinition.getDefaultValue() != null
                 && !getValidationUtil().isValidLiteralValue(variableDefinition.getDefaultValue(), inputType, getValidationContext().getSchema())) {
             String message = String.format("Bad default value %s for type %s", variableDefinition.getDefaultValue(), inputType.getName());
-            addError(new ValidationError(ValidationErrorType.BadValueForDefaultArg, variableDefinition.getSourceLocation(), message));
+            addError(ValidationErrorType.BadValueForDefaultArg, variableDefinition.getSourceLocation(), message);
         }
     }
 }

File: src/main/java/graphql/validation/rules/VariableTypesMatchRule.java
Patch:
@@ -10,7 +10,6 @@
 import graphql.schema.GraphQLTypeUtil;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
-import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
@@ -63,7 +62,7 @@ public void checkVariable(VariableReference variableReference) {
             String message = String.format("Variable type '%s' doesn't match expected type '%s'",
                     GraphQLTypeUtil.getUnwrappedTypeName(effectiveType),
                     GraphQLTypeUtil.getUnwrappedTypeName(expectedType));
-            addError(new ValidationError(ValidationErrorType.VariableTypeMismatch, variableReference.getSourceLocation(), message));
+            addError(ValidationErrorType.VariableTypeMismatch, variableReference.getSourceLocation(), message);
         }
     }
 

File: src/main/java/graphql/validation/rules/VariablesAreInputTypes.java
Patch:
@@ -7,7 +7,6 @@
 import graphql.schema.SchemaUtil;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
-import graphql.validation.ValidationError;
 import graphql.validation.ValidationErrorCollector;
 import graphql.validation.ValidationErrorType;
 
@@ -27,7 +26,7 @@ public void checkVariableDefinition(VariableDefinition variableDefinition) {
         if (type == null) return;
         if (!schemaUtil.isInputType(type)) {
             String message = "Wrong type for a variable";
-            addError(new ValidationError(ValidationErrorType.NonInputTypeOnVariable, variableDefinition.getSourceLocation(), message));
+            addError(ValidationErrorType.NonInputTypeOnVariable, variableDefinition.getSourceLocation(), message);
         }
     }
 }

File: src/main/java/graphql/util/Traverser.java
Patch:
@@ -78,6 +78,7 @@ public TraverserResult traverse(Collection<? extends T> roots, TraverserVisitor<
                 // end-of-list marker, we are done recursing children,
                 // mark the current node as fully visited
                 TraverserContext contextForLeave = (TraverserContext) traverserState.pop();
+                currentContext = contextForLeave;
                 TraversalControl traversalControl = visitor.leave(contextForLeave);
                 assertNotNull(traversalControl, "result of leave must not be null");
                 assertTrue(CONTINUE_OR_QUIT.contains(traversalControl), "result can only return CONTINUE or QUIT");

File: src/main/java/graphql/util/Traverser.java
Patch:
@@ -164,6 +164,7 @@ public <U> Object traverse(Collection<? extends T> roots, TraverserVisitor<? sup
             } else {
                 TraversalControl traversalControl = visitor.enter(currentContext);
                 assertNotNull(traversalControl, "result of enter must not be null");
+                this.traverserState.addVisited((T) currentContext.thisNode());
                 switch (traversalControl) {
                     case QUIT:
                         break traverseLoop;

File: src/main/java/graphql/util/Traverser.java
Patch:
@@ -98,6 +98,7 @@ public static <T> Traverser<T> breadthFirst(Function<? super T, ? extends List<T
      */
     public void reset() {
         stack.clear();
+        rootVars.clear();
     }
 
     /**

File: src/main/java/graphql/language/Argument.java
Patch:
@@ -56,6 +56,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitArgument(this, data);
     }
 }

File: src/main/java/graphql/language/ArrayValue.java
Patch:
@@ -52,6 +52,6 @@ public ArrayValue deepCopy() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitArrayValue(this, data);
     }
 }

File: src/main/java/graphql/language/BooleanValue.java
Patch:
@@ -51,6 +51,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitBooleanValue(this, data);
     }
 }

File: src/main/java/graphql/language/Directive.java
Patch:
@@ -70,6 +70,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitDirective(this, data);
     }
 }

File: src/main/java/graphql/language/DirectiveDefinition.java
Patch:
@@ -76,6 +76,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitDirectiveDefinition(this, data);
     }
 }

File: src/main/java/graphql/language/DirectiveLocation.java
Patch:
@@ -52,6 +52,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitDirectiveLocation(this, data);
     }
 }

File: src/main/java/graphql/language/Document.java
Patch:
@@ -53,6 +53,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitDocument(this, data);
     }
 }

File: src/main/java/graphql/language/EnumTypeDefinition.java
Patch:
@@ -93,6 +93,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitEnumTypeDefinition(this, data);
     }
 }

File: src/main/java/graphql/language/EnumValue.java
Patch:
@@ -50,6 +50,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitEnumValue(this, data);
     }
 }

File: src/main/java/graphql/language/EnumValueDefinition.java
Patch:
@@ -76,6 +76,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitEnumValueDefinition(this, data);
     }
 }

File: src/main/java/graphql/language/Field.java
Patch:
@@ -147,6 +147,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitField(this, data);
     }
 }

File: src/main/java/graphql/language/FieldDefinition.java
Patch:
@@ -106,6 +106,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitFieldDefinition(this, data);
     }
 }

File: src/main/java/graphql/language/FloatValue.java
Patch:
@@ -52,6 +52,6 @@ public FloatValue deepCopy() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitFloatValue(this, data);
     }
 }

File: src/main/java/graphql/language/FragmentDefinition.java
Patch:
@@ -119,6 +119,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitFragmentDefinition(this, data);
     }
 }

File: src/main/java/graphql/language/FragmentSpread.java
Patch:
@@ -82,6 +82,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitFragmentSpread(this, data);
     }
 }

File: src/main/java/graphql/language/InlineFragment.java
Patch:
@@ -103,6 +103,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitInlineFragment(this, data);
     }
 }

File: src/main/java/graphql/language/InputObjectTypeDefinition.java
Patch:
@@ -89,6 +89,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitInputObjectTypeDefinition(this, data);
     }
 }

File: src/main/java/graphql/language/InputValueDefinition.java
Patch:
@@ -114,6 +114,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitInputValueDefinition(this, data);
     }
 }

File: src/main/java/graphql/language/IntValue.java
Patch:
@@ -51,6 +51,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitIntValue(this, data);
     }
 }

File: src/main/java/graphql/language/InterfaceTypeDefinition.java
Patch:
@@ -89,6 +89,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitInterfaceTypeDefinition(this, data);
     }
 }

File: src/main/java/graphql/language/ListType.java
Patch:
@@ -52,6 +52,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitListType(this, data);
     }
 }

File: src/main/java/graphql/language/NonNullType.java
Patch:
@@ -57,6 +57,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitNonNullType(this, data);
     }
 }

File: src/main/java/graphql/language/NullValue.java
Patch:
@@ -38,6 +38,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitNullValue(this, data);
     }
 }

File: src/main/java/graphql/language/ObjectField.java
Patch:
@@ -55,6 +55,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitObjectField(this, data);
     }
 }

File: src/main/java/graphql/language/ObjectTypeDefinition.java
Patch:
@@ -101,6 +101,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitObjectTypeDefinition(this, data);
     }
 }

File: src/main/java/graphql/language/ObjectValue.java
Patch:
@@ -52,6 +52,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitObjectValue(this, data);
     }
 }

File: src/main/java/graphql/language/OperationDefinition.java
Patch:
@@ -137,6 +137,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitOperationDefinition(this, data);
     }
 }

File: src/main/java/graphql/language/OperationTypeDefinition.java
Patch:
@@ -68,6 +68,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitOperationTypeDefinition(this, data);
     }
 }

File: src/main/java/graphql/language/ScalarTypeDefinition.java
Patch:
@@ -79,6 +79,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitScalarTypeDefinition(this, data);
     }
 }

File: src/main/java/graphql/language/SchemaDefinition.java
Patch:
@@ -70,6 +70,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitSchemaDefinition(this, data);
     }
 }

File: src/main/java/graphql/language/SelectionSet.java
Patch:
@@ -51,6 +51,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitSelectionSet(this, data);
     }
 }

File: src/main/java/graphql/language/StringValue.java
Patch:
@@ -51,6 +51,6 @@ public StringValue deepCopy() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitStringValue(this, data);
     }
 }

File: src/main/java/graphql/language/TypeName.java
Patch:
@@ -49,6 +49,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitTypeName(this, data);
     }
 }

File: src/main/java/graphql/language/UnionTypeDefinition.java
Patch:
@@ -90,6 +90,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitUnionTypeDefinition(this, data);
     }
 }

File: src/main/java/graphql/language/VariableDefinition.java
Patch:
@@ -86,6 +86,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitVariableDefinition(this, data);
     }
 }

File: src/main/java/graphql/language/VariableReference.java
Patch:
@@ -49,6 +49,6 @@ public String toString() {
 
     @Override
     public <U> Object accept(U data, NodeVisitor<U> visitor) {
-        return visitor.visit(this, data);
+        return visitor.visitVariableReference(this, data);
     }
 }

File: src/main/java/graphql/execution/AbstractAsyncExecutionStrategy.java
Patch:
@@ -2,6 +2,7 @@
 
 import graphql.ExecutionResult;
 import graphql.ExecutionResultImpl;
+import graphql.execution.defer.DeferSupport;
 
 import java.util.LinkedHashMap;
 import java.util.List;

File: src/main/java/graphql/execution/ExecutionContext.java
Patch:
@@ -3,6 +3,7 @@
 
 import graphql.GraphQLError;
 import graphql.PublicApi;
+import graphql.execution.defer.DeferSupport;
 import graphql.execution.instrumentation.Instrumentation;
 import graphql.execution.instrumentation.InstrumentationState;
 import graphql.language.Document;

File: src/main/java/graphql/execution/SimpleDataFetcherExceptionHandler.java
Patch:
@@ -21,8 +21,5 @@ public void accept(DataFetcherExceptionHandlerParameters handlerParameters) {
         ExceptionWhileDataFetching error = new ExceptionWhileDataFetching(path, exception, sourceLocation);
         handlerParameters.getExecutionContext().addError(error);
         log.warn(error.getMessage(), exception);
-
-        DeferSupport deferSupport = handlerParameters.getExecutionContext().getDeferSupport();
-        deferSupport.onFetcherError(error);
     }
 }

File: src/main/java/graphql/execution/SimpleDataFetcherExceptionHandler.java
Patch:
@@ -21,5 +21,8 @@ public void accept(DataFetcherExceptionHandlerParameters handlerParameters) {
         ExceptionWhileDataFetching error = new ExceptionWhileDataFetching(path, exception, sourceLocation);
         handlerParameters.getExecutionContext().addError(error);
         log.warn(error.getMessage(), exception);
+
+        DeferSupport deferSupport = handlerParameters.getExecutionContext().getDeferSupport();
+        deferSupport.onFetcherError(error);
     }
 }

File: src/main/java/graphql/Assert.java
Patch:
@@ -40,7 +40,7 @@ public static void assertTrue(boolean condition, String format, Object... args)
         throw new AssertException(format(format, args));
     }
 
-    private static final String invalidNameErrorMessage = "Name must be non-null, non-empty and match [_A-Za-z][_0-9A-Za-z]*";
+    private static final String invalidNameErrorMessage = "Name must be non-null, non-empty and match [_A-Za-z][_0-9A-Za-z]* - was '%s'";
 
     /**
      * Validates that the Lexical token name matches the current spec.
@@ -54,7 +54,7 @@ public static String assertValidName(String name) {
         if (name != null && !name.isEmpty() && name.matches("[_A-Za-z][_0-9A-Za-z]*")) {
             return name;
         }
-        throw new AssertException(invalidNameErrorMessage);
+        throw new AssertException(String.format(invalidNameErrorMessage,name));
     }
 
 }

File: src/main/java/graphql/schema/idl/SchemaGenerator.java
Patch:
@@ -650,8 +650,6 @@ private GraphQLArgument buildArgument(BuildContext buildCtx, InputValueDefinitio
         return builder.build();
     }
 
-
-
     @SuppressWarnings("Duplicates")
     private TypeResolver getTypeResolverForUnion(BuildContext buildCtx, UnionTypeDefinition unionType) {
         TypeDefinitionRegistry typeRegistry = buildCtx.getTypeRegistry();
@@ -723,7 +721,6 @@ private GraphQLDirective[] buildDirectives(List<Directive> directives, List<Dire
     }
 
 
-
     private List<ObjectTypeExtensionDefinition> objectTypeExtensions(ObjectTypeDefinition typeDefinition, BuildContext buildCtx) {
         return nvl(buildCtx.typeRegistry.objectTypeExtensions().get(typeDefinition.getName()));
     }

File: src/main/java/graphql/schema/idl/SchemaGenerator.java
Patch:
@@ -725,7 +725,7 @@ private GraphQLDirective[] buildDirectives(List<Directive> directives, List<Dire
 
 
     private List<ObjectTypeExtensionDefinition> objectTypeExtensions(ObjectTypeDefinition typeDefinition, BuildContext buildCtx) {
-        return nvl(buildCtx.typeRegistry.typeExtensions().get(typeDefinition.getName()));
+        return nvl(buildCtx.typeRegistry.objectTypeExtensions().get(typeDefinition.getName()));
     }
 
     private List<InterfaceTypeExtensionDefinition> interfaceTypeExtensions(InterfaceTypeDefinition typeDefinition, BuildContext buildCtx) {

File: src/main/java/graphql/schema/idl/SchemaTypeChecker.java
Patch:
@@ -115,7 +115,7 @@ private void checkSchemaInvariants(List<GraphQLError> errors, TypeDefinitionRegi
 
     private void checkForMissingTypes(List<GraphQLError> errors, TypeDefinitionRegistry typeRegistry) {
         // type extensions
-        List<ObjectTypeExtensionDefinition> typeExtensions = typeRegistry.typeExtensions().values().stream().flatMap(Collection::stream).collect(Collectors.toList());
+        List<ObjectTypeExtensionDefinition> typeExtensions = typeRegistry.objectTypeExtensions().values().stream().flatMap(Collection::stream).collect(Collectors.toList());
         typeExtensions.forEach(typeExtension -> {
 
             List<Type> implementsTypes = typeExtension.getImplements();
@@ -415,7 +415,7 @@ private void checkInterfacesAreImplemented(List<GraphQLError> errors, TypeDefini
             implementsTypes.forEach(checkInterfaceIsImplemented("object", typeRegistry, errors, objectType));
         });
 
-        Map<String, List<ObjectTypeExtensionDefinition>> typeExtensions = typeRegistry.typeExtensions();
+        Map<String, List<ObjectTypeExtensionDefinition>> typeExtensions = typeRegistry.objectTypeExtensions();
         typeExtensions.values().forEach(extList -> extList.forEach(typeExtension -> {
             List<Type> implementsTypes = typeExtension.getImplements();
             implementsTypes.forEach(checkInterfaceIsImplemented("extension", typeRegistry, errors, typeExtension));

File: src/main/java/graphql/schema/idl/SchemaTypeExtensionsChecker.java
Patch:
@@ -67,7 +67,7 @@ void checkTypeExtensions(List<GraphQLError> errors, TypeDefinitionRegistry typeR
      * The resulting extended object type must be a super-set of all interfaces it implements.
      */
     private void checkObjectTypeExtensions(List<GraphQLError> errors, TypeDefinitionRegistry typeRegistry) {
-        typeRegistry.typeExtensions()
+        typeRegistry.objectTypeExtensions()
                 .forEach((name, extensions) -> {
                             checkTypeExtensionHasCorrespondingType(errors, typeRegistry, name, extensions, ObjectTypeDefinition.class);
                             checkTypeExtensionDirectiveRedefinition(errors, typeRegistry, name, extensions, ObjectTypeDefinition.class);

File: src/main/java/graphql/schema/idl/TypeDefinitionRegistry.java
Patch:
@@ -191,7 +191,7 @@ public Map<String, ScalarTypeDefinition> scalars() {
         return scalars;
     }
 
-    public Map<String, List<ObjectTypeExtensionDefinition>> typeExtensions() {
+    public Map<String, List<ObjectTypeExtensionDefinition>> objectTypeExtensions() {
         return new LinkedHashMap<>(typeExtensions);
     }
 

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -55,7 +55,7 @@ public class AstPrinter {
         printers.put(SchemaDefinition.class, schemaDefinition());
         printers.put(SelectionSet.class, selectionSet());
         printers.put(StringValue.class, value());
-        printers.put(TypeExtensionDefinition.class, typeExtensionDefinition());
+        printers.put(ObjectTypeExtensionDefinition.class, typeExtensionDefinition());
         printers.put(TypeName.class, type());
         printers.put(UnionTypeDefinition.class, unionTypeDefinition());
         printers.put(VariableDefinition.class, variableDefinition());
@@ -331,7 +331,7 @@ static private String type(Type type) {
     }
 
     @SuppressWarnings("UnnecessaryLocalVariable")
-    private static NodePrinter<TypeExtensionDefinition> typeExtensionDefinition() {
+    private static NodePrinter<ObjectTypeExtensionDefinition> typeExtensionDefinition() {
         return (out, node) -> {
             ObjectTypeDefinition asObjectType = node;
             out.printf("extend %s", node(asObjectType));

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -34,6 +34,7 @@
 import graphql.language.NonNullType;
 import graphql.language.ObjectField;
 import graphql.language.ObjectTypeDefinition;
+import graphql.language.ObjectTypeExtensionDefinition;
 import graphql.language.ObjectValue;
 import graphql.language.OperationDefinition;
 import graphql.language.OperationTypeDefinition;
@@ -43,7 +44,6 @@
 import graphql.language.SelectionSet;
 import graphql.language.SourceLocation;
 import graphql.language.StringValue;
-import graphql.language.TypeExtensionDefinition;
 import graphql.language.TypeName;
 import graphql.language.UnionTypeDefinition;
 import graphql.language.UnionTypeExtensionDefinition;
@@ -642,7 +642,7 @@ private Void extensionTypeImpl(ParserRuleContext ctx, Definition def, ContextPro
 
     @Override
     public Void visitObjectTypeExtensionDefinition(GraphqlParser.ObjectTypeExtensionDefinitionContext ctx) {
-        return extensionTypeImpl(ctx, new TypeExtensionDefinition(ctx.name().getText()), ContextProperty.ObjectTypeDefinition);
+        return extensionTypeImpl(ctx, new ObjectTypeExtensionDefinition(ctx.name().getText()), ContextProperty.ObjectTypeDefinition);
     }
 
     @Override

File: src/main/java/graphql/language/TypeExtensionDefinition.java
Patch:
@@ -3,6 +3,7 @@
 
 import java.util.List;
 
+// This class should really be called ObjectTypeExtensionDefinition but history
 public class TypeExtensionDefinition extends ObjectTypeDefinition {
     public TypeExtensionDefinition() {
         super(null);

File: src/main/java/graphql/schema/GraphQLDirectiveContainer.java
Patch:
@@ -7,12 +7,12 @@
 import static graphql.DirectivesUtil.directivesByName;
 
 /**
- * Represents a type that can have {@link graphql.schema.GraphQLDirective}s
+ * Represents a graphql object that can have {@link graphql.schema.GraphQLDirective}s
  */
 public interface GraphQLDirectiveContainer extends GraphQLType {
 
     /**
-     * @return a list of directives associated with the type
+     * @return a list of directives associated with the type or field
      */
     List<GraphQLDirective> getDirectives();
 
@@ -26,7 +26,7 @@ default Map<String, GraphQLDirective> getDirectivesByName() {
     /**
      * Returns a named directive
      *
-     * @param directiveName the name of the directive to retrive
+     * @param directiveName the name of the directive to retrieve
      *
      * @return the directive or null if there is one one with that name
      */

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -1,6 +1,7 @@
 package graphql.schema;
 
 import graphql.AssertException;
+import graphql.DirectivesUtil;
 import graphql.Internal;
 import graphql.PublicApi;
 import graphql.language.ObjectTypeDefinition;

File: src/main/java/graphql/validation/rules/VariablesTypesMatcher.java
Patch:
@@ -1,18 +1,20 @@
 package graphql.validation.rules;
 
 
+import graphql.Internal;
 import graphql.language.Value;
 import graphql.schema.GraphQLList;
 import graphql.schema.GraphQLNonNull;
 import graphql.schema.GraphQLType;
 
+@Internal
 public class VariablesTypesMatcher {
 
     public boolean doesVariableTypesMatch(GraphQLType variableType, Value variableDefaultValue, GraphQLType expectedType) {
         return checkType(effectiveType(variableType, variableDefaultValue), expectedType);
     }
 
-    private GraphQLType effectiveType(GraphQLType variableType, Value defaultValue) {
+    public GraphQLType effectiveType(GraphQLType variableType, Value defaultValue) {
         if (defaultValue == null) return variableType;
         if (variableType instanceof GraphQLNonNull) return variableType;
         return new GraphQLNonNull(variableType);

File: src/main/java/graphql/SerializationError.java
Patch:
@@ -53,7 +53,7 @@ public List<Object> getPath() {
 
     @Override
     public String toString() {
-        return "ExceptionWhileDataFetching{" +
+        return "SerializationError{" +
                 "path=" + path +
                 "exception=" + exception +
                 '}';

File: src/main/java/graphql/TypeMismatchError.java
Patch:
@@ -80,7 +80,7 @@ public List<Object> getPath() {
 
     @Override
     public String toString() {
-        return "ExceptionWhileDataFetching{" +
+        return "TypeMismatchError{" +
                 "path=" + path +
                 "expectedType=" + expectedType +
                 '}';

File: src/main/java/graphql/execution/DataFetcherExceptionHandler.java
Patch:
@@ -1,6 +1,7 @@
 package graphql.execution;
 
 import graphql.GraphQLError;
+import graphql.PublicSpi;
 import graphql.schema.DataFetcher;
 import graphql.schema.DataFetchingEnvironment;
 
@@ -9,12 +10,13 @@
 /**
  * This is called when an exception is thrown during {@link graphql.schema.DataFetcher#get(DataFetchingEnvironment)} execution
  */
+@PublicSpi
 public interface DataFetcherExceptionHandler extends Consumer<DataFetcherExceptionHandlerParameters> {
 
     /**
      * When an exception during a call to a {@link DataFetcher} then this handler
      * is called back to shape the error that should be placed in the list of errors
-     * via {@link ExecutionContext#addError(GraphQLError, graphql.execution.ExecutionPath)}
+     * via {@link ExecutionContext#addError(GraphQLError)}
      *
      * @param handlerParameters the parameters to this callback
      */

File: src/main/java/graphql/execution/SimpleDataFetcherExceptionHandler.java
Patch:
@@ -19,7 +19,7 @@ public void accept(DataFetcherExceptionHandlerParameters handlerParameters) {
         ExecutionPath path = handlerParameters.getPath();
 
         ExceptionWhileDataFetching error = new ExceptionWhileDataFetching(path, exception, sourceLocation);
-        handlerParameters.getExecutionContext().addError(error, handlerParameters.getPath());
+        handlerParameters.getExecutionContext().addError(error);
         log.warn(error.getMessage(), exception);
     }
 }

File: src/main/java/graphql/schema/GraphQLDirective.java
Patch:
@@ -14,7 +14,7 @@
 import static graphql.introspection.Introspection.DirectiveLocation;
 
 /**
- * A directive can be used to modify the behavior of a graphql field.
+ * A directive can be used to modify the behavior of a graphql field or type.
  *
  * See http://graphql.org/learn/queries/#directives for more details on the concept.
  */

File: src/main/java/graphql/schema/GraphQLSchema.java
Patch:
@@ -100,8 +100,8 @@ public GraphQLObjectType getObjectType(String typeName) {
         return (GraphQLObjectType) graphQLType;
     }
     
-    Map<String, GraphQLType> getTypeMap () {
-        return typeMap;
+    public Map<String, GraphQLType> getTypeMap () {
+        return Collections.unmodifiableMap(typeMap);
     }
     
     public List<GraphQLType> getAllTypesAsList() {

File: src/main/java/graphql/execution/FieldCollector.java
Patch:
@@ -150,7 +150,7 @@ private boolean checkTypeCondition(FieldCollectorParameters parameters, GraphQLT
         }
 
         if (conditionType instanceof GraphQLInterfaceType) {
-            List<GraphQLObjectType> implementations = schemaUtil.findImplementations(parameters.getGraphQLSchema(), (GraphQLInterfaceType) conditionType);
+            List<GraphQLObjectType> implementations = parameters.getGraphQLSchema().getImplementations((GraphQLInterfaceType)conditionType);
             return implementations.contains(type);
         } else if (conditionType instanceof GraphQLUnionType) {
             return ((GraphQLUnionType) conditionType).getTypes().contains(type);

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -23,7 +23,6 @@
 import graphql.schema.GraphQLScalarType;
 import graphql.schema.GraphQLSchema;
 import graphql.schema.GraphQLUnionType;
-import graphql.schema.SchemaUtil;
 import graphql.schema.visibility.GraphqlFieldVisibility;
 
 import java.util.ArrayList;
@@ -201,7 +200,7 @@ private static String print(Object value, GraphQLInputType type) {
     public static final DataFetcher possibleTypesFetcher = environment -> {
         Object type = environment.getSource();
         if (type instanceof GraphQLInterfaceType) {
-            return new SchemaUtil().findImplementations(environment.getGraphQLSchema(), (GraphQLInterfaceType) type);
+            return environment.getGraphQLSchema().getImplementations((GraphQLInterfaceType)type);
         }
         if (type instanceof GraphQLUnionType) {
             return ((GraphQLUnionType) type).getTypes();

File: src/main/java/graphql/validation/rules/PossibleFragmentSpreads.java
Patch:
@@ -12,7 +12,6 @@
 import graphql.schema.GraphQLOutputType;
 import graphql.schema.GraphQLType;
 import graphql.schema.GraphQLUnionType;
-import graphql.schema.SchemaUtil;
 import graphql.validation.AbstractRule;
 import graphql.validation.ValidationContext;
 import graphql.validation.ValidationError;
@@ -74,7 +73,7 @@ private List<? extends GraphQLType> getPossibleType(GraphQLType type) {
         if (type instanceof GraphQLObjectType) {
             possibleConditionTypes = Collections.singletonList(type);
         } else if (type instanceof GraphQLInterfaceType) {
-            possibleConditionTypes = new SchemaUtil().findImplementations(getValidationContext().getSchema(), (GraphQLInterfaceType) type);
+            possibleConditionTypes = getValidationContext().getSchema().getImplementations((GraphQLInterfaceType)type);
         } else if (type instanceof GraphQLUnionType) {
             possibleConditionTypes = ((GraphQLUnionType) type).getTypes();
         } else {

File: src/main/java/graphql/schema/diff/DiffEvent.java
Patch:
@@ -74,6 +74,7 @@ public String toString() {
     }
 
     /**
+     * @return  a Builder of Info level diff events
      * @deprecated use {@link DiffEvent#apiInfo()} instead
      */
     @Deprecated

File: src/test/groovy/example/http/ExecutionResultJSONTesting.java
Patch:
@@ -13,10 +13,10 @@
 import graphql.ExecutionResultImpl;
 import graphql.GraphQLError;
 import graphql.InvalidSyntaxError;
-import graphql.OperationNotSupportedError;
 import graphql.SerializationError;
 import graphql.execution.ExecutionPath;
 import graphql.execution.ExecutionTypeInfo;
+import graphql.execution.MissingRootTypeException;
 import graphql.execution.NonNullableFieldWasNullError;
 import graphql.execution.NonNullableFieldWasNullException;
 import graphql.introspection.Introspection;
@@ -71,7 +71,7 @@ private ExecutionResult createER() {
         List<GraphQLError> errors = new ArrayList<>();
 
         errors.add(new ValidationError(ValidationErrorType.UnknownType, mkLocations(), "Test ValidationError"));
-        errors.add(new OperationNotSupportedError("Mutations are not supported.", null));
+        errors.add(new MissingRootTypeException("Mutations are not supported.", null));
         errors.add(new InvalidSyntaxError(mkLocations(), "Not good syntax m'kay"));
         errors.add(new NonNullableFieldWasNullError(new NonNullableFieldWasNullException(mkTypeInfo(), mkPath())));
         errors.add(new SerializationError(mkPath(), new CoercingSerializeException("Bad coercing")));

File: src/main/java/graphql/ErrorType.java
Patch:
@@ -9,6 +9,6 @@ public enum ErrorType {
     InvalidSyntax,
     ValidationError,
     DataFetchingException,
-    MutationNotSupported,
+    OperationNotSupported,
     ExecutionAborted
 }

File: src/main/java/graphql/execution/NonNullableValueCoercedAsNullException.java
Patch:
@@ -35,7 +35,7 @@ public NonNullableValueCoercedAsNullException(GraphQLInputObjectField inputTypeF
 
     @Override
     public List<SourceLocation> getLocations() {
-        return null;
+        return sourceLocations;
     }
 
     @Override

File: src/main/java/graphql/analysis/QueryTraversal.java
Patch:
@@ -138,7 +138,7 @@ private void visitField(QueryVisitor visitor, Field field, GraphQLFieldDefinitio
         if (!conditionalNodes.shouldInclude(variables, field.getDirectives())) {
             return;
         }
-        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(fieldDefinition.getArguments(), field.getArguments(), variables);
+        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(schema.getFieldVisibility(), fieldDefinition.getArguments(), field.getArguments(), variables);
         if (preOrder) {
             visitor.visitField(new QueryVisitorEnvironment(field, fieldDefinition, parentType, parentEnv, argumentValues));
         }

File: src/main/java/graphql/schema/idl/SchemaPrinter.java
Patch:
@@ -304,7 +304,7 @@ private TypePrinter<GraphQLInputObjectType> inputObjectPrinter() {
             }
             printComments(out, type, "");
             out.format("input %s {\n", type.getName());
-            type.getFieldDefinitions()
+            visibility.getFieldDefinitions(type)
                     .stream()
                     .sorted(Comparator.comparing(GraphQLInputObjectField::getName))
                     .forEach(fd -> {

File: src/main/java/graphql/validation/TraversalContext.java
Patch:
@@ -167,7 +167,8 @@ private void enterImpl(ObjectField objectField) {
         GraphQLUnmodifiedType objectType = schemaUtil.getUnmodifiedType(getInputType());
         GraphQLInputType inputType = null;
         if (objectType instanceof GraphQLInputObjectType) {
-            GraphQLInputObjectField inputField = ((GraphQLInputObjectType) objectType).getField(objectField.getName());
+            GraphQLInputObjectType inputObjectType = (GraphQLInputObjectType) objectType;
+            GraphQLInputObjectField inputField = schema.getFieldVisibility().getFieldDefinition(inputObjectType, objectField.getName());
             if (inputField != null)
                 inputType = inputField.getType();
         }

File: src/main/java/graphql/validation/rules/ArgumentsOfCorrectType.java
Patch:
@@ -21,10 +21,8 @@ public void checkArgument(Argument argument) {
         GraphQLArgument fieldArgument = getValidationContext().getArgument();
         if (fieldArgument == null) return;
         ArgumentValidationUtil validationUtil = new ArgumentValidationUtil(argument);
-        if (!validationUtil.isValidLiteralValue(argument.getValue(), fieldArgument.getType())) {
+        if (!validationUtil.isValidLiteralValue(argument.getValue(), fieldArgument.getType(), getValidationContext().getSchema())) {
             addError(new ValidationError(ValidationErrorType.WrongType, argument.getSourceLocation(), validationUtil.getMessage()));
         }
     }
-
-
 }

File: src/main/java/graphql/validation/rules/VariableDefaultValuesOfCorrectType.java
Patch:
@@ -27,7 +27,7 @@ public void checkVariableDefinition(VariableDefinition variableDefinition) {
             addError(new ValidationError(ValidationErrorType.DefaultForNonNullArgument, variableDefinition.getSourceLocation(), message));
         }
         if (variableDefinition.getDefaultValue() != null
-                && !getValidationUtil().isValidLiteralValue(variableDefinition.getDefaultValue(), inputType)) {
+                && !getValidationUtil().isValidLiteralValue(variableDefinition.getDefaultValue(), inputType, getValidationContext().getSchema())) {
             String message = String.format("Bad default value %s for type %s", variableDefinition.getDefaultValue(), inputType.getName());
             addError(new ValidationError(ValidationErrorType.BadValueForDefaultArg, variableDefinition.getSourceLocation(), message));
         }

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -176,7 +176,7 @@ private Object coerceValue(VariableDefinition variableDefinition, GraphQLType gr
                 );
             }
         } else {
-            return assertShouldNeverHappen("unhandled type " + graphQLType);
+            return assertShouldNeverHappen("unhandled type %s", graphQLType);
         }
     }
 

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -313,7 +313,7 @@ private List<ExecutionNode> completeValues(ExecutionContext executionContext,
         } else if (isList(unwrappedFieldType)) {
             return handleList(executionContext, argumentValues, fetchedValues, fieldName, fields, typeInfo);
         } else {
-            return Assert.assertShouldNeverHappen("can't handle type: " + unwrappedFieldType);
+            return Assert.assertShouldNeverHappen("can't handle type: %s", unwrappedFieldType);
         }
     }
 

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -83,7 +83,7 @@ public enum TypeKind {
         } else if (type instanceof GraphQLNonNull) {
             return TypeKind.NON_NULL;
         } else {
-            return Assert.assertShouldNeverHappen("Unknown kind of type: " + type);
+            return Assert.assertShouldNeverHappen("Unknown kind of type: %s", type);
         }
     };
 
@@ -496,10 +496,10 @@ public static GraphQLFieldDefinition getFieldDef(GraphQLSchema schema, GraphQLCo
             return TypeNameMetaFieldDef;
         }
 
-        assertTrue(parentType instanceof GraphQLFieldsContainer, "should not happen : parent type must be an object or interface : " + parentType);
+        assertTrue(parentType instanceof GraphQLFieldsContainer, "should not happen : parent type must be an object or interface %s", parentType);
         GraphQLFieldsContainer fieldsContainer = (GraphQLFieldsContainer) parentType;
         GraphQLFieldDefinition fieldDefinition = schema.getFieldVisibility().getFieldDefinition(fieldsContainer, fieldName);
-        Assert.assertTrue(fieldDefinition != null, "Unknown field " + fieldName);
+        Assert.assertTrue(fieldDefinition != null, "Unknown field '%s'", fieldName);
         return fieldDefinition;
     }
 }

File: src/main/java/graphql/introspection/IntrospectionResultToSchema.java
Patch:
@@ -122,7 +122,7 @@ private TypeDefinition createTypeDefinition(Map<String, Object> type) {
             case "SCALAR":
                 return createScalar(type);
             default:
-                return assertShouldNeverHappen("unexpected kind " + kind);
+                return assertShouldNeverHappen("unexpected kind %s", kind);
         }
     }
 
@@ -275,7 +275,7 @@ private Type createTypeIndirection(Map<String, Object> type) {
             case "LIST":
                 return new ListType(createTypeIndirection((Map<String, Object>) type.get("ofType")));
             default:
-                return assertShouldNeverHappen("Unknown kind " + kind);
+                return assertShouldNeverHappen("Unknown kind %s", kind);
         }
     }
 

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -138,7 +138,7 @@ private Object getFromContextStack(ContextProperty contextProperty, boolean requ
             }
         }
         if (required) {
-            Assert.assertShouldNeverHappen("not found" + contextProperty);
+            Assert.assertShouldNeverHappen("not found %s", contextProperty);
         }
         return null;
     }
@@ -202,7 +202,7 @@ private OperationDefinition.Operation parseOperation(GraphqlParser.OperationType
         } else if (operationTypeContext.getText().equals("subscription")) {
             return OperationDefinition.Operation.SUBSCRIPTION;
         } else {
-            return Assert.assertShouldNeverHappen("InternalError: unknown operationTypeContext=" + operationTypeContext.getText());
+            return Assert.assertShouldNeverHappen("InternalError: unknown operationTypeContext=%s", operationTypeContext.getText());
         }
     }
 

File: src/main/java/graphql/schema/SchemaUtil.java
Patch:
@@ -63,7 +63,7 @@ private void collectTypes(GraphQLType root, Map<String, GraphQLType> result) {
         } else if (root instanceof GraphQLTypeReference) {
             // nothing to do
         } else {
-            Assert.assertShouldNeverHappen("Unknown type " + root);
+            Assert.assertShouldNeverHappen("Unknown type %s", root);
         }
     }
 
@@ -218,7 +218,7 @@ private void resolveTypeReferencesForInputFieldsContainer(GraphQLInputFieldsCont
     GraphQLType resolveTypeReference(GraphQLType type, Map<String, GraphQLType> typeMap) {
         if (type instanceof GraphQLTypeReference || typeMap.containsKey(type.getName())) {
             GraphQLType resolvedType = typeMap.get(type.getName());
-            Assert.assertTrue(resolvedType != null, "type " + type.getName() + " not found in schema");
+            Assert.assertTrue(resolvedType != null, "type %s not found in schema", type.getName());
             return resolvedType;
         }
         if (type instanceof GraphQLList) {

File: src/main/java/graphql/schema/idl/SchemaGenerator.java
Patch:
@@ -440,7 +440,7 @@ private GraphQLEnumType buildEnumType(BuildContext buildCtx, EnumTypeDefinition
             Object value;
             if (enumValuesProvider != null) {
                 value = enumValuesProvider.getValue(evd.getName());
-                assertNotNull(value, String.format("EnumValuesProvider for %s returned null for %s", typeDefinition.getName(), evd.getName()));
+                assertNotNull(value, "EnumValuesProvider for %s returned null for %s", typeDefinition.getName(), evd.getName());
             } else {
                 value = evd.getName();
             }
@@ -564,7 +564,7 @@ private Object buildValue(Value value, GraphQLType requiredType) {
             result = buildObjectValue((ObjectValue) value, (GraphQLInputObjectType) requiredType);
         } else if (value != null && !(value instanceof NullValue)) {
             Assert.assertShouldNeverHappen(
-                    "cannot build value of " + requiredType.getName() + " from " + String.valueOf(value));
+                    "cannot build value of %s from %s", requiredType.getName(), String.valueOf(value));
         }
         return result;
     }

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -492,15 +492,15 @@ private PreparsedDocumentEntry parseAndValidate(ExecutionInput executionInput, G
         log.debug("Parsing query: '{}'...", executionInput.getQuery());
         ParseResult parseResult = parse(executionInput, graphQLSchema, instrumentationState);
         if (parseResult.isFailure()) {
-            log.error("Query failed to parse : '{}'", executionInput.getQuery());
+            log.warn("Query failed to parse : '{}'", executionInput.getQuery());
             return new PreparsedDocumentEntry(toInvalidSyntaxError(parseResult.getException()));
         } else {
             final Document document = parseResult.getDocument();
 
             log.debug("Validating query: '{}'", executionInput.getQuery());
             final List<ValidationError> errors = validate(executionInput, document, graphQLSchema, instrumentationState);
             if (!errors.isEmpty()) {
-                log.error("Query failed to validate : '{}'", executionInput.getQuery());
+                log.warn("Query failed to validate : '{}'", executionInput.getQuery());
                 return new PreparsedDocumentEntry(errors);
             }
 

File: src/main/java/graphql/execution/DataFetcherResult.java
Patch:
@@ -1,6 +1,7 @@
 package graphql.execution;
 
 import graphql.GraphQLError;
+import graphql.PublicApi;
 import graphql.schema.DataFetcher;
 
 import java.util.List;
@@ -14,6 +15,7 @@
  *
  * @param <T> The type of the data fetched
  */
+@PublicApi
 public class DataFetcherResult<T> {
 
     private final T data;

File: src/main/java/graphql/execution/AbsoluteGraphQLError.java
Patch:
@@ -10,7 +10,7 @@
 import java.util.Optional;
 import java.util.stream.Collectors;
 
-import static com.sun.tools.javac.util.Assert.checkNonNull;
+import static java.util.Objects.requireNonNull;
 
 /**
  * A {@link GraphQLError} that has been changed from a {@link DataFetcher} relative error to an absolute one.
@@ -22,8 +22,8 @@ class AbsoluteGraphQLError implements GraphQLError {
     private final GraphQLError relativeError;
 
     AbsoluteGraphQLError(ExecutionStrategyParameters executionStrategyParameters, GraphQLError relativeError) {
-        checkNonNull(executionStrategyParameters);
-        this.relativeError = checkNonNull(relativeError);
+        requireNonNull(executionStrategyParameters);
+        this.relativeError = requireNonNull(relativeError);
         List<Object> path = new ArrayList<>();
         path.addAll(executionStrategyParameters.path().toList());
         path.addAll(relativeError.getPath());

File: src/main/java/graphql/execution/NonNullableValueCoercedAsNullException.java
Patch:
@@ -10,6 +10,7 @@
 import graphql.schema.GraphQLType;
 import graphql.schema.GraphQLTypeUtil;
 
+import java.util.Arrays;
 import java.util.List;
 
 import static java.lang.String.format;
@@ -19,10 +20,12 @@
  */
 @PublicApi
 public class NonNullableValueCoercedAsNullException extends GraphQLException implements GraphQLError {
+    private List<SourceLocation> sourceLocations;
 
     public NonNullableValueCoercedAsNullException(VariableDefinition variableDefinition, GraphQLType graphQLType) {
         super(format("Variable '%s' has coerced Null value for NonNull type '%s'",
                 variableDefinition.getName(), GraphQLTypeUtil.getUnwrappedTypeName(graphQLType)));
+        this.sourceLocations = Arrays.asList(variableDefinition.getSourceLocation());
     }
 
     public NonNullableValueCoercedAsNullException(GraphQLInputObjectField inputTypeField) {

File: src/main/java/graphql/schema/PropertyDataFetcher.java
Patch:
@@ -77,6 +77,7 @@ private <O> PropertyDataFetcher(Function<O, T> function) {
      * </pre>
      *
      * @param propertyName the name of the property to retrieve
+     * @param <T>          the type of result
      *
      * @return a new PropertyDataFetcher using the provided function as its source of values
      */
@@ -100,6 +101,7 @@ public static <T> PropertyDataFetcher<T> fetching(String propertyName) {
      *
      * @param function the function to use to obtain a value from the source object
      * @param <O>      the type of the source object
+     * @param <T>      the type of result
      *
      * @return a new PropertyDataFetcher using the provided function as its source of values
      */

File: src/main/java/graphql/execution/instrumentation/tracing/TracingSupport.java
Patch:
@@ -66,7 +66,7 @@ public TracingContext beginField(DataFetchingEnvironment dataFetchingEnvironment
 
             Map<String, Object> fetchMap = new LinkedHashMap<>();
             fetchMap.put("path", typeInfo.getPath().toList());
-            fetchMap.put("parentType", typeInfo.getParentTypeInfo().toAst());
+            fetchMap.put("parentType", typeInfo.getParentTypeInfo().getType().getName());
             fetchMap.put("returnType", typeInfo.toAst());
             fetchMap.put("fieldName", typeInfo.getFieldDefinition().getName());
             fetchMap.put("startOffset", startOffset);

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -7,6 +7,7 @@
 import graphql.execution.ExecutionId;
 import graphql.execution.ExecutionIdProvider;
 import graphql.execution.ExecutionStrategy;
+import graphql.execution.SubscriptionExecutionStrategy;
 import graphql.execution.instrumentation.Instrumentation;
 import graphql.execution.instrumentation.InstrumentationContext;
 import graphql.execution.instrumentation.InstrumentationState;
@@ -148,7 +149,7 @@ private GraphQL(GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, Ex
         this.graphQLSchema = assertNotNull(graphQLSchema, "queryStrategy must be non null");
         this.queryStrategy = queryStrategy != null ? queryStrategy : new AsyncExecutionStrategy();
         this.mutationStrategy = mutationStrategy != null ? mutationStrategy : new AsyncSerialExecutionStrategy();
-        this.subscriptionStrategy = subscriptionStrategy != null ? subscriptionStrategy : new AsyncExecutionStrategy();
+        this.subscriptionStrategy = subscriptionStrategy != null ? subscriptionStrategy : new SubscriptionExecutionStrategy();
         this.idProvider = assertNotNull(idProvider, "idProvider must be non null");
         this.instrumentation = instrumentation;
         this.preparsedDocumentProvider = assertNotNull(preparsedDocumentProvider, "preparsedDocumentProvider must be non null");
@@ -197,7 +198,7 @@ public static class Builder {
         private GraphQLSchema graphQLSchema;
         private ExecutionStrategy queryExecutionStrategy = new AsyncExecutionStrategy();
         private ExecutionStrategy mutationExecutionStrategy = new AsyncSerialExecutionStrategy();
-        private ExecutionStrategy subscriptionExecutionStrategy = new AsyncExecutionStrategy();
+        private ExecutionStrategy subscriptionExecutionStrategy = new SubscriptionExecutionStrategy();
         private ExecutionIdProvider idProvider = DEFAULT_EXECUTION_ID_PROVIDER;
         private Instrumentation instrumentation = NoOpInstrumentation.INSTANCE;
         private PreparsedDocumentProvider preparsedDocumentProvider = NoOpPreparsedDocumentProvider.INSTANCE;

File: src/test/groovy/readme/ExecutionExamples.java
Patch:
@@ -267,4 +267,5 @@ private GraphQL buildSchema() {
         return GraphQL.newGraphQL(schema)
                 .build();
     }
+
 }

File: src/main/java/graphql/schema/AsyncDataFetcher.java
Patch:
@@ -24,6 +24,7 @@ public class AsyncDataFetcher<T> implements DataFetcher<CompletableFuture<T>> {
      * your own {@link Executor} with {@link #async(DataFetcher)} (DataFetcher, Executor)}
      *
      * @param wrappedDataFetcher the data fetcher to run asynchronously
+     * @param <T>                the type of data
      *
      * @return a {@link DataFetcher} that will run the wrappedDataFetcher asynchronously
      */
@@ -40,6 +41,7 @@ public static <T> AsyncDataFetcher<T> async(DataFetcher<T> wrappedDataFetcher) {
      *
      * @param wrappedDataFetcher the data fetcher to run asynchronously
      * @param executor           the executor to run the asynchronous data fetcher in
+     * @param <T>                the type of data
      *
      * @return a {@link DataFetcher} that will run the wrappedDataFetcher asynchronously in
      * the given {@link Executor}

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -416,6 +416,7 @@ private GraphQLObjectType getGraphQLObjectType(ExecutionContext executionContext
                     .field(field)
                     .value(value)
                     .argumentValues(argumentValues)
+                    .context(executionContext.getContext())
                     .schema(executionContext.getGraphQLSchema())
                     .build());
         } else if (fieldType instanceof GraphQLUnionType) {
@@ -424,6 +425,7 @@ private GraphQLObjectType getGraphQLObjectType(ExecutionContext executionContext
                     .field(field)
                     .value(value)
                     .argumentValues(argumentValues)
+                    .context(executionContext.getContext())
                     .schema(executionContext.getGraphQLSchema())
                     .build());
         } else if (fieldType instanceof GraphQLObjectType) {

File: src/main/java/graphql/execution/instrumentation/ChainedInstrumentation.java
Patch:
@@ -137,7 +137,7 @@ public CompletableFuture<ExecutionResult> instrumentExecutionResult(ExecutionRes
             ExecutionResult lastResult = prevResults.size() > 0 ? prevResults.get(prevResults.size() - 1) : executionResult;
             return instrumentation.instrumentExecutionResult(lastResult, parameters.withNewState(state));
         });
-        return resultsFuture.thenApply((results) -> results.get(results.size() - 1));
+        return resultsFuture.thenApply((results) -> results.isEmpty() ? executionResult : results.get(results.size() - 1));
     }
 
     private static class ChainedInstrumentationState implements InstrumentationState {

File: src/main/java/graphql/analysis/MaxQueryComplexityInstrumentation.java
Patch:
@@ -21,8 +21,8 @@
 public class MaxQueryComplexityInstrumentation extends NoOpInstrumentation {
 
 
-    private int maxComplexity;
-    private FieldComplexityCalculator fieldComplexityCalculator;
+    private final int maxComplexity;
+    private final FieldComplexityCalculator fieldComplexityCalculator;
 
     /**
      * new Instrumentation with default complexity calculator which is `1 + childComplexity`

File: src/main/java/graphql/analysis/MaxQueryDepthInstrumentation.java
Patch:
@@ -15,7 +15,7 @@
 @PublicApi
 public class MaxQueryDepthInstrumentation extends NoOpInstrumentation {
 
-    private int maxDepth;
+    private final int maxDepth;
 
     public MaxQueryDepthInstrumentation(int maxDepth) {
         this.maxDepth = maxDepth;

File: src/main/java/graphql/execution/ConditionalNodes.java
Patch:
@@ -12,7 +12,7 @@
 
 public class ConditionalNodes {
 
-    ValuesResolver valuesResolver;
+    final ValuesResolver valuesResolver;
 
     public ConditionalNodes() {
         valuesResolver = new ValuesResolver();

File: src/main/java/graphql/execution/ExecutionPath.java
Patch:
@@ -18,7 +18,7 @@
  */
 @PublicApi
 public class ExecutionPath {
-    private static ExecutionPath ROOT_PATH = new ExecutionPath();
+    private static final ExecutionPath ROOT_PATH = new ExecutionPath();
 
     /**
      * All paths start from here

File: src/main/java/graphql/execution/ExecutorServiceExecutionStrategy.java
Patch:
@@ -35,7 +35,7 @@
 @PublicApi
 public class ExecutorServiceExecutionStrategy extends ExecutionStrategy {
 
-    ExecutorService executorService;
+    final ExecutorService executorService;
 
     public ExecutorServiceExecutionStrategy(ExecutorService executorService) {
         this(executorService, new SimpleDataFetcherExceptionHandler());

File: src/main/java/graphql/execution/FieldCollector.java
Patch:
@@ -28,9 +28,9 @@
 @Internal
 public class FieldCollector {
 
-    private ConditionalNodes conditionalNodes;
+    private final ConditionalNodes conditionalNodes;
 
-    private SchemaUtil schemaUtil = new SchemaUtil();
+    private final SchemaUtil schemaUtil = new SchemaUtil();
 
     public FieldCollector() {
         conditionalNodes = new ConditionalNodes();

File: src/main/java/graphql/execution/FieldCollectorParameters.java
Patch:
@@ -48,8 +48,8 @@ public static Builder newParameters() {
 
     public static class Builder {
         private GraphQLSchema graphQLSchema;
-        private Map<String, FragmentDefinition> fragmentsByName = new LinkedHashMap<>();
-        private Map<String, Object> variables = new LinkedHashMap<>();
+        private final Map<String, FragmentDefinition> fragmentsByName = new LinkedHashMap<>();
+        private final Map<String, Object> variables = new LinkedHashMap<>();
         private GraphQLObjectType objectType;
 
         /**

File: src/main/java/graphql/execution/instrumentation/fieldvalidation/SimpleFieldValidation.java
Patch:
@@ -21,7 +21,7 @@
 @PublicApi
 public class SimpleFieldValidation implements FieldValidation {
 
-    private Map<ExecutionPath, BiFunction<FieldAndArguments, FieldValidationEnvironment, Optional<GraphQLError>>> rules = new LinkedHashMap<>();
+    private final Map<ExecutionPath, BiFunction<FieldAndArguments, FieldValidationEnvironment, Optional<GraphQLError>>> rules = new LinkedHashMap<>();
 
     /**
      * Adds the rule against the field address path.  If the rule returns an error, it will be added to the list of errors

File: src/main/java/graphql/language/DirectiveDefinition.java
Patch:
@@ -5,9 +5,9 @@
 import java.util.List;
 
 public class DirectiveDefinition extends AbstractNode implements Definition {
-    private String name;
-    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
-    private List<DirectiveLocation> directiveLocations = new ArrayList<>();
+    private final String name;
+    private final List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
+    private final List<DirectiveLocation> directiveLocations = new ArrayList<>();
 
     public DirectiveDefinition(String name) {
         this.name = name;

File: src/main/java/graphql/language/DirectiveLocation.java
Patch:
@@ -13,7 +13,7 @@
 //    FRAGMENT_SPREAD
 //    INLINE_FRAGMENT
 public class DirectiveLocation extends AbstractNode {
-    private String name;
+    private final String name;
 
     public DirectiveLocation(String name) {
         this.name = name;

File: src/main/java/graphql/language/EnumTypeDefinition.java
Patch:
@@ -7,9 +7,9 @@
 import static graphql.language.NodeUtil.directivesByName;
 
 public class EnumTypeDefinition extends AbstractNode implements TypeDefinition {
-    private String name;
-    private List<EnumValueDefinition> enumValueDefinitions;
-    private List<Directive> directives;
+    private final String name;
+    private final List<EnumValueDefinition> enumValueDefinitions;
+    private final List<Directive> directives;
 
     public EnumTypeDefinition(String name) {
         this(name, null);

File: src/main/java/graphql/language/EnumValueDefinition.java
Patch:
@@ -6,8 +6,8 @@
 import java.util.Map;
 
 public class EnumValueDefinition extends AbstractNode {
-    private String name;
-    private List<Directive> directives;
+    private final String name;
+    private final List<Directive> directives;
 
     public EnumValueDefinition(String name) {
         this(name, null);

File: src/main/java/graphql/language/FieldDefinition.java
Patch:
@@ -8,10 +8,10 @@
 import static graphql.language.NodeUtil.directivesByName;
 
 public class FieldDefinition extends AbstractNode {
-    private String name;
+    private final String name;
     private Type type;
-    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
-    private List<Directive> directives = new ArrayList<>();
+    private final List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
+    private final List<Directive> directives = new ArrayList<>();
 
     public FieldDefinition(String name) {
         this.name = name;

File: src/main/java/graphql/language/InputObjectTypeDefinition.java
Patch:
@@ -8,9 +8,9 @@
 import static graphql.language.NodeUtil.directivesByName;
 
 public class InputObjectTypeDefinition extends AbstractNode implements TypeDefinition {
-    private String name;
-    private List<Directive> directives = new ArrayList<>();
-    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
+    private final String name;
+    private final List<Directive> directives = new ArrayList<>();
+    private final List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
 
     public InputObjectTypeDefinition(String name) {
         this.name = name;

File: src/main/java/graphql/language/InputValueDefinition.java
Patch:
@@ -8,10 +8,10 @@
 import static graphql.language.NodeUtil.directivesByName;
 
 public class InputValueDefinition extends AbstractNode {
-    private String name;
+    private final String name;
     private Type type;
     private Value defaultValue;
-    private List<Directive> directives = new ArrayList<>();
+    private final List<Directive> directives = new ArrayList<>();
 
     public InputValueDefinition(String name) {
         this(name, null);

File: src/main/java/graphql/language/InterfaceTypeDefinition.java
Patch:
@@ -8,9 +8,9 @@
 import static graphql.language.NodeUtil.directivesByName;
 
 public class InterfaceTypeDefinition extends AbstractNode implements TypeDefinition {
-    private String name;
-    private List<FieldDefinition> definitions = new ArrayList<>();
-    private List<Directive> directives = new ArrayList<>();
+    private final String name;
+    private final List<FieldDefinition> definitions = new ArrayList<>();
+    private final List<Directive> directives = new ArrayList<>();
 
     public InterfaceTypeDefinition(String name) {
         this.name = name;

File: src/main/java/graphql/language/NullValue.java
Patch:
@@ -6,7 +6,7 @@
 
 public class NullValue extends AbstractNode implements Value {
 
-    public static NullValue Null = new NullValue();
+    public static final NullValue Null = new NullValue();
 
     private NullValue() {
     }

File: src/main/java/graphql/language/ObjectField.java
Patch:
@@ -6,8 +6,8 @@
 
 public class ObjectField extends AbstractNode {
 
-    private String name;
-    private Value value;
+    private final String name;
+    private final Value value;
 
     public ObjectField(String name, Value value) {
         this.name = name;

File: src/main/java/graphql/language/ObjectTypeDefinition.java
Patch:
@@ -9,9 +9,9 @@
 
 public class ObjectTypeDefinition extends AbstractNode implements TypeDefinition {
     private String name;
-    private List<Type> implementz = new ArrayList<>();
-    private List<Directive> directives = new ArrayList<>();
-    private List<FieldDefinition> fieldDefinitions = new ArrayList<>();
+    private final List<Type> implementz = new ArrayList<>();
+    private final List<Directive> directives = new ArrayList<>();
+    private final List<FieldDefinition> fieldDefinitions = new ArrayList<>();
 
     public ObjectTypeDefinition(String name) {
         this.name = name;

File: src/main/java/graphql/language/ObjectValue.java
Patch:
@@ -6,7 +6,7 @@
 
 public class ObjectValue extends AbstractNode implements Value {
 
-    private List<ObjectField> objectFields = new ArrayList<>();
+    private final List<ObjectField> objectFields = new ArrayList<>();
 
     public ObjectValue() {
     }

File: src/main/java/graphql/language/OperationTypeDefinition.java
Patch:
@@ -8,7 +8,7 @@
 
 @Internal
 public class OperationTypeDefinition extends AbstractNode {
-    private String name;
+    private final String name;
     private Type type;
 
     public OperationTypeDefinition() {

File: src/main/java/graphql/language/ScalarTypeDefinition.java
Patch:
@@ -8,8 +8,8 @@
 import static graphql.language.NodeUtil.directivesByName;
 
 public class ScalarTypeDefinition extends AbstractNode implements TypeDefinition {
-    private String name;
-    private List<Directive> directives = new ArrayList<>();
+    private final String name;
+    private final List<Directive> directives = new ArrayList<>();
 
     public ScalarTypeDefinition(String name) {
         this.name = name;

File: src/main/java/graphql/language/SchemaDefinition.java
Patch:
@@ -8,8 +8,8 @@
 import static graphql.language.NodeUtil.directivesByName;
 
 public class SchemaDefinition extends AbstractNode implements Definition {
-    private List<Directive> directives = new ArrayList<>();
-    private List<OperationTypeDefinition> operationTypeDefinitions = new ArrayList<>();
+    private final List<Directive> directives = new ArrayList<>();
+    private final List<OperationTypeDefinition> operationTypeDefinitions = new ArrayList<>();
 
     public SchemaDefinition() {
     }

File: src/main/java/graphql/language/UnionTypeDefinition.java
Patch:
@@ -8,9 +8,9 @@
 import static graphql.language.NodeUtil.directivesByName;
 
 public class UnionTypeDefinition extends AbstractNode implements TypeDefinition {
-    private String name;
-    private List<Directive> directives = new ArrayList<>();
-    private List<Type> memberTypes = new ArrayList<>();
+    private final String name;
+    private final List<Directive> directives = new ArrayList<>();
+    private final List<Type> memberTypes = new ArrayList<>();
 
     public UnionTypeDefinition(String name) {
         this.name = name;

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -98,16 +98,16 @@ private enum ContextProperty {
     }
 
     static class ContextEntry {
-        ContextProperty contextProperty;
-        Object value;
+        final ContextProperty contextProperty;
+        final Object value;
 
         public ContextEntry(ContextProperty contextProperty, Object value) {
             this.contextProperty = contextProperty;
             this.value = value;
         }
     }
 
-    private Deque<ContextEntry> contextStack = new ArrayDeque<>();
+    private final Deque<ContextEntry> contextStack = new ArrayDeque<>();
 
 
     private void addContextProperty(ContextProperty contextProperty, Object value) {

File: src/main/java/graphql/relay/Relay.java
Patch:
@@ -39,7 +39,7 @@ public class Relay {
 
     public static final String NODE = "Node";
 
-    private GraphQLObjectType pageInfoType = newObject()
+    private final GraphQLObjectType pageInfoType = newObject()
             .name("PageInfo")
             .description("Information about pagination in a connection.")
             .field(newFieldDefinition()
@@ -209,8 +209,8 @@ public ResolvedGlobalId(String type, String id) {
             this.id = id;
         }
 
-        private String type;
-        private String id;
+        private final String type;
+        private final String id;
 
         public String getType() {
             return type;

File: src/main/java/graphql/schema/GraphQLDirective.java
Patch:
@@ -103,7 +103,7 @@ public static Builder newDirective() {
     public static class Builder {
 
         private String name;
-        private EnumSet<DirectiveLocation> locations = EnumSet.noneOf(DirectiveLocation.class);
+        private final EnumSet<DirectiveLocation> locations = EnumSet.noneOf(DirectiveLocation.class);
         private final List<GraphQLArgument> arguments = new ArrayList<>();
         private String description;
         private boolean onOperation;

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -129,7 +129,7 @@ public static class Builder {
         private String description;
         private GraphQLOutputType type;
         private DataFetcherFactory<?> dataFetcherFactory;
-        private List<GraphQLArgument> arguments = new ArrayList<>();
+        private final List<GraphQLArgument> arguments = new ArrayList<>();
         private String deprecationReason;
         private boolean isField;
         private FieldDefinition definition;

File: src/main/java/graphql/schema/GraphQLInputObjectType.java
Patch:
@@ -92,7 +92,7 @@ public static class Builder {
         private String name;
         private String description;
         private InputObjectTypeDefinition definition;
-        private List<GraphQLInputObjectField> fields = new ArrayList<>();
+        private final List<GraphQLInputObjectField> fields = new ArrayList<>();
 
         public Builder name(String name) {
             this.name = name;

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -104,7 +104,7 @@ public static Builder newInterface() {
     public static class Builder {
         private String name;
         private String description;
-        private List<GraphQLFieldDefinition> fields = new ArrayList<>();
+        private final List<GraphQLFieldDefinition> fields = new ArrayList<>();
         private TypeResolver typeResolver;
         private InterfaceTypeDefinition definition;
 

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -119,8 +119,8 @@ public static Builder newObject() {
     public static class Builder {
         private String name;
         private String description;
-        private List<GraphQLFieldDefinition> fieldDefinitions = new ArrayList<>();
-        private List<GraphQLOutputType> interfaces = new ArrayList<>();
+        private final List<GraphQLFieldDefinition> fieldDefinitions = new ArrayList<>();
+        private final List<GraphQLOutputType> interfaces = new ArrayList<>();
         private ObjectTypeDefinition definition;
 
         public Builder name(String name) {

File: src/main/java/graphql/schema/GraphQLUnionType.java
Patch:
@@ -92,7 +92,7 @@ public static Builder newUnionType() {
     public static class Builder {
         private String name;
         private String description;
-        private List<GraphQLOutputType> types = new ArrayList<>();
+        private final List<GraphQLOutputType> types = new ArrayList<>();
         private TypeResolver typeResolver;
         private UnionTypeDefinition definition;
 

File: src/main/java/graphql/schema/diff/DiffEvent.java
Patch:
@@ -94,7 +94,7 @@ public static class Builder {
         TypeKind typeOfType;
         String reasonMsg;
         String fieldName;
-        List<String> components = new ArrayList<>();
+        final List<String> components = new ArrayList<>();
 
         public Builder level(DiffLevel level) {
             this.level = level;

File: src/main/java/graphql/schema/idl/CombinedWiringFactory.java
Patch:
@@ -15,7 +15,7 @@
  * whether it handles a type and delegates to the first one to answer yes.
  */
 public class CombinedWiringFactory implements WiringFactory {
-    private List<WiringFactory> factories;
+    private final List<WiringFactory> factories;
 
     public CombinedWiringFactory(List<WiringFactory> factories) {
         assertNotNull(factories, "You must provide a list of wiring factories");

File: src/main/java/graphql/schema/idl/errors/BaseError.java
Patch:
@@ -13,7 +13,7 @@
 class BaseError extends GraphQLException implements GraphQLError {
     protected static final SourceLocation NO_WHERE = new SourceLocation(-1, -1);
 
-    private Node node;
+    private final Node node;
 
     public BaseError(Node node, String msg) {
         super(msg);

File: src/main/java/graphql/schema/visibility/DefaultGraphqlFieldVisibility.java
Patch:
@@ -10,7 +10,7 @@
  */
 public class DefaultGraphqlFieldVisibility implements GraphqlFieldVisibility {
 
-    public static DefaultGraphqlFieldVisibility DEFAULT_FIELD_VISIBILITY = new DefaultGraphqlFieldVisibility();
+    public static final DefaultGraphqlFieldVisibility DEFAULT_FIELD_VISIBILITY = new DefaultGraphqlFieldVisibility();
 
     @Override
     public List<GraphQLFieldDefinition> getFieldDefinitions(GraphQLFieldsContainer fieldsContainer) {

File: src/main/java/graphql/validation/ArgumentValidationUtil.java
Patch:
@@ -14,12 +14,12 @@
 
 public class ArgumentValidationUtil extends ValidationUtil {
 
-    private List<String> argumentNames = new ArrayList<>();
+    private final List<String> argumentNames = new ArrayList<>();
     private Value argumentValue;
     private String errorMessage;
-    private List<Object> arguments = new ArrayList<>();
+    private final List<Object> arguments = new ArrayList<>();
 
-    private String argumentName;
+    private final String argumentName;
 
     public ArgumentValidationUtil(Argument argument) {
         argumentName = argument.getName();

File: src/main/java/graphql/validation/ValidationContext.java
Patch:
@@ -22,7 +22,7 @@ public class ValidationContext {
     private final GraphQLSchema schema;
     private final Document document;
 
-    private TraversalContext traversalContext;
+    private final TraversalContext traversalContext;
     private final Map<String, FragmentDefinition> fragmentDefinitionMap = new LinkedHashMap<>();
 
 

File: src/main/java/graphql/validation/rules/NoFragmentCycles.java
Patch:
@@ -20,7 +20,7 @@
 
 public class NoFragmentCycles extends AbstractRule {
 
-    private Map<String, List<FragmentSpread>> fragmentSpreads = new LinkedHashMap<>();
+    private final Map<String, List<FragmentSpread>> fragmentSpreads = new LinkedHashMap<>();
 
 
     public NoFragmentCycles(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {

File: src/main/java/graphql/validation/rules/NoUndefinedVariables.java
Patch:
@@ -16,7 +16,7 @@
 
 public class NoUndefinedVariables extends AbstractRule {
 
-    private Set<String> variableNames = new LinkedHashSet<>();
+    private final Set<String> variableNames = new LinkedHashSet<>();
 
     public NoUndefinedVariables(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
         super(validationContext, validationErrorCollector);

File: src/main/java/graphql/validation/rules/NoUnusedFragments.java
Patch:
@@ -22,7 +22,7 @@ public class NoUnusedFragments extends AbstractRule {
     private final List<FragmentDefinition> allDeclaredFragments = new ArrayList<>();
 
     private List<String> usedFragments = new ArrayList<>();
-    private Map<String, List<String>> spreadsInDefinition = new LinkedHashMap<>();
+    private final Map<String, List<String>> spreadsInDefinition = new LinkedHashMap<>();
     private final List<List<String>> fragmentsUsedDirectlyInOperation = new ArrayList<>();
 
     public NoUnusedFragments(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {

File: src/main/java/graphql/validation/rules/NoUnusedVariables.java
Patch:
@@ -17,8 +17,8 @@
 
 public class NoUnusedVariables extends AbstractRule {
 
-    private List<VariableDefinition> variableDefinitions = new ArrayList<>();
-    private Set<String> usedVariables = new LinkedHashSet<>();
+    private final List<VariableDefinition> variableDefinitions = new ArrayList<>();
+    private final Set<String> usedVariables = new LinkedHashSet<>();
 
     public NoUnusedVariables(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
         super(validationContext, validationErrorCollector);

File: src/main/java/graphql/validation/rules/ScalarLeafs.java
Patch:
@@ -12,7 +12,7 @@
 
 public class ScalarLeafs extends AbstractRule {
 
-    private SchemaUtil schemaUtil = new SchemaUtil();
+    private final SchemaUtil schemaUtil = new SchemaUtil();
 
     public ScalarLeafs(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
         super(validationContext, validationErrorCollector);

File: src/main/java/graphql/validation/rules/VariablesAreInputTypes.java
Patch:
@@ -13,7 +13,7 @@
 
 public class VariablesAreInputTypes extends AbstractRule {
 
-    private SchemaUtil schemaUtil = new SchemaUtil();
+    private final SchemaUtil schemaUtil = new SchemaUtil();
 
     public VariablesAreInputTypes(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
         super(validationContext, validationErrorCollector);

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -90,7 +90,7 @@ public String toString() {
         return "GraphQLInterfaceType{" +
                 "name='" + name + '\'' +
                 ", description='" + description + '\'' +
-                ", fieldDefinitionsByName=" + fieldDefinitionsByName +
+                ", fieldDefinitionsByName=" + fieldDefinitionsByName.keySet() +
                 ", typeResolver=" + typeResolver +
                 '}';
     }

File: src/main/java/graphql/execution/NonNullableFieldValidator.java
Patch:
@@ -25,6 +25,7 @@ public NonNullableFieldValidator(ExecutionContext executionContext, ExecutionTyp
      *
      * @param path   the path to this place
      * @param result the result to check
+     * @param <T>    the type of the result
      *
      * @return the result back
      *

File: src/main/java/graphql/schema/idl/SchemaPrinter.java
Patch:
@@ -93,7 +93,7 @@ public Options includeScalarTypes(boolean flag) {
 
         /**
          * This will allow you to include the graphql 'extended' scalar types that come with graphql-java such as
-         * {@link graphql.Scalars#GraphQLBigDecimal} or {@link graphql.Scalars#GraphQLBigInteger}
+         * GraphQLBigDecimal or GraphQLBigInteger
          *
          * @param flag whether to include them
          *
@@ -173,7 +173,7 @@ private TypePrinter<GraphQLScalarType> scalarPrinter() {
             if (ScalarInfo.isStandardScalar(type)) {
                 printScalar = false;
                 //noinspection RedundantIfStatement
-                if (options.isIncludeExtendedScalars() && ! ScalarInfo.isGraphqlSpecifiedScalar(type)) {
+                if (options.isIncludeExtendedScalars() && !ScalarInfo.isGraphqlSpecifiedScalar(type)) {
                     printScalar = true;
                 }
             } else {

File: src/main/java/graphql/ExceptionWhileDataFetching.java
Patch:
@@ -12,6 +12,9 @@
 import static graphql.Assert.assertNotNull;
 import static java.lang.String.format;
 
+/**
+ * This graphql error will be used if a runtime exception is encountered while a data fetcher is invoked
+ */
 @PublicApi
 public class ExceptionWhileDataFetching implements GraphQLError {
 

File: src/main/java/graphql/schema/DataFetchingEnvironment.java
Patch:
@@ -10,7 +10,8 @@
 import java.util.Map;
 
 /**
- * A DataFetchingEnvironment instance of passed to a {@link DataFetcher} as an execution context parameter
+ * A DataFetchingEnvironment instance of passed to a {@link DataFetcher} as a execution context and its
+ * the place where you can find out information to help you resolve a data value given a graphql field input
  */
 @PublicApi
 public interface DataFetchingEnvironment {

File: src/main/java/graphql/schema/DataFetchingFieldSelectionSetImpl.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.schema;
 
+import graphql.Internal;
 import graphql.execution.ExecutionContext;
 import graphql.execution.ExecutionTypeInfo;
 import graphql.execution.FieldCollector;
@@ -10,6 +11,7 @@
 import java.util.List;
 import java.util.Map;
 
+@Internal
 public class DataFetchingFieldSelectionSetImpl implements DataFetchingFieldSelectionSet {
 
     private final static DataFetchingFieldSelectionSet NOOP = Collections::emptyMap;

File: src/main/java/graphql/schema/GraphQLFieldsContainer.java
Patch:
@@ -5,6 +5,9 @@
 
 /**
  * Types that can contain output fields are marked with this interface
+ *
+ * @see graphql.schema.GraphQLObjectType
+ * @see graphql.schema.GraphQLInterfaceType
  */
 public interface GraphQLFieldsContainer extends GraphQLType {
 

File: src/main/java/graphql/schema/GraphQLTypeUtil.java
Patch:
@@ -1,5 +1,8 @@
 package graphql.schema;
 
+import graphql.Internal;
+
+@Internal
 public class GraphQLTypeUtil {
 
     /**

File: src/main/java/graphql/schema/TypeResolver.java
Patch:
@@ -5,7 +5,7 @@
 import graphql.TypeResolutionEnvironment;
 
 /**
- * This is called during type resolution to work out what graphql type should be used
+ * This is called during type resolution to work out what concrete {@link graphql.schema.GraphQLObjectType} should be used
  * dynamically during runtime for {@link GraphQLInterfaceType}s and {@link GraphQLUnionType}s
  */
 @PublicSpi

File: src/main/java/graphql/schema/TypeResolverProxy.java
Patch:
@@ -1,8 +1,10 @@
 package graphql.schema;
 
 
+import graphql.Internal;
 import graphql.TypeResolutionEnvironment;
 
+@Internal
 public class TypeResolverProxy implements TypeResolver {
 
     private TypeResolver typeResolver;

File: src/main/java/graphql/execution/InputMapDefinesTooManyFieldsException.java
Patch:
@@ -12,7 +12,7 @@
 public class InputMapDefinesTooManyFieldsException extends GraphQLException {
 
     public InputMapDefinesTooManyFieldsException(GraphQLType graphQLType, String fieldName) {
-        super(String.format("The variables input contains a field name '%s' that is not defined for input object type '%s' ", GraphQLTypeUtil.getUnwrappedTypeName(graphQLType), fieldName));
+        super(String.format("The variables input contains a field name '%s' that is not defined for input object type '%s' ", fieldName, GraphQLTypeUtil.getUnwrappedTypeName(graphQLType)));
     }
 
 }

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -399,6 +399,9 @@ public CompletableFuture<ExecutionResult> executeAsync(ExecutionInput executionI
             return executionResult;
         } catch (AbortExecutionException abortException) {
             ExecutionResultImpl executionResult = new ExecutionResultImpl(abortException);
+            if (!abortException.getUnderlyingErrors().isEmpty()) {
+                executionResult = new ExecutionResultImpl(abortException.getUnderlyingErrors());
+            }
             return CompletableFuture.completedFuture(executionResult);
         }
     }

File: src/main/java/graphql/analysis/MaxQueryComplexityInstrumentation.java
Patch:
@@ -15,7 +15,7 @@
 import static graphql.Assert.assertNotNull;
 
 /**
- * Prevents execution if the query complexity is greater than the specified maxDepth
+ * Prevents execution if the query complexity is greater than the specified maxComplexity
  */
 @PublicApi
 public class MaxQueryComplexityInstrumentation extends NoOpInstrumentation {

File: src/main/java/graphql/analysis/MaximumQueryDepthInstrumentation.java
Patch:
@@ -32,7 +32,7 @@ public InstrumentationContext<List<ValidationError>> beginValidation(Instrumenta
                     getOperationResult.fragmentsByName,
                     parameters.getVariables()
             );
-            int depth = (int) queryTraversal.reducePreOrder((env, acc) -> Math.max(getPathLength(env.getPath()), (Integer) acc), 0);
+            int depth = queryTraversal.reducePreOrder((env, acc) -> Math.max(getPathLength(env.getPath()), acc), 0);
             if (depth > maxDepth) {
                 throw new AbortExecutionException("maximum query depth exceeded " + depth + " > " + maxDepth);
             }

File: src/main/java/graphql/visitor/QueryVisitor.java
Patch:
@@ -1,10 +1,11 @@
 package graphql.visitor;
 
 import graphql.language.Field;
+import graphql.schema.GraphQLCompositeType;
 import graphql.schema.GraphQLFieldDefinition;
 
 public interface QueryVisitor {
 
-    void visitField(Field field, GraphQLFieldDefinition fieldDefinition, VisitPath visitPath);
+    void visitField(Field field, GraphQLFieldDefinition fieldDefinition, GraphQLCompositeType parent, VisitPath visitPath);
 
 }

File: src/main/java/graphql/relay/DefaultEdge.java
Patch:
@@ -8,8 +8,8 @@
 public class DefaultEdge<T> implements Edge<T> {
 
     public DefaultEdge(T node, ConnectionCursor cursor) {
-        this.node = assertNotNull(node, "node cannot be null");
         this.cursor = assertNotNull(cursor, "cursor cannot be null");
+        this.node = node;
     }
 
     /**

File: src/main/java/graphql/MutationNotSupportedError.java
Patch:
@@ -33,13 +33,14 @@ public String toString() {
         return "MutationNotSupportedError";
     }
 
+    @SuppressWarnings("EqualsWhichDoesntCheckParameterClass")
     @Override
     public boolean equals(Object o) {
-        return Helper.equals(this, o);
+        return GraphqlErrorHelper.equals(this, o);
     }
 
     @Override
     public int hashCode() {
-        return Helper.hashCode(this);
+        return GraphqlErrorHelper.hashCode(this);
     }
 }

File: src/main/java/graphql/execution/NonNullableFieldValidator.java
Patch:
@@ -32,7 +32,7 @@ <T> T validate(ExecutionPath path, T result) throws NonNullableFieldWasNullExcep
             if (typeInfo.isNonNullType()) {
                 // see http://facebook.github.io/graphql/#sec-Errors-and-Non-Nullability
                 NonNullableFieldWasNullException nonNullException = new NonNullableFieldWasNullException(typeInfo, path);
-                executionContext.addError(nonNullException, path);
+                executionContext.addError(new NonNullableFieldWasNullError(nonNullException), path);
                 throw nonNullException;
             }
         }

File: src/test/groovy/example/http/HttpMain.java
Patch:
@@ -54,6 +54,9 @@ public void handle(String target, Request baseRequest, HttpServletRequest reques
         if ("/graphql".equals(target) || "/".equals(target)) {
             handleStarWars(request, response);
         }
+        if (target.startsWith("/executionresult")) {
+            new ExecutionResultJSONTesting(target, response);
+        }
         baseRequest.setHandled(true);
     }
 

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -302,7 +302,6 @@ public ExecutionResult execute(ExecutionInput.Builder executionInputBuilder) {
      * Executes the graphql query using calling the builder function and giving it a new builder.
      * <p>
      * This allows a lambda style like :
-     * <p>
      * <pre>
      * {@code
      *    ExecutionResult result = graphql.execute(input -> input.query("{hello}").root(startingObj).context(contextObj));
@@ -357,7 +356,6 @@ public CompletableFuture<ExecutionResult> executeAsync(ExecutionInput.Builder ex
      * which is the result of executing the provided query.
      * <p>
      * This allows a lambda style like :
-     * <p>
      * <pre>
      * {@code
      *    ExecutionResult result = graphql.execute(input -> input.query("{hello}").root(startingObj).context(contextObj));

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -585,7 +585,7 @@ protected GraphQLFieldDefinition getFieldDef(GraphQLSchema schema, GraphQLObject
             return TypeNameMetaFieldDef;
         }
 
-        GraphQLFieldDefinition fieldDefinition = parentType.getFieldDefinition(field.getName());
+        GraphQLFieldDefinition fieldDefinition = schema.getFieldVisibility().getFieldDefinition(parentType, field.getName());
         if (fieldDefinition == null) {
             throw new GraphQLException("Unknown field " + field.getName());
         }

File: src/main/java/graphql/schema/SchemaUtil.java
Patch:
@@ -108,6 +108,7 @@ private void collectTypesForInterfaces(GraphQLInterfaceType interfaceType, Map<S
         }
         result.put(interfaceType.getName(), interfaceType);
 
+        // this deliberately has open field visibility as its collecting on the whole schema
         for (GraphQLFieldDefinition fieldDefinition : interfaceType.getFieldDefinitions()) {
             collectTypes(fieldDefinition.getType(), result);
             for (GraphQLArgument fieldArgument : fieldDefinition.getArguments()) {
@@ -124,6 +125,7 @@ private void collectTypesForObjects(GraphQLObjectType objectType, Map<String, Gr
         }
         result.put(objectType.getName(), objectType);
 
+        // this deliberately has open field visibility as its collecting on the whole schema
         for (GraphQLFieldDefinition fieldDefinition : objectType.getFieldDefinitions()) {
             collectTypes(fieldDefinition.getType(), result);
             for (GraphQLArgument fieldArgument : fieldDefinition.getArguments()) {

File: src/main/java/graphql/schema/validation/SchemaValidator.java
Patch:
@@ -62,6 +62,8 @@ private void traverse(GraphQLOutputType root, List<SchemaValidationRule> rules,
         }
         processed.add(root);
         if (root instanceof GraphQLFieldsContainer) {
+            // this deliberately has open field visibility here since its validating the schema
+            // when completely open
             for (GraphQLFieldDefinition fieldDefinition : ((GraphQLFieldsContainer) root).getFieldDefinitions()) {
                 for (SchemaValidationRule rule : rules) {
                     rule.check(fieldDefinition, validationErrorCollector);

File: src/main/java/graphql/validation/TraversalContext.java
Patch:
@@ -284,7 +284,7 @@ private GraphQLFieldDefinition getFieldDef(GraphQLSchema schema, GraphQLType par
             return TypeNameMetaFieldDef;
         }
         if (parentType instanceof GraphQLFieldsContainer) {
-            return ((GraphQLFieldsContainer) parentType).getFieldDefinition(field.getName());
+            return schema.getFieldVisibility().getFieldDefinition((GraphQLFieldsContainer) parentType,field.getName());
         }
         return null;
     }

File: src/main/java/graphql/validation/rules/FieldsOnCorrectType.java
Patch:
@@ -25,7 +25,7 @@ public void checkField(Field field) {
         if (parentType == null) return;
         GraphQLFieldDefinition fieldDef = getValidationContext().getFieldDef();
         if (fieldDef == null) {
-            String message = String.format("Field %s is undefined", field.getName());
+            String message = String.format("Field '%s' in type '%s' is undefined", field.getName(), parentType.getName());
             addError(new ValidationError(ValidationErrorType.FieldUndefined, field.getSourceLocation(), message));
         }
 

File: src/main/java/graphql/ExecutionResultImpl.java
Patch:
@@ -28,7 +28,7 @@ public ExecutionResultImpl(Object data, List<? extends GraphQLError> errors) {
     }
 
     public ExecutionResultImpl(Object data, List<? extends GraphQLError> errors, Map<Object, Object> extensions) {
-        this(data != null, data, errors, extensions);
+        this(true, data, errors, extensions);
     }
 
     private ExecutionResultImpl(boolean dataPresent, Object data, List<? extends GraphQLError> errors, Map<Object, Object> extensions) {

File: src/main/java/graphql/validation/rules/ArgumentsOfCorrectType.java
Patch:
@@ -15,9 +15,9 @@ public ArgumentsOfCorrectType(ValidationContext validationContext, ValidationErr
     public void checkArgument(Argument argument) {
         GraphQLArgument fieldArgument = getValidationContext().getArgument();
         if (fieldArgument == null) return;
-        if (!getValidationUtil().isValidLiteralValue(argument.getValue(), fieldArgument.getType())) {
-            String message = String.format("argument value %s has wrong type", argument.getValue());
-            addError(new ValidationError(ValidationErrorType.WrongType, argument.getSourceLocation(), message));
+        ArgumentValidationUtil validationUtil = new ArgumentValidationUtil(argument);
+        if (!validationUtil.isValidLiteralValue(argument.getValue(), fieldArgument.getType())) {
+            addError(new ValidationError(ValidationErrorType.WrongType, argument.getSourceLocation(), validationUtil.getMessage()));
         }
     }
 

File: src/main/java/graphql/execution/DataFetcherExceptionHandler.java
Patch:
@@ -14,7 +14,7 @@ public interface DataFetcherExceptionHandler extends Consumer<DataFetcherExcepti
     /**
      * When an exception during a call to a {@link DataFetcher} then this handler
      * is called back to shape the error that should be placed in the list of errors
-     * via {@link ExecutionContext#addError(GraphQLError)}
+     * via {@link ExecutionContext#addError(GraphQLError, graphql.execution.ExecutionPath)}
      *
      * @param handlerParameters the parameters to this callback
      */

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -491,7 +491,7 @@ protected CompletableFuture<ExecutionResult> completeValueForScalar(ExecutionCon
     private Object handleCoercionProblem(ExecutionContext context, ExecutionStrategyParameters parameters, CoercingSerializeException e) {
         SerializationError error = new SerializationError(parameters.path(), e);
         log.warn(error.getMessage(), e);
-        context.addError(error);
+        context.addError(error, parameters.path());
         return null;
     }
 
@@ -544,7 +544,6 @@ protected CompletableFuture<ExecutionResult> completeValueForList(ExecutionConte
                 completedResults.add(completedValue.getData());
             }
             overallResult.complete(new ExecutionResultImpl(completedResults, null));
-            return;
         });
         return overallResult;
     }

File: src/main/java/graphql/execution/NonNullableFieldValidator.java
Patch:
@@ -32,7 +32,7 @@ <T> T validate(ExecutionPath path, T result) throws NonNullableFieldWasNullExcep
             if (typeInfo.isNonNullType()) {
                 // see http://facebook.github.io/graphql/#sec-Errors-and-Non-Nullability
                 NonNullableFieldWasNullException nonNullException = new NonNullableFieldWasNullException(typeInfo, path);
-                executionContext.addError(nonNullException);
+                executionContext.addError(nonNullException, path);
                 throw nonNullException;
             }
         }

File: src/main/java/graphql/execution/SimpleDataFetcherExceptionHandler.java
Patch:
@@ -19,7 +19,7 @@ public void accept(DataFetcherExceptionHandlerParameters handlerParameters) {
         ExecutionPath path = handlerParameters.getPath();
 
         ExceptionWhileDataFetching error = new ExceptionWhileDataFetching(path, exception, sourceLocation);
-        handlerParameters.getExecutionContext().addError(error);
+        handlerParameters.getExecutionContext().addError(error, handlerParameters.getPath());
         log.warn(error.getMessage(), exception);
     }
 }

File: src/main/java/graphql/MutationNotSupportedError.java
Patch:
@@ -15,7 +15,7 @@ public class MutationNotSupportedError implements GraphQLError {
 
     @Override
     public String getMessage() {
-        return "Mutations are not supported onm this schema";
+        return "Mutations are not supported on this schema";
     }
 
     @Override

File: src/test/groovy/readme/InstrumentationExamples.java
Patch:
@@ -48,10 +48,10 @@ private GraphQL buildSchema() {
     }
 
     class CustomInstrumentationState implements InstrumentationState {
-        private Map<String, Object> anyStateYourLike = new HashMap<>();
+        private Map<String, Object> anyStateYouLike = new HashMap<>();
 
         void recordTiming(String key, long time) {
-            anyStateYourLike.put(key, time);
+            anyStateYouLike.put(key, time);
         }
     }
 

File: src/main/java/graphql/execution/instrumentation/Instrumentation.java
Patch:
@@ -112,12 +112,12 @@ default DataFetcher<?> instrumentDataFetcher(DataFetcher<?> dataFetcher, Instrum
     /**
      * This is called to allow instrumentation to instrument the execution result in some way
      *
-     * @param executionResultFuture a {@link java.util.concurrent.CompletableFuture} of the result to instrument
+     * @param executionResult {@link java.util.concurrent.CompletableFuture} of the result to instrument
      * @param parameters            the parameters to this step
      *
      * @return a new execution result completable future
      */
-    default CompletableFuture<ExecutionResult> instrumentExecutionResult(CompletableFuture<ExecutionResult> executionResultFuture, InstrumentationExecutionParameters parameters) {
-        return executionResultFuture;
+    default CompletableFuture<ExecutionResult> instrumentExecutionResult(ExecutionResult executionResult, InstrumentationExecutionParameters parameters) {
+        return CompletableFuture.completedFuture(executionResult);
     }
 }

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -122,7 +122,7 @@ private CompletableFuture<ExecutionResult> executeOperation(ExecutionContext exe
             result = completedFuture(new ExecutionResultImpl(null, executionContext.getErrors()));
         }
 
-        result.thenAccept(dataFetchCtx::onEnd);
+        result = result.whenComplete(dataFetchCtx::onEnd);
 
         return result;
     }

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -162,7 +162,7 @@ protected CompletableFuture<ExecutionResult> resolveField(ExecutionContext execu
                 .thenCompose((fetchedValue) ->
                         completeField(executionContext, parameters, fetchedValue));
 
-        result.thenAccept(fieldCtx::onEnd);
+        result.whenComplete(fieldCtx::onEnd);
         return result;
     }
 
@@ -218,8 +218,8 @@ protected CompletableFuture<Object> fetchField(ExecutionContext executionContext
             fetchedValue = new CompletableFuture<>();
             fetchedValue.completeExceptionally(e);
         }
-        fetchedValue.thenAccept(fetchCtx::onEnd);
         return fetchedValue.handle((result, exception) -> {
+            fetchCtx.onEnd(result,exception);
             if (exception != null) {
                 handleFetchingException(executionContext, parameters, field, fieldDef, argumentValues, environment, fetchCtx, exception);
                 return null;
@@ -237,7 +237,7 @@ private void handleFetchingException(ExecutionContext executionContext,
                                          DataFetchingEnvironment environment,
                                          InstrumentationContext<Object> fetchCtx,
                                          Throwable e) {
-        fetchCtx.onEnd(e);
+        fetchCtx.onEnd(null, e);
 
         DataFetcherExceptionHandlerParameters handlerParameters = DataFetcherExceptionHandlerParameters.newExceptionParameters()
                 .executionContext(executionContext)

File: src/main/java/graphql/validation/rules/KnownFragmentNames.java
Patch:
@@ -15,7 +15,7 @@ public KnownFragmentNames(ValidationContext validationContext, ValidationErrorCo
     public void checkFragmentSpread(FragmentSpread fragmentSpread) {
         FragmentDefinition fragmentDefinition = getValidationContext().getFragment(fragmentSpread.getName());
         if (fragmentDefinition == null) {
-            String message = String.format("Undefined framgent %s", fragmentSpread.getName());
+            String message = String.format("Undefined fragment %s", fragmentSpread.getName());
             addError(new ValidationError(ValidationErrorType.UndefinedFragment, fragmentSpread.getSourceLocation(), message));
         }
     }

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -40,7 +40,7 @@ public class Execution {
 
     public Execution(ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy, ExecutionStrategy subscriptionStrategy, Instrumentation instrumentation) {
         this.queryStrategy = queryStrategy != null ? queryStrategy : new AsyncExecutionStrategy();
-        this.mutationStrategy = mutationStrategy != null ? mutationStrategy : new AsyncExecutionStrategy();
+        this.mutationStrategy = mutationStrategy != null ? mutationStrategy : new AsyncSerialExecutionStrategy();
         this.subscriptionStrategy = subscriptionStrategy != null ? subscriptionStrategy : new AsyncExecutionStrategy();
         this.instrumentation = instrumentation;
     }

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -552,7 +552,7 @@ protected GraphQLFieldDefinition getFieldDef(GraphQLSchema schema, GraphQLObject
     protected void assertNonNullFieldPrecondition(NonNullableFieldWasNullException e) throws NonNullableFieldWasNullException {
         ExecutionTypeInfo typeInfo = e.getTypeInfo();
         if (typeInfo.hasParentType() && typeInfo.getParentTypeInfo().isNonNullType()) {
-            throw e;
+            throw new NonNullableFieldWasNullException(e);
         }
     }
 

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -301,7 +301,7 @@ public ExecutionResult execute(ExecutionInput.Builder executionInputBuilder) {
      * Executes the graphql query using calling the builder function and giving it a new builder.
      * <p>
      * This allows a lambda style like :
-     * <p>
+     *
      * <pre>
      * {@code
      *    ExecutionResult result = graphql.execute(input -> input.query("{hello}").root(startingObj).context(contextObj));
@@ -348,7 +348,7 @@ public CompletableFuture<ExecutionResult> executeAsync(ExecutionInput.Builder ex
      * which is the result of executing the provided query.
      * <p>
      * This allows a lambda style like :
-     * <p>
+     *
      * <pre>
      * {@code
      *    ExecutionResult result = graphql.execute(input -> input.query("{hello}").root(startingObj).context(contextObj));

File: src/main/java/graphql/execution/instrumentation/Instrumentation.java
Patch:
@@ -108,7 +108,8 @@ default DataFetcher<?> instrumentDataFetcher(DataFetcher<?> dataFetcher, Instrum
     /**
      * This is called to allow instrumentation to instrument the execution result in some way
      *
-     * @param parameters the parameters to this step
+     * @param executionResult the result to instrument
+     * @param parameters      the parameters to this step
      *
      * @return a new execution result
      */

File: src/main/java/graphql/schema/Coercing.java
Patch:
@@ -16,7 +16,7 @@
  * Java object value that is acceptable to the scalar type.  Again using the DateTime example, the input coercion would try to
  * parse an ISO date time object or throw an exception if it cant.
  *
- * See <a href="http://facebook.github.io/graphql/#sec-Scalars>http://facebook.github.io/graphql/#sec-Scalars</a>
+ * See http://facebook.github.io/graphql/#sec-Scalars
  */
 @PublicSpi
 public interface Coercing<I, O> {

File: src/main/java/graphql/schema/GraphQLScalarType.java
Patch:
@@ -8,12 +8,11 @@
 
 /**
  * This allows you to define new scalar types.
- * <p>
  * <blockquote>
  * GraphQL provides a number of builtin scalars, but type systems can add additional scalars with semantic meaning,
  * for example, a GraphQL system could define a scalar called Time which, while serialized as a string, promises to
  * conform to ISO8601. When querying a field of type Time, you can then rely on the ability to parse the result with an ISO8601 parser and use a clientspecific primitive for time.
- * <p>
+ *
  * From the spec : http://facebook.github.io/graphql/#sec-Scalars
  * </blockquote>
  */

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -8,6 +8,7 @@
 import graphql.MutationNotSupportedError;
 import graphql.execution.instrumentation.Instrumentation;
 import graphql.execution.instrumentation.InstrumentationContext;
+import graphql.execution.instrumentation.InstrumentationState;
 import graphql.execution.instrumentation.parameters.InstrumentationDataFetchParameters;
 import graphql.language.Document;
 import graphql.language.Field;
@@ -44,11 +45,12 @@ public Execution(ExecutionStrategy queryStrategy, ExecutionStrategy mutationStra
         this.instrumentation = instrumentation;
     }
 
-    public CompletableFuture<ExecutionResult> execute(Document document, GraphQLSchema graphQLSchema, ExecutionId executionId, ExecutionInput executionInput) {
+    public CompletableFuture<ExecutionResult> execute(Document document, GraphQLSchema graphQLSchema, ExecutionId executionId, ExecutionInput executionInput, InstrumentationState instrumentationState) {
 
         ExecutionContext executionContext = new ExecutionContextBuilder()
                 .valuesResolver(new ValuesResolver())
                 .instrumentation(instrumentation)
+                .instrumentationState(instrumentationState)
                 .executionId(executionId)
                 .graphQLSchema(graphQLSchema)
                 .queryStrategy(queryStrategy)

File: src/main/java/graphql/execution/instrumentation/NoOpInstrumentation.java
Patch:
@@ -51,7 +51,7 @@ public InstrumentationContext<Object> beginFieldFetch(InstrumentationFieldFetchP
         return new NoOpInstrumentationContext<>();
     }
 
-    private static class NoOpInstrumentationContext<T> implements InstrumentationContext<T> {
+    public static class NoOpInstrumentationContext<T> implements InstrumentationContext<T> {
         @Override
         public void onEnd(T result) {
         }

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationFieldFetchParameters.java
Patch:
@@ -12,7 +12,7 @@ public class InstrumentationFieldFetchParameters extends InstrumentationFieldPar
     private final DataFetchingEnvironment environment;
 
     public InstrumentationFieldFetchParameters(ExecutionContext getExecutionContext, GraphQLFieldDefinition fieldDef, DataFetchingEnvironment environment) {
-        super(getExecutionContext, fieldDef);
+        super(getExecutionContext, fieldDef, environment.getFieldTypeInfo());
         this.environment = environment;
     }
 

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationValidationParameters.java
Patch:
@@ -2,6 +2,7 @@
 
 import graphql.ExecutionInput;
 import graphql.execution.instrumentation.Instrumentation;
+import graphql.execution.instrumentation.InstrumentationState;
 import graphql.language.Document;
 
 /**
@@ -10,8 +11,8 @@
 public class InstrumentationValidationParameters extends InstrumentationExecutionParameters {
     private final Document document;
 
-    public InstrumentationValidationParameters(ExecutionInput executionInput, Document document) {
-        super(executionInput);
+    public InstrumentationValidationParameters(ExecutionInput executionInput, Document document, InstrumentationState instrumentationState) {
+        super(executionInput, instrumentationState);
         this.document = document;
     }
 

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -329,7 +329,7 @@ private List<GraphQLExecutionNodeValue> fetchData(ExecutionContext executionCont
         try {
             values = (List<Object>) getDataFetcher(fieldDef).get(environment);
         } catch (Exception e) {
-            values = new ArrayList<>(nodeData.size());
+            values = Collections.nCopies(nodeData.size(), null);
             log.warn("Exception while fetching data", e);
 
             DataFetcherExceptionHandlerParameters handlerParameters = DataFetcherExceptionHandlerParameters.newExceptionParameters()

File: src/main/java/graphql/execution/NonNullableFieldValidator.java
Patch:
@@ -10,9 +10,9 @@
 public class NonNullableFieldValidator {
 
     private final ExecutionContext executionContext;
-    private final TypeInfo typeInfo;
+    private final ExecutionTypeInfo typeInfo;
 
-    public NonNullableFieldValidator(ExecutionContext executionContext, TypeInfo typeInfo) {
+    public NonNullableFieldValidator(ExecutionContext executionContext, ExecutionTypeInfo typeInfo) {
         this.executionContext = executionContext;
         this.typeInfo = typeInfo;
     }
@@ -29,7 +29,7 @@ public NonNullableFieldValidator(ExecutionContext executionContext, TypeInfo typ
      */
     <T> T validate(ExecutionPath path, T result) throws NonNullableFieldWasNullException {
         if (result == null) {
-            if (typeInfo.typeIsNonNull()) {
+            if (typeInfo.isNonNullType()) {
                 // see http://facebook.github.io/graphql/#sec-Errors-and-Non-Nullability
                 NonNullableFieldWasNullException nonNullException = new NonNullableFieldWasNullException(typeInfo, path);
                 executionContext.addError(nonNullException);

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -320,6 +320,7 @@ private List<GraphQLExecutionNodeValue> fetchData(ExecutionContext executionCont
                 .fieldDefinition(fieldDef)
                 .fields(fields)
                 .fieldType(fieldDef.getType())
+                .fieldTypeInfo(parameters.typeInfo())
                 .parentType(parentType)
                 .selectionSet(fieldCollector)
                 .build();

File: src/main/java/graphql/validation/rules/KnownDirectives.java
Patch:
@@ -45,7 +45,7 @@ private boolean hasInvalidLocation(GraphQLDirective directive, Node ancestor) {
         } else if (ancestor instanceof FragmentDefinition) {
             return !(directive.validLocations().contains(DirectiveLocation.FRAGMENT_DEFINITION) || directive.isOnFragment());
         } else if (ancestor instanceof InlineFragment) {
-            return (!directive.validLocations().contains(DirectiveLocation.INLINE_FRAGMENT) || directive.isOnFragment());
+            return !(directive.validLocations().contains(DirectiveLocation.INLINE_FRAGMENT) || directive.isOnFragment());
         }
         return true;
     }

File: src/main/java/graphql/ExecutionResult.java
Patch:
@@ -27,7 +27,7 @@ public interface ExecutionResult {
      * should be present.  Certain JSON serializers may or may interpret {@link ExecutionResult} to spec, so this method
      * is provided to produce a map that strictly follows the specification.
      *
-     * See : <a href="http://facebook.github.io/graphql/#sec-Response-Format">http://facebook.github.io/graphql/#sec-Response-Format">http://facebook.github.io/graphql/#sec-Response-Format</a>
+     * See : <a href="http://facebook.github.io/graphql/#sec-Response-Format">http://facebook.github.io/graphql/#sec-Response-Format</a>
      *
      * @return a map of the result that strictly follows the spec
      */

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -16,7 +16,7 @@
 import static graphql.Assert.assertValidName;
 
 @PublicApi
-public class GraphQLEnumType implements GraphQLType, GraphQLInputType, GraphQLOutputType, GraphQLUnmodifiedType {
+public class GraphQLEnumType implements GraphQLType, GraphQLInputType, GraphQLOutputType, GraphQLUnmodifiedType, GraphQLNullableType {
 
     private final String name;
     private final String description;

File: src/main/java/graphql/schema/idl/SchemaGenerator.java
Patch:
@@ -481,7 +481,7 @@ private DataFetcher buildDataFetcher(BuildContext buildCtx, TypeDefinition paren
                 dataFetcher = runtimeWiring.getDefaultDataFetcherForType(parentTypeName);
                 if (dataFetcher == null) {
                     dataFetcher = wiringFactory.getDefaultDataFetcher(wiringEnvironment);
-                    assertNotNull(dataFetcher, "The WiringFactory indicated MUST provide a data fetcher of last resort as part of its contract");
+                    assertNotNull(dataFetcher, "The WiringFactory indicated MUST provide a default data fetcher as part of its contract");
                 }
             }
         }

File: src/main/java/graphql/schema/idl/TypeRuntimeWiring.java
Patch:
@@ -122,9 +122,8 @@ public Builder dataFetchers(Map<String, DataFetcher> dataFetchersMap) {
         }
 
         /**
-         * All fields in a type need a data fetcher of some sort and this method is called to prove the data fetcher
-         * of last resort, that is the one that will be used for this type if no specific one has been provided
-         * per field.
+         * All fields in a type need a data fetcher of some sort and this method is called to provide the default data fetcher
+         * that will be used for this type if no specific one has been provided per field.
          *
          * @param dataFetcher the default data fetcher to use for this type
          *

File: src/main/java/graphql/schema/idl/WiringFactory.java
Patch:
@@ -82,8 +82,8 @@ default DataFetcher getDataFetcher(FieldWiringEnvironment environment) {
     }
 
     /**
-     * All fields need a data fetcher of some sort and this  method is called to prove the data fetcher
-     * of last resort, that is the one that will be used if no specific one has been provided
+     * All fields need a data fetcher of some sort and this  method is called to provide the data fetcher
+     * that will be used if no specific one has been provided
      * @param environment the wiring environment
      *
      * @return a {@link DataFetcher}

File: src/main/java/graphql/schema/idl/NoopWiringFactory.java
Patch:
@@ -39,7 +39,7 @@ public DataFetcher getDataFetcher(FieldWiringEnvironment environment) {
     }
 
     @Override
-    public DataFetcher getDataFetcherOfLastResort(FieldWiringEnvironment environment) {
+    public DataFetcher getDefaultDataFetcher(FieldWiringEnvironment environment) {
         return new PropertyDataFetcher(environment.getFieldDefinition().getName());
     }
 }

File: src/main/java/graphql/schema/idl/WiringFactory.java
Patch:
@@ -82,13 +82,13 @@ default DataFetcher getDataFetcher(FieldWiringEnvironment environment) {
     }
 
     /**
-     * All fields need a data fetcher of some sort.  This method is called to prove the data fetcher
+     * All fields need a data fetcher of some sort and this  method is called to prove the data fetcher
      * of last resort, that is the one that will be used if no specific one has been provided
      * @param environment the wiring environment
      *
      * @return a {@link DataFetcher}
      */
-    default DataFetcher getDataFetcherOfLastResort(FieldWiringEnvironment environment) {
+    default DataFetcher getDefaultDataFetcher(FieldWiringEnvironment environment) {
         return new PropertyDataFetcher(environment.getFieldDefinition().getName());
     }
 }

File: src/main/java/graphql/execution/instrumentation/parameters/InstrumentationFieldFetchParameters.java
Patch:
@@ -12,7 +12,7 @@ public class InstrumentationFieldFetchParameters extends InstrumentationFieldPar
     private final DataFetchingEnvironment environment;
 
     public InstrumentationFieldFetchParameters(ExecutionContext getExecutionContext, GraphQLFieldDefinition fieldDef, DataFetchingEnvironment environment) {
-        super(getExecutionContext, fieldDef, environment);
+        super(getExecutionContext, fieldDef);
         this.environment = environment;
     }
 

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -279,7 +279,7 @@ public ExecutionResult execute(String query, String operationName, Object contex
      * @return result including errors
      */
     public ExecutionResult execute(ExecutionInput executionInput) {
-        log.debug("Executing request. operation name: {}. query: {} ", executionInput.getOperationName(), executionInput.getQuery());
+        log.debug("Executing request. operation name: {}. query: {}. variables {} ", executionInput.getOperationName(), executionInput.getQuery(), executionInput.getVariables());
 
         InstrumentationContext<ExecutionResult> executionInstrumentation = instrumentation.beginExecution(new InstrumentationExecutionParameters(executionInput));
         final ExecutionResult executionResult = parseValidateAndExecute(executionInput);

File: src/main/java/graphql/execution/ExecutionContextBuilder.java
Patch:
@@ -116,7 +116,7 @@ public ExecutionContext build() {
             operation = operationsByName.get(operationName);
         }
         if (operation == null) {
-            throw new GraphQLException();
+            throw new GraphQLException("no operation found");
         }
         Map<String, Object> variableValues = valuesResolver.getVariableValues(graphQLSchema, operation.getVariableDefinitions(), variables);
 
@@ -130,7 +130,7 @@ public ExecutionContext build() {
                 fragmentsByName,
                 operation,
                 variableValues,
-                root,
-                context);
+                context,
+                root);
     }
 }

File: src/main/java/graphql/language/EnumValueDefinition.java
Patch:
@@ -26,12 +26,12 @@ public List<Directive> getDirectives() {
         return directives;
     }
 
-    public Map<String, Directive> getDirectivesMap() {
-        return Directive.getDirectivesMap(directives);
+    public Map<String, Directive> getDirectivesByName() {
+        return NodeUtil.directivesByName(directives);
     }
 
     public Directive getDirective(String directiveName) {
-        return getDirectivesMap().get(directiveName);
+        return getDirectivesByName().get(directiveName);
     }
 
     @Override

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -176,7 +176,9 @@ protected ExecutionResult completeValue(ExecutionContext executionContext, Execu
             resolvedType = (GraphQLObjectType) fieldType;
         }
 
-        FieldCollectorParameters collectorParameters = newParameters(executionContext.getGraphQLSchema(), resolvedType)
+        FieldCollectorParameters collectorParameters = newParameters()
+                .schema(executionContext.getGraphQLSchema())
+                .objectType(resolvedType)
                 .fragments(executionContext.getFragmentsByName())
                 .variables(executionContext.getVariables())
                 .build();

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -217,7 +217,9 @@ private boolean isNonNull(GraphQLType fieldType) {
     private Map<String, List<Field>> getChildFields(ExecutionContext executionContext, GraphQLObjectType resolvedType,
                                                     List<Field> fields) {
 
-        FieldCollectorParameters collectorParameters = newParameters(executionContext.getGraphQLSchema(), resolvedType)
+        FieldCollectorParameters collectorParameters = newParameters()
+                .schema(executionContext.getGraphQLSchema())
+                .objectType(resolvedType)
                 .fragments(executionContext.getFragmentsByName())
                 .variables(executionContext.getVariables())
                 .build();

File: src/main/java/graphql/schema/DataFetchingFieldSelectionSetImpl.java
Patch:
@@ -30,8 +30,9 @@ public static DataFetchingFieldSelectionSet newCollector(ExecutionContext execut
     private DataFetchingFieldSelectionSetImpl(ExecutionContext executionContext, GraphQLObjectType fieldType, List<Field> fields) {
         this.fields = fields;
         this.fieldCollector = new FieldCollector();
-        this.parameters = FieldCollectorParameters.
-                newParameters(executionContext.getGraphQLSchema(), fieldType)
+        this.parameters = FieldCollectorParameters.newParameters()
+                .schema(executionContext.getGraphQLSchema())
+                .objectType(fieldType)
                 .fragments(executionContext.getFragmentsByName())
                 .variables(executionContext.getVariables())
                 .build();

File: src/main/java/graphql/validation/rules/ScalarLeafs.java
Patch:
@@ -20,12 +20,12 @@ public void checkField(Field field) {
         if (type == null) return;
         if (schemaUtil.isLeafType(type)) {
             if (field.getSelectionSet() != null) {
-                String message = String.format("Sub selection not allowed on leaf type %s", type.getName());
+                String message = String.format("Sub selection not allowed on leaf type %s of field %s", type.getName(), field.getName());
                 addError(new ValidationError(ValidationErrorType.SubSelectionNotAllowed, field.getSourceLocation(), message));
             }
         } else {
             if (field.getSelectionSet() == null) {
-                String message = String.format("Sub selection required for type %s", type.getName());
+                String message = String.format("Sub selection required for type %s of field %s", type.getName(), field.getName());
                 addError(new ValidationError(ValidationErrorType.SubSelectionRequired, field.getSourceLocation(), message));
             }
         }

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -98,6 +98,7 @@ private ExecutionResult executeOperation(
                 .source(root)
                 .fields(fields)
                 .nonNullFieldValidator(nonNullableFieldValidator)
+                .path(ExecutionPath.rootPath())
                 .build();
 
         ExecutionResult result;

File: src/main/java/graphql/schema/idl/SchemaGenerator.java
Patch:
@@ -464,8 +464,8 @@ private DataFetcher buildDataFetcher(BuildContext buildCtx, TypeDefinition paren
         WiringFactory wiringFactory = wiring.getWiringFactory();
 
         DataFetcher dataFetcher;
-        if (wiringFactory.providesDataFetcher(typeRegistry, fieldDef)) {
-            dataFetcher = wiringFactory.getDataFetcher(typeRegistry, fieldDef);
+        if (wiringFactory.providesDataFetcher(typeRegistry, parentType, fieldDef)) {
+            dataFetcher = wiringFactory.getDataFetcher(typeRegistry, parentType, fieldDef);
             assertNotNull(dataFetcher, "The WiringFactory indicated it provides a data fetcher but then returned null");
         } else {
             dataFetcher = wiring.getDataFetcherForType(parentType.getName()).get(fieldName);

File: src/test/groovy/example/http/HttpMain.java
Patch:
@@ -68,9 +68,9 @@ private void handleStarWars(HttpServletRequest httpRequest, HttpServletResponse
         }
 
         ExecutionInput.Builder executionInput = newExecutionInput()
-                .requestString(parameters.getQuery())
+                .query(parameters.getQuery())
                 .operationName(parameters.getOperationName())
-                .arguments(parameters.getVariables());
+                .variables(parameters.getVariables());
 
         //
         // the context object is something that means something to down stream code.  It is instructions

File: src/main/java/graphql/execution/TypeInfo.java
Patch:
@@ -74,7 +74,7 @@ public String toString() {
                 typeIsNonNull, type, parentType);
     }
 
-    static class Builder {
+    public static class Builder {
         GraphQLType type;
         TypeInfo parentType;
 

File: src/main/java/graphql/execution/ExecutionStrategyParameters.java
Patch:
@@ -49,7 +49,7 @@ public NonNullableFieldValidator nonNullFieldValidator() {
         return nonNullableFieldValidator;
     }
 
-    public ExecutionParameters transform(Consumer<Builder> builderConsumer) {
+    public ExecutionStrategyParameters transform(Consumer<Builder> builderConsumer) {
         Builder builder = newParameters(this);
         builderConsumer.accept(builder);
         return builder.build();
@@ -59,7 +59,7 @@ public static Builder newParameters() {
         return new Builder();
     }
 
-    public static Builder newParameters(ExecutionParameters oldParameters) {
+    public static Builder newParameters(ExecutionStrategyParameters oldParameters) {
         return new Builder(oldParameters);
     }
 
@@ -79,7 +79,7 @@ public static class Builder {
         private Builder() {
         }
 
-        private Builder(ExecutionParameters oldParameters) {
+        private Builder(ExecutionStrategyParameters oldParameters) {
             this.typeInfo = oldParameters.typeInfo;
             this.source = oldParameters.source;
             this.fields = oldParameters.fields;

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -167,8 +167,8 @@ public GraphQL build() {
     }
 
     /**
-     * @param requestString
-     * @return
+     * @param requestString  the query/mutation/subscription
+     * @return result including errors
      * @deprecated Use {@link #execute(ExecutionInput)}
      */
     @Deprecated

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -219,13 +219,13 @@ protected GraphQLObjectType resolveTypeForUnion(TypeResolutionParameters params)
         return result;
     }
 
-    protected ExecutionResult completeValueForEnum(GraphQLEnumType enumType, ExecutionSParameters parameters, Object result) {
+    protected ExecutionResult completeValueForEnum(GraphQLEnumType enumType, ExecutionStrategyParameters parameters, Object result) {
         Object serialized = enumType.getCoercing().serialize(result);
         serialized = parameters.nonNullFieldValidator().validate(serialized);
         return new ExecutionResultImpl(serialized, null);
     }
 
-    protected ExecutionResult completeValueForScalar(GraphQLScalarType scalarType, ExecutionParameters parameters, Object result) {
+    protected ExecutionResult completeValueForScalar(GraphQLScalarType scalarType, ExecutionStrategyParameters parameters, Object result) {
         Object serialized = scalarType.getCoercing().serialize(result);
         //6.6.1 http://facebook.github.io/graphql/#sec-Field-entries
         if (serialized instanceof Double && ((Double) serialized).isNaN()) {

File: src/main/java/graphql/schema/DataFetchingEnvironment.java
Patch:
@@ -61,7 +61,7 @@ public interface DataFetchingEnvironment {
     /**
      * This is the source object for the root query.
      *
-     * @param <T>
+     * @param <T>  you decide what type it is
      * @return can be null
      */
     <T> T getRoot();

File: src/main/java/graphql/schema/SchemaUtil.java
Patch:
@@ -154,6 +154,9 @@ public Map<String, GraphQLType> allTypes(GraphQLSchema schema, Set<GraphQLType>
         if (schema.isSupportingMutations()) {
             collectTypes(schema.getMutationType(), typesByName);
         }
+        if (schema.isSupportingSubscriptions()) {
+            collectTypes(schema.getSubscriptionType(), typesByName);
+        }
         if (additionalTypes != null) {
             for (GraphQLType type : additionalTypes) {
                 collectTypes(type, typesByName);

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -11,6 +11,7 @@
 import graphql.execution.instrumentation.parameters.FieldFetchParameters;
 import graphql.execution.instrumentation.parameters.FieldParameters;
 import graphql.language.Field;
+import graphql.schema.DataFetcher;
 import graphql.schema.DataFetchingEnvironment;
 import graphql.schema.DataFetchingEnvironmentImpl;
 import graphql.schema.DataFetchingFieldSelectionSet;
@@ -96,7 +97,8 @@ protected ExecutionResult resolveField(ExecutionContext executionContext, Execut
         InstrumentationContext<Object> fetchCtx = instrumentation.beginFieldFetch(new FieldFetchParameters(executionContext, fieldDef, environment));
         Object resolvedValue = null;
         try {
-            resolvedValue = fieldDef.getDataFetcher().get(environment);
+            DataFetcher dataFetcher = fieldDef.getDataFetcher();
+            resolvedValue = dataFetcher.get(environment);
 
             fetchCtx.onEnd(resolvedValue);
         } catch (Exception e) {

File: src/main/java/graphql/language/AstPrinter.java
Patch:
@@ -26,6 +26,7 @@ public class AstPrinter {
         printers.put(Argument.class, argument());
         printers.put(ArrayValue.class, value());
         printers.put(BooleanValue.class, value());
+        printers.put(NullValue.class, value());
         printers.put(Directive.class, directive());
         printers.put(DirectiveDefinition.class, directiveDefinition());
         printers.put(DirectiveLocation.class, directiveLocation());
@@ -399,6 +400,8 @@ static private String value(Value value) {
             return valueOf(((EnumValue) value).getName());
         } else if (value instanceof BooleanValue) {
             return valueOf(((BooleanValue) value).isValue());
+        } else if (value instanceof NullValue) {
+            return "null";
         } else if (value instanceof ArrayValue) {
             return "[" + join(((ArrayValue) value).getValues(), ", ") + "]";
         } else if (value instanceof ObjectValue) {

File: src/main/java/graphql/schema/idl/SchemaGenerator.java
Patch:
@@ -13,6 +13,7 @@
 import graphql.language.IntValue;
 import graphql.language.InterfaceTypeDefinition;
 import graphql.language.Node;
+import graphql.language.NullValue;
 import graphql.language.ObjectTypeDefinition;
 import graphql.language.ObjectValue;
 import graphql.language.OperationTypeDefinition;
@@ -475,6 +476,8 @@ private Object buildValue(Value value) {
             result = arrayValue.getValues().stream().map(this::buildValue).toArray();
         } else if (value instanceof ObjectValue) {
             result = buildObjectValue((ObjectValue) value);
+        } else if (value instanceof NullValue) {
+            result = null;
         }
         return result;
 

File: src/main/java/graphql/validation/ValidationUtil.java
Patch:
@@ -25,6 +25,9 @@ public boolean isValidLiteralValue(Value value, GraphQLType type) {
         if (value == null) {
             return !(type instanceof GraphQLNonNull);
         }
+        if (value instanceof NullValue) {
+            return !(type instanceof GraphQLNonNull);
+        }
         if (value instanceof VariableReference) {
             return true;
         }

File: src/main/java/graphql/schema/idl/SchemaParser.java
Patch:
@@ -83,7 +83,7 @@ private SchemaProblem handleParseException(ParseCancellationException e) throws
 
     /**
      * special method to build directly a TypeDefinitionRegistry from a Document
-     * useful for Introspection =&gt; IDL (Document) => TypeDefinitionRegistry
+     * useful for Introspection =&gt; IDL (Document) =&gt; TypeDefinitionRegistry
      *
      * @param document containing type definitions
      * @throws SchemaProblem if an error occurs

File: src/main/java/graphql/schema/idl/EnumValuesProvider.java
Patch:
@@ -11,7 +11,7 @@
 public interface EnumValuesProvider {
 
     /**
-     * @param name
+     * @param name an Enum value
      * @return not null
      */
     Object getValue(String name);

File: src/main/java/graphql/schema/idl/NaturalEnumValuesProvider.java
Patch:
@@ -6,7 +6,6 @@
 /**
  * Simple EnumValuesProvided which maps the GraphQL Enum name to the Java Enum instance.
  *
- * @param <T>
  */
 @PublicApi
 public class NaturalEnumValuesProvider<T extends Enum<T>> implements EnumValuesProvider {

File: src/main/java/graphql/language/InputValueDefinition.java
Patch:
@@ -39,7 +39,7 @@ public Value getDefaultValue() {
         return defaultValue;
     }
 
-    public void setValue(Value defaultValue) {
+    public void setDefaultValue(Value defaultValue) {
         this.defaultValue = defaultValue;
     }
 

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -537,7 +537,7 @@ public Void visitInputValueDefinition(GraphqlParser.InputValueDefinitionContext
         InputValueDefinition def = new InputValueDefinition(ctx.name().getText());
         newNode(def, ctx);
         if (ctx.defaultValue() != null) {
-            def.setValue(getValue(ctx.defaultValue().value()));
+            def.setDefaultValue(getValue(ctx.defaultValue().value()));
         }
         for (ContextEntry contextEntry : contextStack) {
             if (contextEntry.contextProperty == ContextProperty.FieldDefinition) {

File: src/main/java/graphql/execution/ExecutionParameters.java
Patch:
@@ -17,8 +17,8 @@ public class ExecutionParameters {
     private final Map<String, List<Field>> fields;
 
     private ExecutionParameters(TypeInfo typeInfo, Object source, Map<String, List<Field>> fields, Map<String, Object> arguments) {
-        this.typeInfo = assertNotNull(typeInfo, "");
-        this.fields = assertNotNull(fields, "");
+        this.typeInfo = assertNotNull(typeInfo, "typeInfo is null");
+        this.fields = assertNotNull(fields, "fields is null");
         this.source = source;
         this.arguments = arguments;
     }

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -257,6 +257,7 @@ private void handlePrimitives(List<GraphQLExecutionNodeValue> values, String fie
     }
 
     private Object coerce(GraphQLType type, Object value) {
+        if (value == null) return null;
         if (type instanceof GraphQLEnumType) {
             return ((GraphQLEnumType) type).getCoercing().serialize(value);
         } else {

File: src/main/java/graphql/language/InterfaceTypeDefinition.java
Patch:
@@ -4,7 +4,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-public class InterfaceTypeDefinition extends AbstractNode implements TypeDefinition, ResolvedTypeDefinition {
+public class InterfaceTypeDefinition extends AbstractNode implements TypeDefinition {
     private String name;
     private List<FieldDefinition> definitions = new ArrayList<>();
     private List<Directive> directives = new ArrayList<>();

File: src/main/java/graphql/language/UnionTypeDefinition.java
Patch:
@@ -4,7 +4,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-public class UnionTypeDefinition extends AbstractNode implements TypeDefinition, ResolvedTypeDefinition {
+public class UnionTypeDefinition extends AbstractNode implements TypeDefinition {
     private String name;
     private List<Directive> directives = new ArrayList<>();
     private List<Type> memberTypes = new ArrayList<>();

File: src/main/java/graphql/schema/idl/RuntimeWiring.java
Patch:
@@ -2,8 +2,6 @@
 
 import graphql.Assert;
 import graphql.PublicApi;
-import graphql.language.FieldDefinition;
-import graphql.language.ResolvedTypeDefinition;
 import graphql.schema.DataFetcher;
 import graphql.schema.GraphQLScalarType;
 import graphql.schema.GraphQLSchema;
@@ -64,7 +62,7 @@ public static class Builder {
         private final Map<String, Map<String, DataFetcher>> dataFetchers = new LinkedHashMap<>();
         private final Map<String, GraphQLScalarType> scalars = new LinkedHashMap<>();
         private final Map<String, TypeResolver> typeResolvers = new LinkedHashMap<>();
-        private WiringFactory wiringFactory = WiringFactory.NOOP_WIRING_FACTORY;
+        private WiringFactory wiringFactory = new NoopWiringFactory();
 
         private Builder() {
             ScalarInfo.STANDARD_SCALARS.forEach(this::scalar);

File: src/main/java/graphql/language/OperationTypeDefinition.java
Patch:
@@ -1,9 +1,12 @@
 package graphql.language;
 
 
+import graphql.Internal;
+
 import java.util.ArrayList;
 import java.util.List;
 
+@Internal
 public class OperationTypeDefinition extends AbstractNode {
     private String name;
     private Type type;

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -1,6 +1,7 @@
 package graphql.parser;
 
 
+import graphql.Internal;
 import graphql.ShouldNotHappenException;
 import graphql.language.AbstractNode;
 import graphql.language.Argument;
@@ -57,6 +58,7 @@
 import java.util.Deque;
 import java.util.List;
 
+@Internal
 public class GraphqlAntlrToLanguage extends GraphqlBaseVisitor<Void> {
 
     private final CommonTokenStream tokens;

File: src/main/java/graphql/parser/Parser.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.parser;
 
+import graphql.Internal;
 import graphql.language.Document;
 import graphql.parser.antlr.GraphqlLexer;
 import graphql.parser.antlr.GraphqlParser;
@@ -12,6 +13,7 @@
 
 import java.util.List;
 
+@Internal
 public class Parser {
 
     public Document parseDocument(String input) {

File: src/main/java/graphql/schema/DataFetchingEnvironment.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.schema;
 
+import graphql.PublicApi;
 import graphql.execution.ExecutionId;
 import graphql.language.Field;
 import graphql.language.FragmentDefinition;
@@ -10,6 +11,7 @@
 /**
  * A DataFetchingEnvironment instance of passed to a {@link DataFetcher} as an execution context parameter
  */
+@PublicApi
 public interface DataFetchingEnvironment {
     /**
      * @param <T> you decide what type it is

File: src/main/java/graphql/schema/idl/TypeDefinitionRegistry.java
Patch:
@@ -22,7 +22,7 @@
 
 /**
  * A {@link TypeDefinitionRegistry} contains the set of type definitions that come from compiling
- * a graphql schema definition file via {@link SchemaCompiler#compile(String)}
+ * a graphql schema definition file via {@link SchemaParser#parse(String)}
  */
 public class TypeDefinitionRegistry {
 

File: src/main/java/graphql/schema/idl/errors/SchemaProblem.java
Patch:
@@ -2,12 +2,13 @@
 
 import graphql.GraphQLError;
 import graphql.GraphQLException;
+import graphql.schema.idl.SchemaParser;
 
 import java.util.ArrayList;
 import java.util.List;
 
 /**
- * A number of problems can occur when using the schema tools like {@link graphql.schema.idl.SchemaCompiler}
+ * A number of problems can occur when using the schema tools like {@link SchemaParser}
  * or {@link graphql.schema.idl.SchemaGenerator} classes and they are reported via this
  * exception as a list of {@link GraphQLError}s
  */

File: src/main/java/graphql/schema/idl/SchemaGenerator.java
Patch:
@@ -22,7 +22,6 @@
 import graphql.language.Type;
 import graphql.language.TypeDefinition;
 import graphql.language.TypeExtensionDefinition;
-import graphql.language.TypeName;
 import graphql.language.UnionTypeDefinition;
 import graphql.language.Value;
 import graphql.schema.DataFetcher;
@@ -253,6 +252,7 @@ private GraphQLInputType buildInputType(BuildContext buildCtx, Type rawType) {
     }
 
     private GraphQLObjectType buildObjectType(BuildContext buildCtx, ObjectTypeDefinition typeDefinition) {
+
         GraphQLObjectType.Builder builder = GraphQLObjectType.newObject();
         builder.name(typeDefinition.getName());
         builder.description(buildDescription(typeDefinition));
@@ -331,7 +331,8 @@ private GraphQLUnionType buildUnionType(BuildContext buildCtx, UnionTypeDefiniti
         builder.typeResolver(getTypeResolver(buildCtx, typeDefinition.getName()));
 
         typeDefinition.getMemberTypes().forEach(mt -> {
-            builder.possibleType(new GraphQLTypeReference(((TypeName) mt).getName()));
+            GraphQLObjectType objectType = buildOutputType(buildCtx, mt);
+            builder.possibleType(objectType);
         });
         return builder.build();
     }

File: src/main/java/graphql/schema/GraphQLSchema.java
Patch:
@@ -3,8 +3,8 @@
 
 import graphql.Directives;
 import graphql.schema.validation.InvalidSchemaException;
-import graphql.schema.validation.ValidationError;
-import graphql.schema.validation.Validator;
+import graphql.schema.validation.SchemaValidationError;
+import graphql.schema.validation.SchemaValidator;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -125,7 +125,7 @@ public GraphQLSchema build(Set<GraphQLType> additionalTypes) {
             assertNotNull(additionalTypes, "additionalTypes can't be null");
             GraphQLSchema graphQLSchema = new GraphQLSchema(queryType, mutationType, subscriptionType, additionalTypes);
             new SchemaUtil().replaceTypeReferences(graphQLSchema);
-            Collection<ValidationError> errors = new Validator().validateSchema(graphQLSchema);
+            Collection<SchemaValidationError> errors = new SchemaValidator().validateSchema(graphQLSchema);
             if (errors.size() > 0) {
                 throw new InvalidSchemaException(errors);
             }

File: src/main/java/graphql/schema/validation/InvalidSchemaException.java
Patch:
@@ -6,13 +6,13 @@
 
 public class InvalidSchemaException extends GraphQLException {
 
-    public InvalidSchemaException(Collection<ValidationError> errors) {
+    public InvalidSchemaException(Collection<SchemaValidationError> errors) {
         super(buildErrorMsg(errors));
     }
 
-    private static String buildErrorMsg(Collection<ValidationError> errors) {
+    private static String buildErrorMsg(Collection<SchemaValidationError> errors) {
         StringBuilder message = new StringBuilder("invalid schema:");
-        for (ValidationError error : errors) {
+        for (SchemaValidationError error : errors) {
             message.append("\n").append(error.getDescription());
         }
         return message.toString();

File: src/main/java/graphql/schema/validation/ValidationErrorType.java
Patch:
@@ -2,5 +2,6 @@
 
 public enum ValidationErrorType {
     
-    UnbrokenInputCycle
+    UnbrokenInputCycle,
+    ObjectDoesNotImplementItsInterfaces
 }

File: src/main/java/graphql/schema/validation/ValidationRule.java
Patch:
@@ -1,9 +1,11 @@
 package graphql.schema.validation;
 
 import graphql.schema.GraphQLFieldDefinition;
+import graphql.schema.GraphQLType;
 
 public interface ValidationRule {
 
     void check(GraphQLFieldDefinition fieldDef, ValidationErrorCollector validationErrorCollector);
-    
+
+    void check(GraphQLType type, ValidationErrorCollector validationErrorCollector);
 }

File: src/main/java/graphql/schema/idl/errors/SchemaMissingError.java
Patch:
@@ -3,6 +3,6 @@
 public class SchemaMissingError extends BaseError {
 
     public SchemaMissingError() {
-        super(null, "There is no ttop level schema object defined");
+        super(null, "There is no top level schema object defined");
     }
 }

File: src/main/java/graphql/execution/ExecutionContextBuilder.java
Patch:
@@ -30,7 +30,7 @@ public ExecutionContextBuilder executionId(ExecutionId executionId) {
         return this;
     }
 
-    public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy, Object root, Document document, String operationName, Map<String, Object> args) {
+    public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy, ExecutionStrategy subscriptionStrategy, Object root, Document document, String operationName, Map<String, Object> args) {
         // preconditions
         assertNotNull(executionId, "You must provide a query identifier");
 
@@ -68,6 +68,7 @@ public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy que
                 graphQLSchema,
                 queryStrategy,
                 mutationStrategy,
+                subscriptionStrategy,
                 fragmentsByName,
                 operation,
                 variableValues,

File: src/main/java/graphql/execution/ExecutorServiceExecutionStrategy.java
Patch:
@@ -4,7 +4,6 @@
 import graphql.ExecutionResultImpl;
 import graphql.GraphQLException;
 import graphql.language.Field;
-import graphql.schema.GraphQLObjectType;
 
 import java.util.LinkedHashMap;
 import java.util.List;

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -392,8 +392,8 @@ public enum DirectiveLocation {
                     .description("'If this server support subscription, the type that subscription operations will be rooted at.")
                     .type(__Type)
                     .dataFetcher(environment -> {
-                        // Not yet supported
-                        return null;
+                        GraphQLSchema schema = environment.getSource();
+                        return schema.getSubscriptionType();
                     }))
             .build();
 

File: src/main/java/graphql/language/OperationDefinition.java
Patch:
@@ -7,7 +7,7 @@
 public class OperationDefinition extends AbstractNode implements Definition {
 
     public enum Operation {
-        QUERY, MUTATION
+        QUERY, MUTATION, SUBSCRIPTION
     }
 
     private String name;

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -192,6 +192,8 @@ private OperationDefinition.Operation parseOperation(GraphqlParser.OperationType
             return OperationDefinition.Operation.QUERY;
         } else if (operationTypeContext.getText().equals("mutation")) {
             return OperationDefinition.Operation.MUTATION;
+        } else if (operationTypeContext.getText().equals("subscription")) {
+            return OperationDefinition.Operation.SUBSCRIPTION;
         } else {
             throw new RuntimeException("InternalError: unknown operationTypeContext=" + operationTypeContext.getText());
         }

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -6,7 +6,6 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
-import java.util.function.BinaryOperator;
 import java.util.function.UnaryOperator;
 
 import static graphql.Assert.assertNotNull;
@@ -43,7 +42,7 @@ public GraphQLFieldDefinition(String name, String description, GraphQLOutputType
 
 
     void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
-        type = (GraphQLOutputType) new SchemaUtil().resolveTypeReference(type, typeMap);
+        this.type = (GraphQLOutputType) new SchemaUtil().resolveTypeReference(this.type, typeMap);
     }
 
     public String getName() {

File: src/main/java/graphql/schema/GraphQLTypeReference.java
Patch:
@@ -1,14 +1,14 @@
 package graphql.schema;
 
 
-import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
 
 /**
  * A special type to allow a object/interface types to reference itself. It's replaced with the real type
  * object when the schema is build.
+ *
  */
-public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType, GraphQLInputType, TypeReference {
+public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType, GraphQLInputType {
 
     private final String name;
 

File: src/main/java/graphql/schema/idl/SchemaDecompiler.java
Patch:
@@ -9,6 +9,7 @@
 import graphql.schema.GraphQLList;
 import graphql.schema.GraphQLNonNull;
 import graphql.schema.GraphQLObjectType;
+import graphql.schema.GraphQLOutputType;
 import graphql.schema.GraphQLScalarType;
 import graphql.schema.GraphQLSchema;
 import graphql.schema.GraphQLType;
@@ -172,9 +173,9 @@ private TypePrinter<GraphQLUnionType> unionPrinter() {
                 return;
             }
             out.format("union %s = ", type.getName());
-            List<GraphQLObjectType> types = type.getTypes();
+            List<GraphQLOutputType> types = type.getTypes();
             for (int i = 0; i < types.size(); i++) {
-                GraphQLObjectType objectType = types.get(i);
+                GraphQLOutputType objectType = types.get(i);
                 if (i > 0) {
                     out.format(" | ");
                 }

File: src/main/java/graphql/validation/TraversalContext.java
Patch:
@@ -81,6 +81,8 @@ private void enterImpl(OperationDefinition operationDefinition) {
             addType(schema.getMutationType());
         } else if (operationDefinition.getOperation() == OperationDefinition.Operation.QUERY) {
             addType(schema.getQueryType());
+        } else if (operationDefinition.getOperation() == OperationDefinition.Operation.SUBSCRIPTION) {
+            addType(schema.getSubscriptionType());
         } else {
             throw new ShouldNotHappenException();
         }

File: src/test/groovy/graphql/TypeReferenceSchema.java
Patch:
@@ -18,8 +18,8 @@ public class TypeReferenceSchema {
 
     public static GraphQLUnionType PetType = newUnionType()
             .name("Pet")
-            .possibleType(GraphQLObjectType.reference(CatType.getName()))
-            .possibleType(GraphQLObjectType.reference(DogType.getName()))
+            .possibleType(new GraphQLTypeReference(CatType.getName()))
+            .possibleType(new GraphQLTypeReference(DogType.getName()))
             .typeResolver(new TypeResolverProxy())
             .build();
     
@@ -38,7 +38,7 @@ public class TypeReferenceSchema {
             .field(newFieldDefinition()
                     .name("pet")
                     .type(new GraphQLTypeReference(PetType.getName())))
-            .withInterface(GraphQLInterfaceType.reference(NamedType.getName()))
+            .withInterface(new GraphQLTypeReference(NamedType.getName()))
             .build();
 
     public static GraphQLFieldDefinition exists = newFieldDefinition()

File: src/test/groovy/readme/ReadmeExamples.java
Patch:
@@ -178,6 +178,7 @@ void executionStrategies() {
         GraphQL graphQL = GraphQL.newGraphQL(StarWarsSchema.starWarsSchema)
                 .queryExecutionStrategy(new ExecutorServiceExecutionStrategy(threadPoolExecutor))
                 .mutationExecutionStrategy(new SimpleExecutionStrategy())
+                .subscriptionExecutionStrategy(new SimpleExecutionStrategy())
                 .build();
 
     }

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -6,7 +6,6 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
-import java.util.function.BinaryOperator;
 import java.util.function.UnaryOperator;
 
 import static graphql.Assert.assertNotNull;
@@ -43,7 +42,7 @@ public GraphQLFieldDefinition(String name, String description, GraphQLOutputType
 
 
     void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
-        type = (GraphQLOutputType) new SchemaUtil().resolveTypeReference(type, typeMap);
+        this.type = (GraphQLOutputType) new SchemaUtil().resolveTypeReference(this.type, typeMap);
     }
 
     public String getName() {

File: src/main/java/graphql/schema/GraphQLTypeReference.java
Patch:
@@ -1,14 +1,14 @@
 package graphql.schema;
 
 
-import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
 
 /**
  * A special type to allow a object/interface types to reference itself. It's replaced with the real type
  * object when the schema is build.
+ *
  */
-public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType, GraphQLInputType, TypeReference {
+public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType, GraphQLInputType {
 
     private final String name;
 

File: src/main/java/graphql/schema/idl/SchemaDecompiler.java
Patch:
@@ -9,6 +9,7 @@
 import graphql.schema.GraphQLList;
 import graphql.schema.GraphQLNonNull;
 import graphql.schema.GraphQLObjectType;
+import graphql.schema.GraphQLOutputType;
 import graphql.schema.GraphQLScalarType;
 import graphql.schema.GraphQLSchema;
 import graphql.schema.GraphQLType;
@@ -172,9 +173,9 @@ private TypePrinter<GraphQLUnionType> unionPrinter() {
                 return;
             }
             out.format("union %s = ", type.getName());
-            List<GraphQLObjectType> types = type.getTypes();
+            List<GraphQLOutputType> types = type.getTypes();
             for (int i = 0; i < types.size(); i++) {
-                GraphQLObjectType objectType = types.get(i);
+                GraphQLOutputType objectType = types.get(i);
                 if (i > 0) {
                     out.format(" | ");
                 }

File: src/test/groovy/graphql/TypeReferenceSchema.java
Patch:
@@ -18,8 +18,8 @@ public class TypeReferenceSchema {
 
     public static GraphQLUnionType PetType = newUnionType()
             .name("Pet")
-            .possibleType(GraphQLObjectType.reference(CatType.getName()))
-            .possibleType(GraphQLObjectType.reference(DogType.getName()))
+            .possibleType(new GraphQLTypeReference(CatType.getName()))
+            .possibleType(new GraphQLTypeReference(DogType.getName()))
             .typeResolver(new TypeResolverProxy())
             .build();
     
@@ -38,7 +38,7 @@ public class TypeReferenceSchema {
             .field(newFieldDefinition()
                     .name("pet")
                     .type(new GraphQLTypeReference(PetType.getName())))
-            .withInterface(GraphQLInterfaceType.reference(NamedType.getName()))
+            .withInterface(new GraphQLTypeReference(NamedType.getName()))
             .build();
 
     public static GraphQLFieldDefinition exists = newFieldDefinition()

File: src/main/java/graphql/schema/idl/SchemaDecompiler.java
Patch:
@@ -9,6 +9,7 @@
 import graphql.schema.GraphQLList;
 import graphql.schema.GraphQLNonNull;
 import graphql.schema.GraphQLObjectType;
+import graphql.schema.GraphQLOutputType;
 import graphql.schema.GraphQLScalarType;
 import graphql.schema.GraphQLSchema;
 import graphql.schema.GraphQLType;
@@ -172,9 +173,9 @@ private TypePrinter<GraphQLUnionType> unionPrinter() {
                 return;
             }
             out.format("union %s = ", type.getName());
-            List<GraphQLObjectType> types = type.getTypes();
+            List<GraphQLOutputType> types = type.getTypes();
             for (int i = 0; i < types.size(); i++) {
-                GraphQLObjectType objectType = types.get(i);
+                GraphQLOutputType objectType = types.get(i);
                 if (i > 0) {
                     out.format(" | ");
                 }

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -6,7 +6,6 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
-import java.util.function.BinaryOperator;
 import java.util.function.UnaryOperator;
 
 import static graphql.Assert.assertNotNull;
@@ -43,7 +42,7 @@ public GraphQLFieldDefinition(String name, String description, GraphQLOutputType
 
 
     void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
-        type = (GraphQLOutputType) new SchemaUtil().resolveTypeReference(type, typeMap);
+        this.type = (GraphQLOutputType) new SchemaUtil().resolveTypeReference(this.type, typeMap);
     }
 
     public String getName() {

File: src/main/java/graphql/schema/GraphQLTypeReference.java
Patch:
@@ -1,14 +1,14 @@
 package graphql.schema;
 
 
-import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
 
 /**
  * A special type to allow a object/interface types to reference itself. It's replaced with the real type
  * object when the schema is build.
+ *
  */
-public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType, GraphQLInputType, TypeReference {
+public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType, GraphQLInputType {
 
     private final String name;
 

File: src/test/groovy/graphql/TypeReferenceSchema.java
Patch:
@@ -18,8 +18,8 @@ public class TypeReferenceSchema {
 
     public static GraphQLUnionType PetType = newUnionType()
             .name("Pet")
-            .possibleType(GraphQLObjectType.reference(CatType.getName()))
-            .possibleType(GraphQLObjectType.reference(DogType.getName()))
+            .possibleType(new GraphQLTypeReference(CatType.getName()))
+            .possibleType(new GraphQLTypeReference(DogType.getName()))
             .typeResolver(new TypeResolverProxy())
             .build();
     
@@ -38,7 +38,7 @@ public class TypeReferenceSchema {
             .field(newFieldDefinition()
                     .name("pet")
                     .type(new GraphQLTypeReference(PetType.getName())))
-            .withInterface(GraphQLInterfaceType.reference(NamedType.getName()))
+            .withInterface(new GraphQLTypeReference(NamedType.getName()))
             .build();
 
     public static GraphQLFieldDefinition exists = newFieldDefinition()

File: src/main/java/graphql/execution/ExecutionContextBuilder.java
Patch:
@@ -30,7 +30,7 @@ public ExecutionContextBuilder executionId(ExecutionId executionId) {
         return this;
     }
 
-    public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy, Object root, Document document, String operationName, Map<String, Object> args) {
+    public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy, ExecutionStrategy subscriptionStrategy, Object root, Document document, String operationName, Map<String, Object> args) {
         // preconditions
         assertNotNull(executionId, "You must provide a query identifier");
 
@@ -68,6 +68,7 @@ public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy que
                 graphQLSchema,
                 queryStrategy,
                 mutationStrategy,
+                subscriptionStrategy,
                 fragmentsByName,
                 operation,
                 variableValues,

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -392,8 +392,8 @@ public enum DirectiveLocation {
                     .description("'If this server support subscription, the type that subscription operations will be rooted at.")
                     .type(__Type)
                     .dataFetcher(environment -> {
-                        // Not yet supported
-                        return null;
+                        GraphQLSchema schema = environment.getSource();
+                        return schema.getSubscriptionType();
                     }))
             .build();
 

File: src/main/java/graphql/language/OperationDefinition.java
Patch:
@@ -7,7 +7,7 @@
 public class OperationDefinition extends AbstractNode implements Definition {
 
     public enum Operation {
-        QUERY, MUTATION
+        QUERY, MUTATION, SUBSCRIPTION
     }
 
     private String name;

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -192,6 +192,8 @@ private OperationDefinition.Operation parseOperation(GraphqlParser.OperationType
             return OperationDefinition.Operation.QUERY;
         } else if (operationTypeContext.getText().equals("mutation")) {
             return OperationDefinition.Operation.MUTATION;
+        } else if (operationTypeContext.getText().equals("subscription")) {
+            return OperationDefinition.Operation.SUBSCRIPTION;
         } else {
             throw new RuntimeException("InternalError: unknown operationTypeContext=" + operationTypeContext.getText());
         }

File: src/main/java/graphql/validation/TraversalContext.java
Patch:
@@ -81,6 +81,8 @@ private void enterImpl(OperationDefinition operationDefinition) {
             addType(schema.getMutationType());
         } else if (operationDefinition.getOperation() == OperationDefinition.Operation.QUERY) {
             addType(schema.getQueryType());
+        } else if (operationDefinition.getOperation() == OperationDefinition.Operation.SUBSCRIPTION) {
+            addType(schema.getSubscriptionType());
         } else {
             throw new ShouldNotHappenException();
         }

File: src/test/groovy/readme/ReadmeExamples.java
Patch:
@@ -178,6 +178,7 @@ void executionStrategies() {
         GraphQL graphQL = GraphQL.newGraphQL(StarWarsSchema.starWarsSchema)
                 .queryExecutionStrategy(new ExecutorServiceExecutionStrategy(threadPoolExecutor))
                 .mutationExecutionStrategy(new SimpleExecutionStrategy())
+                .subscriptionExecutionStrategy(new SimpleExecutionStrategy())
                 .build();
 
     }

File: src/main/java/graphql/schema/idl/errors/SchemaMissingError.java
Patch:
@@ -3,6 +3,6 @@
 public class SchemaMissingError extends BaseError {
 
     public SchemaMissingError() {
-        super(null, "There is no ttop level schema object defined");
+        super(null, "There is no top level schema object defined");
     }
 }

File: src/main/java/graphql/schema/idl/RuntimeWiring.java
Patch:
@@ -83,12 +83,13 @@ public Builder type(TypeRuntimeWiring.Builder builder) {
         /**
          * This form allows a lambda to be used as the builder of a type wiring
          *
+         * @param typeName the name of the type to wire
          * @param builderFunction a function that will be given the builder to use
          *
          * @return the runtime wiring builder
          */
-        public Builder type(UnaryOperator<TypeRuntimeWiring.Builder> builderFunction) {
-            TypeRuntimeWiring.Builder builder = builderFunction.apply(TypeRuntimeWiring.newTypeWiring());
+        public Builder type(String typeName, UnaryOperator<TypeRuntimeWiring.Builder> builderFunction) {
+            TypeRuntimeWiring.Builder builder = builderFunction.apply(TypeRuntimeWiring.newTypeWiring(typeName));
             return type(builder.build());
         }
 

File: src/test/groovy/readme/ReadmeExamples.java
Patch:
@@ -57,6 +57,9 @@
 /**
  * This class holds readme examples so they stay correct and can be compiled.  If this
  * does not compile, chances are the readme examples are now wrong.
+ *
+ * You should place these examples into the README.next.md and NOT the main README.md.  This allows
+ * 'master' to progress yet shows consumers the released information about the project.
  */
 @SuppressWarnings({"unused", "Convert2Lambda", "UnnecessaryLocalVariable"})
 public class ReadmeExamples {

File: src/main/java/graphql/schema/idl/RuntimeWiring.java
Patch:
@@ -83,12 +83,13 @@ public Builder type(TypeRuntimeWiring.Builder builder) {
         /**
          * This form allows a lambda to be used as the builder of a type wiring
          *
+         * @param typeName the name of the type to wire
          * @param builderFunction a function that will be given the builder to use
          *
          * @return the runtime wiring builder
          */
-        public Builder type(UnaryOperator<TypeRuntimeWiring.Builder> builderFunction) {
-            TypeRuntimeWiring.Builder builder = builderFunction.apply(TypeRuntimeWiring.newTypeWiring());
+        public Builder type(String typeName, UnaryOperator<TypeRuntimeWiring.Builder> builderFunction) {
+            TypeRuntimeWiring.Builder builder = builderFunction.apply(TypeRuntimeWiring.newTypeWiring(typeName));
             return type(builder.build());
         }
 

File: src/main/java/graphql/relay/SimpleListConnection.java
Patch:
@@ -80,9 +80,9 @@ public Connection<T> get(DataFetchingEnvironment environment) {
             !lastEdge.getCursor().equals(lastPresliceCursor)
         );
 
-        return new DefaultConnection<T>(
-            edges,
-            pageInfo
+        return new DefaultConnection<>(
+                edges,
+                pageInfo
         );
     }
 

File: src/test/groovy/graphql/validation/rules/Harness.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.validation.rules;
 
+import graphql.TypeResolutionEnvironment;
 import graphql.schema.*;
 
 import static graphql.Scalars.*;
@@ -14,7 +15,7 @@
 
 public class Harness {
 
-    private static TypeResolver dummyTypeResolve = object -> null;
+    private static TypeResolver dummyTypeResolve = env -> null;
 
 
     public static GraphQLInterfaceType Being = newInterface()
@@ -112,7 +113,7 @@ public class Harness {
     public static GraphQLUnionType CatOrDog = newUnionType()
             .name("CatOrDog")
             .possibleTypes(Dog, Cat)
-            .typeResolver(object -> null)
+            .typeResolver(env -> null)
             .build();
 
     public static GraphQLInterfaceType Intelligent = newInterface()

File: src/main/java/graphql/language/TypeDefinition.java
Patch:
@@ -5,5 +5,5 @@ public interface TypeDefinition extends Node, Definition {
     /**
      * @return the name of the type being defined.
      */
-    public String getName();
+    String getName();
 }

File: src/main/java/graphql/relay/SimpleListConnection.java
Patch:
@@ -43,9 +43,9 @@ public Connection<T> get(DataFetchingEnvironment environment) {
 
         List<Edge<T>> edges = buildEdges();
 
-        int afterOffset = getOffsetFromCursor(environment.<String>getArgument("after"), -1);
+        int afterOffset = getOffsetFromCursor(environment.getArgument("after"), -1);
         int begin = Math.max(afterOffset, -1) + 1;
-        int beforeOffset = getOffsetFromCursor(environment.<String>getArgument("before"), edges.size());
+        int beforeOffset = getOffsetFromCursor(environment.getArgument("before"), edges.size());
         int end = Math.min(beforeOffset, edges.size());
 
         edges = edges.subList(begin, end);

File: src/main/java/graphql/schema/GraphQLDirective.java
Patch:
@@ -4,6 +4,7 @@
 import java.util.ArrayList;
 import java.util.EnumSet;
 import java.util.List;
+import java.util.function.UnaryOperator;
 
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
@@ -130,7 +131,7 @@ public Builder argument(GraphQLArgument fieldArgument) {
          * @param builderFunction a supplier for the builder impl
          * @return this
          */
-        public Builder argument(BuilderFunction<GraphQLArgument.Builder> builderFunction) {
+        public Builder argument(UnaryOperator<GraphQLArgument.Builder> builderFunction) {
             GraphQLArgument.Builder builder = GraphQLArgument.newArgument();
             builder = builderFunction.apply(builder);
             return argument(builder);

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -6,6 +6,8 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.function.BinaryOperator;
+import java.util.function.UnaryOperator;
 
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
@@ -169,7 +171,7 @@ public Builder argument(GraphQLArgument argument) {
          * @param builderFunction a supplier for the builder impl
          * @return this
          */
-        public Builder argument(BuilderFunction<GraphQLArgument.Builder> builderFunction) {
+        public Builder argument(UnaryOperator<GraphQLArgument.Builder> builderFunction) {
             GraphQLArgument.Builder builder = GraphQLArgument.newArgument();
             builder = builderFunction.apply(builder);
             return argument(builder);

File: src/main/java/graphql/schema/GraphQLInputObjectType.java
Patch:
@@ -5,6 +5,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.function.UnaryOperator;
 
 import graphql.AssertException;
 import graphql.language.InputObjectTypeDefinition;
@@ -117,7 +118,7 @@ public Builder field(GraphQLInputObjectField field) {
          * @param builderFunction a supplier for the builder impl
          * @return this
          */
-        public Builder field(BuilderFunction<GraphQLInputObjectField.Builder> builderFunction) {
+        public Builder field(UnaryOperator<GraphQLInputObjectField.Builder> builderFunction) {
             assertNotNull(builderFunction, "builderFunction should not be null");
             GraphQLInputObjectField.Builder builder = GraphQLInputObjectField.newInputObjectField();
             builder = builderFunction.apply(builder);

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -5,6 +5,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.function.UnaryOperator;
 
 import graphql.AssertException;
 import graphql.language.InterfaceTypeDefinition;
@@ -127,7 +128,7 @@ public Builder field(GraphQLFieldDefinition fieldDefinition) {
          * @param builderFunction a supplier for the builder impl
          * @return this
          */
-        public Builder field(BuilderFunction<GraphQLFieldDefinition.Builder> builderFunction) {
+        public Builder field(UnaryOperator<GraphQLFieldDefinition.Builder> builderFunction) {
             assertNotNull(builderFunction, "builderFunction can't be null");
             GraphQLFieldDefinition.Builder builder = GraphQLFieldDefinition.newFieldDefinition();
             builder = builderFunction.apply(builder);

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -8,6 +8,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.function.UnaryOperator;
 
 import static graphql.Assert.assertNotNull;
 import static graphql.Assert.assertValidName;
@@ -141,7 +142,7 @@ public Builder field(GraphQLFieldDefinition fieldDefinition) {
          * @param builderFunction a supplier for the builder impl
          * @return this
          */
-        public Builder field(BuilderFunction<GraphQLFieldDefinition.Builder> builderFunction) {
+        public Builder field(UnaryOperator<GraphQLFieldDefinition.Builder> builderFunction) {
             assertNotNull(builderFunction, "builderFunction can't be null");
             GraphQLFieldDefinition.Builder builder = GraphQLFieldDefinition.newFieldDefinition();
             builder = builderFunction.apply(builder);

File: src/main/java/graphql/schema/idl/RuntimeWiring.java
Patch:
@@ -1,13 +1,13 @@
 package graphql.schema.idl;
 
-import graphql.schema.BuilderFunction;
 import graphql.schema.DataFetcher;
 import graphql.schema.GraphQLScalarType;
 import graphql.schema.GraphQLSchema;
 import graphql.schema.TypeResolver;
 
 import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.function.UnaryOperator;
 
 /**
  * A runtime wiring is a specification of data fetchers, type resolves and custom scalars that are needed
@@ -87,7 +87,7 @@ public Builder type(TypeRuntimeWiring.Builder builder) {
          *
          * @return the runtime wiring builder
          */
-        public Builder type(BuilderFunction<TypeRuntimeWiring.Builder> builderFunction) {
+        public Builder type(UnaryOperator<TypeRuntimeWiring.Builder> builderFunction) {
             TypeRuntimeWiring.Builder builder = builderFunction.apply(TypeRuntimeWiring.newTypeWiring());
             return type(builder.build());
         }

File: src/main/java/graphql/schema/idl/TypeRuntimeWiring.java
Patch:
@@ -1,13 +1,13 @@
 package graphql.schema.idl;
 
 import graphql.Assert;
-import graphql.schema.BuilderFunction;
 import graphql.schema.DataFetcher;
 import graphql.schema.GraphQLSchema;
 import graphql.schema.TypeResolver;
 
 import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.function.UnaryOperator;
 
 /**
  * A type runtime wiring is a specification of the data fetchers and possible type resolver for a given type name.
@@ -64,7 +64,7 @@ public static Builder newTypeWiring() {
      *
      * @return the same builder back please
      */
-    public static TypeRuntimeWiring newTypeWiring(BuilderFunction<Builder> builderFunction) {
+    public static TypeRuntimeWiring newTypeWiring(UnaryOperator<Builder> builderFunction) {
         return builderFunction.apply(newTypeWiring()).build();
     }
 

File: src/test/groovy/graphql/GarfieldSchema.java
Patch:
@@ -69,7 +69,7 @@ public static class Person implements Named {
         private List<Named> friends;
 
         public Person(String name) {
-            this(name, Collections.<Cat>emptyList(), Collections.<Dog>emptyList(), Collections.<Named>emptyList());
+            this(name, Collections.emptyList(), Collections.emptyList(), Collections.emptyList());
         }
 
         public Person(String name, List<Cat> cats, List<Dog> dogs, List<Named> friends) {

File: src/main/java/graphql/relay/SimpleListConnection.java
Patch:
@@ -43,9 +43,9 @@ public Connection<T> get(DataFetchingEnvironment environment) {
 
         List<Edge<T>> edges = buildEdges();
 
-        int afterOffset = getOffsetFromCursor(environment.<String>getArgument("after"), -1);
+        int afterOffset = getOffsetFromCursor(environment.getArgument("after"), -1);
         int begin = Math.max(afterOffset, -1) + 1;
-        int beforeOffset = getOffsetFromCursor(environment.<String>getArgument("before"), edges.size());
+        int beforeOffset = getOffsetFromCursor(environment.getArgument("before"), edges.size());
         int end = Math.min(beforeOffset, edges.size());
 
         edges = edges.subList(begin, end);

File: src/test/groovy/graphql/GarfieldSchema.java
Patch:
@@ -69,7 +69,7 @@ public static class Person implements Named {
         private List<Named> friends;
 
         public Person(String name) {
-            this(name, Collections.<Cat>emptyList(), Collections.<Dog>emptyList(), Collections.<Named>emptyList());
+            this(name, Collections.emptyList(), Collections.emptyList(), Collections.emptyList());
         }
 
         public Person(String name, List<Cat> cats, List<Dog> dogs, List<Named> friends) {

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -270,11 +270,10 @@ private List<GraphQLExecutionNodeValue> fetchData(ExecutionContext executionCont
         DataFetchingEnvironment environment = new DataFetchingEnvironmentImpl(
                 sources,
                 argumentValues,
-                executionContext.getRoot(),
                 fields,
                 fieldDef.getType(),
                 parentType,
-                executionContext.getGraphQLSchema()
+                executionContext
         );
 
         List<Object> values;

File: src/main/java/graphql/execution/batched/UnbatchedDataFetcher.java
Patch:
@@ -35,7 +35,9 @@ public Object get(DataFetchingEnvironment environment) {
                     environment.getFields(),
                     environment.getFieldType(),
                     environment.getParentType(),
-                    environment.getGraphQLSchema());
+                    environment.getGraphQLSchema(),
+                    environment.getFragmentsByName(),
+                    environment.getExecutionId());
             results.add(delegate.get(singleEnv));
         }
         return results;

File: src/main/java/graphql/relay/DefaultConnection.java
Patch:
@@ -41,6 +41,7 @@ public List<Edge<T>> getEdges() {
 
     /**
      * @deprecated prefer {@link #DefaultConnection(List, PageInfo)} and avoid mutation
+     * @param edges edges
      */
     @Deprecated
     public void setEdges(List<Edge<T>> edges) {
@@ -57,6 +58,7 @@ public PageInfo getPageInfo() {
 
     /**
      * @deprecated prefer {@link #DefaultConnection(List, PageInfo)} and avoid mutation
+     * @param pageInfo page info
      */
     @Deprecated
     public void setPageInfo(PageInfo pageInfo) {

File: src/main/java/graphql/relay/DefaultEdge.java
Patch:
@@ -30,6 +30,7 @@ public T getNode() {
 
     /**
      * @deprecated prefer {@link #DefaultEdge(Object, ConnectionCursor)} and avoid mutation.
+     * @param  node node
      */
     @Deprecated
     public void setNode(T node) {
@@ -43,6 +44,7 @@ public ConnectionCursor getCursor() {
 
     /**
      * @deprecated prefer {@link #DefaultEdge(Object, ConnectionCursor)} and avoid mutation.
+     * @param cursor cursor
      */
     @Deprecated
     public void setCursor(ConnectionCursor cursor) {

File: src/main/java/graphql/relay/SimpleListConnection.java
Patch:
@@ -93,6 +93,8 @@ private Connection<T> emptyConnection() {
 
     /**
      * find the object's cursor, or null if the object is not in this connection.
+     * @param object the object in play
+     * @return a connection cursor
      */
     public ConnectionCursor cursorForObjectInConnection(T object) {
         int index = data.indexOf(object);

File: src/main/java/graphql/validation/RulesVisitor.java
Patch:
@@ -112,7 +112,7 @@ private void checkFragmentSpread(FragmentSpread fragmentSpread, List<AbstractRul
         List<AbstractRule> rulesVisitingFragmentSpreads = getRulesVisitingFragmentSpreads(rules);
         if (rulesVisitingFragmentSpreads.size() > 0) {
             FragmentDefinition fragment = validationContext.getFragment(fragmentSpread.getName());
-            if(!ancestors.contains(fragment)){
+            if (fragment != null && !ancestors.contains(fragment)) {
                 new LanguageTraversal(ancestors).traverse(fragment, new RulesVisitor(validationContext, rulesVisitingFragmentSpreads, true));
             }
         }

File: src/main/java/graphql/validation/rules/NoUnusedFragments.java
Patch:
@@ -67,6 +67,9 @@ private void collectUsedFragmentsInDefinition(List<String> result, String fragme
         if (result.contains(fragmentName)) return;
         result.add(fragmentName);
         List<String> spreadList = spreadsInDefinition.get(fragmentName);
+        if (spreadList == null) {
+            return;
+        }
         for (String fragment : spreadList) {
             collectUsedFragmentsInDefinition(result, fragment);
         }

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -255,11 +255,10 @@ private List<GraphQLExecutionNodeValue> fetchData(ExecutionContext executionCont
         DataFetchingEnvironment environment = new DataFetchingEnvironmentImpl(
                 sources,
                 argumentValues,
-                executionContext.getRoot(),
                 fields,
                 fieldDef.getType(),
                 parentType,
-                executionContext.getGraphQLSchema()
+                executionContext
         );
 
         List<Object> values;

File: src/main/java/graphql/execution/batched/UnbatchedDataFetcher.java
Patch:
@@ -35,7 +35,9 @@ public Object get(DataFetchingEnvironment environment) {
                     environment.getFields(),
                     environment.getFieldType(),
                     environment.getParentType(),
-                    environment.getGraphQLSchema());
+                    environment.getGraphQLSchema(),
+                    environment.getFragmentsByName(),
+                    environment.getExecutionId());
             results.add(delegate.get(singleEnv));
         }
         return results;

File: src/main/java/graphql/relay/DefaultConnection.java
Patch:
@@ -41,6 +41,7 @@ public List<Edge<T>> getEdges() {
 
     /**
      * @deprecated prefer {@link #DefaultConnection(List, PageInfo)} and avoid mutation
+     * @param edges edges
      */
     @Deprecated
     public void setEdges(List<Edge<T>> edges) {
@@ -57,6 +58,7 @@ public PageInfo getPageInfo() {
 
     /**
      * @deprecated prefer {@link #DefaultConnection(List, PageInfo)} and avoid mutation
+     * @param pageInfo page info
      */
     @Deprecated
     public void setPageInfo(PageInfo pageInfo) {

File: src/main/java/graphql/relay/DefaultEdge.java
Patch:
@@ -30,6 +30,7 @@ public T getNode() {
 
     /**
      * @deprecated prefer {@link #DefaultEdge(Object, ConnectionCursor)} and avoid mutation.
+     * @param  node node
      */
     @Deprecated
     public void setNode(T node) {
@@ -43,6 +44,7 @@ public ConnectionCursor getCursor() {
 
     /**
      * @deprecated prefer {@link #DefaultEdge(Object, ConnectionCursor)} and avoid mutation.
+     * @param cursor cursor
      */
     @Deprecated
     public void setCursor(ConnectionCursor cursor) {

File: src/main/java/graphql/relay/SimpleListConnection.java
Patch:
@@ -93,6 +93,8 @@ private Connection<T> emptyConnection() {
 
     /**
      * find the object's cursor, or null if the object is not in this connection.
+     * @param object the object in play
+     * @return a connection cursor
      */
     public ConnectionCursor cursorForObjectInConnection(T object) {
         int index = data.indexOf(object);

File: src/main/java/graphql/validation/RulesVisitor.java
Patch:
@@ -112,7 +112,7 @@ private void checkFragmentSpread(FragmentSpread fragmentSpread, List<AbstractRul
         List<AbstractRule> rulesVisitingFragmentSpreads = getRulesVisitingFragmentSpreads(rules);
         if (rulesVisitingFragmentSpreads.size() > 0) {
             FragmentDefinition fragment = validationContext.getFragment(fragmentSpread.getName());
-            if(!ancestors.contains(fragment)){
+            if (fragment != null && !ancestors.contains(fragment)) {
                 new LanguageTraversal(ancestors).traverse(fragment, new RulesVisitor(validationContext, rulesVisitingFragmentSpreads, true));
             }
         }

File: src/main/java/graphql/validation/rules/NoUnusedFragments.java
Patch:
@@ -67,6 +67,9 @@ private void collectUsedFragmentsInDefinition(List<String> result, String fragme
         if (result.contains(fragmentName)) return;
         result.add(fragmentName);
         List<String> spreadList = spreadsInDefinition.get(fragmentName);
+        if (spreadList == null) {
+            return;
+        }
         for (String fragment : spreadList) {
             collectUsedFragmentsInDefinition(result, fragment);
         }

File: src/main/java/graphql/validation/RulesVisitor.java
Patch:
@@ -112,7 +112,7 @@ private void checkFragmentSpread(FragmentSpread fragmentSpread, List<AbstractRul
         List<AbstractRule> rulesVisitingFragmentSpreads = getRulesVisitingFragmentSpreads(rules);
         if (rulesVisitingFragmentSpreads.size() > 0) {
             FragmentDefinition fragment = validationContext.getFragment(fragmentSpread.getName());
-            if(!ancestors.contains(fragment)){
+            if (fragment != null && !ancestors.contains(fragment)) {
                 new LanguageTraversal(ancestors).traverse(fragment, new RulesVisitor(validationContext, rulesVisitingFragmentSpreads, true));
             }
         }

File: src/main/java/graphql/validation/rules/NoUnusedFragments.java
Patch:
@@ -67,6 +67,9 @@ private void collectUsedFragmentsInDefinition(List<String> result, String fragme
         if (result.contains(fragmentName)) return;
         result.add(fragmentName);
         List<String> spreadList = spreadsInDefinition.get(fragmentName);
+        if (spreadList == null) {
+            return;
+        }
         for (String fragment : spreadList) {
             collectUsedFragmentsInDefinition(result, fragment);
         }

File: src/main/java/graphql/schema/TypeResolver.java
Patch:
@@ -1,9 +1,10 @@
 package graphql.schema;
 
 
-public interface TypeResolver {
+import graphql.TypeResolutionEnvironment;
 
+public interface TypeResolver {
 
-    GraphQLObjectType getType(Object object);
+    GraphQLObjectType getType(TypeResolutionEnvironment env);
 
 }

File: src/main/java/graphql/relay/DefaultConnection.java
Patch:
@@ -41,6 +41,7 @@ public List<Edge<T>> getEdges() {
 
     /**
      * @deprecated prefer {@link #DefaultConnection(List, PageInfo)} and avoid mutation
+     * @param edges edges
      */
     @Deprecated
     public void setEdges(List<Edge<T>> edges) {
@@ -57,6 +58,7 @@ public PageInfo getPageInfo() {
 
     /**
      * @deprecated prefer {@link #DefaultConnection(List, PageInfo)} and avoid mutation
+     * @param pageInfo page info
      */
     @Deprecated
     public void setPageInfo(PageInfo pageInfo) {

File: src/main/java/graphql/relay/DefaultEdge.java
Patch:
@@ -30,6 +30,7 @@ public T getNode() {
 
     /**
      * @deprecated prefer {@link #DefaultEdge(Object, ConnectionCursor)} and avoid mutation.
+     * @param  node node
      */
     @Deprecated
     public void setNode(T node) {
@@ -43,6 +44,7 @@ public ConnectionCursor getCursor() {
 
     /**
      * @deprecated prefer {@link #DefaultEdge(Object, ConnectionCursor)} and avoid mutation.
+     * @param cursor cursor
      */
     @Deprecated
     public void setCursor(ConnectionCursor cursor) {

File: src/main/java/graphql/relay/SimpleListConnection.java
Patch:
@@ -93,6 +93,8 @@ private Connection<T> emptyConnection() {
 
     /**
      * find the object's cursor, or null if the object is not in this connection.
+     * @param object the object in play
+     * @return a connection cursor
      */
     public ConnectionCursor cursorForObjectInConnection(T object) {
         int index = data.indexOf(object);

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -69,11 +69,10 @@ protected ExecutionResult resolveField(ExecutionContext executionContext, Execut
         DataFetchingEnvironment environment = new DataFetchingEnvironmentImpl(
                 parameters.source(),
                 argumentValues,
-                executionContext.getRoot(),
                 fields,
                 fieldDef.getType(),
                 type,
-                executionContext.getGraphQLSchema()
+                executionContext
         );
 
         Instrumentation instrumentation = executionContext.getInstrumentation();

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -255,11 +255,10 @@ private List<GraphQLExecutionNodeValue> fetchData(ExecutionContext executionCont
         DataFetchingEnvironment environment = new DataFetchingEnvironmentImpl(
                 sources,
                 argumentValues,
-                executionContext.getRoot(),
                 fields,
                 fieldDef.getType(),
                 parentType,
-                executionContext.getGraphQLSchema()
+                executionContext
         );
 
         List<Object> values;

File: src/main/java/graphql/execution/batched/UnbatchedDataFetcher.java
Patch:
@@ -35,7 +35,9 @@ public Object get(DataFetchingEnvironment environment) {
                     environment.getFields(),
                     environment.getFieldType(),
                     environment.getParentType(),
-                    environment.getGraphQLSchema());
+                    environment.getGraphQLSchema(),
+                    environment.getFragmentsByName(),
+                    environment.getExecutionId());
             results.add(delegate.get(singleEnv));
         }
         return results;

File: src/main/java/graphql/relay/Connection.java
Patch:
@@ -5,9 +5,9 @@
 /**
  * represents a connection in relay.
  */
-public interface Connection {
+public interface Connection<T> {
 
-    List<Edge> getEdges();
+    List<Edge<T>> getEdges();
 
     PageInfo getPageInfo();
 

File: src/main/java/graphql/relay/ConnectionCursor.java
Patch:
@@ -1,7 +1,7 @@
 package graphql.relay;
 
 /**
- * represents a connection cursor in relay.
+ * represents a {@link Connection connection} cursor in relay.
  */
 public interface ConnectionCursor {
 

File: src/main/java/graphql/relay/Edge.java
Patch:
@@ -3,9 +3,9 @@
 /**
  * represents an edge in relay.
  */
-public interface Edge {
+public interface Edge<T> {
 
-    Object getNode();
+    T getNode();
 
     ConnectionCursor getCursor();
 

File: src/main/java/graphql/language/AbstractNode.java
Patch:
@@ -9,7 +9,7 @@
 public abstract class AbstractNode implements Node {
 
     private SourceLocation sourceLocation;
-    private List<String> comments = Collections.emptyList();
+    private List<Comment> comments = Collections.emptyList();
 
 
     public void setSourceLocation(SourceLocation sourceLocation) {
@@ -21,11 +21,11 @@ public SourceLocation getSourceLocation() {
         return sourceLocation;
     }
 
-    public List<String> getComments() {
+    public List<Comment> getComments() {
         return comments;
     }
 
-    public void setComments(List<String> comments) {
+    public void setComments(List<Comment> comments) {
         assertNotNull(comments, "You must provide non null comments");
         this.comments = comments;
     }

File: src/main/java/graphql/language/Node.java
Patch:
@@ -14,7 +14,7 @@ public interface Node {
      *
      * @return the list of comments or an empty list of there are none
      */
-    List<String> getComments();
+    List<Comment> getComments();
 
     /**
      * Compares just the content and not the children.

File: src/main/java/graphql/language/Node.java
Patch:
@@ -10,7 +10,7 @@ public interface Node {
     SourceLocation getSourceLocation();
 
     /**
-     * Nodes can have comments made on them
+     * Nodes can have comments made on them, the following is one comment per line before a node.
      *
      * @return the list of comments or an empty list of there are none
      */

File: src/main/java/graphql/ExceptionWhileDataFetching.java
Patch:
@@ -20,7 +20,7 @@ public Throwable getException() {
 
     @Override
     public String getMessage() {
-        return "Exception while fetching data: " + exception.toString();
+        return "Exception while fetching data: " + exception.getMessage();
     }
 
     @Override

File: src/main/java/graphql/InvalidSyntaxError.java
Patch:
@@ -8,7 +8,7 @@
 
 public class InvalidSyntaxError implements GraphQLError {
 
-    private final List<SourceLocation> sourceLocations = new ArrayList<SourceLocation>();
+    private final List<SourceLocation> sourceLocations = new ArrayList<>();
 
     public InvalidSyntaxError(SourceLocation sourceLocation) {
         if (sourceLocation != null)

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -78,8 +78,8 @@ private ExecutionResult executeOperation(
             return new ExecutionResultImpl(Collections.singletonList(new MutationNotSupportedError()));
         }
 
-        Map<String, List<Field>> fields = new LinkedHashMap<String, List<Field>>();
-        fieldCollector.collectFields(executionContext, operationRootType, operationDefinition.getSelectionSet(), new ArrayList<String>(), fields);
+        Map<String, List<Field>> fields = new LinkedHashMap<>();
+        fieldCollector.collectFields(executionContext, operationRootType, operationDefinition.getSelectionSet(), new ArrayList<>(), fields);
 
 
         ExecutionParameters parameters = newParameters()

File: src/main/java/graphql/execution/ExecutionContext.java
Patch:
@@ -22,7 +22,7 @@ public class ExecutionContext {
     private final OperationDefinition operationDefinition;
     private final Map<String, Object> variables;
     private final Object root;
-    private final List<GraphQLError> errors = new CopyOnWriteArrayList<GraphQLError>();
+    private final List<GraphQLError> errors = new CopyOnWriteArrayList<>();
     private final Instrumentation instrumentation;
 
     public ExecutionContext(Instrumentation instrumentation, ExecutionId executionId, GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy, Map<String, FragmentDefinition> fragmentsByName, OperationDefinition operationDefinition, Map<String, Object> variables, Object root) {

File: src/main/java/graphql/execution/ExecutionContextBuilder.java
Patch:
@@ -34,8 +34,8 @@ public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy que
         // preconditions
         assertNotNull(executionId, "You must provide a query identifier");
 
-        Map<String, FragmentDefinition> fragmentsByName = new LinkedHashMap<String, FragmentDefinition>();
-        Map<String, OperationDefinition> operationsByName = new LinkedHashMap<String, OperationDefinition>();
+        Map<String, FragmentDefinition> fragmentsByName = new LinkedHashMap<>();
+        Map<String, OperationDefinition> operationsByName = new LinkedHashMap<>();
 
         for (Definition definition : document.getDefinitions()) {
             if (definition instanceof OperationDefinition) {

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -123,8 +123,8 @@ protected ExecutionResult completeValue(ExecutionContext executionContext, Execu
             resolvedType = (GraphQLObjectType) fieldType;
         }
 
-        Map<String, List<Field>> subFields = new LinkedHashMap<String, List<Field>>();
-        List<String> visitedFragments = new ArrayList<String>();
+        Map<String, List<Field>> subFields = new LinkedHashMap<>();
+        List<String> visitedFragments = new ArrayList<>();
         for (Field field : fields) {
             if (field.getSelectionSet() == null) continue;
             fieldCollector.collectFields(executionContext, resolvedType, field.getSelectionSet(), visitedFragments, subFields);
@@ -178,7 +178,7 @@ protected ExecutionResult completeValueForScalar(GraphQLScalarType scalarType, O
     }
 
     protected ExecutionResult completeValueForList(ExecutionContext executionContext, ExecutionParameters parameters, List<Field> fields, Iterable<Object> result) {
-        List<Object> completedResults = new ArrayList<Object>();
+        List<Object> completedResults = new ArrayList<>();
         TypeInfo typeInfo = parameters.typeInfo();
         GraphQLList fieldType = typeInfo.castType(GraphQLList.class);
         for (Object item : result) {

File: src/main/java/graphql/execution/ExecutorServiceExecutionStrategy.java
Patch:
@@ -42,7 +42,7 @@ public ExecutionResult execute(final ExecutionContext executionContext, final Ex
             return new SimpleExecutionStrategy().execute(executionContext,parameters);
 
         Map<String, List<Field>> fields = parameters.fields();
-        Map<String, Future<ExecutionResult>> futures = new LinkedHashMap<String, Future<ExecutionResult>>();
+        Map<String, Future<ExecutionResult>> futures = new LinkedHashMap<>();
         for (String fieldName : fields.keySet()) {
             final List<Field> fieldList = fields.get(fieldName);
             Callable<ExecutionResult> resolveField = new Callable<ExecutionResult>() {
@@ -55,7 +55,7 @@ public ExecutionResult call() throws Exception {
             futures.put(fieldName, executorService.submit(resolveField));
         }
         try {
-            Map<String, Object> results = new LinkedHashMap<String, Object>();
+            Map<String, Object> results = new LinkedHashMap<>();
             for (String fieldName : futures.keySet()) {
                 ExecutionResult executionResult = futures.get(fieldName).get();
 

File: src/main/java/graphql/execution/FieldCollector.java
Patch:
@@ -67,7 +67,7 @@ private void collectField(ExecutionContext executionContext, Map<String, List<Fi
         }
         String name = getFieldEntryKey(field);
         if (!fields.containsKey(name)) {
-            fields.put(name, new ArrayList<Field>());
+            fields.put(name, new ArrayList<>());
         }
         fields.get(name).add(field);
     }

File: src/main/java/graphql/execution/SimpleExecutionStrategy.java
Patch:
@@ -12,7 +12,7 @@ public class SimpleExecutionStrategy extends ExecutionStrategy {
     @Override
     public ExecutionResult execute(ExecutionContext executionContext, ExecutionParameters parameters) throws NonNullableFieldWasNullException {
         Map<String, List<Field>> fields = parameters.fields();
-        Map<String, Object> results = new LinkedHashMap<String, Object>();
+        Map<String, Object> results = new LinkedHashMap<>();
         for (String fieldName : fields.keySet()) {
             List<Field> fieldList = fields.get(fieldName);
             try {

File: src/main/java/graphql/execution/batched/GraphQLExecutionResultContainer.java
Patch:
@@ -14,13 +14,13 @@ public abstract class GraphQLExecutionResultContainer {
      * @return datum
      */
     public GraphQLExecutionNodeDatum createAndPutChildDatum(String fieldName, Object value) {
-        Map<String, Object> map = new LinkedHashMap<String, Object>();
+        Map<String, Object> map = new LinkedHashMap<>();
         putResult(fieldName, map);
         return new GraphQLExecutionNodeDatum(map, value);
     }
 
     public GraphQLExecutionResultList createAndPutEmptyChildList(String fieldName) {
-        List<Object> resultList = new ArrayList<Object>();
+        List<Object> resultList = new ArrayList<>();
         putResult(fieldName, resultList);
         return new GraphQLExecutionResultList(resultList);
     }

File: src/main/java/graphql/execution/batched/UnbatchedDataFetcher.java
Patch:
@@ -26,7 +26,7 @@ public UnbatchedDataFetcher(DataFetcher delegate) {
     @Override
     public Object get(DataFetchingEnvironment environment) {
         List<Object> sources = environment.getSource();
-        List<Object> results = new ArrayList<Object>();
+        List<Object> results = new ArrayList<>();
         for (Object source : sources) {
             DataFetchingEnvironment singleEnv = new DataFetchingEnvironmentImpl(
                     source,

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -183,7 +183,7 @@ public Object get(DataFetchingEnvironment environment) {
                 GraphQLFieldsContainer fieldsContainer = (GraphQLFieldsContainer) type;
                 List<GraphQLFieldDefinition> fieldDefinitions = fieldsContainer.getFieldDefinitions();
                 if (includeDeprecated) return fieldDefinitions;
-                List<GraphQLFieldDefinition> filtered = new ArrayList<GraphQLFieldDefinition>(fieldDefinitions);
+                List<GraphQLFieldDefinition> filtered = new ArrayList<>(fieldDefinitions);
                 for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {
                     if (fieldDefinition.isDeprecated()) filtered.remove(fieldDefinition);
                 }
@@ -226,7 +226,7 @@ public Object get(DataFetchingEnvironment environment) {
             if (type instanceof GraphQLEnumType) {
                 List<GraphQLEnumValueDefinition> values = ((GraphQLEnumType) type).getValues();
                 if (includeDeprecated) return values;
-                List<GraphQLEnumValueDefinition> filtered = new ArrayList<GraphQLEnumValueDefinition>(values);
+                List<GraphQLEnumValueDefinition> filtered = new ArrayList<>(values);
                 for (GraphQLEnumValueDefinition valueDefinition : values) {
                     if (valueDefinition.isDeprecated()) filtered.remove(valueDefinition);
                 }
@@ -343,7 +343,7 @@ public enum DirectiveLocation {
                         @Override
                         public Object get(DataFetchingEnvironment environment) {
                             GraphQLDirective directive = environment.getSource();
-                            return new ArrayList<DirectiveLocation>(directive.validLocations());
+                            return new ArrayList<>(directive.validLocations());
                         }
                     }))
             .field(newFieldDefinition()

File: src/main/java/graphql/language/Argument.java
Patch:
@@ -33,7 +33,7 @@ public void setValue(Value value) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(value);
         return result;
     }

File: src/main/java/graphql/language/ArrayValue.java
Patch:
@@ -6,7 +6,7 @@
 
 public class ArrayValue extends AbstractNode implements Value {
 
-    private List<Value> values = new ArrayList<Value>();
+    private List<Value> values = new ArrayList<>();
 
     public ArrayValue() {
     }
@@ -26,7 +26,7 @@ public void setValues(List<Value> values) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>(values);
+        return new ArrayList<>(values);
     }
 
     @Override

File: src/main/java/graphql/language/BooleanValue.java
Patch:
@@ -23,7 +23,7 @@ public void setValue(boolean value) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/language/Directive.java
Patch:
@@ -6,7 +6,7 @@
 
 public class Directive extends AbstractNode {
     private String name;
-    private final List<Argument> arguments = new ArrayList<Argument>();
+    private final List<Argument> arguments = new ArrayList<>();
 
     public Directive() {
 
@@ -36,7 +36,7 @@ public void setName(String name) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>(arguments);
+        return new ArrayList<>(arguments);
     }
 
     @Override

File: src/main/java/graphql/language/DirectiveDefinition.java
Patch:
@@ -6,8 +6,8 @@
 
 public class DirectiveDefinition extends AbstractNode implements Definition {
     private String name;
-    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<InputValueDefinition>();
-    private List<DirectiveLocation> directiveLocations = new ArrayList<DirectiveLocation>();
+    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
+    private List<DirectiveLocation> directiveLocations = new ArrayList<>();
 
     public DirectiveDefinition(String name) {
         this.name = name;
@@ -23,7 +23,7 @@ public List<DirectiveLocation> getDirectiveLocations() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(inputValueDefinitions);
         result.addAll(directiveLocations);
         return result;

File: src/main/java/graphql/language/DirectiveLocation.java
Patch:
@@ -21,7 +21,7 @@ public DirectiveLocation(String name) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         return result;
     }
 

File: src/main/java/graphql/language/Document.java
Patch:
@@ -6,7 +6,7 @@
 
 public class Document extends AbstractNode {
 
-    private List<Definition> definitions = new ArrayList<Definition>();
+    private List<Definition> definitions = new ArrayList<>();
 
     public Document() {
 
@@ -27,7 +27,7 @@ public void setDefinitions(List<Definition> definitions) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>(definitions);
+        return new ArrayList<>(definitions);
     }
 
 

File: src/main/java/graphql/language/EnumTypeDefinition.java
Patch:
@@ -15,8 +15,8 @@ public EnumTypeDefinition(String name) {
 
     public EnumTypeDefinition(String name, List<Directive> directives) {
         this.name = name;
-        this.directives = ( null == directives ) ? new ArrayList<Directive>() : directives;
-        this.enumValueDefinitions = new ArrayList<EnumValueDefinition>();
+        this.directives = ( null == directives ) ? new ArrayList<>() : directives;
+        this.enumValueDefinitions = new ArrayList<>();
     }
 
     public List<EnumValueDefinition> getEnumValueDefinitions() {
@@ -34,7 +34,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(enumValueDefinitions);
         result.addAll(directives);
         return result;

File: src/main/java/graphql/language/EnumValue.java
Patch:
@@ -23,7 +23,7 @@ public void setName(String name) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/language/EnumValueDefinition.java
Patch:
@@ -14,7 +14,7 @@ public EnumValueDefinition(String name) {
 
     public EnumValueDefinition(String name, List<Directive> directives) {
         this.name = name;
-        this.directives = (null == directives) ? new ArrayList<Directive>() : directives;
+        this.directives = (null == directives) ? new ArrayList<>() : directives;
     }
 
     public String getName() {
@@ -27,7 +27,7 @@ public List<Directive> getDirectives() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         return result;
     }

File: src/main/java/graphql/language/Field.java
Patch:
@@ -9,8 +9,8 @@ public class Field extends AbstractNode implements Selection {
     private String name;
     private String alias;
 
-    private List<Argument> arguments = new ArrayList<Argument>();
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Argument> arguments = new ArrayList<>();
+    private List<Directive> directives = new ArrayList<>();
     private SelectionSet selectionSet;
 
     public Field() {
@@ -47,7 +47,7 @@ public Field(String name, List<Argument> arguments, SelectionSet selectionSet) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(arguments);
         result.addAll(directives);
         if (selectionSet != null) result.add(selectionSet);

File: src/main/java/graphql/language/FieldDefinition.java
Patch:
@@ -7,8 +7,8 @@
 public class FieldDefinition extends AbstractNode {
     private String name;
     private Type type;
-    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<InputValueDefinition>();
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
+    private List<Directive> directives = new ArrayList<>();
 
     public FieldDefinition(String name) {
         this.name = name;
@@ -41,7 +41,7 @@ public List<Directive> getDirectives() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         result.addAll(inputValueDefinitions);
         result.addAll(directives);

File: src/main/java/graphql/language/FloatValue.java
Patch:
@@ -24,7 +24,7 @@ public void setValue(BigDecimal value) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/language/FragmentDefinition.java
Patch:
@@ -8,7 +8,7 @@ public class FragmentDefinition extends AbstractNode implements Definition {
 
     private String name;
     private TypeName typeCondition;
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Directive> directives = new ArrayList<>();
     private SelectionSet selectionSet;
 
     public FragmentDefinition() {
@@ -61,7 +61,7 @@ public void setSelectionSet(SelectionSet selectionSet) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(typeCondition);
         result.addAll(directives);
         result.add(selectionSet);

File: src/main/java/graphql/language/FragmentSpread.java
Patch:
@@ -7,7 +7,7 @@
 public class FragmentSpread extends AbstractNode implements Selection {
 
     private String name;
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Directive> directives = new ArrayList<>();
 
     public FragmentSpread() {
     }
@@ -46,7 +46,7 @@ public boolean isEqualTo(Node o) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         return result;
     }

File: src/main/java/graphql/language/InlineFragment.java
Patch:
@@ -6,7 +6,7 @@
 
 public class InlineFragment extends AbstractNode implements Selection {
     private TypeName typeCondition;
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Directive> directives = new ArrayList<>();
     private SelectionSet selectionSet;
 
     public InlineFragment() {
@@ -55,7 +55,7 @@ public void setSelectionSet(SelectionSet selectionSet) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         if (typeCondition != null) {
             result.add(typeCondition);
         }

File: src/main/java/graphql/language/InputObjectTypeDefinition.java
Patch:
@@ -6,8 +6,8 @@
 
 public class InputObjectTypeDefinition extends AbstractNode implements TypeDefinition {
     private String name;
-    private List<Directive> directives = new ArrayList<Directive>();
-    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<InputValueDefinition>();
+    private List<Directive> directives = new ArrayList<>();
+    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
 
     public InputObjectTypeDefinition(String name) {
         this.name = name;
@@ -28,7 +28,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         result.addAll(inputValueDefinitions);
         return result;

File: src/main/java/graphql/language/InputValueDefinition.java
Patch:
@@ -8,7 +8,7 @@ public class InputValueDefinition extends AbstractNode {
     private String name;
     private Type type;
     private Value defaultValue;
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Directive> directives = new ArrayList<>();
 
     public InputValueDefinition(String name) {
         this(name, null);
@@ -49,7 +49,7 @@ public List<Directive> getDirectives() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         result.add(defaultValue);
         result.addAll(directives);

File: src/main/java/graphql/language/IntValue.java
Patch:
@@ -23,7 +23,7 @@ public void setValue(BigInteger value) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/language/InterfaceTypeDefinition.java
Patch:
@@ -6,8 +6,8 @@
 
 public class InterfaceTypeDefinition extends AbstractNode implements TypeDefinition {
     private String name;
-    private List<FieldDefinition> definitions = new ArrayList<FieldDefinition>();
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<FieldDefinition> definitions = new ArrayList<>();
+    private List<Directive> directives = new ArrayList<>();
 
     public InterfaceTypeDefinition(String name) {
         this.name = name;
@@ -28,7 +28,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(definitions);
         result.addAll(directives);
         return result;

File: src/main/java/graphql/language/ListType.java
Patch:
@@ -25,7 +25,7 @@ public void setType(Type type) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         return result;
     }

File: src/main/java/graphql/language/NonNullType.java
Patch:
@@ -29,7 +29,7 @@ public void setType(TypeName type) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         return result;
     }

File: src/main/java/graphql/language/ObjectField.java
Patch:
@@ -24,7 +24,7 @@ public Value getValue() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(value);
         return result;
     }

File: src/main/java/graphql/language/ObjectValue.java
Patch:
@@ -6,7 +6,7 @@
 
 public class ObjectValue extends AbstractNode implements Value {
 
-    private List<ObjectField> objectFields = new ArrayList<ObjectField>();
+    private List<ObjectField> objectFields = new ArrayList<>();
 
     public ObjectValue() {
     }
@@ -21,7 +21,7 @@ public List<ObjectField> getObjectFields() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(objectFields);
         return result;
     }

File: src/main/java/graphql/language/OperationDefinition.java
Patch:
@@ -13,8 +13,8 @@ public enum Operation {
     private String name;
 
     private Operation operation;
-    private List<VariableDefinition> variableDefinitions = new ArrayList<VariableDefinition>();
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<VariableDefinition> variableDefinitions = new ArrayList<>();
+    private List<Directive> directives = new ArrayList<>();
     private SelectionSet selectionSet;
 
     public OperationDefinition() {
@@ -44,7 +44,7 @@ public OperationDefinition(String name, Operation operation, SelectionSet select
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(variableDefinitions);
         result.addAll(directives);
         result.add(selectionSet);

File: src/main/java/graphql/language/OperationTypeDefinition.java
Patch:
@@ -35,7 +35,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         return result;
     }

File: src/main/java/graphql/language/ScalarTypeDefinition.java
Patch:
@@ -6,7 +6,7 @@
 
 public class ScalarTypeDefinition extends AbstractNode implements TypeDefinition {
     private String name;
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Directive> directives = new ArrayList<>();
 
     public ScalarTypeDefinition(String name) {
         this.name = name;
@@ -23,7 +23,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         return result;
     }

File: src/main/java/graphql/language/SchemaDefinition.java
Patch:
@@ -5,8 +5,8 @@
 import java.util.List;
 
 public class SchemaDefinition extends AbstractNode implements Definition {
-    private List<Directive> directives = new ArrayList<Directive>();
-    private List<OperationTypeDefinition> operationTypeDefinitions = new ArrayList<OperationTypeDefinition>();
+    private List<Directive> directives = new ArrayList<>();
+    private List<OperationTypeDefinition> operationTypeDefinitions = new ArrayList<>();
 
     public SchemaDefinition() {
     }
@@ -21,7 +21,7 @@ public List<OperationTypeDefinition> getOperationTypeDefinitions() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         result.addAll(operationTypeDefinitions);
         return result;

File: src/main/java/graphql/language/SelectionSet.java
Patch:
@@ -6,7 +6,7 @@
 
 public class SelectionSet extends AbstractNode {
 
-    private final List<Selection> selections = new ArrayList<Selection>();
+    private final List<Selection> selections = new ArrayList<>();
 
     public List<Selection> getSelections() {
         return selections;
@@ -21,7 +21,7 @@ public SelectionSet(List<Selection> selections) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(selections);
         return result;
     }

File: src/main/java/graphql/language/StringValue.java
Patch:
@@ -22,7 +22,7 @@ public void setValue(String value) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         return result;
     }
 

File: src/main/java/graphql/language/TypeName.java
Patch:
@@ -22,7 +22,7 @@ public void setName(String name) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/language/UnionTypeDefinition.java
Patch:
@@ -6,8 +6,8 @@
 
 public class UnionTypeDefinition extends AbstractNode implements TypeDefinition {
     private String name;
-    private List<Directive> directives = new ArrayList<Directive>();
-    private List<Type> memberTypes = new ArrayList<Type>();
+    private List<Directive> directives = new ArrayList<>();
+    private List<Type> memberTypes = new ArrayList<>();
 
     public UnionTypeDefinition(String name) {
         this.name = name;
@@ -28,7 +28,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         result.addAll(memberTypes);
         return result;

File: src/main/java/graphql/language/VariableDefinition.java
Patch:
@@ -52,7 +52,7 @@ public void setType(Type type) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         if (defaultValue != null) result.add(defaultValue);
         return result;

File: src/main/java/graphql/language/VariableReference.java
Patch:
@@ -22,7 +22,7 @@ public void setName(String name) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -53,7 +53,7 @@ public ContextEntry(ContextProperty contextProperty, Object value) {
         }
     }
 
-    private Deque<ContextEntry> contextStack = new ArrayDeque<ContextEntry>();
+    private Deque<ContextEntry> contextStack = new ArrayDeque<>();
 
 
     private void addContextProperty(ContextProperty contextProperty, Object value) {

File: src/main/java/graphql/relay/DefaultConnection.java
Patch:
@@ -5,7 +5,7 @@
 
 public class DefaultConnection implements Connection {
 
-    private List<Edge> edges = new ArrayList<Edge>();
+    private List<Edge> edges = new ArrayList<>();
 
     private PageInfo pageInfo;
 

File: src/main/java/graphql/schema/GraphQLDirective.java
Patch:
@@ -14,7 +14,7 @@ public class GraphQLDirective {
     private final String name;
     private final String description;
     private final EnumSet<DirectiveLocation> locations;
-    private final List<GraphQLArgument> arguments = new ArrayList<GraphQLArgument>();
+    private final List<GraphQLArgument> arguments = new ArrayList<>();
     private final boolean onOperation;
     private final boolean onFragment;
     private final boolean onField;
@@ -37,7 +37,7 @@ public String getName() {
     }
 
     public List<GraphQLArgument> getArguments() {
-        return new ArrayList<GraphQLArgument>(arguments);
+        return new ArrayList<>(arguments);
     }
 
     public GraphQLArgument getArgument(String name) {
@@ -90,7 +90,7 @@ public static class Builder {
 
         private String name;
         private EnumSet<DirectiveLocation> locations = EnumSet.noneOf(DirectiveLocation.class);
-        private final List<GraphQLArgument> arguments = new ArrayList<GraphQLArgument>();
+        private final List<GraphQLArgument> arguments = new ArrayList<>();
         private String description;
         private boolean onOperation;
         private boolean onFragment;

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -15,7 +15,7 @@ public class GraphQLEnumType implements GraphQLType, GraphQLInputType, GraphQLOu
 
     private final String name;
     private final String description;
-    private final Map<String, GraphQLEnumValueDefinition> valueDefinitionMap = new LinkedHashMap<String, GraphQLEnumValueDefinition>();
+    private final Map<String, GraphQLEnumValueDefinition> valueDefinitionMap = new LinkedHashMap<>();
 
     private final Coercing coercing = new Coercing() {
         @Override
@@ -58,7 +58,7 @@ private Object getNameByValue(Object value) {
     }
 
     public List<GraphQLEnumValueDefinition> getValues() {
-        return new ArrayList<GraphQLEnumValueDefinition>(valueDefinitionMap.values());
+        return new ArrayList<>(valueDefinitionMap.values());
     }
 
 
@@ -99,7 +99,7 @@ public static class Builder {
 
         private String name;
         private String description;
-        private final List<GraphQLEnumValueDefinition> values = new ArrayList<GraphQLEnumValueDefinition>();
+        private final List<GraphQLEnumValueDefinition> values = new ArrayList<>();
 
         public Builder name(String name) {
             this.name = name;

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -15,7 +15,7 @@ public class GraphQLFieldDefinition {
     private GraphQLOutputType type;
     private final DataFetcher dataFetcher;
     private final String deprecationReason;
-    private final List<GraphQLArgument> arguments = new ArrayList<GraphQLArgument>();
+    private final List<GraphQLArgument> arguments = new ArrayList<>();
 
 
     public GraphQLFieldDefinition(String name, String description, GraphQLOutputType type, DataFetcher dataFetcher, List<GraphQLArgument> arguments, String deprecationReason) {
@@ -57,7 +57,7 @@ public GraphQLArgument getArgument(String name) {
     }
 
     public List<GraphQLArgument> getArguments() {
-        return new ArrayList<GraphQLArgument>(arguments);
+        return new ArrayList<>(arguments);
     }
 
     public String getDescription() {
@@ -82,7 +82,7 @@ public static class Builder {
         private String description;
         private GraphQLOutputType type;
         private DataFetcher dataFetcher;
-        private List<GraphQLArgument> arguments = new ArrayList<GraphQLArgument>();
+        private List<GraphQLArgument> arguments = new ArrayList<>();
         private String deprecationReason;
         private boolean isField;
 

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -15,7 +15,7 @@ public class GraphQLInterfaceType implements GraphQLType, GraphQLOutputType, Gra
 
     private final String name;
     private final String description;
-    private final Map<String, GraphQLFieldDefinition> fieldDefinitionsByName = new LinkedHashMap<String, GraphQLFieldDefinition>();
+    private final Map<String, GraphQLFieldDefinition> fieldDefinitionsByName = new LinkedHashMap<>();
     private final TypeResolver typeResolver;
 
     public GraphQLInterfaceType(String name, String description, List<GraphQLFieldDefinition> fieldDefinitions, TypeResolver typeResolver) {
@@ -43,7 +43,7 @@ public GraphQLFieldDefinition getFieldDefinition(String name) {
 
 
     public List<GraphQLFieldDefinition> getFieldDefinitions() {
-        return new ArrayList<GraphQLFieldDefinition>(fieldDefinitionsByName.values());
+        return new ArrayList<>(fieldDefinitionsByName.values());
     }
 
     public String getName() {
@@ -79,7 +79,7 @@ public static Reference reference(String name) {
     public static class Builder {
         private String name;
         private String description;
-        private List<GraphQLFieldDefinition> fields = new ArrayList<GraphQLFieldDefinition>();
+        private List<GraphQLFieldDefinition> fields = new ArrayList<>();
         private TypeResolver typeResolver;
 
 

File: src/main/java/graphql/schema/GraphQLSchema.java
Patch:
@@ -46,7 +46,7 @@ public GraphQLType getType(String typeName) {
     }
 
     public List<GraphQLType> getAllTypesAsList() {
-        return new ArrayList<GraphQLType>(typeMap.values());
+        return new ArrayList<>(typeMap.values());
     }
 
     public GraphQLObjectType getQueryType() {

File: src/main/java/graphql/schema/GraphQLUnionType.java
Patch:
@@ -11,7 +11,7 @@ public class GraphQLUnionType implements GraphQLType, GraphQLOutputType, GraphQL
 
     private final String name;
     private final String description;
-    private final List<GraphQLObjectType> types = new ArrayList<GraphQLObjectType>();
+    private final List<GraphQLObjectType> types = new ArrayList<>();
     private final TypeResolver typeResolver;
 
 
@@ -36,7 +36,7 @@ void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
     }
 
     public List<GraphQLObjectType> getTypes() {
-        return new ArrayList<GraphQLObjectType>(types);
+        return new ArrayList<>(types);
     }
 
     public TypeResolver getTypeResolver() {
@@ -59,7 +59,7 @@ public static Builder newUnionType() {
     public static class Builder {
         private String name;
         private String description;
-        private List<GraphQLObjectType> types = new ArrayList<GraphQLObjectType>();
+        private List<GraphQLObjectType> types = new ArrayList<>();
         private TypeResolver typeResolver;
 
         public Builder name(String name) {

File: src/main/java/graphql/schema/PropertyDataFetcher.java
Patch:
@@ -72,9 +72,7 @@ private Object getPropertyViaGetterUsingPrefix(Object object, String prefix) thr
             Method method = findAccessibleMethod(object.getClass(), getterName);
             return method.invoke(object);
 
-        } catch (IllegalAccessException e) {
-            throw new RuntimeException(e);
-        } catch (InvocationTargetException e) {
+        } catch (IllegalAccessException | InvocationTargetException e) {
             throw new RuntimeException(e);
         }
     }

File: src/main/java/graphql/schema/SchemaUtil.java
Patch:
@@ -106,7 +106,7 @@ private void collectTypesForInputObjects(GraphQLInputObjectType objectType, Map<
 
 
     public Map<String, GraphQLType> allTypes(GraphQLSchema schema, Set<GraphQLType> dictionary) {
-        Map<String, GraphQLType> typesByName = new LinkedHashMap<String, GraphQLType>();
+        Map<String, GraphQLType> typesByName = new LinkedHashMap<>();
         collectTypes(schema.getQueryType(), typesByName);
         if (schema.isSupportingMutations()) {
             collectTypes(schema.getMutationType(), typesByName);
@@ -122,7 +122,7 @@ public Map<String, GraphQLType> allTypes(GraphQLSchema schema, Set<GraphQLType>
 
     public List<GraphQLObjectType> findImplementations(GraphQLSchema schema, GraphQLInterfaceType interfaceType) {
         Map<String, GraphQLType> allTypes = allTypes(schema, schema.getDictionary());
-        List<GraphQLObjectType> result = new ArrayList<GraphQLObjectType>();
+        List<GraphQLObjectType> result = new ArrayList<>();
         for (GraphQLType type : allTypes.values()) {
             if (!(type instanceof GraphQLObjectType)) {
                 continue;
@@ -179,7 +179,7 @@ GraphQLType resolveTypeReference(GraphQLType type, Map<String, GraphQLType> type
     }
 
     List<GraphQLType> resolveTypeReferences(List<GraphQLType> types, Map<String, GraphQLType> typeMap) {
-        List<GraphQLType> resolvedTypes = new ArrayList<GraphQLType>();
+        List<GraphQLType> resolvedTypes = new ArrayList<>();
         for (GraphQLType type : types) {
             resolvedTypes.add(resolveTypeReference(type, typeMap));
         }

File: src/main/java/graphql/schema/validation/ValidationErrorCollector.java
Patch:
@@ -5,7 +5,7 @@
 
 public class ValidationErrorCollector {
 
-    private final LinkedHashSet<ValidationError> errors = new LinkedHashSet<ValidationError>();
+    private final LinkedHashSet<ValidationError> errors = new LinkedHashSet<>();
 
     public void addError(ValidationError validationError) {
         this.errors.add(validationError);

File: src/main/java/graphql/schema/validation/Validator.java
Patch:
@@ -12,11 +12,11 @@
 
 public class Validator {
 
-    private final Set<GraphQLOutputType> processed = new HashSet<GraphQLOutputType>();
+    private final Set<GraphQLOutputType> processed = new HashSet<>();
     
     public Set<ValidationError> validateSchema(GraphQLSchema schema) {
         ValidationErrorCollector validationErrorCollector = new ValidationErrorCollector();
-        List<ValidationRule> rules = new ArrayList<ValidationRule>();
+        List<ValidationRule> rules = new ArrayList<>();
         rules.add(new NoUnbrokenInputCycles());
         
         traverse(schema.getQueryType(), rules, validationErrorCollector);

File: src/main/java/graphql/validation/ErrorFactory.java
Patch:
@@ -11,7 +11,7 @@ public class ErrorFactory {
 
 
     public ValidationError newError(ValidationErrorType validationErrorType, List<? extends Node> locations, String description) {
-        List<SourceLocation> locationList = new ArrayList<SourceLocation>();
+        List<SourceLocation> locationList = new ArrayList<>();
         for (Node node : locations) {
             locationList.add(node.getSourceLocation());
         }

File: src/main/java/graphql/validation/LanguageTraversal.java
Patch:
@@ -11,14 +11,14 @@ public class LanguageTraversal {
     private final List<Node> path;
 
     public LanguageTraversal() {
-        path = new ArrayList<Node>();
+        path = new ArrayList<>();
     }
 
     public LanguageTraversal(List<Node> basePath) {
         if (basePath != null) {
             path = basePath;
         } else {
-            path = new ArrayList<Node>();
+            path = new ArrayList<>();
         }
     }
 

File: src/main/java/graphql/validation/ValidationContext.java
Patch:
@@ -15,7 +15,7 @@ public class ValidationContext {
     private final Document document;
 
     private TraversalContext traversalContext;
-    private final Map<String, FragmentDefinition> fragmentDefinitionMap = new LinkedHashMap<String, FragmentDefinition>();
+    private final Map<String, FragmentDefinition> fragmentDefinitionMap = new LinkedHashMap<>();
 
 
     public ValidationContext(GraphQLSchema schema, Document document) {

File: src/main/java/graphql/validation/ValidationError.java
Patch:
@@ -12,7 +12,7 @@ public class ValidationError implements GraphQLError {
 
 
     private final ValidationErrorType validationErrorType;
-    private final List<SourceLocation> sourceLocations = new ArrayList<SourceLocation>();
+    private final List<SourceLocation> sourceLocations = new ArrayList<>();
     private final String description;
 
     public ValidationError(ValidationErrorType validationErrorType) {

File: src/main/java/graphql/validation/ValidationErrorCollector.java
Patch:
@@ -6,7 +6,7 @@
 
 public class ValidationErrorCollector {
 
-    private final List<ValidationError> errors = new ArrayList<ValidationError>();
+    private final List<ValidationError> errors = new ArrayList<>();
 
     public void addError(ValidationError validationError) {
         this.errors.add(validationError);

File: src/main/java/graphql/validation/ValidationUtil.java
Patch:
@@ -74,7 +74,7 @@ private boolean isFieldMissing(GraphQLInputObjectType type, Map<String, ObjectFi
     }
 
     private Map<String, ObjectField> fieldMap(ObjectValue objectValue) {
-        Map<String, ObjectField> result = new LinkedHashMap<String, ObjectField>();
+        Map<String, ObjectField> result = new LinkedHashMap<>();
         for (ObjectField objectField : objectValue.getObjectFields()) {
             result.put(objectField.getName(), objectField);
         }

File: src/main/java/graphql/validation/Validator.java
Patch:
@@ -23,7 +23,7 @@ public List<ValidationError> validateDocument(GraphQLSchema schema, Document doc
     }
 
     private List<AbstractRule> createRules(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
-        List<AbstractRule> rules = new ArrayList<AbstractRule>();
+        List<AbstractRule> rules = new ArrayList<>();
         
         ArgumentsOfCorrectType argumentsOfCorrectType = new ArgumentsOfCorrectType(validationContext, validationErrorCollector);
         rules.add(argumentsOfCorrectType);

File: src/main/java/graphql/validation/rules/NoFragmentCycles.java
Patch:
@@ -14,7 +14,7 @@
 
 public class NoFragmentCycles extends AbstractRule {
 
-    private Map<String, List<FragmentSpread>> fragmentSpreads = new LinkedHashMap<String, List<FragmentSpread>>();
+    private Map<String, List<FragmentSpread>> fragmentSpreads = new LinkedHashMap<>();
 
 
     public NoFragmentCycles(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
@@ -34,7 +34,7 @@ private void prepareFragmentMap() {
 
 
     private List<FragmentSpread> gatherSpreads(FragmentDefinition fragmentDefinition) {
-        final List<FragmentSpread> fragmentSpreads = new ArrayList<FragmentSpread>();
+        final List<FragmentSpread> fragmentSpreads = new ArrayList<>();
         QueryLanguageVisitor visitor = new QueryLanguageVisitor() {
             @Override
             public void enter(Node node, List<Node> path) {
@@ -56,7 +56,7 @@ public void leave(Node node, List<Node> path) {
 
     @Override
     public void checkFragmentDefinition(FragmentDefinition fragmentDefinition) {
-        List<FragmentSpread> spreadPath = new ArrayList<FragmentSpread>();
+        List<FragmentSpread> spreadPath = new ArrayList<>();
         detectCycleRecursive(fragmentDefinition.getName(), fragmentDefinition.getName(), spreadPath);
     }
 

File: src/main/java/graphql/validation/rules/NoUndefinedVariables.java
Patch:
@@ -12,7 +12,7 @@
 
 public class NoUndefinedVariables extends AbstractRule {
 
-    private Set<String> variableNames = new LinkedHashSet<String>();
+    private Set<String> variableNames = new LinkedHashSet<>();
 
     public NoUndefinedVariables(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
         super(validationContext, validationErrorCollector);

File: src/main/java/graphql/validation/rules/NoUnusedVariables.java
Patch:
@@ -13,8 +13,8 @@
 
 public class NoUnusedVariables extends AbstractRule {
 
-    private List<VariableDefinition> variableDefinitions = new ArrayList<VariableDefinition>();
-    private Set<String> usedVariables = new LinkedHashSet<String>();
+    private List<VariableDefinition> variableDefinitions = new ArrayList<>();
+    private Set<String> usedVariables = new LinkedHashSet<>();
 
     public NoUnusedVariables(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
         super(validationContext, validationErrorCollector);

File: src/main/java/graphql/validation/rules/ProvidedNonNullArguments.java
Patch:
@@ -38,7 +38,7 @@ public void checkField(Field field) {
     }
 
     private Map<String, Argument> argumentMap(List<Argument> arguments) {
-        Map<String, Argument> result = new LinkedHashMap<String, Argument>();
+        Map<String, Argument> result = new LinkedHashMap<>();
         for (Argument argument : arguments) {
             result.put(argument.getName(), argument);
         }

File: src/main/java/graphql/validation/rules/VariableTypesMatchRule.java
Patch:
@@ -16,16 +16,16 @@ public class VariableTypesMatchRule extends AbstractRule {
 
     VariablesTypesMatcher variablesTypesMatcher = new VariablesTypesMatcher();
 
+    private Map<String, VariableDefinition> variableDefinitionMap;
+
     public VariableTypesMatchRule(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
         super(validationContext, validationErrorCollector);
         setVisitFragmentSpreads(true);
     }
 
-    private Map<String, VariableDefinition> variableDefinitionMap;
-
     @Override
     public void checkOperationDefinition(OperationDefinition operationDefinition) {
-        variableDefinitionMap = new LinkedHashMap<String, VariableDefinition>();
+        variableDefinitionMap = new LinkedHashMap<>();
     }
 
     @Override

File: src/main/java/graphql/schema/TypeResolver.java
Patch:
@@ -1,9 +1,10 @@
 package graphql.schema;
 
 
-public interface TypeResolver {
+import graphql.TypeResolutionEnvironment;
 
+public interface TypeResolver {
 
-    GraphQLObjectType getType(Object object);
+    GraphQLObjectType getType(TypeResolutionEnvironment env);
 
 }

File: src/test/groovy/graphql/validation/rules/Harness.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.validation.rules;
 
+import graphql.TypeResolutionEnvironment;
 import graphql.schema.*;
 
 import static graphql.Scalars.*;
@@ -16,7 +17,7 @@ public class Harness {
 
     private static TypeResolver dummyTypeResolve = new TypeResolver() {
         @Override
-        public GraphQLObjectType getType(Object object) {
+        public GraphQLObjectType getType(TypeResolutionEnvironment env) {
             return null;
         }
     };
@@ -119,7 +120,7 @@ public GraphQLObjectType getType(Object object) {
             .possibleTypes(Dog, Cat)
             .typeResolver(new TypeResolver() {
                 @Override
-                public GraphQLObjectType getType(Object object) {
+                public GraphQLObjectType getType(TypeResolutionEnvironment env) {
                     return null;
                 }
             })

File: src/main/java/graphql/schema/PropertyDataFetcher.java
Patch:
@@ -72,9 +72,7 @@ private Object getPropertyViaGetterUsingPrefix(Object object, String prefix) thr
             Method method = findAccessibleMethod(object.getClass(), getterName);
             return method.invoke(object);
 
-        } catch (IllegalAccessException e) {
-            throw new RuntimeException(e);
-        } catch (InvocationTargetException e) {
+        } catch (IllegalAccessException | InvocationTargetException e) {
             throw new RuntimeException(e);
         }
     }

File: src/main/java/graphql/InvalidSyntaxError.java
Patch:
@@ -8,7 +8,7 @@
 
 public class InvalidSyntaxError implements GraphQLError {
 
-    private final List<SourceLocation> sourceLocations = new ArrayList<SourceLocation>();
+    private final List<SourceLocation> sourceLocations = new ArrayList<>();
 
     public InvalidSyntaxError(SourceLocation sourceLocation) {
         if (sourceLocation != null)

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -75,8 +75,8 @@ private ExecutionResult executeOperation(
             return new ExecutionResultImpl(Collections.singletonList(new MutationNotSupportedError()));
         }
 
-        Map<String, List<Field>> fields = new LinkedHashMap<String, List<Field>>();
-        fieldCollector.collectFields(executionContext, operationRootType, operationDefinition.getSelectionSet(), new ArrayList<String>(), fields);
+        Map<String, List<Field>> fields = new LinkedHashMap<>();
+        fieldCollector.collectFields(executionContext, operationRootType, operationDefinition.getSelectionSet(), new ArrayList<>(), fields);
 
         ExecutionResult result;
         if (operation == MUTATION) {

File: src/main/java/graphql/execution/ExecutionContext.java
Patch:
@@ -22,7 +22,7 @@ public class ExecutionContext {
     private final OperationDefinition operationDefinition;
     private final Map<String, Object> variables;
     private final Object root;
-    private final List<GraphQLError> errors = new CopyOnWriteArrayList<GraphQLError>();
+    private final List<GraphQLError> errors = new CopyOnWriteArrayList<>();
     private final Instrumentation instrumentation;
 
     public ExecutionContext(Instrumentation instrumentation, ExecutionId executionId, GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy, Map<String, FragmentDefinition> fragmentsByName, OperationDefinition operationDefinition, Map<String, Object> variables, Object root) {

File: src/main/java/graphql/execution/ExecutionContextBuilder.java
Patch:
@@ -34,8 +34,8 @@ public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy que
         // preconditions
         assertNotNull(executionId, "You must provide a query identifier");
 
-        Map<String, FragmentDefinition> fragmentsByName = new LinkedHashMap<String, FragmentDefinition>();
-        Map<String, OperationDefinition> operationsByName = new LinkedHashMap<String, OperationDefinition>();
+        Map<String, FragmentDefinition> fragmentsByName = new LinkedHashMap<>();
+        Map<String, OperationDefinition> operationsByName = new LinkedHashMap<>();
 
         for (Definition definition : document.getDefinitions()) {
             if (definition instanceof OperationDefinition) {

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -108,8 +108,8 @@ protected ExecutionResult completeValue(ExecutionContext executionContext, Graph
             resolvedType = (GraphQLObjectType) fieldType;
         }
 
-        Map<String, List<Field>> subFields = new LinkedHashMap<String, List<Field>>();
-        List<String> visitedFragments = new ArrayList<String>();
+        Map<String, List<Field>> subFields = new LinkedHashMap<>();
+        List<String> visitedFragments = new ArrayList<>();
         for (Field field : fields) {
             if (field.getSelectionSet() == null) continue;
             fieldCollector.collectFields(executionContext, resolvedType, field.getSelectionSet(), visitedFragments, subFields);
@@ -160,7 +160,7 @@ protected ExecutionResult completeValueForScalar(GraphQLScalarType scalarType, O
     }
 
     protected ExecutionResult completeValueForList(ExecutionContext executionContext, GraphQLList fieldType, List<Field> fields, Iterable<Object> result) {
-        List<Object> completedResults = new ArrayList<Object>();
+        List<Object> completedResults = new ArrayList<>();
         for (Object item : result) {
             ExecutionResult completedValue = completeValue(executionContext, fieldType.getWrappedType(), fields, item);
             completedResults.add(completedValue != null ? completedValue.getData() : null);

File: src/main/java/graphql/execution/ExecutorServiceExecutionStrategy.java
Patch:
@@ -41,7 +41,7 @@ public ExecutionResult execute(final ExecutionContext executionContext, final Gr
         if (executorService == null)
             return new SimpleExecutionStrategy().execute(executionContext, parentType, source, fields);
 
-        Map<String, Future<ExecutionResult>> futures = new LinkedHashMap<String, Future<ExecutionResult>>();
+        Map<String, Future<ExecutionResult>> futures = new LinkedHashMap<>();
         for (String fieldName : fields.keySet()) {
             final List<Field> fieldList = fields.get(fieldName);
             Callable<ExecutionResult> resolveField = new Callable<ExecutionResult>() {
@@ -54,7 +54,7 @@ public ExecutionResult call() throws Exception {
             futures.put(fieldName, executorService.submit(resolveField));
         }
         try {
-            Map<String, Object> results = new LinkedHashMap<String, Object>();
+            Map<String, Object> results = new LinkedHashMap<>();
             for (String fieldName : futures.keySet()) {
                 ExecutionResult executionResult = futures.get(fieldName).get();
 

File: src/main/java/graphql/execution/FieldCollector.java
Patch:
@@ -67,7 +67,7 @@ private void collectField(ExecutionContext executionContext, Map<String, List<Fi
         }
         String name = getFieldEntryKey(field);
         if (!fields.containsKey(name)) {
-            fields.put(name, new ArrayList<Field>());
+            fields.put(name, new ArrayList<>());
         }
         fields.get(name).add(field);
     }

File: src/main/java/graphql/execution/SimpleExecutionStrategy.java
Patch:
@@ -12,7 +12,7 @@
 public class SimpleExecutionStrategy extends ExecutionStrategy {
     @Override
     public ExecutionResult execute(ExecutionContext executionContext, GraphQLObjectType parentType, Object source, Map<String, List<Field>> fields) {
-        Map<String, Object> results = new LinkedHashMap<String, Object>();
+        Map<String, Object> results = new LinkedHashMap<>();
         for (String fieldName : fields.keySet()) {
             List<Field> fieldList = fields.get(fieldName);
             ExecutionResult resolvedResult = resolveField(executionContext, parentType, source, fieldList);

File: src/main/java/graphql/execution/batched/GraphQLExecutionResultContainer.java
Patch:
@@ -14,13 +14,13 @@ public abstract class GraphQLExecutionResultContainer {
      * @return datum
      */
     public GraphQLExecutionNodeDatum createAndPutChildDatum(String fieldName, Object value) {
-        Map<String, Object> map = new LinkedHashMap<String, Object>();
+        Map<String, Object> map = new LinkedHashMap<>();
         putResult(fieldName, map);
         return new GraphQLExecutionNodeDatum(map, value);
     }
 
     public GraphQLExecutionResultList createAndPutEmptyChildList(String fieldName) {
-        List<Object> resultList = new ArrayList<Object>();
+        List<Object> resultList = new ArrayList<>();
         putResult(fieldName, resultList);
         return new GraphQLExecutionResultList(resultList);
     }

File: src/main/java/graphql/execution/batched/UnbatchedDataFetcher.java
Patch:
@@ -26,7 +26,7 @@ public UnbatchedDataFetcher(DataFetcher delegate) {
     @Override
     public Object get(DataFetchingEnvironment environment) {
         List<Object> sources = environment.getSource();
-        List<Object> results = new ArrayList<Object>();
+        List<Object> results = new ArrayList<>();
         for (Object source : sources) {
             DataFetchingEnvironment singleEnv = new DataFetchingEnvironmentImpl(
                     source,

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -183,7 +183,7 @@ public Object get(DataFetchingEnvironment environment) {
                 GraphQLFieldsContainer fieldsContainer = (GraphQLFieldsContainer) type;
                 List<GraphQLFieldDefinition> fieldDefinitions = fieldsContainer.getFieldDefinitions();
                 if (includeDeprecated) return fieldDefinitions;
-                List<GraphQLFieldDefinition> filtered = new ArrayList<GraphQLFieldDefinition>(fieldDefinitions);
+                List<GraphQLFieldDefinition> filtered = new ArrayList<>(fieldDefinitions);
                 for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {
                     if (fieldDefinition.isDeprecated()) filtered.remove(fieldDefinition);
                 }
@@ -226,7 +226,7 @@ public Object get(DataFetchingEnvironment environment) {
             if (type instanceof GraphQLEnumType) {
                 List<GraphQLEnumValueDefinition> values = ((GraphQLEnumType) type).getValues();
                 if (includeDeprecated) return values;
-                List<GraphQLEnumValueDefinition> filtered = new ArrayList<GraphQLEnumValueDefinition>(values);
+                List<GraphQLEnumValueDefinition> filtered = new ArrayList<>(values);
                 for (GraphQLEnumValueDefinition valueDefinition : values) {
                     if (valueDefinition.isDeprecated()) filtered.remove(valueDefinition);
                 }
@@ -343,7 +343,7 @@ public enum DirectiveLocation {
                         @Override
                         public Object get(DataFetchingEnvironment environment) {
                             GraphQLDirective directive = environment.getSource();
-                            return new ArrayList<DirectiveLocation>(directive.validLocations());
+                            return new ArrayList<>(directive.validLocations());
                         }
                     }))
             .field(newFieldDefinition()

File: src/main/java/graphql/language/Argument.java
Patch:
@@ -33,7 +33,7 @@ public void setValue(Value value) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(value);
         return result;
     }

File: src/main/java/graphql/language/ArrayValue.java
Patch:
@@ -6,7 +6,7 @@
 
 public class ArrayValue extends AbstractNode implements Value {
 
-    private List<Value> values = new ArrayList<Value>();
+    private List<Value> values = new ArrayList<>();
 
     public ArrayValue() {
     }
@@ -26,7 +26,7 @@ public void setValues(List<Value> values) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>(values);
+        return new ArrayList<>(values);
     }
 
     @Override

File: src/main/java/graphql/language/BooleanValue.java
Patch:
@@ -23,7 +23,7 @@ public void setValue(boolean value) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/language/Directive.java
Patch:
@@ -6,7 +6,7 @@
 
 public class Directive extends AbstractNode {
     private String name;
-    private final List<Argument> arguments = new ArrayList<Argument>();
+    private final List<Argument> arguments = new ArrayList<>();
 
     public Directive() {
 
@@ -36,7 +36,7 @@ public void setName(String name) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>(arguments);
+        return new ArrayList<>(arguments);
     }
 
     @Override

File: src/main/java/graphql/language/DirectiveDefinition.java
Patch:
@@ -6,8 +6,8 @@
 
 public class DirectiveDefinition extends AbstractNode implements Definition {
     private String name;
-    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<InputValueDefinition>();
-    private List<DirectiveLocation> directiveLocations = new ArrayList<DirectiveLocation>();
+    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
+    private List<DirectiveLocation> directiveLocations = new ArrayList<>();
 
     public DirectiveDefinition(String name) {
         this.name = name;
@@ -23,7 +23,7 @@ public List<DirectiveLocation> getDirectiveLocations() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(inputValueDefinitions);
         result.addAll(directiveLocations);
         return result;

File: src/main/java/graphql/language/DirectiveLocation.java
Patch:
@@ -21,7 +21,7 @@ public DirectiveLocation(String name) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         return result;
     }
 

File: src/main/java/graphql/language/Document.java
Patch:
@@ -6,7 +6,7 @@
 
 public class Document extends AbstractNode {
 
-    private List<Definition> definitions = new ArrayList<Definition>();
+    private List<Definition> definitions = new ArrayList<>();
 
     public Document() {
 
@@ -27,7 +27,7 @@ public void setDefinitions(List<Definition> definitions) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>(definitions);
+        return new ArrayList<>(definitions);
     }
 
 

File: src/main/java/graphql/language/EnumTypeDefinition.java
Patch:
@@ -15,8 +15,8 @@ public EnumTypeDefinition(String name) {
 
     public EnumTypeDefinition(String name, List<Directive> directives) {
         this.name = name;
-        this.directives = ( null == directives ) ? new ArrayList<Directive>() : directives;
-        this.enumValueDefinitions = new ArrayList<EnumValueDefinition>();
+        this.directives = ( null == directives ) ? new ArrayList<>() : directives;
+        this.enumValueDefinitions = new ArrayList<>();
     }
 
     public List<EnumValueDefinition> getEnumValueDefinitions() {
@@ -34,7 +34,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(enumValueDefinitions);
         result.addAll(directives);
         return result;

File: src/main/java/graphql/language/EnumValue.java
Patch:
@@ -23,7 +23,7 @@ public void setName(String name) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/language/EnumValueDefinition.java
Patch:
@@ -14,7 +14,7 @@ public EnumValueDefinition(String name) {
 
     public EnumValueDefinition(String name, List<Directive> directives) {
         this.name = name;
-        this.directives = (null == directives) ? new ArrayList<Directive>() : directives;
+        this.directives = (null == directives) ? new ArrayList<>() : directives;
     }
 
     public String getName() {
@@ -27,7 +27,7 @@ public List<Directive> getDirectives() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         return result;
     }

File: src/main/java/graphql/language/Field.java
Patch:
@@ -9,8 +9,8 @@ public class Field extends AbstractNode implements Selection {
     private String name;
     private String alias;
 
-    private List<Argument> arguments = new ArrayList<Argument>();
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Argument> arguments = new ArrayList<>();
+    private List<Directive> directives = new ArrayList<>();
     private SelectionSet selectionSet;
 
     public Field() {
@@ -47,7 +47,7 @@ public Field(String name, List<Argument> arguments, SelectionSet selectionSet) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(arguments);
         result.addAll(directives);
         if (selectionSet != null) result.add(selectionSet);

File: src/main/java/graphql/language/FieldDefinition.java
Patch:
@@ -7,8 +7,8 @@
 public class FieldDefinition extends AbstractNode {
     private String name;
     private Type type;
-    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<InputValueDefinition>();
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
+    private List<Directive> directives = new ArrayList<>();
 
     public FieldDefinition(String name) {
         this.name = name;
@@ -41,7 +41,7 @@ public List<Directive> getDirectives() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         result.addAll(inputValueDefinitions);
         result.addAll(directives);

File: src/main/java/graphql/language/FloatValue.java
Patch:
@@ -24,7 +24,7 @@ public void setValue(BigDecimal value) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/language/FragmentDefinition.java
Patch:
@@ -8,7 +8,7 @@ public class FragmentDefinition extends AbstractNode implements Definition {
 
     private String name;
     private TypeName typeCondition;
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Directive> directives = new ArrayList<>();
     private SelectionSet selectionSet;
 
     public FragmentDefinition() {
@@ -61,7 +61,7 @@ public void setSelectionSet(SelectionSet selectionSet) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(typeCondition);
         result.addAll(directives);
         result.add(selectionSet);

File: src/main/java/graphql/language/FragmentSpread.java
Patch:
@@ -7,7 +7,7 @@
 public class FragmentSpread extends AbstractNode implements Selection {
 
     private String name;
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Directive> directives = new ArrayList<>();
 
     public FragmentSpread() {
     }
@@ -46,7 +46,7 @@ public boolean isEqualTo(Node o) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         return result;
     }

File: src/main/java/graphql/language/InlineFragment.java
Patch:
@@ -6,7 +6,7 @@
 
 public class InlineFragment extends AbstractNode implements Selection {
     private TypeName typeCondition;
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Directive> directives = new ArrayList<>();
     private SelectionSet selectionSet;
 
     public InlineFragment() {
@@ -55,7 +55,7 @@ public void setSelectionSet(SelectionSet selectionSet) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         if (typeCondition != null) {
             result.add(typeCondition);
         }

File: src/main/java/graphql/language/InputObjectTypeDefinition.java
Patch:
@@ -6,8 +6,8 @@
 
 public class InputObjectTypeDefinition extends AbstractNode implements TypeDefinition {
     private String name;
-    private List<Directive> directives = new ArrayList<Directive>();
-    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<InputValueDefinition>();
+    private List<Directive> directives = new ArrayList<>();
+    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
 
     public InputObjectTypeDefinition(String name) {
         this.name = name;
@@ -28,7 +28,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         result.addAll(inputValueDefinitions);
         return result;

File: src/main/java/graphql/language/InputValueDefinition.java
Patch:
@@ -8,7 +8,7 @@ public class InputValueDefinition extends AbstractNode {
     private String name;
     private Type type;
     private Value defaultValue;
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Directive> directives = new ArrayList<>();
 
     public InputValueDefinition(String name) {
         this(name, null);
@@ -49,7 +49,7 @@ public List<Directive> getDirectives() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         result.add(defaultValue);
         result.addAll(directives);

File: src/main/java/graphql/language/IntValue.java
Patch:
@@ -23,7 +23,7 @@ public void setValue(BigInteger value) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/language/InterfaceTypeDefinition.java
Patch:
@@ -6,8 +6,8 @@
 
 public class InterfaceTypeDefinition extends AbstractNode implements TypeDefinition {
     private String name;
-    private List<FieldDefinition> definitions = new ArrayList<FieldDefinition>();
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<FieldDefinition> definitions = new ArrayList<>();
+    private List<Directive> directives = new ArrayList<>();
 
     public InterfaceTypeDefinition(String name) {
         this.name = name;
@@ -28,7 +28,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(definitions);
         result.addAll(directives);
         return result;

File: src/main/java/graphql/language/ListType.java
Patch:
@@ -25,7 +25,7 @@ public void setType(Type type) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         return result;
     }

File: src/main/java/graphql/language/NonNullType.java
Patch:
@@ -29,7 +29,7 @@ public void setType(TypeName type) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         return result;
     }

File: src/main/java/graphql/language/ObjectField.java
Patch:
@@ -24,7 +24,7 @@ public Value getValue() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(value);
         return result;
     }

File: src/main/java/graphql/language/ObjectValue.java
Patch:
@@ -6,7 +6,7 @@
 
 public class ObjectValue extends AbstractNode implements Value {
 
-    private List<ObjectField> objectFields = new ArrayList<ObjectField>();
+    private List<ObjectField> objectFields = new ArrayList<>();
 
     public ObjectValue() {
     }
@@ -21,7 +21,7 @@ public List<ObjectField> getObjectFields() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(objectFields);
         return result;
     }

File: src/main/java/graphql/language/OperationDefinition.java
Patch:
@@ -13,8 +13,8 @@ public enum Operation {
     private String name;
 
     private Operation operation;
-    private List<VariableDefinition> variableDefinitions = new ArrayList<VariableDefinition>();
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<VariableDefinition> variableDefinitions = new ArrayList<>();
+    private List<Directive> directives = new ArrayList<>();
     private SelectionSet selectionSet;
 
     public OperationDefinition() {
@@ -44,7 +44,7 @@ public OperationDefinition(String name, Operation operation, SelectionSet select
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(variableDefinitions);
         result.addAll(directives);
         result.add(selectionSet);

File: src/main/java/graphql/language/OperationTypeDefinition.java
Patch:
@@ -35,7 +35,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         return result;
     }

File: src/main/java/graphql/language/ScalarTypeDefinition.java
Patch:
@@ -6,7 +6,7 @@
 
 public class ScalarTypeDefinition extends AbstractNode implements TypeDefinition {
     private String name;
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Directive> directives = new ArrayList<>();
 
     public ScalarTypeDefinition(String name) {
         this.name = name;
@@ -23,7 +23,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         return result;
     }

File: src/main/java/graphql/language/SchemaDefinition.java
Patch:
@@ -5,8 +5,8 @@
 import java.util.List;
 
 public class SchemaDefinition extends AbstractNode implements Definition {
-    private List<Directive> directives = new ArrayList<Directive>();
-    private List<OperationTypeDefinition> operationTypeDefinitions = new ArrayList<OperationTypeDefinition>();
+    private List<Directive> directives = new ArrayList<>();
+    private List<OperationTypeDefinition> operationTypeDefinitions = new ArrayList<>();
 
     public SchemaDefinition() {
     }
@@ -21,7 +21,7 @@ public List<OperationTypeDefinition> getOperationTypeDefinitions() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         result.addAll(operationTypeDefinitions);
         return result;

File: src/main/java/graphql/language/SelectionSet.java
Patch:
@@ -6,7 +6,7 @@
 
 public class SelectionSet extends AbstractNode {
 
-    private final List<Selection> selections = new ArrayList<Selection>();
+    private final List<Selection> selections = new ArrayList<>();
 
     public List<Selection> getSelections() {
         return selections;
@@ -21,7 +21,7 @@ public SelectionSet(List<Selection> selections) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(selections);
         return result;
     }

File: src/main/java/graphql/language/StringValue.java
Patch:
@@ -22,7 +22,7 @@ public void setValue(String value) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         return result;
     }
 

File: src/main/java/graphql/language/TypeName.java
Patch:
@@ -22,7 +22,7 @@ public void setName(String name) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/language/UnionTypeDefinition.java
Patch:
@@ -6,8 +6,8 @@
 
 public class UnionTypeDefinition extends AbstractNode implements TypeDefinition {
     private String name;
-    private List<Directive> directives = new ArrayList<Directive>();
-    private List<Type> memberTypes = new ArrayList<Type>();
+    private List<Directive> directives = new ArrayList<>();
+    private List<Type> memberTypes = new ArrayList<>();
 
     public UnionTypeDefinition(String name) {
         this.name = name;
@@ -28,7 +28,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         result.addAll(memberTypes);
         return result;

File: src/main/java/graphql/language/VariableDefinition.java
Patch:
@@ -52,7 +52,7 @@ public void setType(Type type) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         if (defaultValue != null) result.add(defaultValue);
         return result;

File: src/main/java/graphql/language/VariableReference.java
Patch:
@@ -22,7 +22,7 @@ public void setName(String name) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -53,7 +53,7 @@ public ContextEntry(ContextProperty contextProperty, Object value) {
         }
     }
 
-    private Deque<ContextEntry> contextStack = new ArrayDeque<ContextEntry>();
+    private Deque<ContextEntry> contextStack = new ArrayDeque<>();
 
 
     private void addContextProperty(ContextProperty contextProperty, Object value) {

File: src/main/java/graphql/relay/DefaultConnection.java
Patch:
@@ -5,7 +5,7 @@
 
 public class DefaultConnection implements Connection {
 
-    private List<Edge> edges = new ArrayList<Edge>();
+    private List<Edge> edges = new ArrayList<>();
 
     private PageInfo pageInfo;
 

File: src/main/java/graphql/relay/Relay.java
Patch:
@@ -66,7 +66,7 @@ public GraphQLFieldDefinition nodeField(GraphQLInterfaceType nodeInterface, Data
     }
 
     public List<GraphQLArgument> getConnectionFieldArguments() {
-        List<GraphQLArgument> args = new ArrayList<GraphQLArgument>();
+        List<GraphQLArgument> args = new ArrayList<>();
 
         args.add(newArgument()
                 .name("before")
@@ -88,7 +88,7 @@ public List<GraphQLArgument> getConnectionFieldArguments() {
     }
 
     public List<GraphQLArgument> getBackwardPaginationConnectionFieldArguments() {
-        List<GraphQLArgument> args = new ArrayList<GraphQLArgument>();
+        List<GraphQLArgument> args = new ArrayList<>();
 
         args.add(newArgument()
                 .name("before")
@@ -102,7 +102,7 @@ public List<GraphQLArgument> getBackwardPaginationConnectionFieldArguments() {
     }
 
     public List<GraphQLArgument> getForwardPaginationConnectionFieldArguments() {
-        List<GraphQLArgument> args = new ArrayList<GraphQLArgument>();
+        List<GraphQLArgument> args = new ArrayList<>();
 
         args.add(newArgument()
                 .name("after")

File: src/main/java/graphql/relay/SimpleListConnection.java
Patch:
@@ -25,7 +25,7 @@ public SimpleListConnection(List<?> data) {
     }
 
     private List<Edge> buildEdges() {
-        List<Edge> edges = new ArrayList<Edge>();
+        List<Edge> edges = new ArrayList<>();
         int ix = 0;
         for (Object object : data) {
             edges.add(new DefaultEdge(object, new DefaultConnectionCursor(createCursor(ix++))));

File: src/main/java/graphql/schema/GraphQLDirective.java
Patch:
@@ -14,7 +14,7 @@ public class GraphQLDirective {
     private final String name;
     private final String description;
     private final EnumSet<DirectiveLocation> locations;
-    private final List<GraphQLArgument> arguments = new ArrayList<GraphQLArgument>();
+    private final List<GraphQLArgument> arguments = new ArrayList<>();
     private final boolean onOperation;
     private final boolean onFragment;
     private final boolean onField;
@@ -37,7 +37,7 @@ public String getName() {
     }
 
     public List<GraphQLArgument> getArguments() {
-        return new ArrayList<GraphQLArgument>(arguments);
+        return new ArrayList<>(arguments);
     }
 
     public GraphQLArgument getArgument(String name) {
@@ -90,7 +90,7 @@ public static class Builder {
 
         private String name;
         private EnumSet<DirectiveLocation> locations = EnumSet.noneOf(DirectiveLocation.class);
-        private final List<GraphQLArgument> arguments = new ArrayList<GraphQLArgument>();
+        private final List<GraphQLArgument> arguments = new ArrayList<>();
         private String description;
         private boolean onOperation;
         private boolean onFragment;

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -15,7 +15,7 @@ public class GraphQLEnumType implements GraphQLType, GraphQLInputType, GraphQLOu
 
     private final String name;
     private final String description;
-    private final Map<String, GraphQLEnumValueDefinition> valueDefinitionMap = new LinkedHashMap<String, GraphQLEnumValueDefinition>();
+    private final Map<String, GraphQLEnumValueDefinition> valueDefinitionMap = new LinkedHashMap<>();
 
     private final Coercing coercing = new Coercing() {
         @Override
@@ -58,7 +58,7 @@ private Object getNameByValue(Object value) {
     }
 
     public List<GraphQLEnumValueDefinition> getValues() {
-        return new ArrayList<GraphQLEnumValueDefinition>(valueDefinitionMap.values());
+        return new ArrayList<>(valueDefinitionMap.values());
     }
 
 
@@ -99,7 +99,7 @@ public static class Builder {
 
         private String name;
         private String description;
-        private final List<GraphQLEnumValueDefinition> values = new ArrayList<GraphQLEnumValueDefinition>();
+        private final List<GraphQLEnumValueDefinition> values = new ArrayList<>();
 
         public Builder name(String name) {
             this.name = name;

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -15,7 +15,7 @@ public class GraphQLFieldDefinition {
     private GraphQLOutputType type;
     private final DataFetcher dataFetcher;
     private final String deprecationReason;
-    private final List<GraphQLArgument> arguments = new ArrayList<GraphQLArgument>();
+    private final List<GraphQLArgument> arguments = new ArrayList<>();
 
 
     public GraphQLFieldDefinition(String name, String description, GraphQLOutputType type, DataFetcher dataFetcher, List<GraphQLArgument> arguments, String deprecationReason) {
@@ -57,7 +57,7 @@ public GraphQLArgument getArgument(String name) {
     }
 
     public List<GraphQLArgument> getArguments() {
-        return new ArrayList<GraphQLArgument>(arguments);
+        return new ArrayList<>(arguments);
     }
 
     public String getDescription() {
@@ -82,7 +82,7 @@ public static class Builder {
         private String description;
         private GraphQLOutputType type;
         private DataFetcher dataFetcher;
-        private List<GraphQLArgument> arguments = new ArrayList<GraphQLArgument>();
+        private List<GraphQLArgument> arguments = new ArrayList<>();
         private String deprecationReason;
         private boolean isField;
 

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -15,7 +15,7 @@ public class GraphQLInterfaceType implements GraphQLType, GraphQLOutputType, Gra
 
     private final String name;
     private final String description;
-    private final Map<String, GraphQLFieldDefinition> fieldDefinitionsByName = new LinkedHashMap<String, GraphQLFieldDefinition>();
+    private final Map<String, GraphQLFieldDefinition> fieldDefinitionsByName = new LinkedHashMap<>();
     private final TypeResolver typeResolver;
 
     public GraphQLInterfaceType(String name, String description, List<GraphQLFieldDefinition> fieldDefinitions, TypeResolver typeResolver) {
@@ -43,7 +43,7 @@ public GraphQLFieldDefinition getFieldDefinition(String name) {
 
 
     public List<GraphQLFieldDefinition> getFieldDefinitions() {
-        return new ArrayList<GraphQLFieldDefinition>(fieldDefinitionsByName.values());
+        return new ArrayList<>(fieldDefinitionsByName.values());
     }
 
     public String getName() {
@@ -79,7 +79,7 @@ public static Reference reference(String name) {
     public static class Builder {
         private String name;
         private String description;
-        private List<GraphQLFieldDefinition> fields = new ArrayList<GraphQLFieldDefinition>();
+        private List<GraphQLFieldDefinition> fields = new ArrayList<>();
         private TypeResolver typeResolver;
 
 

File: src/main/java/graphql/schema/GraphQLSchema.java
Patch:
@@ -46,7 +46,7 @@ public GraphQLType getType(String typeName) {
     }
 
     public List<GraphQLType> getAllTypesAsList() {
-        return new ArrayList<GraphQLType>(typeMap.values());
+        return new ArrayList<>(typeMap.values());
     }
 
     public GraphQLObjectType getQueryType() {

File: src/main/java/graphql/schema/GraphQLUnionType.java
Patch:
@@ -11,7 +11,7 @@ public class GraphQLUnionType implements GraphQLType, GraphQLOutputType, GraphQL
 
     private final String name;
     private final String description;
-    private final List<GraphQLObjectType> types = new ArrayList<GraphQLObjectType>();
+    private final List<GraphQLObjectType> types = new ArrayList<>();
     private final TypeResolver typeResolver;
 
 
@@ -36,7 +36,7 @@ void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
     }
 
     public List<GraphQLObjectType> getTypes() {
-        return new ArrayList<GraphQLObjectType>(types);
+        return new ArrayList<>(types);
     }
 
     public TypeResolver getTypeResolver() {
@@ -59,7 +59,7 @@ public static Builder newUnionType() {
     public static class Builder {
         private String name;
         private String description;
-        private List<GraphQLObjectType> types = new ArrayList<GraphQLObjectType>();
+        private List<GraphQLObjectType> types = new ArrayList<>();
         private TypeResolver typeResolver;
 
         public Builder name(String name) {

File: src/main/java/graphql/schema/SchemaUtil.java
Patch:
@@ -106,7 +106,7 @@ private void collectTypesForInputObjects(GraphQLInputObjectType objectType, Map<
 
 
     public Map<String, GraphQLType> allTypes(GraphQLSchema schema, Set<GraphQLType> dictionary) {
-        Map<String, GraphQLType> typesByName = new LinkedHashMap<String, GraphQLType>();
+        Map<String, GraphQLType> typesByName = new LinkedHashMap<>();
         collectTypes(schema.getQueryType(), typesByName);
         if (schema.isSupportingMutations()) {
             collectTypes(schema.getMutationType(), typesByName);
@@ -122,7 +122,7 @@ public Map<String, GraphQLType> allTypes(GraphQLSchema schema, Set<GraphQLType>
 
     public List<GraphQLObjectType> findImplementations(GraphQLSchema schema, GraphQLInterfaceType interfaceType) {
         Map<String, GraphQLType> allTypes = allTypes(schema, schema.getDictionary());
-        List<GraphQLObjectType> result = new ArrayList<GraphQLObjectType>();
+        List<GraphQLObjectType> result = new ArrayList<>();
         for (GraphQLType type : allTypes.values()) {
             if (!(type instanceof GraphQLObjectType)) {
                 continue;
@@ -179,7 +179,7 @@ GraphQLType resolveTypeReference(GraphQLType type, Map<String, GraphQLType> type
     }
 
     List<GraphQLType> resolveTypeReferences(List<GraphQLType> types, Map<String, GraphQLType> typeMap) {
-        List<GraphQLType> resolvedTypes = new ArrayList<GraphQLType>();
+        List<GraphQLType> resolvedTypes = new ArrayList<>();
         for (GraphQLType type : types) {
             resolvedTypes.add(resolveTypeReference(type, typeMap));
         }

File: src/main/java/graphql/schema/validation/ValidationErrorCollector.java
Patch:
@@ -5,7 +5,7 @@
 
 public class ValidationErrorCollector {
 
-    private final LinkedHashSet<ValidationError> errors = new LinkedHashSet<ValidationError>();
+    private final LinkedHashSet<ValidationError> errors = new LinkedHashSet<>();
 
     public void addError(ValidationError validationError) {
         this.errors.add(validationError);

File: src/main/java/graphql/schema/validation/Validator.java
Patch:
@@ -12,11 +12,11 @@
 
 public class Validator {
 
-    private final Set<GraphQLOutputType> processed = new HashSet<GraphQLOutputType>();
+    private final Set<GraphQLOutputType> processed = new HashSet<>();
     
     public Set<ValidationError> validateSchema(GraphQLSchema schema) {
         ValidationErrorCollector validationErrorCollector = new ValidationErrorCollector();
-        List<ValidationRule> rules = new ArrayList<ValidationRule>();
+        List<ValidationRule> rules = new ArrayList<>();
         rules.add(new NoUnbrokenInputCycles());
         
         traverse(schema.getQueryType(), rules, validationErrorCollector);

File: src/main/java/graphql/validation/ErrorFactory.java
Patch:
@@ -11,7 +11,7 @@ public class ErrorFactory {
 
 
     public ValidationError newError(ValidationErrorType validationErrorType, List<? extends Node> locations, String description) {
-        List<SourceLocation> locationList = new ArrayList<SourceLocation>();
+        List<SourceLocation> locationList = new ArrayList<>();
         for (Node node : locations) {
             locationList.add(node.getSourceLocation());
         }

File: src/main/java/graphql/validation/LanguageTraversal.java
Patch:
@@ -11,14 +11,14 @@ public class LanguageTraversal {
     private final List<Node> path;
 
     public LanguageTraversal() {
-        path = new ArrayList<Node>();
+        path = new ArrayList<>();
     }
 
     public LanguageTraversal(List<Node> basePath) {
         if (basePath != null) {
             path = basePath;
         } else {
-            path = new ArrayList<Node>();
+            path = new ArrayList<>();
         }
     }
 

File: src/main/java/graphql/validation/ValidationContext.java
Patch:
@@ -15,7 +15,7 @@ public class ValidationContext {
     private final Document document;
 
     private TraversalContext traversalContext;
-    private final Map<String, FragmentDefinition> fragmentDefinitionMap = new LinkedHashMap<String, FragmentDefinition>();
+    private final Map<String, FragmentDefinition> fragmentDefinitionMap = new LinkedHashMap<>();
 
 
     public ValidationContext(GraphQLSchema schema, Document document) {

File: src/main/java/graphql/validation/ValidationError.java
Patch:
@@ -12,7 +12,7 @@ public class ValidationError implements GraphQLError {
 
 
     private final ValidationErrorType validationErrorType;
-    private final List<SourceLocation> sourceLocations = new ArrayList<SourceLocation>();
+    private final List<SourceLocation> sourceLocations = new ArrayList<>();
     private final String description;
 
     public ValidationError(ValidationErrorType validationErrorType) {

File: src/main/java/graphql/validation/ValidationErrorCollector.java
Patch:
@@ -6,7 +6,7 @@
 
 public class ValidationErrorCollector {
 
-    private final List<ValidationError> errors = new ArrayList<ValidationError>();
+    private final List<ValidationError> errors = new ArrayList<>();
 
     public void addError(ValidationError validationError) {
         this.errors.add(validationError);

File: src/main/java/graphql/validation/ValidationUtil.java
Patch:
@@ -74,7 +74,7 @@ private boolean isFieldMissing(GraphQLInputObjectType type, Map<String, ObjectFi
     }
 
     private Map<String, ObjectField> fieldMap(ObjectValue objectValue) {
-        Map<String, ObjectField> result = new LinkedHashMap<String, ObjectField>();
+        Map<String, ObjectField> result = new LinkedHashMap<>();
         for (ObjectField objectField : objectValue.getObjectFields()) {
             result.put(objectField.getName(), objectField);
         }

File: src/main/java/graphql/validation/Validator.java
Patch:
@@ -23,7 +23,7 @@ public List<ValidationError> validateDocument(GraphQLSchema schema, Document doc
     }
 
     private List<AbstractRule> createRules(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
-        List<AbstractRule> rules = new ArrayList<AbstractRule>();
+        List<AbstractRule> rules = new ArrayList<>();
         
         ArgumentsOfCorrectType argumentsOfCorrectType = new ArgumentsOfCorrectType(validationContext, validationErrorCollector);
         rules.add(argumentsOfCorrectType);

File: src/main/java/graphql/validation/rules/NoFragmentCycles.java
Patch:
@@ -14,7 +14,7 @@
 
 public class NoFragmentCycles extends AbstractRule {
 
-    private Map<String, List<FragmentSpread>> fragmentSpreads = new LinkedHashMap<String, List<FragmentSpread>>();
+    private Map<String, List<FragmentSpread>> fragmentSpreads = new LinkedHashMap<>();
 
 
     public NoFragmentCycles(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
@@ -34,7 +34,7 @@ private void prepareFragmentMap() {
 
 
     private List<FragmentSpread> gatherSpreads(FragmentDefinition fragmentDefinition) {
-        final List<FragmentSpread> fragmentSpreads = new ArrayList<FragmentSpread>();
+        final List<FragmentSpread> fragmentSpreads = new ArrayList<>();
         QueryLanguageVisitor visitor = new QueryLanguageVisitor() {
             @Override
             public void enter(Node node, List<Node> path) {
@@ -56,7 +56,7 @@ public void leave(Node node, List<Node> path) {
 
     @Override
     public void checkFragmentDefinition(FragmentDefinition fragmentDefinition) {
-        List<FragmentSpread> spreadPath = new ArrayList<FragmentSpread>();
+        List<FragmentSpread> spreadPath = new ArrayList<>();
         detectCycleRecursive(fragmentDefinition.getName(), fragmentDefinition.getName(), spreadPath);
     }
 

File: src/main/java/graphql/validation/rules/NoUndefinedVariables.java
Patch:
@@ -12,7 +12,7 @@
 
 public class NoUndefinedVariables extends AbstractRule {
 
-    private Set<String> variableNames = new LinkedHashSet<String>();
+    private Set<String> variableNames = new LinkedHashSet<>();
 
     public NoUndefinedVariables(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
         super(validationContext, validationErrorCollector);

File: src/main/java/graphql/validation/rules/NoUnusedVariables.java
Patch:
@@ -13,8 +13,8 @@
 
 public class NoUnusedVariables extends AbstractRule {
 
-    private List<VariableDefinition> variableDefinitions = new ArrayList<VariableDefinition>();
-    private Set<String> usedVariables = new LinkedHashSet<String>();
+    private List<VariableDefinition> variableDefinitions = new ArrayList<>();
+    private Set<String> usedVariables = new LinkedHashSet<>();
 
     public NoUnusedVariables(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
         super(validationContext, validationErrorCollector);

File: src/main/java/graphql/validation/rules/ProvidedNonNullArguments.java
Patch:
@@ -38,7 +38,7 @@ public void checkField(Field field) {
     }
 
     private Map<String, Argument> argumentMap(List<Argument> arguments) {
-        Map<String, Argument> result = new LinkedHashMap<String, Argument>();
+        Map<String, Argument> result = new LinkedHashMap<>();
         for (Argument argument : arguments) {
             result.put(argument.getName(), argument);
         }

File: src/main/java/graphql/validation/rules/VariableTypesMatchRule.java
Patch:
@@ -25,7 +25,7 @@ public VariableTypesMatchRule(ValidationContext validationContext, ValidationErr
 
     @Override
     public void checkOperationDefinition(OperationDefinition operationDefinition) {
-        variableDefinitionMap = new LinkedHashMap<String, VariableDefinition>();
+        variableDefinitionMap = new LinkedHashMap<>();
     }
 
     @Override

File: src/main/java/graphql/InvalidSyntaxError.java
Patch:
@@ -8,7 +8,7 @@
 
 public class InvalidSyntaxError implements GraphQLError {
 
-    private final List<SourceLocation> sourceLocations = new ArrayList<SourceLocation>();
+    private final List<SourceLocation> sourceLocations = new ArrayList<>();
 
     public InvalidSyntaxError(SourceLocation sourceLocation) {
         if (sourceLocation != null)

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -75,8 +75,8 @@ private ExecutionResult executeOperation(
             return new ExecutionResultImpl(Collections.singletonList(new MutationNotSupportedError()));
         }
 
-        Map<String, List<Field>> fields = new LinkedHashMap<String, List<Field>>();
-        fieldCollector.collectFields(executionContext, operationRootType, operationDefinition.getSelectionSet(), new ArrayList<String>(), fields);
+        Map<String, List<Field>> fields = new LinkedHashMap<>();
+        fieldCollector.collectFields(executionContext, operationRootType, operationDefinition.getSelectionSet(), new ArrayList<>(), fields);
 
         ExecutionResult result;
         if (operation == MUTATION) {

File: src/main/java/graphql/execution/ExecutionContext.java
Patch:
@@ -22,7 +22,7 @@ public class ExecutionContext {
     private final OperationDefinition operationDefinition;
     private final Map<String, Object> variables;
     private final Object root;
-    private final List<GraphQLError> errors = new CopyOnWriteArrayList<GraphQLError>();
+    private final List<GraphQLError> errors = new CopyOnWriteArrayList<>();
     private final Instrumentation instrumentation;
 
     public ExecutionContext(Instrumentation instrumentation, ExecutionId executionId, GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy, Map<String, FragmentDefinition> fragmentsByName, OperationDefinition operationDefinition, Map<String, Object> variables, Object root) {

File: src/main/java/graphql/execution/ExecutionContextBuilder.java
Patch:
@@ -34,8 +34,8 @@ public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy que
         // preconditions
         assertNotNull(executionId, "You must provide a query identifier");
 
-        Map<String, FragmentDefinition> fragmentsByName = new LinkedHashMap<String, FragmentDefinition>();
-        Map<String, OperationDefinition> operationsByName = new LinkedHashMap<String, OperationDefinition>();
+        Map<String, FragmentDefinition> fragmentsByName = new LinkedHashMap<>();
+        Map<String, OperationDefinition> operationsByName = new LinkedHashMap<>();
 
         for (Definition definition : document.getDefinitions()) {
             if (definition instanceof OperationDefinition) {

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -108,8 +108,8 @@ protected ExecutionResult completeValue(ExecutionContext executionContext, Graph
             resolvedType = (GraphQLObjectType) fieldType;
         }
 
-        Map<String, List<Field>> subFields = new LinkedHashMap<String, List<Field>>();
-        List<String> visitedFragments = new ArrayList<String>();
+        Map<String, List<Field>> subFields = new LinkedHashMap<>();
+        List<String> visitedFragments = new ArrayList<>();
         for (Field field : fields) {
             if (field.getSelectionSet() == null) continue;
             fieldCollector.collectFields(executionContext, resolvedType, field.getSelectionSet(), visitedFragments, subFields);
@@ -160,7 +160,7 @@ protected ExecutionResult completeValueForScalar(GraphQLScalarType scalarType, O
     }
 
     protected ExecutionResult completeValueForList(ExecutionContext executionContext, GraphQLList fieldType, List<Field> fields, Iterable<Object> result) {
-        List<Object> completedResults = new ArrayList<Object>();
+        List<Object> completedResults = new ArrayList<>();
         for (Object item : result) {
             ExecutionResult completedValue = completeValue(executionContext, fieldType.getWrappedType(), fields, item);
             completedResults.add(completedValue != null ? completedValue.getData() : null);

File: src/main/java/graphql/execution/ExecutorServiceExecutionStrategy.java
Patch:
@@ -41,7 +41,7 @@ public ExecutionResult execute(final ExecutionContext executionContext, final Gr
         if (executorService == null)
             return new SimpleExecutionStrategy().execute(executionContext, parentType, source, fields);
 
-        Map<String, Future<ExecutionResult>> futures = new LinkedHashMap<String, Future<ExecutionResult>>();
+        Map<String, Future<ExecutionResult>> futures = new LinkedHashMap<>();
         for (String fieldName : fields.keySet()) {
             final List<Field> fieldList = fields.get(fieldName);
             Callable<ExecutionResult> resolveField = new Callable<ExecutionResult>() {
@@ -54,7 +54,7 @@ public ExecutionResult call() throws Exception {
             futures.put(fieldName, executorService.submit(resolveField));
         }
         try {
-            Map<String, Object> results = new LinkedHashMap<String, Object>();
+            Map<String, Object> results = new LinkedHashMap<>();
             for (String fieldName : futures.keySet()) {
                 ExecutionResult executionResult = futures.get(fieldName).get();
 

File: src/main/java/graphql/execution/FieldCollector.java
Patch:
@@ -67,7 +67,7 @@ private void collectField(ExecutionContext executionContext, Map<String, List<Fi
         }
         String name = getFieldEntryKey(field);
         if (!fields.containsKey(name)) {
-            fields.put(name, new ArrayList<Field>());
+            fields.put(name, new ArrayList<>());
         }
         fields.get(name).add(field);
     }

File: src/main/java/graphql/execution/SimpleExecutionStrategy.java
Patch:
@@ -12,7 +12,7 @@
 public class SimpleExecutionStrategy extends ExecutionStrategy {
     @Override
     public ExecutionResult execute(ExecutionContext executionContext, GraphQLObjectType parentType, Object source, Map<String, List<Field>> fields) {
-        Map<String, Object> results = new LinkedHashMap<String, Object>();
+        Map<String, Object> results = new LinkedHashMap<>();
         for (String fieldName : fields.keySet()) {
             List<Field> fieldList = fields.get(fieldName);
             ExecutionResult resolvedResult = resolveField(executionContext, parentType, source, fieldList);

File: src/main/java/graphql/execution/batched/GraphQLExecutionResultContainer.java
Patch:
@@ -14,13 +14,13 @@ public abstract class GraphQLExecutionResultContainer {
      * @return datum
      */
     public GraphQLExecutionNodeDatum createAndPutChildDatum(String fieldName, Object value) {
-        Map<String, Object> map = new LinkedHashMap<String, Object>();
+        Map<String, Object> map = new LinkedHashMap<>();
         putResult(fieldName, map);
         return new GraphQLExecutionNodeDatum(map, value);
     }
 
     public GraphQLExecutionResultList createAndPutEmptyChildList(String fieldName) {
-        List<Object> resultList = new ArrayList<Object>();
+        List<Object> resultList = new ArrayList<>();
         putResult(fieldName, resultList);
         return new GraphQLExecutionResultList(resultList);
     }

File: src/main/java/graphql/execution/batched/UnbatchedDataFetcher.java
Patch:
@@ -26,7 +26,7 @@ public UnbatchedDataFetcher(DataFetcher delegate) {
     @Override
     public Object get(DataFetchingEnvironment environment) {
         List<Object> sources = environment.getSource();
-        List<Object> results = new ArrayList<Object>();
+        List<Object> results = new ArrayList<>();
         for (Object source : sources) {
             DataFetchingEnvironment singleEnv = new DataFetchingEnvironmentImpl(
                     source,

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -183,7 +183,7 @@ public Object get(DataFetchingEnvironment environment) {
                 GraphQLFieldsContainer fieldsContainer = (GraphQLFieldsContainer) type;
                 List<GraphQLFieldDefinition> fieldDefinitions = fieldsContainer.getFieldDefinitions();
                 if (includeDeprecated) return fieldDefinitions;
-                List<GraphQLFieldDefinition> filtered = new ArrayList<GraphQLFieldDefinition>(fieldDefinitions);
+                List<GraphQLFieldDefinition> filtered = new ArrayList<>(fieldDefinitions);
                 for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {
                     if (fieldDefinition.isDeprecated()) filtered.remove(fieldDefinition);
                 }
@@ -226,7 +226,7 @@ public Object get(DataFetchingEnvironment environment) {
             if (type instanceof GraphQLEnumType) {
                 List<GraphQLEnumValueDefinition> values = ((GraphQLEnumType) type).getValues();
                 if (includeDeprecated) return values;
-                List<GraphQLEnumValueDefinition> filtered = new ArrayList<GraphQLEnumValueDefinition>(values);
+                List<GraphQLEnumValueDefinition> filtered = new ArrayList<>(values);
                 for (GraphQLEnumValueDefinition valueDefinition : values) {
                     if (valueDefinition.isDeprecated()) filtered.remove(valueDefinition);
                 }
@@ -343,7 +343,7 @@ public enum DirectiveLocation {
                         @Override
                         public Object get(DataFetchingEnvironment environment) {
                             GraphQLDirective directive = environment.getSource();
-                            return new ArrayList<DirectiveLocation>(directive.validLocations());
+                            return new ArrayList<>(directive.validLocations());
                         }
                     }))
             .field(newFieldDefinition()

File: src/main/java/graphql/language/Argument.java
Patch:
@@ -33,7 +33,7 @@ public void setValue(Value value) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(value);
         return result;
     }

File: src/main/java/graphql/language/ArrayValue.java
Patch:
@@ -6,7 +6,7 @@
 
 public class ArrayValue extends AbstractNode implements Value {
 
-    private List<Value> values = new ArrayList<Value>();
+    private List<Value> values = new ArrayList<>();
 
     public ArrayValue() {
     }
@@ -26,7 +26,7 @@ public void setValues(List<Value> values) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>(values);
+        return new ArrayList<>(values);
     }
 
     @Override

File: src/main/java/graphql/language/BooleanValue.java
Patch:
@@ -23,7 +23,7 @@ public void setValue(boolean value) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/language/Directive.java
Patch:
@@ -6,7 +6,7 @@
 
 public class Directive extends AbstractNode {
     private String name;
-    private final List<Argument> arguments = new ArrayList<Argument>();
+    private final List<Argument> arguments = new ArrayList<>();
 
     public Directive() {
 
@@ -36,7 +36,7 @@ public void setName(String name) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>(arguments);
+        return new ArrayList<>(arguments);
     }
 
     @Override

File: src/main/java/graphql/language/DirectiveDefinition.java
Patch:
@@ -6,8 +6,8 @@
 
 public class DirectiveDefinition extends AbstractNode implements Definition {
     private String name;
-    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<InputValueDefinition>();
-    private List<DirectiveLocation> directiveLocations = new ArrayList<DirectiveLocation>();
+    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
+    private List<DirectiveLocation> directiveLocations = new ArrayList<>();
 
     public DirectiveDefinition(String name) {
         this.name = name;
@@ -23,7 +23,7 @@ public List<DirectiveLocation> getDirectiveLocations() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(inputValueDefinitions);
         result.addAll(directiveLocations);
         return result;

File: src/main/java/graphql/language/DirectiveLocation.java
Patch:
@@ -21,7 +21,7 @@ public DirectiveLocation(String name) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         return result;
     }
 

File: src/main/java/graphql/language/Document.java
Patch:
@@ -6,7 +6,7 @@
 
 public class Document extends AbstractNode {
 
-    private List<Definition> definitions = new ArrayList<Definition>();
+    private List<Definition> definitions = new ArrayList<>();
 
     public Document() {
 
@@ -27,7 +27,7 @@ public void setDefinitions(List<Definition> definitions) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>(definitions);
+        return new ArrayList<>(definitions);
     }
 
 

File: src/main/java/graphql/language/EnumTypeDefinition.java
Patch:
@@ -15,8 +15,8 @@ public EnumTypeDefinition(String name) {
 
     public EnumTypeDefinition(String name, List<Directive> directives) {
         this.name = name;
-        this.directives = ( null == directives ) ? new ArrayList<Directive>() : directives;
-        this.enumValueDefinitions = new ArrayList<EnumValueDefinition>();
+        this.directives = ( null == directives ) ? new ArrayList<>() : directives;
+        this.enumValueDefinitions = new ArrayList<>();
     }
 
     public List<EnumValueDefinition> getEnumValueDefinitions() {
@@ -34,7 +34,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(enumValueDefinitions);
         result.addAll(directives);
         return result;

File: src/main/java/graphql/language/EnumValue.java
Patch:
@@ -23,7 +23,7 @@ public void setName(String name) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/language/EnumValueDefinition.java
Patch:
@@ -14,7 +14,7 @@ public EnumValueDefinition(String name) {
 
     public EnumValueDefinition(String name, List<Directive> directives) {
         this.name = name;
-        this.directives = (null == directives) ? new ArrayList<Directive>() : directives;
+        this.directives = (null == directives) ? new ArrayList<>() : directives;
     }
 
     public String getName() {
@@ -27,7 +27,7 @@ public List<Directive> getDirectives() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         return result;
     }

File: src/main/java/graphql/language/Field.java
Patch:
@@ -9,8 +9,8 @@ public class Field extends AbstractNode implements Selection {
     private String name;
     private String alias;
 
-    private List<Argument> arguments = new ArrayList<Argument>();
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Argument> arguments = new ArrayList<>();
+    private List<Directive> directives = new ArrayList<>();
     private SelectionSet selectionSet;
 
     public Field() {
@@ -47,7 +47,7 @@ public Field(String name, List<Argument> arguments, SelectionSet selectionSet) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(arguments);
         result.addAll(directives);
         if (selectionSet != null) result.add(selectionSet);

File: src/main/java/graphql/language/FieldDefinition.java
Patch:
@@ -7,8 +7,8 @@
 public class FieldDefinition extends AbstractNode {
     private String name;
     private Type type;
-    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<InputValueDefinition>();
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
+    private List<Directive> directives = new ArrayList<>();
 
     public FieldDefinition(String name) {
         this.name = name;
@@ -41,7 +41,7 @@ public List<Directive> getDirectives() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         result.addAll(inputValueDefinitions);
         result.addAll(directives);

File: src/main/java/graphql/language/FloatValue.java
Patch:
@@ -24,7 +24,7 @@ public void setValue(BigDecimal value) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/language/FragmentDefinition.java
Patch:
@@ -8,7 +8,7 @@ public class FragmentDefinition extends AbstractNode implements Definition {
 
     private String name;
     private TypeName typeCondition;
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Directive> directives = new ArrayList<>();
     private SelectionSet selectionSet;
 
     public FragmentDefinition() {
@@ -61,7 +61,7 @@ public void setSelectionSet(SelectionSet selectionSet) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(typeCondition);
         result.addAll(directives);
         result.add(selectionSet);

File: src/main/java/graphql/language/FragmentSpread.java
Patch:
@@ -7,7 +7,7 @@
 public class FragmentSpread extends AbstractNode implements Selection {
 
     private String name;
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Directive> directives = new ArrayList<>();
 
     public FragmentSpread() {
     }
@@ -46,7 +46,7 @@ public boolean isEqualTo(Node o) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         return result;
     }

File: src/main/java/graphql/language/InlineFragment.java
Patch:
@@ -6,7 +6,7 @@
 
 public class InlineFragment extends AbstractNode implements Selection {
     private TypeName typeCondition;
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Directive> directives = new ArrayList<>();
     private SelectionSet selectionSet;
 
     public InlineFragment() {
@@ -55,7 +55,7 @@ public void setSelectionSet(SelectionSet selectionSet) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         if (typeCondition != null) {
             result.add(typeCondition);
         }

File: src/main/java/graphql/language/InputObjectTypeDefinition.java
Patch:
@@ -6,8 +6,8 @@
 
 public class InputObjectTypeDefinition extends AbstractNode implements TypeDefinition {
     private String name;
-    private List<Directive> directives = new ArrayList<Directive>();
-    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<InputValueDefinition>();
+    private List<Directive> directives = new ArrayList<>();
+    private List<InputValueDefinition> inputValueDefinitions = new ArrayList<>();
 
     public InputObjectTypeDefinition(String name) {
         this.name = name;
@@ -28,7 +28,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         result.addAll(inputValueDefinitions);
         return result;

File: src/main/java/graphql/language/InputValueDefinition.java
Patch:
@@ -8,7 +8,7 @@ public class InputValueDefinition extends AbstractNode {
     private String name;
     private Type type;
     private Value defaultValue;
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Directive> directives = new ArrayList<>();
 
     public InputValueDefinition(String name) {
         this(name, null);
@@ -49,7 +49,7 @@ public List<Directive> getDirectives() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         result.add(defaultValue);
         result.addAll(directives);

File: src/main/java/graphql/language/IntValue.java
Patch:
@@ -23,7 +23,7 @@ public void setValue(BigInteger value) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/language/InterfaceTypeDefinition.java
Patch:
@@ -6,8 +6,8 @@
 
 public class InterfaceTypeDefinition extends AbstractNode implements TypeDefinition {
     private String name;
-    private List<FieldDefinition> definitions = new ArrayList<FieldDefinition>();
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<FieldDefinition> definitions = new ArrayList<>();
+    private List<Directive> directives = new ArrayList<>();
 
     public InterfaceTypeDefinition(String name) {
         this.name = name;
@@ -28,7 +28,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(definitions);
         result.addAll(directives);
         return result;

File: src/main/java/graphql/language/ListType.java
Patch:
@@ -25,7 +25,7 @@ public void setType(Type type) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         return result;
     }

File: src/main/java/graphql/language/NonNullType.java
Patch:
@@ -29,7 +29,7 @@ public void setType(TypeName type) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         return result;
     }

File: src/main/java/graphql/language/ObjectField.java
Patch:
@@ -24,7 +24,7 @@ public Value getValue() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(value);
         return result;
     }

File: src/main/java/graphql/language/ObjectValue.java
Patch:
@@ -6,7 +6,7 @@
 
 public class ObjectValue extends AbstractNode implements Value {
 
-    private List<ObjectField> objectFields = new ArrayList<ObjectField>();
+    private List<ObjectField> objectFields = new ArrayList<>();
 
     public ObjectValue() {
     }
@@ -21,7 +21,7 @@ public List<ObjectField> getObjectFields() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(objectFields);
         return result;
     }

File: src/main/java/graphql/language/OperationDefinition.java
Patch:
@@ -13,8 +13,8 @@ public enum Operation {
     private String name;
 
     private Operation operation;
-    private List<VariableDefinition> variableDefinitions = new ArrayList<VariableDefinition>();
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<VariableDefinition> variableDefinitions = new ArrayList<>();
+    private List<Directive> directives = new ArrayList<>();
     private SelectionSet selectionSet;
 
     public OperationDefinition() {
@@ -44,7 +44,7 @@ public OperationDefinition(String name, Operation operation, SelectionSet select
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(variableDefinitions);
         result.addAll(directives);
         result.add(selectionSet);

File: src/main/java/graphql/language/OperationTypeDefinition.java
Patch:
@@ -35,7 +35,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         return result;
     }

File: src/main/java/graphql/language/ScalarTypeDefinition.java
Patch:
@@ -6,7 +6,7 @@
 
 public class ScalarTypeDefinition extends AbstractNode implements TypeDefinition {
     private String name;
-    private List<Directive> directives = new ArrayList<Directive>();
+    private List<Directive> directives = new ArrayList<>();
 
     public ScalarTypeDefinition(String name) {
         this.name = name;
@@ -23,7 +23,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         return result;
     }

File: src/main/java/graphql/language/SchemaDefinition.java
Patch:
@@ -5,8 +5,8 @@
 import java.util.List;
 
 public class SchemaDefinition extends AbstractNode implements Definition {
-    private List<Directive> directives = new ArrayList<Directive>();
-    private List<OperationTypeDefinition> operationTypeDefinitions = new ArrayList<OperationTypeDefinition>();
+    private List<Directive> directives = new ArrayList<>();
+    private List<OperationTypeDefinition> operationTypeDefinitions = new ArrayList<>();
 
     public SchemaDefinition() {
     }
@@ -21,7 +21,7 @@ public List<OperationTypeDefinition> getOperationTypeDefinitions() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         result.addAll(operationTypeDefinitions);
         return result;

File: src/main/java/graphql/language/SelectionSet.java
Patch:
@@ -6,7 +6,7 @@
 
 public class SelectionSet extends AbstractNode {
 
-    private final List<Selection> selections = new ArrayList<Selection>();
+    private final List<Selection> selections = new ArrayList<>();
 
     public List<Selection> getSelections() {
         return selections;
@@ -21,7 +21,7 @@ public SelectionSet(List<Selection> selections) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(selections);
         return result;
     }

File: src/main/java/graphql/language/StringValue.java
Patch:
@@ -22,7 +22,7 @@ public void setValue(String value) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         return result;
     }
 

File: src/main/java/graphql/language/TypeName.java
Patch:
@@ -22,7 +22,7 @@ public void setName(String name) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/language/UnionTypeDefinition.java
Patch:
@@ -6,8 +6,8 @@
 
 public class UnionTypeDefinition extends AbstractNode implements TypeDefinition {
     private String name;
-    private List<Directive> directives = new ArrayList<Directive>();
-    private List<Type> memberTypes = new ArrayList<Type>();
+    private List<Directive> directives = new ArrayList<>();
+    private List<Type> memberTypes = new ArrayList<>();
 
     public UnionTypeDefinition(String name) {
         this.name = name;
@@ -28,7 +28,7 @@ public String getName() {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.addAll(directives);
         result.addAll(memberTypes);
         return result;

File: src/main/java/graphql/language/VariableDefinition.java
Patch:
@@ -52,7 +52,7 @@ public void setType(Type type) {
 
     @Override
     public List<Node> getChildren() {
-        List<Node> result = new ArrayList<Node>();
+        List<Node> result = new ArrayList<>();
         result.add(type);
         if (defaultValue != null) result.add(defaultValue);
         return result;

File: src/main/java/graphql/language/VariableReference.java
Patch:
@@ -22,7 +22,7 @@ public void setName(String name) {
 
     @Override
     public List<Node> getChildren() {
-        return new ArrayList<Node>();
+        return new ArrayList<>();
     }
 
     @Override

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -53,7 +53,7 @@ public ContextEntry(ContextProperty contextProperty, Object value) {
         }
     }
 
-    private Deque<ContextEntry> contextStack = new ArrayDeque<ContextEntry>();
+    private Deque<ContextEntry> contextStack = new ArrayDeque<>();
 
 
     private void addContextProperty(ContextProperty contextProperty, Object value) {

File: src/main/java/graphql/relay/DefaultConnection.java
Patch:
@@ -5,7 +5,7 @@
 
 public class DefaultConnection implements Connection {
 
-    private List<Edge> edges = new ArrayList<Edge>();
+    private List<Edge> edges = new ArrayList<>();
 
     private PageInfo pageInfo;
 

File: src/main/java/graphql/relay/Relay.java
Patch:
@@ -66,7 +66,7 @@ public GraphQLFieldDefinition nodeField(GraphQLInterfaceType nodeInterface, Data
     }
 
     public List<GraphQLArgument> getConnectionFieldArguments() {
-        List<GraphQLArgument> args = new ArrayList<GraphQLArgument>();
+        List<GraphQLArgument> args = new ArrayList<>();
 
         args.add(newArgument()
                 .name("before")
@@ -88,7 +88,7 @@ public List<GraphQLArgument> getConnectionFieldArguments() {
     }
 
     public List<GraphQLArgument> getBackwardPaginationConnectionFieldArguments() {
-        List<GraphQLArgument> args = new ArrayList<GraphQLArgument>();
+        List<GraphQLArgument> args = new ArrayList<>();
 
         args.add(newArgument()
                 .name("before")
@@ -102,7 +102,7 @@ public List<GraphQLArgument> getBackwardPaginationConnectionFieldArguments() {
     }
 
     public List<GraphQLArgument> getForwardPaginationConnectionFieldArguments() {
-        List<GraphQLArgument> args = new ArrayList<GraphQLArgument>();
+        List<GraphQLArgument> args = new ArrayList<>();
 
         args.add(newArgument()
                 .name("after")

File: src/main/java/graphql/relay/SimpleListConnection.java
Patch:
@@ -25,7 +25,7 @@ public SimpleListConnection(List<?> data) {
     }
 
     private List<Edge> buildEdges() {
-        List<Edge> edges = new ArrayList<Edge>();
+        List<Edge> edges = new ArrayList<>();
         int ix = 0;
         for (Object object : data) {
             edges.add(new DefaultEdge(object, new DefaultConnectionCursor(createCursor(ix++))));

File: src/main/java/graphql/schema/GraphQLDirective.java
Patch:
@@ -14,7 +14,7 @@ public class GraphQLDirective {
     private final String name;
     private final String description;
     private final EnumSet<DirectiveLocation> locations;
-    private final List<GraphQLArgument> arguments = new ArrayList<GraphQLArgument>();
+    private final List<GraphQLArgument> arguments = new ArrayList<>();
     private final boolean onOperation;
     private final boolean onFragment;
     private final boolean onField;
@@ -37,7 +37,7 @@ public String getName() {
     }
 
     public List<GraphQLArgument> getArguments() {
-        return new ArrayList<GraphQLArgument>(arguments);
+        return new ArrayList<>(arguments);
     }
 
     public GraphQLArgument getArgument(String name) {
@@ -90,7 +90,7 @@ public static class Builder {
 
         private String name;
         private EnumSet<DirectiveLocation> locations = EnumSet.noneOf(DirectiveLocation.class);
-        private final List<GraphQLArgument> arguments = new ArrayList<GraphQLArgument>();
+        private final List<GraphQLArgument> arguments = new ArrayList<>();
         private String description;
         private boolean onOperation;
         private boolean onFragment;

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -15,7 +15,7 @@ public class GraphQLEnumType implements GraphQLType, GraphQLInputType, GraphQLOu
 
     private final String name;
     private final String description;
-    private final Map<String, GraphQLEnumValueDefinition> valueDefinitionMap = new LinkedHashMap<String, GraphQLEnumValueDefinition>();
+    private final Map<String, GraphQLEnumValueDefinition> valueDefinitionMap = new LinkedHashMap<>();
 
     private final Coercing coercing = new Coercing() {
         @Override
@@ -58,7 +58,7 @@ private Object getNameByValue(Object value) {
     }
 
     public List<GraphQLEnumValueDefinition> getValues() {
-        return new ArrayList<GraphQLEnumValueDefinition>(valueDefinitionMap.values());
+        return new ArrayList<>(valueDefinitionMap.values());
     }
 
 
@@ -99,7 +99,7 @@ public static class Builder {
 
         private String name;
         private String description;
-        private final List<GraphQLEnumValueDefinition> values = new ArrayList<GraphQLEnumValueDefinition>();
+        private final List<GraphQLEnumValueDefinition> values = new ArrayList<>();
 
         public Builder name(String name) {
             this.name = name;

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -15,7 +15,7 @@ public class GraphQLFieldDefinition {
     private GraphQLOutputType type;
     private final DataFetcher dataFetcher;
     private final String deprecationReason;
-    private final List<GraphQLArgument> arguments = new ArrayList<GraphQLArgument>();
+    private final List<GraphQLArgument> arguments = new ArrayList<>();
 
 
     public GraphQLFieldDefinition(String name, String description, GraphQLOutputType type, DataFetcher dataFetcher, List<GraphQLArgument> arguments, String deprecationReason) {
@@ -57,7 +57,7 @@ public GraphQLArgument getArgument(String name) {
     }
 
     public List<GraphQLArgument> getArguments() {
-        return new ArrayList<GraphQLArgument>(arguments);
+        return new ArrayList<>(arguments);
     }
 
     public String getDescription() {
@@ -82,7 +82,7 @@ public static class Builder {
         private String description;
         private GraphQLOutputType type;
         private DataFetcher dataFetcher;
-        private List<GraphQLArgument> arguments = new ArrayList<GraphQLArgument>();
+        private List<GraphQLArgument> arguments = new ArrayList<>();
         private String deprecationReason;
         private boolean isField;
 

File: src/main/java/graphql/schema/GraphQLInterfaceType.java
Patch:
@@ -15,7 +15,7 @@ public class GraphQLInterfaceType implements GraphQLType, GraphQLOutputType, Gra
 
     private final String name;
     private final String description;
-    private final Map<String, GraphQLFieldDefinition> fieldDefinitionsByName = new LinkedHashMap<String, GraphQLFieldDefinition>();
+    private final Map<String, GraphQLFieldDefinition> fieldDefinitionsByName = new LinkedHashMap<>();
     private final TypeResolver typeResolver;
 
     public GraphQLInterfaceType(String name, String description, List<GraphQLFieldDefinition> fieldDefinitions, TypeResolver typeResolver) {
@@ -43,7 +43,7 @@ public GraphQLFieldDefinition getFieldDefinition(String name) {
 
 
     public List<GraphQLFieldDefinition> getFieldDefinitions() {
-        return new ArrayList<GraphQLFieldDefinition>(fieldDefinitionsByName.values());
+        return new ArrayList<>(fieldDefinitionsByName.values());
     }
 
     public String getName() {
@@ -79,7 +79,7 @@ public static Reference reference(String name) {
     public static class Builder {
         private String name;
         private String description;
-        private List<GraphQLFieldDefinition> fields = new ArrayList<GraphQLFieldDefinition>();
+        private List<GraphQLFieldDefinition> fields = new ArrayList<>();
         private TypeResolver typeResolver;
 
 

File: src/main/java/graphql/schema/GraphQLSchema.java
Patch:
@@ -46,7 +46,7 @@ public GraphQLType getType(String typeName) {
     }
 
     public List<GraphQLType> getAllTypesAsList() {
-        return new ArrayList<GraphQLType>(typeMap.values());
+        return new ArrayList<>(typeMap.values());
     }
 
     public GraphQLObjectType getQueryType() {

File: src/main/java/graphql/schema/GraphQLUnionType.java
Patch:
@@ -11,7 +11,7 @@ public class GraphQLUnionType implements GraphQLType, GraphQLOutputType, GraphQL
 
     private final String name;
     private final String description;
-    private final List<GraphQLObjectType> types = new ArrayList<GraphQLObjectType>();
+    private final List<GraphQLObjectType> types = new ArrayList<>();
     private final TypeResolver typeResolver;
 
 
@@ -36,7 +36,7 @@ void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
     }
 
     public List<GraphQLObjectType> getTypes() {
-        return new ArrayList<GraphQLObjectType>(types);
+        return new ArrayList<>(types);
     }
 
     public TypeResolver getTypeResolver() {
@@ -59,7 +59,7 @@ public static Builder newUnionType() {
     public static class Builder {
         private String name;
         private String description;
-        private List<GraphQLObjectType> types = new ArrayList<GraphQLObjectType>();
+        private List<GraphQLObjectType> types = new ArrayList<>();
         private TypeResolver typeResolver;
 
         public Builder name(String name) {

File: src/main/java/graphql/schema/SchemaUtil.java
Patch:
@@ -106,7 +106,7 @@ private void collectTypesForInputObjects(GraphQLInputObjectType objectType, Map<
 
 
     public Map<String, GraphQLType> allTypes(GraphQLSchema schema, Set<GraphQLType> dictionary) {
-        Map<String, GraphQLType> typesByName = new LinkedHashMap<String, GraphQLType>();
+        Map<String, GraphQLType> typesByName = new LinkedHashMap<>();
         collectTypes(schema.getQueryType(), typesByName);
         if (schema.isSupportingMutations()) {
             collectTypes(schema.getMutationType(), typesByName);
@@ -122,7 +122,7 @@ public Map<String, GraphQLType> allTypes(GraphQLSchema schema, Set<GraphQLType>
 
     public List<GraphQLObjectType> findImplementations(GraphQLSchema schema, GraphQLInterfaceType interfaceType) {
         Map<String, GraphQLType> allTypes = allTypes(schema, schema.getDictionary());
-        List<GraphQLObjectType> result = new ArrayList<GraphQLObjectType>();
+        List<GraphQLObjectType> result = new ArrayList<>();
         for (GraphQLType type : allTypes.values()) {
             if (!(type instanceof GraphQLObjectType)) {
                 continue;
@@ -179,7 +179,7 @@ GraphQLType resolveTypeReference(GraphQLType type, Map<String, GraphQLType> type
     }
 
     List<GraphQLType> resolveTypeReferences(List<GraphQLType> types, Map<String, GraphQLType> typeMap) {
-        List<GraphQLType> resolvedTypes = new ArrayList<GraphQLType>();
+        List<GraphQLType> resolvedTypes = new ArrayList<>();
         for (GraphQLType type : types) {
             resolvedTypes.add(resolveTypeReference(type, typeMap));
         }

File: src/main/java/graphql/schema/validation/ValidationErrorCollector.java
Patch:
@@ -5,7 +5,7 @@
 
 public class ValidationErrorCollector {
 
-    private final LinkedHashSet<ValidationError> errors = new LinkedHashSet<ValidationError>();
+    private final LinkedHashSet<ValidationError> errors = new LinkedHashSet<>();
 
     public void addError(ValidationError validationError) {
         this.errors.add(validationError);

File: src/main/java/graphql/schema/validation/Validator.java
Patch:
@@ -12,11 +12,11 @@
 
 public class Validator {
 
-    private final Set<GraphQLOutputType> processed = new HashSet<GraphQLOutputType>();
+    private final Set<GraphQLOutputType> processed = new HashSet<>();
     
     public Set<ValidationError> validateSchema(GraphQLSchema schema) {
         ValidationErrorCollector validationErrorCollector = new ValidationErrorCollector();
-        List<ValidationRule> rules = new ArrayList<ValidationRule>();
+        List<ValidationRule> rules = new ArrayList<>();
         rules.add(new NoUnbrokenInputCycles());
         
         traverse(schema.getQueryType(), rules, validationErrorCollector);

File: src/main/java/graphql/validation/ErrorFactory.java
Patch:
@@ -11,7 +11,7 @@ public class ErrorFactory {
 
 
     public ValidationError newError(ValidationErrorType validationErrorType, List<? extends Node> locations, String description) {
-        List<SourceLocation> locationList = new ArrayList<SourceLocation>();
+        List<SourceLocation> locationList = new ArrayList<>();
         for (Node node : locations) {
             locationList.add(node.getSourceLocation());
         }

File: src/main/java/graphql/validation/LanguageTraversal.java
Patch:
@@ -11,14 +11,14 @@ public class LanguageTraversal {
     private final List<Node> path;
 
     public LanguageTraversal() {
-        path = new ArrayList<Node>();
+        path = new ArrayList<>();
     }
 
     public LanguageTraversal(List<Node> basePath) {
         if (basePath != null) {
             path = basePath;
         } else {
-            path = new ArrayList<Node>();
+            path = new ArrayList<>();
         }
     }
 

File: src/main/java/graphql/validation/ValidationContext.java
Patch:
@@ -15,7 +15,7 @@ public class ValidationContext {
     private final Document document;
 
     private TraversalContext traversalContext;
-    private final Map<String, FragmentDefinition> fragmentDefinitionMap = new LinkedHashMap<String, FragmentDefinition>();
+    private final Map<String, FragmentDefinition> fragmentDefinitionMap = new LinkedHashMap<>();
 
 
     public ValidationContext(GraphQLSchema schema, Document document) {

File: src/main/java/graphql/validation/ValidationError.java
Patch:
@@ -12,7 +12,7 @@ public class ValidationError implements GraphQLError {
 
 
     private final ValidationErrorType validationErrorType;
-    private final List<SourceLocation> sourceLocations = new ArrayList<SourceLocation>();
+    private final List<SourceLocation> sourceLocations = new ArrayList<>();
     private final String description;
 
     public ValidationError(ValidationErrorType validationErrorType) {

File: src/main/java/graphql/validation/ValidationErrorCollector.java
Patch:
@@ -6,7 +6,7 @@
 
 public class ValidationErrorCollector {
 
-    private final List<ValidationError> errors = new ArrayList<ValidationError>();
+    private final List<ValidationError> errors = new ArrayList<>();
 
     public void addError(ValidationError validationError) {
         this.errors.add(validationError);

File: src/main/java/graphql/validation/ValidationUtil.java
Patch:
@@ -74,7 +74,7 @@ private boolean isFieldMissing(GraphQLInputObjectType type, Map<String, ObjectFi
     }
 
     private Map<String, ObjectField> fieldMap(ObjectValue objectValue) {
-        Map<String, ObjectField> result = new LinkedHashMap<String, ObjectField>();
+        Map<String, ObjectField> result = new LinkedHashMap<>();
         for (ObjectField objectField : objectValue.getObjectFields()) {
             result.put(objectField.getName(), objectField);
         }

File: src/main/java/graphql/validation/Validator.java
Patch:
@@ -23,7 +23,7 @@ public List<ValidationError> validateDocument(GraphQLSchema schema, Document doc
     }
 
     private List<AbstractRule> createRules(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
-        List<AbstractRule> rules = new ArrayList<AbstractRule>();
+        List<AbstractRule> rules = new ArrayList<>();
         
         ArgumentsOfCorrectType argumentsOfCorrectType = new ArgumentsOfCorrectType(validationContext, validationErrorCollector);
         rules.add(argumentsOfCorrectType);

File: src/main/java/graphql/validation/rules/NoFragmentCycles.java
Patch:
@@ -14,7 +14,7 @@
 
 public class NoFragmentCycles extends AbstractRule {
 
-    private Map<String, List<FragmentSpread>> fragmentSpreads = new LinkedHashMap<String, List<FragmentSpread>>();
+    private Map<String, List<FragmentSpread>> fragmentSpreads = new LinkedHashMap<>();
 
 
     public NoFragmentCycles(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
@@ -34,7 +34,7 @@ private void prepareFragmentMap() {
 
 
     private List<FragmentSpread> gatherSpreads(FragmentDefinition fragmentDefinition) {
-        final List<FragmentSpread> fragmentSpreads = new ArrayList<FragmentSpread>();
+        final List<FragmentSpread> fragmentSpreads = new ArrayList<>();
         QueryLanguageVisitor visitor = new QueryLanguageVisitor() {
             @Override
             public void enter(Node node, List<Node> path) {
@@ -56,7 +56,7 @@ public void leave(Node node, List<Node> path) {
 
     @Override
     public void checkFragmentDefinition(FragmentDefinition fragmentDefinition) {
-        List<FragmentSpread> spreadPath = new ArrayList<FragmentSpread>();
+        List<FragmentSpread> spreadPath = new ArrayList<>();
         detectCycleRecursive(fragmentDefinition.getName(), fragmentDefinition.getName(), spreadPath);
     }
 

File: src/main/java/graphql/validation/rules/NoUndefinedVariables.java
Patch:
@@ -12,7 +12,7 @@
 
 public class NoUndefinedVariables extends AbstractRule {
 
-    private Set<String> variableNames = new LinkedHashSet<String>();
+    private Set<String> variableNames = new LinkedHashSet<>();
 
     public NoUndefinedVariables(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
         super(validationContext, validationErrorCollector);

File: src/main/java/graphql/validation/rules/NoUnusedVariables.java
Patch:
@@ -13,8 +13,8 @@
 
 public class NoUnusedVariables extends AbstractRule {
 
-    private List<VariableDefinition> variableDefinitions = new ArrayList<VariableDefinition>();
-    private Set<String> usedVariables = new LinkedHashSet<String>();
+    private List<VariableDefinition> variableDefinitions = new ArrayList<>();
+    private Set<String> usedVariables = new LinkedHashSet<>();
 
     public NoUnusedVariables(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
         super(validationContext, validationErrorCollector);

File: src/main/java/graphql/validation/rules/ProvidedNonNullArguments.java
Patch:
@@ -38,7 +38,7 @@ public void checkField(Field field) {
     }
 
     private Map<String, Argument> argumentMap(List<Argument> arguments) {
-        Map<String, Argument> result = new LinkedHashMap<String, Argument>();
+        Map<String, Argument> result = new LinkedHashMap<>();
         for (Argument argument : arguments) {
             result.put(argument.getName(), argument);
         }

File: src/main/java/graphql/validation/rules/VariableTypesMatchRule.java
Patch:
@@ -25,7 +25,7 @@ public VariableTypesMatchRule(ValidationContext validationContext, ValidationErr
 
     @Override
     public void checkOperationDefinition(OperationDefinition operationDefinition) {
-        variableDefinitionMap = new LinkedHashMap<String, VariableDefinition>();
+        variableDefinitionMap = new LinkedHashMap<>();
     }
 
     @Override

File: src/main/java/graphql/relay/DefaultConnection.java
Patch:
@@ -6,7 +6,7 @@
 
 public class DefaultConnection<T> implements Connection<T> {
 
-    private List<Edge<T>> edges = new ArrayList<Edge<T>>();
+    private List<Edge<T>> edges = new ArrayList<>();
 
     private PageInfo pageInfo;
 

File: src/main/java/graphql/relay/SimpleListConnection.java
Patch:
@@ -25,10 +25,10 @@ public SimpleListConnection(List<T> data) {
     }
 
     private List<Edge<T>> buildEdges() {
-        List<Edge<T>> edges = new ArrayList<Edge<T>>();
+        List<Edge<T>> edges = new ArrayList<>();
         int ix = 0;
         for (T object : data) {
-            edges.add(new DefaultEdge<T>(object, new DefaultConnectionCursor(createCursor(ix++))));
+            edges.add(new DefaultEdge<>(object, new DefaultConnectionCursor(createCursor(ix++))));
         }
         return edges;
     }
@@ -83,7 +83,7 @@ public Connection<T> get(DataFetchingEnvironment environment) {
 
     private Connection<T> emptyConnection() {
         PageInfo pageInfo = new DefaultPageInfo(null, null, false, false);
-        return new DefaultConnection<T>(Collections.<Edge<T>>emptyList(), pageInfo);
+        return new DefaultConnection<>(Collections.emptyList(), pageInfo);
     }
 
     /**

File: src/main/java/graphql/relay/Connection.java
Patch:
@@ -5,9 +5,9 @@
 /**
  * represents a connection in relay.
  */
-public interface Connection {
+public interface Connection<T> {
 
-    List<Edge> getEdges();
+    List<Edge<T>> getEdges();
 
     PageInfo getPageInfo();
 

File: src/main/java/graphql/relay/ConnectionCursor.java
Patch:
@@ -1,7 +1,7 @@
 package graphql.relay;
 
 /**
- * represents a connection cursor in relay.
+ * represents a {@link Connection connection} cursor in relay.
  */
 public interface ConnectionCursor {
 

File: src/main/java/graphql/relay/Edge.java
Patch:
@@ -3,9 +3,9 @@
 /**
  * represents an edge in relay.
  */
-public interface Edge {
+public interface Edge<T> {
 
-    Object getNode();
+    T getNode();
 
     ConnectionCursor getCursor();
 

File: src/main/java/graphql/execution/ExecutionContextBuilder.java
Patch:
@@ -30,7 +30,7 @@ public ExecutionContextBuilder executionId(ExecutionId executionId) {
         return this;
     }
 
-    public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy, Object root, Document document, String operationName, Map<String, Object> args) {
+    public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy, ExecutionStrategy subscriptionStrategy, Object root, Document document, String operationName, Map<String, Object> args) {
         // preconditions
         assertNotNull(executionId, "You must provide a query identifier");
 
@@ -68,6 +68,7 @@ public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy que
                 graphQLSchema,
                 queryStrategy,
                 mutationStrategy,
+                subscriptionStrategy,
                 fragmentsByName,
                 operation,
                 variableValues,

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -449,8 +449,8 @@ public Object get(DataFetchingEnvironment environment) {
                     .dataFetcher(new DataFetcher() {
                         @Override
                         public Object get(DataFetchingEnvironment environment) {
-                            // Not yet supported
-                            return null;
+                            GraphQLSchema schema = environment.getSource();
+                            return schema.getSubscriptionType();
                         }
                     }))
             .build();

File: src/main/java/graphql/language/OperationDefinition.java
Patch:
@@ -7,7 +7,7 @@
 public class OperationDefinition extends AbstractNode implements Definition {
 
     public enum Operation {
-        QUERY, MUTATION
+        QUERY, MUTATION, SUBSCRIPTION
     }
 
     private String name;

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -143,6 +143,8 @@ private OperationDefinition.Operation parseOperation(GraphqlParser.OperationType
             return OperationDefinition.Operation.QUERY;
         } else if (operationTypeContext.getText().equals("mutation")) {
             return OperationDefinition.Operation.MUTATION;
+        } else if (operationTypeContext.getText().equals("subscription")) {
+            return OperationDefinition.Operation.SUBSCRIPTION;
         } else {
             throw new RuntimeException("InternalError: unknown operationTypeContext="+operationTypeContext.getText());
         }

File: src/main/java/graphql/validation/TraversalContext.java
Patch:
@@ -81,6 +81,8 @@ private void enterImpl(OperationDefinition operationDefinition) {
             addType(schema.getMutationType());
         } else if (operationDefinition.getOperation() == OperationDefinition.Operation.QUERY) {
             addType(schema.getQueryType());
+        } else if (operationDefinition.getOperation() == OperationDefinition.Operation.SUBSCRIPTION) {
+            addType(schema.getSubscriptionType());
         } else {
             throw new ShouldNotHappenException();
         }

File: src/test/groovy/readme/ReadmeExamples.java
Patch:
@@ -154,6 +154,7 @@ void executionStrategies() {
         GraphQL graphQL = GraphQL.newGraphQL(StarWarsSchema.starWarsSchema)
                 .queryExecutionStrategy(new ExecutorServiceExecutionStrategy(threadPoolExecutor))
                 .mutationExecutionStrategy(new SimpleExecutionStrategy())
+                .subscriptionExecutionStrategy(new SimpleExecutionStrategy())
                 .build();
 
     }

File: src/main/java/graphql/ExceptionWhileDataFetching.java
Patch:
@@ -20,7 +20,7 @@ public Throwable getException() {
 
     @Override
     public String getMessage() {
-        return "Exception while fetching data: " + exception.toString();
+        return "Exception while fetching data: " + exception.getMessage();
     }
 
     @Override

File: src/main/java/graphql/ExceptionWhileDataFetching.java
Patch:
@@ -20,7 +20,7 @@ public Throwable getException() {
 
     @Override
     public String getMessage() {
-        return "Exception while fetching data: " + exception.toString();
+        return "Exception while fetching data: " + exception.getMessage();
     }
 
     @Override

File: src/main/java/graphql/ErrorType.java
Patch:
@@ -5,5 +5,7 @@ public enum ErrorType {
 
     InvalidSyntax,
     ValidationError,
-    DataFetchingException
+    DataFetchingException,
+    MutationNotSupported
+
 }

File: src/main/java/graphql/ErrorType.java
Patch:
@@ -6,5 +6,4 @@ public enum ErrorType {
     InvalidSyntax,
     ValidationError,
     DataFetchingException
-
 }

File: src/main/java/graphql/ErrorType.java
Patch:
@@ -5,6 +5,7 @@ public enum ErrorType {
 
     InvalidSyntax,
     ValidationError,
-    DataFetchingException
+    DataFetchingException,
+    MutationNotSupported
 
 }

File: src/main/java/graphql/ErrorType.java
Patch:
@@ -5,6 +5,7 @@ public enum ErrorType {
 
     InvalidSyntax,
     ValidationError,
-    DataFetchingException
+    DataFetchingException,
+    MutationsNoSupported
 
 }

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -119,7 +119,7 @@ public ExecutionResult execute(String requestString, String operationName, Objec
         ExecutionId executionId = idProvider.provide(requestString, operationName, context);
 
         Execution execution = new Execution(queryStrategy, mutationStrategy, instrumentation);
-        ExecutionResult result = execution.execute(graphQLSchema, context, document, operationName, arguments);
+        ExecutionResult result = execution.execute(executionId, graphQLSchema, context, document, operationName, arguments);
 
         executionCtx.onEnd(result);
 

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -28,7 +28,7 @@ public Execution(ExecutionStrategy queryStrategy, ExecutionStrategy mutationStra
         this.instrumentation = instrumentation;
     }
 
-    public ExecutionResult execute(GraphQLSchema graphQLSchema, Object root, Document document, String operationName, Map<String, Object> args) {
+    public ExecutionResult execute(ExecutionId executionId, GraphQLSchema graphQLSchema, Object root, Document document, String operationName, Map<String, Object> args) {
         ExecutionContextBuilder executionContextBuilder = new ExecutionContextBuilder(new ValuesResolver(),instrumentation);
         ExecutionContext executionContext = executionContextBuilder
                 .executionId(executionId)

File: src/main/java/graphql/execution/ExecutionContextBuilder.java
Patch:
@@ -19,7 +19,7 @@ public class ExecutionContextBuilder {
     private Instrumentation instrumentation;
     private ExecutionId executionId;
 
-    public ExecutionContextBuilder(ValuesResolver valuesResolver, , Instrumentation instrumentation) {
+    public ExecutionContextBuilder(ValuesResolver valuesResolver, Instrumentation instrumentation) {
         this.valuesResolver = valuesResolver;
         this.instrumentation = instrumentation;
     }
@@ -32,7 +32,7 @@ public ExecutionContextBuilder executionId(ExecutionId executionId) {
 
     public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy, Object root, Document document, String operationName, Map<String, Object> args) {
         // preconditions
-        assertNotNull(executionId,"You must provide a query identifier");
+        assertNotNull(executionId, "You must provide a query identifier");
 
         Map<String, FragmentDefinition> fragmentsByName = new LinkedHashMap<String, FragmentDefinition>();
         Map<String, OperationDefinition> operationsByName = new LinkedHashMap<String, OperationDefinition>();

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -114,10 +114,9 @@ protected ExecutionResult completeValue(ExecutionContext executionContext, Graph
             fieldCollector.collectFields(executionContext, resolvedType, field.getSelectionSet(), visitedFragments, subFields);
         }
 
-        // Calling this from the executionContext so that you can shift from the simple execution strategy for mutations
-        // back to the desired strategy.
+        // Calling this from the executionContext to ensure we shift back from mutation strategy to the query strategy.
 
-        return executionContext.getExecutionStrategy().execute(executionContext, resolvedType, result, subFields);
+        return executionContext.getQueryStrategy().execute(executionContext, resolvedType, result, subFields);
     }
 
     private ExecutionResult completeValueForList(ExecutionContext executionContext, GraphQLList fieldType, List<Field> fields, Object result) {

File: src/main/java/graphql/execution/FieldCollector.java
Patch:
@@ -79,6 +79,9 @@ private String getFieldEntryKey(Field field) {
 
 
     private boolean doesFragmentConditionMatch(ExecutionContext executionContext, InlineFragment inlineFragment, GraphQLObjectType type) {
+        if (inlineFragment.getTypeCondition() == null) {
+            return true;
+        }
         GraphQLType conditionType;
         conditionType = getTypeFromAST(executionContext.getGraphQLSchema(), inlineFragment.getTypeCondition());
         return checkTypeCondition(executionContext, type, conditionType);

File: src/main/java/graphql/language/InlineFragment.java
Patch:
@@ -56,7 +56,9 @@ public void setSelectionSet(SelectionSet selectionSet) {
     @Override
     public List<Node> getChildren() {
         List<Node> result = new ArrayList<Node>();
-        result.add(typeCondition);
+        if (typeCondition != null) {
+            result.add(typeCondition);
+        }
         result.addAll(directives);
         result.add(selectionSet);
         return result;

File: src/main/java/graphql/schema/DataFetcher.java
Patch:
@@ -1,7 +1,7 @@
 package graphql.schema;
 
 
-public interface DataFetcher {
+public interface DataFetcher<T> {
 
-    Object get(DataFetchingEnvironment environment);
+    T get(DataFetchingEnvironment environment);
 }

File: src/main/java/graphql/schema/GraphQLTypeReference.java
Patch:
@@ -7,7 +7,7 @@
  * A special type to allow a object/interface types to reference itself. It's replaced with the real type
  * object when the schema is build.
  */
-public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType {
+public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType, GraphQLInputType, TypeReference {
 
     private final String name;
 

File: src/main/java/graphql/validation/rules/FragmentsOnCompositeType.java
Patch:
@@ -16,6 +16,9 @@ public FragmentsOnCompositeType(ValidationContext validationContext, ValidationE
 
     @Override
     public void checkInlineFragment(InlineFragment inlineFragment) {
+        if (inlineFragment.getTypeCondition() == null) {
+            return;
+        }
         GraphQLType type = getValidationContext().getSchema().getType(inlineFragment.getTypeCondition().getName());
         if (type == null) return;
         if (!(type instanceof GraphQLCompositeType)) {

File: src/main/java/graphql/schema/GraphQLTypeReference.java
Patch:
@@ -7,7 +7,7 @@
  * A special type to allow a object/interface types to reference itself. It's replaced with the real type
  * object when the schema is build.
  */
-public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType {
+public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType, GraphQLInputType, TypeReference {
 
     private final String name;
 

File: src/main/java/graphql/execution/ExecutionContextBuilder.java
Patch:
@@ -18,7 +18,7 @@ public ExecutionContextBuilder(ValuesResolver valuesResolver) {
         this.valuesResolver = valuesResolver;
     }
 
-    public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy executionStrategy, Object root, Document document, String operationName, Map<String, Object> args) {
+    public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy, Object root, Document document, String operationName, Map<String, Object> args) {
         Map<String, FragmentDefinition> fragmentsByName = new LinkedHashMap<String, FragmentDefinition>();
         Map<String, OperationDefinition> operationsByName = new LinkedHashMap<String, OperationDefinition>();
 
@@ -45,12 +45,12 @@ public ExecutionContext build(GraphQLSchema graphQLSchema, ExecutionStrategy exe
         if (operation == null) {
             throw new GraphQLException();
         }
-
         Map<String, Object> variableValues = valuesResolver.getVariableValues(graphQLSchema, operation.getVariableDefinitions(), args);
 
         return new ExecutionContext(
                 graphQLSchema,
-                executionStrategy,
+                queryStrategy,
+                mutationStrategy,
                 fragmentsByName,
                 operation,
                 variableValues,

File: src/main/java/graphql/execution/ExecutionStrategy.java
Patch:
@@ -82,10 +82,9 @@ protected ExecutionResult completeValue(ExecutionContext executionContext, Graph
             fieldCollector.collectFields(executionContext, resolvedType, field.getSelectionSet(), visitedFragments, subFields);
         }
 
-        // Calling this from the executionContext so that you can shift from the simple execution strategy for mutations
-        // back to the desired strategy.
+        // Calling this from the executionContext to ensure we shift back from mutation strategy to the query strategy.
 
-        return executionContext.getExecutionStrategy().execute(executionContext, resolvedType, result, subFields);
+        return executionContext.getQueryStrategy().execute(executionContext, resolvedType, result, subFields);
     }
 
     private ExecutionResult completeValueForList(ExecutionContext executionContext, GraphQLList fieldType, List<Field> fields, Object result) {

File: src/main/java/graphql/execution/FieldCollector.java
Patch:
@@ -79,6 +79,9 @@ private String getFieldEntryKey(Field field) {
 
 
     private boolean doesFragmentConditionMatch(ExecutionContext executionContext, InlineFragment inlineFragment, GraphQLObjectType type) {
+        if (inlineFragment.getTypeCondition() == null) {
+            return true;
+        }
         GraphQLType conditionType;
         conditionType = getTypeFromAST(executionContext.getGraphQLSchema(), inlineFragment.getTypeCondition());
         return checkTypeCondition(executionContext, type, conditionType);

File: src/main/java/graphql/language/InlineFragment.java
Patch:
@@ -56,7 +56,9 @@ public void setSelectionSet(SelectionSet selectionSet) {
     @Override
     public List<Node> getChildren() {
         List<Node> result = new ArrayList<Node>();
-        result.add(typeCondition);
+        if (typeCondition != null) {
+            result.add(typeCondition);
+        }
         result.addAll(directives);
         result.add(selectionSet);
         return result;

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -182,7 +182,7 @@ public Void visitFragmentDefinition(GraphqlParser.FragmentDefinitionContext ctx)
         FragmentDefinition fragmentDefinition = new FragmentDefinition();
         newNode(fragmentDefinition, ctx);
         fragmentDefinition.setName(ctx.fragmentName().getText());
-        fragmentDefinition.setTypeCondition(new TypeName(ctx.typeCondition().getText()));
+        fragmentDefinition.setTypeCondition(new TypeName(ctx.typeCondition().typeName().getText()));
         addContextProperty(ContextProperty.FragmentDefinition, fragmentDefinition);
         result.getDefinitions().add(fragmentDefinition);
         super.visitFragmentDefinition(ctx);
@@ -332,7 +332,8 @@ public Void visitArgument(GraphqlParser.ArgumentContext ctx) {
 
     @Override
     public Void visitInlineFragment(GraphqlParser.InlineFragmentContext ctx) {
-        InlineFragment inlineFragment = new InlineFragment(new TypeName(ctx.typeCondition().getText()));
+        TypeName typeName = ctx.typeCondition() != null ? new TypeName(ctx.typeCondition().typeName().getText()) : null;
+        InlineFragment inlineFragment = new InlineFragment(typeName);
         newNode(inlineFragment, ctx);
         ((SelectionSet) getFromContextStack(ContextProperty.SelectionSet)).getSelections().add(inlineFragment);
         addContextProperty(ContextProperty.InlineFragment, inlineFragment);

File: src/main/java/graphql/validation/rules/FragmentsOnCompositeType.java
Patch:
@@ -16,6 +16,9 @@ public FragmentsOnCompositeType(ValidationContext validationContext, ValidationE
 
     @Override
     public void checkInlineFragment(InlineFragment inlineFragment) {
+        if (inlineFragment.getTypeCondition() == null) {
+            return;
+        }
         GraphQLType type = getValidationContext().getSchema().getType(inlineFragment.getTypeCondition().getName());
         if (type == null) return;
         if (!(type instanceof GraphQLCompositeType)) {

File: src/main/java/graphql/execution/FieldCollector.java
Patch:
@@ -79,6 +79,9 @@ private String getFieldEntryKey(Field field) {
 
 
     private boolean doesFragmentConditionMatch(ExecutionContext executionContext, InlineFragment inlineFragment, GraphQLObjectType type) {
+        if (inlineFragment.getTypeCondition() == null) {
+            return true;
+        }
         GraphQLType conditionType;
         conditionType = getTypeFromAST(executionContext.getGraphQLSchema(), inlineFragment.getTypeCondition());
         return checkTypeCondition(executionContext, type, conditionType);

File: src/main/java/graphql/language/InlineFragment.java
Patch:
@@ -56,7 +56,9 @@ public void setSelectionSet(SelectionSet selectionSet) {
     @Override
     public List<Node> getChildren() {
         List<Node> result = new ArrayList<Node>();
-        result.add(typeCondition);
+        if (typeCondition != null) {
+            result.add(typeCondition);
+        }
         result.addAll(directives);
         result.add(selectionSet);
         return result;

File: src/main/java/graphql/parser/GraphqlAntlrToLanguage.java
Patch:
@@ -182,7 +182,7 @@ public Void visitFragmentDefinition(GraphqlParser.FragmentDefinitionContext ctx)
         FragmentDefinition fragmentDefinition = new FragmentDefinition();
         newNode(fragmentDefinition, ctx);
         fragmentDefinition.setName(ctx.fragmentName().getText());
-        fragmentDefinition.setTypeCondition(new TypeName(ctx.typeCondition().getText()));
+        fragmentDefinition.setTypeCondition(new TypeName(ctx.typeCondition().typeName().getText()));
         addContextProperty(ContextProperty.FragmentDefinition, fragmentDefinition);
         result.getDefinitions().add(fragmentDefinition);
         super.visitFragmentDefinition(ctx);
@@ -332,7 +332,8 @@ public Void visitArgument(GraphqlParser.ArgumentContext ctx) {
 
     @Override
     public Void visitInlineFragment(GraphqlParser.InlineFragmentContext ctx) {
-        InlineFragment inlineFragment = new InlineFragment(new TypeName(ctx.typeCondition().getText()));
+        TypeName typeName = ctx.typeCondition() != null ? new TypeName(ctx.typeCondition().typeName().getText()) : null;
+        InlineFragment inlineFragment = new InlineFragment(typeName);
         newNode(inlineFragment, ctx);
         ((SelectionSet) getFromContextStack(ContextProperty.SelectionSet)).getSelections().add(inlineFragment);
         addContextProperty(ContextProperty.InlineFragment, inlineFragment);

File: src/main/java/graphql/validation/rules/FragmentsOnCompositeType.java
Patch:
@@ -16,6 +16,9 @@ public FragmentsOnCompositeType(ValidationContext validationContext, ValidationE
 
     @Override
     public void checkInlineFragment(InlineFragment inlineFragment) {
+        if (inlineFragment.getTypeCondition() == null) {
+            return;
+        }
         GraphQLType type = getValidationContext().getSchema().getType(inlineFragment.getTypeCondition().getName());
         if (type == null) return;
         if (!(type instanceof GraphQLCompositeType)) {

File: src/main/java/graphql/schema/GraphQLTypeReference.java
Patch:
@@ -7,7 +7,7 @@
  * A special type to allow a object/interface types to reference itself. It's replaced with the real type
  * object when the schema is build.
  */
-public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType, GraphQLInputType {
+public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType, GraphQLInputType, TypeReference {
 
     private final String name;
 

File: src/main/java/graphql/schema/SchemaUtil.java
Patch:
@@ -68,7 +68,7 @@ private void collectTypesForUnions(GraphQLUnionType unionType, Map<String, Graph
     }
 
     private void collectTypesForInterfaces(GraphQLInterfaceType interfaceType, Map<String, GraphQLType> result) {
-        if (result.containsKey(interfaceType.getName())) return;
+        if (result.containsKey(interfaceType.getName()) && !(result.get(interfaceType.getName()) instanceof TypeReference)) return;
         result.put(interfaceType.getName(), interfaceType);
 
         for (GraphQLFieldDefinition fieldDefinition : interfaceType.getFieldDefinitions()) {
@@ -81,7 +81,7 @@ private void collectTypesForInterfaces(GraphQLInterfaceType interfaceType, Map<S
 
 
     private void collectTypesForObjects(GraphQLObjectType objectType, Map<String, GraphQLType> result) {
-        if (result.containsKey(objectType.getName())) return;
+        if (result.containsKey(objectType.getName()) && !(result.get(objectType.getName()) instanceof TypeReference)) return;
         result.put(objectType.getName(), objectType);
 
         for (GraphQLFieldDefinition fieldDefinition : objectType.getFieldDefinitions()) {
@@ -96,7 +96,7 @@ private void collectTypesForObjects(GraphQLObjectType objectType, Map<String, Gr
     }
 
     private void collectTypesForInputObjects(GraphQLInputObjectType objectType, Map<String, GraphQLType> result) {
-        if (result.containsKey(objectType.getName())) return;
+        if (result.containsKey(objectType.getName()) && !(result.get(objectType.getName()) instanceof TypeReference)) return;
         result.put(objectType.getName(), objectType);
 
         for (GraphQLInputObjectField fieldDefinition : objectType.getFields()) {

File: src/main/java/graphql/relay/SimpleListConnection.java
Patch:
@@ -55,7 +55,7 @@ public Object get(DataFetchingEnvironment environment) {
             edges = edges.subList(0, first <= edges.size() ? first : edges.size());
         }
         if (last != null) {
-            edges = edges.subList(edges.size() - last, edges.size());
+            edges = edges.subList( last > edges.size() ? 0 : edges.size() - last, edges.size());
         }
 
         if (edges.size() == 0) {

File: src/main/java/graphql/schema/GraphQLTypeReference.java
Patch:
@@ -7,7 +7,7 @@
  * A special type to allow a object/interface types to reference itself. It's replaced with the real type
  * object when the schema is build.
  */
-public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType {
+public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType, GraphQLInputType {
 
     private final String name;
 

File: src/main/java/graphql/schema/SchemaUtil.java
Patch:
@@ -146,7 +146,7 @@ private void resolveTypeReferencesForFieldsContainer(GraphQLFieldsContainer fiel
     }
 
     GraphQLType resolveTypeReference(GraphQLType type, Map<String, GraphQLType> typeMap) {
-        if (type instanceof GraphQLTypeReference) {
+        if (type instanceof GraphQLTypeReference || typeMap.containsKey(type.getName())) {
             GraphQLType resolvedType = typeMap.get(type.getName());
             if (resolvedType == null) {
                 throw new GraphQLException("type " + type.getName() + " not found in schema");

File: src/main/java/graphql/schema/PropertyDataFetcher.java
Patch:
@@ -48,8 +48,6 @@ private Object getPropertyViaGetterUsingPrefix(Object object, GraphQLOutputType
             Method method = object.getClass().getMethod(getterName);
             return method.invoke(object);
 
-        } catch (NoSuchMethodException e) {
-            throw e;
         } catch (IllegalAccessException e) {
             throw new RuntimeException(e);
         } catch (InvocationTargetException e) {

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -81,13 +81,13 @@ private Object coerceValue(GraphQLType graphQLType, Object value) {
         } else if (graphQLType instanceof GraphQLList) {
             return coerceValueForList((GraphQLList) graphQLType, value);
         } else if (graphQLType instanceof GraphQLInputObjectType) {
-            return coerceValueForInputObjectField((GraphQLInputObjectType) graphQLType, (Map<String, Object>) value);
+            return coerceValueForInputObjectType((GraphQLInputObjectType) graphQLType, (Map<String, Object>) value);
         } else {
             throw new GraphQLException("unknown type " + graphQLType);
         }
     }
 
-    private Object coerceValueForInputObjectField(GraphQLInputObjectType inputObjectType, Map<String, Object> input) {
+    private Object coerceValueForInputObjectType(GraphQLInputObjectType inputObjectType, Map<String, Object> input) {
         Map<String, Object> result = new LinkedHashMap<String, Object>();
         for (GraphQLInputObjectField inputField : inputObjectType.getFields()) {
             Object value = coerceValue(inputField.getType(), input.get(inputField.getName()));

File: src/main/java/graphql/execution/batched/GraphQLExecutionResultContainer.java
Patch:
@@ -1,7 +1,7 @@
 package graphql.execution.batched;
 
 import java.util.ArrayList;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -14,7 +14,7 @@ public abstract class GraphQLExecutionResultContainer {
      * @return datum
      */
     public GraphQLExecutionNodeDatum createAndPutChildDatum(String fieldName, Object value) {
-        Map<String, Object> map = new HashMap<String, Object>();
+        Map<String, Object> map = new LinkedHashMap<String, Object>();
         putResult(fieldName, map);
         return new GraphQLExecutionNodeDatum(map, value);
     }

File: src/main/java/graphql/execution/batched/GraphQLExecutionResultContainer.java
Patch:
@@ -1,7 +1,7 @@
 package graphql.execution.batched;
 
 import java.util.ArrayList;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -14,7 +14,7 @@ public abstract class GraphQLExecutionResultContainer {
      * @return datum
      */
     public GraphQLExecutionNodeDatum createAndPutChildDatum(String fieldName, Object value) {
-        Map<String, Object> map = new HashMap<String, Object>();
+        Map<String, Object> map = new LinkedHashMap<String, Object>();
         putResult(fieldName, map);
         return new GraphQLExecutionNodeDatum(map, value);
     }

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -172,7 +172,7 @@ public Object get(DataFetchingEnvironment environment) {
         @Override
         public Object get(DataFetchingEnvironment environment) {
             Object type = environment.getSource();
-            boolean includeDeprecated = environment.getArgument("includeDeprecated");
+            Boolean includeDeprecated = environment.getArgument("includeDeprecated");
             if (type instanceof GraphQLFieldsContainer) {
                 GraphQLFieldsContainer fieldsContainer = (GraphQLFieldsContainer) type;
                 List<GraphQLFieldDefinition> fieldDefinitions = fieldsContainer.getFieldDefinitions();
@@ -216,7 +216,7 @@ public Object get(DataFetchingEnvironment environment) {
         @Override
         public Object get(DataFetchingEnvironment environment) {
             Object type = environment.getSource();
-            boolean includeDeprecated = environment.getArgument("includeDeprecated");
+            Boolean includeDeprecated = environment.getArgument("includeDeprecated");
             if (type instanceof GraphQLEnumType) {
                 List<GraphQLEnumValueDefinition> values = ((GraphQLEnumType) type).getValues();
                 if (includeDeprecated) return values;

File: src/test/groovy/graphql/MutationSchema.java
Patch:
@@ -79,7 +79,7 @@ public NumberHolder failToChangeTheNumber(int newNumber) {
                     .dataFetcher(new DataFetcher() {
                         @Override
                         public Object get(DataFetchingEnvironment environment) {
-                            int newNumber = environment.getArgument("newNumber");
+                            Integer newNumber = environment.getArgument("newNumber");
                             Root root = (Root) environment.getSource();
                             return root.changeNumber(newNumber);
                         }
@@ -95,7 +95,7 @@ public Object get(DataFetchingEnvironment environment) {
                     .dataFetcher(new DataFetcher() {
                         @Override
                         public Object get(DataFetchingEnvironment environment) {
-                            int newNumber = environment.getArgument("newNumber");
+                            Integer newNumber = environment.getArgument("newNumber");
                             Root root = (Root) environment.getSource();
                             return root.failToChangeTheNumber(newNumber);
                         }

File: src/test/groovy/graphql/NestedInputSchema.java
Patch:
@@ -35,7 +35,7 @@ public static GraphQLObjectType rootType() {
                         .dataFetcher(new DataFetcher() {
                             @Override
                             public Object get(DataFetchingEnvironment environment) {
-                                int initialValue = environment.getArgument("initialValue");
+                                Integer initialValue = environment.getArgument("initialValue");
                                 Map<String, Object> filter = environment.getArgument("filter");
                                 if (filter != null) {
                                     if (filter.containsKey("even")) {

File: src/main/java/graphql/language/Node.java
Patch:
@@ -12,8 +12,8 @@ public interface Node {
     /**
      * Compares just the content and not the children.
      *
-     * @param node
-     * @return
+     * @param node the other node to compare to
+     * @return isEqualTo
      */
     boolean isEqualTo(Node node);
 }

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -117,9 +117,9 @@ public Object get(DataFetchingEnvironment environment) {
         }
 
         /**
-         * Get the data from a field.
+         * Get the data from a field, rather than a property.
          *
-         * @return
+         * @return this builder
          */
         public Builder fetchField() {
             this.isField = true;

File: src/main/java/graphql/language/Node.java
Patch:
@@ -12,8 +12,8 @@ public interface Node {
     /**
      * Compares just the content and not the children.
      *
-     * @param node
-     * @return
+     * @param node the other node to compare to
+     * @return isEqualTo
      */
     boolean isEqualTo(Node node);
 }

File: src/main/java/graphql/schema/GraphQLFieldDefinition.java
Patch:
@@ -117,9 +117,9 @@ public Object get(DataFetchingEnvironment environment) {
         }
 
         /**
-         * Get the data from a field.
+         * Get the data from a field, rather than a property.
          *
-         * @return
+         * @return this builder
          */
         public Builder fetchField() {
             this.isField = true;

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -17,9 +17,9 @@ public class GraphQLObjectType implements GraphQLType, GraphQLOutputType, GraphQ
     private final List<GraphQLInterfaceType> interfaces = new ArrayList<GraphQLInterfaceType>();
 
     public GraphQLObjectType(String name, String description, List<GraphQLFieldDefinition> fieldDefinitions, List<GraphQLInterfaceType> interfaces) {
-        assertNotNull(name, "name can't null");
-        assertNotNull(fieldDefinitions, "fieldDefinitions can't null");
-        assertNotNull(interfaces, "interfaces can't null");
+        assertNotNull(name, "name can't be null");
+        assertNotNull(fieldDefinitions, "fieldDefinitions can't be null");
+        assertNotNull(interfaces, "interfaces can't be null");
         this.name = name;
         this.description = description;
         this.interfaces.addAll(interfaces);

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -17,9 +17,9 @@ public class GraphQLObjectType implements GraphQLType, GraphQLOutputType, GraphQ
     private final List<GraphQLInterfaceType> interfaces = new ArrayList<GraphQLInterfaceType>();
 
     public GraphQLObjectType(String name, String description, List<GraphQLFieldDefinition> fieldDefinitions, List<GraphQLInterfaceType> interfaces) {
-        assertNotNull(name, "name can't null");
-        assertNotNull(fieldDefinitions, "fieldDefinitions can't null");
-        assertNotNull(interfaces, "interfaces can't null");
+        assertNotNull(name, "name can't be null");
+        assertNotNull(fieldDefinitions, "fieldDefinitions can't be null");
+        assertNotNull(interfaces, "interfaces can't be null");
         this.name = name;
         this.description = description;
         this.interfaces.addAll(interfaces);

File: src/main/java/graphql/relay/SimpleListConnection.java
Patch:
@@ -1,5 +1,6 @@
 package graphql.relay;
 
+
 import graphql.schema.DataFetcher;
 import graphql.schema.DataFetchingEnvironment;
 

File: src/main/java/graphql/Scalars.java
Patch:
@@ -89,7 +89,7 @@ public Object parseValue(Object input) {
 
         @Override
         public Object parseLiteral(Object input) {
-            return ((FloatValue) input).getValue().floatValue();
+            return ((FloatValue) input).getValue().doubleValue();
         }
     });
 

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -19,9 +19,9 @@
  * Execution Strategy that minimizes calls to the data fetcher when used in conjunction with {@link DataFetcher}s that have
  * {@link DataFetcher#get(DataFetchingEnvironment)} methods annotated with {@link Batched}. See the javadoc comment on
  * {@link Batched} for a more detailed description of batched data fetchers.
- * <p/>
+ * <p>
  * The strategy runs a BFS over terms of the query and passes a list of all the relevant sources to the batched data fetcher.
- * <p/>
+ * </p>
  * Normal DataFetchers can be used, however they will not see benefits of batching as they expect a single source object
  * at a time.
  */

File: src/main/java/graphql/execution/batched/BatchedExecutionStrategy.java
Patch:
@@ -19,9 +19,9 @@
  * Execution Strategy that minimizes calls to the data fetcher when used in conjunction with {@link DataFetcher}s that have
  * {@link DataFetcher#get(DataFetchingEnvironment)} methods annotated with {@link Batched}. See the javadoc comment on
  * {@link Batched} for a more detailed description of batched data fetchers.
- * <p/>
+ * <p>
  * The strategy runs a BFS over terms of the query and passes a list of all the relevant sources to the batched data fetcher.
- * <p/>
+ * </p>
  * Normal DataFetchers can be used, however they will not see benefits of batching as they expect a single source object
  * at a time.
  */

File: src/main/java/graphql/execution/ExecutorServiceExecutionStrategy.java
Patch:
@@ -25,7 +25,8 @@
  * </ul><p>
  *
  * Failure to follow 1. and 2. can result in a very large number of threads created or hanging. (deadlock)
- * @see {@link graphql.execution.ExecutorServiceExecutionStrategyTest} for example usage
+ * <p>
+ * See {@code graphql.execution.ExecutorServiceExecutionStrategyTest} for example usage.
  */
 public class ExecutorServiceExecutionStrategy extends ExecutionStrategy {
 

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -89,7 +89,7 @@ private Object coerceValueForInputObjectField(GraphQLInputObjectType inputObject
     }
 
     private Object coerceValueForScalar(GraphQLScalarType graphQLScalarType, Object value) {
-        return graphQLScalarType.getCoercing().serialize(value);
+        return graphQLScalarType.getCoercing().parseValue(value);
     }
 
     private Object coerceValueForEnum(GraphQLEnumType graphQLEnumType, Object value) {

File: src/main/java/graphql/schema/Coercing.java
Patch:
@@ -6,6 +6,7 @@ public interface Coercing {
 
     /**
      * Called to convert a result of a DataFetcher to a valid runtime value.
+     *
      * @param input
      * @return
      */

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -33,6 +33,7 @@ public Object coerceLiteral(Object input) {
             if (!(input instanceof EnumValue)) return null;
             EnumValue enumValue = (EnumValue) input;
             GraphQLEnumValueDefinition enumValueDefinition = valueDefinitionMap.get(enumValue.getName());
+            if (enumValueDefinition == null) return null;
             if (enumValueDefinition.getValue() != null) return enumValueDefinition.getValue();
             return enumValueDefinition.getValue();
         }

File: src/main/java/graphql/validation/TraversalContext.java
Patch:
@@ -127,7 +127,8 @@ private void enterImpl(ObjectField objectField) {
         GraphQLInputType inputType = null;
         if (objectType instanceof GraphQLInputObjectType) {
             GraphQLInputObjectField inputField = ((GraphQLInputObjectType) objectType).getField(objectField.getName());
-            inputType = inputField.getType();
+            if (inputField != null)
+                inputType = inputField.getType();
         }
         addInputType(inputType);
     }

File: src/main/java/graphql/validation/TraversalContext.java
Patch:
@@ -127,7 +127,8 @@ private void enterImpl(ObjectField objectField) {
         GraphQLInputType inputType = null;
         if (objectType instanceof GraphQLInputObjectType) {
             GraphQLInputObjectField inputField = ((GraphQLInputObjectType) objectType).getField(objectField.getName());
-            inputType = inputField.getType();
+            if (inputField != null)
+                inputType = inputField.getType();
         }
         addInputType(inputType);
     }

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -33,6 +33,7 @@ public Object coerceLiteral(Object input) {
             if (!(input instanceof EnumValue)) return null;
             EnumValue enumValue = (EnumValue) input;
             GraphQLEnumValueDefinition enumValueDefinition = valueDefinitionMap.get(enumValue.getName());
+            if (enumValueDefinition == null) return null;
             if (enumValueDefinition.getValue() != null) return enumValueDefinition.getValue();
             return enumValueDefinition.getValue();
         }

File: src/main/java/graphql/execution/ValuesResolver.java
Patch:
@@ -93,7 +93,7 @@ private Object coerceValueForScalar(GraphQLScalarType graphQLScalarType, Object
     }
 
     private Object coerceValueForEnum(GraphQLEnumType graphQLEnumType, Object value) {
-        return graphQLEnumType.getCoercing().coerce(value);
+        return graphQLEnumType.getCoercing().coerceValue(value);
     }
 
     private List coerceValueForList(GraphQLList graphQLList, Object value) {

File: src/main/java/graphql/schema/Coercing.java
Patch:
@@ -6,6 +6,8 @@ public interface Coercing {
 
     Object coerce(Object input);
 
+    Object coerceValue(Object input);
+
     /**
      * @param input
      * @return return null if not valid

File: src/test/groovy/graphql/GarfieldSchema.java
Patch:
@@ -13,6 +13,7 @@
 import static graphql.schema.GraphQLFieldDefinition.newFieldDefinition;
 import static graphql.schema.GraphQLInterfaceType.newInterface;
 import static graphql.schema.GraphQLObjectType.newObject;
+import static graphql.schema.GraphQLUnionType.newUnionType;
 
 public class GarfieldSchema {
 
@@ -149,7 +150,7 @@ public GraphQLObjectType getType(Object object) {
             .withInterface(NamedType)
             .build();
 
-    public static GraphQLUnionType PetType = GraphQLUnionType.newUnionType()
+    public static GraphQLUnionType PetType = newUnionType()
             .name("Pet")
             .possibleType(CatType)
             .possibleType(DogType)

File: src/test/groovy/graphql/GarfieldSchema.java
Patch:
@@ -13,6 +13,7 @@
 import static graphql.schema.GraphQLFieldDefinition.newFieldDefinition;
 import static graphql.schema.GraphQLInterfaceType.newInterface;
 import static graphql.schema.GraphQLObjectType.newObject;
+import static graphql.schema.GraphQLUnionType.newUnionType;
 
 public class GarfieldSchema {
 
@@ -149,7 +150,7 @@ public GraphQLObjectType getType(Object object) {
             .withInterface(NamedType)
             .build();
 
-    public static GraphQLUnionType PetType = GraphQLUnionType.newUnionType()
+    public static GraphQLUnionType PetType = newUnionType()
             .name("Pet")
             .possibleType(CatType)
             .possibleType(DogType)

File: src/main/java/graphql/relay/Base64.java
Patch:
@@ -14,7 +14,7 @@ public static String toBase64(String string) {
         }
     }
 
-    public static String fromeBase64(String string) {
+    public static String fromBase64(String string) {
         return new String(DatatypeConverter.parseBase64Binary(string));
     }
 }

File: src/main/java/graphql/relay/Relay.java
Patch:
@@ -178,7 +178,7 @@ public String toGlobalId(String type, String id) {
     }
 
     public ResolvedGlobalId fromGlobalId(String globalId) {
-        String[] split = Base64.fromeBase64(globalId).split(":", 2);
+        String[] split = Base64.fromBase64(globalId).split(":", 2);
         return new ResolvedGlobalId(split[0], split[1]);
     }
 }

File: src/main/java/graphql/relay/SimpleListConnection.java
Patch:
@@ -94,7 +94,7 @@ public ConnectionCursor cursorForObjectInConnection(Object object) {
 
     private int getOffsetFromCursor(String cursor, int defaultValue) {
         if (cursor == null) return defaultValue;
-        String string = Base64.fromeBase64(cursor);
+        String string = Base64.fromBase64(cursor);
         return Integer.parseInt(string.substring(DUMMY_CURSOR_PREFIX.length()));
     }
 

File: src/main/java/graphql/relay/Base64.java
Patch:
@@ -14,7 +14,7 @@ public static String toBase64(String string) {
         }
     }
 
-    public static String fromeBase64(String string) {
+    public static String fromBase64(String string) {
         return new String(DatatypeConverter.parseBase64Binary(string));
     }
 }

File: src/main/java/graphql/relay/Relay.java
Patch:
@@ -178,7 +178,7 @@ public String toGlobalId(String type, String id) {
     }
 
     public ResolvedGlobalId fromGlobalId(String globalId) {
-        String[] split = Base64.fromeBase64(globalId).split(":", 2);
+        String[] split = Base64.fromBase64(globalId).split(":", 2);
         return new ResolvedGlobalId(split[0], split[1]);
     }
 }

File: src/main/java/graphql/relay/SimpleListConnection.java
Patch:
@@ -94,7 +94,7 @@ public ConnectionCursor cursorForObjectInConnection(Object object) {
 
     private int getOffsetFromCursor(String cursor, int defaultValue) {
         if (cursor == null) return defaultValue;
-        String string = Base64.fromeBase64(cursor);
+        String string = Base64.fromBase64(cursor);
         return Integer.parseInt(string.substring(DUMMY_CURSOR_PREFIX.length()));
     }
 

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -102,7 +102,7 @@ public Builder value(String name, Object value) {
         }
 
         public Builder value(String name) {
-            values.add(new GraphQLEnumValueDefinition(name, null, null));
+            values.add(new GraphQLEnumValueDefinition(name, null, name));
             return this;
         }
 

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -102,7 +102,7 @@ public Builder value(String name, Object value) {
         }
 
         public Builder value(String name) {
-            values.add(new GraphQLEnumValueDefinition(name, null, null));
+            values.add(new GraphQLEnumValueDefinition(name, null, name));
             return this;
         }
 

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -380,7 +380,7 @@ public Object get(DataFetchingEnvironment environment) {
             .field(newFieldDefinition()
                     .name("mutationType")
                     .description("If this server supports mutation, the type that mutation operations will be rooted at.")
-                    .type(new GraphQLNonNull(__Type))
+                    .type(__Type)
                     .dataFetcher(new DataFetcher() {
                         @Override
                         public Object get(DataFetchingEnvironment environment) {

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -380,7 +380,7 @@ public Object get(DataFetchingEnvironment environment) {
             .field(newFieldDefinition()
                     .name("mutationType")
                     .description("If this server supports mutation, the type that mutation operations will be rooted at.")
-                    .type(new GraphQLNonNull(__Type))
+                    .type(__Type)
                     .dataFetcher(new DataFetcher() {
                         @Override
                         public Object get(DataFetchingEnvironment environment) {

File: src/main/java/graphql/Scalars.java
Patch:
@@ -73,7 +73,7 @@ public Object coerceLiteral(Object input) {
     public static GraphQLScalarType GraphQLString = new GraphQLScalarType("String", "Built-in String", new Coercing() {
         @Override
         public Object coerce(Object input) {
-            return input.toString();
+            return input == null ? null : input.toString();
         }
 
         @Override

File: src/main/java/graphql/Scalars.java
Patch:
@@ -73,7 +73,7 @@ public Object coerceLiteral(Object input) {
     public static GraphQLScalarType GraphQLString = new GraphQLScalarType("String", "Built-in String", new Coercing() {
         @Override
         public Object coerce(Object input) {
-            return input.toString();
+            return input == null ? null : input.toString();
         }
 
         @Override

File: src/main/java/graphql/relay/ConnectionCursor.java
Patch:
@@ -34,8 +34,6 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return "ConnectionCursor{" +
-                "value='" + value + '\'' +
-                '}';
+        return value;
     }
 }

File: src/main/java/graphql/ExceptionWhileDataFetching.java
Patch:
@@ -29,7 +29,7 @@ public List<SourceLocation> getLocations() {
     }
 
     @Override
-    public ErrorType geErrorType() {
+    public ErrorType getErrorType() {
         return ErrorType.DataFetchingException;
     }
 

File: src/main/java/graphql/GraphQLError.java
Patch:
@@ -11,6 +11,6 @@ public interface GraphQLError {
 
     List<SourceLocation> getLocations();
 
-    ErrorType geErrorType();
+    ErrorType getErrorType();
 
 }

File: src/main/java/graphql/InvalidSyntaxError.java
Patch:
@@ -33,7 +33,7 @@ public List<SourceLocation> getLocations() {
     }
 
     @Override
-    public ErrorType geErrorType() {
+    public ErrorType getErrorType() {
         return ErrorType.InvalidSyntax;
     }
 

File: src/main/java/graphql/validation/ValidationError.java
Patch:
@@ -48,7 +48,7 @@ public List<SourceLocation> getLocations() {
     }
 
     @Override
-    public ErrorType geErrorType() {
+    public ErrorType getErrorType() {
         return ErrorType.ValidationError;
     }
 

File: src/main/java/graphql/ExceptionWhileDataFetching.java
Patch:
@@ -29,7 +29,7 @@ public List<SourceLocation> getLocations() {
     }
 
     @Override
-    public ErrorType geErrorType() {
+    public ErrorType getErrorType() {
         return ErrorType.DataFetchingException;
     }
 

File: src/main/java/graphql/GraphQLError.java
Patch:
@@ -11,6 +11,6 @@ public interface GraphQLError {
 
     List<SourceLocation> getLocations();
 
-    ErrorType geErrorType();
+    ErrorType getErrorType();
 
 }

File: src/main/java/graphql/InvalidSyntaxError.java
Patch:
@@ -33,7 +33,7 @@ public List<SourceLocation> getLocations() {
     }
 
     @Override
-    public ErrorType geErrorType() {
+    public ErrorType getErrorType() {
         return ErrorType.InvalidSyntax;
     }
 

File: src/main/java/graphql/validation/ValidationError.java
Patch:
@@ -48,7 +48,7 @@ public List<SourceLocation> getLocations() {
     }
 
     @Override
-    public ErrorType geErrorType() {
+    public ErrorType getErrorType() {
         return ErrorType.ValidationError;
     }
 

File: src/main/java/graphql/validation/rules/ArgumentsOfCorrectType.java
Patch:
@@ -16,7 +16,8 @@ public void checkArgument(Argument argument) {
         GraphQLArgument fieldArgument = getValidationContext().getArgument();
         if (fieldArgument == null) return;
         if (!getValidationUtil().isValidLiteralValue(argument.getValue(), fieldArgument.getType())) {
-            addError(new ValidationError(ValidationErrorType.WrongType));
+            String message = String.format("argument value %s has wrong type", argument.getValue());
+            addError(new ValidationError(ValidationErrorType.WrongType, argument.getSourceLocation(), message));
         }
     }
 

File: src/main/java/graphql/validation/rules/FieldsOnCorrectType.java
Patch:
@@ -20,7 +20,8 @@ public void checkField(Field field) {
         if (parentType == null) return;
         GraphQLFieldDefinition fieldDef = getValidationContext().getFieldDef();
         if (fieldDef == null) {
-            addError(new ValidationError(ValidationErrorType.FieldUndefined));
+            String message = String.format("Field %s is undefined", field.getName());
+            addError(new ValidationError(ValidationErrorType.FieldUndefined, field.getSourceLocation(), message));
         }
 
     }

File: src/main/java/graphql/validation/rules/KnownArgumentNames.java
Patch:
@@ -18,8 +18,9 @@ public void checkArgument(Argument argument) {
         GraphQLFieldDefinition fieldDef = getValidationContext().getFieldDef();
         if (fieldDef == null) return;
         GraphQLArgument fieldArgument = fieldDef.getArgument(argument.getName());
-        if(fieldArgument == null){
-            addError(new ValidationError(ValidationErrorType.UnknownArgument));
+        if (fieldArgument == null) {
+            String message = String.format("Unknown argument %s", argument.getName());
+            addError(new ValidationError(ValidationErrorType.UnknownArgument, argument.getSourceLocation(), message));
         }
     }
 }

File: src/main/java/graphql/validation/rules/KnownTypeNames.java
Patch:
@@ -14,7 +14,8 @@ public KnownTypeNames(ValidationContext validationContext, ValidationErrorCollec
     @Override
     public void checkTypeName(TypeName typeName) {
         if ((getValidationContext().getSchema().getType(typeName.getName())) == null) {
-            addError(new ValidationError(ValidationErrorType.UnknownType));
+            String message = String.format("Unknown type %s", typeName.getName());
+            addError(new ValidationError(ValidationErrorType.UnknownType, typeName.getSourceLocation(), message));
         }
     }
 }

File: src/main/java/graphql/validation/rules/NoUndefinedVariables.java
Patch:
@@ -32,7 +32,8 @@ public void checkFragmentDefinition(FragmentDefinition fragmentDefinition) {
     @Override
     public void checkVariable(VariableReference variableReference) {
         if (!variableNames.contains(variableReference.getName())) {
-            addError(new ValidationError(ValidationErrorType.UndefinedVariable, variableReference.getSourceLocation(), null));
+            String message = String.format("Undefined variable %s",variableReference.getName());
+            addError(new ValidationError(ValidationErrorType.UndefinedVariable, variableReference.getSourceLocation(), message));
         }
     }
 

File: src/main/java/graphql/validation/rules/NoUnusedVariables.java
Patch:
@@ -25,7 +25,8 @@ public NoUnusedVariables(ValidationContext validationContext, ValidationErrorCol
     public void leaveOperationDefinition(OperationDefinition operationDefinition) {
         for (VariableDefinition variableDefinition : variableDefinitions) {
             if (!usedVariables.contains(variableDefinition.getName())) {
-                addError(new ValidationError(ValidationErrorType.UnusedVariable, variableDefinition.getSourceLocation(), null));
+                String message = String.format("Unused variable %s",variableDefinition.getName());
+                addError(new ValidationError(ValidationErrorType.UnusedVariable, variableDefinition.getSourceLocation(), message));
             }
         }
     }

File: src/main/java/graphql/validation/rules/VariableTypesMatchRule.java
Patch:
@@ -41,7 +41,8 @@ public void checkVariable(VariableReference variableReference) {
         if (variableType == null) return;
         GraphQLInputType inputType = getValidationContext().getInputType();
         if (!variablesTypesMatcher.doesVariableTypesMatch(variableType, variableDefinition.getDefaultValue(), inputType)) {
-            addError(new ValidationError(ValidationErrorType.VariableTypeMismatch));
+            String message = "Variable type doesn't match";
+            addError(new ValidationError(ValidationErrorType.VariableTypeMismatch, variableReference.getSourceLocation(), message));
         }
     }
 

File: src/main/java/graphql/validation/rules/VariablesAreInputTypes.java
Patch:
@@ -22,7 +22,8 @@ public void checkVariableDefinition(VariableDefinition variableDefinition) {
         GraphQLType type = getValidationContext().getSchema().getType(unmodifiedAstType.getName());
         if (type == null) return;
         if (!schemaUtil.isInputType(type)) {
-            addError(new ValidationError(ValidationErrorType.NonInputTypeOnVariable));
+            String message = "Wrong type for a variable";
+            addError(new ValidationError(ValidationErrorType.NonInputTypeOnVariable, variableDefinition.getSourceLocation(), message));
         }
     }
 }

File: src/main/java/graphql/execution/TypeFromAST.java
Patch:
@@ -17,6 +17,6 @@ public static GraphQLType getTypeFromAST(GraphQLSchema schema, Type type) {
         } else if (type instanceof NonNullType) {
             return new GraphQLNonNull(getTypeFromAST(schema, ((NonNullType) type).getType()));
         }
-        return schemaUtil.findType(schema, ((TypeName) type).getName());
+        return schema.getType(((TypeName) type).getName());
     }
 }

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -355,7 +355,7 @@ public Object get(DataFetchingEnvironment environment) {
                         @Override
                         public Object get(DataFetchingEnvironment environment) {
                             GraphQLSchema schema = (GraphQLSchema) environment.getSource();
-                            return new SchemaUtil().allTypesAsList(schema);
+                            return schema.getAllTypesAsList();
                         }
                     })
                     .build())
@@ -421,7 +421,7 @@ public Object get(DataFetchingEnvironment environment) {
                 @Override
                 public Object get(DataFetchingEnvironment environment) {
                     String name = environment.getArgument("name");
-                    return new SchemaUtil().findType(environment.getGraphQLSchema(), name);
+                    return environment.getGraphQLSchema().getType(name);
                 }
             })
             .build();

File: src/main/java/graphql/validation/TraversalContext.java
Patch:
@@ -87,12 +87,12 @@ private void enterImpl(OperationDefinition operationDefinition) {
     }
 
     private void enterImpl(InlineFragment inlineFragment) {
-        GraphQLType type = schemaUtil.findType(schema, inlineFragment.getTypeCondition().getName());
+        GraphQLType type = schema.getType(inlineFragment.getTypeCondition().getName());
         addType((GraphQLOutputType) type);
     }
 
     private void enterImpl(FragmentDefinition fragmentDefinition) {
-        GraphQLType type = schemaUtil.findType(schema, fragmentDefinition.getTypeCondition().getName());
+        GraphQLType type = schema.getType(fragmentDefinition.getTypeCondition().getName());
         addType((GraphQLOutputType) type);
     }
 
@@ -141,7 +141,7 @@ private GraphQLArgument find(List<GraphQLArgument> arguments, String name) {
 
 
     @Override
-    public void leave(Node node,List<Node> ancestors) {
+    public void leave(Node node, List<Node> ancestors) {
         if (node instanceof OperationDefinition) {
             outputTypeStack.remove(outputTypeStack.size() - 1);
         } else if (node instanceof SelectionSet) {

File: src/main/java/graphql/validation/rules/KnownTypeNames.java
Patch:
@@ -2,20 +2,18 @@
 
 
 import graphql.language.TypeName;
-import graphql.schema.SchemaUtil;
 import graphql.validation.*;
 
 public class KnownTypeNames extends AbstractRule {
 
-    private SchemaUtil schemaUtil = new SchemaUtil();
 
     public KnownTypeNames(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
         super(validationContext, validationErrorCollector);
     }
 
     @Override
     public void checkTypeName(TypeName typeName) {
-        if (schemaUtil.findType(getValidationContext().getSchema(), typeName.getName()) == null) {
+        if ((getValidationContext().getSchema().getType(typeName.getName())) == null) {
             addError(new ValidationError(ValidationErrorType.UnknownType));
         }
     }

File: src/main/java/graphql/validation/rules/VariablesAreInputTypes.java
Patch:
@@ -19,7 +19,7 @@ public VariablesAreInputTypes(ValidationContext validationContext, ValidationErr
     public void checkVariableDefinition(VariableDefinition variableDefinition) {
         TypeName unmodifiedAstType = getValidationUtil().getUnmodifiedType(variableDefinition.getType());
 
-        GraphQLType type = schemaUtil.findType(getValidationContext().getSchema(), unmodifiedAstType.getName());
+        GraphQLType type = getValidationContext().getSchema().getType(unmodifiedAstType.getName());
         if (type == null) return;
         if (!schemaUtil.isInputType(type)) {
             addError(new ValidationError(ValidationErrorType.NonInputTypeOnVariable));

File: src/main/java/graphql/validation/ValidationErrorCollector.java
Patch:
@@ -4,7 +4,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-public class ErrorCollector {
+public class ValidationErrorCollector {
 
     private final List<ValidationError> errors = new ArrayList<>();
 
@@ -16,9 +16,9 @@ public List<ValidationError> getErrors(){
         return errors;
     }
 
-    public boolean containsError(ValidationErrorType validationErrorType){
+    public boolean containsValidationError(ValidationErrorType validationErrorType){
         for(ValidationError validationError : errors){
-            if(validationError.getErrorType() == validationErrorType) return true;
+            if(validationError.getValidationErrorType() == validationErrorType) return true;
         }
         return false;
     }

File: src/main/java/graphql/validation/rules/ArgumentsOfCorrectType.java
Patch:
@@ -7,8 +7,8 @@
 
 public class ArgumentsOfCorrectType extends AbstractRule {
 
-    public ArgumentsOfCorrectType(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public ArgumentsOfCorrectType(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 
     @Override

File: src/main/java/graphql/validation/rules/FieldsOnCorrectType.java
Patch:
@@ -9,8 +9,8 @@
 public class FieldsOnCorrectType extends AbstractRule {
 
 
-    public FieldsOnCorrectType(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public FieldsOnCorrectType(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 
 

File: src/main/java/graphql/validation/rules/FragmentsOnCompositeType.java
Patch:
@@ -12,8 +12,8 @@ public class FragmentsOnCompositeType extends AbstractRule {
 
     private SchemaUtil schemaUtil = new SchemaUtil();
 
-    public FragmentsOnCompositeType(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public FragmentsOnCompositeType(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 
     @Override

File: src/main/java/graphql/validation/rules/KnownArgumentNames.java
Patch:
@@ -8,8 +8,8 @@
 
 public class KnownArgumentNames extends AbstractRule {
 
-    public KnownArgumentNames(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public KnownArgumentNames(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 
 

File: src/main/java/graphql/validation/rules/KnownFragmentNames.java
Patch:
@@ -7,8 +7,8 @@
 
 public class KnownFragmentNames extends AbstractRule{
 
-    public KnownFragmentNames(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public KnownFragmentNames(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 
     @Override

File: src/main/java/graphql/validation/rules/KnownTypeNames.java
Patch:
@@ -9,8 +9,8 @@ public class KnownTypeNames extends AbstractRule {
 
     private SchemaUtil schemaUtil = new SchemaUtil();
 
-    public KnownTypeNames(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public KnownTypeNames(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 
     @Override

File: src/main/java/graphql/validation/rules/NoFragmentCycles.java
Patch:
@@ -2,13 +2,13 @@
 
 
 import graphql.validation.AbstractRule;
-import graphql.validation.ErrorCollector;
 import graphql.validation.ValidationContext;
+import graphql.validation.ValidationErrorCollector;
 
 public class NoFragmentCycles extends AbstractRule{
 
-    public NoFragmentCycles(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public NoFragmentCycles(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 
 }

File: src/main/java/graphql/validation/rules/NoUndefinedVariables.java
Patch:
@@ -2,12 +2,12 @@
 
 
 import graphql.validation.AbstractRule;
-import graphql.validation.ErrorCollector;
 import graphql.validation.ValidationContext;
+import graphql.validation.ValidationErrorCollector;
 
 public class NoUndefinedVariables extends AbstractRule{
 
-    public NoUndefinedVariables(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public NoUndefinedVariables(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 }

File: src/main/java/graphql/validation/rules/NoUnusedFragments.java
Patch:
@@ -21,8 +21,8 @@ public class NoUnusedFragments extends AbstractRule {
     private Map<String, List<String>> spreadsInDefinition = new LinkedHashMap<>();
     private final List<List<String>>  fragmentsUsedDirectlyInOperation = new ArrayList<>();
 
-    public NoUnusedFragments(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public NoUnusedFragments(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 
     @Override

File: src/main/java/graphql/validation/rules/NoUnusedVariables.java
Patch:
@@ -2,12 +2,12 @@
 
 
 import graphql.validation.AbstractRule;
-import graphql.validation.ErrorCollector;
 import graphql.validation.ValidationContext;
+import graphql.validation.ValidationErrorCollector;
 
 public class NoUnusedVariables extends AbstractRule{
 
-    public NoUnusedVariables(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public NoUnusedVariables(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 }

File: src/main/java/graphql/validation/rules/OverlappingFieldsCanBeMerged.java
Patch:
@@ -2,12 +2,12 @@
 
 
 import graphql.validation.AbstractRule;
-import graphql.validation.ErrorCollector;
 import graphql.validation.ValidationContext;
+import graphql.validation.ValidationErrorCollector;
 
 public class OverlappingFieldsCanBeMerged extends AbstractRule{
 
-    public OverlappingFieldsCanBeMerged(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public OverlappingFieldsCanBeMerged(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 }

File: src/main/java/graphql/validation/rules/PossibleFragmentSpreads.java
Patch:
@@ -2,12 +2,12 @@
 
 
 import graphql.validation.AbstractRule;
-import graphql.validation.ErrorCollector;
 import graphql.validation.ValidationContext;
+import graphql.validation.ValidationErrorCollector;
 
 public class PossibleFragmentSpreads extends AbstractRule{
 
-    public PossibleFragmentSpreads(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public PossibleFragmentSpreads(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 }

File: src/main/java/graphql/validation/rules/ProvidedNonNullArguments.java
Patch:
@@ -16,8 +16,8 @@
 
 public class ProvidedNonNullArguments extends AbstractRule {
 
-    public ProvidedNonNullArguments(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public ProvidedNonNullArguments(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 
     @Override

File: src/main/java/graphql/validation/rules/ScalarLeafs.java
Patch:
@@ -10,8 +10,8 @@ public class ScalarLeafs extends AbstractRule {
 
     private SchemaUtil schemaUtil = new SchemaUtil();
 
-    public ScalarLeafs(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public ScalarLeafs(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 
     @Override

File: src/main/java/graphql/validation/rules/VariableDefaultValuesOfCorrectType.java
Patch:
@@ -9,8 +9,8 @@
 public class VariableDefaultValuesOfCorrectType extends AbstractRule {
 
 
-    public VariableDefaultValuesOfCorrectType(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public VariableDefaultValuesOfCorrectType(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 
 

File: src/main/java/graphql/validation/rules/VariableTypesMatchRule.java
Patch:
@@ -16,8 +16,8 @@ public class VariableTypesMatchRule extends AbstractRule {
 
     VariablesTypesMatcher variablesTypesMatcher = new VariablesTypesMatcher();
 
-    public VariableTypesMatchRule(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public VariableTypesMatchRule(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 
     private Map<String, VariableDefinition> variableDefinitionMap;

File: src/main/java/graphql/validation/rules/VariablesAreInputTypes.java
Patch:
@@ -11,8 +11,8 @@ public class VariablesAreInputTypes extends AbstractRule {
 
     private SchemaUtil schemaUtil = new SchemaUtil();
 
-    public VariablesAreInputTypes(ValidationContext validationContext, ErrorCollector errorCollector) {
-        super(validationContext, errorCollector);
+    public VariablesAreInputTypes(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {
+        super(validationContext, validationErrorCollector);
     }
 
     @Override

File: src/main/java/graphql/schema/GraphQLList.java
Patch:
@@ -25,6 +25,6 @@ void replaceTypeReferences(Map<String, GraphQLType> typeMap) {
 
     @Override
     public String getName() {
-        return "GraphQLList";
+        return null;
     }
 }

File: src/main/java/graphql/schema/GraphQLNonNull.java
Patch:
@@ -32,6 +32,6 @@ public String toString() {
 
     @Override
     public String getName() {
-        return "GraphQLNonNull";
+        return null;
     }
 }

File: src/main/java/graphql/schema/SchemaUtil.java
Patch:
@@ -2,6 +2,7 @@
 
 
 import graphql.GraphQLException;
+import graphql.introspection.Introspection;
 
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
@@ -101,6 +102,7 @@ public Map<String, GraphQLType> allTypes(GraphQLSchema schema) {
         if (schema.isSupportingMutations()) {
             collectTypes(schema.getMutationType(), typesByName);
         }
+        collectTypes(Introspection.__Schema, typesByName);
         return typesByName;
     }
 

File: src/main/java/graphql/introspection/Introspection.java
Patch:
@@ -65,7 +65,7 @@ public Object get(DataFetchingEnvironment environment) {
     };
 
     public static GraphQLObjectType __InputValue = newObject()
-            .name("__Field")
+            .name("__InputValue")
             .field(newFieldDefinition()
                     .name("name")
                     .type(new GraphQLNonNull(GraphQLString))

File: src/main/java/graphql/ExecutionResultImpl.java
Patch:
@@ -19,8 +19,9 @@ public ExecutionResultImpl(List<? extends GraphQLError> errors) {
         this.errors.addAll(errors);
     }
 
-    public ExecutionResultImpl(Map<String, Object> result) {
+    public ExecutionResultImpl(Map<String, Object> result,List<? extends GraphQLError> errors) {
         this.result = result;
+        this.errors.addAll(errors);
     }
 
 

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -2,7 +2,6 @@
 
 
 import graphql.execution.Execution;
-import graphql.execution.ExecutionResult;
 import graphql.language.Document;
 import graphql.parser.Parser;
 import graphql.schema.GraphQLSchema;
@@ -59,13 +58,13 @@ public ExecutionResult execute(String requestString, String operationName, Objec
             document = parser.parseDocument(requestString);
         } catch (RecognitionException e) {
             ValidationError validationError = new ValidationError(ValidationErrorType.InvalidSyntax);
-            return new ExecutionResult(Arrays.asList(validationError));
+            return new ExecutionResultImpl(Arrays.asList(validationError));
         }
 
         Validator validator = new Validator();
         List<ValidationError> validationErrors = validator.validateDocument(graphQLSchema, document);
         if (validationErrors.size() > 0) {
-            ExecutionResult result = new ExecutionResult(validationErrors);
+            ExecutionResult result = new ExecutionResultImpl(validationErrors);
             return result;
         }
         Execution execution = new Execution(executorService);

File: src/main/java/graphql/validation/ValidationError.java
Patch:
@@ -1,7 +1,9 @@
 package graphql.validation;
 
 
-public class ValidationError {
+import graphql.GraphQLError;
+
+public class ValidationError implements GraphQLError {
 
     private final ValidationErrorType errorType;
 

File: src/main/java/graphql/validation/ValidationErrorType.java
Patch:
@@ -18,7 +18,7 @@ public enum ValidationErrorType {
     NonInputTypeOnVariable,
     UnusedFragment,
     MissingFieldArgument,
-    MissingDirectiveArgument
-
+    MissingDirectiveArgument,
+    VariableTypeMismatch
 
 }

File: src/main/java/graphql/validation/Validator.java
Patch:
@@ -56,8 +56,8 @@ private List<AbstractRule> createRules(ValidationContext validationContext, Erro
         rules.add(scalarLeafs);
         VariablesAreInputTypes variablesAreInputTypes = new VariablesAreInputTypes(validationContext, errorCollector);
         rules.add(variablesAreInputTypes);
-        VariablesInAllowedPosition variablesInAllowedPosition = new VariablesInAllowedPosition(validationContext, errorCollector);
-        rules.add(variablesInAllowedPosition);
+        VariableTypesMatchRule variableTypesMatchRule = new VariableTypesMatchRule(validationContext, errorCollector);
+        rules.add(variableTypesMatchRule);
         return rules;
     }
 }

File: src/test/groovy/graphql/HelloWorld.java
Patch:
@@ -22,7 +22,7 @@ public static void main(String[] args) {
         GraphQLSchema schema = GraphQLSchema.newSchema()
                 .query(queryType)
                 .build();
-        Object result = new GraphQL(schema, "{hello}").execute().getResult();
+        Object result = new GraphQL(schema).execute("{hello}").getResult();
         System.out.println(result);
     }
 }

File: src/main/java/graphql/execution/Execution.java
Patch:
@@ -16,7 +16,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 
-import static graphql.introspection.Schema.*;
+import static graphql.introspection.Introspection.*;
 
 public class Execution {
 

File: src/main/java/graphql/schema/SchemaUtil.java
Patch:
@@ -56,6 +56,7 @@ private  void collectTypes(GraphQLType root, Map<String, GraphQLType> result) {
     }
 
     private  void collectTypesForUnions(GraphQLUnionType unionType, Map<String, GraphQLType> result) {
+        result.put(unionType.getName(), unionType);
         for (GraphQLType type : unionType.getTypes()) {
             collectTypes(type, result);
         }

File: src/main/java/graphql/validation/TraversalContext.java
Patch:
@@ -9,7 +9,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import static graphql.introspection.Schema.*;
+import static graphql.introspection.Introspection.*;
 
 public class TraversalContext implements QueryLanguageVisitor {
     GraphQLSchema schema;

File: src/main/java/graphql/validation/ValidationErrorType.java
Patch:
@@ -14,6 +14,7 @@ public enum ValidationErrorType {
     InlineFragmentTypeConditionInvalid,
     FragmentTypeConditionInvalid,
     UnknownArgument,
-    UndefinedFragment
+    UndefinedFragment,
+    NonInputTypeOnVariable
 
 }

File: src/main/java/graphql/validation/TraversalContext.java
Patch:
@@ -52,7 +52,7 @@ public void enter(Node node) {
 
 
     private void enterImpl(SelectionSet selectionSet) {
-        GraphQLUnmodifiedType rawType = SchemaUtil.getUnmodifiedType(getType());
+        GraphQLUnmodifiedType rawType = SchemaUtil.getUnmodifiedType(getOutputType());
         GraphQLCompositeType parentType = null;
         if (rawType instanceof GraphQLCompositeType) {
             parentType = (GraphQLCompositeType) rawType;
@@ -170,7 +170,7 @@ private GraphQLNullableType getNullableType(GraphQLType type) {
         return (GraphQLNullableType) (type instanceof GraphQLNonNull ? ((GraphQLNonNull) type).getWrappedType() : type);
     }
 
-    public GraphQLOutputType getType() {
+    public GraphQLOutputType getOutputType() {
         return lastElement(typeStack);
     }
 

File: src/main/java/graphql/validation/ValidationContext.java
Patch:
@@ -69,8 +69,8 @@ public GraphQLArgument getArgument() {
         return traversalContext.getArgument();
     }
 
-    public GraphQLOutputType getType() {
-        return traversalContext.getType();
+    public GraphQLOutputType getOutputType() {
+        return traversalContext.getOutputType();
     }
 
 

File: src/main/java/graphql/validation/rules/ScalarLeafs.java
Patch:
@@ -15,7 +15,7 @@ public ScalarLeafs(ValidationContext validationContext, ErrorCollector errorColl
 
     @Override
     public void checkField(Field field) {
-        GraphQLOutputType type = getValidationContext().getType();
+        GraphQLOutputType type = getValidationContext().getOutputType();
         if (type == null) return;
         if (SchemaUtil.isLeafType(type)) {
             if (field.getSelectionSet() != null) {

File: src/main/java/graphql/validation/RulesVisitor.java
Patch:
@@ -37,7 +37,7 @@ public RulesVisitor(ValidationContext validationContext,ErrorCollector errorColl
 
     @Override
     public void enter(Node node) {
-        validationContext.getTypeInfo().enter(node);
+        validationContext.getTraversalContext().enter(node);
         if (node instanceof Argument) {
             for (AbstractRule rule : rules) {
                 rule.checkArgument((Argument) node);
@@ -51,6 +51,6 @@ public void enter(Node node) {
 
     @Override
     public void leave(Node node) {
-        validationContext.getTypeInfo().leave(node);
+        validationContext.getTraversalContext().leave(node);
     }
 }

File: src/main/java/graphql/validation/TraversalContext.java
Patch:
@@ -11,7 +11,7 @@
 
 import static graphql.introspection.Schema.*;
 
-public class TypeInfo implements QueryLanguageVisitor {
+public class TraversalContext implements QueryLanguageVisitor {
     GraphQLSchema schema;
     List<GraphQLOutputType> typeStack = new ArrayList<>();
     List<GraphQLCompositeType> parentTypeStack = new ArrayList<>();
@@ -21,7 +21,7 @@ public class TypeInfo implements QueryLanguageVisitor {
     GraphQLArgument argument;
 
 
-    public TypeInfo(GraphQLSchema graphQLSchema) {
+    public TraversalContext(GraphQLSchema graphQLSchema) {
         this.schema = graphQLSchema;
     }
 
@@ -62,7 +62,6 @@ private void enterImpl(SelectionSet selectionSet) {
             compositeType = (GraphQLCompositeType) rawType;
         }
         addParentType(compositeType);
-        ;
     }
 
     private void enterImpl(Field field) {

File: src/main/java/graphql/schema/GraphQLArgument.java
Patch:
@@ -5,7 +5,7 @@ public class GraphQLArgument {
 
     private final String name;
     private final String description;
-    private final GraphQLInputType type;
+    private GraphQLInputType type;
     private final Object defaultValue;
 
     public GraphQLArgument(String name, String description, GraphQLInputType graphQLInputType, Object defaultValue) {
@@ -19,6 +19,7 @@ public GraphQLArgument(String name, GraphQLInputType type) {
         this(name, null, type, null);
     }
 
+
     public String getName() {
         return name;
     }

File: src/main/java/graphql/schema/GraphQLFieldsContainer.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.List;
 
 
-public interface GraphQLFieldsContainer {
+public interface GraphQLFieldsContainer extends GraphQLType{
 
     GraphQLFieldDefinition getFieldDefinition(String name);
 

File: src/main/java/graphql/schema/GraphQLInputObjectField.java
Patch:
@@ -8,7 +8,7 @@ public class GraphQLInputObjectField {
 
     private final String name;
     private final String description;
-    private final GraphQLInputType type;
+    private GraphQLInputType type;
     private final Object defaultValue;
 
     public GraphQLInputObjectField(String name, GraphQLInputType type) {
@@ -22,6 +22,7 @@ public GraphQLInputObjectField(String name, String description, GraphQLInputType
         this.description = description;
     }
 
+
     public String getName() {
         return name;
     }
@@ -58,7 +59,7 @@ public Builder description(String description) {
             return this;
         }
 
-        public Builder type(GraphQLInputType type){
+        public Builder type(GraphQLInputType type) {
             this.type = type;
             return this;
         }

File: src/main/java/graphql/schema/GraphQLObjectType.java
Patch:
@@ -11,7 +11,7 @@ public class GraphQLObjectType implements GraphQLType, GraphQLOutputType, GraphQ
     private final String name;
     private final String description;
     private final Map<String, GraphQLFieldDefinition> fieldDefinitionsByName = new LinkedHashMap<>();
-    private final List<GraphQLInterfaceType> interfaces = new ArrayList<>();
+    private  List<GraphQLInterfaceType> interfaces = new ArrayList<>();
 
     public GraphQLObjectType(String name, String description, List<GraphQLFieldDefinition> fieldDefinitions, List<GraphQLInterfaceType> interfaces) {
         this.name = name;
@@ -26,6 +26,7 @@ private void buildDefinitionMap(List<GraphQLFieldDefinition> fieldDefinitions) {
         }
     }
 
+
     public GraphQLFieldDefinition getFieldDefinition(String name) {
         return fieldDefinitionsByName.get(name);
     }
@@ -49,6 +50,7 @@ public String getName() {
         return name;
     }
 
+
     @Override
     public String toString() {
         return "GraphQLObjectType{" +

File: src/main/java/graphql/schema/GraphQLType.java
Patch:
@@ -4,4 +4,6 @@
 public interface GraphQLType {
 
     String getName();
+
+
 }

File: src/main/java/graphql/schema/GraphQLTypeReference.java
Patch:
@@ -1,7 +1,7 @@
 package graphql.schema;
 
 
-public class GraphQLTypeReference implements GraphQLType {
+public class GraphQLTypeReference implements GraphQLType, GraphQLOutputType {
 
     private final String name;
 

File: src/main/java/graphql/schema/GraphQLUnionType.java
Patch:
@@ -4,11 +4,11 @@
 import java.util.ArrayList;
 import java.util.List;
 
-public class GraphQLUnionType implements GraphQLType, GraphQLOutputType, GraphQLCompositeType,GraphQLUnmodifiedType,GraphQLNullableType {
+public class GraphQLUnionType implements GraphQLType, GraphQLOutputType, GraphQLCompositeType, GraphQLUnmodifiedType, GraphQLNullableType {
 
     private final String name;
     private final String description;
-    private final List<GraphQLType> types = new ArrayList<>();
+    private List<GraphQLType> types = new ArrayList<>();
     private final TypeResolver typeResolver;
 
 
@@ -19,6 +19,7 @@ public GraphQLUnionType(String name, String description, List<GraphQLType> possi
         this.typeResolver = typeResolver;
     }
 
+
     public List<GraphQLType> getTypes() {
         return new ArrayList<>(types);
     }

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -39,7 +39,7 @@ public Object execute() {
         Parser parser = new Parser();
         Document document = parser.parseDocument(requestString);
         Execution execution = new Execution(executorService);
-        return execution.execute(graphQLSchema, null, document, null, arguments).getResut();
+        return execution.execute(graphQLSchema, null, document, null, arguments).getResult();
     }
 
 

File: src/main/java/graphql/GraphQL.java
Patch:
@@ -39,7 +39,7 @@ public Object execute() {
         Parser parser = new Parser();
         Document document = parser.parseDocument(requestString);
         Execution execution = new Execution(executorService);
-        return execution.execute(graphQLSchema, null, document, null, arguments).getResut();
+        return execution.execute(graphQLSchema, null, document, null, arguments).getResult();
     }
 
 

File: src/test/groovy/graphql/StarWarsSchema.java
Patch:
@@ -45,6 +45,7 @@ public class StarWarsSchema {
                     .description("Which movies they appear in.")
                     .type(new GraphQLList(episodeEnum))
                     .build())
+            .typeResolver(StarWarsData.getCharacterTypeResolver())
             .build();
 
     static GraphQLObjectType humanType = newObject()

File: src/main/java/graphql/execution/Resolver.java
Patch:
@@ -56,7 +56,7 @@ private Map<String, Argument> argumentMap(List<Argument> arguments) {
 
 
     private Object getVariableValue(GraphQLSchema schema, VariableDefinition variableDefinition, Object inputValue) {
-        GraphQLType type = SchemaUtil.findType(schema, variableDefinition.getType().getName());
+        GraphQLType type = TypeFromAST.getTypeFromAST(schema, variableDefinition.getType());
 
         if (!isValid(type, inputValue)) {
             throw new GraphQLException("Invalid value for type");

File: src/main/java/graphql/schema/GraphQLEnumType.java
Patch:
@@ -1,7 +1,7 @@
 package graphql.schema;
 
 
-public class GraphQLEnumType implements NamedType, GraphQLInputType, GraphQLOutputType {
+public class GraphQLEnumType implements GraphQLType, GraphQLInputType, GraphQLOutputType {
 
     String name;
 

