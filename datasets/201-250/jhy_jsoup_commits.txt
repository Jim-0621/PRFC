File: src/main/java/org/jsoup/helper/RequestAuthenticator.java
Patch:
@@ -38,7 +38,7 @@ class Context {
         }
 
         /**
-         Get he URL that is being requested.
+         Get the URL that is being requested.
          * @return URL
          */
         public URL url() {

File: src/main/java/org/jsoup/internal/SharedConstants.java
Patch:
@@ -18,5 +18,7 @@ public final class SharedConstants {
 
     public static final String DummyUri = "https://dummy.example/"; // used as a base URI if none provided, to allow abs url resolution to preserve relative links
 
+    public static final String UseHttpClient = "jsoup.useHttpClient";
+
     private SharedConstants() {}
 }

File: src/test/java/org/jsoup/integration/TestServer.java
Patch:
@@ -182,7 +182,6 @@ private static void setupDefaultTrust(File keystoreFile) throws KeyStoreExceptio
         TrustManager[] managers = trustManagerFactory.getTrustManagers();
         SSLContext tls = SSLContext.getInstance("TLS");
         tls.init(null, managers, null);
-        SSLSocketFactory socketFactory = tls.getSocketFactory();
-        HttpsURLConnection.setDefaultSSLSocketFactory(socketFactory);
+        SSLContext.setDefault(tls);
     }
 }

File: src/main/java/org/jsoup/select/Evaluator.java
Patch:
@@ -170,7 +170,7 @@ public boolean matches(Element root, Element element) {
         }
 
         @Override protected int cost() {
-            return 6; // does whitespace scanning
+            return 8; // does whitespace scanning; more than .contains()
         }
 
         @Override

File: src/main/java/org/jsoup/select/QueryParser.java
Patch:
@@ -114,7 +114,7 @@ private void combinator(char combinator) {
                 currentEval = run;
                 break;
             case ' ':
-                currentEval = new CombiningEvaluator.And(new StructuralEvaluator.Parent(currentEval), newEval);
+                currentEval = new CombiningEvaluator.And(new StructuralEvaluator.Ancestor(currentEval), newEval);
                 break;
             case '+':
                 currentEval = new CombiningEvaluator.And(new StructuralEvaluator.ImmediatePreviousSibling(currentEval), newEval);

File: src/test/java/org/jsoup/select/SelectorTest.java
Patch:
@@ -1282,7 +1282,7 @@ public void emptyPseudo() {
         // https://github.com/jhy/jsoup/issues/2073
         Document doc = Jsoup.parse("<div id=parent><span class=child></span><span class=child></span><span class=child></span></div>");
         String q = "#parent [class*=child], .some-other-selector .nested";
-        assertEquals("(Or (And (Parent (Id '#parent'))(AttributeWithValueContaining '[class*=child]'))(And (Class '.nested')(Parent (Class '.some-other-selector'))))", EvaluatorDebug.sexpr(q));
+        assertEquals("(Or (And (AttributeWithValueContaining '[class*=child]')(Ancestor (Id '#parent')))(And (Class '.nested')(Ancestor (Class '.some-other-selector'))))", EvaluatorDebug.sexpr(q));
         Elements els = doc.select(q);
         assertEquals(3, els.size());
     }

File: src/main/java/org/jsoup/Jsoup.java
Patch:
@@ -261,7 +261,7 @@ public static Document parse(Path path, @Nullable String charsetName, String bas
      @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
      @return sane HTML
 
-     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
+     @throws IOException if the stream could not be read, or if the charsetName is invalid.
      */
     public static Document parse(InputStream in, @Nullable String charsetName, String baseUri) throws IOException {
         return DataUtil.load(in, charsetName, baseUri);
@@ -278,7 +278,7 @@ public static Document parse(InputStream in, @Nullable String charsetName, Strin
      @param parser alternate {@link Parser#xmlParser() parser} to use.
      @return sane HTML
 
-     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
+     @throws IOException if the stream could not be read, or if the charsetName is invalid.
      */
     public static Document parse(InputStream in, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {
         return DataUtil.load(in, charsetName, baseUri, parser);

File: src/main/java/org/jsoup/internal/ControllableInputStream.java
Patch:
@@ -46,11 +46,11 @@ private ControllableInputStream(SimpleBufferedInput in, int maxSize) {
 
     /**
      * If this InputStream is not already a ControllableInputStream, let it be one.
-     * @param in the input stream to (maybe) wrap
+     * @param in the input stream to (maybe) wrap. A {@code null} input will create an empty wrapped stream.
      * @param maxSize the maximum size to allow to be read. 0 == infinite.
      * @return a controllable input stream
      */
-    public static ControllableInputStream wrap(InputStream in, int maxSize) {
+    public static ControllableInputStream wrap(@Nullable InputStream in, int maxSize) {
         // bufferSize currently unused; consider implementing as a min size in the SoftPool recycler
         if (in instanceof ControllableInputStream)
             return (ControllableInputStream) in;

File: src/main/java/org/jsoup/internal/SimpleBufferedInput.java
Patch:
@@ -24,8 +24,9 @@ class SimpleBufferedInput extends FilterInputStream {
     private int bufMark = -1;
     private boolean inReadFully = false; // true when the underlying inputstream has been read fully
 
-    SimpleBufferedInput(InputStream in) {
+    SimpleBufferedInput(@Nullable InputStream in) {
         super(in);
+        if (in == null) inReadFully = true; // effectively an empty stream
     }
 
     @Override
@@ -148,7 +149,7 @@ public void reset() throws IOException {
 
     @Override
     public void close() throws IOException {
-        super.close();
+        if (in != null) super.close();
         if (byteBuf == null) return; // already closed, or never allocated
         BufferPool.release(byteBuf); // return the buffer to the pool
         byteBuf = null; // NPE further attempts to read

File: src/main/java/org/jsoup/parser/TreeBuilder.java
Patch:
@@ -77,8 +77,8 @@ Document parse(Reader input, String baseUri, Parser parser) {
         return doc;
     }
 
-    List<Node> parseFragment(String inputFragment, @Nullable Element context, String baseUri, Parser parser) {
-        initialiseParse(new StringReader(inputFragment), baseUri, parser);
+    List<Node> parseFragment(Reader inputFragment, @Nullable Element context, String baseUri, Parser parser) {
+        initialiseParse(inputFragment, baseUri, parser);
         initialiseParseFragment(context);
         runParser();
         return completeParseFragment();

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -509,6 +509,7 @@ void nodelistChanged() {
      */
     public void replaceWith(Node in) {
         Validate.notNull(in);
+        if (parentNode == null) parentNode = in.parentNode; // allows old to have been temp removed before replacing
         Validate.notNull(parentNode);
         parentNode.replaceChild(this, in);
     }

File: src/test/java/org/jsoup/parser/TokeniserStateTest.java
Patch:
@@ -230,7 +230,7 @@ public void testOpeningAngleBracketInsteadOfAttribute() {
 
         Parser.parseFragment(triggeringSnippet, null, "", errorList);
 
-        assertEquals(6, errorList.get(0).getPosition());
+        assertEquals(7, errorList.get(0).getPosition());
     }
 
     @Test

File: src/main/java/org/jsoup/parser/CharacterReader.java
Patch:
@@ -489,7 +489,7 @@ String consumeRawData() {
 
     String consumeTagName() {
         // '\t', '\n', '\r', '\f', ' ', '/', '>'
-        // NOTE: out of spec, added '<' to fix common author bugs; does not stop and append on nullChar but eats
+        // NOTE: out of spec; does not stop and append on nullChar but eats
         bufferUp();
         int pos = bufPos;
         final int start = pos;
@@ -505,7 +505,6 @@ String consumeTagName() {
                 case ' ':
                 case '/':
                 case '>':
-                case '<':
                     break OUTER;
             }
             pos++;

File: src/main/java/org/jsoup/select/CombiningEvaluator.java
Patch:
@@ -66,7 +66,7 @@ void updateEvaluators() {
     }
 
     public static final class And extends CombiningEvaluator {
-        And(Collection<Evaluator> evaluators) {
+        public And(Collection<Evaluator> evaluators) {
             super(evaluators);
         }
 
@@ -95,7 +95,7 @@ public static final class Or extends CombiningEvaluator {
          * Create a new Or evaluator. The initial evaluators are ANDed together and used as the first clause of the OR.
          * @param evaluators initial OR clause (these are wrapped into an AND evaluator).
          */
-        Or(Collection<Evaluator> evaluators) {
+        public Or(Collection<Evaluator> evaluators) {
             super();
             if (num > 1)
                 this.evaluators.add(new And(evaluators));

File: src/test/java/org/jsoup/integration/servlets/RedirectServlet.java
Patch:
@@ -33,7 +33,8 @@ protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOEx
 
         if (req.getParameter(SetCookiesParam) != null) {
             res.addCookie(new Cookie("token", "asdfg123"));
-            res.addCookie(new Cookie("uid", "jhy"));
+            res.addCookie(new Cookie("uid", "foobar"));
+            res.addCookie(new Cookie("uid", "jhy")); // dupe, should use latter
         }
 
         res.setHeader("Location", location);

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -25,18 +25,19 @@ enum HtmlTreeBuilderState {
                 tb.insertCommentNode(t.asComment());
             } else if (t.isDoctype()) {
                 // todo: parse error check on expected doctypes
-                // todo: quirk state check on doctype ids
                 Token.Doctype d = t.asDoctype();
                 DocumentType doctype = new DocumentType(
                     tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());
                 doctype.setPubSysKey(d.getPubSysKey());
                 tb.getDocument().appendChild(doctype);
                 tb.onNodeInserted(doctype);
-                if (d.isForceQuirks())
+                // todo: quirk state check on more doctype ids, if deemed useful (most are ancient legacy and presumably irrelevant)
+                if (d.isForceQuirks() || !doctype.name().equals("html") || doctype.publicId().equalsIgnoreCase("HTML"))
                     tb.getDocument().quirksMode(Document.QuirksMode.quirks);
                 tb.transition(BeforeHtml);
             } else {
                 // todo: check not iframe srcdoc
+                tb.getDocument().quirksMode(Document.QuirksMode.quirks); // missing doctype
                 tb.transition(BeforeHtml);
                 return tb.process(t); // re-process token
             }

File: src/test/java/org/jsoup/select/SelectorTest.java
Patch:
@@ -28,7 +28,7 @@ public static void assertSelectedIds(Elements els, String... ids) {
         }
     }
 
-    static void assertSelectedOwnText(Elements els, String... ownTexts) {
+    public static void assertSelectedOwnText(Elements els, String... ownTexts) {
         assertNotNull(els);
         assertEquals(ownTexts.length, els.size(), "Incorrect number of selected elements");
         for (int i = 0; i < ownTexts.length; i++) {

File: src/main/java/org/jsoup/internal/SharedConstants.java
Patch:
@@ -10,7 +10,7 @@ public final class SharedConstants {
     public static final String RangeKey = "jsoup.start";
     public static final String EndRangeKey = "jsoup.end";
 
-    public static final int DefaultBufferSize = 1024 * 32;
+    public static final int DefaultBufferSize = 8 * 1024;
 
     public static final String[] FormSubmitTags = {
         "input", "keygen", "object", "select", "textarea"

File: src/test/java/org/jsoup/integration/ParseTest.java
Patch:
@@ -153,7 +153,8 @@ public static String getFileAsString(File file) throws IOException {
         if (file.getName().endsWith(".gz")) {
             InputStream stream = new GZIPInputStream(new FileInputStream(file));
             ByteBuffer byteBuffer = DataUtil.readToByteBuffer(stream, 0);
-            bytes = byteBuffer.array();
+            bytes = new byte[byteBuffer.limit()];
+            System.arraycopy(byteBuffer.array(), 0, bytes, 0, byteBuffer.limit());
         } else {
             bytes = Files.readAllBytes(file.toPath());
         }

File: src/test/java/org/jsoup/integration/servlets/EchoServlet.java
Patch:
@@ -90,7 +90,7 @@ protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOEx
 
         // post body
         ByteBuffer byteBuffer = DataUtil.readToByteBuffer(req.getInputStream(), 0);
-        String postData = new String(byteBuffer.array(), StandardCharsets.UTF_8);
+        String postData = new String(byteBuffer.array(), byteBuffer.arrayOffset(), byteBuffer.limit(), StandardCharsets.UTF_8);
         if (!StringUtil.isBlank(postData)) {
             write(w, "Post Data", postData);
         }

File: src/test/java/org/jsoup/integration/servlets/InterruptedServlet.java
Patch:
@@ -27,8 +27,8 @@ protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOEx
 
         StringBuilder sb = new StringBuilder();
         sb.append("<title>Something</title>");
-        while (sb.length() <= CharacterReaderTest.maxBufferLen) {
-            sb.append("A suitable amount of data. \n");
+        while (sb.length() <= 32 * 1024) {
+            sb.append("<div>A suitable amount of data.</div>\n");
         }
         sb.append("<p>Finale.</p>");
         String data = sb.toString();

File: src/test/java/org/jsoup/parser/HtmlParserTest.java
Patch:
@@ -368,7 +368,7 @@ private static Stream<Arguments> dupeAttributeData() {
 
     @Test public void handlesCdataAcrossBuffer() {
         StringBuilder sb = new StringBuilder();
-        while (sb.length() <= CharacterReader.maxBufferLen) {
+        while (sb.length() <= CharacterReader.BufferSize) {
             sb.append("A suitable amount of CData.\n");
         }
         String cdata = sb.toString();

File: src/test/java/org/jsoup/parser/TokeniserStateTest.java
Patch:
@@ -208,21 +208,21 @@ public void testPublicAndSystemIdentifiersWithWhitespace() {
     @Test
     public void testUnconsumeAtBufferBoundary() {
         String triggeringSnippet = "<a href=\"\"foo";
-        char[] padding = new char[CharacterReader.readAheadLimit - triggeringSnippet.length() + 2]; // The "foo" part must be just at the limit.
+        char[] padding = new char[CharacterReader.RefillPoint - triggeringSnippet.length() + 2]; // The "foo" part must be just at the limit.
         Arrays.fill(padding, ' ');
         String paddedSnippet = String.valueOf(padding) + triggeringSnippet;
         ParseErrorList errorList = ParseErrorList.tracking(1);
 
         Parser.parseFragment(paddedSnippet, null, "", errorList);
 
-        assertEquals(CharacterReader.readAheadLimit - 1, errorList.get(0).getPosition());
+        assertEquals(CharacterReader.RefillPoint - 1, errorList.get(0).getPosition());
     }
 
     @Test
     public void testUnconsumeAfterBufferUp() {
         // test for after consume() a bufferUp occurs (look-forward) but then attempts to unconsume. Would throw a "No buffer left to unconsume"
         String triggeringSnippet = "<title>One <span>Two";
-        char[] padding = new char[CharacterReader.readAheadLimit - triggeringSnippet.length() + 8]; // The "<span" part must be just at the limit. The "containsIgnoreCase" scan does a bufferUp, losing the unconsume
+        char[] padding = new char[CharacterReader.RefillPoint - triggeringSnippet.length() + 8]; // The "<span" part must be just at the limit. The "containsIgnoreCase" scan does a bufferUp, losing the unconsume
         Arrays.fill(padding, ' ');
         String paddedSnippet = String.valueOf(padding) + triggeringSnippet;
         ParseErrorList errorList = ParseErrorList.tracking(1);

File: src/main/java/org/jsoup/parser/TokenQueue.java
Patch:
@@ -302,7 +302,7 @@ public static String escapeCssIdentifier(String in) {
         StringBuilder out = StringUtil.borrowBuilder();
         TokenQueue q = new TokenQueue(in);
         while (!q.isEmpty()) {
-            if (q.matchesCssIdentifier(ElementSelectorChars)) {
+            if (q.matchesCssIdentifier(CssIdentifierChars)) {
                 out.append(q.consume());
             } else {
                 out.append(ESC).append(q.consume());

File: src/main/java/org/jsoup/parser/Tag.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.jsoup.helper.Validate;
 import org.jsoup.internal.Normalizer;
+import org.jsoup.internal.SharedConstants;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -296,9 +297,7 @@ protected Tag clone() {
     private static final String[] formListedTags = {
             "button", "fieldset", "input", "keygen", "object", "output", "select", "textarea"
     };
-    private static final String[] formSubmitTags = {
-            "input", "keygen", "object", "select", "textarea"
-    };
+    private static final String[] formSubmitTags = SharedConstants.FormSubmitTags;
 
     private static final Map<String, String[]> namespaces = new HashMap<>();
     static {

File: src/test/java/org/jsoup/select/SelectorTest.java
Patch:
@@ -20,7 +20,7 @@
 public class SelectorTest {
 
     /** Test that the selected elements match exactly the specified IDs. */
-    static void assertSelectedIds(Elements els, String... ids) {
+    public static void assertSelectedIds(Elements els, String... ids) {
         assertNotNull(els);
         assertEquals(ids.length, els.size(), "Incorrect number of selected elements");
         for (int i = 0; i < ids.length; i++) {

File: src/test/java/org/jsoup/helper/W3CDomTest.java
Patch:
@@ -151,7 +151,7 @@ public void handlesInvalidAttributeNames() {
 
         Document w3Doc = W3CDom.convert(jsoupDoc);
         String xml = W3CDom.asString(w3Doc, W3CDom.OutputXml());
-        assertEquals("<?xml version=\"1.0\" encoding=\"UTF-8\"?><html xmlns=\"http://www.w3.org/1999/xhtml\"><head/><body name=\"\" style=\"color: red\"/></html>", xml);
+        assertEquals("<?xml version=\"1.0\" encoding=\"UTF-8\"?><html xmlns=\"http://www.w3.org/1999/xhtml\"><head/><body _=\"\" name_=\"\" style=\"color: red\"/></html>", xml);
     }
 
     @Test
@@ -175,7 +175,7 @@ public void xmlInputDocMaintainsHtmlAttributeNames() {
 
         Document w3Doc = W3CDom.convert(jsoupDoc);
         String out = W3CDom.asString(w3Doc, W3CDom.OutputHtml());
-        String expected = "<!DOCTYPE html SYSTEM \"about:legacy-compat\"><html xmlns=\"http://www.w3.org/1999/xhtml\"><head><META http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"></head><body><p hnh=\"2\">unicode attr names coerced</p></body></html>";
+        String expected = "<!DOCTYPE html SYSTEM \"about:legacy-compat\"><html xmlns=\"http://www.w3.org/1999/xhtml\"><head><META http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"></head><body><p h_nh=\"2\">unicode attr names coerced</p></body></html>";
         assertEquals(expected, TextUtil.stripNewlines(out));
     }
 

File: src/test/java/org/jsoup/parser/HtmlParserTest.java
Patch:
@@ -85,7 +85,7 @@ private static Stream<Arguments> dupeAttributeData() {
         // NOTE: per spec this should be the test case. but impacts too many ppl
         // assertEquals("<p =a>One<a <p>Something</a></p>\n<a <p>Else</a>", doc.body().html());
 
-        assertEquals("<p a>One<a></a></p><p><a>Something</a></p><a>Else</a>", TextUtil.stripNewlines(doc.body().html()));
+        assertEquals("<p _a>One<a></a></p><p><a>Something</a></p><a>Else</a>", TextUtil.stripNewlines(doc.body().html()));
 
         doc = Jsoup.parse("<p .....>");
         assertEquals("<p .....></p>", doc.body().html());
@@ -1522,7 +1522,7 @@ private boolean didAddElements(String input) {
         assertEquals(Document.OutputSettings.Syntax.html, doc.outputSettings().syntax());
 
         String out = doc.body().outerHtml();
-        assertEquals("<body style=\"color: red\" name>\n <div></div>\n</body>", out);
+        assertEquals("<body style=\"color: red\" _ name_>\n <div _></div>\n</body>", out);
     }
 
     @Test void templateInHead() {

File: src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java
Patch:
@@ -296,7 +296,7 @@ public void handlesLTinScript() {
         assertEquals(Syntax.xml, doc.outputSettings().syntax());
 
         String out = doc.html();
-        assertEquals("<body style=\"color: red\" name=\"\"><div></div></body>", out);
+        assertEquals("<body style=\"color: red\" _=\"\" name_=\"\"><div _=\"\"></div></body>", out);
     }
 
     @Test void customTagsAreFlyweights() {

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -168,7 +168,7 @@ static void htmlNoValidate(String key, @Nullable String val, Appendable accum, D
         accum.append(key);
         if (!shouldCollapseAttribute(key, val, out)) {
             accum.append("=\"");
-            Entities.escape(accum, Attributes.checkNotNull(val) , out, true, false, false, false);
+            Entities.escape(accum, Attributes.checkNotNull(val) , out, false, true, false, false, false);
             accum.append('"');
         }
     }

File: src/main/java/org/jsoup/nodes/TextNode.java
Patch:
@@ -110,7 +110,7 @@ void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) thr
                 indent(accum, depth, out);
         }
 
-        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);
+        Entities.escape(accum, coreValue(), out, true, false, normaliseWhite, trimLeading, trimTrailing);
     }
 
     @Override

File: src/main/java/org/jsoup/nodes/XmlDeclaration.java
Patch:
@@ -60,7 +60,7 @@ private void getWholeDeclaration(Appendable accum, Document.OutputSettings out)
                 accum.append(key);
                 if (!val.isEmpty()) {
                     accum.append("=\"");
-                    Entities.escape(accum, val, out, true, false, false, false);
+                    Entities.escape(accum, val, out, false, true, false, false, false);
                     accum.append('"');
                 }
             }

File: src/test/java/org/jsoup/integration/servlets/FileServlet.java
Patch:
@@ -20,6 +20,7 @@ public class FileServlet extends BaseServlet {
     }
     public static final String ContentTypeParam = "contentType";
     public static final String DefaultType = "text/html";
+    public static final String SuppressContentLength = "surpriseMe";
 
     @Override
     protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {
@@ -33,6 +34,8 @@ protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOEx
             res.setContentType(contentType);
             if (file.getName().endsWith("gz"))
                 res.addHeader("Content-Encoding", "gzip");
+            if (req.getParameter(SuppressContentLength) == null)
+                res.setContentLength((int) file.length());
             res.setStatus(HttpServletResponse.SC_OK);
 
             ServletOutputStream out = res.getOutputStream();

File: src/main/java/org/jsoup/internal/StringUtil.java
Patch:
@@ -283,7 +283,7 @@ public static boolean isAscii(String string) {
         return true;
     }
 
-    private static final Pattern extraDotSegmentsPattern = Pattern.compile("^/((\\.{1,2}/)+)");
+    private static final Pattern extraDotSegmentsPattern = Pattern.compile("^/(?>(?>\\.\\.?/)+)");
     /**
      * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.
      * @param base the existing absolute base URL

File: src/main/java/org/jsoup/parser/TokenQueue.java
Patch:
@@ -344,7 +344,7 @@ public String consumeWord() {
     public String consumeElementSelector() {
         return consumeEscapedCssIdentifier(ElementSelectorChars);
     }
-    private static final String[] ElementSelectorChars = {"*|", "|", "_", "-"};
+    private static final String[] ElementSelectorChars = {"*", "|", "_", "-"};
 
     /**
      Consume a CSS identifier (ID or class) off the queue (letter, digit, -, _)

File: src/main/java/org/jsoup/select/QueryParser.java
Patch:
@@ -272,11 +272,13 @@ private Evaluator byTag() {
                 new Evaluator.Tag(plainTag),
                 new Evaluator.TagEndsWith(tagName.replace("*|", ":"))
             );
+        } else if (tagName.endsWith("|*")){ // ns|*
+            String ns = tagName.substring(0, tagName.length() -2 ) + ":"; // strip |*, to ns:
+            eval = new Evaluator.TagStartsWith(ns);
         } else {
             // namespaces: if element name is "abc:def", selector must be "abc|def", so flip:
             if (tagName.contains("|"))
                 tagName = tagName.replace("|", ":");
-
             eval = new Evaluator.Tag(tagName);
         }
         return eval;

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -24,8 +24,9 @@
  * <tr><th align="left">Pattern</th><th align="left">Matches</th><th align="left">Example</th></tr>
  * <tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>
  * <tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>
- * <tr><td><code>*|E</code></td><td>elements of type E in any namespace (including non-namespaced)</td><td><code>*|name</code> finds <code>&lt;fb:name&gt;</code> and <code>&lt;name&gt;</code> elements</td></tr>
- * <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name&gt;</code> elements</td></tr>
+ * <tr><td><code>*|E</code></td><td>elements of type E in any namespace (including non-namespaced)</td><td><code>*|name</code> finds <code>&lt;dc:name&gt;</code> and <code>&lt;name&gt;</code> elements</td></tr>
+ * <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>dc|name</code> finds <code>&lt;dc:name&gt;</code> elements</td></tr>
+ * <tr><td><code>ns|*</code></td><td>all elements in the namespace <i>ns</i></td><td><code>dc|*</code> finds <code>&lt;dc:p&gt;</code> and <code>&lt;dc:img&gt;</code>elements</td></tr>
  * <tr><td><code>#id</code></td><td>elements with attribute ID of "id"</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>
  * <tr><td><code>.class</code></td><td>elements with a class name of "class"</td><td><code>div.left</code>, <code>.result</code></td></tr>
  * <tr><td><code>[attr]</code></td><td>elements with an attribute named "attr" (with any value)</td><td><code>a[href]</code>, <code>[title]</code></td></tr>

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -74,7 +74,7 @@
  * <tr><td><code>:last-of-type</code></td><td>elements that are the last sibling of its type in the list of children of its parent element</td><td><code>tr {@literal >} td:last-of-type</code></td></tr>
  * <tr><td><code>:only-child</code></td><td>elements that have a parent element and whose parent element have no other element children</td><td></td></tr>
  * <tr><td><code>:only-of-type</code></td><td> an element that has a parent element and whose parent element has no other element children with the same expanded element name</td><td></td></tr>
- * <tr><td><code>:empty</code></td><td>elements that have no children at all</td><td></td></tr>
+ * <tr><td><code>:empty</code></td><td>elements that contain no child elements or nodes, with the exception of blank text nodes, comments, XML declarations, and doctype declarations. In other words, it matches elements that are effectively empty of meaningful content.</td><td><code>li:not(:empty)</code></td></tr>
  * </table>
  *
  * <p>A word on using regular expressions in these selectors: depending on the content of the regex, you will need to quote the pattern using <b><code>Pattern.quote("regex")</code></b> for it to parse correctly through both the selector parser and the regex parser. E.g. <code>String query = "div:matches(" + Pattern.quote(regex) + ");"</code>.</p>

File: src/test/java/org/jsoup/helper/HttpConnectionTest.java
Patch:
@@ -280,8 +280,8 @@ public void caseInsensitiveHeaders(Locale locale) {
         URL url1 = new URL("https://test.com/[foo] bar+/%5BOne%5D?q=white space#frag ment");
         URL url2 = new UrlBuilder(url1).build();
         URL url3 = new UrlBuilder(url2).build();
-        assertEquals("https://test.com/[foo]%20bar+/%5BOne%5D?q=white+space#frag%20ment", url2.toExternalForm());
-        assertEquals("https://test.com/[foo]%20bar+/%5BOne%5D?q=white+space#frag%20ment", url3.toExternalForm());
+        assertEquals("https://test.com/%5Bfoo%5D%20bar+/%5BOne%5D?q=white+space#frag%20ment", url2.toExternalForm());
+        assertEquals("https://test.com/%5Bfoo%5D%20bar+/%5BOne%5D?q=white+space#frag%20ment", url3.toExternalForm());
     }
 
     @Test void connectToEncodedUrl() {

File: src/main/java/org/jsoup/parser/Tokeniser.java
Patch:
@@ -50,7 +50,7 @@ final class Tokeniser {
     @Nullable private String lastStartCloseSeq; // "</" + lastStartTag, so we can quickly check for that in RCData
 
     private static final int Unset = -1;
-    private int markupStartPos, charStartPos = Unset; // reader pos at the start of markup / characters. updated on state transition
+    private int markupStartPos, charStartPos = 0; // reader pos at the start of markup / characters. updated on state transition. Initialized to start (0), but set to Unset after emissions.
 
     Tokeniser(TreeBuilder treeBuilder) {
         tagPending = startPending  = new Token.StartTag(treeBuilder);

File: src/main/java/org/jsoup/parser/Tag.java
Patch:
@@ -271,7 +271,7 @@ protected Tag clone() {
     private static final String[] inlineTags = {
             "object", "base", "font", "tt", "i", "b", "u", "big", "small", "em", "strong", "dfn", "code", "samp", "kbd",
             "var", "cite", "abbr", "time", "acronym", "mark", "ruby", "rt", "rp", "rtc", "a", "img", "br", "wbr", "map", "q",
-            "sub", "sup", "bdo", "iframe", "embed", "span", "input", "select", "textarea", "label", "button", "optgroup",
+            "sub", "sup", "bdo", "iframe", "embed", "span", "input", "select", "textarea", "label", "optgroup",
             "option", "legend", "datalist", "keygen", "output", "progress", "meter", "area", "param", "source", "track",
             "summary", "command", "device", "area", "basefont", "bgsound", "menuitem", "param", "source", "track",
             "data", "bdi", "s", "strike", "nobr",
@@ -286,7 +286,7 @@ protected Tag clone() {
     // todo - rework this to format contents as inline; and update html emitter in Element. Same output, just neater.
     private static final String[] formatAsInlineTags = {
             "title", "a", "p", "h1", "h2", "h3", "h4", "h5", "h6", "pre", "address", "li", "th", "td", "script", "style",
-            "ins", "del", "s"
+            "ins", "del", "s", "button"
     };
     private static final String[] preserveWhitespaceTags = {
             "pre", "plaintext", "title", "textarea"

File: src/test/java/org/jsoup/select/SelectorTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import org.jsoup.Jsoup;
 import org.jsoup.MultiLocaleExtension.MultiLocaleTest;
-import org.jsoup.TextUtil;
 import org.jsoup.nodes.Document;
 import org.jsoup.nodes.Element;
 import org.jsoup.parser.Parser;

File: src/main/java/org/jsoup/select/QueryParser.java
Patch:
@@ -292,6 +292,8 @@ private Evaluator byAttribute() {
         if (cq.isEmpty()) {
             if (key.startsWith("^"))
                 eval = new Evaluator.AttributeStarting(key.substring(1));
+            else if (key.equals("*")) // any attribute
+                eval = new Evaluator.AttributeStarting("");
             else
                 eval = new Evaluator.Attribute(key);
         } else {

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -36,6 +36,7 @@
  * <tr><td><code>[attr$=valSuffix]</code></td><td>elements with an attribute named "attr", and value ending with "valSuffix"</td><td><code>img[src$=.png]</code></td></tr>
  * <tr><td><code>[attr*=valContaining]</code></td><td>elements with an attribute named "attr", and value containing "valContaining"</td><td><code>a[href*=/search/]</code></td></tr>
  * <tr><td><code>[attr~=<em>regex</em>]</code></td><td>elements with an attribute named "attr", and value matching the regular expression</td><td><code>img[src~=(?i)\\.(png|jpe?g)]</code></td></tr>
+ * <tr><td><code>[*]</code></td><td>elements with any attribute</td><td><code>p[*]</code> finds <code>p</code> elements that have at least one attribute; <code>p:not([*])</code> finds those with no attributes</td></tr>
  * <tr><td></td><td>The above may be combined in any order</td><td><code>div.header[title]</code></td></tr>
  * <tr><td colspan="3"><h3>Combinators</h3></td></tr>
  * <tr><td><code>E F</code></td><td>an F element descended from an E element</td><td><code>div a</code>, <code>.logo h1</code></td></tr>

File: src/main/java/org/jsoup/select/Evaluator.java
Patch:
@@ -191,7 +191,7 @@ public static final class AttributeStarting extends Evaluator {
         private final String keyPrefix;
 
         public AttributeStarting(String keyPrefix) {
-            Validate.notEmpty(keyPrefix);
+            Validate.notNull(keyPrefix); // OK to be empty - will find elements with any attributes
             this.keyPrefix = lowerCase(keyPrefix);
         }
 

File: src/main/java/org/jsoup/parser/TreeBuilder.java
Patch:
@@ -26,7 +26,7 @@ abstract class TreeBuilder {
     Document doc; // current doc we are building into
     ArrayList<Element> stack; // the stack of open elements
     String baseUri; // current base uri, for creating new elements
-    Token currentToken; // currentToken is used only for error tracking.
+    Token currentToken; // currentToken is used for error and source position tracking. Null at start of fragment parse
     ParseSettings settings;
     Map<String, Tag> seenTags; // tags we've used in this parse; saves tag GC for custom tags.
 
@@ -48,11 +48,11 @@ void initialiseParse(Reader input, String baseUri, Parser parser) {
         reader = new CharacterReader(input);
         trackSourceRange = parser.isTrackPosition();
         reader.trackNewlines(parser.isTrackErrors() || trackSourceRange); // when tracking errors or source ranges, enable newline tracking for better legibility
-        currentToken = null;
         tokeniser = new Tokeniser(this);
         stack = new ArrayList<>(32);
         seenTags = new HashMap<>();
         start = new Token.StartTag(this);
+        currentToken = start; // init current token to the virtual start token.
         this.baseUri = baseUri;
     }
 

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -88,7 +88,7 @@ protected void initialiseParse(Reader input, String baseUri, Parser parser) {
         formattingElements = new ArrayList<>();
         tmplInsertMode = new ArrayList<>();
         pendingTableCharacters = new ArrayList<>();
-        emptyEnd = new Token.EndTag();
+        emptyEnd = new Token.EndTag(this);
         framesetOk = true;
         fosterInserts = false;
         fragmentParsing = false;

File: src/main/java/org/jsoup/parser/Parser.java
Patch:
@@ -245,7 +245,9 @@ public static Document parseBodyFragment(String bodyHtml, String baseUri) {
      * @return an unescaped string
      */
     public static String unescapeEntities(String string, boolean inAttribute) {
-        Tokeniser tokeniser = new Tokeniser(new CharacterReader(string), ParseErrorList.noTracking(), false);
+        Parser parser = Parser.htmlParser();
+        parser.treeBuilder.initialiseParse(new StringReader(string), "", parser);
+        Tokeniser tokeniser = new Tokeniser(parser.treeBuilder);
         return tokeniser.unescapeEntities(inAttribute);
     }
 

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -798,9 +798,9 @@ public static class Response extends HttpConnection.Base<Connection.Response> im
         private final HttpConnection.Request req;
 
         /*
-         * Matches XML content types (like text/xml, application/xhtml+xml;charset=UTF8, etc)
+         * Matches XML content types (like text/xml, image/svg+xml, application/xhtml+xml;charset=UTF8, etc)
          */
-        private static final Pattern xmlContentTypeRxp = Pattern.compile("(application|text)/\\w*\\+?xml.*");
+        private static final Pattern xmlContentTypeRxp = Pattern.compile("(\\w+)/\\w*\\+?xml.*");
 
         /**
          <b>Internal only! </b>Creates a dummy HttpConnection.Response, useful for testing. All actual responses
@@ -885,7 +885,7 @@ else if (methodHasBody)
                         && !contentType.startsWith("text/")
                         && !xmlContentTypeRxp.matcher(contentType).matches()
                         )
-                    throw new UnsupportedMimeTypeException("Unhandled content type. Must be text/*, application/xml, or application/*+xml",
+                    throw new UnsupportedMimeTypeException("Unhandled content type. Must be text/*, */xml, or */*+xml",
                             contentType, req.url().toString());
 
                 // switch to the XML parser if content type is xml and not parser not explicitly set

File: src/main/java/org/jsoup/nodes/Attributes.java
Patch:
@@ -348,7 +348,7 @@ public Range.AttributeRange sourceRange(String key) {
 
     @Override
     public Iterator<Attribute> iterator() {
-        return new Iterator<>() {
+        return new Iterator<Attribute>() {
             int expectedSize = size;
             int i = 0;
 

File: src/main/java/org/jsoup/safety/Safelist.java
Patch:
@@ -632,7 +632,7 @@ static class AttributeKey extends TypedValue {
         }
 
         static AttributeKey valueOf(String value) {
-            return new AttributeKey(value);
+            return new AttributeKey(Normalizer.lowerCase(value));
         }
     }
 

File: src/main/java/org/jsoup/safety/Cleaner.java
Patch:
@@ -155,7 +155,7 @@ public void head(Node source, int depth) {
                 TextNode sourceText = (TextNode) source;
                 TextNode destText = new TextNode(sourceText.getWholeText());
                 destination.appendChild(destText);
-            } else if (source instanceof DataNode && safelist.isSafeTag(source.parent().nodeName())) {
+            } else if (source instanceof DataNode && safelist.isSafeTag(source.parent().normalName())) {
               DataNode sourceData = (DataNode) source;
               DataNode destData = new DataNode(sourceData.getWholeData());
               destination.appendChild(destData);
@@ -165,7 +165,7 @@ public void head(Node source, int depth) {
         }
 
         public void tail(Node source, int depth) {
-            if (source instanceof Element && safelist.isSafeTag(source.nodeName())) {
+            if (source instanceof Element && safelist.isSafeTag(source.normalName())) {
                 destination = destination.parent(); // would have descended, so pop destination stack
             }
         }
@@ -180,7 +180,7 @@ private int copySafeNodes(Element source, Element dest) {
     private ElementMeta createSafeElement(Element sourceEl) {
         String sourceTag = sourceEl.tagName();
         Attributes destAttrs = new Attributes();
-        Element dest = new Element(Tag.valueOf(sourceTag, sourceEl.tag().namespace(), ParseSettings.preserveCase), sourceEl.baseUri(), destAttrs);
+        Element dest = new Element(sourceEl.tag(), sourceEl.baseUri(), destAttrs);
         int numDiscarded = 0;
 
         Attributes sourceAttrs = sourceEl.attributes();

File: src/main/java/org/jsoup/safety/Safelist.java
Patch:
@@ -6,6 +6,7 @@ Thank you to Ryan Grove (wonko.com) for the Ruby HTML cleaner http://github.com/
  */
 
 import org.jsoup.helper.Validate;
+import org.jsoup.internal.Normalizer;
 import org.jsoup.nodes.Attribute;
 import org.jsoup.nodes.Attributes;
 import org.jsoup.nodes.Element;
@@ -296,8 +297,8 @@ public Safelist addAttributes(String tag, String... attributes) {
         Validate.notNull(attributes);
         Validate.isTrue(attributes.length > 0, "No attribute names supplied.");
 
+        addTags(tag);
         TagName tagName = TagName.valueOf(tag);
-        tagNames.add(tagName);
         Set<AttributeKey> attributeSet = new HashSet<>();
         for (String key : attributes) {
             Validate.notEmpty(key);
@@ -621,7 +622,7 @@ static class TagName extends TypedValue {
         }
 
         static TagName valueOf(String value) {
-            return new TagName(value);
+            return new TagName(Normalizer.lowerCase(value));
         }
     }
 

File: src/main/java/org/jsoup/internal/SharedConstants.java
Patch:
@@ -12,5 +12,7 @@ public final class SharedConstants {
 
     public static final String  AttrRange     = PrivatePrefix + "attrRange.";
 
+    public static final int DefaultBufferSize = 1024 * 32;
+
     private SharedConstants() {}
 }

File: src/main/java/org/jsoup/safety/Safelist.java
Patch:
@@ -52,9 +52,8 @@ If you need to allow more through (please be careful!), tweak a base safelist wi
 
  <p>
  The cleaner and these safelists assume that you want to clean a <code>body</code> fragment of HTML (to add user
- supplied HTML into a templated page), and not to clean a full HTML document. If the latter is the case, either wrap the
- document HTML around the cleaned body HTML, or create a safelist that allows <code>html</code> and <code>head</code>
- elements as appropriate.
+ supplied HTML into a templated page), and not to clean a full HTML document. If the latter is the case, you could wrap
+ the templated document HTML around the cleaned body HTML.
  </p>
  <p>
  If you are going to extend a safelist, please be very careful. Make sure you understand what attributes may lead to

File: src/main/java/org/jsoup/parser/CharacterReader.java
Patch:
@@ -451,11 +451,12 @@ String consumeAttributeQuoted(final boolean single) {
                     break OUTER;
                 case '\'':
                     if (single) break OUTER;
+                    break;
                 case '"':
                     if (!single) break OUTER;
-                default:
-                    pos++;
+                    break;
             }
+            pos++;
         }
         bufPos = pos;
         return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : "";

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -66,7 +66,7 @@ public boolean hasParent() {
     /**
      * Get an attribute's value by its key. <b>Case insensitive</b>
      * <p>
-     * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs</b></code>,
+     * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs:</b></code>,
      * which is a shortcut to the {@link #absUrl} method.
      * </p>
      * E.g.:

File: src/main/java/org/jsoup/Connection.java
Patch:
@@ -3,8 +3,8 @@
 import org.jsoup.helper.RequestAuthenticator;
 import org.jsoup.nodes.Document;
 import org.jsoup.parser.Parser;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import javax.net.ssl.SSLSocketFactory;
 import java.io.BufferedInputStream;
 import java.io.IOException;

File: src/main/java/org/jsoup/helper/AuthenticationHandler.java
Patch:
@@ -1,6 +1,7 @@
 package org.jsoup.helper;
 
-import javax.annotation.Nullable;
+import org.jspecify.annotations.Nullable;
+
 import java.lang.reflect.Constructor;
 import java.net.Authenticator;
 import java.net.HttpURLConnection;

File: src/main/java/org/jsoup/helper/RequestAuthenticator.java
Patch:
@@ -1,8 +1,8 @@
 package org.jsoup.helper;
 
 import org.jsoup.Connection;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.net.Authenticator;
 import java.net.PasswordAuthentication;
 import java.net.URL;

File: src/main/java/org/jsoup/helper/UrlBuilder.java
Patch:
@@ -2,8 +2,8 @@
 
 import org.jsoup.Connection;
 import org.jsoup.internal.StringUtil;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.io.UnsupportedEncodingException;
 import java.net.IDN;
 import java.net.MalformedURLException;

File: src/main/java/org/jsoup/helper/Validate.java
Patch:
@@ -1,6 +1,6 @@
 package org.jsoup.helper;
 
-import javax.annotation.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Validators to check that method arguments meet expectations. 

File: src/main/java/org/jsoup/helper/W3CDom.java
Patch:
@@ -17,8 +17,8 @@
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 import org.w3c.dom.Text;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
@@ -353,7 +353,7 @@ protected static class W3CBuilder implements NodeVisitor {
         private final Stack<HashMap<String, String>> namespacesStack = new Stack<>(); // stack of namespaces, prefix => urn
         private Node dest;
         private Syntax syntax = Syntax.xml; // the syntax (to coerce attributes to). From the input doc if available.
-        @Nullable private final org.jsoup.nodes.Element contextElement;
+        /*@Nullable*/ private final org.jsoup.nodes.Element contextElement; // todo - unsure why this can't be marked nullable?
 
         public W3CBuilder(Document doc) {
             this.doc = doc;

File: src/main/java/org/jsoup/helper/package-info.java
Patch:
@@ -1,7 +1,7 @@
 /**
  Package containing classes supporting the core jsoup code.
  */
-@NonnullByDefault
+@NullMarked
 package org.jsoup.helper;
 
-import org.jsoup.internal.NonnullByDefault;
+import org.jspecify.annotations.NullMarked;

File: src/main/java/org/jsoup/internal/StringUtil.java
Patch:
@@ -1,8 +1,8 @@
 package org.jsoup.internal;
 
 import org.jsoup.helper.Validate;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.Arrays;

File: src/main/java/org/jsoup/internal/package-info.java
Patch:
@@ -2,4 +2,7 @@
  * Util methods used by Jsoup. Please don't depend on the APIs implemented here as the contents may change without
  * notice.
  */
+@NullMarked
 package org.jsoup.internal;
+
+import org.jspecify.annotations.NullMarked;

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -5,8 +5,8 @@
 import org.jsoup.internal.Normalizer;
 import org.jsoup.internal.StringUtil;
 import org.jsoup.nodes.Document.OutputSettings.Syntax;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Map;

File: src/main/java/org/jsoup/nodes/Attributes.java
Patch:
@@ -4,8 +4,8 @@
 import org.jsoup.helper.Validate;
 import org.jsoup.internal.StringUtil;
 import org.jsoup.parser.ParseSettings;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.io.IOException;
 import java.util.AbstractMap;
 import java.util.AbstractSet;

File: src/main/java/org/jsoup/nodes/Comment.java
Patch:
@@ -2,8 +2,8 @@
 
 import org.jsoup.parser.ParseSettings;
 import org.jsoup.parser.Parser;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.io.IOException;
 
 /**

File: src/main/java/org/jsoup/nodes/Document.java
Patch:
@@ -11,8 +11,8 @@
 import org.jsoup.select.Elements;
 import org.jsoup.select.Evaluator;
 import org.jsoup.select.Selector;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
 import java.util.List;

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -15,8 +15,8 @@
 import org.jsoup.select.NodeVisitor;
 import org.jsoup.select.QueryParser;
 import org.jsoup.select.Selector;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.io.IOException;
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;

File: src/main/java/org/jsoup/nodes/Entities.java
Patch:
@@ -6,8 +6,8 @@
 import org.jsoup.nodes.Document.OutputSettings;
 import org.jsoup.parser.CharacterReader;
 import org.jsoup.parser.Parser;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.io.IOException;
 import java.nio.charset.CharsetEncoder;
 import java.util.Arrays;

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -6,8 +6,8 @@
 import org.jsoup.select.NodeFilter;
 import org.jsoup.select.NodeTraversor;
 import org.jsoup.select.NodeVisitor;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;

File: src/main/java/org/jsoup/nodes/package-info.java
Patch:
@@ -1,7 +1,7 @@
 /**
  HTML document structure nodes.
  */
-@NonnullByDefault
+@NullMarked
 package org.jsoup.nodes;
 
-import org.jsoup.internal.NonnullByDefault;
+import org.jspecify.annotations.NullMarked;

File: src/main/java/org/jsoup/package-info.java
Patch:
@@ -1,7 +1,7 @@
 /**
  Contains the main {@link org.jsoup.Jsoup} class, which provides convenient static access to the jsoup functionality.
  */
-@NonnullByDefault
+@NullMarked
 package org.jsoup;
 
-import org.jsoup.internal.NonnullByDefault;
+import org.jspecify.annotations.NullMarked;

File: src/main/java/org/jsoup/parser/CharacterReader.java
Patch:
@@ -2,8 +2,8 @@
 
 import org.jsoup.UncheckedIOException;
 import org.jsoup.helper.Validate;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.io.IOException;
 import java.io.Reader;
 import java.io.StringReader;

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -12,9 +12,8 @@
 import org.jsoup.nodes.Node;
 import org.jsoup.nodes.TextNode;
 import org.jsoup.parser.Token.StartTag;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
-import javax.annotation.ParametersAreNonnullByDefault;
 import java.io.Reader;
 import java.io.StringReader;
 import java.util.ArrayList;
@@ -75,7 +74,7 @@ HtmlTreeBuilder newInstance() {
         return new HtmlTreeBuilder();
     }
 
-    @Override @ParametersAreNonnullByDefault
+    @Override
     protected void initialiseParse(Reader input, String baseUri, Parser parser) {
         super.initialiseParse(input, baseUri, parser);
 

File: src/main/java/org/jsoup/parser/ParseSettings.java
Patch:
@@ -1,7 +1,8 @@
 package org.jsoup.parser;
 
 import org.jsoup.nodes.Attributes;
-import javax.annotation.Nullable;
+import org.jspecify.annotations.Nullable;
+
 import static org.jsoup.internal.Normalizer.lowerCase;
 
 /**

File: src/main/java/org/jsoup/parser/Token.java
Patch:
@@ -2,8 +2,8 @@
 
 import org.jsoup.helper.Validate;
 import org.jsoup.nodes.Attributes;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 
 /**
  * Parse tokens for the Tokeniser.

File: src/main/java/org/jsoup/parser/Tokeniser.java
Patch:
@@ -3,8 +3,8 @@
 import org.jsoup.helper.Validate;
 import org.jsoup.internal.StringUtil;
 import org.jsoup.nodes.Entities;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.util.Arrays;
 
 /**

File: src/main/java/org/jsoup/parser/XmlTreeBuilder.java
Patch:
@@ -10,8 +10,8 @@
 import org.jsoup.nodes.Node;
 import org.jsoup.nodes.TextNode;
 import org.jsoup.nodes.XmlDeclaration;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.ParametersAreNonnullByDefault;
 import java.io.Reader;
 import java.io.StringReader;
 import java.util.List;
@@ -30,7 +30,7 @@ ParseSettings defaultSettings() {
         return ParseSettings.preserveCase;
     }
 
-    @Override @ParametersAreNonnullByDefault
+    @Override
     protected void initialiseParse(Reader input, String baseUri, Parser parser) {
         super.initialiseParse(input, baseUri, parser);
         stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)

File: src/main/java/org/jsoup/parser/package-info.java
Patch:
@@ -1,7 +1,7 @@
 /**
  Contains the HTML parser, tag specifications, and HTML tokeniser.
  */
-@NonnullByDefault
+@NullMarked
 package org.jsoup.parser;
 
-import org.jsoup.internal.NonnullByDefault;
+import org.jspecify.annotations.NullMarked;

File: src/main/java/org/jsoup/safety/package-info.java
Patch:
@@ -1,4 +1,7 @@
 /**
  Contains the jsoup HTML cleaner, and safelist definitions.
  */
+@NullMarked
 package org.jsoup.safety;
+
+import org.jspecify.annotations.NullMarked;
\ No newline at end of file

File: src/main/java/org/jsoup/select/Collector.java
Patch:
@@ -2,8 +2,7 @@
 
 import org.jsoup.nodes.Element;
 import org.jsoup.nodes.Node;
-
-import javax.annotation.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import static org.jsoup.select.NodeFilter.FilterResult.CONTINUE;
 import static org.jsoup.select.NodeFilter.FilterResult.STOP;

File: src/main/java/org/jsoup/select/CombiningEvaluator.java
Patch:
@@ -2,8 +2,8 @@
 
 import org.jsoup.internal.StringUtil;
 import org.jsoup.nodes.Element;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;

File: src/main/java/org/jsoup/select/Elements.java
Patch:
@@ -8,8 +8,8 @@
 import org.jsoup.nodes.FormElement;
 import org.jsoup.nodes.Node;
 import org.jsoup.nodes.TextNode;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -2,8 +2,8 @@
 
 import org.jsoup.helper.Validate;
 import org.jsoup.nodes.Element;
+import org.jspecify.annotations.Nullable;
 
-import javax.annotation.Nullable;
 import java.util.Collection;
 import java.util.IdentityHashMap;
 

File: src/main/java/org/jsoup/select/package-info.java
Patch:
@@ -2,7 +2,7 @@
  Packages to support the CSS-style element selector.
  {@link org.jsoup.select.Selector Selector defines the query syntax.}
  */
-@NonnullByDefault
+@NullMarked
 package org.jsoup.select;
 
-import org.jsoup.internal.NonnullByDefault;
+import org.jspecify.annotations.NullMarked;

File: src/main/java9/module-info.java
Patch:
@@ -7,5 +7,5 @@
     exports org.jsoup.select;
 
     requires transitive java.xml; // for org.w3c.dom out of W3CDom
-    requires static jsr305; // TODO[must] migrate to another nullable package prior to next release
+    requires static org.jspecify; // TODO[must] migrate to another nullable package prior to next release
 }

File: src/test/java/org/jsoup/helper/HttpConnectionTest.java
Patch:
@@ -6,7 +6,6 @@
 import org.jsoup.integration.ParseTest;
 import org.junit.jupiter.api.Test;
 
-import javax.annotation.Nullable;
 import java.io.IOException;
 import java.net.Authenticator;
 import java.net.MalformedURLException;

File: src/test/java/org/jsoup/select/QueryParserTest.java
Patch:
@@ -18,10 +18,10 @@ public class QueryParserTest {
                 "<a><li><strong>l2</strong></li></a>" +
                 "<p><strong>yes</strong></p>" +
                 "</body></html>");
-        assertEquals("l1 l2 yes", doc.body().select(">p>strong,>*>li>strong").text());
+        assertEquals("l1 yes", doc.body().select(">p>strong,>li>strong").text()); // selecting immediate from body
+        assertEquals("l2 yes", doc.select("body>p>strong,body>*>li>strong").text());
+        assertEquals("l2 yes", doc.select("body>*>li>strong,body>p>strong").text());
         assertEquals("l2 yes", doc.select("body>p>strong,body>*>li>strong").text());
-        assertEquals("yes", doc.select(">body>*>li>strong,>body>p>strong").text());
-        assertEquals("l2", doc.select(">body>p>strong,>body>*>li>strong").text());
     }
 
     @Test public void testImmediateParentRun() {

File: src/main/java/org/jsoup/select/StructuralEvaluator.java
Patch:
@@ -189,7 +189,9 @@ void add(Evaluator evaluator) {
 
         @Override
         public boolean matches(Element root, Element element) {
-            // evaluate from last to first
+            if (element == root)
+                return false; // cannot match as the second eval (first parent test) would be above the root
+
             for (int i = evaluators.size() -1; i >= 0; --i) {
                 if (element == null)
                     return false;

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -1775,9 +1775,9 @@ else if (HtmlTreeBuilderState.isWhitespace(c))
                     if (StringUtil.in(start.normalName, InForeignToHtml))
                         return processAsHtml(t, tb);
                     if (start.normalName.equals("font") && (
-                        start.attributes.hasKeyIgnoreCase("color")
-                            || start.attributes.hasKeyIgnoreCase("face")
-                            || start.attributes.hasKeyIgnoreCase("size")))
+                        start.hasAttributeIgnoreCase("color")
+                            || start.hasAttributeIgnoreCase("face")
+                            || start.hasAttributeIgnoreCase("size")))
                         return processAsHtml(t, tb);
 
                     // Any other start:

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -166,7 +166,7 @@ boolean process(Token t, HtmlTreeBuilder tb) {
                             tb.error(this);
                         } else {
                             tb.generateImpliedEndTags(true);
-                            if (!name.equals(tb.currentElement().normalName())) tb.error(this);
+                            if (!tb.currentElementIs(name)) tb.error(this);
                             tb.popStackToClose(name);
                             tb.clearFormattingElementsToLastMarker();
                             tb.popTemplateMode();
@@ -1796,7 +1796,7 @@ else if (HtmlTreeBuilderState.isWhitespace(c))
                         tb.error(this);
                     while (i != 0) {
                         if (el.normalName().equals(end.normalName)) {
-                            tb.popStackToClose(el.normalName());
+                            tb.popStackToCloseAnyNamespace(el.normalName());
                             return true;
                         }
                         i--;

File: src/main/java/org/jsoup/nodes/FormElement.java
Patch:
@@ -91,7 +91,7 @@ public List<Connection.KeyVal> formData() {
             if (name.length() == 0) continue;
             String type = el.attr("type");
 
-            if (type.equalsIgnoreCase("button")) continue; // browsers don't submit these
+            if (type.equalsIgnoreCase("button") || type.equalsIgnoreCase("image")) continue; // browsers don't submit these
 
             if ("select".equals(el.normalName())) {
                 Elements options = el.select("option[selected]");

File: src/test/java/org/jsoup/nodes/FormElementTest.java
Patch:
@@ -43,6 +43,7 @@ public static void setUp() {
                 "<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>" +
                 "<input name='ten' value='text' disabled>" +
                 "<input name='eleven' value='text' type='button'>" +
+                "<input name='twelve' value='text' type='image'>" +
                 "</form>";
         Document doc = Jsoup.parse(html);
         FormElement form = (FormElement) doc.select("form").first();

File: src/main/java/org/jsoup/Connection.java
Patch:
@@ -43,7 +43,7 @@ public interface Connection {
      * GET and POST http methods.
      */
     enum Method {
-        GET(false), POST(true), PUT(true), DELETE(false), PATCH(true), HEAD(false), OPTIONS(false), TRACE(false);
+        GET(false), POST(true), PUT(true), DELETE(true), PATCH(true), HEAD(false), OPTIONS(false), TRACE(false);
 
         private final boolean hasBody;
 

File: src/main/java/org/jsoup/internal/ConstrainableInputStream.java
Patch:
@@ -49,8 +49,8 @@ public static ConstrainableInputStream wrap(InputStream in, int bufferSize, int
     public int read(byte[] b, int off, int len) throws IOException {
         if (interrupted || capped && remaining <= 0)
             return -1;
-        if (Thread.interrupted()) {
-            // interrupted latches, because parse() may call twice (and we still want the thread interupt to clear)
+        if (Thread.currentThread().isInterrupted()) {
+            // interrupted latches, because parse() may call twice
             interrupted = true;
             return -1;
         }

File: src/main/java/org/jsoup/nodes/Comment.java
Patch:
@@ -88,7 +88,7 @@ private static boolean isXmlDeclarationData(String data) {
         String fragment = "<" + declContent + ">";
         // use the HTML parser not XML, so we don't get into a recursive XML Declaration on contrived data
         Document doc = Parser.htmlParser().settings(ParseSettings.preserveCase).parseInput(fragment, baseUri());
-        if (doc.body().children().size() > 0) {
+        if (doc.body().childrenSize() > 0) {
             Element el = doc.body().child(0);
             decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith("!"));
             decl.attributes().addAll(el.attributes());

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -1844,7 +1844,7 @@ public void onContentsChanged() {
     }
 
     private boolean isFormatAsBlock(Document.OutputSettings out) {
-        return tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline();
+        return tag.isBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline();
     }
 
     private boolean isInlineable(Document.OutputSettings out) {

File: src/test/java/org/jsoup/parser/HtmlParserTest.java
Patch:
@@ -1729,8 +1729,7 @@ private boolean didAddElements(String input) {
         // https://github.com/jhy/jsoup/issues/1851
         String html = "<body><div>One</html>Two</div></body>";
         Document doc = Jsoup.parse(html);
-        //assertEquals("OneTwo", doc.expectFirst("body > div").text());
-        System.out.println(doc.html());
+        assertEquals("OneTwo", doc.expectFirst("body > div").text());
     }
 
     @Test void largeTextareaContents() {

File: src/main/java/org/jsoup/parser/TokeniserState.java
Patch:
@@ -186,7 +186,7 @@ void read(Tokeniser t, CharacterReader r) {
             if (r.matches('/')) {
                 t.createTempBuffer();
                 t.advanceTransition(RCDATAEndTagOpen);
-            } else if (r.matchesAsciiAlpha() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(t.appropriateEndTagSeq())) {
+            } else if (r.readFully() && r.matchesAsciiAlpha() && t.appropriateEndTagName() != null &&  !r.containsIgnoreCase(t.appropriateEndTagSeq())) {
                 // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than
                 // consuming to EOF; break out here
                 t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());

File: src/main/java/org/jsoup/parser/Tag.java
Patch:
@@ -246,7 +246,8 @@ protected Tag clone() {
             "sub", "sup", "bdo", "iframe", "embed", "span", "input", "select", "textarea", "label", "button", "optgroup",
             "option", "legend", "datalist", "keygen", "output", "progress", "meter", "area", "param", "source", "track",
             "summary", "command", "device", "area", "basefont", "bgsound", "menuitem", "param", "source", "track",
-            "data", "bdi", "s", "strike", "nobr"
+            "data", "bdi", "s", "strike", "nobr",
+            "rb" // deprecated but still known / special handling
     };
     private static final String[] emptyTags = {
             "meta", "link", "base", "frame", "img", "br", "wbr", "embed", "hr", "input", "keygen", "col", "command",

File: src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java
Patch:
@@ -45,7 +45,7 @@ static void ensureSorted(List<Object[]> constants) {
     public void ensureArraysAreSorted() {
         List<Object[]> constants = findConstantArrays(Constants.class);
         ensureSorted(constants);
-        assertEquals(38, constants.size());
+        assertEquals(39, constants.size());
     }
 
     @Test public void ensureTagSearchesAreKnownTags() {

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -91,7 +91,7 @@ public static Connection connect(URL url) {
     }
 
     /**
-     Creates a new, empty HttpConnection.
+     Create a new, empty HttpConnection.
      */
     public HttpConnection() {
         req = new Request();

File: src/test/java/org/jsoup/integration/ConnectTest.java
Patch:
@@ -751,10 +751,10 @@ public void maxBodySizeInReadToByteBuffer() throws IOException {
     }
 
     @Test void fetchUnicodeUrl() throws IOException {
-        String url = EchoServlet.Url + "//?=";
+        String url = EchoServlet.Url + "//?%E9%8D%B5=%E5%80%A4"; // encoded =
         Document doc = Jsoup.connect(url).get();
 
         assertEquals("//", ihVal("Path Info", doc));
-        assertEquals("=", ihVal("Query String", doc));
+        assertEquals("%E9%8D%B5=%E5%80%A4", ihVal("Query String", doc));
     }
 }

File: src/test/java/org/jsoup/integration/servlets/EchoServlet.java
Patch:
@@ -67,6 +67,7 @@ private void doIt(HttpServletRequest req, HttpServletResponse res) throws IOExce
         // some get items
         write(w, "Method", req.getMethod());
         write(w, "Request URI", req.getRequestURI());
+        write(w, "Path Info", req.getPathInfo());
         write(w, "Query String", req.getQueryString());
 
         // request headers (why is it an enumeration?)

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -1851,6 +1851,7 @@ private boolean isInlineable(Document.OutputSettings out) {
             return false;
         return (parent() == null || parent().isBlock())
             && !isEffectivelyFirst()
-            && !out.outline();
+            && !out.outline()
+            && !isNode("br");
     }
 }

File: src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java
Patch:
@@ -94,7 +94,7 @@ public void testSupplyParserToDataStream() throws IOException, URISyntaxExceptio
     public void testDoesNotForceSelfClosingKnownTags() {
         // html will force "<br>one</br>" to logically "<br />One<br />". XML should be stay "<br>one</br> -- don't recognise tag.
         Document htmlDoc = Jsoup.parse("<br>one</br>");
-        assertEquals("<br>\none<br>", htmlDoc.body().html());
+        assertEquals("<br>\none\n<br>", htmlDoc.body().html());
 
         Document xmlDoc = Jsoup.parse("<br>one</br>", "", Parser.xmlParser());
         assertEquals("<br>one</br>", xmlDoc.html());

File: src/main/java/org/jsoup/nodes/Comment.java
Patch:
@@ -38,7 +38,7 @@ public Comment setData(String data) {
 
     @Override
 	void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
-        if (out.prettyPrint() && ((siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock()) || (out.outline() )))
+        if (out.prettyPrint() && ((isEffectivelyFirst() && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock()) || (out.outline() )))
             indent(accum, depth, out);
         accum
                 .append("<!--")

File: src/test/java/org/jsoup/parser/HtmlParserTest.java
Patch:
@@ -1247,7 +1247,7 @@ public void testInvalidTableContents() throws IOException {
         File in = ParseTest.getFile("/htmltests/comments.html");
         Document doc = Jsoup.parse(in, "UTF-8");
 
-        assertEquals("<!--?xml version=\"1.0\" encoding=\"utf-8\"?--><!-- so --> <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><!-- what --> <html xml:lang=\"en\" lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\"><!-- now --> <head><!-- then --> <meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\"> <title>A Certain Kind of Test</title> </head> <body> <h1>Hello</h1>h1&gt; (There is a UTF8 hidden BOM at the top of this file.) </body> </html>",
+        assertEquals("<!--?xml version=\"1.0\" encoding=\"utf-8\"?--><!-- so --> <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><!-- what --> <html xml:lang=\"en\" lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\"> <!-- now --> <head> <!-- then --> <meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\"> <title>A Certain Kind of Test</title> </head> <body> <h1>Hello</h1>h1&gt; (There is a UTF8 hidden BOM at the top of this file.) </body> </html>",
             StringUtil.normaliseWhitespace(doc.html()));
 
         assertEquals("A Certain Kind of Test", doc.head().select("title").text());

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -1670,7 +1670,7 @@ public Range endSourceRange() {
     }
 
     boolean shouldIndent(final Document.OutputSettings out) {
-        return out.prettyPrint() && isFormatAsBlock(out) && !isInlineable(out);
+        return out.prettyPrint() && isFormatAsBlock(out) && !isInlineable(out) && !preserveWhitespace(parentNode);
     }
 
     @Override
@@ -1701,7 +1701,8 @@ void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSetti
     void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
         if (!(childNodes.isEmpty() && tag.isSelfClosing())) {
             if (out.prettyPrint() && (!childNodes.isEmpty() && (
-                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && (childNodes.get(0) instanceof Element))))
+                (tag.formatAsBlock() && !preserveWhitespace(parentNode)) ||
+                    (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && (childNodes.get(0) instanceof Element))))
             )))
                 indent(accum, depth, out);
             accum.append("</").append(tagName()).append('>');

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -838,6 +838,7 @@ boolean isInActiveFormattingElements(Element el) {
         return onStack(formattingElements, el);
     }
 
+    @Nullable
     Element getActiveFormattingElement(String nodeName) {
         for (int pos = formattingElements.size() -1; pos >= 0; pos--) {
             Element next = formattingElements.get(pos);

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -480,6 +480,8 @@ protected void setParentNode(Node parentNode) {
     protected void replaceChild(Node out, Node in) {
         Validate.isTrue(out.parentNode == this);
         Validate.notNull(in);
+        if (out == in) return; // no-op self replacement
+
         if (in.parentNode != null)
             in.parentNode.removeChild(in);
 

File: src/main/java/org/jsoup/parser/TokenQueue.java
Patch:
@@ -282,8 +282,10 @@ public static String unescape(String in) {
         char last = 0;
         for (char c : in.toCharArray()) {
             if (c == ESC) {
-                if (last == ESC)
+                if (last == ESC) {
                     out.append(c);
+                    c = 0;
+                }
             }
             else 
                 out.append(c);

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -76,9 +76,9 @@
  * <tr><td><code>:empty</code></td><td>elements that have no children at all</td><td></td></tr>
  * </table>
  *
- * <p>A word on using regular expressions in these selectors: depending on the content of the regex, you will need to quote the pattern using <b><code>Pattern.quote("regex")</code></b> for it to parse correclty through both the selector parser and the regex parser. E.g. <code>String query = "div:matches(" + Pattern.quote(regex) + ");"</code>.</p>
+ * <p>A word on using regular expressions in these selectors: depending on the content of the regex, you will need to quote the pattern using <b><code>Pattern.quote("regex")</code></b> for it to parse correctly through both the selector parser and the regex parser. E.g. <code>String query = "div:matches(" + Pattern.quote(regex) + ");"</code>.</p>
+ * <p><b>Escaping special characters:</b> to match a tag, ID, or other selector that does not follow the regular CSS syntax, the query must be escaped with the <code>\</code> character. For example, to match by ID {@code <p id="i.d">}, use {@code document.select("#i\\.d")}.</p>
  *
- * @author Jonathan Hedley, jonathan@hedley.net
  * @see Element#select(String)
  */
 public class Selector {

File: src/test/java/org/jsoup/parser/HtmlParserTest.java
Patch:
@@ -1192,7 +1192,7 @@ public void testInvalidTableContents() throws IOException {
 
         assertTrue(Jsoup.isValid(html, Safelist.basic()));
         String clean = Jsoup.clean(html, Safelist.basic());
-        assertEquals("<p>test<br>test<br></p>", clean);
+        assertEquals("<p>test<br>\n test<br></p>", clean);
     }
 
     @Test public void selfClosingOnNonvoidIsError() {

File: src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java
Patch:
@@ -94,7 +94,7 @@ public void testSupplyParserToDataStream() throws IOException, URISyntaxExceptio
     public void testDoesNotForceSelfClosingKnownTags() {
         // html will force "<br>one</br>" to logically "<br />One<br />". XML should be stay "<br>one</br> -- don't recognise tag.
         Document htmlDoc = Jsoup.parse("<br>one</br>");
-        assertEquals("<br>one<br>", htmlDoc.body().html());
+        assertEquals("<br>\none<br>", htmlDoc.body().html());
 
         Document xmlDoc = Jsoup.parse("<br>one</br>", "", Parser.xmlParser());
         assertEquals("<br>one</br>", xmlDoc.html());

File: src/test/java/org/jsoup/select/SelectorTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.jsoup.Jsoup;
 import org.jsoup.MultiLocaleExtension.MultiLocaleTest;
+import org.jsoup.TextUtil;
 import org.jsoup.nodes.Document;
 import org.jsoup.nodes.Element;
 import org.jsoup.parser.Parser;
@@ -907,6 +908,7 @@ public void containsData(Locale locale) {
     @Test public void matchText() {
         String html = "<p>One<br>Two</p>";
         Document doc = Jsoup.parse(html);
+        doc.outputSettings().prettyPrint(false);
         String origHtml = doc.html();
 
         Elements one = doc.select("p:matchText:first-child");

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -59,7 +59,7 @@ public Element(String tag) {
     }
 
     /**
-     * Create a new, standalone Element. (Standalone in that is has no parent.)
+     * Create a new, standalone Element. (Standalone in that it has no parent.)
      *
      * @param tag tag of this element
      * @param baseUri the base URI (optional, may be null to inherit from parent, or "" to clear parent's)
@@ -1085,7 +1085,7 @@ public Elements getElementsByAttribute(String key) {
      * Find elements that have an attribute name starting with the supplied prefix. Use {@code data-} to find elements
      * that have HTML5 datasets.
      * @param keyPrefix name prefix of the attribute e.g. {@code data-}
-     * @return elements that have attribute names that start with with the prefix, empty if none.
+     * @return elements that have attribute names that start with the prefix, empty if none.
      */
     public Elements getElementsByAttributeStarting(String keyPrefix) {
         Validate.notEmpty(keyPrefix);

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -452,7 +452,7 @@ void nodelistChanged() {
 
     /**
      * Replace this node in the DOM with the supplied node.
-     * @param in the node that will will replace the existing node.
+     * @param in the node that will replace the existing node.
      */
     public void replaceWith(Node in) {
         Validate.notNull(in);
@@ -763,7 +763,7 @@ public int hashCode() {
     }
 
     /**
-     * Check if this node is has the same content as another node. A node is considered the same if its name, attributes and content match the
+     * Check if this node has the same content as another node. A node is considered the same if its name, attributes and content match the
      * other node; particularly its position in the tree does not influence its similarity.
      * @param o other object to compare to
      * @return true if the content of this node is the same as the other

File: src/main/java/org/jsoup/parser/TokenQueue.java
Patch:
@@ -187,7 +187,7 @@ else if (skip < 0) // no chance of finding, grab to end
      @return consumed string   
      */
     // todo: method name. not good that consumeTo cares for case, and consume to any doesn't. And the only use for this
-    // is is a case sensitive time...
+    // is a case sensitive time...
     public String consumeToAny(String... seq) {
         int start = pos;
         while (!isEmpty() && !matchesAny(seq)) {

File: src/test/java/org/jsoup/parser/HtmlParserTest.java
Patch:
@@ -672,7 +672,7 @@ public class HtmlParserTest {
     }
 
     @Test public void handlesUnexpectedMarkupInTables() {
-        // whatwg - tests markers in active formatting (if they didn't work, would get in in table)
+        // whatwg - tests markers in active formatting (if they didn't work, would get in table)
         // also tests foster parenting
         String h = "<table><b><tr><td>aaa</td></tr>bbb</table>ccc";
         Document doc = Jsoup.parse(h);
@@ -1633,4 +1633,4 @@ private boolean didAddElements(String input) {
         assertEquals("<template><select></select><input>&lt;</template>",
             TextUtil.stripNewlines(doc.head().html()));
     }
-}
\ No newline at end of file
+}

File: src/main/java/org/jsoup/helper/W3CDom.java
Patch:
@@ -269,8 +269,8 @@ public NodeList selectXpath(String xpath, Document doc) {
      @return the matches nodes
      */
     public NodeList selectXpath(String xpath, Node contextNode) {
-        Validate.notEmpty(xpath);
-        Validate.notNull(contextNode);
+        Validate.notEmptyParam(xpath, "xpath");
+        Validate.notNullParam(contextNode, "contextNode");
 
         NodeList nodeList;
         try {

File: src/main/java/org/jsoup/parser/TreeBuilder.java
Patch:
@@ -37,8 +37,8 @@ abstract class TreeBuilder {
 
     @ParametersAreNonnullByDefault
     protected void initialiseParse(Reader input, String baseUri, Parser parser) {
-        Validate.notNull(input, "String input must not be null");
-        Validate.notNull(baseUri, "BaseURI must not be null");
+        Validate.notNullParam(input, "input");
+        Validate.notNullParam(baseUri, "baseUri");
         Validate.notNull(parser);
 
         doc = new Document(baseUri);

File: src/main/java/org/jsoup/select/QueryParser.java
Patch:
@@ -360,7 +360,7 @@ private int consumeIndex() {
     private void has() {
         tq.consume(":has");
         String subQuery = tq.chompBalanced('(', ')');
-        Validate.notEmpty(subQuery, ":has(selector) subselect must not be empty");
+        Validate.notEmpty(subQuery, ":has(selector) sub-select must not be empty");
         evals.add(new StructuralEvaluator.Has(parse(subQuery)));
     }
 

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -522,6 +522,8 @@ public boolean is(Evaluator evaluator) {
 
     /**
      Find Elements that match the supplied XPath expression.
+     <p>Note that for convenience of writing the Xpath expression, namespaces are disabled, and queries can be
+     expressed using the elements local name only.</p>
      <p>By default, XPath 1.0 expressions are supported. If you would to use XPath 2.0 or higher, you can provide an
      alternate XPathFactory implementation:</p>
      <ol>

File: src/main/java/org/jsoup/nodes/NodeUtils.java
Patch:
@@ -42,7 +42,7 @@ static <T extends Node> List<T> selectXpath(String xpath, Element el, Class<T> n
         Validate.notNull(el);
         Validate.notNull(nodeType);
 
-        W3CDom w3c = new W3CDom();
+        W3CDom w3c = new W3CDom().namespaceAware(false);
         org.w3c.dom.Document wDoc = w3c.fromJsoup(el);
         org.w3c.dom.Node contextNode = w3c.contextNode(wDoc);
         NodeList nodeList = w3c.selectXpath(xpath, contextNode);

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -142,7 +142,7 @@ static void htmlNoValidate(String key, @Nullable String val, Appendable accum, D
         accum.append(key);
         if (!shouldCollapseAttribute(key, val, out)) {
             accum.append("=\"");
-            Entities.escape(accum, Attributes.checkNotNull(val) , out, true, false, false);
+            Entities.escape(accum, Attributes.checkNotNull(val) , out, true, false, false, false);
             accum.append('"');
         }
     }

File: src/main/java/org/jsoup/nodes/XmlDeclaration.java
Patch:
@@ -60,7 +60,7 @@ private void getWholeDeclaration(Appendable accum, Document.OutputSettings out)
                 accum.append(key);
                 if (!val.isEmpty()) {
                     accum.append("=\"");
-                    Entities.escape(accum, val, out, true, false, false);
+                    Entities.escape(accum, val, out, true, false, false, false);
                     accum.append('"');
                 }
             }

File: src/test/java/org/jsoup/nodes/DocumentTest.java
Patch:
@@ -55,15 +55,15 @@ public class DocumentTest {
     @Test public void testOutputEncoding() {
         Document doc = Jsoup.parse("<p title=> & < > </p>");
         // default is utf-8
-        assertEquals("<p title=\"\"> &amp; &lt; &gt; </p>", doc.body().html());
+        assertEquals("<p title=\"\"> &amp; &lt; &gt;</p>", doc.body().html());
         assertEquals("UTF-8", doc.outputSettings().charset().name());
 
         doc.outputSettings().charset("ascii");
         assertEquals(Entities.EscapeMode.base, doc.outputSettings().escapeMode());
-        assertEquals("<p title=\"&#x3c0;\">&#x3c0; &amp; &lt; &gt; </p>", doc.body().html());
+        assertEquals("<p title=\"&#x3c0;\">&#x3c0; &amp; &lt; &gt;</p>", doc.body().html());
 
         doc.outputSettings().escapeMode(Entities.EscapeMode.extended);
-        assertEquals("<p title=\"&pi;\">&pi; &amp; &lt; &gt; </p>", doc.body().html());
+        assertEquals("<p title=\"&pi;\">&pi; &amp; &lt; &gt;</p>", doc.body().html());
     }
 
     @Test public void testXhtmlReferences() {

File: src/test/java/org/jsoup/select/TraversorTest.java
Patch:
@@ -95,7 +95,7 @@ public FilterResult tail(Node node, int depth) {
                 return ("b".equals(node.nodeName())) ? FilterResult.REMOVE : FilterResult.CONTINUE;
             }
         }, doc.select("div"));
-        assertEquals("<div></div>\n<div>\n There be \n</div>", doc.select("body").html());
+        assertEquals("<div></div>\n<div>\n There be\n</div>", doc.select("body").html());
     }
 
     @Test

File: src/test/java/org/jsoup/parser/HtmlParserTest.java
Patch:
@@ -1246,7 +1246,7 @@ public void testInvalidTableContents() throws IOException {
         File in = ParseTest.getFile("/htmltests/comments.html");
         Document doc = Jsoup.parse(in, "UTF-8");
 
-        assertEquals("<!--?xml version=\"1.0\" encoding=\"utf-8\"?--><!-- so --><!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><!-- what --> <html xml:lang=\"en\" lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\"> <!-- now --> <head> <!-- then --> <meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\"> <title>A Certain Kind of Test</title> </head> <body> <h1>Hello</h1>h1&gt; (There is a UTF8 hidden BOM at the top of this file.) </body> </html>",
+        assertEquals("<!--?xml version=\"1.0\" encoding=\"utf-8\"?--><!-- so --> <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><!-- what --> <html xml:lang=\"en\" lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\"> <!-- now --> <head> <!-- then --> <meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\"> <title>A Certain Kind of Test</title> </head> <body> <h1>Hello</h1>h1&gt; (There is a UTF8 hidden BOM at the top of this file.) </body> </html>",
             StringUtil.normaliseWhitespace(doc.html()));
 
         assertEquals("A Certain Kind of Test", doc.head().select("title").text());

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -385,8 +385,9 @@ private boolean inBodyStartTag(Token t, HtmlTreeBuilder tb) {
                         return false; // ignore
                     } else {
                         tb.framesetOk(false);
-                        Element body = stack.get(1);
-                        if (startTag.hasAttributes()) {
+                        // will be on stack if this is a nested body. won't be if closed (which is a variance from spec, which leaves it on)
+                        Element body;
+                        if (startTag.hasAttributes() && (body = tb.getFromStack("body")) != null) { // we only ever put one body on stack
                             for (Attribute attribute : startTag.attributes) {
                                 if (!body.hasAttr(attribute.getKey()))
                                     body.attributes().put(attribute);

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -1842,7 +1842,6 @@ private boolean isFormatAsBlock(Document.OutputSettings out) {
 
     private boolean isInlineable(Document.OutputSettings out) {
         return tag().isInline()
-            && !tag().isEmpty()
             && (parent() == null || parent().isBlock())
             && previousSibling() != null
             && !out.outline();

File: src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java
Patch:
@@ -75,7 +75,7 @@ public void nestedAnchorElements01() {
         String s = Jsoup.parse(html).toString();
         assertEquals("<html>\n" +
             " <head></head>\n" +
-            " <body><a href=\"#1\"> </a>\n" +
+            " <body> <a href=\"#1\"> </a>\n" +
             "  <div>\n" +
             "   <a href=\"#1\"></a><a href=\"#2\">child</a>\n" +
             "  </div>\n" +
@@ -99,7 +99,7 @@ public void nestedAnchorElements02() {
         String s = Jsoup.parse(html).toString();
         assertEquals("<html>\n" +
             " <head></head>\n" +
-            " <body><a href=\"#1\"> </a>\n" +
+            " <body> <a href=\"#1\"> </a>\n" +
             "  <div>\n" +
             "   <a href=\"#1\"></a>\n" +
             "   <div>\n" +

File: src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java
Patch:
@@ -94,7 +94,7 @@ public void testSupplyParserToDataStream() throws IOException, URISyntaxExceptio
     public void testDoesNotForceSelfClosingKnownTags() {
         // html will force "<br>one</br>" to logically "<br />One<br />". XML should be stay "<br>one</br> -- don't recognise tag.
         Document htmlDoc = Jsoup.parse("<br>one</br>");
-        assertEquals("<br>one\n<br>", htmlDoc.body().html());
+        assertEquals("<br>one<br>", htmlDoc.body().html());
 
         Document xmlDoc = Jsoup.parse("<br>one</br>", "", Parser.xmlParser());
         assertEquals("<br>one</br>", xmlDoc.html());

File: src/main/java/org/jsoup/nodes/TextNode.java
Patch:
@@ -85,14 +85,14 @@ void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) thr
         final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;
         final boolean parentIndent = parent != null && parent.shouldIndent(out);
         final boolean blank = isBlank();
+        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);
 
-        if (parentIndent && StringUtil.startsWithNewline(coreValue()) && blank) // we are skippable whitespace
+        if (normaliseWhite && parentIndent && StringUtil.startsWithNewline(coreValue()) && blank) // we are skippable whitespace
             return;
 
         if (prettyPrint && ((siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !blank) || (out.outline() && siblingNodes().size()>0 && !blank) ))
             indent(accum, depth, out);
 
-        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);
         final boolean stripWhite = prettyPrint && parentNode instanceof Document;
         Entities.escape(accum, coreValue(), out, false, normaliseWhite, stripWhite);
     }

File: src/main/java/org/jsoup/helper/Consumer.java
Patch:
@@ -8,7 +8,7 @@ A functional interface (ala Java's {@link java.util.function.Consumer} interface
 public interface Consumer<T> {
 
     /**
-     * Executre this operation on the supplied argument. It is expected to have side effects.
+     * Execute this operation on the supplied argument. It is expected to have side effects.
      *
      * @param t the input argument
      */

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -56,7 +56,8 @@
  * <tr><td><code>:containsWholeText(<em>text</em>)</code></td><td>elements that contains the specified <b>non-normalized</b> text. The search is case sensitive, and will match exactly against spaces and newlines found in the original input. The text may appear in the found element, or any of its descendants. <p>To find content that includes parentheses, escape those with a {@code \}.</p></td><td><code>p:containsWholeText(jsoup\nThe Java HTML Parser)</code> finds p elements containing the text <code>"jsoup\nThe Java HTML Parser"</code> (and not other variations of whitespace or casing, as <code>:contains()</code> would. Note that {@code br} elements are presented as a newline.</p></td></tr>
  * <tr><td><code>:containsWholeOwnText(<em>text</em>)</code></td><td>elements that <b>directly</b> contain the specified <b>non-normalized</b> text. The search is case sensitive, and will match exactly against spaces and newlines found in the original input. The text may appear in the found element, but not in its descendants. <p>To find content that includes parentheses, escape those with a {@code \}.</p></td><td><code>p:containsWholeOwnText(jsoup\nThe Java HTML Parser)</code> finds p elements directly containing the text <code>"jsoup\nThe Java HTML Parser"</code> (and not other variations of whitespace or casing, as <code>:contains()</code> would. Note that {@code br} elements are presented as a newline.</p></td></tr>
  * <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements containing <b>whitespace normalized</b> text that matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>
- * <tr><td><code>:matchesOwn(<em>regex</em>)</code></td><td>elements whose own text matches the specified regular expression. The text must appear in the found element, not any of its descendants.</td><td><code>td:matchesOwn(\\d+)</code> finds table cells directly containing digits. <code>div:matchesOwn((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>
+ * <tr><td><code>:matchesWholeText(<em>regex</em>)</code></td><td>elements containing <b>non-normalized</b> whole text that matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matchesWholeText(\\s{2,})</code> finds table cells a run of at least two space characters.</td></tr>
+ * <tr><td><code>:matchesWholeOwnText(<em>regex</em>)</code></td><td>elements whose own <b>non-normalized</b> whole text matches the specified regular expression. The text must appear in the found element, not any of its descendants.</td><td><code>td:matchesWholeOwnText(\n\\d+)</code> finds table cells directly containing digits following a neewline.</td></tr>
  * <tr><td></td><td>The above may be combined in any order and with other selectors</td><td><code>.light:contains(name):eq(0)</code></td></tr>
  * <tr><td><code>:matchText</code></td><td>treats text nodes as elements, and so allows you to match against and select text nodes.<p><b>Note</b> that using this selector will modify the DOM, so you may want to {@code clone} your document before using.</td><td>{@code p:matchText:firstChild} with input {@code <p>One<br />Two</p>} will return one {@link org.jsoup.nodes.PseudoTextElement} with text "{@code One}".</td></tr>
  * <tr><td colspan="3"><h3>Structural pseudo selectors</h3></td></tr>

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -47,7 +47,7 @@ public class Element extends Node {
     private Tag tag;
     private @Nullable WeakReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children
     List<Node> childNodes;
-    private @Nullable Attributes attributes; // field is nullable but all methods for attributes are non null
+    protected @Nullable Attributes attributes; // field is nullable but all methods for attributes are non null
 
     /**
      * Create a new, standalone element.

File: src/test/java/org/jsoup/integration/FuzzFixesIT.java
Patch:
@@ -20,7 +20,7 @@
  */
 public class FuzzFixesIT {
     static int numIters = 50;
-    static int timeout = 20; // external fuzzer is set to 60 for 100 runs
+    static int timeout = 30; // external fuzzer is set to 60 for 100 runs
     static File testDir = ParseTest.getFile("/fuzztests/");
 
     private static Stream<File> testFiles() {

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -997,8 +997,7 @@ boolean process(Token t, HtmlTreeBuilder tb) {
                         return false;
                     } else {
                         tb.popStackToClose(name);
-                        tb.resetInsertionMode();
-                        if (tb.state() == InTable) {
+                        if (!tb.resetInsertionMode()) {
                             // not per spec - but haven't transitioned out of table. so try something else
                             tb.insert(startTag);
                             return true;

File: src/main/java/org/jsoup/select/QueryParser.java
Patch:
@@ -130,7 +130,7 @@ private void combinator(char combinator) {
                 currentEval = or;
                 break;
             default:
-                throw new Selector.SelectorParseException("Unknown combinator: " + combinator);
+                throw new Selector.SelectorParseException("Unknown combinator '%s'", combinator);
         }
 
         if (replaceRightMost)

File: src/main/java/org/jsoup/internal/ConstrainableInputStream.java
Patch:
@@ -81,10 +81,10 @@ public ByteBuffer readToByteBuffer(int max) throws IOException {
         final ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);
 
         int read;
-        int remaining = max;
+        int remaining = bufferSize;
 
         while (true) {
-            read = read(readBuffer);
+            read = read(readBuffer, 0, remaining);
             if (read == -1) break;
             if (localCapped) { // this local byteBuffer cap may be smaller than the overall maxSize (like when reading first bytes)
                 if (read >= remaining) {

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -683,7 +683,7 @@ public String toString() {
     }
 
     protected void indent(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
-        accum.append('\n').append(StringUtil.padding(depth * out.indentAmount()));
+        accum.append('\n').append(StringUtil.padding(depth * out.indentAmount(), out.maxPaddingWidth()));
     }
 
     /**

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.jsoup.SerializationException;
 import org.jsoup.helper.Validate;
+import org.jsoup.internal.Normalizer;
 import org.jsoup.internal.StringUtil;
 import org.jsoup.nodes.Document.OutputSettings.Syntax;
 
@@ -211,7 +212,7 @@ protected static boolean shouldCollapseAttribute(final String key, @Nullable fin
      * Checks if this attribute name is defined as a boolean attribute in HTML5
      */
     public static boolean isBooleanAttribute(final String key) {
-        return Arrays.binarySearch(booleanAttributes, key) >= 0;
+        return Arrays.binarySearch(booleanAttributes, Normalizer.lowerCase(key)) >= 0;
     }
 
     @Override

File: src/main/java/org/jsoup/nodes/NodeUtils.java
Patch:
@@ -44,7 +44,8 @@ static <T extends Node> List<T> selectXpath(String xpath, Element el, Class<T> n
 
         W3CDom w3c = new W3CDom();
         org.w3c.dom.Document wDoc = w3c.fromJsoup(el);
-        NodeList nodeList = w3c.selectXpath(xpath, wDoc);
+        org.w3c.dom.Node contextNode = w3c.contextNode(wDoc);
+        NodeList nodeList = w3c.selectXpath(xpath, contextNode);
         return w3c.sourceNodes(nodeList, nodeType);
     }
 }

File: src/test/java/org/jsoup/helper/W3CDomTest.java
Patch:
@@ -328,7 +328,7 @@ private void assertEqualsIgnoreCase(String want, String have) {
         Element jDiv = jdoc.selectFirst("div");
         assertNotNull(jDiv);
         Document doc = w3CDom.fromJsoup(jDiv);
-        Node div = doc.getFirstChild();
+        Node div = w3CDom.contextNode(doc);
 
         assertEquals("div", div.getLocalName());
         assertEquals(jDiv, div.getUserData(W3CDom.SourceProperty));

File: src/main/java/org/jsoup/parser/TokeniserState.java
Patch:
@@ -186,7 +186,7 @@ void read(Tokeniser t, CharacterReader r) {
             if (r.matches('/')) {
                 t.createTempBuffer();
                 t.advanceTransition(RCDATAEndTagOpen);
-            } else if (r.matchesAsciiAlpha() && t.appropriateEndTagName() != null && !r.containsIgnoreCase("</" + t.appropriateEndTagName())) {
+            } else if (r.matchesAsciiAlpha() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(t.appropriateEndTagSeq())) {
                 // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than
                 // consuming to EOF; break out here
                 t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -1547,7 +1547,9 @@ else if (name.equals("col")) {
                     tb.clearFormattingElementsToLastMarker();
                     tb.popTemplateMode();
                     tb.resetInsertionMode();
-                    if (tb.state() != InTemplate) // spec deviation - if we did not break out of Template, stop processing
+                    // spec deviation - if we did not break out of Template, stop processing, and don't worry about cleaning up ultra-deep template stacks
+                    // limited depth because this can recurse and will blow stack if too deep
+                    if (tb.state() != InTemplate && tb.templateModeSize() < 12)
                         return tb.process(t);
                     else return true;
             }

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -478,7 +478,7 @@ void resetInsertionMode() {
 
         LOOP: for (int pos = bottom; pos >= upper; pos--) {
             Element node = stack.get(pos);
-            if (pos == 0) {
+            if (pos == upper) {
                 last = true;
                 if (fragmentParsing)
                     node = contextElement;

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -544,6 +544,7 @@ private boolean inBodyStartTag(Token t, HtmlTreeBuilder tb) {
                     tb.reconstructFormattingElements();
                     tb.insert(startTag);
                     tb.framesetOk(false);
+                    if (startTag.selfClosing) break; // don't change states if not added to the stack
 
                     HtmlTreeBuilderState state = tb.state();
                     if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))

File: src/main/java/org/jsoup/parser/Tag.java
Patch:
@@ -237,7 +237,7 @@ protected Tag clone() {
             "ul", "ol", "pre", "div", "blockquote", "hr", "address", "figure", "figcaption", "form", "fieldset", "ins",
             "del", "dl", "dt", "dd", "li", "table", "caption", "thead", "tfoot", "tbody", "colgroup", "col", "tr", "th",
             "td", "video", "audio", "canvas", "details", "menu", "plaintext", "template", "article", "main",
-            "svg", "math", "center"
+            "svg", "math", "center", "template"
     };
     private static final String[] inlineTags = {
             "object", "base", "font", "tt", "i", "b", "u", "big", "small", "em", "strong", "dfn", "code", "samp", "kbd",

File: src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java
Patch:
@@ -44,7 +44,7 @@ static void ensureSorted(List<Object[]> constants) {
     public void ensureArraysAreSorted() {
         List<Object[]> constants = findConstantArrays(Constants.class);
         ensureSorted(constants);
-        assertEquals(38, constants.size());
+        assertEquals(40, constants.size());
     }
 
 

File: src/test/java/org/jsoup/parser/HtmlTreeBuilderTest.java
Patch:
@@ -18,7 +18,7 @@ public class HtmlTreeBuilderTest {
     public void ensureSearchArraysAreSorted() {
         List<Object[]> constants = HtmlTreeBuilderStateTest.findConstantArrays(HtmlTreeBuilder.class);
         HtmlTreeBuilderStateTest.ensureSorted(constants);
-        assertEquals(7, constants.size());
+        assertEquals(8, constants.size());
     }
 
     @Test

File: src/main/java/org/jsoup/nodes/Attributes.java
Patch:
@@ -25,7 +25,7 @@
  * Attributes are treated as a map: there can be only one value associated with an attribute key/name.
  * </p>
  * <p>
- * Attribute name and value comparisons are  generally <b>case sensitive</b>. By default for HTML, attribute names are
+ * Attribute name and value comparisons are generally <b>case sensitive</b>. By default for HTML, attribute names are
  * normalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by
  * name.
  * </p>

File: src/main/java/org/jsoup/helper/W3CDom.java
Patch:
@@ -50,8 +50,8 @@ public class W3CDom {
     public static final String SourceProperty = "jsoupSource";
 
     /**
-     To get support for XPath versions > 1, set this property to the classname of an alternate XPathFactory
-     implementation (e.g. <code>net.sf.saxon.xpath.XPathFactoryImpl</code>).
+     To get support for XPath versions &gt; 1, set this property to the classname of an alternate XPathFactory
+     implementation (e.g. {@code net.sf.saxon.xpath.XPathFactoryImpl}).
      */
     public static final String XPathFactoryProperty = "javax.xml.xpath.XPathFactory:jsoup";
 

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -188,7 +188,7 @@ protected static boolean isBooleanAttribute(final String key) {
     }
 
     @Override
-    public boolean equals(Object o) { // note parent not considered
+    public boolean equals(@Nullable Object o) { // note parent not considered
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         Attribute attribute = (Attribute) o;

File: src/main/java/org/jsoup/nodes/Attributes.java
Patch:
@@ -376,7 +376,7 @@ public String toString() {
      * @return if both sets of attributes have the same content
      */
     @Override
-    public boolean equals(Object o) {
+    public boolean equals(@Nullable Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
 

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -691,7 +691,7 @@ protected void indent(Appendable accum, int depth, Document.OutputSettings out)
      * @see Node#hasSameValue(Object)
      */
     @Override
-    public boolean equals(Object o) {
+    public boolean equals(@Nullable Object o) {
         // implemented just so that javadoc is clear this is an identity test
         return this == o;
     }

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -212,7 +212,7 @@ Element insert(final Token.StartTag startTag) {
         if (startTag.hasAttributes() && !startTag.attributes.isEmpty()) {
             int dupes = startTag.attributes.deduplicate(settings);
             if (dupes > 0) {
-                error("Duplicate attribute");
+                error("Dropped duplicate attribute(s) in tag [%s]", startTag.normalName);
             }
         }
 
@@ -249,7 +249,7 @@ Element insertEmpty(Token.StartTag startTag) {
         if (startTag.isSelfClosing()) {
             if (tag.isKnownTag()) {
                 if (!tag.isEmpty())
-                    tokeniser.error("Tag cannot be self closing; not a void tag");
+                    tokeniser.error("Tag [%s] cannot be self closing; not a void tag", tag.normalName());
             }
             else // unknown tag, remember this is self closing for output
                 tag.setSelfClosing();

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -204,7 +204,7 @@ boolean isFragmentParsing() {
 
     void error(HtmlTreeBuilderState state) {
         if (parser.getErrors().canAddError())
-            parser.getErrors().add(new ParseError(reader.pos(), "Unexpected token [%s] when in state [%s]", currentToken.tokenType(), state));
+            parser.getErrors().add(new ParseError(reader, "Unexpected token [%s] when in state [%s]", currentToken.tokenType(), state));
     }
 
     Element insert(final Token.StartTag startTag) {

File: src/main/java/org/jsoup/parser/Parser.java
Patch:
@@ -93,6 +93,7 @@ public Parser setTrackErrors(int maxErrors) {
     /**
      * Retrieve the parse errors, if any, from the last parse.
      * @return list of parse errors, up to the size of the maximum errors tracked.
+     * @see #setTrackErrors(int)
      */
     public ParseErrorList getErrors() {
         return errors;

File: src/main/java/org/jsoup/parser/TreeBuilder.java
Patch:
@@ -40,6 +40,7 @@ protected void initialiseParse(Reader input, String baseUri, Parser parser) {
         this.parser = parser;
         settings = parser.settings();
         reader = new CharacterReader(input);
+        reader.trackNewlines(parser.isTrackErrors()); // when tracking errors, enable newline tracking for better error reports
         currentToken = null;
         tokeniser = new Tokeniser(reader, parser.getErrors());
         stack = new ArrayList<>(32);
@@ -139,7 +140,7 @@ protected boolean currentElementIs(String normalName) {
     protected void error(String msg) {
         ParseErrorList errors = parser.getErrors();
         if (errors.canAddError())
-            errors.add(new ParseError(reader.pos(), msg));
+            errors.add(new ParseError(reader, msg));
     }
 
     /**

File: src/main/java/org/jsoup/Jsoup.java
Patch:
@@ -266,7 +266,7 @@ public static String clean(String bodyHtml, String baseUri, Whitelist safelist)
      <p>Note that as this method does not take a base href URL to resolve attributes with relative URLs against, those
      URLs will be removed, unless the input HTML contains a {@code <base href> tag}. If you wish to preserve those, use
      the {@link Jsoup#clean(String html, String baseHref, Safelist)} method instead, and enable
-     {@link Safelist#preserveRelativeLinks(boolean true)}.</p>
+     {@link Safelist#preserveRelativeLinks(boolean)}.</p>
 
      @param bodyHtml input untrusted HTML (body fragment)
      @param safelist list of permitted HTML elements

File: src/main/java/org/jsoup/nodes/Attributes.java
Patch:
@@ -275,7 +275,6 @@ public void addAll(Attributes incoming) {
             // todo - should this be case insensitive?
             put(attr);
         }
-
     }
 
     public Iterator<Attribute> iterator() {

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -815,8 +815,7 @@ else if (!tb.onStack(formatEl)) {
                 Element furthestBlock = null;
                 Element commonAncestor = null;
                 boolean seenFormattingElement = false;
-                // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents
-                // run-aways
+                // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents run-aways
                 final int stackSize = stack.size();
                 int bookmark = -1;
                 for (int si = 1; si < stackSize && si < 64; si++) {

File: src/main/java/org/jsoup/parser/Tokeniser.java
Patch:
@@ -4,6 +4,7 @@
 import org.jsoup.internal.StringUtil;
 import org.jsoup.nodes.Entities;
 
+import javax.annotation.Nullable;
 import java.util.Arrays;
 
 /**
@@ -152,7 +153,7 @@ void advanceTransition(TokeniserState state) {
 
     final private int[] codepointHolder = new int[1]; // holder to not have to keep creating arrays
     final private int[] multipointHolder = new int[2];
-    int[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
+    @Nullable int[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
         if (reader.isEmpty())
             return null;
         if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())

File: src/main/java/org/jsoup/internal/StringUtil.java
Patch:
@@ -299,9 +299,11 @@ public static String resolve(final String baseUrl, final String relUrl) {
             }
             return resolve(base, relUrl).toExternalForm();
         } catch (MalformedURLException e) {
-            return "";
+            // it may still be valid, just that Java doesn't have a registered stream handler for it, e.g. tel:
+            return validUriScheme.matcher(relUrl).find() ? relUrl : "";
         }
     }
+    private static final Pattern validUriScheme = Pattern.compile("^[a-zA-Z][a-zA-Z0-9+-.]*:");
 
     private static final ThreadLocal<Stack<StringBuilder>> threadLocalBuilders = new ThreadLocal<Stack<StringBuilder>>() {
         @Override

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -82,7 +82,7 @@ public Element(Tag tag, @Nullable String baseUri, @Nullable Attributes attribute
      * @param baseUri the base URI of this element. Optional, and will inherit from its parent, if any.
      * @see Tag#valueOf(String, ParseSettings)
      */
-    public Element(Tag tag, String baseUri) {
+    public Element(Tag tag, @Nullable String baseUri) {
         this(tag, baseUri, null);
     }
 

File: src/test/java/org/jsoup/parser/HtmlParserTest.java
Patch:
@@ -814,7 +814,7 @@ public class HtmlParserTest {
 
     @Test public void handlesNullInData() {
         Document doc = Jsoup.parse("<p id=\u0000>Blah \u0000</p>");
-        assertEquals("<p id=\"\uFFFD\">Blah \u0000</p>", doc.body().html()); // replaced in attr, NOT replaced in data
+        assertEquals("<p id=\"\uFFFD\">Blah &#x0;</p>", doc.body().html()); // replaced in attr, NOT replaced in data (but is escaped as control char <0x20)
     }
 
     @Test public void handlesNullInComments() {

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -816,7 +816,8 @@ else if (!tb.onStack(formatEl)) {
                 // run-aways
                 final int stackSize = stack.size();
                 int bookmark = -1;
-                for (int si = 0; si < stackSize && si < 64; si++) {
+                for (int si = 1; si < stackSize && si < 64; si++) {
+                    // TODO: this no longer matches the current spec at https://html.spec.whatwg.org/#adoption-agency-algorithm and should be updated
                     el = stack.get(si);
                     if (el == formatEl) {
                         commonAncestor = stack.get(si - 1);

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -774,7 +774,7 @@ boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {
                 Element node = stack.get(pos);
                 if (node.normalName().equals(name)) {
                     tb.generateImpliedEndTags(name);
-                    if (!name.equals(tb.currentElement().normalName()))
+                    if (!tb.currentElementIs(name))
                         tb.error(this);
                     tb.popStackToClose(name);
                     break;
@@ -1000,7 +1000,6 @@ boolean process(Token t, HtmlTreeBuilder tb) {
                 }
                 return true; // todo: as above todo
             } else if (t.isEOF()) {
-                Element el = tb.currentElement();
                 if (tb.currentElementIs("html"))
                     tb.error(this);
                 return true; // stops parsing

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -335,6 +335,7 @@ private boolean isElementInQueue(ArrayList<Element> queue, Element element) {
         return false;
     }
 
+    @Nullable
     Element getFromStack(String elName) {
         final int bottom = stack.size() - 1;
         final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -460,7 +460,8 @@ private boolean inBodyStartTag(Token t, HtmlTreeBuilder tb) {
                     tb.processStartTag("form");
                     if (startTag.hasAttribute("action")) {
                         Element form = tb.getFormElement();
-                        form.attr("action", startTag.attributes.get("action"));
+                        String action = startTag.attributes.get("action");
+                        form.attributes().put("action", action); // always LC, so don't need to scan up for ownerdoc
                     }
                     tb.processStartTag("hr");
                     tb.processStartTag("label");

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -336,7 +336,9 @@ private boolean isElementInQueue(ArrayList<Element> queue, Element element) {
     }
 
     Element getFromStack(String elName) {
-        for (int pos = stack.size() -1; pos >= 0; pos--) {
+        final int bottom = stack.size() - 1;
+        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;
+        for (int pos = bottom; pos >= upper; pos--) {
             Element next = stack.get(pos);
             if (next.normalName().equals(elName)) {
                 return next;

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -73,6 +73,8 @@
  * <tr><td><code>:empty</code></td><td>elements that have no children at all</td><td></td></tr>
  * </table>
  *
+ * <p>A word on using regular expressions in these selectors: depending on the content of the regex, you will need to quote the pattern using <b><code>Pattern.quote("regex")</code></b> for it to parse correclty through both the selector parser and the regex parser. E.g. <code>String query = "div:matches(" + Pattern.quote(regex) + ");"</code>.</p>
+ *
  * @author Jonathan Hedley, jonathan@hedley.net
  * @see Element#select(String)
  */

File: src/main/java/org/jsoup/parser/Token.java
Patch:
@@ -181,6 +181,8 @@ final void appendTagName(char append) {
         }
 
         final void appendAttributeName(String append) {
+            // might have null chars because we eat in one pass - need to replace with null replacement character
+            append = append.replace(TokeniserState.nullChar, Tokeniser.replacementChar);
             pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);
         }
 

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -25,7 +25,7 @@
  * <tr><th align="left">Pattern</th><th align="left">Matches</th><th align="left">Example</th></tr>
  * <tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>
  * <tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>
- * <tr><td><code>*|E</code></td><td>elements of type E in any namespace <i>ns</i></td><td><code>*|name</code> finds <code>&lt;fb:name&gt;</code> elements</td></tr>
+ * <tr><td><code>*|E</code></td><td>elements of type E in any namespace (including non-namespaced)</td><td><code>*|name</code> finds <code>&lt;fb:name&gt;</code> and <code>&lt;name&gt;</code> elements</td></tr>
  * <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name&gt;</code> elements</td></tr>
  * <tr><td><code>#id</code></td><td>elements with attribute ID of "id"</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>
  * <tr><td><code>.class</code></td><td>elements with a class name of "class"</td><td><code>div.left</code>, <code>.result</code></td></tr>

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -708,6 +708,7 @@ public boolean hasSameValue(@Nullable Object o) {
      * @return a stand-alone cloned node, including clones of any children
      * @see #shallowClone()
      */
+    @SuppressWarnings("MethodDoesntCallSuperMethod") // because it does call super.clone in doClone - analysis just isn't following
     @Override
     public Node clone() {
         Node thisClone = doClone(null); // splits for orphan

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -356,6 +356,7 @@ boolean removeFromStack(Element el) {
         return false;
     }
 
+    @Nullable
     Element popStackToClose(String elName) {
         for (int pos = stack.size() -1; pos >= 0; pos--) {
             Element el = stack.get(pos);

File: src/main/java/org/jsoup/parser/CharacterReader.java
Patch:
@@ -362,8 +362,8 @@ String consumeRawData() {
     }
 
     String consumeTagName() {
-        // '\t', '\n', '\r', '\f', ' ', '/', '>', nullChar
-        // NOTE: out of spec, added '<' to fix common author bugs
+        // '\t', '\n', '\r', '\f', ' ', '/', '>'
+        // NOTE: out of spec, added '<' to fix common author bugs; does not stop and append on nullChar but eats
         bufferUp();
         int pos = bufPos;
         final int start = pos;
@@ -380,7 +380,6 @@ String consumeTagName() {
                 case '/':
                 case '>':
                 case '<':
-                case TokeniserState.nullChar:
                     break OUTER;
             }
             pos++;

File: src/main/java/org/jsoup/parser/Token.java
Patch:
@@ -165,6 +165,8 @@ final boolean isSelfClosing() {
 
         // these appenders are rarely hit in not null state-- caused by null chars.
         final void appendTagName(String append) {
+            // might have null chars - need to replace with null replacement character
+            append = append.replace(TokeniserState.nullChar, Tokeniser.replacementChar);
             tagName = tagName == null ? append : tagName.concat(append);
             normalName = lowerCase(tagName);
         }

File: src/main/java/org/jsoup/parser/TokeniserState.java
Patch:
@@ -191,8 +191,7 @@ void read(Tokeniser t, CharacterReader r) {
                 // consuming to EOF; break out here
                 t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());
                 t.emitTagPending();
-                r.unconsume(); // undo "<"
-                t.transition(Data);
+                t.transition(TagOpen); // straight into TagOpen, as we came from < and looks like we're on a start tag
             } else {
                 t.emit("<");
                 t.transition(Rcdata);

File: src/main/java/org/jsoup/parser/XmlTreeBuilder.java
Patch:
@@ -6,6 +6,7 @@
 import org.jsoup.nodes.Document;
 import org.jsoup.nodes.DocumentType;
 import org.jsoup.nodes.Element;
+import org.jsoup.nodes.Entities;
 import org.jsoup.nodes.Node;
 import org.jsoup.nodes.TextNode;
 import org.jsoup.nodes.XmlDeclaration;
@@ -33,6 +34,7 @@ protected void initialiseParse(Reader input, String baseUri, Parser parser) {
         stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)
         doc.outputSettings()
             .syntax(Document.OutputSettings.Syntax.xml)
+            .escapeMode(Entities.EscapeMode.xhtml)
             .prettyPrint(false); // as XML, we don't understand what whitespace is significant or not
     }
 

File: src/test/java/org/jsoup/nodes/DocumentTest.java
Patch:
@@ -163,7 +163,7 @@ public class DocumentTest {
                 "<html>\n" +
                 " <head></head>\n" +
                 " <body>\n" +
-                "  <img async=\"\" checked=\"checked\" src=\"&amp;<>&quot;\" />&lt;&gt;&amp;\"<foo />bar\n" +
+                "  <img async=\"\" checked=\"checked\" src=\"&amp;&lt;>&quot;\" />&lt;&gt;&amp;\"<foo />bar\n" +
                 " </body>\n" +
                 "</html>", doc.html());
     }

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -1320,7 +1320,7 @@ static boolean preserveWhitespace(@Nullable Node node) {
 
     /**
      * Set the text of this element. Any existing contents (text or elements) will be cleared.
-     * <p>As a special case, for {@code <script>} and {@code <style> tags, the input text will be treated as data,
+     * <p>As a special case, for {@code <script>} and {@code <style>} tags, the input text will be treated as data,
      * not visible text.</p>
      * @param text unencoded text
      * @return this element

File: src/main/java/org/jsoup/select/CombiningEvaluator.java
Patch:
@@ -50,7 +50,7 @@ static final class And extends CombiningEvaluator {
 
         @Override
         public boolean matches(Element root, Element node) {
-            for (int i = 0; i < num; i++) {
+            for (int i = num - 1; i >= 0; i--) { // process backwards so that :matchText is evaled earlier, to catch parent query. todo - should redo matchText to virtually expand during match, not pre-match (see SelectorTest#findBetweenSpan)
                 Evaluator s = evaluators.get(i);
                 if (!s.matches(root, node))
                     return false;
@@ -60,7 +60,7 @@ public boolean matches(Element root, Element node) {
 
         @Override
         public String toString() {
-            return StringUtil.join(evaluators, " ");
+            return StringUtil.join(evaluators, "");
         }
     }
 

File: src/test/java/org/jsoup/select/SelectorTest.java
Patch:
@@ -871,6 +871,7 @@ public void containsData(Locale locale) {
     @Test public void findBetweenSpan() {
         Document doc = Jsoup.parse("<p><span>One</span> Two <span>Three</span>");
         Elements els = doc.select("span ~ p:matchText"); // the Two becomes its own p, sibling of the span
+        // todo - think this should really be 'p:matchText span ~ p'. The :matchText should behave as a modifier to expand the nodes.
 
         assertEquals(1, els.size());
         assertEquals("Two", els.text());

File: src/main/java/org/jsoup/nodes/Document.java
Patch:
@@ -354,7 +354,7 @@ private void ensureMetaCharsetElement() {
                 }
                 select("meta[name=charset]").remove(); // Remove obsolete elements
             } else if (syntax == OutputSettings.Syntax.xml) {
-                Node node = childNodes().get(0);
+                Node node = ensureChildNodes().get(0);
                 if (node instanceof XmlDeclaration) {
                     XmlDeclaration decl = (XmlDeclaration) node;
                     if (decl.name().equals("xml")) {

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -357,10 +357,10 @@ private void addSiblingHtml(int index, String html) {
     public Node wrap(String html) {
         Validate.notEmpty(html);
 
-        // Parse context - this if element or parent if element else null
+        // Parse context - parent (because wrapping), this, or null
         Element context =
-            this instanceof Element ? (Element) this :
-                parentNode != null && parentNode instanceof Element ? (Element) parentNode :
+            parentNode != null && parentNode instanceof Element ? (Element) parentNode :
+                this instanceof Element ? (Element) this :
                     null;
         List<Node> wrapChildren = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());
         Node wrapNode = wrapChildren.get(0);

File: src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java
Patch:
@@ -18,7 +18,8 @@ static List<Object[]> findConstantArrays(Class aClass) {
         Field[] fields = aClass.getDeclaredFields();
 
         for (Field field : fields) {
-            if (Modifier.isStatic(field.getModifiers()) && field.getType().isArray()) {
+            int modifiers = field.getModifiers();
+            if (Modifier.isStatic(modifiers) && !Modifier.isPrivate(modifiers) && field.getType().isArray()) {
                 try {
                     array.add((Object[]) field.get(null));
                 } catch (IllegalAccessException e) {

File: src/main/java/org/jsoup/parser/XmlTreeBuilder.java
Patch:
@@ -31,7 +31,9 @@ ParseSettings defaultSettings() {
     protected void initialiseParse(Reader input, String baseUri, Parser parser) {
         super.initialiseParse(input, baseUri, parser);
         stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)
-        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);
+        doc.outputSettings()
+            .syntax(Document.OutputSettings.Syntax.xml)
+            .prettyPrint(false); // as XML, we don't understand what whitespace is significant or not
     }
 
     Document parse(Reader input, String baseUri) {

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -323,7 +323,7 @@ public Elements children() {
      * TODO - think about pulling this out as a helper as there are other shadow lists (like in Attributes) kept around.
      * @return a list of child elements
      */
-    private List<Element> childElementsList() {
+    List<Element> childElementsList() {
         List<Element> children;
         if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {
             final int size = childNodes.size();
@@ -433,7 +433,7 @@ public Elements select(Evaluator evaluator) {
      * @param cssQuery cssQuery a {@link Selector} CSS-like query
      * @return the first matching element, or <b>{@code null}</b> if there is no match.
      */
-    public Element selectFirst(String cssQuery) {
+    public @Nullable Element selectFirst(String cssQuery) {
         return Selector.selectFirst(cssQuery, this);
     }
 
@@ -445,7 +445,7 @@ public Element selectFirst(String cssQuery) {
      * @return the first matching element (walking down the tree, starting from this element), or {@code null} if none
      *     matchn.
      */
-    public Element selectFirst(Evaluator evaluator) {
+    public @Nullable Element selectFirst(Evaluator evaluator) {
         return Collector.findFirst(evaluator, this);
     }
 

File: src/main/java/org/jsoup/safety/Cleaner.java
Patch:
@@ -33,7 +33,7 @@
  </p>
  */
 public class Cleaner {
-    private Safelist safelist;
+    private final Safelist safelist;
 
     /**
      Create a new cleaner, that sanitizes documents using the supplied safelist.
@@ -51,7 +51,7 @@ public Cleaner(Safelist safelist) {
     @Deprecated
     public Cleaner(Whitelist whitelist) {
         Validate.notNull(whitelist);
-        new Cleaner((Safelist) whitelist);
+        this.safelist = whitelist;
     }
 
     /**

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -3,6 +3,7 @@
 import org.jsoup.helper.Validate;
 import org.jsoup.nodes.Element;
 
+import javax.annotation.Nullable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.IdentityHashMap;
@@ -155,7 +156,7 @@ static Elements filterOut(Collection<Element> elements, Collection<Element> outs
      * @param root root element to descend into
      * @return the matching element, or <b>null</b> if none.
      */
-    public static Element selectFirst(String cssQuery, Element root) {
+    public static @Nullable Element selectFirst(String cssQuery, Element root) {
         Validate.notEmpty(cssQuery);
         return Collector.findFirst(QueryParser.parse(cssQuery), root);
     }

File: src/test/java/org/jsoup/integration/ConnectTest.java
Patch:
@@ -470,9 +470,10 @@ public void testBinaryContentTypeThrowsException() {
         con.data(FileServlet.ContentTypeParam, "application/rss+xml");
         Document doc = con.get();
         Element title = doc.selectFirst("title");
+        assertNotNull(title);
         assertEquals("jsoup RSS news", title.text());
         assertEquals("channel", title.parent().nodeName());
-        assertEquals("jsoup RSS news", doc.title());
+        assertEquals("", doc.title()); // the document title is unset, this tag is channel>title, not html>head>title
         assertEquals(3, doc.select("link").size());
         assertEquals("application/rss+xml", con.response().contentType());
         assertEquals(Document.OutputSettings.Syntax.xml, doc.outputSettings().syntax());

File: src/main/java/org/jsoup/nodes/Comment.java
Patch:
@@ -3,6 +3,7 @@
 import org.jsoup.Jsoup;
 import org.jsoup.parser.Parser;
 
+import javax.annotation.Nullable;
 import java.io.IOException;
 
 /**
@@ -69,7 +70,7 @@ public boolean isXmlDeclaration() {
      * Attempt to cast this comment to an XML Declaration note.
      * @return an XML declaration if it could be parsed as one, null otherwise.
      */
-    public XmlDeclaration asXmlDeclaration() {
+    public @Nullable XmlDeclaration asXmlDeclaration() {
         String data = getData();
         Document doc = Jsoup.parse("<" + data.substring(1, data.length() -1) + ">", baseUri(), Parser.xmlParser());
         XmlDeclaration decl = null;

File: src/main/java/org/jsoup/nodes/Entities.java
Patch:
@@ -45,7 +45,7 @@ public enum EscapeMode {
         private int[] codeVals; // limitation is the few references with multiple characters; those go into multipoints.
 
         // table of codepoints to named entities.
-        private int[] codeKeys; // we don' support multicodepoints to single named value currently
+        private int[] codeKeys; // we don't support multicodepoints to single named value currently
         private String[] nameVals;
 
         EscapeMode(String file, int size) {

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -12,6 +12,7 @@
 import org.jsoup.nodes.TextNode;
 import org.jsoup.select.Elements;
 
+import javax.annotation.Nullable;
 import javax.annotation.ParametersAreNonnullByDefault;
 import java.io.Reader;
 import java.io.StringReader;
@@ -80,7 +81,7 @@ protected void initialiseParse(Reader input, String baseUri, Parser parser) {
         fragmentParsing = false;
     }
 
-    List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) {
+    List<Node> parseFragment(String inputFragment, @Nullable Element context, String baseUri, Parser parser) {
         // context may be null
         state = HtmlTreeBuilderState.Initial;
         initialiseParse(new StringReader(inputFragment), baseUri, parser);

File: src/main/java/org/jsoup/safety/package-info.java
Patch:
@@ -1,4 +1,4 @@
 /**
- Contains the jsoup HTML cleaner, and whitelist definitions.
+ Contains the jsoup HTML cleaner, and safelist definitions.
  */
 package org.jsoup.safety;

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -176,7 +176,7 @@ public Tag tag() {
     
     /**
      * Test if this element is a block-level element. (E.g. {@code <div> == true} or an inline element
-     * {@code <p> == false}).
+     * {@code <span> == false}).
      * 
      * @return true if block, false if not (and thus inline)
      */

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -196,7 +196,7 @@ void error(HtmlTreeBuilderState state) {
 
     Element insert(final Token.StartTag startTag) {
         // cleanup duplicate attributes:
-        if (startTag.attributes != null && !startTag.attributes.isEmpty()) {
+        if (startTag.hasAttributes() && !startTag.attributes.isEmpty()) {
             int dupes = startTag.attributes.deduplicate(settings);
             if (dupes > 0) {
                 error("Duplicate attribute");

File: src/main/java/org/jsoup/parser/Tokeniser.java
Patch:
@@ -85,7 +85,7 @@ void emit(Token token) {
             lastStartTag = startTag.tagName;
         } else if (token.type == Token.TokenType.EndTag) {
             Token.EndTag endTag = (Token.EndTag) token;
-            if (endTag.attributes != null)
+            if (endTag.hasAttributes())
                 error("Attributes incorrectly present on end tag");
         }
     }

File: src/main/java/org/jsoup/parser/XmlTreeBuilder.java
Patch:
@@ -75,7 +75,7 @@ private void insertNode(Node node) {
     Element insert(Token.StartTag startTag) {
         Tag tag = Tag.valueOf(startTag.name(), settings);
         // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.
-        if (startTag.attributes != null)
+        if (startTag.hasAttributes())
             startTag.attributes.deduplicate(settings);
 
         Element el = new Element(tag, null, settings.normalizeAttributes(startTag.attributes));

File: src/main/java/org/jsoup/nodes/Document.java
Patch:
@@ -9,6 +9,7 @@
 
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -398,7 +399,7 @@ public enum Syntax {html, xml}
         private Syntax syntax = Syntax.html;
 
         public OutputSettings() {
-            charset(Charset.forName("UTF8"));
+            charset(StandardCharsets.UTF_8);
         }
         
         /**

File: src/main/java/org/jsoup/parser/Token.java
Patch:
@@ -252,7 +252,7 @@ final static class EndTag extends Tag{
 
         @Override
         public String toString() {
-            return "</" + name() + ">";
+            return "</" + (tagName != null ? tagName : "(unset)") + ">";
         }
     }
 

File: src/main/java/org/jsoup/internal/StringUtil.java
Patch:
@@ -237,7 +237,6 @@ public static String resolve(final String baseUrl, final String relUrl) {
      * <p>
      * Care must be taken to release the builder once its work has been completed, with {@link #releaseBuilder}
      * @return an empty StringBuilder
-     * @
      */
     public static StringBuilder borrowBuilder() {
         synchronized (builders) {

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -135,8 +135,9 @@ public String tagName() {
 
     /**
      * Get the normalized name of this Element's tag. This will always be the lowercased version of the tag, regardless
-     * of the tag case preserving setting of the parser.
-     * @return
+     * of the tag case preserving setting of the parser. For e.g., {@code <DIV>} and {@code <div>} both have a
+     * normal name of {@code div}.
+     * @return normal name
      */
     public String normalName() {
         return tag.normalName();

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -1243,8 +1243,8 @@ else if (name.equals("option")) {
                         tb.insert(start);
                     } else if (name.equals("optgroup")) {
                         if (tb.currentElement().normalName().equals("option"))
-                            tb.processEndTag("option");
-                        else if (tb.currentElement().normalName().equals("optgroup"))
+                            tb.processEndTag("option"); // pop option and flow to pop optgroup
+                        if (tb.currentElement().normalName().equals("optgroup"))
                             tb.processEndTag("optgroup");
                         tb.insert(start);
                     } else if (name.equals("select")) {

File: src/main/java/org/jsoup/helper/W3CDom.java
Patch:
@@ -6,6 +6,7 @@
 import org.jsoup.select.NodeTraversor;
 import org.jsoup.select.NodeVisitor;
 import org.w3c.dom.Comment;
+import org.w3c.dom.DOMConfiguration;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.Text;
@@ -23,8 +24,7 @@
 import java.util.Properties;
 import java.util.Stack;
 
-import static javax.xml.transform.OutputKeys.INDENT;
-import static javax.xml.transform.OutputKeys.METHOD;
+import static javax.xml.transform.OutputKeys.*;
 
 /**
  * Helper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},
@@ -46,6 +46,7 @@ public Document fromJsoup(org.jsoup.nodes.Document in) {
         	factory.setNamespaceAware(true);
             builder = factory.newDocumentBuilder();
             Document out = builder.newDocument();
+            out.setXmlStandalone(true);
             convert(in, out);
             return out;
         } catch (ParserConfigurationException e) {

File: src/main/java/org/jsoup/nodes/TextNode.java
Patch:
@@ -97,8 +97,7 @@ void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) thr
         if (out.prettyPrint() && ((siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank()) || (out.outline() && siblingNodes().size()>0 && !isBlank()) ))
             indent(accum, depth, out);
 
-        boolean normaliseWhite = out.prettyPrint() && parent() instanceof Element
-                && !Element.preserveWhitespace(parent());
+        boolean normaliseWhite = out.prettyPrint() && !Element.preserveWhitespace(parent());
         Entities.escape(accum, coreValue(), out, false, normaliseWhite, false);
     }
 

File: src/test/java/org/jsoup/parser/HtmlParserTest.java
Patch:
@@ -694,8 +694,7 @@ public class HtmlParserTest {
         // and the <i> inside the table and does not leak out.
         String h = "<p><b>One</p> <table><tr><td><p><i>Three<p>Four</i></td></tr></table> <p>Five</p>";
         Document doc = Jsoup.parse(h);
-        String want = "<p><b>One</b></p>\n" +
-            "<b> \n" +
+        String want = "<p><b>One</b></p><b> \n" +
             " <table>\n" +
             "  <tbody>\n" +
             "   <tr>\n" +
@@ -1033,7 +1032,7 @@ public void testInvalidTableContents() throws IOException {
     @Test public void testNormalisesIsIndex() {
         Document doc = Jsoup.parse("<body><isindex action='/submit'></body>");
         String html = doc.outerHtml();
-        assertEquals("<form action=\"/submit\"> <hr> <label>This is a searchable index. Enter search keywords: <input name=\"isindex\"></label> <hr> </form>",
+        assertEquals("<form action=\"/submit\"> <hr><label>This is a searchable index. Enter search keywords: <input name=\"isindex\"></label> <hr> </form>",
             StringUtil.normaliseWhitespace(doc.body().html()));
     }
 

File: src/test/java/org/jsoup/parser/TagTest.java
Patch:
@@ -64,7 +64,7 @@ public class TagTest {
         Tag foo2 = Tag.valueOf("FOO");
 
         assertEquals(foo, foo2);
-        assertTrue(foo.isInline());
+        assertFalse(foo.isInline());
         assertTrue(foo.formatAsBlock());
     }
 

File: src/test/java/org/jsoup/safety/CleanerTest.java
Patch:
@@ -310,6 +310,6 @@ public void bailsIfRemovingProtocolThatsNotSet() {
         String dirty = "<a>One</a> <a href>Two</a>";
         Whitelist relaxedWithAnchor = Whitelist.relaxed().addProtocols("a", "href", "#");
         String clean = Jsoup.clean(dirty, relaxedWithAnchor);
-        assertEquals("<a>One</a> \n<a>Two</a>", clean);
+        assertEquals("<a>One</a> <a>Two</a>", clean);
     }
 }

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -613,6 +613,7 @@ public Element after(Node node) {
      * Remove all of the element's child nodes. Any attributes are left as-is.
      * @return this element
      */
+    @Override
     public Element empty() {
         childNodes.clear();
         return this;

File: src/main/java/org/jsoup/select/QueryParser.java
Patch:
@@ -27,6 +27,8 @@ public class QueryParser {
      * @param query CSS query
      */
     private QueryParser(String query) {
+        Validate.notEmpty(query);
+        query = query.trim();
         this.query = query;
         this.tq = new TokenQueue(query);
     }

File: src/main/java/org/jsoup/select/Evaluator.java
Patch:
@@ -47,7 +47,7 @@ public Tag(String tagName) {
 
         @Override
         public boolean matches(Element root, Element element) {
-            return (element.tagName().equalsIgnoreCase(tagName));
+            return (element.normalName().equals(tagName));
         }
 
         @Override
@@ -69,7 +69,7 @@ public TagEndsWith(String tagName) {
 
         @Override
         public boolean matches(Element root, Element element) {
-            return (element.tagName().endsWith(tagName));
+            return (element.normalName().endsWith(tagName));
         }
 
         @Override

File: src/main/java/org/jsoup/internal/StringUtil.java
Patch:
@@ -132,8 +132,8 @@ public static boolean isActuallyWhitespace(int c){
     }
 
     public static boolean isInvisibleChar(int c) {
-        return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);
-        // zero width sp, zw non join, zw join, soft hyphen
+        return c == 8203 || c == 173; // zero width sp, soft hyphen
+        // previously also included zw non join, zw join - but removing those breaks semantic meaning of text
     }
 
     /**

File: src/main/java/org/jsoup/select/Evaluator.java
Patch:
@@ -237,7 +237,7 @@ public String toString() {
      */
     public static final class AttributeWithValueEnding extends AttributeKeyPair {
         public AttributeWithValueEnding(String key, String value) {
-            super(key, value);
+            super(key, value, false);
         }
 
         @Override

File: src/main/java/org/jsoup/parser/CharacterReader.java
Patch:
@@ -16,7 +16,7 @@ public final class CharacterReader {
     static final char EOF = (char) -1;
     private static final int maxStringCacheLen = 12;
     static final int maxBufferLen = 1024 * 32; // visible for testing
-    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);
+    static final int readAheadLimit = (int) (maxBufferLen * 0.75); // visible for testing
     private static final int minReadAheadLen = 1024; // the minimum mark length supported. No HTML entities can be larger than this.
 
     private final char[] charBuf;

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -57,7 +57,7 @@ public class HttpConnection implements Connection {
      * vs in jsoup, which would otherwise default to {@code Java}. So by default, use a desktop UA.
      */
     public static final String DEFAULT_UA =
-        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36";
+        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36";
     private static final String USER_AGENT = "User-Agent";
     public static final String CONTENT_TYPE = "Content-Type";
     public static final String MULTIPART_FORM_DATA = "multipart/form-data";
@@ -551,7 +551,7 @@ public static class Request extends HttpConnection.Base<Connection.Request> impl
 
         Request() {
             timeoutMilliseconds = 30000; // 30 seconds
-            maxBodySizeBytes = 1024 * 1024; // 1MB
+            maxBodySizeBytes = 1024 * 1024 * 2; // 2MB
             followRedirects = true;
             data = new ArrayList<>();
             method = Method.GET;

File: src/main/java/org/jsoup/nodes/FormElement.java
Patch:
@@ -86,7 +86,9 @@ public List<Connection.KeyVal> formData() {
             if (name.length() == 0) continue;
             String type = el.attr("type");
 
-            if ("select".equals(el.tagName())) {
+            if (type.equalsIgnoreCase("button")) continue; // browsers don't submit these
+
+            if ("select".equals(el.normalName())) {
                 Elements options = el.select("option[selected]");
                 boolean set = false;
                 for (Element option: options) {

File: src/test/java/org/jsoup/nodes/FormElementTest.java
Patch:
@@ -30,6 +30,7 @@ public class FormElementTest {
                 "<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>" +
                 "<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>" +
                 "<input name='ten' value='text' disabled>" +
+                "<input name='eleven' value='text' type='button'>" +
                 "</form>";
         Document doc = Jsoup.parse(html);
         FormElement form = (FormElement) doc.select("form").first();
@@ -44,6 +45,7 @@ public class FormElementTest {
         assertEquals("eight=on", data.get(5).toString()); // default
         // nine should not appear, not checked checkbox
         // ten should not appear, disabled
+        // eleven should not appear, button
     }
 
     @Test public void formDataUsesFirstAttribute() {

File: src/main/java/org/jsoup/parser/Token.java
Patch:
@@ -112,7 +112,8 @@ else if (hasEmptyAttributeValue)
                         value = "";
                     else
                         value = null;
-                    attributes.put(pendingAttributeName, value);
+                    // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known (the appropriate tree builder).
+                    attributes.add(pendingAttributeName, value);
                 }
             }
             pendingAttributeName = null;
@@ -125,7 +126,6 @@ else if (hasEmptyAttributeValue)
         final void finaliseTag() {
             // finalises for emit
             if (pendingAttributeName != null) {
-                // todo: check if attribute name exists; if so, drop and error
                 newAttribute();
             }
         }

File: src/main/java/org/jsoup/parser/XmlTreeBuilder.java
Patch:
@@ -75,6 +75,8 @@ private void insertNode(Node node) {
     Element insert(Token.StartTag startTag) {
         Tag tag = Tag.valueOf(startTag.name(), settings);
         // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.
+        startTag.attributes.deduplicate(settings);
+
         Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));
         insertNode(el);
         if (startTag.isSelfClosing()) {

File: src/main/java/org/jsoup/helper/DataUtil.java
Patch:
@@ -99,12 +99,11 @@ static Document parseInputStream(InputStream input, String charsetName, String b
         input = ConstrainableInputStream.wrap(input, bufferSize, 0);
 
         Document doc = null;
-        boolean fullyRead = false;
 
         // read the start of the stream and look for a BOM or meta charset
         input.mark(bufferSize);
         ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.
-        fullyRead = input.read() == -1;
+        boolean fullyRead = (input.read() == -1);
         input.reset();
 
         // look for BOM - overrides any other header or input

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -446,7 +446,7 @@ public T header(String name, String value) {
 
         public boolean hasHeader(String name) {
             Validate.notEmpty(name, "Header name must not be empty");
-            return getHeadersCaseInsensitive(name).size() != 0;
+            return !getHeadersCaseInsensitive(name).isEmpty();
         }
 
         /**

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -204,7 +204,7 @@ Element insert(Token.StartTag startTag) {
             tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing
             return el;
         }
-        
+
         Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));
         insert(el);
         return el;
@@ -268,7 +268,7 @@ else if (tagName.equals("script") || tagName.equals("style"))
 
     private void insertNode(Node node) {
         // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc
-        if (stack.size() == 0)
+        if (stack.isEmpty())
             doc.appendChild(node);
         else if (isFosterInserts())
             insertInFosterParent(node);

File: src/main/java/org/jsoup/safety/Cleaner.java
Patch:
@@ -77,7 +77,7 @@ public boolean isValid(Document dirtyDocument) {
         Document clean = Document.createShell(dirtyDocument.baseUri());
         int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());
         return numDiscarded == 0
-            && dirtyDocument.head().childNodes().size() == 0; // because we only look at the body, but we start from a shell, make sure there's nothing in the head
+            && dirtyDocument.head().childNodes().isEmpty(); // because we only look at the body, but we start from a shell, make sure there's nothing in the head
     }
 
     public boolean isValidBodyHtml(String bodyHtml) {
@@ -87,7 +87,7 @@ public boolean isValidBodyHtml(String bodyHtml) {
         List<Node> nodes = Parser.parseFragment(bodyHtml, dirty.body(), "", errorList);
         dirty.body().insertChildren(0, nodes);
         int numDiscarded = copySafeNodes(dirty.body(), clean.body());
-        return numDiscarded == 0 && errorList.size() == 0;
+        return numDiscarded == 0 && errorList.isEmpty();
     }
 
     /**

File: src/test/java/org/jsoup/MultiLocaleRule.java
Patch:
@@ -13,6 +13,7 @@ public class MultiLocaleRule implements TestRule {
     public @interface MultiLocaleTest {
     }
 
+    @Override
     public Statement apply(final Statement statement, final Description description) {
         return new Statement() {
             @Override

File: src/test/java/org/jsoup/TextUtil.java
Patch:
@@ -6,7 +6,6 @@
  @author Jonathan Hedley, jonathan@hedley.net */
 public class TextUtil {
     public static String stripNewlines(String text) {
-        text = text.replaceAll("\\r?\\n\\s*", "");
-        return text;
+        return text.replaceAll("\\r?\\n\\s*", "");
     }
 }

File: src/test/java/org/jsoup/parser/TokeniserTest.java
Patch:
@@ -33,7 +33,7 @@ public void bufferUpInAttributeVal() {
             }
 
             sb.append('X'); // First character to cross character buffer boundary
-            sb.append(tail + quote + ">\n");
+            sb.append(tail).append(quote).append(">\n");
 
             String html = sb.toString();
             Document doc = Jsoup.parse(html);

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -104,7 +104,7 @@ public boolean hasAttr(String attributeKey) {
     }
 
     /**
-     * Remove an attribute from this element.
+     * Remove an attribute from this node.
      * @param attributeKey The attribute to remove.
      * @return this (for chaining)
      */

File: src/main/java/org/jsoup/select/StructuralEvaluator.java
Patch:
@@ -21,7 +21,7 @@ public Has(Evaluator evaluator) {
 
         public boolean matches(Element root, Element element) {
             for (Element e : element.getAllElements()) {
-                if (e != element && evaluator.matches(root, e))
+                if (e != element && evaluator.matches(element, e))
                     return true;
             }
             return false;

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -1021,7 +1021,7 @@ public Elements getElementsMatchingOwnText(Pattern pattern) {
     }
     
     /**
-     * Find elements whose text matches the supplied regular expression.
+     * Find elements whose own text matches the supplied regular expression.
      * @param regex regular expression to match text against. You can use <a href="http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded">embedded flags</a> (such as (?i) and (?m) to control regex options.
      * @return elements matching the supplied regular expression.
      * @see Element#ownText()

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -66,7 +66,7 @@
  * <tr><td><code>:last-child</code></td><td>elements that are the last child of some other element.</td><td><code>ol {@literal >} li:last-child</code></td></tr>
  * <tr><td><code>:first-of-type</code></td><td>elements that are the first sibling of its type in the list of children of its parent element</td><td><code>dl dt:first-of-type</code></td></tr>
  * <tr><td><code>:last-of-type</code></td><td>elements that are the last sibling of its type in the list of children of its parent element</td><td><code>tr {@literal >} td:last-of-type</code></td></tr>
- * <tr><td><code>:only-child</code></td><td>elements that have a parent element and whose parent element hasve no other element children</td><td></td></tr>
+ * <tr><td><code>:only-child</code></td><td>elements that have a parent element and whose parent element have no other element children</td><td></td></tr>
  * <tr><td><code>:only-of-type</code></td><td> an element that has a parent element and whose parent element has no other element children with the same expanded element name</td><td></td></tr>
  * <tr><td><code>:empty</code></td><td>elements that have no children at all</td><td></td></tr>
  * </table>

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -421,6 +421,9 @@ private static boolean looksLikeUtf8(byte[] input) {
                     return false;
                 }
 
+                if (end >= input.length)
+                    return false;
+
                 while (i < end) {
                     i++;
                     o = input[i];

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -85,14 +85,15 @@ public String getValue() {
      @param val the new attribute value; must not be null
      */
     public String setValue(String val) {
-        String oldVal = parent.get(this.key);
+        String oldVal = this.val;
         if (parent != null) {
+            oldVal = parent.get(this.key); // trust the container more
             int i = parent.indexOfKey(this.key);
             if (i != Attributes.NotFound)
                 parent.vals[i] = val;
         }
         this.val = val;
-        return oldVal;
+        return Attributes.checkNotNull(oldVal);
     }
 
     /**

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -77,7 +77,7 @@ public void setKey(String key) {
      @return the attribute value
      */
     public String getValue() {
-        return val;
+        return Attributes.checkNotNull(val);
     }
 
     /**

File: src/main/java/org/jsoup/parser/Token.java
Patch:
@@ -130,12 +130,14 @@ final void finaliseTag() {
             }
         }
 
+        /** Preserves case */
         final String name() { // preserves case, for input into Tag.valueOf (which may drop case)
             Validate.isFalse(tagName == null || tagName.length() == 0);
             return tagName;
         }
 
-        final String normalName() { // loses case, used in tree building for working out where in tree it should go
+        /** Lower case */
+        final String normalName() { // lower case, used in tree building for working out where in tree it should go
             return normalName;
         }
 

File: src/main/java/org/jsoup/nodes/Comment.java
Patch:
@@ -75,7 +75,7 @@ public XmlDeclaration asXmlDeclaration() {
         String data = getData();
         Document doc = Jsoup.parse("<" + data.substring(1, data.length() -1) + ">", baseUri(), Parser.xmlParser());
         XmlDeclaration decl = null;
-        if (doc.childNodeSize() > 0) {
+        if (doc.children().size() > 0) {
             Element el = doc.child(0);
             decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith("!"));
             decl.attributes().addAll(el.attributes());

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -41,8 +41,9 @@ public Attribute(String key, String value) {
      * @see #createFromEncoded*/
     public Attribute(String key, String val, Attributes parent) {
         Validate.notNull(key);
-        this.key = key.trim();
+        key = key.trim();
         Validate.notEmpty(key); // trimming could potentially make empty, so validate here
+        this.key = key;
         this.val = val;
         this.parent = parent;
     }

File: src/main/java/org/jsoup/parser/CharacterReader.java
Patch:
@@ -243,14 +243,15 @@ String consumeData() {
 
     String consumeTagName() {
         // '\t', '\n', '\r', '\f', ' ', '/', '>', nullChar
+        // NOTE: out of spec, added '<' to fix common author bugs
         bufferUp();
         final int start = bufPos;
         final int remaining = bufLength;
         final char[] val = charBuf;
 
         while (bufPos < remaining) {
             final char c = val[bufPos];
-            if (c == '\t'|| c ==  '\n'|| c ==  '\r'|| c ==  '\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)
+            if (c == '\t'|| c ==  '\n'|| c ==  '\r'|| c ==  '\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)
                 break;
             bufPos++;
         }

File: src/main/java/org/jsoup/parser/ParseSettings.java
Patch:
@@ -35,14 +35,14 @@ public ParseSettings(boolean tag, boolean attribute) {
         preserveAttributeCase = attribute;
     }
 
-    String normalizeTag(String name) {
+    public String normalizeTag(String name) {
         name = name.trim();
         if (!preserveTagCase)
             name = lowerCase(name);
         return name;
     }
 
-    String normalizeAttribute(String name) {
+    public String normalizeAttribute(String name) {
         name = name.trim();
         if (!preserveAttributeCase)
             name = lowerCase(name);

File: src/test/java/org/jsoup/nodes/ElementTest.java
Patch:
@@ -384,8 +384,8 @@ public class ElementTest {
         Element div = doc.getElementById("1");
         div.appendElement("p").text("there");
         div.appendElement("P").attr("CLASS", "second").text("now");
-        // manually specifying tag and attributes should now preserve case, regardless of parse mode
-        assertEquals("<html><head></head><body><div id=\"1\"><p>Hello</p><p>there</p><P CLASS=\"second\">now</P></div></body></html>",
+        // manually specifying tag and attributes should maintain case based on parser settings
+        assertEquals("<html><head></head><body><div id=\"1\"><p>Hello</p><p>there</p><p class=\"second\">now</p></div></body></html>",
                 TextUtil.stripNewlines(doc.html()));
 
         // check sibling index (with short circuit on reindexChildren):

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -56,8 +56,6 @@ public class HtmlTreeBuilder extends TreeBuilder {
     private boolean fosterInserts; // if next inserts should be fostered
     private boolean fragmentParsing; // if parsing a fragment of html
 
-    HtmlTreeBuilder() {}
-
     ParseSettings defaultSettings() {
         return ParseSettings.htmlDefault;
     }

File: src/main/java/org/jsoup/parser/Token.java
Patch:
@@ -381,7 +381,7 @@ final boolean isEOF() {
         return type == TokenType.EOF;
     }
 
-    enum TokenType {
+    public enum TokenType {
         Doctype,
         StartTag,
         EndTag,

File: src/main/java/org/jsoup/Connection.java
Patch:
@@ -724,6 +724,7 @@ interface Response extends Base<Response> {
          * same connection response (otherwise, once the response is read, its InputStream will have been drained and
          * may not be re-read). Calling {@link #body() } or {@link #bodyAsBytes()} has the same effect.
          * @return this response, for chaining
+         * @throws UncheckedIOException if an IO exception occurs during buffering.
          */
         Response bufferUp();
 

File: src/main/java/org/jsoup/UncheckedIOException.java
Patch:
@@ -2,7 +2,7 @@
 
 import java.io.IOException;
 
-public class UncheckedIOException extends Error {
+public class UncheckedIOException extends RuntimeException {
     public UncheckedIOException(IOException cause) {
         super(cause);
     }

File: src/test/java/org/jsoup/parser/CharacterReaderTest.java
Patch:
@@ -13,6 +13,7 @@
  * @author Jonathan Hedley, jonathan@hedley.net
  */
 public class CharacterReaderTest {
+    public final static int maxBufferLen = CharacterReader.maxBufferLen;
 
     @Test public void consume() {
         CharacterReader r = new CharacterReader("one");

File: src/main/java/org/jsoup/parser/XmlTreeBuilder.java
Patch:
@@ -114,7 +114,7 @@ void insert(Token.Doctype d) {
      * @param endTag tag to close
      */
     private void popStackToClose(Token.EndTag endTag) {
-        String elName = endTag.normalName();
+        String elName = settings.normalizeTag(endTag.tagName);
         Element firstFound = null;
 
         for (int pos = stack.size() -1; pos >= 0; pos--) {

File: src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java
Patch:
@@ -179,9 +179,9 @@ public void testCreatesValidProlog() {
 
     @Test
     public void preservesCaseByDefault() {
-        String xml = "<TEST ID=1>Check</TEST>";
+        String xml = "<CHECK>One</CHECK><TEST ID=1>Check</TEST>";
         Document doc = Jsoup.parse(xml, "", Parser.xmlParser());
-        assertEquals("<TEST ID=\"1\">Check</TEST>", TextUtil.stripNewlines(doc.html()));
+        assertEquals("<CHECK>One</CHECK><TEST ID=\"1\">Check</TEST>", TextUtil.stripNewlines(doc.html()));
     }
 
     @Test

File: src/main/java/org/jsoup/parser/XmlTreeBuilder.java
Patch:
@@ -114,7 +114,7 @@ void insert(Token.Doctype d) {
      * @param endTag tag to close
      */
     private void popStackToClose(Token.EndTag endTag) {
-        String elName = endTag.name();
+        String elName = endTag.normalName();
         Element firstFound = null;
 
         for (int pos = stack.size() -1; pos >= 0; pos--) {

File: src/main/java/org/jsoup/helper/DataUtil.java
Patch:
@@ -99,8 +99,8 @@ static Document parseInputStream(InputStream input, String charsetName, String b
         boolean fullyRead = false;
 
         // read the start of the stream and look for a BOM or meta charset
-        input.mark(firstReadBufferSize);
-        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed
+        input.mark(bufferSize);
+        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.
         fullyRead = input.read() == -1;
         input.reset();
 

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -379,7 +379,7 @@ boolean process(Token t, HtmlTreeBuilder tb) {
                             tb.processEndTag("p");
                         }
                         tb.insert(startTag);
-                        // todo: ignore LF if next token
+                        tb.reader.matchConsume("\n"); // ignore LF if next token
                         tb.framesetOk(false);
                     } else if (name.equals("form")) {
                         if (tb.getFormElement() != null) {

File: src/main/java/org/jsoup/nodes/Attributes.java
Patch:
@@ -316,9 +316,7 @@ final void html(final Appendable accum, final Document.OutputSettings out) throw
             accum.append(' ').append(key);
 
             // collapse checked=null, checked="", checked=checked; write out others
-            if (!(out.syntax() == Document.OutputSettings.Syntax.html
-                && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {
-
+            if (!Attribute.shouldCollapseAttribute(key, val, out)) {
                 accum.append("=\"");
                 Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);
                 accum.append('"');

File: src/main/java/org/jsoup/helper/StringUtil.java
Patch:
@@ -227,7 +227,7 @@ public static String resolve(final String baseUrl, final String relUrl) {
     }
 
     /**
-     * Maintains a cached StringBuilder, to minimize new StringBuilder GCs. Prevents it from growing to big per thread.
+     * Maintains a cached StringBuilder, to minimize new StringBuilder GCs. Prevents it from growing too big per thread.
      * Care must be taken to not grab more than one in the same stack (not locked or mutexed or anything).
      * @return an empty StringBuilder
      */

File: src/main/java/org/jsoup/nodes/TextNode.java
Patch:
@@ -43,7 +43,7 @@ public String nodeName() {
      * @see TextNode#getWholeText()
      */
     public String text() {
-        return normaliseWhitespace(getWholeText());
+        return StringUtil.normaliseWhitespace(getWholeText());
     }
     
     /**

File: src/main/java/org/jsoup/parser/TokeniserState.java
Patch:
@@ -917,6 +917,7 @@ void read(Tokeniser t, CharacterReader r) {
                 // todo: should actually check current namepspace, and only non-html allows cdata. until namespace
                 // is implemented properly, keep handling as cdata
                 //} else if (!t.currentNodeInHtmlNS() && r.matchConsume("[CDATA[")) {
+                t.createTempBuffer();
                 t.transition(CdataSection);
             } else {
                 t.error(this);
@@ -1600,8 +1601,9 @@ void read(Tokeniser t, CharacterReader r) {
     CdataSection {
         void read(Tokeniser t, CharacterReader r) {
             String data = r.consumeTo("]]>");
-            t.emit(data);
+            t.dataBuffer.append(data);
             if (r.matchConsume("]]>") || r.isEmpty()) {
+                t.emit(new Token.CData(t.dataBuffer.toString()));
                 t.transition(Data);
             }// otherwise, buffer underrun, stay in data section
         }

File: src/main/java/org/jsoup/parser/XmlTreeBuilder.java
Patch:
@@ -96,9 +96,9 @@ void insert(Token.Comment commentToken) {
         insertNode(insert);
     }
 
-    void insert(Token.Character characterToken) {
-        Node node = new TextNode(characterToken.getData());
-        insertNode(node);
+    void insert(Token.Character token) {
+        final String data = token.getData();
+        insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));
     }
 
     void insert(Token.Doctype d) {

File: src/main/java/org/jsoup/nodes/Entities.java
Patch:
@@ -176,7 +176,7 @@ static void escape(Appendable accum, String string, Document.OutputSettings out,
         boolean lastWasWhite = false;
         boolean reachedNonWhite = false;
         final EscapeMode escapeMode = out.escapeMode();
-        final CharsetEncoder encoder = out.encoder != null ? out.encoder : out.prepareEncoder();
+        final CharsetEncoder encoder = out.encoder();
         final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()
         final int length = string.length();
 

File: src/main/java/org/jsoup/internal/Normalizer.java
Patch:
@@ -8,7 +8,7 @@
 public final class Normalizer {
 
     public static String lowerCase(final String input) {
-        return input.toLowerCase(Locale.ENGLISH);
+        return input != null ? input.toLowerCase(Locale.ENGLISH) : "";
     }
 
     public static String normalize(final String input) {

File: src/main/java/org/jsoup/parser/CharacterReader.java
Patch:
@@ -424,6 +424,8 @@ private static String cacheString(final char[] charBuf, final String[] stringCac
         // limit (no cache):
         if (count > maxStringCacheLen)
             return new String(charBuf, start, count);
+        if (count < 1)
+            return "";
 
         // calculate hash:
         int hash = 0;

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -54,6 +54,7 @@
  * <tr><td><code>:matchesOwn(<em>regex</em>)</code></td><td>elements whose own text matches the specified regular expression. The text must appear in the found element, not any of its descendants.</td><td><code>td:matchesOwn(\\d+)</code> finds table cells directly containing digits. <code>div:matchesOwn((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>
  * <tr><td><code>:containsData(<em>data</em>)</code></td><td>elements that contains the specified <em>data</em>. The contents of {@code script} and {@code style} elements, and {@code comment} nodes (etc) are considered data nodes, not text nodes. The search is case insensitive. The data may appear in the found element, or any of its descendants.</td><td><code>script:contains(jsoup)</code> finds script elements containing the data "jsoup".</td></tr>
  * <tr><td></td><td>The above may be combined in any order and with other selectors</td><td><code>.light:contains(name):eq(0)</code></td></tr>
+ * <tr><td><code>:matchText</code></td><td>treats text nodes as elements, and so allows you to match against and select text nodes.<p><b>Note</b> that using this selector will modify the DOM, so you may want to {@code clone} your document before using.</td><td>{@code p:matchText:firstChild} with input {@code <p>One<br />Two</p>} will return one {@link org.jsoup.nodes.PseudoTextElement} with text "{@code One}".</td></tr>
  * <tr><td colspan="3"><h3>Structural pseudo selectors</h3></td></tr>
  * <tr><td><code>:root</code></td><td>The element that is the root of the document. In HTML, this is the <code>html</code> element</td><td><code>:root</code></td></tr>
  * <tr><td><code>:nth-child(<em>a</em>n+<em>b</em>)</code></td><td><p>elements that have <code><em>a</em>n+<em>b</em>-1</code> siblings <b>before</b> it in the document tree, for any positive integer or zero value of <code>n</code>, and has a parent element. For values of <code>a</code> and <code>b</code> greater than zero, this effectively divides the element's children into groups of a elements (the last group taking the remainder), and selecting the <em>b</em>th element of each group. For example, this allows the selectors to address every other row in a table, and could be used to alternate the color of paragraph text in a cycle of four. The <code>a</code> and <code>b</code> values must be integers (positive, negative, or zero). The index of the first child of an element is 1.</p>

File: src/main/java/org/jsoup/internal/ConstrainableInputStream.java
Patch:
@@ -19,7 +19,7 @@ public final class ConstrainableInputStream extends BufferedInputStream {
     private final boolean capped;
     private final int maxSize;
     private long startTime;
-    private long timeout = -1; // optional max time of request
+    private long timeout = 0; // optional max time of request
     private int remaining;
     private boolean interrupted;
 
@@ -111,7 +111,7 @@ public ConstrainableInputStream timeout(long startTimeNanos, long timeoutMillis)
     }
 
     private boolean expired() {
-        if (timeout == -1)
+        if (timeout == 0)
             return false;
 
         final long now = System.nanoTime();

File: src/main/java/org/jsoup/parser/CharacterReader.java
Patch:
@@ -15,7 +15,7 @@
 public final class CharacterReader {
     static final char EOF = (char) -1;
     private static final int maxStringCacheLen = 12;
-    private static final int maxBufferLen = 1024 * 32;
+    static final int maxBufferLen = 1024 * 32; // visible for testing
     private static final int readAheadLimit = (int) (maxBufferLen * 0.75);
 
     private final char[] charBuf;

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -31,6 +31,7 @@
 import java.net.URI;
 import java.net.URL;
 import java.net.URLEncoder;
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 import java.nio.charset.IllegalCharsetNameException;
@@ -859,7 +860,7 @@ public String body() {
                 body = Charset.forName(DataUtil.defaultCharset).decode(byteData).toString();
             else
                 body = Charset.forName(charset).decode(byteData).toString();
-            byteData.rewind();
+            ((Buffer)byteData).rewind(); // cast to avoid covariant return type change in jdk9
             return body;
         }
 

File: src/main/java/org/jsoup/nodes/Document.java
Patch:
@@ -8,7 +8,6 @@
 
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
-import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -381,7 +380,7 @@ public enum Syntax {html, xml}
         private Syntax syntax = Syntax.html;
 
         public OutputSettings() {
-            charset(StandardCharsets.UTF_8);
+            charset(Charset.forName("UTF8"));
         }
         
         /**

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -357,11 +357,11 @@ void clearStackToTableContext() {
     }
 
     void clearStackToTableBodyContext() {
-        clearStackToContext("tbody", "tfoot", "thead");
+        clearStackToContext("tbody", "tfoot", "thead", "template");
     }
 
     void clearStackToTableRowContext() {
-        clearStackToContext("tr");
+        clearStackToContext("tr", "template");
     }
 
     private void clearStackToContext(String... nodeNames) {

File: src/main/java/org/jsoup/select/Evaluator.java
Patch:
@@ -340,7 +340,7 @@ public IndexLessThan(int index) {
 
         @Override
         public boolean matches(Element root, Element element) {
-            return element.elementSiblingIndex() < index;
+            return root != element && element.elementSiblingIndex() < index;
         }
 
         @Override

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -760,7 +760,7 @@ else if (!tb.onStack(formatEl)) {
         }
 
         boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {
-            String name = t.asEndTag().name(); // matches with case sensitivity if enabled
+            String name = tb.settings.normalizeTag(t.asEndTag().name()); // matches with case sensitivity if enabled
             ArrayList<Element> stack = tb.getStack();
             for (int pos = stack.size() -1; pos >= 0; pos--) {
                 Element node = stack.get(pos);

File: src/test/java/org/jsoup/TextUtil.java
Patch:
@@ -5,8 +5,6 @@
 
  @author Jonathan Hedley, jonathan@hedley.net */
 public class TextUtil {
-    public static final String LE = String.format("%n");
-
     public static String stripNewlines(String text) {
         text = text.replaceAll("\\n\\s*", "");
         return text;

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -1479,17 +1479,17 @@ private static boolean isWhitespace(String data) {
     }
 
     private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {
-        tb.insert(startTag);
         tb.tokeniser.transition(TokeniserState.Rcdata);
         tb.markInsertionMode();
         tb.transition(Text);
+        tb.insert(startTag);
     }
 
     private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {
-        tb.insert(startTag);
         tb.tokeniser.transition(TokeniserState.Rawtext);
         tb.markInsertionMode();
         tb.transition(Text);
+        tb.insert(startTag);
     }
 
     // lists of tags to search through. A little harder to read here, but causes less GC than dynamic varargs.

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -466,7 +466,6 @@ boolean process(Token t, HtmlTreeBuilder tb) {
                         if (tb.getFormElement() != null)
                             return false;
 
-                        tb.tokeniser.acknowledgeSelfClosingFlag();
                         tb.processStartTag("form");
                         if (startTag.attributes.hasKey("action")) {
                             Element form = tb.getFormElement();
@@ -540,12 +539,10 @@ boolean process(Token t, HtmlTreeBuilder tb) {
                         tb.reconstructFormattingElements();
                         // todo: handle A start tag whose tag name is "math" (i.e. foreign, mathml)
                         tb.insert(startTag);
-                        tb.tokeniser.acknowledgeSelfClosingFlag();
                     } else if (name.equals("svg")) {
                         tb.reconstructFormattingElements();
                         // todo: handle A start tag whose tag name is "svg" (xlink, svg)
                         tb.insert(startTag);
-                        tb.tokeniser.acknowledgeSelfClosingFlag();
                     } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {
                         tb.error(this);
                         return false;

File: src/main/java/org/jsoup/parser/XmlTreeBuilder.java
Patch:
@@ -72,7 +72,6 @@ Element insert(Token.StartTag startTag) {
         Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));
         insertNode(el);
         if (startTag.isSelfClosing()) {
-            tokeniser.acknowledgeSelfClosingFlag();
             if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.
                 tag.setSelfClosing();
         } else {

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -26,6 +26,8 @@
 import java.util.regex.Pattern;
 import java.util.regex.PatternSyntaxException;
 
+import static org.jsoup.internal.Normalizer.normalize;
+
 /**
  * A HTML element consists of a tag name, attributes, and child nodes (including text nodes and
  * other elements).
@@ -688,7 +690,7 @@ private static <E extends Element> Integer indexInList(Element search, List<E> e
      */
     public Elements getElementsByTag(String tagName) {
         Validate.notEmpty(tagName);
-        tagName = tagName.toLowerCase().trim();
+        tagName = normalize(tagName);
 
         return Collector.collect(new Evaluator.Tag(tagName), this);
     }

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -15,6 +15,8 @@
 import java.util.LinkedList;
 import java.util.List;
 
+import static org.jsoup.internal.Normalizer.lowerCase;
+
 /**
  The base, abstract Node model. Elements, Documents, Comments etc are all Node instances.
 
@@ -80,7 +82,7 @@ public String attr(String attributeKey) {
         String val = attributes.getIgnoreCase(attributeKey);
         if (val.length() > 0)
             return val;
-        else if (attributeKey.toLowerCase().startsWith("abs:"))
+        else if (lowerCase(attributeKey).startsWith("abs:"))
             return absUrl(attributeKey.substring("abs:".length()));
         else return "";
     }

File: src/main/java/org/jsoup/safety/Whitelist.java
Patch:
@@ -15,6 +15,8 @@ Thank you to Ryan Grove (wonko.com) for the Ruby HTML cleaner http://github.com/
 import java.util.Map;
 import java.util.Set;
 
+import static org.jsoup.internal.Normalizer.lowerCase;
+
 
 /**
  Whitelists define what HTML (elements and attributes) to allow through the cleaner. Everything else is removed.
@@ -542,7 +544,7 @@ private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> prot
 
             prot += ":";
 
-            if (value.toLowerCase().startsWith(prot)) {
+            if (lowerCase(value).startsWith(prot)) {
                 return true;
             }
         }

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -1229,7 +1229,8 @@ boolean process(Token t, HtmlTreeBuilder tb) {
                     if (name.equals("html"))
                         return tb.process(start, InBody);
                     else if (name.equals("option")) {
-                        tb.processEndTag("option");
+                        if (tb.currentElement().nodeName().equals("option"))
+                            tb.processEndTag("option");
                         tb.insert(start);
                     } else if (name.equals("optgroup")) {
                         if (tb.currentElement().nodeName().equals("option"))

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -663,6 +663,7 @@ else if (methodHasBody)
                         req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.
                         req.data().clear();
                         req.requestBody(null);
+                        req.removeHeader(CONTENT_TYPE);
                     }
 
                     String location = res.header(LOCATION);

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -761,7 +761,7 @@ else if (!tb.onStack(formatEl)) {
         }
 
         boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {
-            String name = t.asEndTag().normalName();
+            String name = t.asEndTag().name(); // matches with case sensitivity if enabled
             ArrayList<Element> stack = tb.getStack();
             for (int pos = stack.size() -1; pos >= 0; pos--) {
                 Element node = stack.get(pos);

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -662,6 +662,7 @@ else if (methodHasBody)
                     if (status != HTTP_TEMP_REDIR) {
                         req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.
                         req.data().clear();
+                        req.requestBody(null);
                     }
 
                     String location = res.header(LOCATION);

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -662,6 +662,7 @@ else if (methodHasBody)
                     if (status != HTTP_TEMP_REDIR) {
                         req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.
                         req.data().clear();
+                        req.requestBody(null);
                     }
 
                     String location = res.header(LOCATION);

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -25,6 +25,8 @@
 import java.util.regex.Pattern;
 import java.util.regex.PatternSyntaxException;
 
+import static org.jsoup.internal.Normalizer.normalize;
+
 /**
  * A HTML element consists of a tag name, attributes, and child nodes (including text nodes and
  * other elements).
@@ -647,7 +649,7 @@ private static <E extends Element> Integer indexInList(Element search, List<E> e
      */
     public Elements getElementsByTag(String tagName) {
         Validate.notEmpty(tagName);
-        tagName = tagName.toLowerCase().trim();
+        tagName = normalize(tagName);
 
         return Collector.collect(new Evaluator.Tag(tagName), this);
     }

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -13,6 +13,8 @@
 import java.util.LinkedList;
 import java.util.List;
 
+import static org.jsoup.internal.Normalizer.lowerCase;
+
 /**
  The base, abstract Node model. Elements, Documents, Comments etc are all Node instances.
 
@@ -78,7 +80,7 @@ public String attr(String attributeKey) {
         String val = attributes.getIgnoreCase(attributeKey);
         if (val.length() > 0)
             return val;
-        else if (attributeKey.toLowerCase().startsWith("abs:"))
+        else if (lowerCase(attributeKey).startsWith("abs:"))
             return absUrl(attributeKey.substring("abs:".length()));
         else return "";
     }

File: src/main/java/org/jsoup/safety/Whitelist.java
Patch:
@@ -15,6 +15,8 @@ Thank you to Ryan Grove (wonko.com) for the Ruby HTML cleaner http://github.com/
 import java.util.Map;
 import java.util.Set;
 
+import static org.jsoup.internal.Normalizer.lowerCase;
+
 
 /**
  Whitelists define what HTML (elements and attributes) to allow through the cleaner. Everything else is removed.
@@ -542,7 +544,7 @@ private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> prot
 
             prot += ":";
 
-            if (value.toLowerCase().startsWith(prot)) {
+            if (lowerCase(value).startsWith(prot)) {
                 return true;
             }
         }

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -1229,7 +1229,8 @@ boolean process(Token t, HtmlTreeBuilder tb) {
                     if (name.equals("html"))
                         return tb.process(start, InBody);
                     else if (name.equals("option")) {
-                        tb.processEndTag("option");
+                        if (tb.currentElement().nodeName().equals("option"))
+                            tb.processEndTag("option");
                         tb.insert(start);
                     } else if (name.equals("optgroup")) {
                         if (tb.currentElement().nodeName().equals("option"))

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -67,7 +67,7 @@ private static String encodeUrl(String url) {
 	private static URL encodeUrl(URL u) {
         try {
             //  odd way to encode urls, but it works!
-            final URI uri = new URI(u.getProtocol(), u.getUserInfo(), u.getHost(), u.getPort(), u.getPath(), u.getQuery(), u.getRef());
+            final URI uri = new URI(u.toExternalForm());
             return new URL(uri.toASCIIString());
         } catch (Exception e) {
             return u;

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -1089,7 +1089,7 @@ public Element classNames(Set<String> classNames) {
      */
     // performance sensitive
     public boolean hasClass(String className) {
-        final String classAttr = attributes.get("class");
+        final String classAttr = attributes.getIgnoreCase("class");
         final int len = classAttr.length();
         final int wantLen = className.length();
 

File: src/test/java/org/jsoup/integration/ParseTest.java
Patch:
@@ -164,7 +164,7 @@ public void testNytArticle() throws IOException {
     public void testYahooArticle() throws IOException {
         File in = getFile("/htmltests/yahoo-article-1.html");
         Document doc = Jsoup.parse(in, "UTF-8", "http://news.yahoo.com/s/nm/20100831/bs_nm/us_gm_china");
-        Element p = doc.select("p:contains(Volt will be sold in the United States").first();
+        Element p = doc.select("p:contains(Volt will be sold in the United States)").first();
         assertEquals("In July, GM said its electric Chevrolet Volt will be sold in the United States at $41,000 -- $8,000 more than its nearest competitor, the Nissan Leaf.", p.text());
     }
 

File: src/test/java/org/jsoup/parser/TokenQueueTest.java
Patch:
@@ -31,10 +31,10 @@ public class TokenQueueTest {
     }
 
     @Test public void chompBalancedMatchesAsMuchAsPossible() {
-        TokenQueue tq = new TokenQueue("unbalanced(something(or another");
+        TokenQueue tq = new TokenQueue("unbalanced(something(or another)) else");
         tq.consumeTo("(");
         String match = tq.chompBalanced('(', ')');
-        assertEquals("something(or another", match);
+        assertEquals("something(or another)", match);
     }
     
     @Test public void unescape() {

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -29,9 +29,10 @@ public class Attribute implements Map.Entry<String, String>, Cloneable  {
      * @see #createFromEncoded
      */
     public Attribute(String key, String value) {
-        Validate.notEmpty(key);
+        Validate.notNull(key);
         Validate.notNull(value);
         this.key = key.trim();
+        Validate.notEmpty(key); // trimming could potentially make empty, so validate here
         this.value = value;
     }
 

File: src/main/java/org/jsoup/parser/ParseErrorList.java
Patch:
@@ -7,7 +7,7 @@
  * 
  * @author Jonathan Hedley
  */
-class ParseErrorList extends ArrayList<ParseError>{
+public class ParseErrorList extends ArrayList<ParseError>{
     private static final int INITIAL_CAPACITY = 16;
     private final int maxSize;
     
@@ -24,11 +24,11 @@ int getMaxSize() {
         return maxSize;
     }
 
-    static ParseErrorList noTracking() {
+    public static ParseErrorList noTracking() {
         return new ParseErrorList(0, 0);
     }
     
-    static ParseErrorList tracking(int maxSize) {
+    public static ParseErrorList tracking(int maxSize) {
         return new ParseErrorList(INITIAL_CAPACITY, maxSize);
     }
 }

File: src/main/java/org/jsoup/Connection.java
Patch:
@@ -140,7 +140,7 @@ public final boolean hasBody() {
     Connection ignoreContentType(boolean ignoreContentType);
 
     /**
-     * Disable/enable TSL certificates validation for HTTPS requests.
+     * Disable/enable TLS certificates validation for HTTPS requests.
      * <p>
      * By default this is <b>true</b>; all
      * connections over HTTPS perform normal validation of certificates, and will abort requests if the provided
@@ -153,7 +153,7 @@ public final boolean hasBody() {
      * <p>
      * <b>Be careful</b> and understand why you need to disable these validations.
      * </p>
-     * @param value if should validate TSL (SSL) certificates. <b>true</b> by default.
+     * @param value if should validate TLS (SSL) certificates. <b>true</b> by default.
      * @return this Connection, for chaining
      */
     Connection validateTLSCertificates(boolean value);
@@ -168,7 +168,7 @@ public final boolean hasBody() {
     Connection data(String key, String value);
 
     /**
-     * Add an input stream as a request data paramater. For GETs, has no effect, but for POSTS this will upload the
+     * Add an input stream as a request data parameter. For GETs, has no effect, but for POSTS this will upload the
      * input stream.
      * @param key data key (form item name)
      * @param filename the name of the file to present to the remove server. Typically just the name, not path,

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -122,7 +122,7 @@ protected boolean isDataAttribute() {
     /**
      * Collapsible if it's a boolean attribute and value is empty or same as name
      * 
-     * @param out Outputsettings
+     * @param out output settings
      * @return  Returns whether collapsible or not
      */
     protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {

File: src/main/java/org/jsoup/nodes/Document.java
Patch:
@@ -296,7 +296,7 @@ public Document clone() {
      * <tt>true</tt>, otherwise this method does nothing.
      * 
      * <ul>
-     * <li>An exsiting element gets updated with the current charset</li>
+     * <li>An existing element gets updated with the current charset</li>
      * <li>If there's no element yet it will be inserted</li>
      * <li>Obsolete elements are removed</li>
      * </ul>

File: src/main/java/org/jsoup/nodes/Entities.java
Patch:
@@ -112,7 +112,7 @@ public static Character getCharacterByName(String name) {
     }
 
     /**
-     * Get the character(s) represented by the named entitiy
+     * Get the character(s) represented by the named entity
      *
      * @param name entity (e.g. "lt" or "amp")
      * @return the string value of the character(s) represented by this entity, or "" if not defined

File: src/main/java/org/jsoup/parser/Tag.java
Patch:
@@ -164,7 +164,7 @@ public static boolean isKnownTag(String tagName) {
     /**
      * Get if this tag should preserve whitespace within child text nodes.
      *
-     * @return if preserve whitepace
+     * @return if preserve whitespace
      */
     public boolean preserveWhitespace() {
         return preserveWhitespace;

File: src/main/java/org/jsoup/Connection.java
Patch:
@@ -78,12 +78,13 @@ public final boolean hasBody() {
      * Set the request user-agent header.
      * @param userAgent user-agent to use
      * @return this Connection, for chaining
+     * @see org.jsoup.helper.HttpConnection#DEFAULT_UA
      */
     Connection userAgent(String userAgent);
 
     /**
      * Set the request timeouts (connect and read). If a timeout occurs, an IOException will be thrown. The default
-     * timeout is 3 seconds (3000 millis). A timeout of zero is treated as an infinite timeout.
+     * timeout is <b<30 seconds</b> (30000 millis). A timeout of zero is treated as an infinite timeout.
      * @param millis number of milliseconds (thousandths of a second) before timing out connects or reads.
      * @return this Connection, for chaining
      */

File: src/test/java/org/jsoup/helper/HttpConnectionTest.java
Patch:
@@ -116,12 +116,14 @@ public class HttpConnectionTest {
 
     @Test public void userAgent() {
         Connection con = HttpConnection.connect("http://example.com/");
+        assertEquals(HttpConnection.DEFAULT_UA, con.request().header("User-Agent"));
         con.userAgent("Mozilla");
         assertEquals("Mozilla", con.request().header("User-Agent"));
     }
 
     @Test public void timeout() {
         Connection con = HttpConnection.connect("http://example.com/");
+        assertEquals(30 * 1000, con.request().timeout());
         con.timeout(1000);
         assertEquals(1000, con.request().timeout());
     }
@@ -139,7 +141,7 @@ public class HttpConnectionTest {
         assertEquals(Connection.Method.POST, con.request().method());
     }
 
-    @Test(expected=IllegalArgumentException.class) public void throwsOnOdddData() {
+    @Test(expected=IllegalArgumentException.class) public void throwsOnOddData() {
         Connection con = HttpConnection.connect("http://example.com/");
         con.data("Name", "val", "what");
     }

File: src/main/java/org/jsoup/nodes/Attributes.java
Patch:
@@ -119,9 +119,10 @@ public void removeIgnoreCase(String key) {
         Validate.notEmpty(key);
         if (attributes == null)
             return;
-        for (String attrKey : attributes.keySet()) {
+        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {
+            String attrKey = it.next();
             if (attrKey.equalsIgnoreCase(key))
-                attributes.remove(attrKey);
+                it.remove();
         }
     }
 

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -20,7 +20,7 @@ boolean process(Token t, HtmlTreeBuilder tb) {
                 // todo: quirk state check on doctype ids
                 Token.Doctype d = t.asDoctype();
                 DocumentType doctype = new DocumentType(
-                    tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());
+                    tb.settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());
                 tb.getDocument().appendChild(doctype);
                 if (d.isForceQuirks())
                     tb.getDocument().quirksMode(Document.QuirksMode.quirks);

File: src/main/java/org/jsoup/parser/XmlTreeBuilder.java
Patch:
@@ -97,7 +97,7 @@ void insert(Token.Character characterToken) {
     }
 
     void insert(Token.Doctype d) {
-        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);
+        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);
         insertNode(doctypeNode);
     }
 

File: src/main/java/org/jsoup/nodes/Document.java
Patch:
@@ -371,7 +371,6 @@ public enum Syntax {html, xml}
 
         private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;
         private Charset charset = Charset.forName("UTF-8");
-        private CharsetEncoder charsetEncoder = charset.newEncoder();
         private boolean prettyPrint = true;
         private boolean outline = false;
         private int indentAmount = 1;
@@ -421,7 +420,6 @@ public Charset charset() {
          */
         public OutputSettings charset(Charset charset) {
             this.charset = charset;
-            charsetEncoder = charset.newEncoder();
             return this;
         }
 
@@ -436,7 +434,7 @@ public OutputSettings charset(String charset) {
         }
 
         CharsetEncoder encoder() {
-            return charsetEncoder;
+            return charset.newEncoder();
         }
 
         /**

File: src/main/java/org/jsoup/parser/TokeniserState.java
Patch:
@@ -880,6 +880,7 @@ void read(Tokeniser t, CharacterReader r) {
                     break;
                 default:
                     t.error(this);
+                    r.unconsume();
                     t.transition(BeforeAttributeName);
             }
         }

File: src/test/java/org/jsoup/integration/UrlConnectTest.java
Patch:
@@ -36,7 +36,7 @@ public class UrlConnectTest {
     private static final String WEBSITE_WITH_INVALID_CERTIFICATE = "https://certs.cac.washington.edu/CAtest/";
     private static final String WEBSITE_WITH_SNI = "https://jsoup.org/";
     private static String echoURL = "http://direct.infohound.net/tools/q.pl";
-    private static String browserUa = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36";
+    public static String browserUa = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36";
 
     @Test
     public void fetchURl() throws IOException {

File: src/test/java/org/jsoup/safety/CleanerTest.java
Patch:
@@ -210,7 +210,7 @@ public class CleanerTest {
         String defaultOut = Jsoup.clean(html, "http://foo.com/", Whitelist.relaxed());
         assertNotSame(defaultOut, customOut);
 
-        assertEquals("<div><p>&bernou;</p></div>", customOut);
+        assertEquals("<div><p>&Bscr;</p></div>", customOut); // entities now prefers shorted names if aliased
         assertEquals("<div>\n" +
             " <p></p>\n" +
             "</div>", defaultOut);

File: src/main/java/org/jsoup/helper/DataUtil.java
Patch:
@@ -113,7 +113,7 @@ static Document parseByteData(ByteBuffer byteData, String charsetName, String ba
                 }
             }
             // look for <?xml encoding='ISO-8859-1'?>
-            if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {
+            if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {
                 XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);
                 if (prolog.name().equals("xml")) {
                     foundCharset = prolog.attr("encoding");

File: src/main/java/org/jsoup/parser/TokenQueue.java
Patch:
@@ -346,13 +346,13 @@ public String consumeTagName() {
     }
     
     /**
-     * Consume a CSS element selector (tag name, but | instead of : for namespaces, to not conflict with :pseudo selects).
+     * Consume a CSS element selector (tag name, but | instead of : for namespaces (or *| for wildcard namespace), to not conflict with :pseudo selects).
      * 
      * @return tag name
      */
     public String consumeElementSelector() {
         int start = pos;
-        while (!isEmpty() && (matchesWord() || matchesAny('|', '_', '-')))
+        while (!isEmpty() && (matchesWord() || matchesAny("*|","|", "_", "-")))
             pos++;
         
         return queue.substring(start, pos);

File: src/main/java/org/jsoup/select/CombiningEvaluator.java
Patch:
@@ -77,6 +77,8 @@ static final class Or extends CombiningEvaluator {
             updateNumEvaluators();
         }
 
+        Or(Evaluator... evaluators) { this(Arrays.asList(evaluators)); }
+
         Or() {
             super();
         }

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -23,6 +23,7 @@
  * <tr><th align="left">Pattern</th><th align="left">Matches</th><th align="left">Example</th></tr>
  * <tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>
  * <tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>
+ * <tr><td><code>*|E</code></td><td>elements of type E in any namespace <i>ns</i></td><td><code>*|name</code> finds <code>&lt;fb:name&gt;</code> elements</td></tr>
  * <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name&gt;</code> elements</td></tr>
  * <tr><td><code>#id</code></td><td>elements with attribute ID of "id"</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>
  * <tr><td><code>.class</code></td><td>elements with a class name of "class"</td><td><code>div.left</code>, <code>.result</code></td></tr>

File: src/main/java/org/jsoup/parser/TokenQueue.java
Patch:
@@ -346,13 +346,13 @@ public String consumeTagName() {
     }
     
     /**
-     * Consume a CSS element selector (tag name, but | instead of : for namespaces, to not conflict with :pseudo selects).
+     * Consume a CSS element selector (tag name, but | instead of : for namespaces (or *| for wildcard namespace), to not conflict with :pseudo selects).
      * 
      * @return tag name
      */
     public String consumeElementSelector() {
         int start = pos;
-        while (!isEmpty() && (matchesWord() || matchesAny('|', '_', '-')))
+        while (!isEmpty() && (matchesWord() || matchesAny("*|","|", "_", "-")))
             pos++;
         
         return queue.substring(start, pos);

File: src/main/java/org/jsoup/select/CombiningEvaluator.java
Patch:
@@ -77,6 +77,8 @@ static final class Or extends CombiningEvaluator {
             updateNumEvaluators();
         }
 
+        Or(Evaluator... evaluators) { this(Arrays.asList(evaluators)); }
+
         Or() {
             super();
         }

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -23,6 +23,7 @@
  * <tr><th align="left">Pattern</th><th align="left">Matches</th><th align="left">Example</th></tr>
  * <tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>
  * <tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>
+ * <tr><td><code>*|E</code></td><td>elements of type E in any namespace <i>ns</i></td><td><code>*|name</code> finds <code>&lt;fb:name&gt;</code> elements</td></tr>
  * <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name&gt;</code> elements</td></tr>
  * <tr><td><code>#id</code></td><td>elements with attribute ID of "id"</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>
  * <tr><td><code>.class</code></td><td>elements with a class name of "class"</td><td><code>div.left</code>, <code>.result</code></td></tr>

File: src/main/java/org/jsoup/nodes/Document.java
Patch:
@@ -332,7 +332,7 @@ private void ensureMetaCharsetElement() {
                 if (node instanceof XmlDeclaration) {
                     XmlDeclaration decl = (XmlDeclaration) node;
 
-                    if (decl.attr(XmlDeclaration.DECL_KEY).equals("xml")) {
+                    if (decl.name().equals("xml")) {
                         decl.attr("encoding", charset().displayName());
 
                         final String version = decl.attr("version");

File: src/test/java/org/jsoup/parser/HtmlParserTest.java
Patch:
@@ -894,7 +894,7 @@ public void testInvalidTableContents() throws IOException {
     }
 
     @Test public void testSupportsPartiallyNonAsciiTags() {
-        String body = "<div>Check</div>";
+        String body = "<div>Check</div>";
         Document doc = Jsoup.parse(body);
         Elements els = doc.select("div");
         assertEquals("Check", els.text());

File: src/main/java/org/jsoup/parser/CharacterReader.java
Patch:
@@ -194,7 +194,7 @@ String consumeLetterSequence() {
         int start = pos;
         while (pos < length) {
             char c = input[pos];
-            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
+            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))
                 pos++;
             else
                 break;
@@ -207,7 +207,7 @@ String consumeLetterThenDigitSequence() {
         int start = pos;
         while (pos < length) {
             char c = input[pos];
-            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
+            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))
                 pos++;
             else
                 break;

File: src/main/java/org/jsoup/select/Elements.java
Patch:
@@ -412,7 +412,7 @@ public Elements select(String query) {
      * Remove elements from this list that match the {@link Selector} query.
      * <p>
      * E.g. HTML: {@code <div class=logo>One</div> <div>Two</div>}<br>
-     * <code>Elements divs = doc.select("div").not("#logo");</code><br>
+     * <code>Elements divs = doc.select("div").not(".logo");</code><br>
      * Result: {@code divs: [<div>Two</div>]}
      * <p>
      * @param query the selector query whose results should be removed from these elements

File: src/test/java/org/jsoup/nodes/EntitiesTest.java
Patch:
@@ -7,7 +7,6 @@
 import static org.jsoup.nodes.Entities.EscapeMode.*;
 import static org.junit.Assert.*;
 
-
 public class EntitiesTest {
     @Test public void escape() {
         String text = "Hello &<>     there   ";
@@ -32,7 +31,7 @@ public class EntitiesTest {
         assertEquals(text, Entities.unescape(escapedUtfMin));
     }
 
-    @Test public void escapeSupplementaryCharacter(){
+    @Test public void escapeSupplementaryCharacter() {
         String text = new String(Character.toChars(135361));
         String escapedAscii = Entities.escape(text, new OutputSettings().charset("ascii").escapeMode(base));
         assertEquals("&#x210c1;", escapedAscii);

File: src/main/java/org/jsoup/parser/CharacterReader.java
Patch:
@@ -297,7 +297,7 @@ boolean matchesLetter() {
         if (isEmpty())
             return false;
         char c = input[pos];
-        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
+        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);
     }
 
     boolean matchesDigit() {

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -437,13 +437,13 @@ protected void addChildren(Node... children) {
 
     protected void addChildren(int index, Node... children) {
         Validate.noNullElements(children);
+        ensureChildNodes();
         for (int i = children.length - 1; i >= 0; i--) {
             Node in = children[i];
             reparentChild(in);
-            ensureChildNodes();
             childNodes.add(index, in);
+            reindexChildren(index);
         }
-        reindexChildren(index);
     }
 
     protected void ensureChildNodes() {

File: src/main/java/org/jsoup/Connection.java
Patch:
@@ -28,7 +28,7 @@ public interface Connection {
      * GET and POST http methods.
      */
     enum Method {
-        GET(false), POST(true), PUT(true), DELETE(false), PATCH(true);
+        GET(false), POST(true), PUT(true), DELETE(false), PATCH(true), HEAD(false), OPTIONS(false), TRACE(false);
 
         private final boolean hasBody;
 

File: src/main/java/org/jsoup/select/StructuralEvaluator.java
Patch:
@@ -58,9 +58,11 @@ public boolean matches(Element root, Element element) {
                 return false;
 
             Element parent = element.parent();
-            while (parent != root) {
+            while (true) {
                 if (evaluator.matches(root, parent))
                     return true;
+                if( parent == root )
+                	break;
                 parent = parent.parent();
             }
             return false;

File: src/main/java/org/jsoup/nodes/Entities.java
Patch:
@@ -118,7 +118,8 @@ static void escape(StringBuilder accum, String string, Document.OutputSettings o
                             accum.append("&#xa0;");
                         break;
                     case '<':
-                        if (!inAttribute)
+                        // escape when in character data or when in a xml attribue val; not needed in html attr val
+                        if (!inAttribute || escapeMode == EscapeMode.xhtml)
                             accum.append("&lt;");
                         else
                             accum.append(c);

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -526,7 +526,7 @@ static Response execute(Connection.Request req, Response previousResponse) throw
                     String location = res.header(LOCATION);
                     if (location != null && location.startsWith("http:/") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php
                         location = location.substring(6);
-                    req.url(new URL(req.url(), encodeUrl(location)));
+                    req.url(StringUtil.resolve(req.url(), encodeUrl(location)));
 
                     for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)
                         req.cookie(cookie.getKey(), cookie.getValue());

File: src/main/java/org/jsoup/nodes/Entities.java
Patch:
@@ -115,7 +115,7 @@ static void escape(StringBuilder accum, String string, Document.OutputSettings o
                         if (escapeMode != EscapeMode.xhtml)
                             accum.append("&nbsp;");
                         else
-                            accum.append(c);
+                            accum.append("&#xa0;");
                         break;
                     case '<':
                         if (!inAttribute)

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -391,7 +391,7 @@ void resetInsertionMode() {
             if ("select".equals(name)) {
                 transition(HtmlTreeBuilderState.InSelect);
                 break; // frag
-            } else if (("td".equals(name) || "td".equals(name) && !last)) {
+            } else if (("td".equals(name) || "th".equals(name) && !last)) {
                 transition(HtmlTreeBuilderState.InCell);
                 break;
             } else if ("tr".equals(name)) {

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -547,6 +547,9 @@ static Response execute(Connection.Request req, Response previousResponse) throw
                     throw new UnsupportedMimeTypeException("Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml",
                             contentType, req.url().toString());
 
+                if (contentType.startsWith("application/xml") || xmlContentTypeRxp.matcher(contentType).matches())
+                       req.parser(Parser.xmlParser());
+
                 res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it
                 if (conn.getContentLength() != 0) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body
                     InputStream bodyStream = null;

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -41,7 +41,7 @@
  * <tr><td><code>E ~ F</code></td><td>an F element preceded by sibling E</td><td><code>h1 ~ p</code></td></tr>
  * <tr><td><code>E, F, G</code></td><td>all matching elements E, F, or G</td><td><code>a[href], div, h3</code></td></tr>
  * <tr><td><td colspan="3"><h3>Pseudo selectors</h3></td></tr>
- * <tr><td><code>:lt(<em>n</em>)</code></td><td>elements whose sibling index is less than <em>n</em></td><td><code>td:lt(3)</code> finds the first 2 cells of each row</td></tr>
+ * <tr><td><code>:lt(<em>n</em>)</code></td><td>elements whose sibling index is less than <em>n</em></td><td><code>td:lt(3)</code> finds the first 3 cells of each row</td></tr>
  * <tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>
  * <tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>
  * <tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds divs that contain p elements </td></tr>

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -571,7 +571,7 @@ private static <E extends Element> Integer indexInList(Element search, List<E> e
 
         for (int i = 0; i < elements.size(); i++) {
             E element = elements.get(i);
-            if (element.equals(search))
+            if (element == search)
                 return i;
         }
         return null;

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -252,6 +252,7 @@ public List<DataNode> dataNodes() {
      * @param cssQuery a {@link Selector} CSS-like query
      * @return elements that match the query (empty if none match)
      * @see org.jsoup.select.Selector
+     * @throws Selector.SelectorParseException (unchecked) on an invalid CSS query.
      */
     public Elements select(String cssQuery) {
         return Selector.select(cssQuery, this);

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -99,6 +99,7 @@ private Selector(Evaluator evaluator, Element root) {
      * @param query CSS selector
      * @param root  root element to descend into
      * @return matching elements, empty if none
+     * @throws Selector.SelectorParseException (unchecked) on an invalid CSS query.
      */
     public static Elements select(String query, Element root) {
         return new Selector(query, root).select();

File: src/main/java/org/jsoup/helper/W3CDom.java
Patch:
@@ -21,8 +21,9 @@
 /**
  * Helper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},
  * for integration with toolsets that use the W3C DOM.
- * <p/>
+ * <p>
  * This class is currently <b>experimental</b>, please provide feedback on utility and any problems experienced.
+ * </p>
  */
 public class W3CDom {
     protected DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -114,6 +114,9 @@ protected boolean isDataAttribute() {
 
     /**
      * Collapsible if it's a boolean attribute and value is empty or same as name
+     * 
+     * @param out Outputsettings
+     * @return  Returns whether collapsible or not
      */
     protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {
         return ("".equals(value) || value.equalsIgnoreCase(key))

File: src/main/java/org/jsoup/nodes/Document.java
Patch:
@@ -361,7 +361,7 @@ public int indentAmount() {
 
         /**
          * Set the indent amount for pretty printing
-         * @param indentAmount number of spaces to use for indenting each level. Must be >= 0.
+         * @param indentAmount number of spaces to use for indenting each level. Must be {@literal >=} 0.
          * @return this, for chaining
          */
         public OutputSettings indentAmount(int indentAmount) {

File: src/main/java/org/jsoup/nodes/Entities.java
Patch:
@@ -63,7 +63,7 @@ public static boolean isBaseNamedEntity(String name) {
     /**
      * Get the Character value of the named entity
      * @param name named entity (e.g. "lt" or "amp")
-     * @return the Character value of the named entity (e.g. '<' or '&')
+     * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}')
      */
     public static Character getCharacterByName(String name) {
         return full.get(name);

File: src/main/java/org/jsoup/parser/Tag.java
Patch:
@@ -39,9 +39,10 @@ public String getName() {
 
     /**
      * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.
-     * <p/>
+     * <p>
      * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().
-     *
+     * </p>
+     * 
      * @param tagName Name of tag, e.g. "p". Case insensitive.
      * @return The tag, either defined or new generic.
      */

File: src/main/java/org/jsoup/select/NodeTraversor.java
Patch:
@@ -4,8 +4,9 @@
 
 /**
  * Depth-first node traversor. Use to iterate through all nodes under and including the specified root node.
- * <p/>
+ * <p>
  * This implementation does not use recursion, so a deep DOM does not risk blowing the stack.
+ * </p>
  */
 public class NodeTraversor {
     private NodeVisitor visitor;

File: src/main/java/org/jsoup/select/NodeVisitor.java
Patch:
@@ -4,10 +4,11 @@
 
 /**
  * Node visitor interface. Provide an implementing class to {@link NodeTraversor} to iterate through nodes.
- * <p/>
+ * <p>
  * This interface provides two methods, {@code head} and {@code tail}. The head method is called when the node is first
  * seen, and the tail method when all of the node's children have been visited. As an example, head can be used to
  * create a start tag for a node, and tail to create the end tag.
+ * </p>
  */
 public interface NodeVisitor {
     /**

File: src/main/java/org/jsoup/select/Evaluator.java
Patch:
@@ -152,7 +152,7 @@ public AttributeWithValue(String key, String value) {
 
         @Override
         public boolean matches(Element root, Element element) {
-            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key));
+            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key).trim());
         }
 
         @Override

File: src/test/java/org/jsoup/nodes/DocumentTest.java
Patch:
@@ -65,7 +65,7 @@ public class DocumentTest {
 
     @Test public void testNormalisesStructure() {
         Document doc = Jsoup.parse("<html><head><script>one</script><noscript><p>two</p></noscript></head><body><p>three</p></body><p>four</p></html>");
-        assertEquals("<html><head><script>one</script><noscript></noscript></head><body><p>two</p><p>three</p><p>four</p></body></html>", TextUtil.stripNewlines(doc.html()));
+        assertEquals("<html><head><script>one</script><noscript>&lt;p&gt;two</noscript></head><body><p>three</p><p>four</p></body></html>", TextUtil.stripNewlines(doc.html()));
     }
 
     @Test public void testClone() {

File: src/test/java/org/jsoup/TextUtil.java
Patch:
@@ -5,6 +5,8 @@
 
  @author Jonathan Hedley, jonathan@hedley.net */
 public class TextUtil {
+    public static final String LE = String.format("%n");
+
     public static String stripNewlines(String text) {
         text = text.replaceAll("\\n\\s*", "");
         return text;

File: src/main/java/org/jsoup/select/Evaluator.java
Patch:
@@ -152,7 +152,7 @@ public AttributeWithValue(String key, String value) {
 
         @Override
         public boolean matches(Element root, Element element) {
-            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key));
+            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key).trim());
         }
 
         @Override

File: src/main/java/org/jsoup/helper/W3CDom.java
Patch:
@@ -21,8 +21,9 @@
 /**
  * Helper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},
  * for integration with toolsets that use the W3C DOM.
- * <p/>
+ * <p>
  * This class is currently <b>experimental</b>, please provide feedback on utility and any problems experienced.
+ * </p>
  */
 public class W3CDom {
     protected DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -114,6 +114,9 @@ protected boolean isDataAttribute() {
 
     /**
      * Collapsible if it's a boolean attribute and value is empty or same as name
+     * 
+     * @param out Outputsettings
+     * @return  Returns whether collapsible or not
      */
     protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {
         return ("".equals(value) || value.equalsIgnoreCase(key))

File: src/main/java/org/jsoup/nodes/Document.java
Patch:
@@ -361,7 +361,7 @@ public int indentAmount() {
 
         /**
          * Set the indent amount for pretty printing
-         * @param indentAmount number of spaces to use for indenting each level. Must be >= 0.
+         * @param indentAmount number of spaces to use for indenting each level. Must be {@literal >=} 0.
          * @return this, for chaining
          */
         public OutputSettings indentAmount(int indentAmount) {

File: src/main/java/org/jsoup/nodes/Entities.java
Patch:
@@ -63,7 +63,7 @@ public static boolean isBaseNamedEntity(String name) {
     /**
      * Get the Character value of the named entity
      * @param name named entity (e.g. "lt" or "amp")
-     * @return the Character value of the named entity (e.g. '<' or '&')
+     * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}')
      */
     public static Character getCharacterByName(String name) {
         return full.get(name);

File: src/main/java/org/jsoup/parser/Tag.java
Patch:
@@ -39,9 +39,10 @@ public String getName() {
 
     /**
      * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.
-     * <p/>
+     * <p>
      * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().
-     *
+     * </p>
+     * 
      * @param tagName Name of tag, e.g. "p". Case insensitive.
      * @return The tag, either defined or new generic.
      */

File: src/main/java/org/jsoup/select/NodeTraversor.java
Patch:
@@ -4,8 +4,9 @@
 
 /**
  * Depth-first node traversor. Use to iterate through all nodes under and including the specified root node.
- * <p/>
+ * <p>
  * This implementation does not use recursion, so a deep DOM does not risk blowing the stack.
+ * </p>
  */
 public class NodeTraversor {
     private NodeVisitor visitor;

File: src/main/java/org/jsoup/select/NodeVisitor.java
Patch:
@@ -4,10 +4,11 @@
 
 /**
  * Node visitor interface. Provide an implementing class to {@link NodeTraversor} to iterate through nodes.
- * <p/>
+ * <p>
  * This interface provides two methods, {@code head} and {@code tail}. The head method is called when the node is first
  * seen, and the tail method when all of the node's children have been visited. As an example, head can be used to
  * create a start tag for a node, and tail to create the end tag.
+ * </p>
  */
 public interface NodeVisitor {
     /**

File: src/main/java/org/jsoup/nodes/TextNode.java
Patch:
@@ -94,7 +94,7 @@ void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out)
             indent(accum, depth, out);
 
         boolean normaliseWhite = out.prettyPrint() && parent() instanceof Element
-                && !Element.preserveWhitespace((Element) parent());
+                && !Element.preserveWhitespace(parent());
         Entities.escape(accum, getWholeText(), out, false, normaliseWhite, false);
     }
 

File: src/main/java/org/jsoup/parser/Tokeniser.java
Patch:
@@ -1,7 +1,6 @@
 package org.jsoup.parser;
 
 import org.jsoup.helper.Validate;
-import org.jsoup.nodes.Element;
 import org.jsoup.nodes.Entities;
 
 import java.util.Arrays;

File: src/test/java/org/jsoup/helper/StringUtilTest.java
Patch:
@@ -12,9 +12,9 @@
 public class StringUtilTest {
 
     @Test public void join() {
-        assertEquals("", StringUtil.join(Arrays.<String>asList(""), " "));
-        assertEquals("one", StringUtil.join(Arrays.<String>asList("one"), " "));
-        assertEquals("one two three", StringUtil.join(Arrays.<String>asList("one", "two", "three"), " "));
+        assertEquals("", StringUtil.join(Arrays.asList(""), " "));
+        assertEquals("one", StringUtil.join(Arrays.asList("one"), " "));
+        assertEquals("one two three", StringUtil.join(Arrays.asList("one", "two", "three"), " "));
     }
 
     @Test public void padding() {

File: src/test/java/org/jsoup/nodes/EntitiesTest.java
Patch:
@@ -7,7 +7,6 @@
 import static org.jsoup.nodes.Entities.EscapeMode.*;
 import static org.junit.Assert.*;
 
-import java.nio.charset.Charset;
 
 public class EntitiesTest {
     @Test public void escape() {

File: src/test/java/org/jsoup/nodes/FormElementTest.java
Patch:
@@ -4,8 +4,6 @@
 import org.jsoup.Jsoup;
 import org.junit.Test;
 
-import java.io.IOException;
-import java.util.Collection;
 import java.util.List;
 
 import static org.junit.Assert.*;

File: src/test/java/org/jsoup/nodes/NodeTest.java
Patch:
@@ -3,7 +3,6 @@
 import org.jsoup.Jsoup;
 import org.jsoup.TextUtil;
 import org.jsoup.parser.Tag;
-import org.jsoup.select.Elements;
 import org.jsoup.select.NodeVisitor;
 import org.junit.Test;
 

File: src/test/java/org/jsoup/parser/HtmlParserTest.java
Patch:
@@ -10,7 +10,6 @@
 import java.util.List;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
 /**

File: src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java
Patch:
@@ -4,7 +4,6 @@
 import org.jsoup.TextUtil;
 import org.jsoup.helper.StringUtil;
 import org.jsoup.nodes.Document;
-import org.jsoup.nodes.Element;
 import org.jsoup.nodes.Node;
 import org.jsoup.nodes.TextNode;
 import org.junit.Ignore;

File: src/main/java/org/jsoup/parser/Parser.java
Patch:
@@ -130,6 +130,9 @@ public static Document parseBodyFragment(String bodyHtml, String baseUri) {
         Element body = doc.body();
         List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);
         Node[] nodes = nodeList.toArray(new Node[nodeList.size()]); // the node list gets modified when re-parented
+        for (int i = nodes.length - 1; i > 0; i--) {
+            nodes[i].remove();
+        }
         for (Node node : nodes) {
             body.appendChild(node);
         }

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -88,7 +88,6 @@ public String html() {
     
     protected void html(Appendable accum, Document.OutputSettings out) throws IOException {
         accum.append(key);
-        
         if (!shouldCollapseAttribute(out)) {
             accum.append("=\"");
             Entities.escape(accum, value, out, true, false, false);

File: src/main/java/org/jsoup/nodes/Document.java
Patch:
@@ -211,7 +211,7 @@ public String nodeName() {
      * {@inheritDoc}
      */
     @Override
-    public <T extends Appendable> T serialize(T appendable) {
+    public <T extends Appendable> T html(T appendable) {
     	 // Exclude outer wrapper tag.
     	for (Node node : childNodes)
             node.outerHtml(appendable);

File: src/main/java/org/jsoup/nodes/DocumentType.java
Patch:
@@ -3,6 +3,7 @@
 import java.io.IOException;
 
 import org.jsoup.helper.StringUtil;
+import org.jsoup.helper.Validate;
 
 /**
  * A {@code <!DOCTYPE>} node.

File: src/main/java/org/jsoup/nodes/XmlDeclaration.java
Patch:
@@ -34,7 +34,6 @@ public String getWholeDeclaration() {
         return attributes.get(DECL_KEY);
     }
 
-    @Override
 	void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
         accum
                 .append("<")
@@ -43,10 +42,8 @@ void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) thr
                 .append(">");
     }
 
-    @Override
 	void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}
 
-    @Override
 	public String toString() {
         return outerHtml();
     }

File: src/main/java/org/jsoup/examples/HtmlToPlainText.java
Patch:
@@ -102,6 +102,7 @@ private void append(String text) {
             }
         }
 
+        @Override
         public String toString() {
             return accum.toString();
         }

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -92,6 +92,7 @@ protected void html(StringBuilder accum, Document.OutputSettings out) {
      Get the string representation of this attribute, implemented as {@link #html()}.
      @return string
      */
+    @Override
     public String toString() {
         return html();
     }

File: src/main/java/org/jsoup/nodes/Attributes.java
Patch:
@@ -150,6 +150,7 @@ void html(StringBuilder accum, Document.OutputSettings out) {
         }
     }
     
+    @Override
     public String toString() {
         return html();
     }
@@ -161,9 +162,7 @@ public boolean equals(Object o) {
         
         Attributes that = (Attributes) o;
         
-        if (attributes != null ? !attributes.equals(that.attributes) : that.attributes != null) return false;
-        
-        return true;
+        return !(attributes != null ? !attributes.equals(that.attributes) : that.attributes != null);
     }
     
     @Override

File: src/main/java/org/jsoup/nodes/Comment.java
Patch:
@@ -40,6 +40,7 @@ void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out)
 
     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}
 
+    @Override
     public String toString() {
         return outerHtml();
     }

File: src/main/java/org/jsoup/nodes/DataNode.java
Patch:
@@ -45,6 +45,7 @@ void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out)
 
     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}
 
+    @Override
     public String toString() {
         return outerHtml();
     }

File: src/main/java/org/jsoup/nodes/Entities.java
Patch:
@@ -7,8 +7,6 @@
 import java.io.InputStream;
 import java.nio.charset.CharsetEncoder;
 import java.util.*;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 /**
  * HTML entities, and escape routines.

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -569,6 +569,7 @@ Document.OutputSettings getOutputSettings() {
 
     abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out);
 
+    @Override
     public String toString() {
         return outerHtml();
     }
@@ -579,9 +580,9 @@ protected void indent(StringBuilder accum, int depth, Document.OutputSettings ou
 
     @Override
     public boolean equals(Object o) {
-        if (this == o) return true;
         // todo: have nodes hold a child index, compare against that and parent (not children)
-        return false;
+
+        return this == o;
     }
 
     @Override

File: src/main/java/org/jsoup/nodes/TextNode.java
Patch:
@@ -100,13 +100,15 @@ void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out)
 
     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}
 
+    @Override
     public String toString() {
         return outerHtml();
     }
 
     /**
      * Create a new TextNode from HTML encoded (aka escaped) data.
      * @param encodedText Text containing encoded HTML (e.g. &amp;lt;)
+     * @param baseUri Base uri
      * @return TextNode containing unencoded data (e.g. &lt;)
      */
     public static TextNode createFromEncoded(String encodedText, String baseUri) {

File: src/main/java/org/jsoup/nodes/XmlDeclaration.java
Patch:
@@ -42,6 +42,7 @@ void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out)
 
     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}
 
+    @Override
     public String toString() {
         return outerHtml();
     }

File: src/main/java/org/jsoup/parser/CharacterReader.java
Patch:
@@ -85,11 +85,11 @@ int nextIndexOf(CharSequence seq) {
         for (int offset = pos; offset < length; offset++) {
             // scan to first instance of startchar:
             if (startChar != input[offset])
-                while(++offset < length && startChar != input[offset]);
+                while(++offset < length && startChar != input[offset]) { /* empty */ }
             int i = offset + 1;
             int last = i + seq.length()-1;
             if (offset < length && last <= length) {
-                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);
+                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) { /* empty */ }
                 if (i == last) // found full sequence
                     return offset - pos;
             }

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -100,7 +100,7 @@ else if (contextTag.equals("plaintext"))
         }
 
         runParser();
-        if (context != null)
+        if (context != null && root != null)
             return root.childNodes();
         else
             return doc.childNodes();
@@ -684,7 +684,7 @@ void insertMarkerToFormattingElements() {
     }
 
     void insertInFosterParent(Node in) {
-        Element fosterParent = null;
+        Element fosterParent;
         Element lastTable = getFromStack("table");
         boolean isLastTableParent = false;
         if (lastTable != null) {

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -885,7 +885,7 @@ boolean process(Token t, HtmlTreeBuilder tb) {
 
         boolean anythingElse(Token t, HtmlTreeBuilder tb) {
             tb.error(this);
-            boolean processed = true;
+            boolean processed;
             if (StringUtil.in(tb.currentElement().nodeName(), "table", "tbody", "tfoot", "thead", "tr")) {
                 tb.setFosterInserts(true);
                 processed = tb.process(t, InBody);

File: src/main/java/org/jsoup/parser/Tag.java
Patch:
@@ -212,6 +212,7 @@ public int hashCode() {
         return result;
     }
 
+    @Override
     public String toString() {
         return tagName;
     }

File: src/main/java/org/jsoup/parser/TokenQueue.java
Patch:
@@ -307,6 +307,7 @@ public static String unescape(String in) {
 
     /**
      * Pulls the next run of whitespace characters of the queue.
+     * @return Whether consuming whitespace or not
      */
     public boolean consumeWhitespace() {
         boolean seen = false;
@@ -389,6 +390,7 @@ public String remainder() {
         return remainder;
     }
     
+    @Override
     public String toString() {
         return queue.substring(pos);
     }

File: src/main/java/org/jsoup/parser/Tokeniser.java
Patch:
@@ -3,8 +3,6 @@
 import org.jsoup.helper.Validate;
 import org.jsoup.nodes.Entities;
 
-import java.util.ArrayList;
-import java.util.List;
 
 /**
  * Readers the input stream into tokens.

File: src/main/java/org/jsoup/parser/TreeBuilder.java
Patch:
@@ -5,8 +5,6 @@
 import org.jsoup.nodes.Document;
 import org.jsoup.nodes.Element;
 
-import java.util.ArrayList;
-import java.util.List;
 
 /**
  * @author Jonathan Hedley

File: src/main/java/org/jsoup/safety/Cleaner.java
Patch:
@@ -6,7 +6,6 @@
 import org.jsoup.select.NodeTraversor;
 import org.jsoup.select.NodeVisitor;
 
-import java.util.List;
 
 /**
  The whitelist based HTML cleaner. Use to ensure that end-user provided HTML contains only the elements and attributes

File: src/main/java/org/jsoup/select/CombiningEvaluator.java
Patch:
@@ -6,7 +6,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.List;
 
 /**
  * Base combining (and, or) evaluator.

File: src/main/java/org/jsoup/select/Elements.java
Patch:
@@ -248,6 +248,7 @@ public String outerHtml() {
      * @see #text()
      * @see #html()
      */
+    @Override
     public String toString() {
         return outerHtml();
     }
@@ -537,8 +538,10 @@ public List<FormElement> forms() {
 
     public void clear() {contents.clear();}
 
+    @Override
     public boolean equals(Object o) {return contents.equals(o);}
 
+    @Override
     public int hashCode() {return contents.hashCode();}
 
     public Element get(int index) {return contents.get(index);}

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -27,7 +27,7 @@
  * <tr><td><code>[^attrPrefix]</code></td><td>elements with an attribute name starting with "attrPrefix". Use to find elements with HTML5 datasets</td><td><code>[^data-]</code>, <code>div[^data-]</code></td></tr>
  * <tr><td><code>[attr=val]</code></td><td>elements with an attribute named "attr", and value equal to "val"</td><td><code>img[width=500]</code>, <code>a[rel=nofollow]</code></td></tr>
  * <tr><td><code>[attr=&quot;val&quot;]</code></td><td>elements with an attribute named "attr", and value equal to "val"</td><td><code>span[hello="Cleveland"][goodbye="Columbus"]</code>, <code>a[rel=&quot;nofollow&quot;]</code></td></tr>
- * <tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named "attr", and value starting with "valPrefix"</td><td><code>a[href^=http:]</code></code></td></tr>
+ * <tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named "attr", and value starting with "valPrefix"</td><td><code>a[href^=http:]</code></td></tr>
  * <tr><td><code>[attr$=valSuffix]</code></td><td>elements with an attribute named "attr", and value ending with "valSuffix"</td><td><code>img[src$=.png]</code></td></tr>
  * <tr><td><code>[attr*=valContaining]</code></td><td>elements with an attribute named "attr", and value containing "valContaining"</td><td><code>a[href*=/search/]</code></td></tr>
  * <tr><td><code>[attr~=<em>regex</em>]</code></td><td>elements with an attribute named "attr", and value matching the regular expression</td><td><code>img[src~=(?i)\\.(png|jpe?g)]</code></td></tr>
@@ -43,7 +43,7 @@
  * <tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>
  * <tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>
  * <tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds divs that contain p elements </td></tr>
- * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the "logo" class.<br /><code>div:not(:has(div))</code> finds divs that do not contain divs.</code></td></tr>
+ * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the "logo" class.<br /><code>div:not(:has(div))</code> finds divs that do not contain divs.</td></tr>
  * <tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants.</td><td><code>p:contains(jsoup)</code> finds p elements containing the text "jsoup".</td></tr>
  * <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>
  * <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contain the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text "jsoup".</td></tr>

File: src/test/java/org/jsoup/nodes/DocumentTest.java
Patch:
@@ -84,7 +84,7 @@ public class DocumentTest {
         Document clone = doc.clone();
 
         assertEquals(doc.html(), clone.html());
-        assertEquals("<!DOCTYPE html><html><head><title>Doctype test</title></head><body></body></html>",
+        assertEquals("<!doctype html><html><head><title>Doctype test</title></head><body></body></html>",
                 TextUtil.stripNewlines(clone.html()));
     }
     
@@ -108,7 +108,7 @@ public class DocumentTest {
         Document doc = Jsoup.parse(h);
 
         doc.outputSettings().syntax(Syntax.html);
-        assertEquals("<!DOCTYPE html>\n" +
+        assertEquals("<!doctype html>\n" +
                 "<html>\n" +
                 " <head></head>\n" +
                 " <body>\n" +

File: src/test/java/org/jsoup/nodes/DocumentTypeTest.java
Patch:
@@ -27,7 +27,7 @@ public void constructorValidationOkWithBlankPublicAndSystemIds() {
 
     @Test public void outerHtmlGeneration() {
         DocumentType html5 = new DocumentType("html", "", "", "");
-        assertEquals("<!DOCTYPE html>", html5.outerHtml());
+        assertEquals("<!doctype html>", html5.outerHtml());
 
         DocumentType publicDocType = new DocumentType("html", "-//IETF//DTD HTML//", "", "");
         assertEquals("<!DOCTYPE html PUBLIC \"-//IETF//DTD HTML//\">", publicDocType.outerHtml());

File: src/test/java/org/jsoup/integration/UrlConnectTest.java
Patch:
@@ -23,7 +23,7 @@
  Tests the URL connection. Not enabled by default, so tests don't require network connection.
 
  @author Jonathan Hedley, jonathan@hedley.net */
-//@Ignore // ignored by default so tests don't require network access. comment out to enable.
+@Ignore // ignored by default so tests don't require network access. comment out to enable.
 public class UrlConnectTest {
     private static final String WEBSITE_WITH_INVALID_CERTIFICATE = "https://certs.cac.washington.edu/CAtest/";
     private static final String WEBSITE_WITH_SNI = "https://sni.velox.ch/";

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -286,7 +286,7 @@ private Map.Entry<String, String> scanHeaders(String name) {
         }
 
         public String cookie(String name) {
-            Validate.notNull(name, "Cookie name must not be null");
+            Validate.notEmpty(name, "Cookie name must not be empty");
             return cookies.get(name);
         }
 
@@ -298,12 +298,12 @@ public T cookie(String name, String value) {
         }
 
         public boolean hasCookie(String name) {
-            Validate.notEmpty("Cookie name must not be empty");
+            Validate.notEmpty(name, "Cookie name must not be empty");
             return cookies.containsKey(name);
         }
 
         public T removeCookie(String name) {
-            Validate.notEmpty("Cookie name must not be empty");
+            Validate.notEmpty(name, "Cookie name must not be empty");
             cookies.remove(name);
             return (T) this;
         }

File: src/main/java/org/jsoup/select/Evaluator.java
Patch:
@@ -489,7 +489,7 @@ protected int calculatePosition(Element root, Element element) {
 			int pos = 0;
         	Elements family = element.parent().children();
         	for (int i = 0; i < family.size(); i++) {
-        		if (family.get(i).tag() == element.tag()) pos++;
+        		if (family.get(i).tag().equals(element.tag())) pos++;
         		if (family.get(i) == element) break;
         	}
 			return pos;
@@ -512,7 +512,7 @@ protected int calculatePosition(Element root, Element element) {
 			int pos = 0;
         	Elements family = element.parent().children();
         	for (int i = element.elementSiblingIndex(); i < family.size(); i++) {
-        		if (family.get(i).tag() == element.tag()) pos++;
+        		if (family.get(i).tag().equals(element.tag())) pos++;
         	}
 			return pos;
 		}

File: src/main/java/org/jsoup/select/Evaluator.java
Patch:
@@ -278,6 +278,9 @@ public AttributeKeyPair(String key, String value) {
             Validate.notEmpty(value);
 
             this.key = key.trim().toLowerCase();
+            if (value.startsWith("\"") && value.endsWith("\"")) {
+                value = value.substring(1, value.length()-1);
+            }
             this.value = value.trim().toLowerCase();
         }
     }

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -26,6 +26,7 @@
  * <tr><td><code>[attr]</code></td><td>elements with an attribute named "attr" (with any value)</td><td><code>a[href]</code>, <code>[title]</code></td></tr>
  * <tr><td><code>[^attrPrefix]</code></td><td>elements with an attribute name starting with "attrPrefix". Use to find elements with HTML5 datasets</td><td><code>[^data-]</code>, <code>div[^data-]</code></td></tr>
  * <tr><td><code>[attr=val]</code></td><td>elements with an attribute named "attr", and value equal to "val"</td><td><code>img[width=500]</code>, <code>a[rel=nofollow]</code></td></tr>
+ * <tr><td><code>[attr=&quot;val&quot;]</code></td><td>elements with an attribute named "attr", and value equal to "val"</td><td><code>span[hello="Cleveland"][goodbye="Columbus"]</code>, <code>a[rel=&quot;nofollow&quot;]</code></td></tr>
  * <tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named "attr", and value starting with "valPrefix"</td><td><code>a[href^=http:]</code></code></td></tr>
  * <tr><td><code>[attr$=valSuffix]</code></td><td>elements with an attribute named "attr", and value ending with "valSuffix"</td><td><code>img[src$=.png]</code></td></tr>
  * <tr><td><code>[attr*=valContaining]</code></td><td>elements with an attribute named "attr", and value containing "valContaining"</td><td><code>a[href*=/search/]</code></td></tr>

File: src/main/java/org/jsoup/parser/Token.java
Patch:
@@ -78,7 +78,7 @@ void finaliseTag() {
         }
 
         String name() {
-            Validate.isFalse(tagName.length() == 0);
+            Validate.isFalse(tagName == null || tagName.length() == 0);
             return tagName;
         }
 

File: src/main/java/org/jsoup/parser/Tokeniser.java
Patch:
@@ -195,6 +195,8 @@ boolean isAppropriateEndTagToken() {
     }
 
     String appropriateEndTagName() {
+        if (lastStartTag == null)
+            return null;
         return lastStartTag.tagName;
     }
 
@@ -245,4 +247,4 @@ String unescapeEntities(boolean inAttribute) {
         }
         return builder.toString();
     }
-}
\ No newline at end of file
+}

File: src/main/java/org/jsoup/parser/TokeniserState.java
Patch:
@@ -216,7 +216,7 @@ void read(Tokeniser t, CharacterReader r) {
             if (r.matches('/')) {
                 t.createTempBuffer();
                 t.advanceTransition(RCDATAEndTagOpen);
-            } else if (r.matchesLetter() && !r.containsIgnoreCase("</" + t.appropriateEndTagName())) {
+            } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase("</" + t.appropriateEndTagName())) {
                 // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than
                 // consuming to EOF; break out here
                 t.tagPending = new Token.EndTag(t.appropriateEndTagName());
@@ -1722,4 +1722,4 @@ private static final void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader
                 t.transition(fallback);
         }
     }
-}
\ No newline at end of file
+}

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -453,12 +453,12 @@ public Element wrap(String html) {
      * @return the CSS Path that can be used to retrieve the element in a selector.
      */
     public String cssSelector() {
-        if (!id().isEmpty())
+        if (id().length() > 0)
             return "#" + id();
 
         StringBuilder selector = new StringBuilder(tagName());
         String classes = StringUtil.join(classNames(), ".");
-        if (!classes.isEmpty())
+        if (classes.length() > 0)
             selector.append('.').append(classes);
 
         if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node

File: src/main/java/org/jsoup/helper/DataUtil.java
Patch:
@@ -178,7 +178,7 @@ static String getCharsetFromContentType(String contentType) {
         if (m.find()) {
             String charset = m.group(1).trim();
             charset = charset.replace("charset=", "");
-            if (charset.isEmpty()) return null;
+            if (charset.length() == 0) return null;
             try {
                 if (Charset.isSupported(charset)) return charset;
                 charset = charset.toUpperCase(Locale.ENGLISH);

File: src/main/java/org/jsoup/select/Elements.java
Patch:
@@ -8,9 +8,9 @@
 import java.util.*;
 
 /**
- A list of {@link Element Elements}, with methods that act on every element in the list.
+ A list of {@link Element}s, with methods that act on every element in the list.
  <p/>
- To get an Elements object, use the {@link Element#select(String)} method.
+ To get an {@code Elements} object, use the {@link Element#select(String)} method.
 
  @author Jonathan Hedley, jonathan@hedley.net */
 public class Elements implements List<Element>, Cloneable {
@@ -497,7 +497,7 @@ public Elements traverse(NodeVisitor nodeVisitor) {
 
     /**
      * Get the {@link FormElement} forms from the selected elements, if any.
-     * @return a list of FormElements pulled from the matched elements. The list will be empty if the elements contain
+     * @return a list of {@link FormElement}s pulled from the matched elements. The list will be empty if the elements contain
      * no forms.
      */
     public List<FormElement> forms() {

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -22,6 +22,8 @@
  * @see org.jsoup.Jsoup#connect(String) 
  */
 public class HttpConnection implements Connection {
+    private static final int HTTP_TEMP_REDIR = 307; // http/1.1 temporary redirect, not in Java's set.
+
     public static Connection connect(String url) {
         Connection con = new HttpConnection();
         con.url(url);
@@ -443,7 +445,7 @@ static Response execute(Connection.Request req, Response previousResponse) throw
                 int status = conn.getResponseCode();
                 boolean needsRedirect = false;
                 if (status != HttpURLConnection.HTTP_OK) {
-                    if (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER)
+                    if (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER || status == HTTP_TEMP_REDIR)
                         needsRedirect = true;
                     else if (!req.ignoreHttpErrors())
                         throw new HttpStatusException("HTTP error fetching URL", status, req.url().toString());

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -51,6 +51,7 @@ class HtmlTreeBuilder extends TreeBuilder {
     @Override
     Document parse(String input, String baseUri, ParseErrorList errors) {
         state = HtmlTreeBuilderState.Initial;
+        baseUriSetFromDoc = false;
         return super.parse(input, baseUri, errors);
     }
 

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -806,9 +806,9 @@ public Elements getAllElements() {
     }
 
     /**
-     * Gets the combined text of this element and all its children.
+     * Gets the combined text of this element and all its children. Whitespace is normalized and trimmed.
      * <p>
-     * For example, given HTML {@code <p>Hello <b>there</b> now!</p>}, {@code p.text()} returns {@code "Hello there now!"}
+     * For example, given HTML {@code <p>Hello  <b>there</b> now! </p>}, {@code p.text()} returns {@code "Hello there now!"}
      *
      * @return unencoded text, or empty string if none.
      * @see #ownText()

File: src/main/java/org/jsoup/nodes/DocumentType.java
Patch:
@@ -19,7 +19,6 @@ public class DocumentType extends Node {
     public DocumentType(String name, String publicId, String systemId, String baseUri) {
         super(baseUri);
 
-        Validate.notEmpty(name);
         attr("name", name);
         attr("publicId", publicId);
         attr("systemId", systemId);
@@ -32,7 +31,9 @@ public String nodeName() {
 
     @Override
     void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {
-        accum.append("<!DOCTYPE ").append(attr("name"));
+        accum.append("<!DOCTYPE");
+        if (!StringUtil.isBlank(attr("name")))
+            accum.append(" ").append(attr("name"));
         if (!StringUtil.isBlank(attr("publicId")))
             accum.append(" PUBLIC \"").append(attr("publicId")).append('"');
         if (!StringUtil.isBlank(attr("systemId")))

File: src/test/java/org/jsoup/nodes/DocumentTypeTest.java
Patch:
@@ -10,8 +10,8 @@
  * @author Jonathan Hedley, http://jonathanhedley.com/
  */
 public class DocumentTypeTest {
-    @Test(expected = IllegalArgumentException.class)
-    public void constructorValidationThrowsExceptionOnBlankName() {
+    @Test
+    public void constructorValidationOkWithBlankName() {
         DocumentType fail = new DocumentType("","", "", "");
     }
 

File: src/main/java/org/jsoup/helper/DataUtil.java
Patch:
@@ -178,7 +178,7 @@ static String getCharsetFromContentType(String contentType) {
         if (m.find()) {
             String charset = m.group(1).trim();
             charset = charset.replace("charset=", "");
-            if (charset.isEmpty()) return null;
+            if (charset.length() == 0) return null;
             try {
                 if (Charset.isSupported(charset)) return charset;
                 charset = charset.toUpperCase(Locale.ENGLISH);

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -283,7 +283,7 @@ private Map.Entry<String, String> scanHeaders(String name) {
         }
 
         public String cookie(String name) {
-            Validate.notNull(name, "Cookie name must not be null");
+            Validate.notEmpty(name, "Cookie name must not be empty");
             return cookies.get(name);
         }
 
@@ -295,12 +295,12 @@ public T cookie(String name, String value) {
         }
 
         public boolean hasCookie(String name) {
-            Validate.notEmpty("Cookie name must not be empty");
+            Validate.notEmpty(name, "Cookie name must not be empty");
             return cookies.containsKey(name);
         }
 
         public T removeCookie(String name) {
-            Validate.notEmpty("Cookie name must not be empty");
+            Validate.notEmpty(name, "Cookie name must not be empty");
             cookies.remove(name);
             return (T) this;
         }

File: src/main/java/org/jsoup/nodes/DocumentType.java
Patch:
@@ -34,9 +34,9 @@ public String nodeName() {
     void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {
         accum.append("<!DOCTYPE ").append(attr("name"));
         if (!StringUtil.isBlank(attr("publicId")))
-            accum.append(" PUBLIC \"").append(attr("publicId")).append("\"");
+            accum.append(" PUBLIC \"").append(attr("publicId")).append('"');
         if (!StringUtil.isBlank(attr("systemId")))
-            accum.append(" \"").append(attr("systemId")).append("\"");
+            accum.append(" \"").append(attr("systemId")).append('"');
         accum.append('>');
     }
 

File: src/main/java/org/jsoup/parser/Tag.java
Patch:
@@ -230,11 +230,11 @@ public String toString() {
             "var", "cite", "abbr", "time", "acronym", "mark", "ruby", "rt", "rp", "a", "img", "br", "wbr", "map", "q",
             "sub", "sup", "bdo", "iframe", "embed", "span", "input", "select", "textarea", "label", "button", "optgroup",
             "option", "legend", "datalist", "keygen", "output", "progress", "meter", "area", "param", "source", "track",
-            "summary", "command", "device"
+            "summary", "command", "device", "area", "basefont", "bgsound", "menuitem", "param", "source", "track"
     };
     private static final String[] emptyTags = {
             "meta", "link", "base", "frame", "img", "br", "wbr", "embed", "hr", "input", "keygen", "col", "command",
-            "device"
+            "device", "area", "basefont", "bgsound", "menuitem", "param", "source", "track"
     };
     private static final String[] formatAsInlineTags = {
             "title", "a", "p", "h1", "h2", "h3", "h4", "h5", "h6", "pre", "address", "li", "th", "td", "script", "style",

File: src/test/java/org/jsoup/nodes/ElementTest.java
Patch:
@@ -212,7 +212,7 @@ public class ElementTest {
 
     @Test public void testOuterHtml() {
         Document doc = Jsoup.parse("<div title='Tags &amp;c.'><img src=foo.png><p><!-- comment -->Hello<p>there");
-        assertEquals("<html><head></head><body><div title=\"Tags &amp;c.\"><img src=\"foo.png\" /><p><!-- comment -->Hello</p><p>there</p></div></body></html>",
+        assertEquals("<html><head></head><body><div title=\"Tags &amp;c.\"><img src=\"foo.png\"><p><!-- comment -->Hello</p><p>there</p></div></body></html>",
                 TextUtil.stripNewlines(doc.outerHtml()));
     }
 
@@ -457,10 +457,10 @@ public class ElementTest {
     @Test public void parentlessToString() {
         Document doc = Jsoup.parse("<img src='foo'>");
         Element img = doc.select("img").first();
-        assertEquals("<img src=\"foo\" />", img.toString());
+        assertEquals("<img src=\"foo\">", img.toString());
 
         img.remove(); // lost its parent
-        assertEquals("<img src=\"foo\" />", img.toString());
+        assertEquals("<img src=\"foo\">", img.toString());
     }
 
     @Test public void testClone() {

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -1097,8 +1097,8 @@ void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out)
      */
     public String html() {
         StringBuilder accum = new StringBuilder();
-        html(accum); 
-        return accum.toString().trim();
+        html(accum);
+        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();
     }
 
     private void html(StringBuilder accum) {

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -557,7 +557,7 @@ protected void outerHtml(StringBuilder accum) {
     }
 
     // if this node has no document (or parent), retrieve the default output settings
-    private Document.OutputSettings getOutputSettings() {
+    Document.OutputSettings getOutputSettings() {
         return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document("")).outputSettings();
     }
 

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -722,7 +722,8 @@ else if (!tb.onStack(formatEl)) {
                                 commonAncestor.appendChild(lastNode);
                             }
 
-                            Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());
+                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());
+                            adopter.attributes().addAll(formatEl.attributes());
                             Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);
                             for (Node childNode : childNodes) {
                                 adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.

File: src/main/java/org/jsoup/parser/CharacterReader.java
Patch:
@@ -86,9 +86,9 @@ int nextIndexOf(CharSequence seq) {
             // scan to first instance of startchar:
             if (startChar != input[offset])
                 while(++offset < length && startChar != input[offset]);
-            if (offset < length) {
-                int i = offset + 1;
-                int last = i + seq.length()-1;
+            int i = offset + 1;
+            int last = i + seq.length()-1;
+            if (offset < length && last <= length) {
                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);
                 if (i == last) // found full sequence
                     return offset - pos;

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -159,6 +159,7 @@ Element insert(Token.StartTag startTag) {
         if (startTag.isSelfClosing()) {
             Element el = insertEmpty(startTag);
             stack.add(el);
+            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data
             tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing
             return el;
         }

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -127,10 +127,11 @@ boolean process(Token t, HtmlTreeBuilder tb) {
                         tb.transition(InHeadNoscript);
                     } else if (name.equals("script")) {
                         // skips some script rules as won't execute them
-                        tb.insert(start);
+
                         tb.tokeniser.transition(TokeniserState.ScriptData);
                         tb.markInsertionMode();
                         tb.transition(Text);
+                        tb.insert(start);
                     } else if (name.equals("head")) {
                         tb.error(this);
                         return false;

File: src/test/java/org/jsoup/parser/HtmlParserTest.java
Patch:
@@ -326,9 +326,9 @@ public class HtmlParserTest {
 
     @Test public void handlesKnownEmptyBlocks() {
         // if a known tag, allow self closing outside of spec, but force an end tag. unknown tags can be self closing.
-        String h = "<div id='1' /><div id=2><img /><img></div><a id=3 /><i /><foo /><foo>One</foo> <hr /> hr text <hr> hr text two";
+        String h = "<div id='1' /><script src='/foo' /><div id=2><img /><img></div><a id=3 /><i /><foo /><foo>One</foo> <hr /> hr text <hr> hr text two";
         Document doc = Jsoup.parse(h);
-        assertEquals("<div id=\"1\"></div><div id=\"2\"><img /><img /></div><a id=\"3\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr /> hr text two", TextUtil.stripNewlines(doc.body().html()));
+        assertEquals("<div id=\"1\"></div><script src=\"/foo\"></script><div id=\"2\"><img /><img /></div><a id=\"3\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr /> hr text two", TextUtil.stripNewlines(doc.body().html()));
     }
 
     @Test public void handlesSolidusAtAttributeEnd() {

File: src/main/java/org/jsoup/parser/TokeniserState.java
Patch:
@@ -971,7 +971,7 @@ void read(Tokeniser t, CharacterReader r) {
                     t.transition(AfterAttributeValue_quoted);
                     break;
                 case '&':
-                    char[] ref = t.consumeCharacterReference('"', true);
+                    char[] ref = t.consumeCharacterReference('\'', true);
                     if (ref != null && ref.length>0)
                         t.tagPending.appendAttributeValue(new String(ref));
                     else
@@ -1005,7 +1005,7 @@ void read(Tokeniser t, CharacterReader r) {
                     t.transition(BeforeAttributeName);
                     break;
                 case '&':
-                    char[] ref = t.consumeCharacterReference('"', true);
+                    char[] ref = t.consumeCharacterReference('>', true);
                     if (ref != null && ref.length>0)
                         t.tagPending.appendAttributeValue(new String(ref));
                     else

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -1083,7 +1083,7 @@ void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out)
     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {
         if (!(childNodes.isEmpty() && tag.isSelfClosing())) {
             if (out.prettyPrint() && (!childNodes.isEmpty() && (
-                    tag.formatAsBlock() || (out.outline() && childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode)))
+                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))
             )))
                 indent(accum, depth, out);
             accum.append("</").append(tagName()).append(">");

File: src/main/java/org/jsoup/nodes/TextNode.java
Patch:
@@ -95,7 +95,7 @@ void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out)
             html = normaliseWhitespace(html);
         }
 
-        if (out.prettyPrint() && ((siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank()) || (out.forceAllElementAsBlock() && siblingNodes().size()>0 && !isBlank()) )) 
+        if (out.prettyPrint() && ((siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank()) || (out.outline() && siblingNodes().size()>0 && !isBlank()) ))
             indent(accum, depth, out);
         accum.append(html);
     }

File: src/test/java/org/jsoup/nodes/ElementTest.java
Patch:
@@ -226,9 +226,9 @@ public class ElementTest {
         assertEquals("<html>\n <head>\n  <title>Format test</title>\n </head>\n <body>\n  <div>\n   <p>Hello <span>jsoup <span>users</span></span></p>\n   <p>Good.</p>\n  </div>\n </body>\n</html>", doc.html());
     }
     
-    @Test public void testForceAllElementAsBlock() {
+    @Test public void testFormatOutline() {
         Document doc = Jsoup.parse("<title>Format test</title><div><p>Hello <span>jsoup <span>users</span></span></p><p>Good.</p></div>");
-        doc.outputSettings().forceAllElementAsBlock(true);
+        doc.outputSettings().outline(true);
         assertEquals("<html>\n <head>\n  <title>Format test</title>\n </head>\n <body>\n  <div>\n   <p>\n    Hello \n    <span>\n     jsoup \n     <span>users</span>\n    </span>\n   </p>\n   <p>Good.</p>\n  </div>\n </body>\n</html>", doc.html());
     }
 

File: src/main/java/org/jsoup/nodes/TextNode.java
Patch:
@@ -91,7 +91,7 @@ public TextNode splitText(int offset) {
 
     void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {
         String html = Entities.escape(getWholeText(), out);
-        if (out.prettyPrint() && parent() instanceof Element && !((Element) parent()).preserveWhitespace()) {
+        if (out.prettyPrint() && parent() instanceof Element && !Element.preserveWhitespace((Element) parent())) {
             html = normaliseWhitespace(html);
         }
 

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -664,7 +664,9 @@ else if (!tb.onStack(formatEl)) {
                             Element commonAncestor = null;
                             boolean seenFormattingElement = false;
                             LinkedList<Element> stack = tb.getStack();
-                            for (int si = 0; si < stack.size(); si++) {
+                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents
+                            // run-aways
+                            for (int si = 0; si < stack.size() && si < 64; si++) {
                                 Element el = stack.get(si);
                                 if (el == formatEl) {
                                     commonAncestor = stack.get(si - 1);

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -1135,7 +1135,7 @@ public int hashCode() {
     @Override
     public Element clone() {
         Element clone = (Element) super.clone();
-        clone.classNames(); // creates linked set of class names from class attribute
+        clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames
         return clone;
     }
 }

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -721,7 +721,7 @@ else if (!tb.onStack(formatEl)) {
                             }
 
                             Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());
-                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);
+                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);
                             for (Node childNode : childNodes) {
                                 adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.
                             }

File: src/main/java/org/jsoup/select/NodeTraversor.java
Patch:
@@ -28,7 +28,7 @@ public void traverse(Node root) {
         
         while (node != null) {
             visitor.head(node, depth);
-            if (node.childNodes().size() > 0) {
+            if (node.childNodeSize() > 0) {
                 node = node.childNode(0);
                 depth++;
             } else {

File: src/test/java/org/jsoup/parser/HtmlParserTest.java
Patch:
@@ -284,7 +284,7 @@ public class HtmlParserTest {
         Element div = doc.getElementById("1");
         assertEquals("<html> <foo><&amp;", div.text());
         assertEquals(0, div.children().size());
-        assertEquals(1, div.childNodes().size()); // no elements, one text node
+        assertEquals(1, div.childNodeSize()); // no elements, one text node
     }
 
     @Test public void handlesInvalidStartTags() {

File: src/test/java/org/jsoup/safety/CleanerTest.java
Patch:
@@ -176,7 +176,7 @@ public class CleanerTest {
         Document dirtyDoc = Jsoup.parse(dirty);
         Document cleanDoc = new Cleaner(Whitelist.basic()).clean(dirtyDoc);
         assertFalse(cleanDoc == null);
-        assertEquals(0, cleanDoc.body().childNodes().size());
+        assertEquals(0, cleanDoc.body().childNodeSize());
     }
 
     @Test public void cleansInternationalText() {

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -167,7 +167,7 @@ private static void accumulateParents(Element el, Elements parents) {
      * a filtered list of children that are elements, and the index is based on that filtered list.
      * 
      * @param index the index number of the element to retrieve
-     * @return the child element, if it exists, or {@code null} if absent.
+     * @return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}
      * @see #childNode(int)
      */
     public Element child(int index) {

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -196,9 +196,9 @@ public String absUrl(String attributeKey) {
     }
 
     /**
-     Get a child node by index
+     Get a child node by its 0-based index.
      @param index index of child node
-     @return the child node at this index.
+     @return the child node at this index. Throws a {@code IndexOutOfBoundsException} if the index is out of bounds.
      */
     public Node childNode(int index) {
         return childNodes.get(index);

File: src/main/java/org/jsoup/select/Elements.java
Patch:
@@ -455,7 +455,7 @@ public Elements parents() {
     // list-like methods
     /**
      Get the first matched element.
-     @return The first matched element, or <code>null</code> if contents is empty;
+     @return The first matched element, or <code>null</code> if contents is empty.
      */
     public Element first() {
         return contents.isEmpty() ? null : contents.get(0);

File: src/main/java/org/jsoup/parser/TokeniserState.java
Patch:
@@ -284,6 +284,7 @@ void read(Tokeniser t, CharacterReader r) {
 
         private void anythingElse(Tokeniser t, CharacterReader r) {
             t.emit("</" + t.dataBuffer.toString());
+            r.unconsume();
             t.transition(Rcdata);
         }
     },

File: src/main/java/org/jsoup/parser/Token.java
Patch:
@@ -168,6 +168,7 @@ public String toString() {
 
     static class Comment extends Token {
         final StringBuilder data = new StringBuilder();
+        boolean bogus = false;
 
         Comment() {
             type = TokenType.Comment;

File: src/main/java/org/jsoup/parser/TokeniserState.java
Patch:
@@ -1091,6 +1091,7 @@ void read(Tokeniser t, CharacterReader r) {
             // rewind to capture character that lead us here
             r.unconsume();
             Token.Comment comment = new Token.Comment();
+            comment.bogus = true;
             comment.data.append(r.consumeTo('>'));
             // todo: replace nullChar with replaceChar
             t.emit(comment);

File: src/main/java/org/jsoup/nodes/DocumentType.java
Patch:
@@ -4,7 +4,7 @@
 import org.jsoup.helper.Validate;
 
 /**
- * A {@code <!DOCTPYE>} node.
+ * A {@code <!DOCTYPE>} node.
  */
 public class DocumentType extends Node {
     // todo: quirk mode from publicId and systemId

File: src/test/java/org/jsoup/safety/CleanerTest.java
Patch:
@@ -92,9 +92,11 @@ public class CleanerTest {
         String ok = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>";
         String nok1 = "<p><script></script>Not <b>OK</b></p>";
         String nok2 = "<p align=right>Test Not <b>OK</b></p>";
+        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
         assertTrue(Jsoup.isValid(ok, Whitelist.basic()));
         assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));
         assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));
+        assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));
     }
     
     @Test public void resolvesRelativeLinks() {
@@ -103,7 +105,7 @@ public class CleanerTest {
         assertEquals("<a href=\"http://example.com/foo\" rel=\"nofollow\">Link</a>\n<img src=\"http://example.com/bar\" />", clean);
     }
 
-    @Test public void preservesRelatedLinksIfConfigured() {
+    @Test public void preservesRelativeLinksIfConfigured() {
         String html = "<a href='/foo'>Link</a><img src='/bar'> <img src='javascript:alert()'>";
         String clean = Jsoup.clean(html, "http://example.com/", Whitelist.basicWithImages().preserveRelativeLinks(true));
         assertEquals("<a href=\"/foo\" rel=\"nofollow\">Link</a>\n<img src=\"/bar\" /> \n<img />", clean);

File: src/test/java/org/jsoup/integration/UrlConnectTest.java
Patch:
@@ -18,7 +18,7 @@
  Tests the URL connection. Not enabled by default, so tests don't require network connection.
 
  @author Jonathan Hedley, jonathan@hedley.net */
-//@Ignore // ignored by default so tests don't require network access. comment out to enable.
+@Ignore // ignored by default so tests don't require network access. comment out to enable.
 public class UrlConnectTest {
     private static String echoURL = "http://direct.infohound.net/tools/q.pl";
 

File: src/main/java/org/jsoup/nodes/Document.java
Patch:
@@ -1,5 +1,6 @@
 package org.jsoup.nodes;
 
+import org.jsoup.helper.StringUtil;
 import org.jsoup.helper.Validate;
 import org.jsoup.parser.Tag;
 import org.jsoup.select.Elements;
@@ -64,8 +65,9 @@ public Element body() {
      @return Trimmed title, or empty string if none set.
      */
     public String title() {
+        // title is a preserve whitespace tag (for document output), but normalised here
         Element titleEl = getElementsByTag("title").first();
-        return titleEl != null ? titleEl.text().trim() : "";
+        return titleEl != null ? StringUtil.normaliseWhitespace(titleEl.text()).trim() : "";
     }
 
     /**

File: src/test/java/org/jsoup/nodes/DocumentTest.java
Patch:
@@ -32,6 +32,9 @@ public class DocumentTest {
         withTitle.title("Hello");
         assertEquals("Hello", withTitle.title());
         assertEquals("Hello", withTitle.select("title").first().text());
+
+        Document normaliseTitle = Jsoup.parse("<title>   Hello\nthere   \n   now   \n");
+        assertEquals("Hello there now", normaliseTitle.title());
     }
 
     @Test public void testOutputEncoding() {

File: src/test/java/org/jsoup/parser/AttributeParseTest.java
Patch:
@@ -57,13 +57,13 @@ public class AttributeParseTest {
     @Test public void strictAttributeUnescapes() {
         String html = "<a id=1 href='?foo=bar&mid&lt=true'>One</a> <a id=2 href='?foo=bar&lt;qux&lg=1'>Two</a>";
         Elements els = Jsoup.parse(html).select("a");
-        assertEquals("?foo=bar&lt=true", els.first().attr("href")); // &mid gets to  because not tailed by =; lt is so not unescaped
+        assertEquals("?foo=bar&mid&lt=true", els.first().attr("href"));
         assertEquals("?foo=bar<qux&lg=1", els.last().attr("href"));
     }
 
     @Test public void moreAttributeUnescapes() {
         String html = "<a href='&wr_id=123&mid-size=true&ok=&wr'>Check</a>";
         Elements els = Jsoup.parse(html).select("a");
-        assertEquals("&wr_id=123&mid-size=true&ok=", els.first().attr("href"));
+        assertEquals("&wr_id=123&mid-size=true&ok=&wr", els.first().attr("href"));
     }
 }

File: src/main/java/org/jsoup/helper/DataUtil.java
Patch:
@@ -96,7 +96,7 @@ static Document parseByteData(ByteBuffer byteData, String charsetName, String ba
             // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present
             // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight
             // into head mode
-            if (docData.charAt(0) == 65279)
+            if (docData.length() > 0 && docData.charAt(0) == 65279)
                 docData = docData.substring(1);
 
             doc = parser.parseInput(docData, baseUri);

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -428,7 +428,7 @@ else if (!req.ignoreHttpErrors())
 
             // check that we can handle the returned content type; if not, abort before fetching it
             String contentType = res.contentType();
-            if (!req.ignoreContentType() && (contentType == null || !(contentType.startsWith("text/") || contentType.startsWith("application/xml") || contentType.startsWith("application/xhtml+xml"))))
+            if (contentType != null && !req.ignoreContentType() && (!(contentType.startsWith("text/") || contentType.startsWith("application/xml") || contentType.startsWith("application/xhtml+xml"))))
                 throw new IOException(String.format("Unhandled content type \"%s\" on URL %s. Must be text/*, application/xml, or application/xhtml+xml",
                     contentType, req.url().toString()));
 

File: src/main/java/org/jsoup/helper/StringUtil.java
Patch:
@@ -110,8 +110,9 @@ public static String normaliseWhitespace(String string) {
         boolean modified = false;
 
         int l = string.length();
-        for (int i = 0; i < l; i++) {
-            int c = string.codePointAt(i);
+        int c;
+        for (int i = 0; i < l; i+= Character.charCount(c)) {
+            c = string.codePointAt(i);
             if (isWhitespace(c)) {
                 if (lastWasWhite) {
                     modified = true;

File: src/main/java/org/jsoup/Jsoup.java
Patch:
@@ -64,7 +64,7 @@ public static Document parse(String html) {
      * Use examples:
      * <ul>
      *  <li><code>Document doc = Jsoup.connect("http://example.com").userAgent("Mozilla").data("name", "jsoup").get();</code></li>
-     *  <li><code>Document doc = Jsoup.connect("http://example.com").cookie("auth", "token").post();
+     *  <li><code>Document doc = Jsoup.connect("http://example.com").cookie("auth", "token").post();</code></li>
      * </ul>
      * @param url URL to connect to. The protocol must be {@code http} or {@code https}.
      * @return the connection. You can add data, cookies, and headers; set the user-agent, referrer, method; and then execute.

File: src/main/java/org/jsoup/safety/Cleaner.java
Patch:
@@ -40,7 +40,8 @@ public Document clean(Document dirtyDocument) {
         Validate.notNull(dirtyDocument);
 
         Document clean = Document.createShell(dirtyDocument.baseUri());
-        copySafeNodes(dirtyDocument.body(), clean.body());
+        if (dirtyDocument.body() != null) // frameset documents won't have a body. the clean doc will have empty body.
+            copySafeNodes(dirtyDocument.body(), clean.body());
 
         return clean;
     }

File: src/main/java/org/jsoup/parser/Tag.java
Patch:
@@ -215,7 +215,7 @@ public String toString() {
     private static final String[] formatAsInlineTags = {
             "title", "a", "p", "h1", "h2", "h3", "h4", "h5", "h6", "pre", "address", "li", "th", "td", "script", "style"
     };
-    private static final String[] preserveWhitespaceTags = {"pre", "plaintext", "title"};
+    private static final String[] preserveWhitespaceTags = {"pre", "plaintext", "title", "textarea"};
 
     static {
         // creates

File: src/main/java/org/jsoup/helper/DataUtil.java
Patch:
@@ -9,6 +9,7 @@
 import java.nio.charset.Charset;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import java.util.Locale;
 
 /**
  * Internal static utilities for handling data.
@@ -126,7 +127,7 @@ static String getCharsetFromContentType(String contentType) {
         if (contentType == null) return null;
         Matcher m = charsetPattern.matcher(contentType);
         if (m.find()) {
-            return m.group(1).trim().toUpperCase();
+            return m.group(1).trim().toUpperCase(Locale.ENGLISH);
         }
         return null;
     }

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -42,7 +42,7 @@
  * <tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>
  * <tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>
  * <tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds divs that contain p elements </td></tr>
- * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><code>div:not(.logo)</code> finds all divs that do not have the "logo" class.<br /><code>div:not(:has(div))</code> finds divs that do not contain divs.</code></td></tr>
+ * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the "logo" class.<br /><code>div:not(:has(div))</code> finds divs that do not contain divs.</code></td></tr>
  * <tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants.</td><td><code>p:contains(jsoup)</code> finds p elements containing the text "jsoup".</td></tr>
  * <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>
  * <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contains the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text "jsoup".</td></tr>

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -39,6 +39,7 @@ Document parse(String input, String baseUri, ParseErrorList errors) {
 
     List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors) {
         // context may be null
+        state = HtmlTreeBuilderState.Initial;
         initialiseParse(inputFragment, baseUri, errors);
         contextElement = context;
         fragmentParsing = true;

File: src/main/java/org/jsoup/helper/DataUtil.java
Patch:
@@ -9,6 +9,7 @@
 import java.nio.charset.Charset;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import java.util.Locale;
 
 /**
  * Internal static utilities for handling data.
@@ -126,7 +127,7 @@ static String getCharsetFromContentType(String contentType) {
         if (contentType == null) return null;
         Matcher m = charsetPattern.matcher(contentType);
         if (m.find()) {
-            return m.group(1).trim().toUpperCase();
+            return m.group(1).trim().toUpperCase(Locale.ENGLISH);
         }
         return null;
     }

File: src/main/java/org/jsoup/safety/Whitelist.java
Patch:
@@ -329,10 +329,9 @@ boolean isSafeAttribute(String tagName, Element el, Attribute attr) {
                     return true;
                 }
             }
-        } else { // no attributes defined for tag, try :all tag
-            return !tagName.equals(":all") && isSafeAttribute(":all", el, attr);
         }
-        return false;
+        // no attributes defined for tag, try :all tag
+        return !tagName.equals(":all") && isSafeAttribute(":all", el, attr);
     }
 
     private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {

File: src/main/java/org/jsoup/parser/Tokeniser.java
Patch:
@@ -192,6 +192,8 @@ void createTempBuffer() {
     }
 
     boolean isAppropriateEndTagToken() {
+        if (lastStartTag == null)
+            return false;
         return tagPending.tagName.equals(lastStartTag.tagName);
     }
 

File: src/main/java/org/jsoup/parser/TokeniserState.java
Patch:
@@ -555,7 +555,6 @@ void read(Tokeniser t, CharacterReader r) {
                 String name = r.consumeLetterSequence();
                 t.tagPending.appendTagName(name.toLowerCase());
                 t.dataBuffer.append(name);
-                r.advance();
                 return;
             }
 

File: src/main/java/org/jsoup/parser/Tokeniser.java
Patch:
@@ -132,7 +132,7 @@ Character consumeCharacterReference(Character additionalAllowedCharacter, boolea
             }
         } else { // named
             // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
-            String nameRef = reader.consumeLetterSequence();
+            String nameRef = reader.consumeLetterThenDigitSequence();
             String origNameRef = new String(nameRef); // for error reporting. nameRef gets chomped looking for matches
             boolean looksLegit = reader.matches(';');
             boolean found = false;

File: src/main/java/org/jsoup/select/Elements.java
Patch:
@@ -405,7 +405,7 @@ public Elements select(String query) {
     }
 
     /**
-     * Remove elements from this list that do not match the {@link Selector} query.
+     * Remove elements from this list that match the {@link Selector} query.
      * <p>
      * E.g. HTML: {@code <div class=logo>One</div> <div>Two</div>}<br>
      * <code>Elements divs = doc.select("div").not("#logo");</code><br>

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -505,7 +505,7 @@ public Node traverse(NodeVisitor nodeVisitor) {
      @return HTML
      */
     public String outerHtml() {
-        StringBuilder accum = new StringBuilder(32*1024);
+        StringBuilder accum = new StringBuilder(128);
         outerHtml(accum);
         return accum.toString();
     }

File: src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
Patch:
@@ -1432,12 +1432,11 @@ boolean process(Token t, HtmlTreeBuilder tb) {
                 return tb.process(t, InBody);
             } else if (t.isEOF()) {
                 // nice work chuck
-            } else if (t.isStartTag() && t.asStartTag().name().equals("nofrmes")) {
+            } else if (t.isStartTag() && t.asStartTag().name().equals("noframes")) {
                 return tb.process(t, InHead);
             } else {
                 tb.error(this);
-                tb.transition(InBody);
-                return tb.process(t);
+                return false;
             }
             return true;
         }

File: src/main/java/org/jsoup/parser/XmlTreeBuilder.java
Patch:
@@ -10,8 +10,8 @@
  */
 public class XmlTreeBuilder extends TreeBuilder {
     @Override
-    protected void initialiseParse(String input, String baseUri, boolean trackErrors) {
-        super.initialiseParse(input, baseUri, trackErrors);
+    protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {
+        super.initialiseParse(input, baseUri, errors);
         stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)
     }
 

File: src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
Patch:
@@ -138,7 +138,7 @@ boolean isFragmentParsing() {
 
     void error(HtmlTreeBuilderState state) {
         if (trackErrors)
-            errors.add(new ParseError("Unexpected token", state, currentToken, reader.pos()));
+            errors.add(new ParseError(reader.pos(), "Unexpected token [%s] when in state [%s]", currentToken.tokenType(), state));
     }
 
     Element insert(Token.StartTag startTag) {

File: src/main/java/org/jsoup/parser/TreeBuilderState.java
Patch:
@@ -810,6 +810,7 @@ boolean process(Token t, TreeBuilder tb) {
                 return tb.process(t);
             } else if (t.isComment()) {
                 tb.insert(t.asComment());
+                return true;
             } else if (t.isDoctype()) {
                 tb.error(this);
                 return false;

File: src/main/java/org/jsoup/parser/TokeniserState.java
Patch:
@@ -1364,7 +1364,9 @@ void read(Tokeniser t, CharacterReader r) {
                 t.transition(Data);
                 return;
             }
-            if (r.matches('>')) {
+            if (r.matchesAny('\t', '\n', '\f', ' '))
+                r.advance(); // ignore whitespace
+            else if (r.matches('>')) {
                 t.emitDoctypePending();
                 t.advanceTransition(Data);
             } else if (r.matchConsumeIgnoreCase("PUBLIC")) {

File: src/main/java/org/jsoup/safety/Whitelist.java
Patch:
@@ -336,9 +336,11 @@ boolean isSafeAttribute(String tagName, Element el, Attribute attr) {
     }
 
     private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {
-        // resolve relative urls to abs, and optionally update the attribute so output html has abs.
+        // try to resolve relative urls to abs, and optionally update the attribute so output html has abs.
         // rels without a baseuri get removed
         String value = el.absUrl(attr.getKey());
+        if (value.length() == 0)
+            value = attr.getValue(); // if it could not be made abs, run as-is to allow custom unknown protocols
         if (!preserveRelativeLinks)
             attr.setValue(value);
         

File: src/main/java/org/jsoup/parser/TokeniserState.java
Patch:
@@ -1168,6 +1168,7 @@ void read(Tokeniser t, CharacterReader r) {
                     break;
                 case nullChar:
                     t.error(this);
+                    r.advance();
                     t.commentPending.data.append(replacementChar);
                     break;
                 case eof:

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -389,6 +389,8 @@ else if (!req.ignoreHttpErrors())
             Response res = new Response(previousResponse);
             res.setupFromConnection(conn, previousResponse);
             if (needsRedirect && req.followRedirects()) {
+                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.
+                req.data().clear();
                 req.url(new URL(req.url(), res.header("Location")));
                 for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)
                     req.cookie(cookie.getKey(), cookie.getValue());

File: src/main/java/org/jsoup/parser/Parser.java
Patch:
@@ -32,7 +32,7 @@ public static Document parse(String html, String baseUri) {
      * provides stack context (for implicit element creation).
      * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.
      *
-     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modifed.
+     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.
      */
     public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {
         TreeBuilder treeBuilder = new TreeBuilder();

File: src/main/java/org/jsoup/parser/TreeBuilderState.java
Patch:
@@ -1448,7 +1448,7 @@ boolean process(Token t, TreeBuilder tb) {
         }
     };
 
-    private static String nullString = String.valueOf(0x0000);
+    private static String nullString = String.valueOf('\u0000');
 
     abstract boolean process(Token t, TreeBuilder tb);
 

File: src/main/java/org/jsoup/parser/CharacterReader.java
Patch:
@@ -29,7 +29,9 @@ char current() {
     }
 
     char consume() {
-        return isEmpty() ? EOF : input.charAt(pos++);
+        char val = isEmpty() ? EOF : input.charAt(pos);
+        pos++;
+        return val;
     }
 
     void unconsume() {

File: src/main/java/org/jsoup/parser/TokeniserState.java
Patch:
@@ -574,6 +574,7 @@ void read(Tokeniser t, CharacterReader r) {
                     case '>':
                         t.emitTagPending();
                         t.transition(Data);
+                        break;
                     default:
                         t.dataBuffer.append(c);
                         anythingElse(t, r);

File: src/main/java/org/jsoup/parser/TreeBuilder.java
Patch:
@@ -173,7 +173,7 @@ Element insert(Token.StartTag startTag) {
         // handle empty unknown tags
         // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate fake end tag.
         if (startTag.isSelfClosing() && !Tag.isKnownTag(startTag.name())) {
-            Element el =  insertEmpty(startTag);
+            Element el = insertEmpty(startTag);
             process(new Token.EndTag(el.tagName())); // ensure we get out of whatever state we are in
             return el;
         }

File: src/main/java/org/jsoup/parser/TreeBuilderState.java
Patch:
@@ -280,7 +280,7 @@ boolean process(Token t, TreeBuilder tb) {
                             if (!html.hasAttr(attribute.getKey()))
                                 html.attributes().put(attribute);
                         }
-                    } else if (StringUtil.in(name, "base", "basefont", "bgsound", "command", "link", "meta", "noframes", "style", "title")) {
+                    } else if (StringUtil.in(name, "base", "basefont", "bgsound", "command", "link", "meta", "noframes", "script", "style", "title")) {
                         return tb.process(t, InHead);
                     } else if (name.equals("body")) {
                         tb.error(this);

File: src/test/java/org/jsoup/parser/ParserTest.java
Patch:
@@ -158,10 +158,10 @@ public class ParserTest {
         assertEquals("font-family: bold", tels.get(0).data());
         assertEquals("", tels.get(0).text());
 
-        String s = "<p>Hello</p><script>Nope</script><p>There</p>";
+        String s = "<p>Hello</p><script>obj.insert('<a rel=\"none\" />');\ni++;</script><p>There</p>";
         Document doc = Jsoup.parse(s);
         assertEquals("Hello There", doc.text());
-        assertEquals("Nope", doc.data());
+        assertEquals("obj.insert('<a rel=\"none\" />');\ni++;", doc.data());
     }
 
     @Test public void handlesTextAfterData() {

File: src/main/java/org/jsoup/parser/TokeniserState.java
Patch:
@@ -699,6 +699,7 @@ void read(Tokeniser t, CharacterReader r) {
                 case '>':
                     t.emit(c);
                     t.transition(ScriptData);
+                    break;
                 case nullChar:
                     t.error(this);
                     t.emit(replacementChar);

File: src/main/java/org/jsoup/parser/Token.java
Patch:
@@ -68,7 +68,7 @@ void finaliseTag() {
         }
 
         String name() {
-            Validate.isFalse(tagName.isEmpty());
+            Validate.isFalse(tagName.length() == 0);
             return tagName;
         }
 

File: src/main/java/org/jsoup/parser/TreeBuilderState.java
Patch:
@@ -1,5 +1,6 @@
 package org.jsoup.parser;
 
+import org.jsoup.helper.DescendableLinkedList;
 import org.jsoup.helper.StringUtil;
 import org.jsoup.nodes.*;
 
@@ -761,7 +762,7 @@ else if (!tb.onStack(formatEl)) {
 
         boolean anyOtherEndTag(Token t, TreeBuilder tb) {
             String name = t.asEndTag().name();
-            LinkedList<Element> stack = tb.getStack();
+            DescendableLinkedList<Element> stack = tb.getStack();
             Iterator<Element> it = stack.descendingIterator();
             while (it.hasNext()) {
                 Element node = it.next();

File: src/main/java/org/jsoup/helper/DataUtil.java
Patch:
@@ -106,7 +106,6 @@ static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException {
      */
     static String getCharsetFromContentType(String contentType) {
         if (contentType == null) return null;
-        
         Matcher m = charsetPattern.matcher(contentType);
         if (m.find()) {
             return m.group(1).trim().toUpperCase();

File: src/main/java/org/jsoup/helper/DataUtil.java
Patch:
@@ -65,7 +65,7 @@ static Document parseByteData(ByteBuffer byteData, String charsetName, String ba
             Element meta = doc.select("meta[http-equiv=content-type], meta[charset]").first();
             if (meta != null) { // if not found, will keep utf-8 as best attempt
                 String foundCharset = meta.hasAttr("http-equiv") ? getCharsetFromContentType(meta.attr("content")) : meta.attr("charset");
-                if (foundCharset != null && !foundCharset.equals(defaultCharset)) { // need to re-decode
+                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode
                     charsetName = foundCharset;
                     byteData.rewind();
                     docData = Charset.forName(foundCharset).decode(byteData).toString();

File: src/test/java/org/jsoup/integration/UrlConnectTest.java
Patch:
@@ -14,7 +14,7 @@
  Tests the URL connection. Not enabled by default, so tests don't require network connection.
 
  @author Jonathan Hedley, jonathan@hedley.net */
-//@Ignore // ignored by default so tests don't require network access. comment out to enable.
+@Ignore // ignored by default so tests don't require network access. comment out to enable.
 public class UrlConnectTest {
     private static String echoURL = "http://infohound.net/tools/q.pl";
 

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -366,8 +366,8 @@ public String contentType() {
 
         public Document parse() throws IOException {
             Validate.isTrue(executed, "Request must be executed (with .execute(), .get(), or .post() before parsing response");
-            if (contentType == null || !contentType.startsWith("text/"))
-                throw new IOException(String.format("Unhandled content type \"%s\" on URL %s. Must be text/*",
+            if (contentType == null || !(contentType.startsWith("text/") || contentType.startsWith("application/xml") || contentType.startsWith("application/xhtml+xml")))
+                throw new IOException(String.format("Unhandled content type \"%s\" on URL %s. Must be text/*, application/xml, or application/xhtml+xml",
                     contentType, url.toString()));
             Document doc = DataUtil.parseByteData(byteData, charset, url.toExternalForm());
             byteData.rewind();

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -329,7 +329,7 @@ static Response execute(Connection.Request req) throws IOException {
             Response res = new Response();
             res.setupFromConnection(conn);
             if (needsRedirect) {
-                req.url(new URL(res.header("Location")));
+                req.url(new URL(req.url(), res.header("Location")));
                 return execute(req);
             }
 

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -92,7 +92,7 @@ public String toString() {
      * @return attribute
      */
     public static Attribute createFromEncoded(String unencodedKey, String encodedValue) {
-        String value = Entities.unescape(encodedValue);
+        String value = Entities.unescape(encodedValue, true);
         return new Attribute(unencodedKey, value);
     }
 

File: src/main/java/org/jsoup/select/selectors/AndSelector.java
Patch:
@@ -5,7 +5,6 @@
 import java.util.Collection;
 import java.util.List;
 
-import com.sun.xml.internal.ws.util.StringUtils;
 import org.jsoup.helper.StringUtil;
 import org.jsoup.nodes.Element;
 import org.jsoup.select.Evaluator;

File: src/main/java/org/jsoup/nodes/Document.java
Patch:
@@ -203,7 +203,7 @@ public Document clone() {
     /**
      * A Document's output settings control the form of the text() and html() methods.
      */
-    public class OutputSettings implements Cloneable {
+    public static class OutputSettings implements Cloneable {
         private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;
         private Charset charset = Charset.forName("UTF-8");
         private CharsetEncoder charsetEncoder = charset.newEncoder();

File: src/main/java/org/jsoup/select/ng/ElementSelector.java
Patch:
@@ -28,7 +28,8 @@ public boolean select(Element node) {
 			if(tag != null && !el.tagName().equals(tag))
 				return false;
 			
-			if(cls != null && !el.className().equals(cls))
+			
+			if(cls != null && !el.classNames().contains(cls))
 				return false;
 			
 			if(id != null && !el.id().equals(id))

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -169,6 +169,9 @@ public String absUrl(String attributeKey) {
                     URL abs = new URL(relUrl);
                     return abs.toExternalForm();
                 }
+                // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired
+                if (relUrl.startsWith("?"))
+                    relUrl = base.getPath() + relUrl;
                 URL abs = new URL(base, relUrl);
                 return abs.toExternalForm();
             } catch (MalformedURLException e) {

File: src/main/java/org/jsoup/helper/HttpConnection.java
Patch:
@@ -434,7 +434,8 @@ private void setupFromConnection(HttpURLConnection conn) throws IOException {
                         cookie(cookieName, cookieVal);
                     }
                 } else { // only take the first instance of each header
-                    header(name, values.get(0));
+                    if (!values.isEmpty())
+                        header(name, values.get(0));
                 }
             }
         }

File: src/main/java/org/jsoup/nodes/Entities.java
Patch:
@@ -35,7 +35,7 @@ public Map<Character, String> getMap() {
     private static final Map<Character, String> xhtmlByVal;
     private static final Map<Character, String> baseByVal;
     private static final Map<Character, String> fullByVal;
-    private static final Pattern unescapePattern = Pattern.compile("&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?");
+    private static final Pattern unescapePattern = Pattern.compile("&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\d*);?");
 
     static String escape(String string, Document.OutputSettings out) {
         return escape(string, out.encoder(), out.escapeMode());
@@ -62,7 +62,7 @@ static String unescape(String string) {
         if (!string.contains("&"))
             return string;
 
-        Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?
+        Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\d*);?
         StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs
         // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required
 

File: src/main/java/org/jsoup/parser/Tag.java
Patch:
@@ -296,7 +296,7 @@ public String toString() {
 
         // special
         createInline("A").setOptionalClosing(); // cannot contain self
-        createInline("IMG").setEmpty();
+        createInline("IMG").setEmpty().setAncestor("BODY", "NOSCRIPT"); // noscript so an image can be in html->head->noscript
         createInline("BR").setEmpty();
         createInline("WBR").setEmpty();
         createInline("MAP"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD.

File: src/main/java/org/jsoup/helper/DataUtil.java
Patch:
@@ -15,7 +15,7 @@
  *
  */
 public class DataUtil {
-    private static final Pattern charsetPattern = Pattern.compile("(?i)\\bcharset=([^\\s;]*)");
+    private static final Pattern charsetPattern = Pattern.compile("(?i)\\bcharset=\\s*\"?([^\\s;\"]*)");
     static final String defaultCharset = "UTF-8"; // used if not found in header or meta charset
     private static final int bufferSize = 0x20000; // ~130K.
 

File: src/main/java/org/jsoup/nodes/Entities.java
Patch:
@@ -48,6 +48,7 @@ static String unescape(String string) {
 
         Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?
         StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs
+        // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required
 
         while (m.find()) {
             int charval = -1;
@@ -66,9 +67,9 @@ static String unescape(String string) {
 
             if (charval != -1 || charval > 0xFFFF) { // out of range
                 String c = Character.toString((char) charval);
-                m.appendReplacement(accum, c);
+                m.appendReplacement(accum, Matcher.quoteReplacement(c));
             } else {
-                m.appendReplacement(accum, m.group(0)); // replace with original string
+                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // replace with original string
             }
         }
         m.appendTail(accum);

File: src/test/java/org/jsoup/nodes/NodeTest.java
Patch:
@@ -1,6 +1,7 @@
 package org.jsoup.nodes;
 
 import org.jsoup.Jsoup;
+import org.jsoup.TextUtil;
 import org.jsoup.parser.Tag;
 import org.junit.Test;
 
@@ -44,7 +45,7 @@ public class NodeTest {
         p.childNode(0).remove();
         
         assertEquals("two three", p.text());
-        assertEquals("<span>two</span> three", p.html());
+        assertEquals("<span>two</span> three", TextUtil.stripNewlines(p.html()));
     }
     
     @Test public void testReplace() {

File: src/test/java/org/jsoup/nodes/TextNodeTest.java
Patch:
@@ -1,6 +1,7 @@
 package org.jsoup.nodes;
 
 import org.jsoup.Jsoup;
+import org.jsoup.TextUtil;
 import org.junit.Test;
 
 import static org.junit.Assert.*;
@@ -37,10 +38,10 @@ public class TextNodeTest {
         assertEquals(" three &", tn.text());
         
         tn.text(" POW!");
-        assertEquals("One <span>two &amp;</span> POW!", p.html());
+        assertEquals("One <span>two &amp;</span> POW!", TextUtil.stripNewlines(p.html()));
 
         tn.attr("text", "kablam &");
         assertEquals("kablam &", tn.text());
-        assertEquals("One <span>two &amp;</span>kablam &amp;", p.html());
+        assertEquals("One <span>two &amp;</span>kablam &amp;", TextUtil.stripNewlines(p.html()));
     }
 }

File: src/test/java/org/jsoup/parser/TagTest.java
Patch:
@@ -53,8 +53,8 @@ public class TagTest {
         Tag div = Tag.valueOf("div");
 
         assertTrue(span.canContain(span));
-        assertFalse(span.canContain(p));
-        assertFalse(span.canContain(div));
+        assertTrue(span.canContain(p));
+        assertTrue(span.canContain(div));
     }
 
     @Test public void imgSemantics() {

File: src/test/java/org/jsoup/select/ElementsTest.java
Patch:
@@ -118,13 +118,13 @@ public class ElementsTest {
     @Test public void before() {
         Document doc = Jsoup.parse("<p>This <a>is</a> <a>jsoup</a>.</p>");
         doc.select("a").before("<span>foo</span>");
-        assertEquals("<p>This <span>foo</span><a>is</a> <span>foo</span><a>jsoup</a>.</p>", doc.body().html());
+        assertEquals("<p>This <span>foo</span><a>is</a> <span>foo</span><a>jsoup</a>.</p>", TextUtil.stripNewlines(doc.body().html()));
     }
     
     @Test public void after() {
         Document doc = Jsoup.parse("<p>This <a>is</a> <a>jsoup</a>.</p>");
         doc.select("a").after("<span>foo</span>");
-        assertEquals("<p>This <a>is</a><span>foo</span> <a>jsoup</a><span>foo</span>.</p>", doc.body().html());
+        assertEquals("<p>This <a>is</a><span>foo</span> <a>jsoup</a><span>foo</span>.</p>", TextUtil.stripNewlines(doc.body().html()));
     }
 
     @Test public void wrap() {

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -66,7 +66,7 @@ public String setValue(String value) {
      @return HTML
      */
     public String html() {
-        return key + "=\"" + Entities.escape(value, (new Document(null)).outputSettings()) + "\"";
+        return key + "=\"" + Entities.escape(value, (new Document("")).outputSettings()) + "\"";
     }
     
     protected void html(StringBuilder accum, Document.OutputSettings out) {

File: src/main/java/org/jsoup/nodes/Comment.java
Patch:
@@ -30,7 +30,8 @@ public String getData() {
     }
 
     void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {
-        indent(accum, depth);
+        if (out.prettyPrint())
+            indent(accum, depth, out);
         accum
                 .append("<!--")
                 .append(getData())

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -372,8 +372,8 @@ public String toString() {
         return outerHtml();
     }
 
-    protected void indent(StringBuilder accum, int depth) {
-        accum.append("\n").append(StringUtil.padding(depth));
+    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {
+        accum.append("\n").append(StringUtil.padding(depth * out.indentAmount()));
     }
 
     @Override

File: src/main/java/org/jsoup/nodes/TextNode.java
Patch:
@@ -71,12 +71,12 @@ public boolean isBlank() {
 
     void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {
         String html = Entities.escape(getWholeText(), out);
-        if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) {
+        if (out.prettyPrint() && parent() instanceof Element && !((Element) parent()).preserveWhitespace()) {
             html = normaliseWhitespace(html);
         }
 
-        if (siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && !isBlank())
-            indent(accum, depth);
+        if (out.prettyPrint() && siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && !isBlank())
+            indent(accum, depth, out);
         accum.append(html);
     }
 

File: src/main/java/org/jsoup/nodes/Attributes.java
Patch:
@@ -118,7 +118,7 @@ public Map<String, String> dataset() {
      */
     public String html() {
         StringBuilder accum = new StringBuilder();
-        html(accum, (new Document(null)).outputSettings()); // output settings a bit funky, but this html() seldom used
+        html(accum, (new Document("")).outputSettings()); // output settings a bit funky, but this html() seldom used
         return accum.toString();
     }
     

File: src/main/java/org/jsoup/parser/Parser.java
Patch:
@@ -203,7 +203,9 @@ private Attribute parseAttribute() {
         if (key.length() != 0)
             return Attribute.createFromEncoded(key, value);
         else {
-            tq.consume(); // unknown char, keep popping so not get stuck
+            if (value.length() == 0) // no key, no val; unknown char, keep popping so not get stuck
+                tq.advance();
+                
             return null;
         }
     }

File: src/main/java/org/jsoup/nodes/Element.java
Patch:
@@ -110,7 +110,7 @@ public Element attr(String attributeKey, String attributeValue) {
      * Get this element's HTML5 custom data attributes. Each attribute in the element that has a key
      * starting with "data-" is included the dataset.
      * <p>
-     * E.g., the element {@code &lt;div data-package="jsoup" data-language="Java" class="group"&gt;...} has the dataset
+     * E.g., the element {@code <div data-package="jsoup" data-language="Java" class="group">...} has the dataset
      * {@code package=jsoup, language=java}.
      * <p>
      * This map is a filtered view of the element's attribute map. Changes to one map (add, remove, update) are reflected

File: src/main/java/org/jsoup/nodes/Attribute.java
Patch:
@@ -20,7 +20,7 @@ public class Attribute {
     public Attribute(String key, String value) {
         Validate.notEmpty(key);
         Validate.notNull(value);
-        this.key = key.trim().toLowerCase();
+        this.key = key.trim().toLowerCase().intern(); // attribute keys are interned as often repeated
         this.value = value;
     }
 

File: src/main/java/org/jsoup/nodes/Attributes.java
Patch:
@@ -15,7 +15,7 @@
  * @author Jonathan Hedley, jonathan@hedley.net
  */
 public class Attributes implements Iterable<Attribute> {
-    private LinkedHashMap<String, Attribute> attributes = new LinkedHashMap<String, Attribute>();
+    private LinkedHashMap<String, Attribute> attributes = new LinkedHashMap<String, Attribute>(2);
     // linked hash map to preserve insertion order.
 
     /**

File: src/main/java/org/jsoup/nodes/Node.java
Patch:
@@ -28,7 +28,7 @@ protected Node(String baseUri, Attributes attributes) {
         Validate.notNull(baseUri);
         Validate.notNull(attributes);
         
-        childNodes = new ArrayList<Node>();
+        childNodes = new ArrayList<Node>(4);
         this.baseUri = baseUri.trim();
         this.attributes = attributes;
     }

File: src/main/java/org/jsoup/select/Selector.java
Patch:
@@ -39,7 +39,7 @@ The universal selector (*) is implicit when no element selector is supplied (i.e
  <tr><td><td colspan="3"><h3>Pseudo selectors</h3></td></tr>
  <tr><td><code>E:lt(<em>n</em>)</code></td><td>an Element whose sibling index is less than <em>n</em></td><td><code>td:lt(3)</code> finds the first 2 cells of each row</td></tr>
  <tr><td><code>E:gt(<em>n</em>)</code></td><td>an Element whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>
- <tr><td><code>E:eq(<em>n</em>)</code></td><td>an Element whose sibling index is equal to <em>n</em></td><td><code>td:eq(1)</code> finds the first cell of each row</td></tr>
+ <tr><td><code>E:eq(<em>n</em>)</code></td><td>an Element whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>
  <tr><td><code>E:has(<em>selector</em>)</code></td><td>an Element that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds divs that contain p elements </td></tr>
  <tr><td><code>E:contains(<em>text</em>)</code></td><td>an Element that contains the specified text. The search is case insensitive. The text may appear in the found Element, or any of its descendants.</td><td><code>p:contains(jsoup)</code> finds p elements containing the text "jsoup".</td></tr>
  </table>

File: src/main/java/org/jsoup/nodes/Document.java
Patch:
@@ -120,10 +120,11 @@ private void normalise(Element element) {
             }
         }
 
-        for (Node node: toMove) {
+        for (int i = toMove.size()-1; i >= 0; i--) {
+            Node node = toMove.get(i);
             element.removeChild(node);
-            body().prependChild(node);
             body().prependChild(new TextNode(" ", ""));
+            body().prependChild(node);
         }
     }
 

File: src/test/java/org/jsoup/parser/ParserTest.java
Patch:
@@ -268,7 +268,7 @@ public class ParserTest {
     @Test public void normalisesDocument() {
         String h = "<!doctype html>One<html>Two<head>Three<link></head>Four<body>Five </body>Six </html>Seven ";
         Document doc = Jsoup.parse(h);
-        assertEquals("<!doctype html><html><head><link /></head><body>Five Six Seven  One Two Four Three</body></html>",
+        assertEquals("<!doctype html><html><head><link /></head><body>One Two Four Three Five Six Seven </body></html>",
                 TextUtil.stripNewlines(doc.html())); // is spaced OK if not newline & space stripped
     }
 

File: src/main/java/org/jsoup/select/Elements.java
Patch:
@@ -200,7 +200,7 @@ public String html() {
      * Get the combined inner HTML of all matched elements.
      * @return string of all element's inner HTML.
      * @see #text()
-     * @see #hmtl()
+     * @see #html()
      */
     public String outerHtml() {
         StringBuilder sb = new StringBuilder();

File: src/main/java/org/jsoup/parser/Parser.java
Patch:
@@ -139,11 +139,13 @@ private void parseStartTag() {
         } else {
             tq.matchChomp(">");
         }
+        addChildToParent(child, isEmptyElement);
 
         // pc data only tags (textarea, script): chomp to end tag, add content as text node
         if (tag.isData()) {
             String data = tq.chompTo("</" + tagName);
             tq.chompTo(">");
+            popStackToClose(tag);
             
             Node dataNode;
             if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)
@@ -161,8 +163,6 @@ private void parseStartTag() {
                 doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base
             }
         }
-
-        addChildToParent(child, isEmptyElement);
     }
 
     private Attribute parseAttribute() {

File: src/test/java/org/jsoup/safety/CleanerTest.java
Patch:
@@ -1,4 +1,4 @@
-package org.jsoup.org.jsoup.safety;
+package org.jsoup.safety;
 
 import org.jsoup.Jsoup;
 import org.jsoup.TextUtil;

File: src/main/java/org/jsoup/Jsoup.java
Patch:
@@ -14,6 +14,7 @@
  * @author Jonathan Hedley
  */
 public class Jsoup {
+    private Jsoup() {}
     
     /**
      * Parse HTML into a Document. The parser will make a sensible, balanced document tree out of any HTML.

File: src/test/java/org/jsoup/integration/ParseTest.java
Patch:
@@ -39,11 +39,11 @@ public class ParseTest {
         
         Element a = doc.select("a[href=/entertainment/horoscopes]").first();
         assertEquals("/entertainment/horoscopes", a.attr("href"));
-        assertEquals("http://www.news.com.au/entertainment/horoscopes", a.absUrl("href"));
+        assertEquals("http://www.news.com.au/entertainment/horoscopes", a.attr("abs:href"));
         
         Element hs = doc.select("a[href*=naughty-corners-are-a-bad-idea]").first();
         assertEquals("http://www.heraldsun.com.au/news/naughty-corners-are-a-bad-idea-for-kids/story-e6frf7jo-1225817899003", hs.attr("href"));
-        assertEquals(hs.attr("href"), hs.absUrl("href"));
+        assertEquals(hs.attr("href"), hs.attr("abs:href"));
     }
     
     @Test public void testGoogleSearchIpod() {

File: src/main/java/org/jsoup/parser/Tag.java
Patch:
@@ -83,11 +83,10 @@ public boolean canContain(Tag child) {
             return false;
 
         // head can only contain a few. if more than head in here, modify to have a list of valids
-        // TODO[must] - lookup what head can contain
-        // from memory: base, script, link, meta, title
+        // (could solve this with walk for ancestor)
         if (this.tagName.equals("head")) {
             if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("link") ||
-                    child.tagName.equals("meta") || child.tagName.equals("title")) {
+                    child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) {
                 return true;
             }
             return false;

