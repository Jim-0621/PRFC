File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerTest.java
Patch:
@@ -22,6 +22,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.junit.Assert.fail;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.BDDMockito.given;

File: resilience4j-commons-configuration/src/main/java/io/github/resilience4j/commons/configuration/circuitbreaker/configure/CommonsConfigurationCircuitBreakerConfiguration.java
Patch:
@@ -55,6 +55,7 @@ public class CommonsConfigurationCircuitBreakerConfiguration extends CommonCircu
     protected static final String EXPONENTIAL_MAX_WAIT_DURATION_IN_OPEN_STATE = "exponentialMaxWaitDurationInOpenState";
     protected static final String ENABLE_RANDOMIZED_WAIT = "enableRandomizedWait";
     protected static final String RANDOMIZED_WAIT_FACTOR = "randomizedWaitFactor";
+    protected static final String IGNORE_CLASS_BINDING_EXCEPTIONS = "ignoreClassBindingExceptions";
 
     private CommonsConfigurationCircuitBreakerConfiguration() {
     }
@@ -142,6 +143,8 @@ private Map<String, InstanceProperties> getProperties(final Configuration config
             instanceProperties.setEnableRandomizedWait(configuration.getBoolean(ENABLE_RANDOMIZED_WAIT));
         if (configuration.containsKey(RANDOMIZED_WAIT_FACTOR))
             instanceProperties.setRandomizedWaitFactor(configuration.getDouble(RANDOMIZED_WAIT_FACTOR));
+        if (configuration.containsKey(IGNORE_CLASS_BINDING_EXCEPTIONS))
+            instanceProperties.setIgnoreClassBindingExceptions(configuration.getBoolean(IGNORE_CLASS_BINDING_EXCEPTIONS));
 
         return instanceProperties;
     };

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/circuitbreaker/autoconfigure/CircuitBreakerAutoConfiguration.java
Patch:
@@ -30,7 +30,6 @@
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.Import;
 
-
 /**
  * {@link org.springframework.boot.autoconfigure.EnableAutoConfiguration Auto-configuration} for
  * resilience4j-circuitbreaker.

File: resilience4j-metrics/src/test/java/io/github/resilience4j/metrics/RetryMetricsTest.java
Patch:
@@ -62,8 +62,7 @@ public void shouldReturnTotalNumberOfRequestsAs1ForSuccess() {
     public void shouldReturnTotalNumberOfRequestsAs1ForSuccessVoid() {
         HelloWorldService helloWorldService = mock(HelloWorldService.class);
 
-        Retry retry = Retry.of("metrics", RetryConfig.<String>custom()
-                .retryOnResult(String::isEmpty)
+        Retry retry = Retry.of("metrics", RetryConfig.custom()
                 .maxAttempts(5)
                 .build());
 

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerMetricsTest.java
Patch:
@@ -34,10 +34,11 @@ public class CircuitBreakerMetricsTest {
     public void testCircuitBreakerMetrics() {
         CircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.custom()
             .slidingWindow(10, 10, CircuitBreakerConfig.SlidingWindowType.COUNT_BASED)
+            .clock(MockClock.at(2019, 1, 1, 12, 0, 0, ZoneId.of("UTC")))
             .build();
 
         CircuitBreakerMetrics circuitBreakerMetrics = CircuitBreakerMetrics
-            .forClosed(circuitBreakerConfig, MockClock.at(2019, 1, 1, 12, 0, 0, ZoneId.of("UTC")));
+            .forClosed(circuitBreakerConfig);
 
         circuitBreakerMetrics.onSuccess(0, TimeUnit.NANOSECONDS);
         circuitBreakerMetrics.onSuccess(0, TimeUnit.NANOSECONDS);

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/RetryConfig.java
Patch:
@@ -245,7 +245,7 @@ public Builder<T> maxAttempts(int maxAttempts) {
 
         public Builder<T> waitDuration(Duration waitDuration) {
             if (waitDuration.toMillis() >= 0) {
-                this.intervalBiFunction = (attempt, either) -> waitDuration.toMillis();
+                this.intervalBiFunction((attempt, either) -> waitDuration.toMillis());
             } else {
                 throw new IllegalArgumentException(
                     "waitDuration must be a positive value");
@@ -311,6 +311,7 @@ public Builder<T> writableStackTraceEnabled(boolean bool) {
          */
         public Builder<T> intervalFunction(IntervalFunction f) {
             this.intervalFunction = f;
+            this.intervalBiFunction = null;
             return this;
         }
 
@@ -322,6 +323,7 @@ public Builder<T> intervalFunction(IntervalFunction f) {
          */
         public Builder<T> intervalBiFunction(IntervalBiFunction<T> f) {
             this.intervalBiFunction = f;
+            this.intervalFunction = null;
             return this;
         }
 

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/retry/configuration/RetryConfigurationPropertiesTest.java
Patch:
@@ -82,8 +82,8 @@ public void testRetryProperties() {
         assertThat(retry1.getConsumeResultBeforeRetryAttempt().getClass()).isEqualTo(ConsumeResultBeforeRetryAttempt.class);
         assertThat(retry2).isNotNull();
         assertThat(retry2.getMaxAttempts()).isEqualTo(2);
-        assertThat(retry2.getIntervalFunction().apply(1)).isEqualTo(99L);
-        assertThat(retry2.getIntervalFunction().apply(2)).isEqualTo(99L);
+        assertThat(retry2.getIntervalBiFunction().apply(1,null)).isEqualTo(99L);
+        assertThat(retry2.getIntervalBiFunction().apply(2,null)).isEqualTo(99L);
         assertThat(retry2.isFailAfterMaxAttempts()).isFalse();
         assertThat(retry2.getConsumeResultBeforeRetryAttempt()).isNull();
     }

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/circuitbreaker/configuration/CommonCircuitBreakerConfigurationProperties.java
Patch:
@@ -651,7 +651,7 @@ public InstanceProperties setSlowCallDurationThreshold(Duration slowCallDuration
             Objects.requireNonNull(slowCallDurationThreshold);
             if (slowCallDurationThreshold.toNanos() < 1) {
                 throw new IllegalArgumentException(
-                    "waitDurationInOpenStateMillis must be greater than or equal to 1 nanos.");
+                    "slowCallDurationThreshold must be greater than or equal to 1 nanos.");
             }
 
             this.slowCallDurationThreshold = slowCallDurationThreshold;

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/fallback/FallbackConfigurationOnMissingBeanTest.java
Patch:
@@ -18,6 +18,6 @@ public class FallbackConfigurationOnMissingBeanTest {
 
     @Test
     public void testSizeOfDecorators() {
-        assertThat(fallbackDecorators.getFallbackDecorators().size()).isEqualTo(3);
+        assertThat(fallbackDecorators.getFallbackDecorators().size()).isEqualTo(4);
     }
 }

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/fallback/FallbackConfigurationOnMissingBeanTest.java
Patch:
@@ -19,6 +19,6 @@ public class FallbackConfigurationOnMissingBeanTest {
 
     @Test
     public void testSizeOfDecorators() {
-        assertThat(fallbackDecorators.getFallbackDecorators().size()).isEqualTo(3);
+        assertThat(fallbackDecorators.getFallbackDecorators().size()).isEqualTo(4);
     }
 }

File: resilience4j-spring/src/test/java/io/github/resilience4j/circuitbreaker/configure/FallbackConfigurationTest.java
Patch:
@@ -19,6 +19,6 @@ public class FallbackConfigurationTest {
 
     @Test
     public void testSizeOfDecorators() {
-        assertThat(fallbackDecorators.getFallbackDecorators().size()).isEqualTo(3);
+        assertThat(fallbackDecorators.getFallbackDecorators().size()).isEqualTo(4);
     }
 }
\ No newline at end of file

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/circuitbreaker/configure/FallbackConfigurationTest.java
Patch:
@@ -19,6 +19,6 @@ public class FallbackConfigurationTest {
 
     @Test
     public void testSizeOfDecorators() {
-        assertThat(fallbackDecorators.getFallbackDecorators().size()).isEqualTo(3);
+        assertThat(fallbackDecorators.getFallbackDecorators().size()).isEqualTo(4);
     }
 }
\ No newline at end of file

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreaker.java
Patch:
@@ -363,7 +363,7 @@ static CircuitBreaker of(String name, CircuitBreakerConfig circuitBreakerConfig)
      *
      * @param name                 the name of the CircuitBreaker
      * @param circuitBreakerConfig a custom CircuitBreaker configuration
-     * @param tags                 tags added to the Retry
+     * @param tags                 tags added to the CircuitBreaker
      * @return a CircuitBreaker with a custom CircuitBreaker configuration.
      */
     static CircuitBreaker of(String name, CircuitBreakerConfig circuitBreakerConfig, Map<String, String> tags) {
@@ -611,9 +611,9 @@ static <T> Supplier<Future<T>> decorateFuture(CircuitBreaker circuitBreaker,
     Metrics getMetrics();
 
     /**
-     * Returns an unmodifiable map with tags assigned to this Retry.
+     * Returns an unmodifiable map with tags assigned to this CircuitBreaker.
      *
-     * @return the tags assigned to this Retry in an unmodifiable map
+     * @return the tags assigned to this CircuitBreaker in an unmodifiable map
      */
     Map<String, String> getTags();
 

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/Retry.java
Patch:
@@ -566,7 +566,7 @@ public void run() {
         private void onError(Exception t) {
             final long delay = retryContext.onError(t);
 
-            if (delay < 1) {
+            if (delay < 0) {
                 promise.completeExceptionally(t);
             } else {
                 scheduler.schedule(this, delay, TimeUnit.MILLISECONDS);
@@ -576,7 +576,7 @@ private void onError(Exception t) {
         private void onResult(T result) {
             final long delay = retryContext.onResult(result);
 
-            if (delay < 1) {
+            if (delay < 0) {
                 try {
                     retryContext.onComplete();
                     promise.complete(result);

File: resilience4j-spring/src/main/java/io/github/resilience4j/fallback/FallbackExecutor.java
Patch:
@@ -28,7 +28,7 @@ public Object execute(ProceedingJoinPoint proceedingJoinPoint, Method method, St
         if (StringUtils.hasLength(fallbackMethodName)) {
             try {
                 fallbackMethod = FallbackMethod
-                    .create(fallbackMethodName, method, proceedingJoinPoint.getArgs(), proceedingJoinPoint.getTarget().getClass(), proceedingJoinPoint.getThis());
+                    .create(fallbackMethodName, method, proceedingJoinPoint.getArgs(), proceedingJoinPoint.getTarget(), proceedingJoinPoint.getThis());
             } catch (NoSuchMethodException ex) {
                 logger.warn("No fallback method match found", ex);
             }

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/fallback/FallbackExecutor.java
Patch:
@@ -28,7 +28,7 @@ public Object execute(ProceedingJoinPoint proceedingJoinPoint, Method method, St
         if (StringUtils.hasLength(fallbackMethodName)) {
             try {
                 fallbackMethod = FallbackMethod
-                    .create(fallbackMethodName, method, proceedingJoinPoint.getArgs(), proceedingJoinPoint.getTarget().getClass(), proceedingJoinPoint.getThis());
+                    .create(fallbackMethodName, method, proceedingJoinPoint.getArgs(), proceedingJoinPoint.getTarget(), proceedingJoinPoint.getThis());
             } catch (NoSuchMethodException ex) {
                 logger.warn("No fallback method match found", ex);
             }

File: resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/bulkhead/BulkheadInterceptor.java
Patch:
@@ -133,7 +133,7 @@ public Object intercept(MethodInvocationContext<Object, Object> context) {
     }
 
     private CompletionStage<?> handleThreadPoolBulkhead(MethodInvocationContext<Object, Object> context, AnnotationValue<io.github.resilience4j.micronaut.annotation.Bulkhead> bulkheadAnnotationValue) {
-        final String name = bulkheadAnnotationValue.stringValue().orElse("default");
+        final String name = bulkheadAnnotationValue.stringValue("name").orElse("default");
         ThreadPoolBulkhead bulkhead = this.threadPoolBulkheadRegistry.bulkhead(name);
 
         InterceptedMethod interceptedMethod = InterceptedMethod.of(context);

File: resilience4j-feign/src/main/java/io/github/resilience4j/feign/DefaultFallbackHandler.java
Patch:
@@ -39,9 +39,7 @@ public CheckedFunction<Object[], Object> decorate(
         CheckedFunction<Object[], Object> invocationCall,
         Method method,
         Predicate<Exception> filter) {
-        validateFallback(fallback, method);
-        Method fallbackMethod = getFallbackMethod(fallback, method);
-        fallbackMethod.setAccessible(true);
+        Method fallbackMethod = validateAndGetFallbackMethod(fallback, method);
         return args -> {
             try {
                 return invocationCall.apply(args);

File: resilience4j-feign/src/main/java/io/github/resilience4j/feign/FallbackFactory.java
Patch:
@@ -49,8 +49,7 @@ public CheckedFunction<Object[], Object> decorate(
             } catch (Exception exception) {
                 if (filter.test(exception)) {
                     T fallbackInstance = fallbackSupplier.apply(exception);
-                    validateFallback(fallbackInstance, method);
-                    Method fallbackMethod = getFallbackMethod(fallbackInstance, method);
+                    Method fallbackMethod = validateAndGetFallbackMethod(fallbackInstance, method);
                     try {
                         return fallbackMethod.invoke(fallbackInstance, args);
                     } catch (InvocationTargetException e) {

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/RetryImpl.java
Patch:
@@ -354,7 +354,9 @@ public long onResult(T result) {
                     }
                     return -1;
                 }
-                return intervalBiFunction.apply(attempt, Either.right(result));
+                Long interval = intervalBiFunction.apply(attempt, Either.right(result));
+                publishRetryEvent(() -> new RetryOnRetryEvent(getName(), attempt, null, interval));
+                return interval;
             } else {
                 return -1;
             }

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/bulkhead/configuration/CommonBulkheadConfigurationProperties.java
Patch:
@@ -148,7 +148,7 @@ public Duration getMaxWaitDuration() {
 
         public InstanceProperties setMaxWaitDuration(Duration maxWaitDuration) {
             Objects.requireNonNull(maxWaitDuration);
-            if (maxWaitDuration.toMillis() < 0) {
+            if (maxWaitDuration.isNegative()) {
                 throw new IllegalArgumentException(
                     "maxWaitDuration must be greater than or equal to 0.");
             }

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/timelimiter/configuration/CommonTimeLimiterConfigurationProperties.java
Patch:
@@ -123,9 +123,9 @@ public Duration getTimeoutDuration() {
 
         public InstanceProperties setTimeoutDuration(Duration timeoutDuration) {
             Objects.requireNonNull(timeoutDuration);
-            if (timeoutDuration.toMillis() < 0) {
+            if (timeoutDuration.isNegative()) {
                 throw new IllegalArgumentException(
-                        "timeoutDuration must be greater than or equal to 0.");
+                    "Illegal argument exponentialMaxWaitDuration: " + timeoutDuration + " is negative");
             }
             this.timeoutDuration = timeoutDuration;
             return this;

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/bulkhead/configuration/ThreadPoolBulkheadConfigurationPropertiesTest.java
Patch:
@@ -175,9 +175,9 @@ public void testCreateThreadPoolBulkHeadPropertiesWithDefaultConfig() {
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void testThreadPoolBulkheadIllegalArgumentOnEventConsumerBufferSize() {
+    public void testThreadPoolBulkheadIllegalArgumentOnEventConsumerBufferSizeLessThanOne() {
         CommonThreadPoolBulkheadConfigurationProperties.InstanceProperties defaultProperties = new CommonThreadPoolBulkheadConfigurationProperties.InstanceProperties();
-        defaultProperties.setEventConsumerBufferSize(-1);
+        defaultProperties.setEventConsumerBufferSize(0);
     }
 
     @Test

File: resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/timelimiter/TimeLimiterInterceptor.java
Patch:
@@ -81,7 +81,7 @@ public Object intercept(MethodInvocationContext<Object, Object> context) {
         }
 
         ExecutableMethod<Object, Object> executableMethod = context.getExecutableMethod();
-        final String name = executableMethod.stringValue(io.github.resilience4j.micronaut.annotation.TimeLimiter.class).orElse("default");
+        final String name = executableMethod.stringValue(io.github.resilience4j.micronaut.annotation.TimeLimiter.class, "name").orElse("default");
         TimeLimiter timeLimiter = this.timeLimiterRegistry.timeLimiter(name);
 
         InterceptedMethod interceptedMethod = InterceptedMethod.of(context);

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/InMemoryBulkheadRegistry.java
Patch:
@@ -39,7 +39,7 @@ public final class InMemoryBulkheadRegistry extends
     AbstractRegistry<Bulkhead, BulkheadConfig> implements BulkheadRegistry {
 
     /**
-     * The constructor with default default.
+     * The constructor with default configuration.
      */
     public InMemoryBulkheadRegistry() {
         this(BulkheadConfig.ofDefaults());

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/InMemoryThreadPoolBulkheadRegistry.java
Patch:
@@ -40,7 +40,7 @@ public final class InMemoryThreadPoolBulkheadRegistry extends
     ThreadPoolBulkheadRegistry {
 
     /**
-     * The constructor with default default.
+     * The constructor with default configuration.
      */
     public InMemoryThreadPoolBulkheadRegistry() {
         this(emptyMap());

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreakerConfig.java
Patch:
@@ -456,7 +456,7 @@ public Builder waitIntervalFunctionInOpenState(
         }
 
         /**
-         * Configures an function which can decide if the circuit breaker should transition to a different
+         * Configures a function which can decide if the circuit breaker should transition to a different
          * state base on the result of the protected function.
          *
          * @param transitionOnResult function which instructs the circuit breaker if it should transition

File: resilience4j-core/src/main/java/io/github/resilience4j/core/metrics/SlidingTimeWindowMetrics.java
Patch:
@@ -34,14 +34,14 @@
  * the previous {@code N-1} epoch seconds.
  * <p>
  * The sliding window does not store call outcomes (tuples) individually, but incrementally updates
- * partial aggregations (bucket) and a total aggregation. The total total aggregation is updated
+ * partial aggregations (bucket) and a total aggregation. The total aggregation is updated
  * incrementally when a new call outcome is recorded. When the oldest bucket is evicted, the partial
  * total aggregation of that bucket is subtracted from the total aggregation. (Subtract-on-Evict)
  * <p>
  * The time to retrieve a Snapshot is constant 0(1), since the Snapshot is pre-aggregated and is
  * independent of the time window size. The space requirement (memory consumption) of this
  * implementation should be nearly constant O(n), since the call outcomes (tuples) are not stored
- * individually. Only {@code N} partial aggregations and 1 total total aggregation are created.
+ * individually. Only {@code N} partial aggregations and 1 total aggregation are created.
  */
 public class SlidingTimeWindowMetrics implements Metrics {
 

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreaker.java
Patch:
@@ -503,7 +503,7 @@ static <T> Supplier<Future<T>> decorateFuture(CircuitBreaker circuitBreaker,
     /**
      * Returns the circuit breaker to its original closed state, losing statistics.
      * <p>
-     * Should only be used, when you want to want to fully reset the circuit breaker without
+     * Should only be used, when you want to fully reset the circuit breaker without
      * creating a new one.
      */
     void reset();

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerStateMachine.java
Patch:
@@ -213,7 +213,7 @@ public void acquirePermission() {
     @Override
     public void onError(long duration, TimeUnit durationUnit, Throwable throwable) {
         // Handle the case if the completable future throws a CompletionException wrapping the original exception
-        // where original exception is the the one to retry not the CompletionException.
+        // where original exception is the one to retry not the CompletionException.
         if (throwable instanceof CompletionException || throwable instanceof ExecutionException) {
             Throwable cause = throwable.getCause();
             handleThrowable(duration, durationUnit, cause);
@@ -272,7 +272,7 @@ private void handlePossibleTransition(Either<Object, Throwable> result) {
     /**
      * Get the state of this CircuitBreaker.
      *
-     * @return the the state of this CircuitBreaker
+     * @return the state of this CircuitBreaker
      */
     @Override
     public State getState() {
@@ -282,7 +282,7 @@ public State getState() {
     /**
      * Get the name of this CircuitBreaker.
      *
-     * @return the the name of this CircuitBreaker
+     * @return the name of this CircuitBreaker
      */
     @Override
     public String getName() {

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/bulkhead/configuration/CommonThreadPoolBulkheadConfigurationProperties.java
Patch:
@@ -211,7 +211,7 @@ public InstanceProperties setWritableStackTraceEnabled(boolean writableStackTrac
 
         /**
          * Gets the shared configuration name. If this is set, the configuration builder will use
-         * the the shared configuration backend over this one.
+         * the shared configuration backend over this one.
          *
          * @return The shared configuration name.
          */
@@ -222,7 +222,7 @@ public String getBaseConfig() {
 
         /**
          * Sets the shared configuration name. If this is set, the configuration builder will use
-         * the the shared configuration backend over this one.
+         * the shared configuration backend over this one.
          *
          * @param baseConfig The shared configuration name.
          */

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/circuitbreaker/configuration/CommonCircuitBreakerConfigurationProperties.java
Patch:
@@ -552,7 +552,7 @@ public InstanceProperties setIgnoreExceptions(
 
         /**
          * Gets the shared configuration name. If this is set, the configuration builder will use
-         * the the shared configuration backend over this one.
+         * the shared configuration backend over this one.
          *
          * @return The shared configuration name.
          */
@@ -563,7 +563,7 @@ public String getBaseConfig() {
 
         /**
          * Sets the shared configuration name. If this is set, the configuration builder will use
-         * the the shared configuration backend over this one.
+         * the shared configuration backend over this one.
          *
          * @param baseConfig The shared configuration name.
          */

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/ratelimiter/configuration/CommonRateLimiterConfigurationProperties.java
Patch:
@@ -293,7 +293,7 @@ public InstanceProperties setRegisterHealthIndicator(Boolean registerHealthIndic
 
         /**
          * Gets the shared configuration name. If this is set, the configuration builder will use
-         * the the shared configuration instance over this one.
+         * the shared configuration instance over this one.
          *
          * @return The shared configuration name.
          */
@@ -304,7 +304,7 @@ public String getBaseConfig() {
 
         /**
          * Sets the shared configuration name. If this is set, the configuration builder will use
-         * the the shared configuration instance over this one.
+         * the shared configuration instance over this one.
          *
          * @param baseConfig The shared configuration name.
          */

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/retry/configuration/CommonRetryConfigurationProperties.java
Patch:
@@ -503,7 +503,7 @@ public InstanceProperties setFailAfterMaxAttempts(Boolean failAfterMaxAttempts)
 
         /**
          * Gets the shared configuration name. If this is set, the configuration builder will use
-         * the the shared configuration backend over this one.
+         * the shared configuration backend over this one.
          *
          * @return The shared configuration name.
          */
@@ -514,7 +514,7 @@ public String getBaseConfig() {
 
         /**
          * Sets the shared configuration name. If this is set, the configuration builder will use
-         * the the shared configuration backend over this one.
+         * the shared configuration backend over this one.
          *
          * @param baseConfig The shared configuration name.
          */

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/event/RetryEvent.java
Patch:
@@ -35,7 +35,7 @@ public interface RetryEvent {
     /**
      * Returns the number of retry attempts.
      *
-     * @return the the number of retry attempts
+     * @return the number of retry attempts
      */
     int getNumberOfRetryAttempts();
 

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/RetryImpl.java
Patch:
@@ -298,7 +298,7 @@ public void onComplete() {
         @Override
         public long onError(Throwable throwable) {
             // Handle the case if the completable future throw CompletionException wrapping the original exception
-            // where original exception is the the one to retry not the CompletionException.
+            // where original exception is the one to retry not the CompletionException.
             if (throwable instanceof CompletionException || throwable instanceof ExecutionException) {
                 Throwable cause = throwable.getCause();
                 return handleThrowable(cause);

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/SpringBootCommonTest.java
Patch:
@@ -73,7 +73,7 @@ public void testBulkHeadCommonConfig() {
                 new DefaultEventConsumerRegistry<>(),
                 new CompositeRegistryEventConsumer<>(Collections.emptyList()),
                 new CompositeCustomizer<>(Collections.singletonList(
-                    ThreadPoolBulkheadConfigCustomizer.of("backend", builder -> builder.coreThreadPoolSize(10)))))).isNotNull();
+                    ThreadPoolBulkheadConfigCustomizer.of("backend", builder -> builder.maxThreadPoolSize(128)))))).isNotNull();
         assertThat(bulkheadConfigurationOnMissingBean.reactorBulkHeadAspectExt()).isNotNull();
         assertThat(bulkheadConfigurationOnMissingBean.rxJava2BulkHeadAspectExt()).isNotNull();
         final DefaultSpelResolver spelResolver = new DefaultSpelResolver(new SpelExpressionParser(), new StandardReflectionParameterNameDiscoverer(), new GenericApplicationContext());

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiterConfig.java
Patch:
@@ -90,9 +90,7 @@ private static Duration checkTimeoutDuration(final Duration timeoutDuration) {
 
     private static Duration validateDurationWithinRange(Duration duration, String message) {
         try {
-            //noinspection ResultOfMethodCallIgnored
-            duration.toNanos(); // make sure there is no long overflow
-            return duration;
+            return Duration.ofNanos(duration.toNanos()); // make sure there is no long overflow
         } catch (Exception e) {
             throw new RuntimeException(message, e);
         }

File: resilience4j-test/src/main/java/io/github/resilience4j/test/TestContextPropagators.java
Patch:
@@ -29,6 +29,8 @@
 
 public class TestContextPropagators {
 
+    private TestContextPropagators(){}
+
     public static class TestThreadLocalContextPropagator implements ContextPropagator<String> {
         private ThreadLocal<String> threadLocal;
 
@@ -45,7 +47,6 @@ public Supplier<Optional<String>> retrieve() {
         public Consumer<Optional<String>> copy() {
             return (t) -> t.ifPresent(e -> {
                 if (threadLocal.get() != null) {
-                    threadLocal.set(null);
                     threadLocal.remove();
                 }
                 threadLocal.set(e);
@@ -56,7 +57,6 @@ public Consumer<Optional<String>> copy() {
         public Consumer<Optional<String>> clear() {
             return (t) -> {
                 if (threadLocal.get() != null) {
-                    threadLocal.set(null);
                     threadLocal.remove();
                 }
             };
@@ -103,7 +103,6 @@ public static Map<String, String> getMDCContext() {
 
             public static void clear() {
                 if (threadLocal.get() != null) {
-                    threadLocal.set(null);
                     threadLocal.remove();
                 }
             }

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/fallback/autoconfigure/FallbackConfigurationOnMissingBean.java
Patch:
@@ -19,6 +19,7 @@
 import io.github.resilience4j.fallback.configure.FallbackConfiguration;
 import io.github.resilience4j.spelresolver.SpelResolver;
 import io.github.resilience4j.spelresolver.autoconfigure.SpelResolverConfigurationOnMissingBean;
+import io.github.resilience4j.utils.AspectJOnClasspathCondition;
 import io.github.resilience4j.utils.ReactorOnClasspathCondition;
 import io.github.resilience4j.utils.RxJava2OnClasspathCondition;
 import org.springframework.beans.factory.annotation.Autowired;
@@ -45,12 +46,14 @@ public FallbackConfigurationOnMissingBean() {
 
     @Bean
     @ConditionalOnMissingBean
+    @Conditional(value = {AspectJOnClasspathCondition.class})
     public FallbackDecorators fallbackDecorators(@Autowired(required = false) List<FallbackDecorator> fallbackDecorators) {
         return fallbackConfiguration.fallbackDecorators(fallbackDecorators);
     }
 
     @Bean
     @ConditionalOnMissingBean
+    @Conditional(value = {AspectJOnClasspathCondition.class})
     public FallbackExecutor fallbackExecutor(SpelResolver spelResolver, FallbackDecorators fallbackDecorators) {
         return fallbackConfiguration.fallbackExecutor(spelResolver, fallbackDecorators);
     }

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/bulkhead/configure/BulkHeadConfigurationSpringTest.java
Patch:
@@ -63,7 +63,7 @@ public void testAllCircuitBreakerConfigurationBeansOverridden() {
     }
 
     @Configuration
-    @ComponentScan({"io.github.resilience4j.bulkhead", "io.github.resilience4j.fallback", "io.github.resilience4j.spelresolver"})
+    @ComponentScan({"io.github.resilience4j.spring6.bulkhead", "io.github.resilience4j.spring6.fallback", "io.github.resilience4j.spring6.spelresolver"})
     public static class ConfigWithOverrides {
 
         private BulkheadRegistry bulkheadRegistry;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/fallback/FallbackMethodTest.java
Patch:
@@ -119,7 +119,7 @@ public void shouldFailIf2FallBackMethodsHandleSameException() throws Throwable {
             .create("returnMismatchFallback", testMethod, new Object[]{"test"}, target))
             .isInstanceOf(NoSuchMethodException.class)
             .hasMessage(
-                "class java.lang.String class io.github.resilience4j.fallback.FallbackMethodTest.returnMismatchFallback(class java.lang.String,class java.lang.Throwable)");
+                "class java.lang.String class io.github.resilience4j.spring6.fallback.FallbackMethodTest.returnMismatchFallback(class java.lang.String,class java.lang.Throwable)");
     }
 
     @Test
@@ -130,7 +130,7 @@ public void notFoundFallbackMethod_shouldThrowsNoSuchMethodException() throws Th
             () -> FallbackMethod.create("noMethod", testMethod, new Object[]{"test"}, target))
             .isInstanceOf(NoSuchMethodException.class)
             .hasMessage(
-                "class java.lang.String class io.github.resilience4j.fallback.FallbackMethodTest.noMethod(class java.lang.String,class java.lang.Throwable)");
+                "class java.lang.String class io.github.resilience4j.spring6.fallback.FallbackMethodTest.noMethod(class java.lang.String,class java.lang.Throwable)");
     }
 
     @Test

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/ratelimiter/configure/RateLimiterConfigurationSpringTest.java
Patch:
@@ -55,7 +55,7 @@ public void testAllCircuitBreakerConfigurationBeansOverridden() {
     }
 
     @Configuration
-    @ComponentScan({"io.github.resilience4j.ratelimiter", "io.github.resilience4j.fallback", "io.github.resilience4j.spelresolver"})
+    @ComponentScan({"io.github.resilience4j.spring6.ratelimiter", "io.github.resilience4j.spring6.fallback", "io.github.resilience4j.spring6.spelresolver"})
     public static class ConfigWithOverrides {
 
         private RateLimiterRegistry rateLimiterRegistry;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/timelimiter/configure/TimeLimiterConfigurationSpringTest.java
Patch:
@@ -44,7 +44,7 @@ public void testAllCircuitBreakerConfigurationBeansOverridden() {
 
 
     @Configuration
-    @ComponentScan({"io.github.resilience4j.timelimiter","io.github.resilience4j.fallback", "io.github.resilience4j.spelresolver"})
+    @ComponentScan({"io.github.resilience4j.spring6.timelimiter","io.github.resilience4j.spring6.fallback", "io.github.resilience4j.spring6.spelresolver"})
     public static class ConfigWithOverrides {
 
         private TimeLimiterRegistry timeLimiterRegistry;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/circuitbreaker/autoconfigure/AbstractCircuitBreakerConfigurationOnMissingBean.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
-import io.github.resilience4j.circuitbreaker.configure.*;
 import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigCustomizer;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/ratelimiter/autoconfigure/AbstractRateLimiterConfigurationOnMissingBean.java
Patch:
@@ -23,7 +23,6 @@
 import io.github.resilience4j.springboot3.fallback.autoconfigure.FallbackConfigurationOnMissingBean;
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
-import io.github.resilience4j.ratelimiter.configure.*;
 import io.github.resilience4j.ratelimiter.event.RateLimiterEvent;
 import io.github.resilience4j.spring6.ratelimiter.configure.*;
 import io.github.resilience4j.spring6.spelresolver.SpelResolver;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/retry/autoconfigure/AbstractRetryConfigurationOnMissingBean.java
Patch:
@@ -24,7 +24,6 @@
 import io.github.resilience4j.springboot3.fallback.autoconfigure.FallbackConfigurationOnMissingBean;
 import io.github.resilience4j.retry.Retry;
 import io.github.resilience4j.retry.RetryRegistry;
-import io.github.resilience4j.retry.configure.*;
 import io.github.resilience4j.retry.event.RetryEvent;
 import io.github.resilience4j.spring6.retry.configure.*;
 import io.github.resilience4j.spring6.spelresolver.SpelResolver;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/timelimiter/autoconfigure/AbstractTimeLimiterConfigurationOnMissingBean.java
Patch:
@@ -28,7 +28,6 @@
 import io.github.resilience4j.spring6.timelimiter.configure.*;
 import io.github.resilience4j.timelimiter.TimeLimiter;
 import io.github.resilience4j.timelimiter.TimeLimiterRegistry;
-import io.github.resilience4j.timelimiter.configure.*;
 import io.github.resilience4j.timelimiter.event.TimeLimiterEvent;
 import io.github.resilience4j.spring6.utils.AspectJOnClasspathCondition;
 import io.github.resilience4j.spring6.utils.ReactorOnClasspathCondition;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/fallback/configure/FallbackConfiguration.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.github.resilience4j.spring6.fallback.configure;
 
-import io.github.resilience4j.fallback.*;
 import io.github.resilience4j.spring6.fallback.*;
 import io.github.resilience4j.spring6.spelresolver.SpelResolver;
 import io.github.resilience4j.spring6.spelresolver.configure.SpelResolverConfiguration;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/bulkhead/autoconfigure/BulkheadConfigurationOnMissingBean.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.bulkhead.autoconfigure;
+package io.github.resilience4j.springboot3.bulkhead.autoconfigure;
 
 import io.github.resilience4j.bulkhead.event.BulkheadEvent;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/bulkhead/autoconfigure/BulkheadMetricsAutoConfiguration.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.bulkhead.autoconfigure;
+package io.github.resilience4j.springboot3.bulkhead.autoconfigure;
 
 import io.github.resilience4j.bulkhead.Bulkhead;
 import io.github.resilience4j.bulkhead.BulkheadRegistry;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/bulkhead/autoconfigure/BulkheadProperties.java
Patch:
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.bulkhead.autoconfigure;
+package io.github.resilience4j.springboot3.bulkhead.autoconfigure;
 
-import io.github.resilience4j.bulkhead.configure.BulkheadConfigurationProperties;
+import io.github.resilience4j.spring6.bulkhead.configure.BulkheadConfigurationProperties;
 import org.springframework.boot.context.properties.ConfigurationProperties;
 
 @ConfigurationProperties(prefix = "resilience4j.bulkhead")

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/bulkhead/autoconfigure/ThreadPoolBulkheadMetricsAutoConfiguration.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.github.resilience4j.bulkhead.autoconfigure;
+package io.github.resilience4j.springboot3.bulkhead.autoconfigure;
 
 import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;
 import io.github.resilience4j.bulkhead.ThreadPoolBulkheadRegistry;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/bulkhead/autoconfigure/ThreadPoolBulkheadProperties.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.bulkhead.autoconfigure;
+package io.github.resilience4j.springboot3.bulkhead.autoconfigure;
 
 import io.github.resilience4j.common.bulkhead.configuration.CommonThreadPoolBulkheadConfigurationProperties;
 import org.springframework.boot.context.properties.ConfigurationProperties;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/bulkhead/autoconfigure/package-info.java
Patch:
@@ -18,7 +18,7 @@
  */
 @NonNullApi
 @NonNullFields
-package io.github.resilience4j.circuitbreaker.monitoring.endpoint;
+package io.github.resilience4j.springboot3.bulkhead.autoconfigure;
 
 import io.github.resilience4j.core.lang.NonNullApi;
 import io.github.resilience4j.core.lang.NonNullFields;
\ No newline at end of file

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/bulkhead/monitoring/endpoint/BulkheadEndpoint.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.bulkhead.monitoring.endpoint;
+package io.github.resilience4j.springboot3.bulkhead.monitoring.endpoint;
 
 import io.github.resilience4j.bulkhead.Bulkhead;
 import io.github.resilience4j.bulkhead.BulkheadRegistry;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/bulkhead/monitoring/endpoint/BulkheadEventsEndpoint.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.bulkhead.monitoring.endpoint;
+package io.github.resilience4j.springboot3.bulkhead.monitoring.endpoint;
 
 import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;
 import io.github.resilience4j.bulkhead.event.BulkheadEvent;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/circuitbreaker/autoconfigure/CircuitBreakerConfigurationOnMissingBean.java
Patch:
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.autoconfigure;
+package io.github.resilience4j.springboot3.circuitbreaker.autoconfigure;
 
-import io.github.resilience4j.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
+import io.github.resilience4j.spring6.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
 import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/circuitbreaker/autoconfigure/CircuitBreakerMetricsAutoConfiguration.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.autoconfigure;
+package io.github.resilience4j.springboot3.circuitbreaker.autoconfigure;
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/circuitbreaker/autoconfigure/CircuitBreakerProperties.java
Patch:
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.autoconfigure;
+package io.github.resilience4j.springboot3.circuitbreaker.autoconfigure;
 
-import io.github.resilience4j.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
+import io.github.resilience4j.spring6.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
 import org.springframework.boot.context.properties.ConfigurationProperties;
 
 @ConfigurationProperties(prefix = "resilience4j.circuitbreaker")

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/circuitbreaker/autoconfigure/CircuitBreakerStreamEventsAutoConfiguration.java
Patch:
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 
-package io.github.resilience4j.circuitbreaker.autoconfigure;
+package io.github.resilience4j.springboot3.circuitbreaker.autoconfigure;
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
-import io.github.resilience4j.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixServerSideEvent;
-import io.github.resilience4j.circuitbreaker.monitoring.endpoint.CircuitBreakerServerSideEvent;
+import io.github.resilience4j.springboot3.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixServerSideEvent;
+import io.github.resilience4j.springboot3.circuitbreaker.monitoring.endpoint.CircuitBreakerServerSideEvent;
 import io.github.resilience4j.reactor.adapter.ReactorAdapter;
 import org.springframework.boot.actuate.autoconfigure.endpoint.condition.ConditionalOnAvailableEndpoint;
 import org.springframework.boot.actuate.endpoint.annotation.Endpoint;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/circuitbreaker/autoconfigure/CircuitBreakersHealthIndicatorAutoConfiguration.java
Patch:
@@ -1,9 +1,9 @@
-package io.github.resilience4j.circuitbreaker.autoconfigure;
+package io.github.resilience4j.springboot3.circuitbreaker.autoconfigure;
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
-import io.github.resilience4j.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
-import io.github.resilience4j.circuitbreaker.monitoring.health.CircuitBreakersHealthIndicator;
+import io.github.resilience4j.spring6.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
+import io.github.resilience4j.springboot3.circuitbreaker.monitoring.health.CircuitBreakersHealthIndicator;
 import org.springframework.boot.actuate.autoconfigure.health.HealthContributorAutoConfiguration;
 import org.springframework.boot.actuate.health.HealthIndicator;
 import org.springframework.boot.actuate.health.StatusAggregator;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/circuitbreaker/monitoring/endpoint/CircuitBreakerEndpoint.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.monitoring.endpoint;
+package io.github.resilience4j.springboot3.circuitbreaker.monitoring.endpoint;
 
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/circuitbreaker/monitoring/endpoint/CircuitBreakerEventsEndpoint.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.monitoring.endpoint;
+package io.github.resilience4j.springboot3.circuitbreaker.monitoring.endpoint;
 
 
 import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/circuitbreaker/monitoring/endpoint/CircuitBreakerHystrixServerSideEvent.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.monitoring.endpoint;
+package io.github.resilience4j.springboot3.circuitbreaker.monitoring.endpoint;
 
 import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.databind.ObjectMapper;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/circuitbreaker/monitoring/endpoint/CircuitBreakerServerSideEvent.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.monitoring.endpoint;
+package io.github.resilience4j.springboot3.circuitbreaker.monitoring.endpoint;
 
 import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.databind.ObjectMapper;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/circuitbreaker/monitoring/health/CircuitBreakersHealthIndicator.java
Patch:
@@ -13,13 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.monitoring.health;
+package io.github.resilience4j.springboot3.circuitbreaker.monitoring.health;
 
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
-import io.github.resilience4j.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
+import io.github.resilience4j.spring6.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
 import org.springframework.boot.actuate.health.Health;
 import org.springframework.boot.actuate.health.HealthIndicator;
 import org.springframework.boot.actuate.health.Status;
@@ -28,7 +28,7 @@
 import java.util.Map;
 import java.util.stream.Collectors;
 
-import static io.github.resilience4j.circuitbreaker.configure.CircuitBreakerConfigurationProperties.InstanceProperties;
+import static io.github.resilience4j.spring6.circuitbreaker.configure.CircuitBreakerConfigurationProperties.InstanceProperties;
 
 /**
  * A Spring Boot health indicators which adds the state of a CircuitBreaker and it's metrics to the

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/ratelimiter/autoconfigure/RateLimiterConfigurationOnMissingBean.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.ratelimiter.autoconfigure;
+package io.github.resilience4j.springboot3.ratelimiter.autoconfigure;
 
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.ratelimiter.event.RateLimiterEvent;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/ratelimiter/autoconfigure/RateLimiterMetricsAutoConfiguration.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.ratelimiter.autoconfigure;
+package io.github.resilience4j.springboot3.ratelimiter.autoconfigure;
 
 import io.github.resilience4j.micrometer.tagged.TaggedRateLimiterMetrics;
 import io.github.resilience4j.micrometer.tagged.TaggedRateLimiterMetricsPublisher;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/ratelimiter/autoconfigure/RateLimiterProperties.java
Patch:
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.ratelimiter.autoconfigure;
+package io.github.resilience4j.springboot3.ratelimiter.autoconfigure;
 
-import io.github.resilience4j.ratelimiter.configure.RateLimiterConfigurationProperties;
+import io.github.resilience4j.spring6.ratelimiter.configure.RateLimiterConfigurationProperties;
 import org.springframework.boot.context.properties.ConfigurationProperties;
 
 @ConfigurationProperties(prefix = "resilience4j.ratelimiter")

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/ratelimiter/autoconfigure/RateLimitersHealthIndicatorAutoConfiguration.java
Patch:
@@ -1,9 +1,9 @@
-package io.github.resilience4j.ratelimiter.autoconfigure;
+package io.github.resilience4j.springboot3.ratelimiter.autoconfigure;
 
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
-import io.github.resilience4j.ratelimiter.configure.RateLimiterConfigurationProperties;
-import io.github.resilience4j.ratelimiter.monitoring.health.RateLimitersHealthIndicator;
+import io.github.resilience4j.spring6.ratelimiter.configure.RateLimiterConfigurationProperties;
+import io.github.resilience4j.springboot3.ratelimiter.monitoring.health.RateLimitersHealthIndicator;
 import org.springframework.boot.actuate.autoconfigure.health.HealthContributorAutoConfiguration;
 import org.springframework.boot.actuate.health.HealthIndicator;
 import org.springframework.boot.actuate.health.StatusAggregator;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/ratelimiter/monitoring/endpoint/RateLimiterEndpoint.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.ratelimiter.monitoring.endpoint;
+package io.github.resilience4j.springboot3.ratelimiter.monitoring.endpoint;
 
 import io.github.resilience4j.common.ratelimiter.monitoring.endpoint.RateLimiterEndpointResponse;
 import io.github.resilience4j.ratelimiter.RateLimiter;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/ratelimiter/monitoring/endpoint/RateLimiterEventsEndpoint.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.ratelimiter.monitoring.endpoint;
+package io.github.resilience4j.springboot3.ratelimiter.monitoring.endpoint;
 
 import io.github.resilience4j.common.ratelimiter.monitoring.endpoint.RateLimiterEventDTO;
 import io.github.resilience4j.common.ratelimiter.monitoring.endpoint.RateLimiterEventsEndpointResponse;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/ratelimiter/monitoring/health/RateLimitersHealthIndicator.java
Patch:
@@ -13,18 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.ratelimiter.monitoring.health;
+package io.github.resilience4j.springboot3.ratelimiter.monitoring.health;
 
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
-import io.github.resilience4j.ratelimiter.configure.RateLimiterConfigurationProperties;
+import io.github.resilience4j.spring6.ratelimiter.configure.RateLimiterConfigurationProperties;
 import io.github.resilience4j.ratelimiter.internal.AtomicRateLimiter;
 import org.springframework.boot.actuate.health.*;
 
 import java.util.Map;
 import java.util.stream.Collectors;
 
-import static io.github.resilience4j.ratelimiter.configure.RateLimiterConfigurationProperties.InstanceProperties;
+import static io.github.resilience4j.spring6.ratelimiter.configure.RateLimiterConfigurationProperties.InstanceProperties;
 
 public class RateLimitersHealthIndicator implements HealthIndicator {
 

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/retry/autoconfigure/RetryConfigurationOnMissingBean.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.retry.autoconfigure;
+package io.github.resilience4j.springboot3.retry.autoconfigure;
 
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/retry/autoconfigure/RetryMetricsAutoConfiguration.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.retry.autoconfigure;
+package io.github.resilience4j.springboot3.retry.autoconfigure;
 
 import io.github.resilience4j.micrometer.tagged.TaggedRetryMetrics;
 import io.github.resilience4j.micrometer.tagged.TaggedRetryMetricsPublisher;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/retry/autoconfigure/RetryProperties.java
Patch:
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.retry.autoconfigure;
+package io.github.resilience4j.springboot3.retry.autoconfigure;
 
-import io.github.resilience4j.retry.configure.RetryConfigurationProperties;
+import io.github.resilience4j.spring6.retry.configure.RetryConfigurationProperties;
 import org.springframework.boot.context.properties.ConfigurationProperties;
 
 /**

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/retry/autoconfigure/package-info.java
Patch:
@@ -18,7 +18,7 @@
  */
 @NonNullApi
 @NonNullFields
-package io.github.resilience4j.circuitbreaker.autoconfigure;
+package io.github.resilience4j.springboot3.retry.autoconfigure;
 
 import io.github.resilience4j.core.lang.NonNullApi;
 import io.github.resilience4j.core.lang.NonNullFields;
\ No newline at end of file

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/retry/monitoring/endpoint/RetryEndpoint.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.retry.monitoring.endpoint;
+package io.github.resilience4j.springboot3.retry.monitoring.endpoint;
 
 
 import io.github.resilience4j.common.retry.monitoring.endpoint.RetryEndpointResponse;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/retry/monitoring/endpoint/RetryEventsEndpoint.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.retry.monitoring.endpoint;
+package io.github.resilience4j.springboot3.retry.monitoring.endpoint;
 
 
 import io.github.resilience4j.common.retry.monitoring.endpoint.RetryEventDTOFactory;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/scheduled/threadpool/autoconfigure/ContextAwareScheduledThreadPoolAutoConfiguration.java
Patch:
@@ -16,7 +16,7 @@
  *
  *
  */
-package io.github.resilience4j.scheduled.threadpool.autoconfigure;
+package io.github.resilience4j.springboot3.scheduled.threadpool.autoconfigure;
 
 import io.github.resilience4j.core.ContextAwareScheduledThreadPoolExecutor;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/scheduled/threadpool/autoconfigure/ContextAwareScheduledThreadPoolProperties.java
Patch:
@@ -16,7 +16,7 @@
  *
  *
  */
-package io.github.resilience4j.scheduled.threadpool.autoconfigure;
+package io.github.resilience4j.springboot3.scheduled.threadpool.autoconfigure;
 
 import io.github.resilience4j.common.scheduled.threadpool.configuration.ContextAwareScheduledThreadPoolConfigurationProperties;
 import org.springframework.boot.context.properties.ConfigurationProperties;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/spelresolver/autoconfigure/SpelResolverConfigurationOnMissingBean.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.spelresolver.autoconfigure;
+package io.github.resilience4j.springboot3.spelresolver.autoconfigure;
 
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
@@ -22,8 +22,8 @@
 import org.springframework.core.ParameterNameDiscoverer;
 import org.springframework.expression.spel.standard.SpelExpressionParser;
 
-import io.github.resilience4j.spelresolver.SpelResolver;
-import io.github.resilience4j.spelresolver.configure.SpelResolverConfiguration;
+import io.github.resilience4j.spring6.spelresolver.SpelResolver;
+import io.github.resilience4j.spring6.spelresolver.configure.SpelResolverConfiguration;
 
 /**
  * {@link Configuration} for {@link SpelResolver}.

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/timelimiter/autoconfigure/TimeLimiterConfigurationOnMissingBean.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.github.resilience4j.timelimiter.autoconfigure;
+package io.github.resilience4j.springboot3.timelimiter.autoconfigure;
 
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/timelimiter/autoconfigure/TimeLimiterMetricsAutoConfiguration.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.github.resilience4j.timelimiter.autoconfigure;
+package io.github.resilience4j.springboot3.timelimiter.autoconfigure;
 
 import io.github.resilience4j.micrometer.tagged.TaggedTimeLimiterMetrics;
 import io.github.resilience4j.micrometer.tagged.TaggedTimeLimiterMetricsPublisher;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/timelimiter/autoconfigure/TimeLimiterProperties.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package io.github.resilience4j.timelimiter.autoconfigure;
+package io.github.resilience4j.springboot3.timelimiter.autoconfigure;
 
-import io.github.resilience4j.timelimiter.configure.TimeLimiterConfigurationProperties;
+import io.github.resilience4j.spring6.timelimiter.configure.TimeLimiterConfigurationProperties;
 import org.springframework.boot.context.properties.ConfigurationProperties;
 
 @ConfigurationProperties(prefix = "resilience4j.timelimiter")

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/timelimiter/monitoring/endpoint/TimeLimiterEndpoint.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.github.resilience4j.timelimiter.monitoring.endpoint;
+package io.github.resilience4j.springboot3.timelimiter.monitoring.endpoint;
 
 import io.github.resilience4j.common.timelimiter.monitoring.endpoint.TimeLimiterEndpointResponse;
 import io.github.resilience4j.timelimiter.TimeLimiter;

File: resilience4j-spring-boot3/src/main/java/io/github/resilience4j/springboot3/timelimiter/monitoring/endpoint/TimeLimiterEventsEndpoint.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.github.resilience4j.timelimiter.monitoring.endpoint;
+package io.github.resilience4j.springboot3.timelimiter.monitoring.endpoint;
 
 import io.github.resilience4j.common.timelimiter.monitoring.endpoint.TimeLimiterEventDTO;
 import io.github.resilience4j.common.timelimiter.monitoring.endpoint.TimeLimiterEventsEndpointResponse;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/ContextAwareScheduledThreadPoolAutoConfigurationTest.java
Patch:
@@ -1,6 +1,6 @@
-package io.github.resilience4j;
+package io.github.resilience4j.springboot3;
 
-import io.github.resilience4j.scheduled.threadpool.autoconfigure.ContextAwareScheduledThreadPoolAutoConfiguration;
+import io.github.resilience4j.springboot3.scheduled.threadpool.autoconfigure.ContextAwareScheduledThreadPoolAutoConfiguration;
 import org.junit.Test;
 import org.springframework.boot.autoconfigure.AutoConfigurations;
 import org.springframework.boot.test.context.runner.ApplicationContextRunner;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/LegacyMetricsAutoConfigurationTest.java
Patch:
@@ -14,11 +14,11 @@
  * limitations under the License.
  */
 
-package io.github.resilience4j;
+package io.github.resilience4j.springboot3;
 
 import io.github.resilience4j.core.metrics.MetricsPublisher;
 import io.github.resilience4j.micrometer.tagged.*;
-import io.github.resilience4j.service.test.TestApplication;
+import io.github.resilience4j.springboot3.service.test.TestApplication;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/MeterRegistryWithoutMetricsAutoConfigurationTest.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j;
+package io.github.resilience4j.springboot3;
 
 import io.github.resilience4j.micrometer.tagged.*;
-import io.github.resilience4j.service.test.TestApplication;
+import io.github.resilience4j.springboot3.service.test.TestApplication;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/MetricsAutoConfigurationTest.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j;
+package io.github.resilience4j.springboot3;
 
 import io.github.resilience4j.micrometer.tagged.*;
-import io.github.resilience4j.service.test.TestApplication;
+import io.github.resilience4j.springboot3.service.test.TestApplication;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/TestThreadLocalContextPropagator.java
Patch:
@@ -1,12 +1,12 @@
-package io.github.resilience4j;
+package io.github.resilience4j.springboot3;
 
 import io.github.resilience4j.core.ContextPropagator;
 
 import java.util.Optional;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 
-import static io.github.resilience4j.TestThreadLocalContextPropagator.TestThreadLocalContextHolder.*;
+import static io.github.resilience4j.springboot3.TestThreadLocalContextPropagator.TestThreadLocalContextHolder.*;
 
 public class TestThreadLocalContextPropagator<T> implements ContextPropagator<T> {
 

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/TestUtils.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j;
+package io.github.resilience4j.springboot3;
 
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.context.annotation.Bean;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/circuitbreaker/CompositeHealthResponse.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.circuitbreaker;
+package io.github.resilience4j.springboot3.circuitbreaker;
 
 import java.util.Map;
 

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/circuitbreaker/HealthResponse.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.circuitbreaker;
+package io.github.resilience4j.springboot3.circuitbreaker;
 
 import java.util.Map;
 

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/circuitbreaker/IgnoredException.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.circuitbreaker;
+package io.github.resilience4j.springboot3.circuitbreaker;
 
 public class IgnoredException extends RuntimeException {
 

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/circuitbreaker/RecordFailurePredicate.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.circuitbreaker;
+package io.github.resilience4j.springboot3.circuitbreaker;
 
 import java.io.IOException;
 import java.util.function.Predicate;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/circuitbreaker/RecordResultPredicate.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.circuitbreaker;
+package io.github.resilience4j.springboot3.circuitbreaker;
 
 import org.apache.http.HttpStatus;
 

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/circuitbreaker/RecordedException.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.circuitbreaker;
+package io.github.resilience4j.springboot3.circuitbreaker;
 
 public class RecordedException extends RuntimeException {
 

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java
Patch:
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.monitoring.events;
+package io.github.resilience4j.springboot3.circuitbreaker.monitoring.events;
 
 
 import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;
-import io.github.resilience4j.service.test.DummyService;
-import io.github.resilience4j.service.test.TestApplication;
+import io.github.resilience4j.springboot3.service.test.DummyService;
+import io.github.resilience4j.springboot3.service.test.TestApplication;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/circuitbreaker/monitoring/events/CircuitBreakerStreamEventsTest.java
Patch:
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.monitoring.events;
+package io.github.resilience4j.springboot3.circuitbreaker.monitoring.events;
 
 
 import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;
-import io.github.resilience4j.service.test.DummyService;
-import io.github.resilience4j.service.test.TestApplication;
+import io.github.resilience4j.springboot3.service.test.DummyService;
+import io.github.resilience4j.springboot3.service.test.TestApplication;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/circuitbreaker/monitoring/health/CircuitBreakersHealthIndicatorTest.java
Patch:
@@ -1,9 +1,10 @@
-package io.github.resilience4j.circuitbreaker.monitoring.health;
+package io.github.resilience4j.springboot3.circuitbreaker.monitoring.health;
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
-import io.github.resilience4j.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
+import io.github.resilience4j.spring6.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
+import io.github.resilience4j.springboot3.circuitbreaker.monitoring.health.CircuitBreakersHealthIndicator;
 import org.junit.Test;
 import org.springframework.boot.actuate.health.Health;
 import org.springframework.boot.actuate.health.SimpleStatusAggregator;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/fallback/FallbackConfigurationOnMissingBeanTest.java
Patch:
@@ -1,6 +1,7 @@
-package io.github.resilience4j.fallback;
+package io.github.resilience4j.springboot3.fallback;
 
-import io.github.resilience4j.fallback.autoconfigure.FallbackConfigurationOnMissingBean;
+import io.github.resilience4j.springboot3.fallback.autoconfigure.FallbackConfigurationOnMissingBean;
+import io.github.resilience4j.spring6.fallback.FallbackDecorators;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/ratelimiter/monitoring/health/RateLimitersHealthIndicatorTest.java
Patch:
@@ -1,9 +1,10 @@
-package io.github.resilience4j.ratelimiter.monitoring.health;
+package io.github.resilience4j.springboot3.ratelimiter.monitoring.health;
 
 import io.github.resilience4j.ratelimiter.RateLimiterConfig;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
-import io.github.resilience4j.ratelimiter.configure.RateLimiterConfigurationProperties;
+import io.github.resilience4j.spring6.ratelimiter.configure.RateLimiterConfigurationProperties;
 import io.github.resilience4j.ratelimiter.internal.AtomicRateLimiter;
+import io.github.resilience4j.springboot3.ratelimiter.monitoring.health.RateLimitersHealthIndicator;
 import org.junit.Test;
 import org.springframework.boot.actuate.health.Health;
 import org.springframework.boot.actuate.health.SimpleStatusAggregator;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/BeanContextPropagator.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.service.test;
+package io.github.resilience4j.springboot3.service.test;
 
 import io.github.resilience4j.core.ContextPropagator;
 

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/DummyFeignClient.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.service.test;
+package io.github.resilience4j.springboot3.service.test;
 
 
 import io.github.resilience4j.bulkhead.annotation.Bulkhead;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/DummyService.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.service.test;
+package io.github.resilience4j.springboot3.service.test;
 
 
 import java.io.IOException;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/DummyServiceImpl.java
Patch:
@@ -1,10 +1,10 @@
-package io.github.resilience4j.service.test;
+package io.github.resilience4j.springboot3.service.test;
 
 
 import io.github.resilience4j.bulkhead.annotation.Bulkhead;
 import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
 import io.github.resilience4j.ratelimiter.annotation.RateLimiter;
-import io.github.resilience4j.service.test.bulkhead.BulkheadDummyService;
+import io.github.resilience4j.springboot3.service.test.bulkhead.BulkheadDummyService;
 import io.github.resilience4j.timelimiter.annotation.TimeLimiter;
 import io.vavr.control.Try;
 import org.springframework.stereotype.Component;
@@ -25,7 +25,7 @@ public void doSomething(boolean throwBackendTrouble) throws IOException {
     }
 
     @Override
-    @TimeLimiter(name = DummyService.BACKEND)
+    @TimeLimiter(name = BACKEND)
     public CompletableFuture<String> doSomethingAsync(boolean throwBackendTrouble)
         throws IOException {
         if (throwBackendTrouble) {

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/ReactiveDummyService.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.service.test;
+package io.github.resilience4j.springboot3.service.test;
 
 
 import io.reactivex.*;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/ReactiveDummyServiceImpl.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.service.test;
+package io.github.resilience4j.springboot3.service.test;
 
 import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
 import io.github.resilience4j.ratelimiter.annotation.RateLimiter;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/TestApplication.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.service.test;
+package io.github.resilience4j.springboot3.service.test;
 
 import io.github.resilience4j.bulkhead.BulkheadConfig;
 import io.github.resilience4j.common.bulkhead.configuration.BulkheadConfigCustomizer;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/bulkhead/BulkheadDummyService.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.service.test.bulkhead;
+package io.github.resilience4j.springboot3.service.test.bulkhead;
 
 import java.util.concurrent.CompletableFuture;
 

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/bulkhead/BulkheadDummyServiceImpl.java
Patch:
@@ -1,6 +1,6 @@
-package io.github.resilience4j.service.test.bulkhead;
+package io.github.resilience4j.springboot3.service.test.bulkhead;
 
-import io.github.resilience4j.TestThreadLocalContextPropagator;
+import io.github.resilience4j.springboot3.TestThreadLocalContextPropagator;
 import io.github.resilience4j.bulkhead.annotation.Bulkhead;
 import io.github.resilience4j.retry.annotation.Retry;
 import org.springframework.stereotype.Component;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/bulkhead/BulkheadReactiveDummyService.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.service.test.bulkhead;
+package io.github.resilience4j.springboot3.service.test.bulkhead;
 
 import io.reactivex.Flowable;
 import reactor.core.publisher.Flux;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/bulkhead/BulkheadReactiveDummyServiceImpl.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.service.test.bulkhead;
+package io.github.resilience4j.springboot3.service.test.bulkhead;
 
 import io.github.resilience4j.bulkhead.annotation.Bulkhead;
 import io.reactivex.Flowable;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/ratelimiter/RateLimiterDummyFeignClient.java
Patch:
@@ -1,12 +1,12 @@
-package io.github.resilience4j.service.test.ratelimiter;
+package io.github.resilience4j.springboot3.service.test.ratelimiter;
 
 
 import io.github.resilience4j.ratelimiter.annotation.RateLimiter;
 import org.springframework.cloud.openfeign.FeignClient;
 import org.springframework.web.bind.annotation.GetMapping;
 import org.springframework.web.bind.annotation.PathVariable;
 
-import static io.github.resilience4j.service.test.ratelimiter.RateLimiterDummyFeignClient.RATE_LIMITER_FEIGN_CLIENT_NAME;
+import static io.github.resilience4j.springboot3.service.test.ratelimiter.RateLimiterDummyFeignClient.RATE_LIMITER_FEIGN_CLIENT_NAME;
 
 @FeignClient(url = "localhost:8090", name = RATE_LIMITER_FEIGN_CLIENT_NAME)
 @RateLimiter(name = RATE_LIMITER_FEIGN_CLIENT_NAME)

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/retry/ReactiveRetryDummyService.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.service.test.retry;
+package io.github.resilience4j.springboot3.service.test.retry;
 
 
 import io.reactivex.Flowable;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/retry/ReactiveRetryDummyServiceImpl.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.service.test.retry;
+package io.github.resilience4j.springboot3.service.test.retry;
 
 import io.github.resilience4j.retry.annotation.Retry;
 import io.reactivex.Flowable;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/retry/RetryDummyFeignClient.java
Patch:
@@ -1,12 +1,12 @@
-package io.github.resilience4j.service.test.retry;
+package io.github.resilience4j.springboot3.service.test.retry;
 
 
 import io.github.resilience4j.retry.annotation.Retry;
 import org.springframework.cloud.openfeign.FeignClient;
 import org.springframework.web.bind.annotation.GetMapping;
 import org.springframework.web.bind.annotation.PathVariable;
 
-import static io.github.resilience4j.service.test.retry.RetryDummyFeignClient.RETRY_DUMMY_FEIGN_CLIENT_NAME;
+import static io.github.resilience4j.springboot3.service.test.retry.RetryDummyFeignClient.RETRY_DUMMY_FEIGN_CLIENT_NAME;
 
 @FeignClient(url = "localhost:8090", name = RETRY_DUMMY_FEIGN_CLIENT_NAME)
 @Retry(name = RETRY_DUMMY_FEIGN_CLIENT_NAME)

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/retry/RetryDummyService.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.service.test.retry;
+package io.github.resilience4j.springboot3.service.test.retry;
 
 
 import java.io.IOException;

File: resilience4j-spring-boot3/src/test/java/io/github/resilience4j/springboot3/service/test/retry/RetryDummyServiceImpl.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.service.test.retry;
+package io.github.resilience4j.springboot3.service.test.retry;
 
 
 import io.github.resilience4j.retry.annotation.Retry;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/bulkhead/configure/BulkheadAspectExt.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.bulkhead.configure;
+package io.github.resilience4j.spring6.bulkhead.configure;
 
 import io.github.resilience4j.bulkhead.Bulkhead;
 import org.aspectj.lang.ProceedingJoinPoint;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/bulkhead/configure/BulkheadConfigurationProperties.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.bulkhead.configure;
+package io.github.resilience4j.spring6.bulkhead.configure;
 
 import org.springframework.core.Ordered;
 

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/bulkhead/configure/ReactorBulkheadAspectExt.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.bulkhead.configure;
+package io.github.resilience4j.spring6.bulkhead.configure;
 
 import io.github.resilience4j.bulkhead.Bulkhead;
 import io.github.resilience4j.reactor.bulkhead.operator.BulkheadOperator;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/bulkhead/configure/RxJava2BulkheadAspectExt.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.bulkhead.configure;
+package io.github.resilience4j.spring6.bulkhead.configure;
 
 import io.github.resilience4j.bulkhead.Bulkhead;
 import io.github.resilience4j.bulkhead.operator.BulkheadOperator;
@@ -24,7 +24,7 @@
 
 import java.util.Set;
 
-import static io.github.resilience4j.utils.AspectUtil.newHashSet;
+import static io.github.resilience4j.spring6.utils.AspectUtil.newHashSet;
 
 /**
  * the Rx bulkhead logic support for the spring AOP conditional on the presence of Rx classes on the

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/bulkhead/configure/package-info.java
Patch:
@@ -18,7 +18,7 @@
  */
 @NonNullApi
 @NonNullFields
-package io.github.resilience4j.ratelimiter.autoconfigure;
+package io.github.resilience4j.spring6.bulkhead.configure;
 
 import io.github.resilience4j.core.lang.NonNullApi;
 import io.github.resilience4j.core.lang.NonNullFields;
\ No newline at end of file

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/bulkhead/configure/threadpool/ThreadPoolBulkheadConfiguration.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.bulkhead.configure.threadpool;
+package io.github.resilience4j.spring6.bulkhead.configure.threadpool;
 
 import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;
 import io.github.resilience4j.bulkhead.ThreadPoolBulkheadConfig;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/circuitbreaker/configure/CircuitBreakerAspectExt.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.configure;
+package io.github.resilience4j.spring6.circuitbreaker.configure;
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import org.aspectj.lang.ProceedingJoinPoint;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/circuitbreaker/configure/CircuitBreakerConfigurationProperties.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.configure;
+package io.github.resilience4j.spring6.circuitbreaker.configure;
 
 import org.springframework.core.Ordered;
 

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/circuitbreaker/configure/ReactorCircuitBreakerAspectExt.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.configure;
+package io.github.resilience4j.spring6.circuitbreaker.configure;
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.reactor.circuitbreaker.operator.CircuitBreakerOperator;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/circuitbreaker/configure/package-info.java
Patch:
@@ -18,7 +18,7 @@
  */
 @NonNullApi
 @NonNullFields
-package io.github.resilience4j.circuitbreaker.monitoring.health;
+package io.github.resilience4j.spring6.circuitbreaker.configure;
 
 import io.github.resilience4j.core.lang.NonNullApi;
 import io.github.resilience4j.core.lang.NonNullFields;
\ No newline at end of file

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/fallback/CompletionStageFallbackDecorator.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.fallback;
+package io.github.resilience4j.spring6.fallback;
 
 import io.github.resilience4j.core.functions.CheckedSupplier;
 

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/fallback/DefaultFallbackDecorator.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.fallback;
+package io.github.resilience4j.spring6.fallback;
 
 import io.github.resilience4j.core.functions.CheckedSupplier;
-import io.github.resilience4j.timelimiter.configure.IllegalReturnTypeException;
+import io.github.resilience4j.spring6.timelimiter.configure.IllegalReturnTypeException;
 
 /**
  * default fallbackMethod decorator. it catches throwable and invoke the fallbackMethod method.

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/fallback/FallbackDecorator.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.fallback;
+package io.github.resilience4j.spring6.fallback;
 
 import io.github.resilience4j.core.functions.CheckedSupplier;
 

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/fallback/FallbackDecorators.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.fallback;
+package io.github.resilience4j.spring6.fallback;
 
 import io.github.resilience4j.core.functions.CheckedSupplier;
 

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/fallback/FallbackExecutor.java
Patch:
@@ -1,7 +1,7 @@
-package io.github.resilience4j.fallback;
+package io.github.resilience4j.spring6.fallback;
 
 import io.github.resilience4j.core.functions.CheckedSupplier;
-import io.github.resilience4j.spelresolver.SpelResolver;
+import io.github.resilience4j.spring6.spelresolver.SpelResolver;
 import org.aspectj.lang.ProceedingJoinPoint;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/fallback/FallbackMethod.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.fallback;
+package io.github.resilience4j.spring6.fallback;
 
 import io.github.resilience4j.core.lang.Nullable;
 import org.springframework.util.ConcurrentReferenceHashMap;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/fallback/ReactorFallbackDecorator.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.fallback;
+package io.github.resilience4j.spring6.fallback;
 
 import io.github.resilience4j.core.functions.CheckedSupplier;
 import org.reactivestreams.Publisher;
@@ -23,7 +23,7 @@
 import java.util.Set;
 import java.util.function.Function;
 
-import static io.github.resilience4j.utils.AspectUtil.newHashSet;
+import static io.github.resilience4j.spring6.utils.AspectUtil.newHashSet;
 
 /**
  * fallbackMethod decorator for {@link Flux} and {@link Mono}

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/fallback/RxJava2FallbackDecorator.java
Patch:
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.fallback;
+package io.github.resilience4j.spring6.fallback;
 
 import io.github.resilience4j.core.functions.CheckedSupplier;
 import io.reactivex.*;
 
 import java.util.Set;
 import java.util.function.Function;
 
-import static io.github.resilience4j.utils.AspectUtil.newHashSet;
+import static io.github.resilience4j.spring6.utils.AspectUtil.newHashSet;
 
 /**
  * fallbackMethod decorator for {@link ObservableSource}, {@link SingleSource}, {@link

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/fallback/package-info.java
Patch:
@@ -18,7 +18,7 @@
  */
 @NonNullApi
 @NonNullFields
-package io.github.resilience4j.fallback;
+package io.github.resilience4j.spring6.fallback;
 
 import io.github.resilience4j.core.lang.NonNullApi;
 import io.github.resilience4j.core.lang.NonNullFields;
\ No newline at end of file

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/ratelimiter/configure/RateLimiterAspectExt.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.ratelimiter.configure;
+package io.github.resilience4j.spring6.ratelimiter.configure;
 
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import org.aspectj.lang.ProceedingJoinPoint;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/ratelimiter/configure/RateLimiterConfigurationProperties.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.ratelimiter.configure;
+package io.github.resilience4j.spring6.ratelimiter.configure;
 
 import org.springframework.core.Ordered;
 

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/ratelimiter/configure/ReactorRateLimiterAspectExt.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.ratelimiter.configure;
+package io.github.resilience4j.spring6.ratelimiter.configure;
 
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.reactor.ratelimiter.operator.RateLimiterOperator;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/ratelimiter/configure/RxJava2RateLimiterAspectExt.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.ratelimiter.configure;
+package io.github.resilience4j.spring6.ratelimiter.configure;
 
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.ratelimiter.operator.RateLimiterOperator;
@@ -24,7 +24,7 @@
 
 import java.util.Set;
 
-import static io.github.resilience4j.utils.AspectUtil.newHashSet;
+import static io.github.resilience4j.spring6.utils.AspectUtil.newHashSet;
 
 /**
  * the Rx RateLimiter logic support for the spring AOP conditional on the presence of Rx classes on

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/ratelimiter/configure/package-info.java
Patch:
@@ -18,7 +18,7 @@
  */
 @NonNullApi
 @NonNullFields
-package io.github.resilience4j.bulkhead.monitoring.endpoint;
+package io.github.resilience4j.spring6.ratelimiter.configure;
 
 import io.github.resilience4j.core.lang.NonNullApi;
 import io.github.resilience4j.core.lang.NonNullFields;
\ No newline at end of file

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/retry/configure/ReactorRetryAspectExt.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.retry.configure;
+package io.github.resilience4j.spring6.retry.configure;
 
 import io.github.resilience4j.reactor.retry.RetryOperator;
 import org.aspectj.lang.ProceedingJoinPoint;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/retry/configure/RetryAspectExt.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.retry.configure;
+package io.github.resilience4j.spring6.retry.configure;
 
 import io.github.resilience4j.retry.Retry;
 import org.aspectj.lang.ProceedingJoinPoint;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/retry/configure/RetryConfigurationProperties.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.retry.configure;
+package io.github.resilience4j.spring6.retry.configure;
 /*
  * Copyright 2019 Mahmoud Romeh
  *

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/retry/configure/package-info.java
Patch:
@@ -18,7 +18,7 @@
  */
 @NonNullApi
 @NonNullFields
-package io.github.resilience4j.bulkhead.autoconfigure;
+package io.github.resilience4j.spring6.retry.configure;
 
 import io.github.resilience4j.core.lang.NonNullApi;
 import io.github.resilience4j.core.lang.NonNullFields;
\ No newline at end of file

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/spelresolver/DefaultSpelResolver.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.spelresolver;
+package io.github.resilience4j.spring6.spelresolver;
 
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.context.EmbeddedValueResolverAware;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/spelresolver/SpelResolver.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.spelresolver;
+package io.github.resilience4j.spring6.spelresolver;
 
 import java.lang.reflect.Method;
 

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/spelresolver/SpelRootObject.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.spelresolver;
+package io.github.resilience4j.spring6.spelresolver;
 
 import java.lang.reflect.Method;
 

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/spelresolver/configure/SpelResolverConfiguration.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.spelresolver.configure;
+package io.github.resilience4j.spring6.spelresolver.configure;
 
-import io.github.resilience4j.spelresolver.DefaultSpelResolver;
-import io.github.resilience4j.spelresolver.SpelResolver;
+import io.github.resilience4j.spring6.spelresolver.DefaultSpelResolver;
+import io.github.resilience4j.spring6.spelresolver.SpelResolver;
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/timelimiter/configure/IllegalReturnTypeException.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.timelimiter.configure;
+package io.github.resilience4j.spring6.timelimiter.configure;
 
 public class IllegalReturnTypeException extends IllegalArgumentException {
 

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/timelimiter/configure/ReactorTimeLimiterAspectExt.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.github.resilience4j.timelimiter.configure;
+package io.github.resilience4j.spring6.timelimiter.configure;
 
 import io.github.resilience4j.reactor.timelimiter.TimeLimiterOperator;
 import io.github.resilience4j.timelimiter.TimeLimiter;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/timelimiter/configure/RxJava2TimeLimiterAspectExt.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.github.resilience4j.timelimiter.configure;
+package io.github.resilience4j.spring6.timelimiter.configure;
 
 import io.github.resilience4j.timelimiter.TimeLimiter;
 import io.github.resilience4j.timelimiter.transformer.TimeLimiterTransformer;
@@ -23,7 +23,7 @@
 
 import java.util.Set;
 
-import static io.github.resilience4j.utils.AspectUtil.newHashSet;
+import static io.github.resilience4j.spring6.utils.AspectUtil.newHashSet;
 
 public class RxJava2TimeLimiterAspectExt implements TimeLimiterAspectExt {
 

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/timelimiter/configure/TimeLimiterAspectExt.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.github.resilience4j.timelimiter.configure;
+package io.github.resilience4j.spring6.timelimiter.configure;
 
 import io.github.resilience4j.timelimiter.TimeLimiter;
 import org.aspectj.lang.ProceedingJoinPoint;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/timelimiter/configure/TimeLimiterConfigurationProperties.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.github.resilience4j.timelimiter.configure;
+package io.github.resilience4j.spring6.timelimiter.configure;
 
 import org.springframework.core.Ordered;
 

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/timelimiter/configure/package-info.java
Patch:
@@ -15,7 +15,7 @@
  */
 @NonNullApi
 @NonNullFields
-package io.github.resilience4j.timelimiter.configure;
+package io.github.resilience4j.spring6.timelimiter.configure;
 
 import io.github.resilience4j.core.lang.NonNullApi;
 import io.github.resilience4j.core.lang.NonNullFields;
\ No newline at end of file

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/utils/AnnotationExtractor.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.utils;
+package io.github.resilience4j.spring6.utils;
 
 import io.github.resilience4j.core.lang.Nullable;
 import org.slf4j.Logger;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/utils/AspectJOnClasspathCondition.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.utils;
+package io.github.resilience4j.spring6.utils;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/utils/AspectUtil.java
Patch:
@@ -12,7 +12,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.utils;
+package io.github.resilience4j.spring6.utils;
 
 import org.springframework.context.annotation.ConditionContext;
 

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/utils/ReactorOnClasspathCondition.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.utils;
+package io.github.resilience4j.spring6.utils;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/utils/RxJava2OnClasspathCondition.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.utils;
+package io.github.resilience4j.spring6.utils;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: resilience4j-spring6/src/main/java/io/github/resilience4j/spring6/utils/package-info.java
Patch:
@@ -18,7 +18,7 @@
  */
 @NonNullApi
 @NonNullFields
-package io.github.resilience4j.utils;
+package io.github.resilience4j.spring6.utils;
 
 import io.github.resilience4j.core.lang.NonNullApi;
 import io.github.resilience4j.core.lang.NonNullFields;
\ No newline at end of file

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/BulkheadDummyService.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j;
+package io.github.resilience4j.spring6;
 
 import io.github.resilience4j.bulkhead.annotation.Bulkhead;
 import io.reactivex.*;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/CircuitBreakerDummyService.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j;
+package io.github.resilience4j.spring6;
 
 import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
 import io.reactivex.*;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/DummySpelBean.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j;
+package io.github.resilience4j.spring6;
 
 public interface DummySpelBean {
     String getBulkheadName(String param1);

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/RateLimiterDummyService.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j;
+package io.github.resilience4j.spring6;
 
 import io.github.resilience4j.ratelimiter.annotation.RateLimiter;
 import io.reactivex.*;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/RetryDummyService.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j;
+package io.github.resilience4j.spring6;
 
 import io.github.resilience4j.retry.annotation.Retry;
 import io.reactivex.*;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/TestDummyService.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j;
+package io.github.resilience4j.spring6;
 
 import io.reactivex.*;
 import reactor.core.publisher.Flux;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/TestThreadLocalContextPropagator.java
Patch:
@@ -1,12 +1,12 @@
-package io.github.resilience4j;
+package io.github.resilience4j.spring6;
 
 import io.github.resilience4j.core.ContextPropagator;
 
 import java.util.Optional;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 
-import static io.github.resilience4j.TestThreadLocalContextPropagator.TestThreadLocalContextHolder.*;
+import static io.github.resilience4j.spring6.TestThreadLocalContextPropagator.TestThreadLocalContextHolder.*;
 
 public class TestThreadLocalContextPropagator<T> implements ContextPropagator<T> {
 

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/TimeLimiterDummyService.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j;
+package io.github.resilience4j.spring6;
 
 import io.github.resilience4j.timelimiter.annotation.TimeLimiter;
 import io.reactivex.*;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/bulkhead/configure/BulkHeadConfigurationTest.java
Patch:
@@ -1,8 +1,8 @@
-package io.github.resilience4j.bulkhead.configure;
+package io.github.resilience4j.spring6.bulkhead.configure;
 
-import io.github.resilience4j.TestThreadLocalContextPropagator;
+import io.github.resilience4j.spring6.TestThreadLocalContextPropagator;
 import io.github.resilience4j.bulkhead.*;
-import io.github.resilience4j.bulkhead.configure.threadpool.ThreadPoolBulkheadConfiguration;
+import io.github.resilience4j.spring6.bulkhead.configure.threadpool.ThreadPoolBulkheadConfiguration;
 import io.github.resilience4j.bulkhead.event.BulkheadEvent;
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.bulkhead.configuration.CommonThreadPoolBulkheadConfigurationProperties;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/bulkhead/configure/BulkheadAspectSpelResolverTest.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.bulkhead.configure;
+package io.github.resilience4j.spring6.bulkhead.configure;
 
-import io.github.resilience4j.TestApplication;
-import io.github.resilience4j.TestDummyService;
+import io.github.resilience4j.spring6.TestApplication;
+import io.github.resilience4j.spring6.TestDummyService;
 import io.github.resilience4j.bulkhead.BulkheadRegistry;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/bulkhead/configure/BulkheadBuilderCustomizerTest.java
Patch:
@@ -1,8 +1,8 @@
-package io.github.resilience4j.bulkhead.configure;
+package io.github.resilience4j.spring6.bulkhead.configure;
 
-import io.github.resilience4j.TestThreadLocalContextPropagator;
+import io.github.resilience4j.spring6.TestThreadLocalContextPropagator;
 import io.github.resilience4j.bulkhead.*;
-import io.github.resilience4j.bulkhead.configure.threadpool.ThreadPoolBulkheadConfiguration;
+import io.github.resilience4j.spring6.bulkhead.configure.threadpool.ThreadPoolBulkheadConfiguration;
 import io.github.resilience4j.bulkhead.event.BulkheadEvent;
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.bulkhead.configuration.BulkheadConfigCustomizer;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/bulkhead/configure/BulkheadRecoveryTest.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.bulkhead.configure;
+package io.github.resilience4j.spring6.bulkhead.configure;
 
-import io.github.resilience4j.TestApplication;
-import io.github.resilience4j.TestDummyService;
+import io.github.resilience4j.spring6.TestApplication;
+import io.github.resilience4j.spring6.TestDummyService;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/bulkhead/configure/ReactorBulkheadAspectExtTest.java
Patch:
@@ -13,9 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.bulkhead.configure;
+package io.github.resilience4j.spring6.bulkhead.configure;
 
 import io.github.resilience4j.bulkhead.Bulkhead;
+import io.github.resilience4j.spring6.bulkhead.configure.ReactorBulkheadAspectExt;
 import org.aspectj.lang.ProceedingJoinPoint;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/bulkhead/configure/RxJava2BulkheadAspectExtTest.java
Patch:
@@ -13,9 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.bulkhead.configure;
+package io.github.resilience4j.spring6.bulkhead.configure;
 
 import io.github.resilience4j.bulkhead.Bulkhead;
+import io.github.resilience4j.spring6.bulkhead.configure.RxJava2BulkheadAspectExt;
 import io.reactivex.Flowable;
 import io.reactivex.Single;
 import org.aspectj.lang.ProceedingJoinPoint;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/circuitbreaker/configure/CircuitBreakerAspectSpelResolverTest.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.configure;
+package io.github.resilience4j.spring6.circuitbreaker.configure;
 
-import io.github.resilience4j.TestApplication;
-import io.github.resilience4j.TestDummyService;
+import io.github.resilience4j.spring6.TestApplication;
+import io.github.resilience4j.spring6.TestDummyService;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/circuitbreaker/configure/CircuitBreakerConfigurationTest.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.circuitbreaker.configure;
+package io.github.resilience4j.spring6.circuitbreaker.configure;
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
@@ -9,6 +9,8 @@
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.core.ConfigurationNotFoundException;
 import io.github.resilience4j.core.registry.CompositeRegistryEventConsumer;
+import io.github.resilience4j.spring6.circuitbreaker.configure.CircuitBreakerConfiguration;
+import io.github.resilience4j.spring6.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.junit.MockitoJUnitRunner;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/circuitbreaker/configure/CircuitBreakerRecoveryTest.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.configure;
+package io.github.resilience4j.spring6.circuitbreaker.configure;
 
-import io.github.resilience4j.TestApplication;
-import io.github.resilience4j.TestDummyService;
+import io.github.resilience4j.spring6.TestApplication;
+import io.github.resilience4j.spring6.TestDummyService;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/circuitbreaker/configure/FallbackConfigurationTest.java
Patch:
@@ -1,7 +1,7 @@
-package io.github.resilience4j.circuitbreaker.configure;
+package io.github.resilience4j.spring6.circuitbreaker.configure;
 
-import io.github.resilience4j.fallback.FallbackDecorators;
-import io.github.resilience4j.fallback.configure.FallbackConfiguration;
+import io.github.resilience4j.spring6.fallback.FallbackDecorators;
+import io.github.resilience4j.spring6.fallback.configure.FallbackConfiguration;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/circuitbreaker/configure/ReactorCircuitBreakerAspectExtTest.java
Patch:
@@ -13,9 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.configure;
+package io.github.resilience4j.spring6.circuitbreaker.configure;
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
+import io.github.resilience4j.spring6.circuitbreaker.configure.ReactorCircuitBreakerAspectExt;
 import org.aspectj.lang.ProceedingJoinPoint;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/circuitbreaker/configure/RxJava2CircuitBreakerAspectExtTest.java
Patch:
@@ -13,9 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.circuitbreaker.configure;
+package io.github.resilience4j.spring6.circuitbreaker.configure;
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
+import io.github.resilience4j.spring6.circuitbreaker.configure.RxJava2CircuitBreakerAspectExt;
 import io.reactivex.Flowable;
 import io.reactivex.Single;
 import org.aspectj.lang.ProceedingJoinPoint;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/fallback/FallbackMethodParentTest.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.fallback;
+package io.github.resilience4j.spring6.fallback;
 
 import org.junit.Test;
 

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/fallback/FallbackMethodTest.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.fallback;
+package io.github.resilience4j.spring6.fallback;
 
 import org.junit.Test;
 

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/fallback/RethrowCheckedException.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.fallback;
+package io.github.resilience4j.spring6.fallback;
 
 class RethrowCheckedException extends Exception {
 

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/fallback/RethrowException.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.fallback;
+package io.github.resilience4j.spring6.fallback;
 
 class RethrowException extends RuntimeException {
 

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/ratelimiter/configure/RateLimiterAspectSpelResolverTest.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.ratelimiter.configure;
+package io.github.resilience4j.spring6.ratelimiter.configure;
 
-import io.github.resilience4j.TestApplication;
-import io.github.resilience4j.TestDummyService;
+import io.github.resilience4j.spring6.TestApplication;
+import io.github.resilience4j.spring6.TestDummyService;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/ratelimiter/configure/RateLimiterConfigurationSpringTest.java
Patch:
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.ratelimiter.configure;
+package io.github.resilience4j.spring6.ratelimiter.configure;
 
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
-import io.github.resilience4j.fallback.FallbackExecutor;
+import io.github.resilience4j.spring6.fallback.FallbackExecutor;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
 import io.github.resilience4j.ratelimiter.event.RateLimiterEvent;
-import io.github.resilience4j.spelresolver.SpelResolver;
+import io.github.resilience4j.spring6.spelresolver.SpelResolver;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/ratelimiter/configure/RateLimiterConfigurationTest.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.ratelimiter.configure;
+package io.github.resilience4j.spring6.ratelimiter.configure;
 
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.ratelimiter.configuration.RateLimiterConfigCustomizer;
@@ -8,6 +8,8 @@
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
 import io.github.resilience4j.ratelimiter.event.RateLimiterEvent;
+import io.github.resilience4j.spring6.ratelimiter.configure.RateLimiterConfiguration;
+import io.github.resilience4j.spring6.ratelimiter.configure.RateLimiterConfigurationProperties;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.junit.MockitoJUnitRunner;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/ratelimiter/configure/RateLimiterRecoveryTest.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.ratelimiter.configure;
+package io.github.resilience4j.spring6.ratelimiter.configure;
 
-import io.github.resilience4j.TestApplication;
-import io.github.resilience4j.TestDummyService;
+import io.github.resilience4j.spring6.TestApplication;
+import io.github.resilience4j.spring6.TestDummyService;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/ratelimiter/configure/ReactorRateLimiterAspectExtTest.java
Patch:
@@ -13,9 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.ratelimiter.configure;
+package io.github.resilience4j.spring6.ratelimiter.configure;
 
 import io.github.resilience4j.ratelimiter.RateLimiter;
+import io.github.resilience4j.spring6.ratelimiter.configure.ReactorRateLimiterAspectExt;
 import org.aspectj.lang.ProceedingJoinPoint;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/ratelimiter/configure/RxJava2RateLimiterAspectExtTest.java
Patch:
@@ -13,9 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.ratelimiter.configure;
+package io.github.resilience4j.spring6.ratelimiter.configure;
 
 import io.github.resilience4j.ratelimiter.RateLimiter;
+import io.github.resilience4j.spring6.ratelimiter.configure.RxJava2RateLimiterAspectExt;
 import io.reactivex.*;
 import org.aspectj.lang.ProceedingJoinPoint;
 import org.junit.Test;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/retry/configure/ReactorRetryAspectExtTest.java
Patch:
@@ -13,9 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.retry.configure;
+package io.github.resilience4j.spring6.retry.configure;
 
 import io.github.resilience4j.retry.Retry;
+import io.github.resilience4j.spring6.retry.configure.ReactorRetryAspectExt;
 import org.aspectj.lang.ProceedingJoinPoint;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/retry/configure/RetryAspectSpelResolverTest.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.retry.configure;
+package io.github.resilience4j.spring6.retry.configure;
 
-import io.github.resilience4j.TestApplication;
-import io.github.resilience4j.TestDummyService;
+import io.github.resilience4j.spring6.TestApplication;
+import io.github.resilience4j.spring6.TestDummyService;
 import io.github.resilience4j.retry.RetryRegistry;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/retry/configure/RetryConfigurationTest.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.retry.configure;
+package io.github.resilience4j.spring6.retry.configure;
 
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.retry.configuration.RetryConfigCustomizer;
@@ -9,6 +9,8 @@
 import io.github.resilience4j.retry.Retry;
 import io.github.resilience4j.retry.RetryRegistry;
 import io.github.resilience4j.retry.event.RetryEvent;
+import io.github.resilience4j.spring6.retry.configure.RetryConfiguration;
+import io.github.resilience4j.spring6.retry.configure.RetryConfigurationProperties;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.junit.MockitoJUnitRunner;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/retry/configure/RetryRecoveryTest.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.retry.configure;
+package io.github.resilience4j.spring6.retry.configure;
 
-import io.github.resilience4j.TestApplication;
-import io.github.resilience4j.TestDummyService;
+import io.github.resilience4j.spring6.TestApplication;
+import io.github.resilience4j.spring6.TestDummyService;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/retry/configure/RxJava2RetryAspectExtTest.java
Patch:
@@ -13,9 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.retry.configure;
+package io.github.resilience4j.spring6.retry.configure;
 
 import io.github.resilience4j.retry.Retry;
+import io.github.resilience4j.spring6.retry.configure.RxJava2RetryAspectExt;
 import io.reactivex.Flowable;
 import io.reactivex.Single;
 import org.aspectj.lang.ProceedingJoinPoint;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/spelresolver/DefaultSpelResolverTest.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.spelresolver;
+package io.github.resilience4j.spring6.spelresolver;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.BDDMockito.given;
@@ -34,8 +34,8 @@
 import org.springframework.expression.spel.standard.SpelExpressionParser;
 import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
 
-import io.github.resilience4j.DummySpelBean;
-import io.github.resilience4j.TestApplication;
+import io.github.resilience4j.spring6.DummySpelBean;
+import io.github.resilience4j.spring6.TestApplication;
 
 @RunWith(SpringJUnit4ClassRunner.class)
 @SpringBootTest(classes = TestApplication.class, properties = "property=backend")

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/timelimiter/configure/ReactorTimeLimiterAspectExtTest.java
Patch:
@@ -1,5 +1,7 @@
-package io.github.resilience4j.timelimiter.configure;
+package io.github.resilience4j.spring6.timelimiter.configure;
 
+import io.github.resilience4j.spring6.timelimiter.configure.IllegalReturnTypeException;
+import io.github.resilience4j.spring6.timelimiter.configure.ReactorTimeLimiterAspectExt;
 import io.github.resilience4j.timelimiter.TimeLimiter;
 import org.aspectj.lang.ProceedingJoinPoint;
 import org.junit.Test;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/timelimiter/configure/RxJava2TimeLimiterAspectExtTest.java
Patch:
@@ -1,5 +1,7 @@
-package io.github.resilience4j.timelimiter.configure;
+package io.github.resilience4j.spring6.timelimiter.configure;
 
+import io.github.resilience4j.spring6.timelimiter.configure.IllegalReturnTypeException;
+import io.github.resilience4j.spring6.timelimiter.configure.RxJava2TimeLimiterAspectExt;
 import io.github.resilience4j.timelimiter.TimeLimiter;
 import io.reactivex.*;
 import org.aspectj.lang.ProceedingJoinPoint;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/timelimiter/configure/TimeLimiterAspectSpelResolverTest.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.timelimiter.configure;
+package io.github.resilience4j.spring6.timelimiter.configure;
 
-import io.github.resilience4j.TestApplication;
-import io.github.resilience4j.TestDummyService;
+import io.github.resilience4j.spring6.TestApplication;
+import io.github.resilience4j.spring6.TestDummyService;
 import io.github.resilience4j.timelimiter.TimeLimiterRegistry;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/timelimiter/configure/TimeLimiterConfigurationSpringTest.java
Patch:
@@ -1,10 +1,10 @@
-package io.github.resilience4j.timelimiter.configure;
+package io.github.resilience4j.spring6.timelimiter.configure;
 
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.ContextAwareScheduledThreadPoolExecutor;
-import io.github.resilience4j.fallback.FallbackExecutor;
-import io.github.resilience4j.spelresolver.SpelResolver;
+import io.github.resilience4j.spring6.fallback.FallbackExecutor;
+import io.github.resilience4j.spring6.spelresolver.SpelResolver;
 import io.github.resilience4j.timelimiter.TimeLimiterRegistry;
 import io.github.resilience4j.timelimiter.event.TimeLimiterEvent;
 import org.junit.Test;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/timelimiter/configure/TimeLimiterConfigurationTest.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.timelimiter.configure;
+package io.github.resilience4j.spring6.timelimiter.configure;
 
 import static java.util.Collections.emptyList;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -7,6 +7,8 @@
 import java.time.Duration;
 import java.util.Collections;
 
+import io.github.resilience4j.spring6.timelimiter.configure.TimeLimiterConfiguration;
+import io.github.resilience4j.spring6.timelimiter.configure.TimeLimiterConfigurationProperties;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.junit.MockitoJUnitRunner;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/timelimiter/configure/TimeLimiterRecoveryTest.java
Patch:
@@ -1,7 +1,7 @@
-package io.github.resilience4j.timelimiter.configure;
+package io.github.resilience4j.spring6.timelimiter.configure;
 
-import io.github.resilience4j.TestApplication;
-import io.github.resilience4j.TestDummyService;
+import io.github.resilience4j.spring6.TestApplication;
+import io.github.resilience4j.spring6.TestDummyService;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;

File: resilience4j-spring6/src/test/java/io/github/resilience4j/spring6/utils/AnnotationExtractorTest.java
Patch:
@@ -1,6 +1,7 @@
-package io.github.resilience4j.utils;
+package io.github.resilience4j.spring6.utils;
 
 import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
+import io.github.resilience4j.spring6.utils.AnnotationExtractor;
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/bulkhead/BulkheadInterceptor.java
Patch:
@@ -48,7 +48,7 @@ public class BulkheadInterceptor extends BaseInterceptor implements MethodInterc
     private final PublisherExtension extension;
 
     /**
-     * @param executionHandleLocator                The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.
+     * @param executionHandleLocator                The bean context to allow for DI.
      * @param bulkheadRegistry           bulkhead registry used to retrieve {@link Bulkhead} by name
      * @param threadPoolBulkheadRegistry thread pool bulkhead registry used to retrieve {@link Bulkhead} by name
      */

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java
Patch:
@@ -20,6 +20,7 @@
 import io.github.resilience4j.service.test.DummyService;
 import io.github.resilience4j.service.test.TestApplication;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;
@@ -46,6 +47,7 @@
 @RunWith(SpringJUnit4ClassRunner.class)
 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)
 @AutoConfigureWebTestClient(timeout="36000")
+@Ignore
 public class CircuitBreakerHystrixStreamEventsTest {
 
     public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = "/actuator/hystrixstreamcircuitbreakerevents";

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/circuitbreaker/configuration/CircuitBreakerConfigurationPropertiesTest.java
Patch:
@@ -343,7 +343,7 @@ public void testIllegalArgumentOnSlowCallDurationThreshold() {
     @Test(expected = IllegalArgumentException.class)
     public void testIllegalArgumentOnWaitDurationInHalfOpenState() {
         CommonCircuitBreakerConfigurationProperties.InstanceProperties defaultProperties = new CommonCircuitBreakerConfigurationProperties.InstanceProperties();
-        defaultProperties.setMaxWaitDurationInHalfOpenState(Duration.ZERO);
+        defaultProperties.setMaxWaitDurationInHalfOpenState(Duration.ofMillis(-1));
     }
 
     @Test

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreakerConfig.java
Patch:
@@ -497,12 +497,12 @@ public Builder slowCallDurationThreshold(Duration slowCallDurationThreshold) {
          * @param maxWaitDurationInHalfOpenState the wait duration which specifies how long the
          *                                CircuitBreaker should stay in Half Open
          * @return the CircuitBreakerConfig.Builder
-         * @throws IllegalArgumentException if {@code maxWaitDurationInHalfOpenState.toMillis() < 1}
+         * @throws IllegalArgumentException if {@code maxWaitDurationInHalfOpenState.toMillis() < 0}
          */
         public Builder maxWaitDurationInHalfOpenState(Duration maxWaitDurationInHalfOpenState) {
-            if (maxWaitDurationInHalfOpenState.toMillis() < 1) {
+            if (maxWaitDurationInHalfOpenState.toMillis() < 0) {
                 throw new IllegalArgumentException(
-                    "maxWaitDurationInHalfOpenState must be at least 1[ms]");
+                    "maxWaitDurationInHalfOpenState must be greater than or equal to 0[ms]");
             }
             this.maxWaitDurationInHalfOpenState = maxWaitDurationInHalfOpenState;
             return this;

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/circuitbreaker/configuration/CommonCircuitBreakerConfigurationProperties.java
Patch:
@@ -651,9 +651,9 @@ public InstanceProperties setSlowCallDurationThreshold(Duration slowCallDuration
 
         public InstanceProperties setMaxWaitDurationInHalfOpenState(Duration maxWaitDurationInHalfOpenState) {
             Objects.requireNonNull(maxWaitDurationInHalfOpenState);
-            if (maxWaitDurationInHalfOpenState.toMillis() < 1) {
+            if (maxWaitDurationInHalfOpenState.toMillis() < 0) {
                 throw new IllegalArgumentException(
-                    "maxWaitDurationInHalfOpenState must be greater than or equal to 1 ms.");
+                    "maxWaitDurationInHalfOpenState must be greater than or equal to 0 ms.");
             }
 
             this.maxWaitDurationInHalfOpenState = maxWaitDurationInHalfOpenState;

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/scheduled/threadpool/autoconfigure/ContextAwareScheduledThreadPoolAutoConfiguration.java
Patch:
@@ -25,7 +25,7 @@
 import org.springframework.context.annotation.Configuration;
 
 @Configuration
-@ConditionalOnProperty(value = "resilience4j.scheduled.executor.corePoolSize")
+@ConditionalOnProperty(value = "resilience4j.scheduled.executor.core-pool-size")
 @EnableConfigurationProperties({ContextAwareScheduledThreadPoolProperties.class})
 public class ContextAwareScheduledThreadPoolAutoConfiguration {
 

File: resilience4j-hedge/src/test/java/io/github/resilience4j/hedge/internal/HedgeImplFutureBehaviorsTest.java
Patch:
@@ -53,7 +53,7 @@ public class HedgeImplFutureBehaviorsTest {
     private static final HedgeBehaviorSpecification SLOW_HEDGE_SUCCESS = new HedgeBehaviorSpecification(SLOW_SPEED, HEDGED, null);
     private static final HedgeBehaviorSpecification SLOW_HEDGE_FAILURE = new HedgeBehaviorSpecification(SLOW_SPEED, HEDGED, HEDGE_RUNTIME_EXCEPTION);
     private final Logger logger = mock(Logger.class);
-    private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(15);
+    private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
 
     @Test
     public void shouldReturnValueWhenSuppliedExecutor() throws Exception {

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerActuatorTest.java
Patch:
@@ -106,7 +106,6 @@ public void testCircuitBreakerDetails() {
         assertThat(circuitBreakersResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
         assertThat(circuitBreakersResponse.getBody()).isNotNull();
         assertThat(circuitBreakersResponse.getBody().getCircuitBreakers()).isNotNull();
-        assertThat(circuitBreakersResponse.getBody().getCircuitBreakers()).hasSize(6);
         final CircuitBreakerDetails cbDetailsA = circuitBreakersResponse.getBody().getCircuitBreakers().get("backendA");
         final CircuitBreaker cbA = circuitBreakerRegistry.circuitBreaker("backendA");
         final CircuitBreaker.Metrics metrics = cbA.getMetrics();

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/bulkhead/configuration/CommonBulkheadConfigurationProperties.java
Patch:
@@ -29,7 +29,7 @@
 import java.util.Map;
 import java.util.Objects;
 
-public class BulkheadConfigurationProperties extends CommonProperties {
+public class CommonBulkheadConfigurationProperties extends CommonProperties {
 
     private static final String DEFAULT = "default";
     private Map<String, InstanceProperties> instances = new HashMap<>();

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/bulkhead/configuration/CommonThreadPoolBulkheadConfigurationProperties.java
Patch:
@@ -30,7 +30,7 @@
 import java.util.Map;
 import java.util.Objects;
 
-public class ThreadPoolBulkheadConfigurationProperties extends CommonProperties {
+public class CommonThreadPoolBulkheadConfigurationProperties extends CommonProperties {
 
     private static final String DEFAULT = "default";
     private Map<String, InstanceProperties> instances = new HashMap<>();

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/circuitbreaker/configuration/CommonCircuitBreakerConfigurationProperties.java
Patch:
@@ -35,7 +35,7 @@
 import static io.github.resilience4j.circuitbreaker.CircuitBreakerConfig.custom;
 import static io.github.resilience4j.circuitbreaker.CircuitBreakerConfig.from;
 
-public class CircuitBreakerConfigurationProperties extends CommonProperties {
+public class CommonCircuitBreakerConfigurationProperties extends CommonProperties {
 
     private static final String DEFAULT = "default";
     private Map<String, InstanceProperties> instances = new HashMap<>();

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/ratelimiter/configuration/CommonRateLimiterConfigurationProperties.java
Patch:
@@ -30,7 +30,7 @@
 import io.github.resilience4j.core.lang.Nullable;
 import io.github.resilience4j.ratelimiter.RateLimiterConfig;
 
-public class RateLimiterConfigurationProperties extends CommonProperties {
+public class CommonRateLimiterConfigurationProperties extends CommonProperties {
 
     private static final String DEFAULT = "default";
     private Map<String, InstanceProperties> instances = new HashMap<>();

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/retry/configuration/CommonRetryConfigurationProperties.java
Patch:
@@ -36,7 +36,7 @@
 /**
  * Main spring properties for retry configuration
  */
-public class RetryConfigurationProperties extends CommonProperties {
+public class CommonRetryConfigurationProperties extends CommonProperties {
 
     private static final String DEFAULT = "default";
     private final Map<String, InstanceProperties> instances = new HashMap<>();

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/timelimiter/configuration/CommonTimeLimiterConfigurationProperties.java
Patch:
@@ -30,7 +30,7 @@
 import java.util.Map;
 import java.util.Objects;
 
-public class TimeLimiterConfigurationProperties extends CommonProperties {
+public class CommonTimeLimiterConfigurationProperties extends CommonProperties {
 
     private static final String DEFAULT = "default";
     private final Map<String, InstanceProperties> instances = new HashMap<>();

File: resilience4j-hedge/src/main/java/io/github/resilience4j/hedge/HedgeConfig.java
Patch:
@@ -46,7 +46,7 @@ public class HedgeConfig implements Serializable {
     private final boolean shouldMeasureErrors;
     private final int windowSize;
     private final Duration cutoff;
-    private final ContextPropagator[] contextPropagators;
+    private final transient ContextPropagator[] contextPropagators;
 
     private HedgeConfig(int concurrentHedges, HedgeDurationSupplierType durationSupplierType, boolean shouldUseFactorAsPercentage, int hedgeTimeFactor, boolean shouldMeasureErrors, int windowSize, Duration cutoff, ContextPropagator[] propagators) {
         this.concurrentHedges = concurrentHedges;

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiterConfig.java
Patch:
@@ -38,7 +38,7 @@ public class RateLimiterConfig implements Serializable {
     private final Duration timeoutDuration;
     private final Duration limitRefreshPeriod;
     private final int limitForPeriod;
-    private final Predicate<Either<? extends Throwable, ?>> drainPermissionsOnResult;
+    private final transient Predicate<Either<? extends Throwable, ?>> drainPermissionsOnResult;
     private final boolean writableStackTraceEnabled;
 
     private RateLimiterConfig(Duration timeoutDuration,

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/bulkhead/autoconfigure/AbstractBulkheadConfigurationOnMissingBean.java
Patch:
@@ -25,7 +25,7 @@
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.bulkhead.configuration.BulkheadConfigCustomizer;
 import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigCustomizer;
-import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigurationProperties;
+import io.github.resilience4j.common.bulkhead.configuration.CommonThreadPoolBulkheadConfigurationProperties;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.registry.RegistryEventConsumer;
 import io.github.resilience4j.fallback.FallbackExecutor;
@@ -128,7 +128,7 @@ public CompositeCustomizer<ThreadPoolBulkheadConfigCustomizer> compositeThreadPo
     @Bean
     @ConditionalOnMissingBean
     public ThreadPoolBulkheadRegistry threadPoolBulkheadRegistry(
-        ThreadPoolBulkheadConfigurationProperties threadPoolBulkheadConfigurationProperties,
+        CommonThreadPoolBulkheadConfigurationProperties threadPoolBulkheadConfigurationProperties,
         EventConsumerRegistry<BulkheadEvent> bulkheadEventConsumerRegistry,
         RegistryEventConsumer<ThreadPoolBulkhead> threadPoolBulkheadRegistryEventConsumer,
         @Qualifier("compositeThreadPoolBulkheadCustomizer") CompositeCustomizer<ThreadPoolBulkheadConfigCustomizer> compositeThreadPoolBulkheadCustomizer) {

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/bulkhead/autoconfigure/ThreadPoolBulkheadProperties.java
Patch:
@@ -15,11 +15,11 @@
  */
 package io.github.resilience4j.bulkhead.autoconfigure;
 
-import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigurationProperties;
+import io.github.resilience4j.common.bulkhead.configuration.CommonThreadPoolBulkheadConfigurationProperties;
 import org.springframework.boot.context.properties.ConfigurationProperties;
 
 
 @ConfigurationProperties(prefix = "resilience4j.thread-pool-bulkhead")
-public class ThreadPoolBulkheadProperties extends ThreadPoolBulkheadConfigurationProperties {
+public class ThreadPoolBulkheadProperties extends CommonThreadPoolBulkheadConfigurationProperties {
 
 }

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/SpringBootCommonTest.java
Patch:
@@ -25,7 +25,7 @@
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.bulkhead.configuration.BulkheadConfigCustomizer;
 import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigCustomizer;
-import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigurationProperties;
+import io.github.resilience4j.common.bulkhead.configuration.CommonThreadPoolBulkheadConfigurationProperties;
 import io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigCustomizer;
 import io.github.resilience4j.common.timelimiter.configuration.TimeLimiterConfigCustomizer;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
@@ -69,7 +69,7 @@ public void testBulkHeadCommonConfig() {
                 new CompositeRegistryEventConsumer<>(Collections.emptyList()),
                 new CompositeCustomizer<>(Collections.singletonList(BulkheadConfigCustomizer.of("backend", builder -> builder.maxConcurrentCalls(10)))))).isNotNull();
         assertThat(bulkheadConfigurationOnMissingBean
-            .threadPoolBulkheadRegistry(new ThreadPoolBulkheadConfigurationProperties(),
+            .threadPoolBulkheadRegistry(new CommonThreadPoolBulkheadConfigurationProperties(),
                 new DefaultEventConsumerRegistry<>(),
                 new CompositeRegistryEventConsumer<>(Collections.emptyList()),
                 new CompositeCustomizer<>(Collections.singletonList(

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/health/CircuitBreakersHealthIndicatorTest.java
Patch:
@@ -158,7 +158,7 @@ public void healthIndicatorMaxImpactCanBeOverridden() {
 
     private void setCircuitBreakerWhen(CircuitBreaker.State givenState, CircuitBreaker circuitBreaker,
                                        CircuitBreakerConfig config, CircuitBreaker.Metrics metrics,
-                                       io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigurationProperties.InstanceProperties instanceProperties,
+                                       io.github.resilience4j.common.circuitbreaker.configuration.CommonCircuitBreakerConfigurationProperties.InstanceProperties instanceProperties,
                                        CircuitBreakerConfigurationProperties circuitBreakerProperties,
                                        boolean allowHealthIndicatorToFail) {
 

File: resilience4j-spring-cloud2/src/main/java/io/github/resilience4j/bulkhead/autoconfigure/RefreshScopedBulkheadAutoConfiguration.java
Patch:
@@ -11,7 +11,7 @@
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.bulkhead.configuration.BulkheadConfigCustomizer;
 import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigCustomizer;
-import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigurationProperties;
+import io.github.resilience4j.common.bulkhead.configuration.CommonThreadPoolBulkheadConfigurationProperties;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.registry.RegistryEventConsumer;
 import org.springframework.beans.factory.annotation.Qualifier;
@@ -66,7 +66,7 @@ public BulkheadRegistry bulkheadRegistry(
     @org.springframework.cloud.context.config.annotation.RefreshScope
     @ConditionalOnMissingBean
     public ThreadPoolBulkheadRegistry threadPoolBulkheadRegistry(
-        ThreadPoolBulkheadConfigurationProperties threadPoolBulkheadConfigurationProperties,
+        CommonThreadPoolBulkheadConfigurationProperties threadPoolBulkheadConfigurationProperties,
         EventConsumerRegistry<BulkheadEvent> bulkheadEventConsumerRegistry,
         RegistryEventConsumer<ThreadPoolBulkhead> threadPoolBulkheadRegistryEventConsumer,
         @Qualifier("compositeThreadPoolBulkheadCustomizer") CompositeCustomizer<ThreadPoolBulkheadConfigCustomizer> compositeThreadPoolBulkheadCustomizer) {

File: resilience4j-spring-cloud2/src/test/java/io/github/resilience4j/bulkhead/autoconfigure/RefreshScopedBulkheadConfigurationTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import io.github.resilience4j.bulkhead.configure.BulkheadConfigurationProperties;
 import io.github.resilience4j.common.CompositeCustomizer;
-import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigurationProperties;
+import io.github.resilience4j.common.bulkhead.configuration.CommonThreadPoolBulkheadConfigurationProperties;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.core.registry.CompositeRegistryEventConsumer;
 import org.junit.Test;
@@ -50,7 +50,7 @@ public void testBulkheadCloudCommonConfig() {
             new CompositeCustomizer<>(Collections.emptyList()))).isNotNull();
 
         assertThat(bulkheadConfig.threadPoolBulkheadRegistry(
-            new ThreadPoolBulkheadConfigurationProperties(), new DefaultEventConsumerRegistry<>(),
+            new CommonThreadPoolBulkheadConfigurationProperties(), new DefaultEventConsumerRegistry<>(),
             new CompositeRegistryEventConsumer<>(emptyList()),
             new CompositeCustomizer<>(Collections.emptyList()))).isNotNull();
     }

File: resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/BulkheadConfiguration.java
Patch:
@@ -23,7 +23,7 @@
 import io.github.resilience4j.bulkhead.event.BulkheadEvent;
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.bulkhead.configuration.BulkheadConfigCustomizer;
-import io.github.resilience4j.common.bulkhead.configuration.BulkheadConfigurationProperties.InstanceProperties;
+import io.github.resilience4j.common.bulkhead.configuration.CommonBulkheadConfigurationProperties.InstanceProperties;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.registry.CompositeRegistryEventConsumer;

File: resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/BulkheadConfigurationProperties.java
Patch:
@@ -18,7 +18,7 @@
 import org.springframework.core.Ordered;
 
 public class BulkheadConfigurationProperties extends
-    io.github.resilience4j.common.bulkhead.configuration.BulkheadConfigurationProperties {
+    io.github.resilience4j.common.bulkhead.configuration.CommonBulkheadConfigurationProperties {
 
     /**
      * As of release 0.16.0 as we set an implicit spring aspect order for bulkhead to cover the

File: resilience4j-spring/src/main/java/io/github/resilience4j/circuitbreaker/configure/CircuitBreakerConfiguration.java
Patch:
@@ -21,7 +21,7 @@
 import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigCustomizer;
-import io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigurationProperties.InstanceProperties;
+import io.github.resilience4j.common.circuitbreaker.configuration.CommonCircuitBreakerConfigurationProperties.InstanceProperties;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.registry.CompositeRegistryEventConsumer;

File: resilience4j-spring/src/main/java/io/github/resilience4j/circuitbreaker/configure/CircuitBreakerConfigurationProperties.java
Patch:
@@ -18,7 +18,7 @@
 import org.springframework.core.Ordered;
 
 public class CircuitBreakerConfigurationProperties extends
-    io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigurationProperties {
+    io.github.resilience4j.common.circuitbreaker.configuration.CommonCircuitBreakerConfigurationProperties {
 
     private int circuitBreakerAspectOrder = Ordered.LOWEST_PRECEDENCE - 3;
 

File: resilience4j-spring/src/main/java/io/github/resilience4j/ratelimiter/configure/RateLimiterConfiguration.java
Patch:
@@ -18,7 +18,7 @@
 
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.ratelimiter.configuration.RateLimiterConfigCustomizer;
-import io.github.resilience4j.common.ratelimiter.configuration.RateLimiterConfigurationProperties.InstanceProperties;
+import io.github.resilience4j.common.ratelimiter.configuration.CommonRateLimiterConfigurationProperties.InstanceProperties;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.registry.CompositeRegistryEventConsumer;

File: resilience4j-spring/src/main/java/io/github/resilience4j/ratelimiter/configure/RateLimiterConfigurationProperties.java
Patch:
@@ -18,7 +18,7 @@
 import org.springframework.core.Ordered;
 
 public class RateLimiterConfigurationProperties extends
-    io.github.resilience4j.common.ratelimiter.configuration.RateLimiterConfigurationProperties {
+    io.github.resilience4j.common.ratelimiter.configuration.CommonRateLimiterConfigurationProperties {
 
     private int rateLimiterAspectOrder = Ordered.LOWEST_PRECEDENCE - 2;
 

File: resilience4j-spring/src/main/java/io/github/resilience4j/retry/configure/RetryConfiguration.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.retry.configuration.RetryConfigCustomizer;
-import io.github.resilience4j.common.retry.configuration.RetryConfigurationProperties.InstanceProperties;
+import io.github.resilience4j.common.retry.configuration.CommonRetryConfigurationProperties.InstanceProperties;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.ContextAwareScheduledThreadPoolExecutor;

File: resilience4j-spring/src/main/java/io/github/resilience4j/retry/configure/RetryConfigurationProperties.java
Patch:
@@ -21,7 +21,7 @@
  * Main spring properties for retry configuration
  */
 public class RetryConfigurationProperties extends
-    io.github.resilience4j.common.retry.configuration.RetryConfigurationProperties {
+    io.github.resilience4j.common.retry.configuration.CommonRetryConfigurationProperties {
 
     private int retryAspectOrder = Ordered.LOWEST_PRECEDENCE - 4;
 

File: resilience4j-spring/src/main/java/io/github/resilience4j/timelimiter/configure/TimeLimiterConfiguration.java
Patch:
@@ -18,7 +18,7 @@
 
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.timelimiter.configuration.TimeLimiterConfigCustomizer;
-import io.github.resilience4j.common.timelimiter.configuration.TimeLimiterConfigurationProperties.InstanceProperties;
+import io.github.resilience4j.common.timelimiter.configuration.CommonTimeLimiterConfigurationProperties.InstanceProperties;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.ContextAwareScheduledThreadPoolExecutor;

File: resilience4j-spring/src/main/java/io/github/resilience4j/timelimiter/configure/TimeLimiterConfigurationProperties.java
Patch:
@@ -20,7 +20,7 @@
 
 @SuppressWarnings("squid:S2176")
 public class TimeLimiterConfigurationProperties extends
-    io.github.resilience4j.common.timelimiter.configuration.TimeLimiterConfigurationProperties {
+    io.github.resilience4j.common.timelimiter.configuration.CommonTimeLimiterConfigurationProperties {
 
     private int timeLimiterAspectOrder = Ordered.LOWEST_PRECEDENCE - 1;
 

File: resilience4j-spring/src/test/java/io/github/resilience4j/TestApplication.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.github.resilience4j.bulkhead.configure.BulkheadConfigurationProperties;
 import io.github.resilience4j.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
-import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigurationProperties;
+import io.github.resilience4j.common.bulkhead.configuration.CommonThreadPoolBulkheadConfigurationProperties;
 import io.github.resilience4j.ratelimiter.configure.RateLimiterConfigurationProperties;
 import io.github.resilience4j.retry.configure.RetryConfigurationProperties;
 import io.github.resilience4j.timelimiter.configure.TimeLimiterConfigurationProperties;
@@ -40,8 +40,8 @@ public BulkheadConfigurationProperties bulkheadConfigurationProperties() {
     }
 
     @Bean
-    public ThreadPoolBulkheadConfigurationProperties threadPoolBulkheadConfigurationProperties() {
-        return new ThreadPoolBulkheadConfigurationProperties();
+    public CommonThreadPoolBulkheadConfigurationProperties threadPoolBulkheadConfigurationProperties() {
+        return new CommonThreadPoolBulkheadConfigurationProperties();
     }
 
     @Bean

File: resilience4j-spring/src/test/java/io/github/resilience4j/bulkhead/configure/BulkheadBuilderCustomizerTest.java
Patch:
@@ -7,7 +7,7 @@
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.bulkhead.configuration.BulkheadConfigCustomizer;
 import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigCustomizer;
-import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigurationProperties;
+import io.github.resilience4j.common.bulkhead.configuration.CommonThreadPoolBulkheadConfigurationProperties;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.ContextPropagator;
@@ -169,7 +169,7 @@ public BeanContextPropagator beanContextPropagator() {
         }
 
         @Bean
-        public ThreadPoolBulkheadConfigurationProperties threadPoolBulkheadConfigurationProperties() {
+        public CommonThreadPoolBulkheadConfigurationProperties threadPoolBulkheadConfigurationProperties() {
             return new ThreadPoolBulkheadConfigurationPropertiesTest();
         }
 
@@ -179,7 +179,7 @@ public BulkheadConfigurationProperties bulkheadConfigurationProperties() {
         }
 
         private class ThreadPoolBulkheadConfigurationPropertiesTest extends
-            ThreadPoolBulkheadConfigurationProperties {
+            CommonThreadPoolBulkheadConfigurationProperties {
 
             ThreadPoolBulkheadConfigurationPropertiesTest() {
                 InstanceProperties properties1 = new InstanceProperties();

File: resilience4j-spring/src/test/java/io/github/resilience4j/circuitbreaker/configure/CircuitBreakerConfigurationTest.java
Patch:
@@ -5,7 +5,7 @@
 import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigCustomizer;
-import io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigurationProperties.InstanceProperties;
+import io.github.resilience4j.common.circuitbreaker.configuration.CommonCircuitBreakerConfigurationProperties.InstanceProperties;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.core.ConfigurationNotFoundException;
 import io.github.resilience4j.core.registry.CompositeRegistryEventConsumer;

File: resilience4j-spring/src/test/java/io/github/resilience4j/retry/configure/RetryConfigurationTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.retry.configuration.RetryConfigCustomizer;
-import io.github.resilience4j.common.retry.configuration.RetryConfigurationProperties.InstanceProperties;
+import io.github.resilience4j.common.retry.configuration.CommonRetryConfigurationProperties.InstanceProperties;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.core.ConfigurationNotFoundException;
 import io.github.resilience4j.core.registry.CompositeRegistryEventConsumer;

File: resilience4j-circularbuffer/src/test/java/io/github/resilience4j/circularbuffer/ConcurrentEvictingQueueGeneralTest.java
Patch:
@@ -231,7 +231,7 @@ public void clear() throws Exception {
     public void toArray() throws Exception {
         Queue<Integer> queue = new ConcurrentEvictingQueue<>(5);
         Object[] objects = queue.toArray();
-        assertThat(objects.length).isZero();
+        assertThat(objects).isEmpty();
 
         queue.add(1);
         assertThat(queue.toArray()).containsExactly(1);
@@ -253,7 +253,7 @@ public void toPreAllocatedArray() throws Exception {
         Queue<Integer> queue = new ConcurrentEvictingQueue<>(5);
 
         Integer[] emptyArray = queue.toArray(new Integer[]{});
-        assertThat(emptyArray.length).isZero();
+        assertThat(emptyArray).isEmpty();
 
         queue.add(1);
         assertThat(queue.toArray()).containsExactly(1);

File: resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/bulkhead/BulkheadInterceptor.java
Patch:
@@ -144,9 +144,7 @@ private CompletionStage<?> handleThreadPoolBulkhead(MethodInvocationContext<Obje
                         return ((CompletableFuture<?>) context.proceed()).get();
                     } catch (ExecutionException e) {
                         throw new CompletionException(e.getCause());
-                    } catch (InterruptedException e) {
-                        throw e;
-                    } catch (CancellationException e) {
+                    } catch (InterruptedException | CancellationException e) {
                         throw e;
                     } catch (Throwable e) {
                         throw new CompletionException(e);

File: resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/BulkheadAspect.java
Patch:
@@ -240,9 +240,7 @@ private Object proceedInThreadPoolBulkhead(ProceedingJoinPoint proceedingJoinPoi
                             .toCompletableFuture().get();
                     } catch (ExecutionException e) {
                         throw new CompletionException(e.getCause());
-                    } catch (InterruptedException e) {
-                        throw e;
-                    } catch (CancellationException e) {
+                    } catch (InterruptedException | CancellationException e) {
                         throw e;
                     } catch (Throwable e) {
                         throw new CompletionException(e);

File: resilience4j-core/src/main/java/io/github/resilience4j/core/EventPublisher.java
Patch:
@@ -1,5 +1,3 @@
-package io.github.resilience4j.core;
-
 /*
  *
  *  Copyright 2017: Robert Winkler
@@ -18,6 +16,9 @@
  *
  *
  */
+
+package io.github.resilience4j.core;
+
 public interface EventPublisher<T> {
 
     void onEvent(EventConsumer<T> onEventConsumer);

File: resilience4j-core/src/main/java/io/github/resilience4j/core/StringUtils.java
Patch:
@@ -22,6 +22,9 @@
 
 public class StringUtils {
 
+    private StringUtils() {
+    }
+
     public static boolean isNotEmpty(@Nullable String string) {
         return string != null && !string.isEmpty();
     }

File: resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/timelimiter/TimeLimiterInterceptor.java
Patch:
@@ -66,7 +66,7 @@ public int getOrder() {
      */
     @Override
     public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {
-        ExecutableMethod executableMethod = context.getExecutableMethod();
+        ExecutableMethod<Object, Object> executableMethod = context.getExecutableMethod();
         final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.micronaut.annotation.TimeLimiter.class, "fallbackMethod").orElse("");
         Class<?> declaringType = context.getDeclaringType();
         return executionHandleLocator.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());
@@ -79,7 +79,7 @@ public Object intercept(MethodInvocationContext<Object, Object> context) {
             return context.proceed();
         }
 
-        ExecutableMethod executableMethod = context.getExecutableMethod();
+        ExecutableMethod<Object, Object> executableMethod = context.getExecutableMethod();
         final String name = executableMethod.stringValue(io.github.resilience4j.micronaut.annotation.TimeLimiter.class).orElse("default");
         TimeLimiter timeLimiter = this.timeLimiterRegistry.timeLimiter(name);
 

File: resilience4j-core/src/main/java/io/github/resilience4j/core/ContextPropagator.java
Patch:
@@ -230,18 +230,18 @@ class EmptyContextPropagator<T> implements ContextPropagator<T> {
 
         @Override
         public Supplier<Optional<T>> retrieve() {
-            return () -> Optional.empty();
+            return Optional::empty;
         }
 
         @Override
         public Consumer<Optional<T>> copy() {
-            return (t) -> {
+            return t -> {
             };
         }
 
         @Override
         public Consumer<Optional<T>> clear() {
-            return (t) -> {
+            return t -> {
             };
         }
     }

File: resilience4j-metrics/src/test/java/io/github/resilience4j/metrics/TimerTest.java
Patch:
@@ -71,7 +71,7 @@ public void shouldDecorateCheckedSupplier() throws Throwable {
         assertThat(timer.getMetrics().getNumberOfTotalCalls()).isEqualTo(1);
         assertThat(timer.getMetrics().getNumberOfSuccessfulCalls()).isEqualTo(1);
         assertThat(timer.getMetrics().getNumberOfFailedCalls()).isZero();
-        assertThat(metricRegistry.getCounters().size()).isEqualTo(2);
+        assertThat(metricRegistry.getCounters()).hasSize(2);
         assertThat(metricRegistry.getTimers().size()).isEqualTo(1);
         assertThat(value).isEqualTo("Hello world");
         then(helloWorldService).should(times(1)).returnHelloWorldWithException();

File: resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/retry/RetryInterceptor.java
Patch:
@@ -23,7 +23,6 @@
 import io.micronaut.aop.InterceptedMethod;
 import io.micronaut.aop.MethodInterceptor;
 import io.micronaut.aop.MethodInvocationContext;
-import io.micronaut.context.BeanContext;
 import io.micronaut.context.ExecutionHandleLocator;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.AnnotationValue;

File: resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/timelimiter/TimeLimiterInterceptor.java
Patch:
@@ -23,7 +23,6 @@
 import io.micronaut.aop.InterceptedMethod;
 import io.micronaut.aop.MethodInterceptor;
 import io.micronaut.aop.MethodInvocationContext;
-import io.micronaut.context.BeanContext;
 import io.micronaut.context.ExecutionHandleLocator;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.AnnotationValue;

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreaker.java
Patch:
@@ -1046,9 +1046,9 @@ interface Metrics {
      */
     final class CircuitBreakerFuture<T> implements Future<T> {
 
-        final private Future<T> future;
-        final private OnceConsumer<CircuitBreaker> onceToCircuitbreaker;
-        final private long start;
+        private final Future<T> future;
+        private final OnceConsumer<CircuitBreaker> onceToCircuitbreaker;
+        private final long start;
 
         CircuitBreakerFuture(CircuitBreaker circuitBreaker, Future<T> future) {
             this(circuitBreaker, future, circuitBreaker.getCurrentTimestamp());

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/utils/CircuitBreakerResultUtils.java
Patch:
@@ -12,6 +12,9 @@
 @SuppressWarnings("unchecked")
 public final class CircuitBreakerResultUtils {
 
+    private CircuitBreakerResultUtils() {
+    }
+
     public static boolean isFailedWith(Either<Object, Throwable> result, Class<? extends Throwable> exceptionClass) {
         return result.isRight() && exceptionClass.isAssignableFrom(result.get().getClass());
     }

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/utils/CircuitBreakerUtil.java
Patch:
@@ -7,6 +7,9 @@
 
 public final class CircuitBreakerUtil {
 
+    private CircuitBreakerUtil() {
+    }
+
     /**
      * Indicates whether Circuit Breaker allows any calls or not.
      *

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/utils/MetricNames.java
Patch:
@@ -2,6 +2,9 @@
 
 public class MetricNames {
 
+    private MetricNames() {
+    }
+
     public static final String DEFAULT_PREFIX = "resilience4j.circuitbreaker";
     public static final String SUCCESSFUL = "successful";
     public static final String FAILED = "failed";

File: resilience4j-circularbuffer/src/test/java/io/github/resilience4j/circularbuffer/CircularFifoBufferTest.java
Patch:
@@ -50,7 +50,7 @@ public void testCircularFifoBuffer() {
 
         List<Exception> bufferedExceptions = exceptionBuffer.toList();
 
-        assertThat(bufferedExceptions.size()).isEqualTo(4);
+        assertThat(bufferedExceptions).hasSize(4);
         assertThat(bufferedExceptions.get(0)).isInstanceOf(IllegalArgumentException.class);
         assertThat(bufferedExceptions.get(1)).isInstanceOf(IOException.class);
         assertThat(bufferedExceptions.get(2)).isInstanceOf(IllegalStateException.class);
@@ -74,6 +74,6 @@ public void testCircularFifoBuffer() {
         assertThat(exceptionBuffer.take().get()).isInstanceOf(IOException.class);
         assertThat(exceptionBuffer.take().get()).isInstanceOf(IOException.class);
         assertThat(exceptionBuffer.take().get()).isInstanceOf(IOException.class);
-        assertThat(exceptionBuffer.take().isEmpty()).isTrue();
+        assertThat(exceptionBuffer.take()).isEmpty();
     }
 }

File: resilience4j-core/src/main/java/io/github/resilience4j/core/ResultUtils.java
Patch:
@@ -24,6 +24,9 @@
 
 public class ResultUtils {
 
+    private ResultUtils() {
+    }
+
     @SuppressWarnings("unchecked")
     public static <T> boolean isSuccessfulAndReturned(
         Either<? extends Throwable, ?> callsResult,

File: resilience4j-core/src/main/java/io/github/resilience4j/core/functions/CheckedFunction.java
Patch:
@@ -29,7 +29,7 @@ public interface CheckedFunction<T, R> {
     R apply(T t) throws Throwable;
 
     default Function<T, R> unchecked() {
-        return (t1) -> {
+        return t1 -> {
             try {
                 return apply(t1);
             } catch(Throwable t) {

File: resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/bulkhead/BulkheadInterceptor.java
Patch:
@@ -139,11 +139,13 @@ private CompletionStage<?> handleThreadPoolBulkhead(MethodInvocationContext<Obje
         InterceptedMethod interceptedMethod = InterceptedMethod.of(context);
         if (interceptedMethod.resultType() == InterceptedMethod.ResultType.COMPLETION_STAGE) {
             try {
-                return this.fallbackForFuture(bulkhead.executeSupplier(() -> {
+                return this.fallbackForFuture(bulkhead.executeCallable(() -> {
                     try {
                         return ((CompletableFuture<?>) context.proceed()).get();
                     } catch (ExecutionException e) {
                         throw new CompletionException(e.getCause());
+                    } catch (InterruptedException e) {
+                        throw e;
                     } catch (CancellationException e) {
                         throw e;
                     } catch (Throwable e) {

File: resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/BulkheadAspect.java
Patch:
@@ -234,12 +234,14 @@ private Object proceedInThreadPoolBulkhead(ProceedingJoinPoint proceedingJoinPoi
             // threadPoolBulkhead.executeSupplier throws a BulkheadFullException, if the Bulkhead is full.
             // The RuntimeException is converted into an exceptionally completed future
             try {
-                return threadPoolBulkhead.executeSupplier(() -> {
+                return threadPoolBulkhead.executeCallable(() -> {
                     try {
                         return ((CompletionStage<?>) proceedingJoinPoint.proceed())
                             .toCompletableFuture().get();
                     } catch (ExecutionException e) {
                         throw new CompletionException(e.getCause());
+                    } catch (InterruptedException e) {
+                        throw e;
                     } catch (CancellationException e) {
                         throw e;
                     } catch (Throwable e) {

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerMetricsTest.java
Patch:
@@ -72,7 +72,7 @@ public void testCircuitBreakerMetrics() {
         assertThat(circuitBreakerMetrics.getNumberOfFailedCalls()).isEqualTo(6);
         assertThat(circuitBreakerMetrics.getNumberOfSuccessfulCalls()).isEqualTo(4);
         assertThat(circuitBreakerMetrics.getFailureRate()).isEqualTo(60);
-        assertThat(Result.hasExceededThresholds(result)).isEqualTo(true);
+        assertThat(Result.hasExceededThresholds(result)).isTrue();
 
         circuitBreakerMetrics.onSuccess(0, TimeUnit.NANOSECONDS);
         circuitBreakerMetrics.onSuccess(0, TimeUnit.NANOSECONDS);

File: resilience4j-core/src/test/java/io/github/resilience4j/core/StringUtilsTest.java
Patch:
@@ -8,16 +8,16 @@ public class StringUtilsTest {
 
     @Test
     public void testString() {
-        assertThat(StringUtils.isNotEmpty("bla")).isEqualTo(true);
+        assertThat(StringUtils.isNotEmpty("bla")).isTrue();
     }
 
     @Test
     public void testEmptyString() {
-        assertThat(StringUtils.isNotEmpty("")).isEqualTo(false);
+        assertThat(StringUtils.isNotEmpty("")).isFalse();
     }
 
     @Test
     public void testNull() {
-        assertThat(StringUtils.isNotEmpty(null)).isEqualTo(false);
+        assertThat(StringUtils.isNotEmpty(null)).isFalse();
     }
 }

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/retry/configuration/RetryConfigurationPropertiesTest.java
Patch:
@@ -75,13 +75,13 @@ public void testRetryProperties() {
             .getInstances().get("backend1");
         assertThat(instancePropertiesForRetry1.getWaitDuration()).isEqualTo(Duration.ofMillis(1000));
         assertThat(retry1).isNotNull();
-        assertThat(retry1.isFailAfterMaxAttempts()).isEqualTo(true);
+        assertThat(retry1.isFailAfterMaxAttempts()).isTrue();
         assertThat(retry1.getMaxAttempts()).isEqualTo(3);
         assertThat(retry2).isNotNull();
         assertThat(retry2.getMaxAttempts()).isEqualTo(2);
         assertThat(retry2.getIntervalFunction().apply(1)).isEqualTo(99L);
         assertThat(retry2.getIntervalFunction().apply(2)).isEqualTo(99L);
-        assertThat(retry2.isFailAfterMaxAttempts()).isEqualTo(false);
+        assertThat(retry2.isFailAfterMaxAttempts()).isFalse();
     }
 
     @Test

File: resilience4j-hedge/src/test/java/io/github/resilience4j/hedge/HedgeConfigTest.java
Patch:
@@ -74,8 +74,8 @@ public void shouldCreateAmountCutoff() {
 
         then(((AverageDurationSupplier) supplier)).isInstanceOf(AverageDurationSupplier.class);
         then(((AverageDurationSupplier) supplier).getFactor()).isEqualTo(200);
-        then(((AverageDurationSupplier) supplier).shouldMeasureErrors()).isEqualTo(false);
-        then(((AverageDurationSupplier) supplier).shouldUseFactorAsPercentage()).isEqualTo(false);
+        then(((AverageDurationSupplier) supplier).shouldMeasureErrors()).isFalse();
+        then(((AverageDurationSupplier) supplier).shouldUseFactorAsPercentage()).isFalse();
     }
 
 //    @Test

File: resilience4j-spring/src/test/java/io/github/resilience4j/timelimiter/configure/TimeLimiterConfigurationTest.java
Patch:
@@ -97,13 +97,13 @@ public void testCreateTimeLimiterRegistryWithSharedConfigs() {
         TimeLimiter timeLimiter1 = timeLimiterRegistry.timeLimiter("backendWithDefaultConfig");
         assertThat(timeLimiter1).isNotNull();
         assertThat(timeLimiter1.getTimeLimiterConfig().getTimeoutDuration()).isEqualTo(Duration.ofSeconds(5));
-        assertThat(timeLimiter1.getTimeLimiterConfig().shouldCancelRunningFuture()).isEqualTo(true);
+        assertThat(timeLimiter1.getTimeLimiterConfig().shouldCancelRunningFuture()).isTrue();
 
         // Should get shared config and overwrite cancelRunningFuture
         TimeLimiter timeLimiter2 = timeLimiterRegistry.timeLimiter("backendWithSharedConfig");
         assertThat(timeLimiter2).isNotNull();
         assertThat(timeLimiter2.getTimeLimiterConfig().getTimeoutDuration()).isEqualTo(Duration.ofSeconds(2));
-        assertThat(timeLimiter2.getTimeLimiterConfig().shouldCancelRunningFuture()).isEqualTo(true);
+        assertThat(timeLimiter2.getTimeLimiterConfig().shouldCancelRunningFuture()).isTrue();
 
         // Unknown backend should get default config of Registry
         TimeLimiter timeLimiter3 = timeLimiterRegistry.timeLimiter("unknownBackend");

File: resilience4j-timelimiter/src/test/java/io/github/resilience4j/timelimiter/TimeLimiterConfigTest.java
Patch:
@@ -63,7 +63,7 @@ public void shouldUseBaseConfigAndOverwriteProperties() {
                 .build();
 
         then(extendedConfig.getTimeoutDuration()).isEqualTo(Duration.ofSeconds(20));
-        then(extendedConfig.shouldCancelRunningFuture()).isEqualTo(false);
+        then(extendedConfig.shouldCancelRunningFuture()).isFalse();
     }
 
 }

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/BulkheadFutureTest.java
Patch:
@@ -156,7 +156,7 @@ public void shouldReturnFailureWithBulkheadFullException() throws Exception {
         Bulkhead bulkhead = Bulkhead.of("test", config);
         bulkhead.tryAcquirePermission();
         bulkhead.tryAcquirePermission();
-        assertThat(bulkhead.getMetrics().getAvailableConcurrentCalls()).isEqualTo(0);
+        assertThat(bulkhead.getMetrics().getAvailableConcurrentCalls()).isZero();
 
         given(future.get()).willReturn("Hello world");
         given(helloWorldService.returnHelloWorldFuture()).willReturn(future);

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/BulkheadRegistryTest.java
Patch:
@@ -99,7 +99,7 @@ public void shouldBeNotTheSameInstance() {
     @Test
     public void noTagsByDefault() {
         Bulkhead retry = registry.bulkhead("testName");
-        assertThat(retry.getTags()).hasSize(0);
+        assertThat(retry.getTags()).isEmpty();
     }
 
     @Test

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/ThreadPoolBulkheadRegistryTest.java
Patch:
@@ -101,7 +101,7 @@ public void shouldBeNotTheSameInstance() {
     @Test
     public void noTagsByDefault() {
         ThreadPoolBulkhead bulkhead = registry.bulkhead("testName");
-        assertThat(bulkhead.getTags()).hasSize(0);
+        assertThat(bulkhead.getTags()).isEmpty();
     }
 
     @Test

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerRegistryTest.java
Patch:
@@ -81,7 +81,7 @@ public void shouldBeNotTheSameCircuitBreaker() {
     public void noTagsByDefault() {
         CircuitBreaker circuitBreaker = CircuitBreakerRegistry.ofDefaults()
             .circuitBreaker("testName");
-        assertThat(circuitBreaker.getTags()).hasSize(0);
+        assertThat(circuitBreaker.getTags()).isEmpty();
     }
 
     @Test

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerExceptionHandlingTest.java
Patch:
@@ -86,7 +86,7 @@ public void shouldIgnoreNumberFormatException() {
         circuitBreaker.onError(0, TimeUnit.NANOSECONDS, new NumberFormatException());
 
         assertThat(circuitBreaker.getMetrics().getNumberOfFailedCalls()).isEqualTo(1);
-        assertThat(circuitBreaker.getMetrics().getNumberOfSuccessfulCalls()).isEqualTo(0);
+        assertThat(circuitBreaker.getMetrics().getNumberOfSuccessfulCalls()).isZero();
         assertThat(circuitBreaker.getMetrics().getNumberOfBufferedCalls()).isEqualTo(1);
     }
 

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerStateMachineTest.java
Patch:
@@ -746,7 +746,7 @@ public void shouldResetClosedState() {
 
         circuitBreaker.reset();
         assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED);
-        assertThat(circuitBreaker.getMetrics().getNumberOfSuccessfulCalls()).isEqualTo(0);
+        assertThat(circuitBreaker.getMetrics().getNumberOfSuccessfulCalls()).isZero();
     }
 
     @Test
@@ -757,7 +757,7 @@ public void shouldResetMetricsAfterMetricsOnlyStateTransition() {
 
         circuitBreaker.transitionToMetricsOnlyState();
         assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.METRICS_ONLY);
-        assertThat(circuitBreaker.getMetrics().getNumberOfSuccessfulCalls()).isEqualTo(0);
+        assertThat(circuitBreaker.getMetrics().getNumberOfSuccessfulCalls()).isZero();
     }
 
     @Test

File: resilience4j-circularbuffer/src/test/java/io/github/resilience4j/circularbuffer/CircularFifoBufferTest.java
Patch:
@@ -33,7 +33,7 @@ public class CircularFifoBufferTest {
     public void testCircularFifoBuffer() {
         CircularFifoBuffer<Exception> exceptionBuffer = new ConcurrentCircularFifoBuffer<>(4);
 
-        assertThat(exceptionBuffer.size()).isEqualTo(0);
+        assertThat(exceptionBuffer.size()).isZero();
         assertThat(exceptionBuffer.isEmpty()).isTrue();
         assertThat(exceptionBuffer.isFull()).isFalse();
         exceptionBuffer.add(new IllegalArgumentException("bla bla"));

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/retry/configuration/RetryConfigurationPropertiesTest.java
Patch:
@@ -221,7 +221,7 @@ public void testCreateRetryPropertiesWithWaitDurationSetToZero() {
         RetryConfig retry = retryConfigurationProperties
             .createRetryConfig("backend", compositeRetryCustomizer());
 
-        assertThat(retry.getIntervalBiFunction().apply(1, null)).isEqualTo(0);
+        assertThat(retry.getIntervalBiFunction().apply(1, null)).isZero();
     }
 
     @Test(expected = IllegalArgumentException.class)

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/retry/monitoring/endpoint/RetryEventDTOFactoryTest.java
Patch:
@@ -47,7 +47,7 @@ public void shouldMapRetryOnIgnoredErrorEvent() {
         RetryEventDTO retryEventDTO = RetryEventDTOFactory.createRetryEventDTO(event);
 
         assertThat(retryEventDTO.getRetryName()).isEqualTo("name");
-        assertThat(retryEventDTO.getNumberOfAttempts()).isEqualTo(0);
+        assertThat(retryEventDTO.getNumberOfAttempts()).isZero();
         assertThat(retryEventDTO.getType()).isEqualTo(RetryEvent.Type.IGNORED_ERROR);
         assertThat(retryEventDTO.getErrorMessage()).isEqualTo("java.io.IOException: Error Message");
         assertThat(retryEventDTO.getCreationTime()).isNotNull();

File: resilience4j-hedge/src/test/java/io/github/resilience4j/hedge/HedgeRegistryTest.java
Patch:
@@ -76,7 +76,7 @@ public void shouldInitRegistryTags() {
     public void noTagsByDefault() {
         Hedge Hedge = HedgeRegistry.builder().build()
             .hedge("testName");
-        assertThat(Hedge.getTags()).hasSize(0);
+        assertThat(Hedge.getTags()).isEmpty();
     }
 
     @Test

File: resilience4j-metrics/src/test/java/io/github/resilience4j/metrics/publisher/CircuitBreakerMetricsPublisherTest.java
Patch:
@@ -59,6 +59,6 @@ public void shouldRemoveAllMetrics() {
         assertThat(metricRegistry.getMetrics()).hasSize(10);
 
         circuitBreakerRegistry.remove(circuitBreaker.getName());
-        assertThat(metricRegistry.getMetrics()).hasSize(0);
+        assertThat(metricRegistry.getMetrics()).isEmpty();
     }
 }
\ No newline at end of file

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedTimeLimiterMetricsPublisherTest.java
Patch:
@@ -99,14 +99,14 @@ public void shouldRemovedMetricsForRemovedRetry() {
     public void shouldReplaceMetrics() {
         Counter before = meterRegistry.get(DEFAULT_TIME_LIMITER_CALLS).counter();
         assertThat(before).isNotNull();
-        assertThat(before.count()).isEqualTo(0);
+        assertThat(before.count()).isZero();
         assertThat(before.getId().getTag(TagNames.NAME)).isEqualTo(timeLimiter.getName());
 
         timeLimiterRegistry.replace(timeLimiter.getName(), TimeLimiter.ofDefaults());
 
         Counter after = meterRegistry.get(DEFAULT_TIME_LIMITER_CALLS).counter();
         assertThat(after).isNotNull();
-        assertThat(after.count()).isEqualTo(0);
+        assertThat(after.count()).isZero();
         assertThat(after.getId().getTag(TagNames.NAME))
             .isEqualTo(TimeLimiter.ofDefaults().getName());
     }

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedTimeLimiterMetricsTest.java
Patch:
@@ -87,14 +87,14 @@ public void shouldRemovedMetricsForRemovedRetry() {
     public void shouldReplaceMetrics() {
         Counter before = meterRegistry.get(DEFAULT_TIME_LIMITER_CALLS).counter();
         assertThat(before).isNotNull();
-        assertThat(before.count()).isEqualTo(0);
+        assertThat(before.count()).isZero();
         assertThat(before.getId().getTag(TagNames.NAME)).isEqualTo(timeLimiter.getName());
 
         timeLimiterRegistry.replace(timeLimiter.getName(), TimeLimiter.ofDefaults());
 
         Counter after = meterRegistry.get(DEFAULT_TIME_LIMITER_CALLS).counter();
         assertThat(after).isNotNull();
-        assertThat(after.count()).isEqualTo(0);
+        assertThat(after.count()).isZero();
         assertThat(after.getId().getTag(TagNames.NAME))
             .isEqualTo(TimeLimiter.ofDefaults().getName());
     }

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterRegistryTest.java
Patch:
@@ -139,7 +139,7 @@ public void testWithNotExistingConfig() {
     @Test
     public void noTagsByDefault() {
         RateLimiter rateLimiter = RateLimiterRegistry.ofDefaults().rateLimiter("testName");
-        assertThat(rateLimiter.getTags()).hasSize(0);
+        assertThat(rateLimiter.getTags()).isEmpty();
     }
 
     @Test

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/RateLimitersImplementationTest.java
Patch:
@@ -111,7 +111,7 @@ public void drainCycleWhichAlreadyHashNoPremitsLeftTest() {
         limiter.drainPermissions();
         Object event = eventAfterDrainCatcher.get();
         then(event).isInstanceOf(RateLimiterOnDrainedEvent.class);
-        then(((RateLimiterOnDrainedEvent) event).getNumberOfPermits()).isEqualTo(0);
+        then(((RateLimiterOnDrainedEvent) event).getNumberOfPermits()).isZero();
     }
 
     protected void waitForRefresh(RateLimiter.Metrics metrics, RateLimiterConfig config,

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/SemaphoreBasedRateLimiterImplTest.java
Patch:
@@ -141,7 +141,7 @@ public void acquirePermissionAndMetrics() throws Exception {
             .until(detailedMetrics::getAvailablePermissions, equalTo(0));
         awaitImpatiently()
             .atMost(2, TimeUnit.SECONDS).until(thread::getState, equalTo(TIMED_WAITING));
-        then(detailedMetrics.getAvailablePermissions()).isEqualTo(0);
+        then(detailedMetrics.getAvailablePermissions()).isZero();
 
         limit.refreshLimit();
         awaitImpatiently()
@@ -234,7 +234,7 @@ public void getMetrics() {
         ScheduledExecutorService scheduler = mock(ScheduledExecutorService.class);
         SemaphoreBasedRateLimiter limit = new SemaphoreBasedRateLimiter("test", config, scheduler);
         RateLimiter.Metrics metrics = limit.getMetrics();
-        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);
+        then(metrics.getNumberOfWaitingThreads()).isZero();
     }
 
     @Test
@@ -259,7 +259,7 @@ public void getDetailedMetrics() {
         ScheduledExecutorService scheduler = mock(ScheduledExecutorService.class);
         SemaphoreBasedRateLimiter limit = new SemaphoreBasedRateLimiter("test", config, scheduler);
         RateLimiter.Metrics metrics = limit.getMetrics();
-        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);
+        then(metrics.getNumberOfWaitingThreads()).isZero();
         then(metrics.getAvailablePermissions()).isEqualTo(2);
     }
 

File: resilience4j-retry/src/test/java/io/github/resilience4j/retry/RetryConfigBuilderTest.java
Patch:
@@ -40,7 +40,7 @@ public void zeroMaxAttemptsShouldFail() {
     @Test
     public void zeroWaitInterval() {
         final RetryConfig config = RetryConfig.custom().waitDuration(Duration.ofMillis(0)).build();
-        assertThat(config.getIntervalBiFunction().apply(1, null)).isEqualTo(0);
+        assertThat(config.getIntervalBiFunction().apply(1, null)).isZero();
     }
 
     @Test
@@ -195,7 +195,7 @@ public void shouldUseBothRecordToBuildPredicate() {
 
     @Test()
     public void shouldBuilderCreateConfigEveryTime() {
-        final RetryConfig.Builder builder = RetryConfig.custom();
+        final RetryConfig.Builder<Object> builder = RetryConfig.custom();
         builder.maxAttempts(5);
         final RetryConfig config1 = builder.build();
         builder.maxAttempts(3);

File: resilience4j-retry/src/test/java/io/github/resilience4j/retry/RetryRegistryTest.java
Patch:
@@ -88,7 +88,7 @@ public void shouldBeNotTheSameRetry() {
     @Test
     public void noTagsByDefault() {
         Retry retry = retryRegistry.retry("testName");
-        assertThat(retry.getTags()).hasSize(0);
+        assertThat(retry.getTags()).isEmpty();
     }
 
     @Test

File: resilience4j-retry/src/test/java/io/github/resilience4j/retry/event/RetryEventTest.java
Patch:
@@ -73,7 +73,7 @@ public void testRetryOnIgnoredErrorEvent() {
         RetryOnIgnoredErrorEvent retryOnIgnoredErrorEvent = new RetryOnIgnoredErrorEvent("test",
             new IOException("Bla"));
         assertThat(retryOnIgnoredErrorEvent.getName()).isEqualTo("test");
-        assertThat(retryOnIgnoredErrorEvent.getNumberOfRetryAttempts()).isEqualTo(0);
+        assertThat(retryOnIgnoredErrorEvent.getNumberOfRetryAttempts()).isZero();
         assertThat(retryOnIgnoredErrorEvent.getEventType()).isEqualTo(Type.IGNORED_ERROR);
         assertThat(retryOnIgnoredErrorEvent.getLastThrowable()).isInstanceOf(IOException.class);
         assertThat(retryOnIgnoredErrorEvent.toString()).contains(

File: resilience4j-retry/src/test/java/io/github/resilience4j/retry/internal/EventPublisherTest.java
Patch:
@@ -107,7 +107,7 @@ public void shouldIgnoreError() {
 
         then(helloWorldService).should().sayHelloWorld();
         assertThat(result.isFailure()).isTrue();
-        assertThat(sleptTime).isEqualTo(0);
+        assertThat(sleptTime).isZero();
         testSubscriber.assertValueCount(1).assertValues(RetryEvent.Type.IGNORED_ERROR);
     }
 }

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterAutoConfigurationTest.java
Patch:
@@ -96,7 +96,7 @@ public void testFeignClient() {
         rateLimiterDummyFeignClient.doSomething(EMPTY);
 
         assertThat(rateLimiter.getMetrics().getAvailablePermissions()).isEqualTo(8);
-        assertThat(rateLimiter.getMetrics().getNumberOfWaitingThreads()).isEqualTo(0);
+        assertThat(rateLimiter.getMetrics().getNumberOfWaitingThreads()).isZero();
 
         assertThat(rateLimiter.getRateLimiterConfig().getLimitForPeriod()).isEqualTo(10);
         assertThat(rateLimiter.getRateLimiterConfig().getLimitRefreshPeriod())
@@ -161,7 +161,7 @@ public void testRateLimiterAutoConfiguration() throws IOException {
         dummyService.doSomething(false);
 
         assertThat(rateLimiter.getMetrics().getAvailablePermissions()).isEqualTo(8);
-        assertThat(rateLimiter.getMetrics().getNumberOfWaitingThreads()).isEqualTo(0);
+        assertThat(rateLimiter.getMetrics().getNumberOfWaitingThreads()).isZero();
 
         assertThat(rateLimiter.getRateLimiterConfig().getLimitForPeriod()).isEqualTo(10);
         assertThat(rateLimiter.getRateLimiterConfig().getLimitRefreshPeriod())

File: resilience4j-spring/src/test/java/io/github/resilience4j/bulkhead/configure/BulkheadBuilderCustomizerTest.java
Patch:
@@ -88,7 +88,7 @@ public void testThreadPoolBulkheadCustomizer() {
         assertThat(bulkheadC).isNotNull();
         assertThat(bulkheadC.getBulkheadConfig().getCoreThreadPoolSize()).isEqualTo(2);
         assertThat(bulkheadC.getBulkheadConfig().getMaxThreadPoolSize()).isEqualTo(4);
-        assertThat(bulkheadC.getBulkheadConfig().getContextPropagator()).hasSize(0);
+        assertThat(bulkheadC.getBulkheadConfig().getContextPropagator()).isEmpty();
 
         //This test context propagator bean set to config using Customizer interface via SpringContext
         ThreadPoolBulkhead bulkheadD = threadPoolBulkheadRegistry.bulkhead("bulkheadD", "backendD");

File: resilience4j-timelimiter/src/test/java/io/github/resilience4j/timelimiter/TimeLimiterRegistryTest.java
Patch:
@@ -54,7 +54,7 @@ public void shouldInitRegistryTags() {
     public void noTagsByDefault() {
         TimeLimiter TimeLimiter = TimeLimiterRegistry.ofDefaults()
             .timeLimiter("testName");
-        assertThat(TimeLimiter.getTags()).hasSize(0);
+        assertThat(TimeLimiter.getTags()).isEmpty();
     }
 
     @Test

File: resilience4j-vavr/src/test/java/io/github/resilience4j/metrics/VavrTimerTest.java
Patch:
@@ -55,7 +55,7 @@ public void shouldDecorateCheckedSupplier() throws Throwable {
 
         assertThat(timer.getMetrics().getNumberOfTotalCalls()).isEqualTo(1);
         assertThat(timer.getMetrics().getNumberOfSuccessfulCalls()).isEqualTo(1);
-        assertThat(timer.getMetrics().getNumberOfFailedCalls()).isEqualTo(0);
+        assertThat(timer.getMetrics().getNumberOfFailedCalls()).isZero();
         assertThat(metricRegistry.getCounters().size()).isEqualTo(2);
         assertThat(metricRegistry.getTimers().size()).isEqualTo(1);
         assertThat(value).isEqualTo("Hello world");
@@ -71,7 +71,7 @@ public void shouldDecorateCheckedRunnableAndReturnWithSuccess() throws Throwable
 
         assertThat(timer.getMetrics().getNumberOfTotalCalls()).isEqualTo(1);
         assertThat(timer.getMetrics().getNumberOfSuccessfulCalls()).isEqualTo(1);
-        assertThat(timer.getMetrics().getNumberOfFailedCalls()).isEqualTo(0);
+        assertThat(timer.getMetrics().getNumberOfFailedCalls()).isZero();
         then(helloWorldService).should().sayHelloWorldWithException();
     }
 
@@ -87,7 +87,7 @@ public void shouldDecorateCheckedFunctionAndReturnWithSuccess() throws Throwable
         assertThat(result).isEqualTo("Hello world Tom");
         assertThat(timer.getMetrics().getNumberOfTotalCalls()).isEqualTo(1);
         assertThat(timer.getMetrics().getNumberOfSuccessfulCalls()).isEqualTo(1);
-        assertThat(timer.getMetrics().getNumberOfFailedCalls()).isEqualTo(0);
+        assertThat(timer.getMetrics().getNumberOfFailedCalls()).isZero();
         then(helloWorldService).should().returnHelloWorldWithNameWithException("Tom");
     }
 }

File: resilience4j-vavr/src/test/java/io/github/resilience4j/retry/SupplierVavrRetryTest.java
Patch:
@@ -101,7 +101,7 @@ public void shouldReturnAfterOneAttempt() {
         then(helloWorldService).should().returnHelloWorld();
         assertThat(result.isFailure()).isTrue();
         assertThat(result.failed().get()).isInstanceOf(HelloWorldException.class);
-        assertThat(sleptTime).isEqualTo(0);
+        assertThat(sleptTime).isZero();
     }
 
     @Test
@@ -122,7 +122,7 @@ public void shouldReturnAfterOneAttemptAndIgnoreException() {
         then(helloWorldService).should().returnHelloWorld();
         assertThat(result.isFailure()).isTrue();
         assertThat(result.failed().get()).isInstanceOf(HelloWorldException.class);
-        assertThat(sleptTime).isEqualTo(0);
+        assertThat(sleptTime).isZero();
     }
 
     @Test

File: resilience4j-vavr/src/test/java/io/github/resilience4j/retry/VavrRetryTest.java
Patch:
@@ -76,7 +76,7 @@ public void shouldReturnAfterOneAttempt() {
         then(helloWorldService).should().sayHelloWorld();
         assertThat(result.isFailure()).isTrue();
         assertThat(result.failed().get()).isInstanceOf(HelloWorldException.class);
-        assertThat(sleptTime).isEqualTo(0);
+        assertThat(sleptTime).isZero();
     }
 
     @Test
@@ -97,7 +97,7 @@ public void shouldReturnAfterOneAttemptAndIgnoreException() {
         then(helloWorldService).should().sayHelloWorld();
         assertThat(result.isFailure()).isTrue();
         assertThat(result.failed().get()).isInstanceOf(HelloWorldException.class);
-        assertThat(sleptTime).isEqualTo(0);
+        assertThat(sleptTime).isZero();
     }
 
     @Test

File: resilience4j-cache/src/main/java/io/github/resilience4j/cache/CacheRegistryStore.java
Patch:
@@ -56,7 +56,7 @@ public Collection<E> values() {
         return values;
     }
 
-    static class AtomicComputeProcessor<String, E> implements EntryProcessor<String, E, E> {
+    static class AtomicComputeProcessor<E> implements EntryProcessor<String, E, E> {
 
         @Override
         public E process(MutableEntry<String, E> entry, Object... arguments) throws EntryProcessorException {

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/utils/CircuitBreakerResultUtils.java
Patch:
@@ -17,7 +17,7 @@ public static boolean isFailedWith(Either<Object, Throwable> result, Class<? ext
     }
 
     public static <T extends Throwable> TransitionCheckThrowableBuilder<T> ifFailedWith(Class<T> exceptionClass) {
-        return new TransitionCheckThrowableBuilder(exceptionClass);
+        return new TransitionCheckThrowableBuilder<>(exceptionClass);
     }
 
     public static class TransitionCheckThrowableBuilder<T extends Throwable> {

File: resilience4j-core/src/main/java/io/github/resilience4j/core/ResultUtils.java
Patch:
@@ -24,6 +24,7 @@
 
 public class ResultUtils {
 
+    @SuppressWarnings("unchecked")
     public static <T> boolean isSuccessfulAndReturned(
         Either<? extends Throwable, ?> callsResult,
         Class<T> expectedClass,
@@ -47,6 +48,7 @@ public static <T extends Throwable>  boolean isFailedAndThrown(
         return isFailedAndThrown(callsResult, expectedClass, thrown -> true);
     }
 
+    @SuppressWarnings("unchecked")
     public static <T extends Throwable>  boolean isFailedAndThrown(
         Either<? extends Throwable, ?> callsResult,
         Class<T> expectedClass,

File: resilience4j-core/src/main/java/io/github/resilience4j/core/functions/CheckedFunction.java
Patch:
@@ -38,6 +38,7 @@ default Function<T, R> unchecked() {
         };
     }
 
+    @SuppressWarnings("unchecked")
     static <T extends Throwable, R> R sneakyThrow(Throwable t) throws T {
         throw (T) t;
     }

File: resilience4j-core/src/main/java/io/github/resilience4j/core/functions/CheckedRunnable.java
Patch:
@@ -36,6 +36,7 @@ default Runnable unchecked() {
         };
     }
 
+    @SuppressWarnings("unchecked")
     static <T extends Throwable, R> R sneakyThrow(Throwable t) throws T {
         throw (T) t;
     }

File: resilience4j-core/src/main/java/io/github/resilience4j/core/functions/CheckedSupplier.java
Patch:
@@ -43,6 +43,7 @@ default Supplier<T> unchecked() {
         };
     }
 
+    @SuppressWarnings("unchecked")
     static <T extends Throwable, R> R sneakyThrow(Throwable t) throws T {
         throw (T) t;
     }

File: resilience4j-core/src/main/java/io/github/resilience4j/core/metrics/AbstractAggregation.java
Patch:
@@ -45,6 +45,9 @@ void record(long duration, TimeUnit durationUnit, Metrics.Outcome outcome) {
             case ERROR:
                 numberOfFailedCalls++;
                 break;
+
+            default:
+                break;
         }
     }
 }

File: resilience4j-core/src/test/java/io/github/resilience4j/core/TestContextPropagators.java
Patch:
@@ -62,6 +62,7 @@ public Consumer<Optional<String>> clear() {
         }
     }
 
+    @SuppressWarnings("unchecked")
     public static class TestThreadLocalContextPropagatorWithHolder<T> implements ContextPropagator<T> {
 
         @Override

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/circuitbreaker/configuration/CircuitBreakerConfigurationPropertiesTest.java
Patch:
@@ -394,6 +394,7 @@ public void testRecordExceptionWithBaseConfig() {
     }
 
     @Test
+    @SuppressWarnings("unchecked")
     public void testIgnoreExceptionWithBaseConfig() {
         CircuitBreakerConfigurationProperties.InstanceProperties defaultConfig = new CircuitBreakerConfigurationProperties.InstanceProperties();
 

File: resilience4j-hedge/src/main/java/io/github/resilience4j/hedge/internal/AverageDurationSupplier.java
Patch:
@@ -79,6 +79,8 @@ public void accept(HedgeEvent.Type type, Duration duration) {
                     metrics.record(duration.toNanos(), TimeUnit.NANOSECONDS, Metrics.Outcome.ERROR);
                 }
                 break;
+            default:
+                break;
         }
     }
 

File: resilience4j-metrics/src/test/java/io/github/resilience4j/metrics/StateTransitionMetricsTest.java
Patch:
@@ -37,6 +37,7 @@
 
 public class StateTransitionMetricsTest {
 
+    @SuppressWarnings("rawtypes")
     private static void circuitBreakerMetricsUsesFirstStateObjectInstance(
         CircuitBreaker circuitBreaker, MetricRegistry metricRegistry) throws Exception {
         SortedMap<String, Gauge> gauges = metricRegistry.getGauges();

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/retry/configuration/RetryConfigurationProperties.java
Patch:
@@ -41,7 +41,6 @@ public class RetryConfigurationProperties extends CommonProperties {
     private static final String DEFAULT = "default";
     private final Map<String, InstanceProperties> instances = new HashMap<>();
     private Map<String, InstanceProperties> configs = new HashMap<>();
-    private Duration waitDuration;
 
     /**
      * @param backend backend name

File: resilience4j-core/src/main/java/io/github/resilience4j/core/IntervalFunction.java
Patch:
@@ -34,7 +34,7 @@ static IntervalFunction of(long intervalMillis, Function<Long, Long> backoffFunc
 
         return (attempt) -> {
             checkAttempt(attempt);
-            return LongStream.iterate(intervalMillis, n -> backoffFunction.apply(n)).skip(attempt - 1).findFirst().getAsLong();
+            return LongStream.iterate(intervalMillis, n -> backoffFunction.apply(n)).skip(attempt - 1L).findFirst().getAsLong();
         };
     }
 

File: resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/bulkhead/BulkheadInterceptor.java
Patch:
@@ -33,6 +33,7 @@
 
 import javax.inject.Singleton;
 import java.util.Optional;
+import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.CompletionStage;
@@ -143,6 +144,8 @@ private CompletionStage<?> handleThreadPoolBulkhead(MethodInvocationContext<Obje
                         return ((CompletableFuture<?>) context.proceed()).get();
                     } catch (ExecutionException e) {
                         throw new CompletionException(e.getCause());
+                    } catch (CancellationException e) {
+                        throw e;
                     } catch (Throwable e) {
                         throw new CompletionException(e);
                     }

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedRateLimiterMetricsTest.java
Patch:
@@ -73,6 +73,7 @@ public void shouldAddMetricsForANewlyCreatedRateLimiter() {
 
     @Test
     public void shouldAddCustomTags() {
+        RateLimiter newRateLimiter = rateLimiterRegistry.rateLimiter("backendF", Map.of("key1", "value1"));
         assertThat(taggedRateLimiterMetrics.meterIdMap).containsKeys("backendA", "backendF");
         assertThat(taggedRateLimiterMetrics.meterIdMap.get("backendA")).hasSize(2);
         assertThat(taggedRateLimiterMetrics.meterIdMap.get("backendF")).hasSize(2);

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/BulkheadFutureTest.java
Patch:
@@ -23,8 +23,9 @@ public class BulkheadFutureTest {
     private BulkheadConfig config;
 
     @Before
+    @SuppressWarnings("unchecked") 
     public void setUp() {
-        helloWorldService = mock(HelloWorldService.class);
+        helloWorldService = mock(HelloWorldService.class);        
         future = mock(Future.class);
         config = BulkheadConfig.custom()
                 .maxConcurrentCalls(1)

File: resilience4j-core/src/test/java/io/github/resilience4j/core/IntervalFunctionTest.java
Patch:
@@ -19,7 +19,7 @@ public void shouldRejectNonPositiveDuration() {
         final long zeroInterval = 0;
         final long positiveInterval = 100;
 
-        List<Try> tries = List.of(
+        List<Try<IntervalFunction>> tries = List.of(
             Try.of(() -> IntervalFunction.of(negativeDuration)),
             Try.of(() -> IntervalFunction.of(zeroDuration)),
 

File: resilience4j-bulkhead/src/jmh/java/io/github/resilience4j/bulkhead/BulkheadBenchmark.java
Patch:
@@ -18,7 +18,7 @@
  */
 package io.github.resilience4j.bulkhead;
 
-import io.github.resilience4j.adapter.RxJava2Adapter;
+import io.github.resilience4j.test.RxJava2Adapter;
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
 import org.openjdk.jmh.profile.GCProfiler;

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/internal/SemaphoreBulkheadTest.java
Patch:
@@ -18,7 +18,7 @@
  */
 package io.github.resilience4j.bulkhead.internal;
 
-import io.github.resilience4j.adapter.RxJava2Adapter;
+import io.github.resilience4j.test.RxJava2Adapter;
 import io.github.resilience4j.bulkhead.Bulkhead;
 import io.github.resilience4j.bulkhead.BulkheadConfig;
 import io.github.resilience4j.bulkhead.event.BulkheadEvent;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/circuitbreaker/operator/BaseCircuitBreakerTest.java
Patch:
@@ -10,7 +10,7 @@
 /**
  * Helper class to test and assert circuit breakers.
  */
-abstract class BaseCircuitBreakerTest {
+public abstract class BaseCircuitBreakerTest {
 
     CircuitBreaker circuitBreaker;
     HelloWorldService helloWorldService;

File: resilience4j-rxjava3/src/test/java/io/github/resilience4j/rxjava3/circuitbreaker/operator/BaseCircuitBreakerTest.java
Patch:
@@ -10,7 +10,7 @@
 /**
  * Helper class to test and assert circuit breakers.
  */
-abstract class BaseCircuitBreakerTest {
+public abstract class BaseCircuitBreakerTest {
 
     CircuitBreaker circuitBreaker;
     HelloWorldService helloWorldService;

File: resilience4j-retry/src/test/java/io/github/resilience4j/retry/internal/EventPublisherTest.java
Patch:
@@ -31,7 +31,7 @@
 
 import java.io.IOException;
 
-import static io.github.resilience4j.adapter.RxJava2Adapter.toFlowable;
+import static io.github.resilience4j.test.RxJava2Adapter.toFlowable;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.BDDMockito.then;
 import static org.mockito.BDDMockito.willThrow;

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/timelimiter/TimeLimiterOperatorTest.java
Patch:
@@ -53,7 +53,7 @@ public void doNotTimeoutUsingMono() {
         StepVerifier.create(mono)
             .expectNextCount(1)
             .verifyComplete();
-        then(timeLimiter).should(times(2))
+        then(timeLimiter).should(times(1))
             .onSuccess();
     }
 

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/timelimiter/TimeLimiterOperator.java
Patch:
@@ -61,7 +61,6 @@ public Publisher<T> apply(Publisher<T> publisher) {
 
     private Publisher<T> withTimeout(Mono<T> upstream) {
         return upstream.timeout(getTimeout())
-            .doOnNext(t -> timeLimiter.onSuccess())
             .doOnSuccess(t -> timeLimiter.onSuccess())
             .doOnError(timeLimiter::onError);
     }

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/bulkhead/autoconfigure/BulkheadMetricsAutoConfiguration.java
Patch:
@@ -20,8 +20,6 @@
 import io.github.resilience4j.micrometer.tagged.TaggedBulkheadMetrics;
 import io.github.resilience4j.micrometer.tagged.TaggedBulkheadMetricsPublisher;
 import io.micrometer.core.instrument.MeterRegistry;
-import org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration;
-import org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleMetricsExportAutoConfiguration;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
@@ -36,7 +34,8 @@
  */
 @Configuration
 @ConditionalOnClass({MeterRegistry.class, Bulkhead.class, TaggedBulkheadMetricsPublisher.class})
-@AutoConfigureAfter({MetricsAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class})
+@AutoConfigureAfter(name = { "org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration",
+	"org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleMetricsExportAutoConfiguration" })
 @ConditionalOnProperty(value = "resilience4j.bulkhead.metrics.enabled", matchIfMissing = true)
 public class BulkheadMetricsAutoConfiguration {
 

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/bulkhead/autoconfigure/ThreadPoolBulkheadMetricsAutoConfiguration.java
Patch:
@@ -21,8 +21,6 @@
 import io.github.resilience4j.micrometer.tagged.TaggedThreadPoolBulkheadMetrics;
 import io.github.resilience4j.micrometer.tagged.TaggedThreadPoolBulkheadMetricsPublisher;
 import io.micrometer.core.instrument.MeterRegistry;
-import org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration;
-import org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleMetricsExportAutoConfiguration;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
@@ -34,7 +32,8 @@
 @Configuration
 @ConditionalOnClass({MeterRegistry.class, ThreadPoolBulkhead.class,
         TaggedThreadPoolBulkheadMetricsPublisher.class})
-@AutoConfigureAfter({MetricsAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class})
+@AutoConfigureAfter(name = { "org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration",
+	"org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleMetricsExportAutoConfiguration" })
 @ConditionalOnProperty(value = "resilience4j.thread-pool-bulkhead.metrics.enabled", matchIfMissing = true)
 public class ThreadPoolBulkheadMetricsAutoConfiguration {
 

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerMetricsAutoConfiguration.java
Patch:
@@ -20,8 +20,6 @@
 import io.github.resilience4j.micrometer.tagged.TaggedCircuitBreakerMetrics;
 import io.github.resilience4j.micrometer.tagged.TaggedCircuitBreakerMetricsPublisher;
 import io.micrometer.core.instrument.MeterRegistry;
-import org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration;
-import org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleMetricsExportAutoConfiguration;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
@@ -37,7 +35,8 @@
 @Configuration
 @ConditionalOnClass({MeterRegistry.class, CircuitBreaker.class,
     TaggedCircuitBreakerMetricsPublisher.class})
-@AutoConfigureAfter({MetricsAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class})
+@AutoConfigureAfter(name = { "org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration",
+    "org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleMetricsExportAutoConfiguration" })
 @ConditionalOnProperty(value = "resilience4j.circuitbreaker.metrics.enabled", matchIfMissing = true)
 public class CircuitBreakerMetricsAutoConfiguration {
 

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterMetricsAutoConfiguration.java
Patch:
@@ -20,8 +20,6 @@
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
 import io.micrometer.core.instrument.MeterRegistry;
-import org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration;
-import org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleMetricsExportAutoConfiguration;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
@@ -37,7 +35,8 @@
 @Configuration
 @ConditionalOnClass({MeterRegistry.class, RateLimiter.class,
     TaggedRateLimiterMetricsPublisher.class})
-@AutoConfigureAfter({MetricsAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class})
+@AutoConfigureAfter(name = { "org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration",
+    "org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleMetricsExportAutoConfiguration" })
 @ConditionalOnProperty(value = "resilience4j.ratelimiter.metrics.enabled", matchIfMissing = true)
 public class RateLimiterMetricsAutoConfiguration {
 

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/retry/autoconfigure/RetryMetricsAutoConfiguration.java
Patch:
@@ -20,8 +20,6 @@
 import io.github.resilience4j.retry.Retry;
 import io.github.resilience4j.retry.RetryRegistry;
 import io.micrometer.core.instrument.MeterRegistry;
-import org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration;
-import org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleMetricsExportAutoConfiguration;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
@@ -36,7 +34,8 @@
  */
 @Configuration
 @ConditionalOnClass({MeterRegistry.class, Retry.class, TaggedRetryMetricsPublisher.class})
-@AutoConfigureAfter({MetricsAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class})
+@AutoConfigureAfter(name = { "org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration",
+	"org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleMetricsExportAutoConfiguration" })
 @ConditionalOnProperty(value = "resilience4j.retry.metrics.enabled", matchIfMissing = true)
 public class RetryMetricsAutoConfiguration {
 

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/timelimiter/autoconfigure/TimeLimiterMetricsAutoConfiguration.java
Patch:
@@ -21,8 +21,6 @@
 import io.github.resilience4j.timelimiter.TimeLimiter;
 import io.github.resilience4j.timelimiter.TimeLimiterRegistry;
 import io.micrometer.core.instrument.MeterRegistry;
-import org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration;
-import org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleMetricsExportAutoConfiguration;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
@@ -33,7 +31,8 @@
 
 @Configuration
 @ConditionalOnClass({MeterRegistry.class, TimeLimiter.class, TaggedTimeLimiterMetricsPublisher.class})
-@AutoConfigureAfter({MetricsAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class})
+@AutoConfigureAfter(name = { "org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration",
+	"org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleMetricsExportAutoConfiguration" })
 @ConditionalOnProperty(value = "resilience4j.timelimiter.metrics.enabled", matchIfMissing = true)
 public class TimeLimiterMetricsAutoConfiguration {
 

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/bulkhead/BulkheadAutoConfigurationTest.java
Patch:
@@ -313,7 +313,7 @@ public void testBulkheadAutoConfiguration() {
             .atMost(1, TimeUnit.SECONDS)
             .until(() -> bulkhead.getMetrics().getAvailableConcurrentCalls() == 0);
 
-        assertThat(bulkhead.getBulkheadConfig().getMaxWaitDuration().toMillis()).isEqualTo(0);
+        assertThat(bulkhead.getBulkheadConfig().getMaxWaitDuration().toMillis()).isEqualTo(10);
         assertThat(bulkhead.getBulkheadConfig().getMaxConcurrentCalls()).isEqualTo(1);
 
         await()

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/retry/configuration/RetryConfigurationProperties.java
Patch:
@@ -170,7 +170,7 @@ private RetryConfig buildRetryConfig(RetryConfig.Builder builder,
      */
     private void configureRetryIntervalFunction(InstanceProperties properties, RetryConfig.Builder<Object> builder) {
         // these take precedence over deprecated properties. Setting one or the other will still work.
-        if (properties.getWaitDuration() != null && properties.getWaitDuration().toMillis() > 0) {
+        if (properties.getWaitDuration() != null && properties.getWaitDuration().toMillis() >= 0) {
             if (Boolean.TRUE.equals(properties.getEnableExponentialBackoff()) &&
                 Boolean.TRUE.equals(properties.getEnableRandomizedWait())) {
                 configureExponentialBackoffAndRandomizedWait(properties, builder);

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/service/test/bulkhead/BulkheadDummyService.java
Patch:
@@ -7,6 +7,7 @@ public interface BulkheadDummyService {
     String BACKEND = "backendA";
     String BACKEND_C = "backendC";
     String BACKEND_D = "backendD";
+    String BACKEND_E = "backendE";
 
     void doSomething();
 

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/service/test/bulkhead/BulkheadDummyServiceImpl.java
Patch:
@@ -30,7 +30,7 @@ public CompletableFuture<String> doSomethingAsync() throws InterruptedException
     }
 
     @Override
-    @Bulkhead(name = BulkheadDummyService.BACKEND_D, type = Bulkhead.Type.THREADPOOL)
+    @Bulkhead(name = BulkheadDummyService.BACKEND_E, type = Bulkhead.Type.THREADPOOL)
     public CompletableFuture<Object> doSomethingAsyncWithThreadLocal() throws InterruptedException {
         return CompletableFuture.completedFuture(
             TestThreadLocalContextPropagator.TestThreadLocalContextHolder.get().orElse(null));

File: resilience4j-prometheus/src/main/java/io/github/resilience4j/prometheus/collectors/CircuitBreakerMetricsCollector.java
Patch:
@@ -41,7 +41,8 @@ private CircuitBreakerMetricsCollector(MetricNames names, MetricOptions options,
             addMetrics(circuitBreaker);
         }
         circuitBreakerRegistry.getEventPublisher()
-            .onEntryAdded(event -> addMetrics(event.getAddedEntry()));
+            .onEntryAdded(event -> addMetrics(event.getAddedEntry()))
+            .onEntryReplaced(event -> addMetrics(event.getNewEntry()));
     }
 
     /**

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/FixedThreadPoolBulkhead.java
Patch:
@@ -82,7 +82,7 @@ public FixedThreadPoolBulkhead(String name, @Nullable ThreadPoolBulkheadConfig b
         this.executorService = new ThreadPoolExecutor(config.getCoreThreadPoolSize(),
             config.getMaxThreadPoolSize(),
             config.getKeepAliveDuration().toMillis(), TimeUnit.MILLISECONDS,
-            new ArrayBlockingQueue<>(config.getQueueCapacity()),
+            config.getQueueCapacity() == 0 ? new SynchronousQueue<>() : new ArrayBlockingQueue<>(config.getQueueCapacity()),
             new BulkheadNamingThreadFactory(name),
             config.getRejectedExecutionHandler());
         // adding prover jvm executor shutdown

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/bulkhead/configuration/ThreadPoolBulkheadConfigurationProperties.java
Patch:
@@ -96,7 +96,7 @@ public ThreadPoolBulkheadConfig buildThreadPoolBulkheadConfig(
             return ThreadPoolBulkheadConfig.custom().build();
         }
 
-        if (properties.getQueueCapacity() > 0) {
+        if (properties.getQueueCapacity() >= 0) {
             builder.queueCapacity(properties.getQueueCapacity());
         }
         if (properties.getCoreThreadPoolSize() > 0) {
@@ -137,7 +137,7 @@ public static class InstanceProperties {
 
         private int maxThreadPoolSize;
         private int coreThreadPoolSize;
-        private int queueCapacity;
+        private int queueCapacity = -1;
         private Duration keepAliveDuration;
 
         @Nullable

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/bulkhead/autoconfigure/AbstractBulkheadConfigurationOnMissingBean.java
Patch:
@@ -28,7 +28,7 @@
 import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigurationProperties;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.registry.RegistryEventConsumer;
-import io.github.resilience4j.fallback.FallbackDecorators;
+import io.github.resilience4j.fallback.FallbackExecutor;
 import io.github.resilience4j.fallback.autoconfigure.FallbackConfigurationOnMissingBean;
 import io.github.resilience4j.spelresolver.SpelResolver;
 import io.github.resilience4j.spelresolver.autoconfigure.SpelResolverConfigurationOnMissingBean;
@@ -94,11 +94,11 @@ public BulkheadAspect bulkheadAspect(
         ThreadPoolBulkheadRegistry threadPoolBulkheadRegistry,
         BulkheadRegistry bulkheadRegistry,
         @Autowired(required = false) List<BulkheadAspectExt> bulkHeadAspectExtList,
-        FallbackDecorators fallbackDecorators,
+        FallbackExecutor fallbackExecutor,
         SpelResolver spelResolver) {
         return bulkheadConfiguration
             .bulkheadAspect(bulkheadConfigurationProperties, threadPoolBulkheadRegistry,
-                bulkheadRegistry, bulkHeadAspectExtList, fallbackDecorators, spelResolver);
+                bulkheadRegistry, bulkHeadAspectExtList, fallbackExecutor, spelResolver);
     }
 
     @Bean

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/AbstractCircuitBreakerConfigurationOnMissingBean.java
Patch:
@@ -23,7 +23,7 @@
 import io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigCustomizer;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.registry.RegistryEventConsumer;
-import io.github.resilience4j.fallback.FallbackDecorators;
+import io.github.resilience4j.fallback.FallbackExecutor;
 import io.github.resilience4j.fallback.autoconfigure.FallbackConfigurationOnMissingBean;
 import io.github.resilience4j.spelresolver.SpelResolver;
 import io.github.resilience4j.spelresolver.autoconfigure.SpelResolverConfigurationOnMissingBean;
@@ -85,12 +85,12 @@ public RegistryEventConsumer<CircuitBreaker> circuitBreakerRegistryEventConsumer
     public CircuitBreakerAspect circuitBreakerAspect(
         CircuitBreakerRegistry circuitBreakerRegistry,
         @Autowired(required = false) List<CircuitBreakerAspectExt> circuitBreakerAspectExtList,
-        FallbackDecorators fallbackDecorators,
+        FallbackExecutor fallbackExecutor,
         SpelResolver spelResolver
     ) {
         return circuitBreakerConfiguration
             .circuitBreakerAspect(circuitBreakerRegistry, circuitBreakerAspectExtList,
-                fallbackDecorators, spelResolver);
+                fallbackExecutor, spelResolver);
     }
 
     @Bean

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/ratelimiter/autoconfigure/AbstractRateLimiterConfigurationOnMissingBean.java
Patch:
@@ -19,7 +19,7 @@
 import io.github.resilience4j.common.ratelimiter.configuration.RateLimiterConfigCustomizer;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.registry.RegistryEventConsumer;
-import io.github.resilience4j.fallback.FallbackDecorators;
+import io.github.resilience4j.fallback.FallbackExecutor;
 import io.github.resilience4j.fallback.autoconfigure.FallbackConfigurationOnMissingBean;
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
@@ -83,12 +83,12 @@ public RateLimiterAspect rateLimiterAspect(
         RateLimiterConfigurationProperties rateLimiterProperties,
         RateLimiterRegistry rateLimiterRegistry,
         @Autowired(required = false) List<RateLimiterAspectExt> rateLimiterAspectExtList,
-        FallbackDecorators fallbackDecorators,
+        FallbackExecutor fallbackExecutor,
         SpelResolver spelResolver
     ) {
         return rateLimiterConfiguration
             .rateLimiterAspect(rateLimiterProperties, rateLimiterRegistry, rateLimiterAspectExtList,
-                fallbackDecorators, spelResolver);
+                fallbackExecutor, spelResolver);
     }
 
     @Bean

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/retry/autoconfigure/AbstractRetryConfigurationOnMissingBean.java
Patch:
@@ -20,7 +20,7 @@
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.ContextAwareScheduledThreadPoolExecutor;
 import io.github.resilience4j.core.registry.RegistryEventConsumer;
-import io.github.resilience4j.fallback.FallbackDecorators;
+import io.github.resilience4j.fallback.FallbackExecutor;
 import io.github.resilience4j.fallback.autoconfigure.FallbackConfigurationOnMissingBean;
 import io.github.resilience4j.retry.Retry;
 import io.github.resilience4j.retry.RetryRegistry;
@@ -96,13 +96,13 @@ public RetryAspect retryAspect(
         RetryConfigurationProperties retryConfigurationProperties,
         RetryRegistry retryRegistry,
         @Autowired(required = false) List<RetryAspectExt> retryAspectExtList,
-        FallbackDecorators fallbackDecorators,
+        FallbackExecutor fallbackExecutor,
         SpelResolver spelResolver,
         @Autowired(required = false) ContextAwareScheduledThreadPoolExecutor contextAwareScheduledThreadPoolExecutor
     ) {
         return retryConfiguration
             .retryAspect(retryConfigurationProperties, retryRegistry, retryAspectExtList,
-                fallbackDecorators, spelResolver, contextAwareScheduledThreadPoolExecutor);
+                fallbackExecutor, spelResolver, contextAwareScheduledThreadPoolExecutor);
     }
 
     @Bean

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/timelimiter/autoconfigure/AbstractTimeLimiterConfigurationOnMissingBean.java
Patch:
@@ -21,7 +21,7 @@
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.ContextAwareScheduledThreadPoolExecutor;
 import io.github.resilience4j.core.registry.RegistryEventConsumer;
-import io.github.resilience4j.fallback.FallbackDecorators;
+import io.github.resilience4j.fallback.FallbackExecutor;
 import io.github.resilience4j.fallback.autoconfigure.FallbackConfigurationOnMissingBean;
 import io.github.resilience4j.spelresolver.SpelResolver;
 import io.github.resilience4j.spelresolver.autoconfigure.SpelResolverConfigurationOnMissingBean;
@@ -83,12 +83,12 @@ public TimeLimiterAspect timeLimiterAspect(
         TimeLimiterConfigurationProperties timeLimiterProperties,
         TimeLimiterRegistry timeLimiterRegistry,
         @Autowired(required = false) List<TimeLimiterAspectExt> timeLimiterAspectExtList,
-        FallbackDecorators fallbackDecorators,
+        FallbackExecutor fallbackExecutor,
         SpelResolver spelResolver,
         @Autowired(required = false) ContextAwareScheduledThreadPoolExecutor contextAwareScheduledThreadPoolExecutor
     ) {
         return timeLimiterConfiguration.timeLimiterAspect(
-            timeLimiterProperties, timeLimiterRegistry, timeLimiterAspectExtList, fallbackDecorators, spelResolver, contextAwareScheduledThreadPoolExecutor);
+            timeLimiterProperties, timeLimiterRegistry, timeLimiterAspectExtList, fallbackExecutor, spelResolver, contextAwareScheduledThreadPoolExecutor);
     }
 
     @Bean

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/bulkhead/autoconfigure/BulkheadConfigurationOnMissingBeanTest.java
Patch:
@@ -24,7 +24,7 @@
 import io.github.resilience4j.bulkhead.event.BulkheadEvent;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
-import io.github.resilience4j.fallback.FallbackDecorators;
+import io.github.resilience4j.fallback.FallbackExecutor;
 import io.github.resilience4j.spelresolver.SpelResolver;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -95,12 +95,12 @@ public BulkheadAspect bulkheadAspect(
             BulkheadRegistry bulkheadRegistry,
             ThreadPoolBulkheadRegistry threadPoolBulkheadRegistry,
             @Autowired(required = false) List<BulkheadAspectExt> bulkheadAspectExts,
-            FallbackDecorators fallbackDecorators,
+            FallbackExecutor fallbackExecutor,
             SpelResolver spelResolver
         ) {
             bulkheadAspect = new BulkheadAspect(new BulkheadProperties(),
                 threadPoolBulkheadRegistry, bulkheadRegistry, bulkheadAspectExts,
-                fallbackDecorators, spelResolver);
+                fallbackExecutor, spelResolver);
             return bulkheadAspect;
         }
 

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerConfigurationOnMissingBeanTest.java
Patch:
@@ -8,7 +8,7 @@
 import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
-import io.github.resilience4j.fallback.FallbackDecorators;
+import io.github.resilience4j.fallback.FallbackExecutor;
 import io.github.resilience4j.spelresolver.SpelResolver;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -81,10 +81,10 @@ public CircuitBreakerRegistry circuitBreakerRegistry() {
         public CircuitBreakerAspect circuitBreakerAspect(
             CircuitBreakerRegistry circuitBreakerRegistry,
             @Autowired(required = false) List<CircuitBreakerAspectExt> circuitBreakerAspectExtList,
-            FallbackDecorators recoveryDecorators,
+            FallbackExecutor fallbackExecutor,
             SpelResolver spelResolver) {
             circuitBreakerAspect = new CircuitBreakerAspect(new CircuitBreakerProperties(),
-                circuitBreakerRegistry, circuitBreakerAspectExtList, recoveryDecorators, spelResolver);
+                circuitBreakerRegistry, circuitBreakerAspectExtList, fallbackExecutor, spelResolver);
             return circuitBreakerAspect;
         }
 

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterConfigurationOnMissingBeanTest.java
Patch:
@@ -3,7 +3,7 @@
 import io.github.resilience4j.TestUtils;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
-import io.github.resilience4j.fallback.FallbackDecorators;
+import io.github.resilience4j.fallback.FallbackExecutor;
 import io.github.resilience4j.ratelimiter.RateLimiterConfig;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
 import io.github.resilience4j.ratelimiter.configure.RateLimiterAspect;
@@ -83,14 +83,14 @@ public RateLimiterRegistry rateLimiterRegistry() {
         public RateLimiterAspect rateLimiterAspect(
             RateLimiterRegistry rateLimiterRegistry,
             @Autowired(required = false) List<RateLimiterAspectExt> rateLimiterAspectExtList,
-            FallbackDecorators fallbackDecorators,
+            FallbackExecutor fallbackExecutor,
             SpelResolver spelResolver
         ) {
             rateLimiterAspect = new RateLimiterAspect(
                 rateLimiterRegistry,
                 new RateLimiterConfigurationProperties(),
                 rateLimiterAspectExtList,
-                fallbackDecorators,
+                fallbackExecutor,
                 spelResolver
             );
             return rateLimiterAspect;

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/retry/autoconfigure/RetryConfigurationOnMissingBeanTest.java
Patch:
@@ -19,7 +19,7 @@
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.ContextAwareScheduledThreadPoolExecutor;
-import io.github.resilience4j.fallback.FallbackDecorators;
+import io.github.resilience4j.fallback.FallbackExecutor;
 import io.github.resilience4j.retry.RetryRegistry;
 import io.github.resilience4j.retry.configure.RetryAspect;
 import io.github.resilience4j.retry.configure.RetryAspectExt;
@@ -93,12 +93,12 @@ public RetryRegistry retryRegistry() {
         public RetryAspect retryAspect(
             RetryRegistry retryRegistry,
             @Autowired(required = false) List<RetryAspectExt> retryAspectExts,
-            FallbackDecorators fallbackDecorators,
+            FallbackExecutor fallbackExecutor,
             SpelResolver spelResolver,
             @Autowired(required = false) ContextAwareScheduledThreadPoolExecutor contextAwareScheduledThreadPoolExecutor
         ) {
             this.retryAspect = new RetryAspect(new RetryProperties(), retryRegistry,
-                retryAspectExts, fallbackDecorators, spelResolver, contextAwareScheduledThreadPoolExecutor);
+                retryAspectExts, fallbackExecutor, spelResolver, contextAwareScheduledThreadPoolExecutor);
             return retryAspect;
         }
 

File: resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/BulkheadConfiguration.java
Patch:
@@ -28,7 +28,7 @@
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.registry.CompositeRegistryEventConsumer;
 import io.github.resilience4j.core.registry.RegistryEventConsumer;
-import io.github.resilience4j.fallback.FallbackDecorators;
+import io.github.resilience4j.fallback.FallbackExecutor;
 import io.github.resilience4j.fallback.configure.FallbackConfiguration;
 import io.github.resilience4j.spelresolver.SpelResolver;
 import io.github.resilience4j.spelresolver.configure.SpelResolverConfiguration;
@@ -141,11 +141,11 @@ public BulkheadAspect bulkheadAspect(
         ThreadPoolBulkheadRegistry threadPoolBulkheadRegistry,
         BulkheadRegistry bulkheadRegistry,
         @Autowired(required = false) List<BulkheadAspectExt> bulkHeadAspectExtList,
-        FallbackDecorators fallbackDecorators,
+        FallbackExecutor fallbackExecutor,
         SpelResolver spelResolver
     ) {
         return new BulkheadAspect(bulkheadConfigurationProperties, threadPoolBulkheadRegistry,
-            bulkheadRegistry, bulkHeadAspectExtList, fallbackDecorators, spelResolver);
+            bulkheadRegistry, bulkHeadAspectExtList, fallbackExecutor, spelResolver);
     }
 
     @Bean

File: resilience4j-spring/src/test/java/io/github/resilience4j/bulkhead/configure/BulkHeadConfigurationSpringTest.java
Patch:
@@ -22,7 +22,7 @@
 import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigurationProperties;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
-import io.github.resilience4j.fallback.FallbackDecorators;
+import io.github.resilience4j.fallback.FallbackExecutor;
 import io.github.resilience4j.spelresolver.SpelResolver;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -95,12 +95,12 @@ public BulkheadAspect bulkheadAspect(
             BulkheadRegistry bulkheadRegistry,
             ThreadPoolBulkheadRegistry threadPoolBulkheadRegistry,
             @Autowired(required = false) List<BulkheadAspectExt> bulkheadAspectExts,
-            FallbackDecorators fallbackDecorators,
+            FallbackExecutor fallbackExecutor,
             SpelResolver spelResolver
         ) {
             bulkheadAspect = new BulkheadAspect(bulkheadConfigurationProperties(),
                 threadPoolBulkheadRegistry, bulkheadRegistry, bulkheadAspectExts,
-                fallbackDecorators, spelResolver);
+                fallbackExecutor, spelResolver);
             return bulkheadAspect;
         }
 

File: resilience4j-spring/src/test/java/io/github/resilience4j/ratelimiter/configure/RateLimiterConfigurationSpringTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
-import io.github.resilience4j.fallback.FallbackDecorators;
+import io.github.resilience4j.fallback.FallbackExecutor;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
 import io.github.resilience4j.ratelimiter.event.RateLimiterEvent;
 import io.github.resilience4j.spelresolver.SpelResolver;
@@ -76,11 +76,11 @@ public RateLimiterRegistry rateLimiterRegistry() {
         public RateLimiterAspect rateLimiterAspect(
             RateLimiterRegistry rateLimiterRegistry,
             @Autowired(required = false) List<RateLimiterAspectExt> rateLimiterAspectExts,
-            FallbackDecorators recoveryDecorators,
+            FallbackExecutor fallbackExecutor,
             SpelResolver spelResolver
         ) {
             rateLimiterAspect = new RateLimiterAspect(rateLimiterRegistry,
-                rateLimiterConfigurationProperties(), rateLimiterAspectExts, recoveryDecorators, spelResolver);
+                rateLimiterConfigurationProperties(), rateLimiterAspectExts, fallbackExecutor, spelResolver);
             return rateLimiterAspect;
         }
 

File: resilience4j-spring/src/test/java/io/github/resilience4j/retry/configure/RetryConfigurationSpringTest.java
Patch:
@@ -18,7 +18,7 @@
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.ContextAwareScheduledThreadPoolExecutor;
-import io.github.resilience4j.fallback.FallbackDecorators;
+import io.github.resilience4j.fallback.FallbackExecutor;
 import io.github.resilience4j.fallback.configure.FallbackConfiguration;
 import io.github.resilience4j.retry.RetryRegistry;
 import io.github.resilience4j.retry.event.RetryEvent;
@@ -81,11 +81,11 @@ public RetryRegistry retryRegistry() {
         public RetryAspect retryAspect(
             RetryRegistry retryRegistry,
             @Autowired(required = false) List<RetryAspectExt> retryAspectExts,
-            FallbackDecorators fallbackDecorators,
+            FallbackExecutor fallbackExecutor,
             SpelResolver spelResolver
         ) {
             retryAspect = new RetryAspect(retryConfigurationProperties(), retryRegistry,
-                retryAspectExts, fallbackDecorators, spelResolver,contextAwareScheduledThreadPoolExecutor);
+                retryAspectExts, fallbackExecutor, spelResolver,contextAwareScheduledThreadPoolExecutor);
             return retryAspect;
         }
 

File: resilience4j-spring/src/test/java/io/github/resilience4j/timelimiter/configure/TimeLimiterConfigurationSpringTest.java
Patch:
@@ -3,7 +3,7 @@
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.ContextAwareScheduledThreadPoolExecutor;
-import io.github.resilience4j.fallback.FallbackDecorators;
+import io.github.resilience4j.fallback.FallbackExecutor;
 import io.github.resilience4j.spelresolver.SpelResolver;
 import io.github.resilience4j.timelimiter.TimeLimiterRegistry;
 import io.github.resilience4j.timelimiter.event.TimeLimiterEvent;
@@ -67,10 +67,10 @@ public TimeLimiterRegistry timeLimiterRegistry() {
         public TimeLimiterAspect timeLimiterAspect(
             TimeLimiterRegistry timeLimiterRegistry,
             @Autowired(required = false) List<TimeLimiterAspectExt> timeLimiterAspectExtList,
-            FallbackDecorators fallbackDecorators,
+            FallbackExecutor fallbackExecutor,
             SpelResolver spelResolver
         ) {
-            timeLimiterAspect = new TimeLimiterAspect(timeLimiterRegistry, timeLimiterConfigurationProperties(), timeLimiterAspectExtList, fallbackDecorators, spelResolver, contextAwareScheduledThreadPoolExecutor);
+            timeLimiterAspect = new TimeLimiterAspect(timeLimiterRegistry, timeLimiterConfigurationProperties(), timeLimiterAspectExtList, fallbackExecutor, spelResolver, contextAwareScheduledThreadPoolExecutor);
             return timeLimiterAspect;
         }
 

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java
Patch:
@@ -597,7 +597,7 @@ static void waitForPermission(final RateLimiter rateLimiter, int permits) {
      * {@link RateLimiterConfig#getDrainPermissionsOnResult()}.
      *
      * @param callsResult result of a methods call that was rate limiter by this rate limiter
-     * @deprecated because of changing visiblity to private in Java9+
+     * @deprecated because of changing visibility to private in Java9+
      */
     @Deprecated
     default void drainIfNeeded(Either<? extends Throwable, ?> callsResult) {

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakersHealthIndicatorAutoConfiguration.java
Patch:
@@ -16,7 +16,7 @@
 import org.springframework.context.annotation.Configuration;
 
 @Configuration
-@ConditionalOnClass({CircuitBreaker.class, HealthIndicator.class})
+@ConditionalOnClass({CircuitBreaker.class, HealthIndicator.class, StatusAggregator.class})
 @AutoConfigureAfter(CircuitBreakerAutoConfiguration.class)
 @AutoConfigureBefore(HealthContributorAutoConfiguration.class)
 public class CircuitBreakersHealthIndicatorAutoConfiguration {

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimitersHealthIndicatorAutoConfiguration.java
Patch:
@@ -16,7 +16,7 @@
 import org.springframework.context.annotation.Configuration;
 
 @Configuration
-@ConditionalOnClass({RateLimiter.class, HealthIndicator.class})
+@ConditionalOnClass({RateLimiter.class, HealthIndicator.class, StatusAggregator.class})
 @AutoConfigureAfter(RateLimiterAutoConfiguration.class)
 @AutoConfigureBefore(HealthContributorAutoConfiguration.class)
 public class RateLimitersHealthIndicatorAutoConfiguration {

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerStateMachine.java
Patch:
@@ -877,11 +877,11 @@ private void checkIfThresholdsExceeded(Result result) {
             }
 
             if (shouldPublishFailureRateExceededEvent(result)) {
-                publishCircuitThresholdsExceededEvent(result, circuitBreakerMetrics);
+                publishCircuitFailureRateExceededEvent(getName(), circuitBreakerMetrics.getFailureRate());
             }
 
             if (shouldPublishSlowCallRateExceededEvent(result)) {
-                publishCircuitThresholdsExceededEvent(result, circuitBreakerMetrics);
+                publishCircuitSlowCallRateExceededEvent(getName(), circuitBreakerMetrics.getSlowCallRate());
             }
         }
 

File: resilience4j-annotations/src/main/java/io/github/resilience4j/bulkhead/annotation/Bulkhead.java
Patch:
@@ -14,9 +14,9 @@
 
     /**
      * Name of the bulkhead.
-     * It can be SpEL expression. If you want to use first parameter of the method as name, you can
-     * express it {@code #root.args[0]}, {@code #p0} or {@code #a0}. And method name can be accessed via
-     * {@code #root.methodName}
+     * It can be SpEL expression. If you want to use the first parameter of the method as name, you can
+     * express it as {@code #root.args[0]}, {@code #p0} or {@code #a0}. The method name can be accessed via
+     * {@code #root.methodName}.  To invoke a method on a Spring bean, pass {@code @yourBean.yourMethod(#a0)}.
      *
      * @return the name of the bulkhead
      */

File: resilience4j-annotations/src/main/java/io/github/resilience4j/circuitbreaker/annotation/CircuitBreaker.java
Patch:
@@ -31,9 +31,9 @@
 
     /**
      * Name of the circuit breaker.
-     * It can be SpEL expression. If you want to use first parameter of the method as name, you can
-     * express it {@code #root.args[0]}, {@code #p0} or {@code #a0}. And method name can be accessed via
-     * {@code #root.methodName}
+     * It can be SpEL expression. If you want to use the first parameter of the method as name, you can
+     * express it as {@code #root.args[0]}, {@code #p0} or {@code #a0}. The method name can be accessed via
+     * {@code #root.methodName}.  To invoke a method on a Spring bean, pass {@code @yourBean.yourMethod(#a0)}.
      *
      * @return the name of the circuit breaker
      */

File: resilience4j-annotations/src/main/java/io/github/resilience4j/ratelimiter/annotation/RateLimiter.java
Patch:
@@ -31,9 +31,9 @@
 
     /**
      * Name of the rate limiter
-     * It can be SpEL expression. If you want to use first parameter of the method as name, you can
-     * express it {@code #root.args[0]}, {@code #p0} or {@code #a0}. And method name can be accessed via
-     * {@code #root.methodName}
+     * It can be SpEL expression. If you want to use the first parameter of the method as name, you can
+     * express it as {@code #root.args[0]}, {@code #p0} or {@code #a0}. The method name can be accessed via
+     * {@code #root.methodName}.  To invoke a method on a Spring bean, pass {@code @yourBean.yourMethod(#a0)}.
      *
      * @return the name of the limiter
      */

File: resilience4j-annotations/src/main/java/io/github/resilience4j/retry/annotation/Retry.java
Patch:
@@ -30,9 +30,9 @@
 
     /**
      * Name of the sync retry.
-     * It can be SpEL expression. If you want to use first parameter of the method as name, you can
-     * express it {@code #root.args[0]}, {@code #p0} or {@code #a0}. And method name can be accessed via
-     * {@code #root.methodName}
+     * It can be SpEL expression. If you want to use the first parameter of the method as name, you can
+     * express it as {@code #root.args[0]}, {@code #p0} or {@code #a0}. The method name can be accessed via
+     * {@code #root.methodName}.  To invoke a method on a Spring bean, pass {@code @yourBean.yourMethod(#a0)}.
      *
      * @return the name of the sync retry.
      */

File: resilience4j-annotations/src/main/java/io/github/resilience4j/timelimiter/annotation/TimeLimiter.java
Patch:
@@ -31,9 +31,9 @@
 
     /**
      * Name of the sync timeLimiter.
-     * It can be SpEL expression. If you want to use first parameter of the method as name, you can
-     * express it {@code #root.args[0]}, {@code #p0} or {@code #a0}. And method name can be accessed via
-     * {@code #root.methodName}
+     * It can be SpEL expression. If you want to use the first parameter of the method as name, you can
+     * express it as {@code #root.args[0]}, {@code #p0} or {@code #a0}. The method name can be accessed via
+     * {@code #root.methodName}.  To invoke a method on a Spring bean, pass {@code @yourBean.yourMethod(#a0)}.
      *
      * @return the name of the sync timeLimiter.
      */

File: resilience4j-core/src/main/java/io/github/resilience4j/core/lang/NonNull.java
Patch:
@@ -40,9 +40,9 @@
  * @see Nullable
  */
 @Target({ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD})
-@Retention(RetentionPolicy.RUNTIME)
+@Retention(RetentionPolicy.CLASS)
 @Documented
 @Nonnull
 @TypeQualifierNickname
 public @interface NonNull {
-}
\ No newline at end of file
+}

File: resilience4j-core/src/main/java/io/github/resilience4j/core/lang/NonNullApi.java
Patch:
@@ -38,9 +38,9 @@
  * @see NonNull
  */
 @Target(ElementType.PACKAGE)
-@Retention(RetentionPolicy.RUNTIME)
+@Retention(RetentionPolicy.CLASS)
 @Documented
 @Nonnull
 @TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})
 public @interface NonNullApi {
-}
\ No newline at end of file
+}

File: resilience4j-core/src/main/java/io/github/resilience4j/core/lang/NonNullFields.java
Patch:
@@ -37,7 +37,7 @@
  * @see NonNull
  */
 @Target(ElementType.PACKAGE)
-@Retention(RetentionPolicy.RUNTIME)
+@Retention(RetentionPolicy.CLASS)
 @Documented
 @Nonnull
 @TypeQualifierDefault(ElementType.FIELD)

File: resilience4j-core/src/main/java/io/github/resilience4j/core/lang/Nullable.java
Patch:
@@ -42,9 +42,9 @@
  * @see NonNull
  */
 @Target({ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD})
-@Retention(RetentionPolicy.RUNTIME)
+@Retention(RetentionPolicy.CLASS)
 @Documented
 @Nonnull(when = When.MAYBE)
 @TypeQualifierNickname
 public @interface Nullable {
-}
\ No newline at end of file
+}

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/bulkhead/configuration/BulkheadConfigurationProperties.java
Patch:
@@ -53,7 +53,7 @@ private BulkheadConfig buildConfigFromBaseConfig(InstanceProperties baseProperti
         CompositeCustomizer<BulkheadConfigCustomizer> compositeBulkheadCustomizer,
         String instanceName) {
         ConfigUtils.mergePropertiesIfAny(baseProperties, instanceProperties);
-        BulkheadConfig baseConfig = buildBulkheadConfig(BulkheadConfig.custom(), baseProperties,
+        BulkheadConfig baseConfig = createBulkheadConfig(baseProperties,
             compositeBulkheadCustomizer, instanceName);
         return buildBulkheadConfig(BulkheadConfig.from(baseConfig), instanceProperties,
             compositeBulkheadCustomizer, instanceName);

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/bulkhead/configuration/ThreadPoolBulkheadConfigurationProperties.java
Patch:
@@ -82,9 +82,8 @@ private ThreadPoolBulkheadConfig buildThreadPoolConfigFromBaseConfig(
         InstanceProperties baseProperties, InstanceProperties instanceProperties,
         CompositeCustomizer<ThreadPoolBulkheadConfigCustomizer> compositeThreadPoolBulkheadCustomizer,
         String instanceName) {
-        ThreadPoolBulkheadConfig baseConfig = buildThreadPoolBulkheadConfig(
-            ThreadPoolBulkheadConfig.custom(), baseProperties,
-            compositeThreadPoolBulkheadCustomizer, instanceName);
+        ThreadPoolBulkheadConfig baseConfig = createThreadPoolBulkheadConfig(
+            baseProperties, compositeThreadPoolBulkheadCustomizer, instanceName);
         return buildThreadPoolBulkheadConfig(ThreadPoolBulkheadConfig.from(baseConfig),
             instanceProperties, compositeThreadPoolBulkheadCustomizer, instanceName);
     }

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/circuitbreaker/configuration/CircuitBreakerConfigurationProperties.java
Patch:
@@ -72,9 +72,8 @@ private CircuitBreakerConfig buildConfigFromBaseConfig(InstanceProperties instan
         CompositeCustomizer<CircuitBreakerConfigCustomizer> compositeCircuitBreakerCustomizer,
         String backendName) {
         ConfigUtils.mergePropertiesIfAny(instanceProperties, baseProperties);
-        CircuitBreakerConfig baseConfig = buildConfig(custom(), baseProperties,
-            compositeCircuitBreakerCustomizer,
-            backendName);
+        CircuitBreakerConfig baseConfig = createCircuitBreakerConfig(
+            backendName, baseProperties, compositeCircuitBreakerCustomizer);
         return buildConfig(from(baseConfig), instanceProperties, compositeCircuitBreakerCustomizer,
             backendName);
     }

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/ratelimiter/configuration/RateLimiterConfigurationProperties.java
Patch:
@@ -66,7 +66,7 @@ private RateLimiterConfig buildConfigFromBaseConfig(InstanceProperties basePrope
         CompositeCustomizer<RateLimiterConfigCustomizer> compositeRateLimiterCustomizer,
         String instanceName) {
         ConfigUtils.mergePropertiesIfAny(baseProperties, instanceProperties);
-        RateLimiterConfig baseConfig = buildRateLimiterConfig(RateLimiterConfig.custom(),
+        RateLimiterConfig baseConfig = createRateLimiterConfig(
             baseProperties, compositeRateLimiterCustomizer, instanceName);
         return buildRateLimiterConfig(RateLimiterConfig.from(baseConfig), instanceProperties,
             compositeRateLimiterCustomizer, instanceName);

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/retry/configuration/RetryConfigurationProperties.java
Patch:
@@ -102,7 +102,7 @@ private RetryConfig buildConfigFromBaseConfig(InstanceProperties baseProperties,
         InstanceProperties instanceProperties,
         CompositeCustomizer<RetryConfigCustomizer> compositeRetryCustomizer,
         String backend) {
-        RetryConfig baseConfig = buildRetryConfig(RetryConfig.custom(), baseProperties,
+        RetryConfig baseConfig = createRetryConfig(baseProperties,
             compositeRetryCustomizer, backend);
         ConfigUtils.mergePropertiesIfAny(baseProperties, instanceProperties);
         return buildRetryConfig(RetryConfig.from(baseConfig), instanceProperties,

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/timelimiter/configuration/TimeLimiterConfigurationProperties.java
Patch:
@@ -70,13 +70,13 @@ public TimeLimiterConfig createTimeLimiterConfig(String backendName,
             compositeTimeLimiterCustomizer, backendName);
     }
 
-    private static TimeLimiterConfig buildConfigFromBaseConfig(
+    private TimeLimiterConfig buildConfigFromBaseConfig(
         InstanceProperties baseProperties, InstanceProperties instanceProperties,
         CompositeCustomizer<TimeLimiterConfigCustomizer> compositeTimeLimiterCustomizer, String backendName) {
 
         ConfigUtils.mergePropertiesIfAny(baseProperties, instanceProperties);
-        TimeLimiterConfig baseConfig = buildTimeLimiterConfig(TimeLimiterConfig.custom(), baseProperties,
-            compositeTimeLimiterCustomizer, backendName);
+        TimeLimiterConfig baseConfig = createTimeLimiterConfig(
+            backendName, baseProperties, compositeTimeLimiterCustomizer);
         return buildTimeLimiterConfig(TimeLimiterConfig.from(baseConfig), instanceProperties,
             compositeTimeLimiterCustomizer, backendName);
     }

File: resilience4j-core/src/main/java/io/github/resilience4j/core/metrics/Measurement.java
Patch:
@@ -24,6 +24,7 @@ void reset() {
         this.totalDurationInMillis = 0;
         this.numberOfSlowCalls = 0;
         this.numberOfFailedCalls = 0;
+        this.numberOfSlowFailedCalls = 0;
         this.numberOfCalls = 0;
     }
 

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java
Patch:
@@ -130,6 +130,7 @@ private Flux<ServerSentEvent<String>> circuitBreakerStreamEvents(String s) {
             .accept(MediaType.TEXT_EVENT_STREAM)
             .retrieve()
             .bodyToFlux(type)
+            .filter(eventData -> !eventData.event().equals("ping"))
             .take(3);
         return eventStream;
     }

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerStreamEventsTest.java
Patch:
@@ -129,6 +129,7 @@ private Flux<ServerSentEvent<String>> circuitBreakerStreamEvents(String s) {
             .accept(MediaType.TEXT_EVENT_STREAM)
             .retrieve()
             .bodyToFlux(type)
+            .filter(eventData -> !eventData.event().equals("ping"))
             .take(3);
         return eventStream;
     }

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java
Patch:
@@ -660,7 +660,9 @@ static void waitForPermission(final RateLimiter rateLimiter, int permits) {
      * {@link RateLimiterConfig#getDrainPermissionsOnResult()}.
      *
      * @param callsResult result of a methods call that was rate limiter by this rate limiter
+     * @deprecated because of changing visiblity to private in Java9+
      */
+    @Deprecated
     default void drainIfNeeded(Either<? extends Throwable, ?> callsResult) {
         Predicate<Either<? extends Throwable, ?>> checker = getRateLimiterConfig()
             .getDrainPermissionsOnResult();

File: resilience4j-rxjava3/src/main/java/io/github/resilience4j/rxjava3/ratelimiter/operator/MaybeRateLimiter.java
Patch:
@@ -22,6 +22,7 @@
 import io.reactivex.rxjava3.core.Maybe;
 import io.reactivex.rxjava3.core.MaybeObserver;
 import io.reactivex.rxjava3.internal.disposables.EmptyDisposable;
+import io.vavr.control.Either;
 
 import java.util.concurrent.TimeUnit;
 
@@ -64,12 +65,12 @@ protected void hookOnComplete() {
 
         @Override
         protected void hookOnError(Throwable e) {
-            // NoOp
+            rateLimiter.onError(e);
         }
 
         @Override
         protected void hookOnSuccess(T value) {
-            // NoOp
+            rateLimiter.onResult(value);
         }
 
         @Override

File: resilience4j-rxjava3/src/main/java/io/github/resilience4j/rxjava3/ratelimiter/operator/SingleRateLimiter.java
Patch:
@@ -22,6 +22,7 @@
 import io.reactivex.rxjava3.core.Single;
 import io.reactivex.rxjava3.core.SingleObserver;
 import io.reactivex.rxjava3.internal.disposables.EmptyDisposable;
+import io.vavr.control.Either;
 
 import java.util.concurrent.TimeUnit;
 
@@ -59,12 +60,12 @@ class RateLimiterSingleObserver extends AbstractSingleObserver<T> {
 
         @Override
         protected void hookOnError(Throwable e) {
-            // NoOp
+            rateLimiter.onError(e);
         }
 
         @Override
         protected void hookOnSuccess(T value) {
-            // NoOp
+            rateLimiter.onResult(value);
         }
 
         @Override

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterConfigTest.java
Patch:
@@ -24,7 +24,7 @@
 import org.junit.rules.ExpectedException;
 
 import java.time.Duration;
-import java.util.function.Function;
+import java.util.function.Predicate;
 
 import static org.assertj.core.api.BDDAssertions.then;
 
@@ -34,7 +34,7 @@ public class RateLimiterConfigTest {
     private static final int LIMIT = 50;
     private static final Duration TIMEOUT = Duration.ofSeconds(5);
     private static final Duration REFRESH_PERIOD = Duration.ofNanos(500);
-    private static final Function<Either<? extends Throwable, ?>, Boolean> DRAIN_CONDITION_CHECKER = result -> false;
+    private static final Predicate<Either<? extends Throwable, ?>> DRAIN_CONDITION_CHECKER = result -> false;
     private static final String TIMEOUT_DURATION_MUST_NOT_BE_NULL = "TimeoutDuration must not be null";
     private static final String REFRESH_PERIOD_MUST_NOT_BE_NULL = "RefreshPeriod must not be null";
 

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/ratelimiter/operator/RateLimiterSubscriberWhiteboxVerification.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.github.resilience4j.reactor.ratelimiter.operator;
 
+import io.github.resilience4j.ratelimiter.RateLimiter;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import org.reactivestreams.tck.SubscriberWhiteboxVerification;
@@ -30,7 +31,7 @@ public RateLimiterSubscriberWhiteboxVerification() {
 
     @Override
     public Subscriber<Integer> createSubscriber(WhiteboxSubscriberProbe<Integer> probe) {
-        return new RateLimiterSubscriber<Integer>(MonoProcessor.create()) {
+        return new RateLimiterSubscriber<Integer>(RateLimiter.ofDefaults("verification"), MonoProcessor.create()) {
             @Override
             public void hookOnSubscribe(Subscription subscription) {
                 super.hookOnSubscribe(subscription);

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/RateLimitersImplementationTest.java
Patch:
@@ -1,6 +1,5 @@
 package io.github.resilience4j.ratelimiter.internal;
 
-import io.github.resilience4j.core.EventConsumer;
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.ratelimiter.RateLimiterConfig;
 import io.github.resilience4j.ratelimiter.event.RateLimiterOnDrainedEvent;
@@ -91,8 +90,6 @@ public void tryToAcquirePermitsAfterDrainBeforeCycleEndsTest() {
         then(retryInSecondCyclePermission).isTrue();
     }
 
-
-
     @Test
     public void drainCycleWhichAlreadyHashNoPremitsLeftTest() {
         RateLimiterConfig config = RateLimiterConfig.custom()

File: resilience4j-core/src/main/java/io/github/resilience4j/core/metrics/PartialAggregation.java
Patch:
@@ -31,6 +31,7 @@ void reset(long epochSecond) {
         this.totalDurationInMillis = 0;
         this.numberOfSlowCalls = 0;
         this.numberOfFailedCalls = 0;
+        this.numberOfSlowFailedCalls = 0;
         this.numberOfCalls = 0;
     }
 

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/event/RateLimiterEvent.java
Patch:
@@ -35,6 +35,7 @@ public interface RateLimiterEvent {
 
     enum Type {
         FAILED_ACQUIRE,
-        SUCCESSFUL_ACQUIRE
+        SUCCESSFUL_ACQUIRE,
+        DRAINED
     }
 }

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/FixedThreadPoolBulkhead.java
Patch:
@@ -83,7 +83,8 @@ public FixedThreadPoolBulkhead(String name, @Nullable ThreadPoolBulkheadConfig b
             config.getMaxThreadPoolSize(),
             config.getKeepAliveDuration().toMillis(), TimeUnit.MILLISECONDS,
             new ArrayBlockingQueue<>(config.getQueueCapacity()),
-            new NamingThreadFactory(name));
+            new NamingThreadFactory(name),
+            config.getRejectedExecutionHandler());
         // adding prover jvm executor shutdown
         this.metrics = new FixedThreadPoolBulkhead.BulkheadMetrics();
         this.eventProcessor = new FixedThreadPoolBulkhead.BulkheadEventProcessor();

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerConfigTest.java
Patch:
@@ -35,6 +35,9 @@
 
 public class CircuitBreakerConfigTest {
 
+
+//    TODO: add tests here for record Result
+
     @Test(expected = IllegalArgumentException.class)
     public void zeroMaxFailuresShouldFail() {
         custom().failureRateThreshold(0).build();

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerMetricsTest.java
Patch:
@@ -30,6 +30,8 @@
 
 public class CircuitBreakerMetricsTest {
 
+//    TODO: add tests here for record Result
+
     @Test
     public void testCircuitBreakerMetrics() {
         CircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.custom()

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedCircuitBreakerMetricsPublisherTest.java
Patch:
@@ -258,4 +258,4 @@ public void testReplaceNewMeter(){
             .isEqualTo(newOne.getMetrics().getNumberOfSuccessfulCalls());
 
     }
-}
\ No newline at end of file
+}

File: resilience4j-prometheus/src/test/java/io/github/resilience4j/prometheus/collectors/CircuitBreakerMetricsCollectorTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.junit.Test;
 
 import java.time.Duration;
+import java.util.Optional;
 import java.util.concurrent.TimeUnit;
 
 import static io.github.resilience4j.prometheus.AbstractCircuitBreakerMetrics.MetricNames;

File: resilience4j-prometheus/src/test/java/io/github/resilience4j/prometheus/publisher/CircuitBreakerMetricsPublisherTest.java
Patch:
@@ -275,4 +275,4 @@ public void customMetricNameBucketsOverrideDefaultOnes() {
             new String[]{circuitBreaker.getName(), "successful", "0.025"}
         )).isNull();
     }
-}
\ No newline at end of file
+}

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/circuitbreaker/CircuitBreakerMethodInterceptor.java
Patch:
@@ -125,7 +125,7 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
                             breaker.onError(durationInNanos, TimeUnit.NANOSECONDS, t);
                             completeFailedFuture(t, fallbackMethod, promise);
                         } else {
-                            breaker.onSuccess(durationInNanos, TimeUnit.NANOSECONDS);
+                            breaker.onResult(durationInNanos, TimeUnit.NANOSECONDS, v);
                             promise.complete(v);
                         }
                     });

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/circuitbreaker/CircuitBreakerTransformer.java
Patch:
@@ -67,7 +67,7 @@ public Upstream<T> apply(Upstream<? extends T> upstream) throws Exception {
                     @Override
                     public void success(T value) {
                         long durationInNanos = System.nanoTime() - start;
-                        circuitBreaker.onSuccess(durationInNanos, TimeUnit.NANOSECONDS);
+                        circuitBreaker.onResult(durationInNanos, TimeUnit.NANOSECONDS, value);
                         down.success(value);
                     }
 

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/circuitbreaker/operator/CircuitBreakerSubscriber.java
Patch:
@@ -20,7 +20,6 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
 
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import static java.util.Objects.requireNonNull;
@@ -53,7 +52,7 @@ protected CircuitBreakerSubscriber(CircuitBreaker circuitBreaker,
     protected void hookOnNext(T value) {
         if (!isDisposed()) {
             if (singleProducer && successSignaled.compareAndSet(false, true)) {
-                circuitBreaker.onSuccess(circuitBreaker.getCurrentTimestamp() - start, circuitBreaker.getTimestampUnit());
+                circuitBreaker.onResult(circuitBreaker.getCurrentTimestamp() - start, circuitBreaker.getTimestampUnit(), value);
             }
             eventWasEmitted.set(true);
 

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/circuitbreaker/operator/FluxCircuitBreakerTest.java
Patch:
@@ -71,7 +71,7 @@ public void shouldPropagateError() {
 
         verify(circuitBreaker, times(1))
             .onError(anyLong(), any(TimeUnit.class), any(IOException.class));
-        verify(circuitBreaker, never()).onSuccess(anyLong(), any(TimeUnit.class));
+        verify(circuitBreaker, never()).onResult(anyLong(), any(TimeUnit.class), any());
     }
 
     @Test
@@ -104,7 +104,7 @@ public void shouldSubscribeToMonoJustTwice() {
             .expectNext("Bla Event 2")
             .verifyComplete();
 
-        verify(circuitBreaker, times(2)).onSuccess(anyLong(), any(TimeUnit.class));
+        verify(circuitBreaker, times(2)).onResult(anyLong(), any(TimeUnit.class), any(String.class));
         verify(circuitBreaker, never())
             .onError(anyLong(), any(TimeUnit.class), any(Throwable.class));
     }
@@ -191,4 +191,4 @@ public void shouldInvokeOnSuccessOnCancelWhenEventWasEmitted() {
             .onError(anyLong(), any(TimeUnit.class), any(Throwable.class));
         verify(circuitBreaker, times(1)).onSuccess(anyLong(), any(TimeUnit.class));
     }
-}
\ No newline at end of file
+}

File: resilience4j-retrofit/src/main/java/io/github/resilience4j/retrofit/RetrofitCircuitBreaker.java
Patch:
@@ -84,7 +84,7 @@ public void enqueue(final Callback<T> callback) {
                 @Override
                 public void onResponse(final Call<T> call, final Response<T> response) {
                     if (responseSuccess.test(response)) {
-                        circuitBreaker.onSuccess(System.nanoTime() - start, TimeUnit.NANOSECONDS);
+                        circuitBreaker.onResult(System.nanoTime() - start, TimeUnit.NANOSECONDS, response);
                     } else {
                         final Throwable throwable = new Throwable(
                             "Response error: HTTP " + response.code() + " - " + response.message());
@@ -114,7 +114,7 @@ public Response<T> execute() throws IOException {
                 final Response<T> response = call.execute();
 
                 if (responseSuccess.test(response)) {
-                    circuitBreaker.onSuccess(stopWatch.stop().toNanos(), TimeUnit.NANOSECONDS);
+                    circuitBreaker.onResult(stopWatch.stop().toNanos(), TimeUnit.NANOSECONDS, response);
                 } else {
                     final Throwable throwable = new Throwable(
                         "Response error: HTTP " + response.code() + " - " + response.message());

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/RetryConfig.java
Patch:
@@ -47,6 +47,7 @@ public class RetryConfig implements Serializable {
 
     @Nullable
     private Predicate<Throwable> retryOnExceptionPredicate;
+
     @Nullable
     private Predicate retryOnResultPredicate;
 
@@ -119,7 +120,7 @@ public Predicate<Throwable> getExceptionPredicate() {
 
     /**
      * Return the Predicate which evaluates if an result should be retried. The Predicate must
-     * return true if the result should  be retried, otherwise it must return false.
+     * return true if the result should be retried, otherwise it must return false.
      *
      * @param <T> The type of result.
      * @return the result predicate

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/AbstractMaybeObserver.java
Patch:
@@ -41,11 +41,11 @@ public void onComplete() {
     @Override
     public void onSuccess(T value) {
         whenNotCompleted(() -> {
-            hookOnSuccess();
+            hookOnSuccess(value);
             downstreamObserver.onSuccess(value);
         });
     }
 
-    protected abstract void hookOnSuccess();
+    protected abstract void hookOnSuccess(T value);
 
 }

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/AbstractSingleObserver.java
Patch:
@@ -31,11 +31,11 @@ public void onError(Throwable e) {
     @Override
     public void onSuccess(T value) {
         whenNotCompleted(() -> {
-            hookOnSuccess();
+            hookOnSuccess(value);
             downstreamObserver.onSuccess(value);
         });
     }
 
-    protected abstract void hookOnSuccess();
+    protected abstract void hookOnSuccess(T value);
 
 }

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/MaybeBulkhead.java
Patch:
@@ -59,7 +59,7 @@ protected void hookOnError(Throwable e) {
         }
 
         @Override
-        protected void hookOnSuccess() {
+        protected void hookOnSuccess(T value) {
             bulkhead.onComplete();
         }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/SingleBulkhead.java
Patch:
@@ -54,7 +54,7 @@ protected void hookOnError(Throwable e) {
         }
 
         @Override
-        protected void hookOnSuccess() {
+        protected void hookOnSuccess(T value) {
             bulkhead.onComplete();
         }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/FlowableCircuitBreaker.java
Patch:
@@ -76,4 +76,4 @@ public void hookOnCancel() {
         }
     }
 
-}
\ No newline at end of file
+}

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/SingleCircuitBreaker.java
Patch:
@@ -58,8 +58,8 @@ protected void hookOnError(Throwable e) {
         }
 
         @Override
-        protected void hookOnSuccess() {
-            circuitBreaker.onSuccess(circuitBreaker.getCurrentTimestamp() - start, circuitBreaker.getTimestampUnit());
+        protected void hookOnSuccess(T value) {
+            circuitBreaker.onResult(circuitBreaker.getCurrentTimestamp() - start, circuitBreaker.getTimestampUnit(), value);
         }
 
         @Override

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/MaybeRateLimiter.java
Patch:
@@ -68,7 +68,7 @@ protected void hookOnError(Throwable e) {
         }
 
         @Override
-        protected void hookOnSuccess() {
+        protected void hookOnSuccess(T value) {
             // NoOp
         }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/SingleRateLimiter.java
Patch:
@@ -63,7 +63,7 @@ protected void hookOnError(Throwable e) {
         }
 
         @Override
-        protected void hookOnSuccess() {
+        protected void hookOnSuccess(T value) {
             // NoOp
         }
 

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/circuitbreaker/operator/MaybeCircuitBreakerTest.java
Patch:
@@ -29,7 +29,7 @@ public void shouldSubscribeToMaybeJust() {
             .test()
             .assertResult(1);
 
-        then(circuitBreaker).should().onSuccess(anyLong(), any(TimeUnit.class));
+        then(circuitBreaker).should().onResult(anyLong(), any(TimeUnit.class), any(Integer.class));
         then(circuitBreaker).should(never())
             .onError(anyLong(), any(TimeUnit.class), any(Throwable.class));
     }
@@ -64,7 +64,7 @@ public void shouldEmitErrorWithCallNotPermittedException() {
             .assertError(CallNotPermittedException.class)
             .assertNotComplete();
 
-        then(circuitBreaker).should(never()).onSuccess(anyLong(), any(TimeUnit.class));
+        then(circuitBreaker).should(never()).onResult(anyLong(), any(TimeUnit.class), any(Integer.class));
         then(circuitBreaker).should(never())
             .onError(anyLong(), any(TimeUnit.class), any(Throwable.class));
     }
@@ -82,7 +82,7 @@ public void shouldReleasePermissionOnCancel() {
         then(circuitBreaker).should().releasePermission();
         then(circuitBreaker).should(never())
             .onError(anyLong(), any(TimeUnit.class), any(Throwable.class));
-        then(circuitBreaker).should(never()).onSuccess(anyLong(), any(TimeUnit.class));
+        then(circuitBreaker).should(never()).onResult(anyLong(), any(TimeUnit.class), any(Integer.class));
     }
 
 }

File: resilience4j-rxjava3/src/main/java/io/github/resilience4j/rxjava3/AbstractMaybeObserver.java
Patch:
@@ -42,11 +42,11 @@ public void onComplete() {
     @Override
     public void onSuccess(T value) {
         whenNotCompleted(() -> {
-            hookOnSuccess();
+            hookOnSuccess(value);
             downstreamObserver.onSuccess(value);
         });
     }
 
-    protected abstract void hookOnSuccess();
+    protected abstract void hookOnSuccess(T value);
 
 }

File: resilience4j-rxjava3/src/main/java/io/github/resilience4j/rxjava3/AbstractSingleObserver.java
Patch:
@@ -31,11 +31,11 @@ public void onError(Throwable e) {
     @Override
     public void onSuccess(T value) {
         whenNotCompleted(() -> {
-            hookOnSuccess();
+            hookOnSuccess(value);
             downstreamObserver.onSuccess(value);
         });
     }
 
-    protected abstract void hookOnSuccess();
+    protected abstract void hookOnSuccess(T value);
 
 }

File: resilience4j-rxjava3/src/main/java/io/github/resilience4j/rxjava3/bulkhead/operator/MaybeBulkhead.java
Patch:
@@ -59,7 +59,7 @@ protected void hookOnError(Throwable e) {
         }
 
         @Override
-        protected void hookOnSuccess() {
+        protected void hookOnSuccess(T value) {
             bulkhead.onComplete();
         }
 

File: resilience4j-rxjava3/src/main/java/io/github/resilience4j/rxjava3/bulkhead/operator/SingleBulkhead.java
Patch:
@@ -54,7 +54,7 @@ protected void hookOnError(Throwable e) {
         }
 
         @Override
-        protected void hookOnSuccess() {
+        protected void hookOnSuccess(T value) {
             bulkhead.onComplete();
         }
 

File: resilience4j-rxjava3/src/main/java/io/github/resilience4j/rxjava3/circuitbreaker/operator/FlowableCircuitBreaker.java
Patch:
@@ -76,4 +76,4 @@ public void hookOnCancel() {
         }
     }
 
-}
\ No newline at end of file
+}

File: resilience4j-rxjava3/src/main/java/io/github/resilience4j/rxjava3/circuitbreaker/operator/MaybeCircuitBreaker.java
Patch:
@@ -63,8 +63,9 @@ protected void hookOnError(Throwable e) {
         }
 
         @Override
-        protected void hookOnSuccess() {
-            circuitBreaker.onSuccess(circuitBreaker.getCurrentTimestamp() - start, circuitBreaker.getTimestampUnit());
+        protected void hookOnSuccess(T value) {
+            circuitBreaker.onResult(circuitBreaker.getCurrentTimestamp() - start, circuitBreaker.getTimestampUnit(), value);
+
         }
 
         @Override

File: resilience4j-rxjava3/src/main/java/io/github/resilience4j/rxjava3/circuitbreaker/operator/SingleCircuitBreaker.java
Patch:
@@ -58,8 +58,8 @@ protected void hookOnError(Throwable e) {
         }
 
         @Override
-        protected void hookOnSuccess() {
-            circuitBreaker.onSuccess(circuitBreaker.getCurrentTimestamp() - start, circuitBreaker.getTimestampUnit());
+        protected void hookOnSuccess(T value) {
+            circuitBreaker.onResult(circuitBreaker.getCurrentTimestamp() - start, circuitBreaker.getTimestampUnit(), value);
         }
 
         @Override

File: resilience4j-rxjava3/src/main/java/io/github/resilience4j/rxjava3/ratelimiter/operator/MaybeRateLimiter.java
Patch:
@@ -68,7 +68,7 @@ protected void hookOnError(Throwable e) {
         }
 
         @Override
-        protected void hookOnSuccess() {
+        protected void hookOnSuccess(T value) {
             // NoOp
         }
 

File: resilience4j-rxjava3/src/main/java/io/github/resilience4j/rxjava3/ratelimiter/operator/SingleRateLimiter.java
Patch:
@@ -63,7 +63,7 @@ protected void hookOnError(Throwable e) {
         }
 
         @Override
-        protected void hookOnSuccess() {
+        protected void hookOnSuccess(T value) {
             // NoOp
         }
 

File: resilience4j-vertx/src/main/java/io/github/resilience4j/circuitbreaker/VertxCircuitBreaker.java
Patch:
@@ -69,7 +69,7 @@ static <T> Supplier<Future<T>> decorateFuture(CircuitBreaker circuitBreaker,
                                 .onError(durationInNanos, TimeUnit.NANOSECONDS, result.cause());
                             future.fail(result.cause());
                         } else {
-                            circuitBreaker.onSuccess(durationInNanos, TimeUnit.NANOSECONDS);
+                            circuitBreaker.onResult(durationInNanos, TimeUnit.NANOSECONDS, result);
                             future.complete(result.result());
                         }
                     });

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/BulkheadRegistry.java
Patch:
@@ -282,7 +282,7 @@ static Builder custom() {
     class Builder {
 
         private static final String DEFAULT_CONFIG = "default";
-        private RegistryStore registryStore;
+        private RegistryStore<Bulkhead> registryStore;
         private Map<String, BulkheadConfig> bulkheadConfigsMap;
         private List<RegistryEventConsumer<Bulkhead>> registryEventConsumers;
         private io.vavr.collection.Map<String, String> tags;
@@ -292,7 +292,7 @@ public Builder() {
             this.registryEventConsumers = new ArrayList<>();
         }
 
-        public Builder withRegistryStore(RegistryStore registryStore) {
+        public Builder withRegistryStore(RegistryStore<Bulkhead> registryStore) {
             this.registryStore = registryStore;
             return this;
         }

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/ThreadPoolBulkheadRegistry.java
Patch:
@@ -306,7 +306,7 @@ static Builder custom() {
     class Builder {
 
         private static final String DEFAULT_CONFIG = "default";
-        private RegistryStore registryStore;
+        private RegistryStore<ThreadPoolBulkhead> registryStore;
         private Map<String, ThreadPoolBulkheadConfig> threadPoolBulkheadConfigsMap;
         private List<RegistryEventConsumer<ThreadPoolBulkhead>> registryEventConsumers;
         private io.vavr.collection.Map<String, String> tags;
@@ -316,7 +316,7 @@ public Builder() {
             this.registryEventConsumers = new ArrayList<>();
         }
 
-        public Builder withRegistryStore(RegistryStore registryStore) {
+        public Builder withRegistryStore(RegistryStore<ThreadPoolBulkhead> registryStore) {
             this.registryStore = registryStore;
             return this;
         }

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/BulkheadRegistryTest.java
Patch:
@@ -360,7 +360,7 @@ public void testCreateUsingBuilderWithRegistryTags() {
     public void testCreateUsingBuilderWithRegistryStore() {
         BulkheadRegistry bulkheadRegistry = BulkheadRegistry.custom()
             .withBulkheadConfig(BulkheadConfig.ofDefaults())
-            .withRegistryStore(new InMemoryRegistryStore())
+            .withRegistryStore(new InMemoryRegistryStore<>())
             .build();
         Bulkhead bulkhead = bulkheadRegistry.bulkhead("testName");
         Bulkhead bulkhead2 = bulkheadRegistry.bulkhead("otherTestName");

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/ThreadPoolBulkheadRegistryTest.java
Patch:
@@ -367,7 +367,7 @@ public void testCreateUsingBuilderWithRegistryTags() {
     public void testCreateUsingBuilderWithRegistryStore() {
         ThreadPoolBulkheadRegistry threadPoolBulkheadRegistry = ThreadPoolBulkheadRegistry.custom()
             .withThreadPoolBulkheadConfig(ThreadPoolBulkheadConfig.ofDefaults())
-            .withRegistryStore(new InMemoryRegistryStore())
+            .withRegistryStore(new InMemoryRegistryStore<>())
             .build();
         ThreadPoolBulkhead threadPoolBulkhead = threadPoolBulkheadRegistry.bulkhead("testName");
         ThreadPoolBulkhead threadPoolBulkhead2 = threadPoolBulkheadRegistry.bulkhead("otherTestName");

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/internal/FixedThreadPoolBulkheadTest.java
Patch:
@@ -124,7 +124,7 @@ public void shouldCreateThreadPoolBulkheadRegistryWithRegistryStore() {
         configs.put("default", defaultConfig);
         final InMemoryThreadPoolBulkheadRegistry inMemoryThreadPoolBulkheadRegistry =
             new InMemoryThreadPoolBulkheadRegistry(configs, registryEventConsumers,
-                io.vavr.collection.HashMap.of("Tag1", "Tag1Value"), new InMemoryRegistryStore());
+                io.vavr.collection.HashMap.of("Tag1", "Tag1Value"), new InMemoryRegistryStore<>());
 
         AssertionsForClassTypes.assertThat(inMemoryThreadPoolBulkheadRegistry).isNotNull();
         AssertionsForClassTypes.assertThat(inMemoryThreadPoolBulkheadRegistry.getDefaultConfig()).isEqualTo(defaultConfig);

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/internal/SemaphoreBulkheadTest.java
Patch:
@@ -533,7 +533,7 @@ public void shouldCreateBulkheadRegistryWithRegistryStore() {
         configs.put("default", defaultConfig);
         final InMemoryBulkheadRegistry inMemoryBulkheadRegistry =
             new InMemoryBulkheadRegistry(configs, registryEventConsumers,
-                io.vavr.collection.HashMap.of("Tag1", "Tag1Value"), new InMemoryRegistryStore());
+                io.vavr.collection.HashMap.of("Tag1", "Tag1Value"), new InMemoryRegistryStore<>());
 
         AssertionsForClassTypes.assertThat(inMemoryBulkheadRegistry).isNotNull();
         AssertionsForClassTypes.assertThat(inMemoryBulkheadRegistry.getDefaultConfig()).isEqualTo(defaultConfig);

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreakerRegistry.java
Patch:
@@ -275,7 +275,7 @@ static Builder custom() {
     class Builder {
 
         private static final String DEFAULT_CONFIG = "default";
-        private RegistryStore registryStore;
+        private RegistryStore<CircuitBreaker> registryStore;
         private Map<String, CircuitBreakerConfig> circuitBreakerConfigsMap;
         private List<RegistryEventConsumer<CircuitBreaker>> registryEventConsumers;
         private io.vavr.collection.Map<String, String> tags;
@@ -285,7 +285,7 @@ public Builder() {
             this.registryEventConsumers = new ArrayList<>();
         }
 
-        public Builder withRegistryStore(RegistryStore registryStore) {
+        public Builder withRegistryStore(RegistryStore<CircuitBreaker> registryStore) {
             this.registryStore = registryStore;
             return this;
         }

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerRegistryTest.java
Patch:
@@ -404,7 +404,7 @@ public void testCreateUsingBuilderWithRegistryTags() {
     public void testCreateUsingBuilderWithRegistryStore() {
         CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.custom()
             .withCircuitBreakerConfig(CircuitBreakerConfig.ofDefaults())
-            .withRegistryStore(new InMemoryRegistryStore())
+            .withRegistryStore(new InMemoryRegistryStore<>())
             .build();
         CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("testName");
         CircuitBreaker circuitBreaker2 = circuitBreakerRegistry.circuitBreaker("otherTestName");

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/InMemoryCircuitBreakerRegistryTest.java
Patch:
@@ -115,7 +115,7 @@ public void shouldCreateCircuitBreakerRegistryWithRegistryStore() {
         configs.put("default", defaultConfig);
         final InMemoryCircuitBreakerRegistry inMemoryCircuitBreakerRegistry =
             new InMemoryCircuitBreakerRegistry(configs, registryEventConsumers,
-                io.vavr.collection.HashMap.of("Tag1", "Tag1Value"), new InMemoryRegistryStore());
+                io.vavr.collection.HashMap.of("Tag1", "Tag1Value"), new InMemoryRegistryStore<>());
 
         assertThat(inMemoryCircuitBreakerRegistry).isNotNull();
         assertThat(inMemoryCircuitBreakerRegistry.getDefaultConfig()).isEqualTo(defaultConfig);

File: resilience4j-core/src/test/java/io/github/resilience4j/core/registry/AbstractRegistryTest.java
Patch:
@@ -168,7 +168,7 @@ static class TestRegistry extends AbstractRegistry<String, String> {
             this.configurations.put(DEFAULT_CONFIG, "default");
         }
 
-        TestRegistry(List<RegistryEventConsumer<String>> registryEventConsumer, Map<String,String> tags, RegistryStore registryStore) {
+        TestRegistry(List<RegistryEventConsumer<String>> registryEventConsumer, Map<String,String> tags, RegistryStore<String> registryStore) {
             super("default", registryEventConsumer, tags, registryStore);
             this.configurations.put(DEFAULT_CONFIG, "default");
         }
@@ -198,7 +198,7 @@ public void onEntryReplacedEvent(EntryReplacedEvent<String> entryReplacedEvent)
         List<RegistryEventConsumer<String>> registryEventConsumers = new ArrayList<>();
         registryEventConsumers.add(registryEventConsumer);
         TestRegistry testRegistry  = new TestRegistry(
-            registryEventConsumers, io.vavr.collection.HashMap.of("Tag1","Tag1Value"), new InMemoryRegistryStore());
+            registryEventConsumers, io.vavr.collection.HashMap.of("Tag1","Tag1Value"), new InMemoryRegistryStore<>());
 
         assertEquals("Wrong Value", "default", testRegistry.getDefaultConfig());
         assertThat(testRegistry.getDefaultConfig()).isEqualTo("default");

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiterRegistry.java
Patch:
@@ -265,7 +265,7 @@ static Builder custom() {
     class Builder {
 
         private static final String DEFAULT_CONFIG = "default";
-        private RegistryStore registryStore;
+        private RegistryStore<RateLimiter> registryStore;
         private Map<String, RateLimiterConfig> rateLimiterConfigsMap;
         private List<RegistryEventConsumer<RateLimiter>> registryEventConsumers;
         private io.vavr.collection.Map<String, String> tags;
@@ -275,7 +275,7 @@ public Builder() {
             this.registryEventConsumers = new ArrayList<>();
         }
 
-        public Builder withRegistryStore(RegistryStore registryStore) {
+        public Builder withRegistryStore(RegistryStore<RateLimiter> registryStore) {
             this.registryStore = registryStore;
             return this;
         }

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterRegistryTest.java
Patch:
@@ -327,7 +327,7 @@ public void testCreateUsingBuilderWithRegistryTags() {
     public void testCreateUsingBuilderWithRegistryStore() {
         RateLimiterRegistry rateLimiterRegistry = RateLimiterRegistry.custom()
             .withRateLimiterConfig(RateLimiterConfig.ofDefaults())
-            .withRegistryStore(new InMemoryRegistryStore())
+            .withRegistryStore(new InMemoryRegistryStore<>())
             .build();
         RateLimiter rateLimiter = rateLimiterRegistry.rateLimiter("testName");
         RateLimiter rateLimiter2 = rateLimiterRegistry.rateLimiter("otherTestName");

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/InMemoryRateLimiterRegistryTest.java
Patch:
@@ -158,7 +158,7 @@ public void shouldCreateRateLimiterRegistryWithRegistryStore() {
         configs.put("default", defaultConfig);
         final InMemoryRateLimiterRegistry inMemoryRateLimiterRegistry =
             new InMemoryRateLimiterRegistry(configs, registryEventConsumers,
-                io.vavr.collection.HashMap.of("Tag1", "Tag1Value"), new InMemoryRegistryStore());
+                io.vavr.collection.HashMap.of("Tag1", "Tag1Value"), new InMemoryRegistryStore<>());
 
         AssertionsForClassTypes.assertThat(inMemoryRateLimiterRegistry).isNotNull();
         AssertionsForClassTypes.assertThat(inMemoryRateLimiterRegistry.getDefaultConfig()).isEqualTo(defaultConfig);

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/RetryRegistry.java
Patch:
@@ -261,7 +261,7 @@ static Builder custom() {
     class Builder {
 
         private static final String DEFAULT_CONFIG = "default";
-        private RegistryStore registryStore;
+        private RegistryStore<Retry> registryStore;
         private Map<String, RetryConfig> retryConfigsMap;
         private List<RegistryEventConsumer<Retry>> registryEventConsumers;
         private io.vavr.collection.Map<String, String> tags;
@@ -271,7 +271,7 @@ public Builder() {
             this.registryEventConsumers = new ArrayList<>();
         }
 
-        public Builder withRegistryStore(RegistryStore registryStore) {
+        public Builder withRegistryStore(RegistryStore<Retry> registryStore) {
             this.registryStore = registryStore;
             return this;
         }

File: resilience4j-retry/src/test/java/io/github/resilience4j/retry/RetryRegistryTest.java
Patch:
@@ -383,7 +383,7 @@ public void testCreateUsingBuilderWithRegistryTags() {
     public void testCreateUsingBuilderWithRegistryStore() {
         RetryRegistry retryRegistry = RetryRegistry.custom()
             .withRetryConfig(RetryConfig.ofDefaults())
-            .withRegistryStore(new InMemoryRegistryStore())
+            .withRegistryStore(new InMemoryRegistryStore<>())
             .build();
         Retry retry = retryRegistry.retry("testName");
         Retry retry2 = retryRegistry.retry("otherTestName");

File: resilience4j-retry/src/test/java/io/github/resilience4j/retry/internal/InMemoryRetryRegistryTest.java
Patch:
@@ -42,7 +42,7 @@ public void shouldCreateRetryRegistryWithRegistryStore() {
         configs.put("default", defaultConfig);
         final InMemoryRetryRegistry inMemoryRetryRegistry =
             new InMemoryRetryRegistry(configs, registryEventConsumers,
-                io.vavr.collection.HashMap.of("Tag1", "Tag1Value"), new InMemoryRegistryStore());
+                io.vavr.collection.HashMap.of("Tag1", "Tag1Value"), new InMemoryRegistryStore<>());
 
         assertThat(inMemoryRetryRegistry).isNotNull();
         assertThat(inMemoryRetryRegistry.getDefaultConfig()).isEqualTo(defaultConfig);

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/retry/configuration/RetryConfigurationPropertiesTest.java
Patch:
@@ -134,14 +134,14 @@ public void testCreateRetryPropertiesWithSharedConfigs() {
             .createRetryConfig("backendWithDefaultConfig", compositeRetryCustomizer());
         assertThat(retry1).isNotNull();
         assertThat(retry1.getMaxAttempts()).isEqualTo(3);
-        assertThat(retry1.getIntervalFunction().apply(1)).isEqualTo(200L);
+        assertThat(retry1.getIntervalBiFunction().apply(1, null)).isEqualTo(200L);
 
         // Should get shared config and overwrite wait time
         RetryConfig retry2 = retryConfigurationProperties
             .createRetryConfig("backendWithSharedConfig", compositeRetryCustomizer());
         assertThat(retry2).isNotNull();
         assertThat(retry2.getMaxAttempts()).isEqualTo(2);
-        assertThat(retry2.getIntervalFunction().apply(1)).isEqualTo(300L);
+        assertThat(retry2.getIntervalBiFunction().apply(1, null)).isEqualTo(300L);
 
         // Unknown backend should get default config of Registry
         RetryConfig retry3 = retryConfigurationProperties

File: resilience4j-spring/src/test/java/io/github/resilience4j/retry/configure/RetryConfigurationTest.java
Patch:
@@ -87,12 +87,12 @@ public void testCreateRetryRegistryWithSharedConfigs() {
         Retry retry1 = retryRegistry.retry("backendWithDefaultConfig");
         assertThat(retry1).isNotNull();
         assertThat(retry1.getRetryConfig().getMaxAttempts()).isEqualTo(3);
-        assertThat(retry1.getRetryConfig().getIntervalFunction().apply(1)).isEqualTo(200L);
+        assertThat(retry1.getRetryConfig().getIntervalBiFunction().apply(1, null)).isEqualTo(200L);
         // Should get shared config and overwrite wait time
         Retry retry2 = retryRegistry.retry("backendWithSharedConfig");
         assertThat(retry2).isNotNull();
         assertThat(retry2.getRetryConfig().getMaxAttempts()).isEqualTo(2);
-        assertThat(retry2.getRetryConfig().getIntervalFunction().apply(1)).isEqualTo(300L);
+        assertThat(retry2.getRetryConfig().getIntervalBiFunction().apply(1, null)).isEqualTo(300L);
         // Unknown backend should get default config of Registry
         Retry retry3 = retryRegistry.retry("unknownBackend");
         assertThat(retry3).isNotNull();

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreakerConfig.java
Patch:
@@ -403,7 +403,7 @@ public Builder slowCallDurationThreshold(Duration slowCallDurationThreshold) {
          * @param maxWaitDurationInHalfOpenState the wait duration which specifies how long the
          *                                CircuitBreaker should stay in Half Open
          * @return the CircuitBreakerConfig.Builder
-         * @throws IllegalArgumentException if {@code waitDurationInOpenState.toMillis() < 1000}
+         * @throws IllegalArgumentException if {@code maxWaitDurationInHalfOpenState.toMillis() < 1}
          */
         public Builder maxWaitDurationInHalfOpenState(Duration maxWaitDurationInHalfOpenState) {
             if (maxWaitDurationInHalfOpenState.toMillis() < 1) {

File: resilience4j-spring/src/main/java/io/github/resilience4j/timelimiter/configure/TimeLimiterAspect.java
Patch:
@@ -45,8 +45,7 @@ public class TimeLimiterAspect implements Ordered, AutoCloseable {
 
     private final TimeLimiterRegistry timeLimiterRegistry;
     private final TimeLimiterConfigurationProperties properties;
-    private static final ScheduledExecutorService timeLimiterExecutorService = Executors
-        .newScheduledThreadPool(Runtime.getRuntime().availableProcessors());
+    private final ScheduledExecutorService timeLimiterExecutorService;
     @Nullable
     private final List<TimeLimiterAspectExt> timeLimiterAspectExtList;
     private final FallbackDecorators fallbackDecorators;
@@ -62,6 +61,7 @@ public TimeLimiterAspect(TimeLimiterRegistry timeLimiterRegistry,
         this.timeLimiterAspectExtList = timeLimiterAspectExtList;
         this.fallbackDecorators = fallbackDecorators;
         this.spelResolver = spelResolver;
+        this.timeLimiterExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());
     }
 
     @Pointcut(value = "@within(timeLimiter) || @annotation(timeLimiter)", argNames = "timeLimiter")
@@ -139,7 +139,7 @@ private static TimeLimiter getTimeLimiterAnnotation(ProceedingJoinPoint proceedi
         }
     }
 
-    private static Object handleJoinPointCompletableFuture(
+    private Object handleJoinPointCompletableFuture(
             ProceedingJoinPoint proceedingJoinPoint, io.github.resilience4j.timelimiter.TimeLimiter timeLimiter) throws Throwable {
         return timeLimiter.executeCompletionStage(timeLimiterExecutorService, () -> {
             try {

File: resilience4j-consumer/src/main/java/io/github/resilience4j/consumer/CircularEventConsumer.java
Patch:
@@ -24,11 +24,11 @@
 import io.vavr.collection.List;
 
 /**
- * A RxJava consumer which stores CircuitBreakerEvents in a circular buffer with a fixed capacity.
+ * A consumer which stores CircuitBreakerEvents in a circular buffer with a fixed capacity.
  */
 public class CircularEventConsumer<T> implements EventConsumer<T> {
 
-    private CircularFifoBuffer<T> eventCircularFifoBuffer;
+    private final CircularFifoBuffer<T> eventCircularFifoBuffer;
 
     /**
      * Creates an {@code CircuitBreakerEventConsumer} with the given (fixed) capacity

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerStreamEventsAutoConfiguration.java
Patch:
@@ -25,7 +25,6 @@
 import org.springframework.boot.actuate.endpoint.annotation.Endpoint;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
-import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 import reactor.core.publisher.Flux;

File: resilience4j-spring/src/main/java/io/github/resilience4j/retry/configure/RetryAspect.java
Patch:
@@ -148,7 +148,7 @@ private io.github.resilience4j.retry.Retry getOrCreateRetry(String methodName, S
         if (logger.isDebugEnabled()) {
             logger.debug(
                 "Created or retrieved retry '{}' with max attempts rate '{}'  for method: '{}'",
-                backend, retry.getRetryConfig().getResultPredicate(), methodName);
+                backend, retry.getRetryConfig().getMaxAttempts(), methodName);
         }
         return retry;
     }

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java
Patch:
@@ -48,7 +48,7 @@
 @AutoConfigureWebTestClient(timeout="36000")
 public class CircuitBreakerHystrixStreamEventsTest {
 
-    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = "/actuator/hystrix-stream-circuitbreaker-events";
+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = "/actuator/hystrixstreamcircuitbreakerevents";
     public static final String ACTUATOR_CIRCUITBREAKEREVENTS = "/actuator/circuitbreakerevents";
 
     @LocalServerPort

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerStreamEventsTest.java
Patch:
@@ -48,7 +48,7 @@
 @AutoConfigureWebTestClient(timeout="36000")
 public class CircuitBreakerStreamEventsTest {
 
-    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = "/actuator/stream-circuitbreaker-events";
+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = "/actuator/streamcircuitbreakerevents";
     public static final String ACTUATOR_CIRCUITBREAKEREVENTS = "/actuator/circuitbreakerevents";
     @LocalServerPort
     int randomServerPort;

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerStreamEventsAutoConfiguration.java
Patch:
@@ -31,21 +31,19 @@
 import reactor.core.publisher.Flux;
 
 @Configuration
-@ConditionalOnClass({CircuitBreaker.class, Endpoint.class})
+@ConditionalOnClass({CircuitBreaker.class, Endpoint.class, Flux.class, ReactorAdapter.class})
 @AutoConfigureAfter(CircuitBreakerAutoConfiguration.class)
 public class CircuitBreakerStreamEventsAutoConfiguration {
 
     @Bean
     @ConditionalOnAvailableEndpoint
-    @ConditionalOnClass({Flux.class, ReactorAdapter.class})
     public CircuitBreakerServerSideEvent circuitBreakerServerSideEventEndpoint(
         CircuitBreakerRegistry circuitBreakerRegistry) {
         return new CircuitBreakerServerSideEvent(circuitBreakerRegistry);
     }
 
     @Bean
     @ConditionalOnAvailableEndpoint
-    @ConditionalOnClass({Flux.class, ReactorAdapter.class})
     public CircuitBreakerHystrixServerSideEvent circuitBreakerHystrixServerSideEventEndpoint(
         CircuitBreakerRegistry circuitBreakerRegistry) {
         return new CircuitBreakerHystrixServerSideEvent(circuitBreakerRegistry);

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/circuitbreaker/configuration/CircuitBreakerConfigurationPropertiesTest.java
Patch:
@@ -118,6 +118,7 @@ public void testCircuitBreakerIntervalFunctionProperties() {
         CircuitBreakerConfigurationProperties.InstanceProperties instanceProperties2 = new CircuitBreakerConfigurationProperties.InstanceProperties();
         instanceProperties2.setEnableExponentialBackoff(true);
         instanceProperties2.setExponentialBackoffMultiplier(1.0);
+        instanceProperties2.setExponentialMaxWaitDurationInOpenState(Duration.ofMillis(99L));
         instanceProperties2.setWaitDurationInOpenState(Duration.ofMillis(100L));
 
         CircuitBreakerConfigurationProperties circuitBreakerConfigurationProperties = new CircuitBreakerConfigurationProperties();
@@ -144,8 +145,7 @@ public void testCircuitBreakerIntervalFunctionProperties() {
         assertThat(circuitBreakerConfig1.getWaitIntervalFunctionInOpenState()).isNotNull();
         assertThat(circuitBreakerConfig2).isNotNull();
         assertThat(circuitBreakerConfig2.getWaitIntervalFunctionInOpenState()).isNotNull();
-
-
+        assertThat(circuitBreakerConfig2.getWaitIntervalFunctionInOpenState().apply(1)).isEqualTo(99L);
     }
 
     @Test

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationTest.java
Patch:
@@ -115,7 +115,7 @@ public void testCircuitBreakerActuatorEndpoint() {
         assertThat(backendAState.getBody().getCurrentState()).isEqualTo(CircuitBreaker.State.FORCED_OPEN.toString());
         assertThat(circuitBreakerRegistry.circuitBreaker("backendA").getState()).isEqualTo(CircuitBreaker.State.FORCED_OPEN);
 
-        // when sending non valid statte change
+        // when sending non valid state change
         HttpEntity<String> nonValid = new HttpEntity<>("{\"updateState\":\"BLA_BLA\"}", headers);
         final ResponseEntity<CircuitBreakerUpdateStateResponse> nonValidResponse = restTemplate
             .postForEntity("/actuator/circuitbreakers/backendA", nonValid, CircuitBreakerUpdateStateResponse.class);
@@ -331,9 +331,9 @@ public void shouldDefineWaitIntervalFunctionInOpenStateForCircuitBreakerAutoConf
 
         assertThat(backendConfig.getWaitIntervalFunctionInOpenState()).isNotNull();
         assertThat(backendConfig.getWaitIntervalFunctionInOpenState().apply(1)).isEqualTo(1000);
+        assertThat(backendConfig.getWaitIntervalFunctionInOpenState().apply(2)).isEqualTo(1111);
         assertThat(backendConfig.getWaitDurationInOpenState())
             .isEqualByComparingTo(Duration.ofSeconds(1L));
-
     }
 
     /**

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/utils/SpringConfigUtilsTest.java
Patch:
@@ -76,18 +76,21 @@ public void testRetrySpringProperties() {
         sharedProperties.setWaitDuration(Duration.ofMillis(100));
         sharedProperties.setEnableRandomizedWait(true);
         sharedProperties.setExponentialBackoffMultiplier(0.1);
+        sharedProperties.setExponentialMaxWaitDuration(Duration.ofMinutes(2));
         sharedProperties.setEnableExponentialBackoff(false);
 
         RetryConfigurationProperties.InstanceProperties backendWithDefaultConfig = new RetryConfigurationProperties.InstanceProperties();
         backendWithDefaultConfig.setBaseConfig("default");
         backendWithDefaultConfig.setWaitDuration(Duration.ofMillis(200L));
         assertThat(backendWithDefaultConfig.getEnableExponentialBackoff()).isNull();
         assertThat(backendWithDefaultConfig.getExponentialBackoffMultiplier()).isNull();
+        assertThat(backendWithDefaultConfig.getExponentialMaxWaitDuration()).isNull();
         assertThat(backendWithDefaultConfig.getEnableRandomizedWait()).isNull();
 
         ConfigUtils.mergePropertiesIfAny(sharedProperties, backendWithDefaultConfig);
         assertThat(backendWithDefaultConfig.getEnableExponentialBackoff()).isFalse();
         assertThat(backendWithDefaultConfig.getExponentialBackoffMultiplier()).isEqualTo(0.1);
+        assertThat(backendWithDefaultConfig.getExponentialMaxWaitDuration()).isEqualTo(Duration.ofMinutes(2));
         assertThat(backendWithDefaultConfig.getEnableRandomizedWait()).isTrue();
     }
 

File: resilience4j-timelimiter/src/test/java/io/github/resilience4j/timelimiter/internal/TimeLimiterTest.java
Patch:
@@ -9,7 +9,6 @@
 import java.util.concurrent.*;
 import java.util.function.Supplier;
 
-import static io.github.resilience4j.timelimiter.internal.TimeLimiterImpl.createdTimeoutExceptionWithName;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.BDDMockito.given;
 import static org.mockito.BDDMockito.then;
@@ -49,7 +48,7 @@ public void shouldThrowTimeoutExceptionAndInvokeCancel() throws Exception {
 
         assertThat(decoratedResult.isFailure()).isTrue();
         assertThat(decoratedResult.getCause()).isInstanceOf(TimeoutException.class);
-        assertThat(decoratedResult.getCause()).hasMessage(createdTimeoutExceptionWithName(TIME_LIMITER_NAME).getMessage());
+        assertThat(decoratedResult.getCause()).hasMessage(TimeLimiter.createdTimeoutExceptionWithName(TIME_LIMITER_NAME, null).getMessage());
 
         then(mockFuture).should().cancel(true);
     }

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/RetryConfig.java
Patch:
@@ -33,7 +33,7 @@ public class RetryConfig implements Serializable {
     private static final long serialVersionUID = 3522903275067138911L;
 
     public static final long DEFAULT_WAIT_DURATION = 500;
-    private static final int DEFAULT_MAX_ATTEMPTS = 3;
+    public static final int DEFAULT_MAX_ATTEMPTS = 3;
     private static final IntervalFunction DEFAULT_INTERVAL_FUNCTION = numOfAttempts -> DEFAULT_WAIT_DURATION;
     private static final Predicate<Throwable> DEFAULT_RECORD_FAILURE_PREDICATE = throwable -> true;
 

File: resilience4j-spring/src/main/java/io/github/resilience4j/fallback/FallbackMethod.java
Patch:
@@ -202,7 +202,7 @@ private Object invoke(Method fallback, Throwable throwable) throws Throwable {
                 ReflectionUtils.makeAccessible(fallback);
             }
             if (args.length != 0) {
-                if (args.length == 1 && Throwable.class
+                if (fallback.getParameterTypes().length == 1 && Throwable.class
                     .isAssignableFrom(fallback.getParameterTypes()[0])) {
                     return fallback.invoke(target, throwable);
                 }

File: resilience4j-micrometer/src/main/java/io/github/resilience4j/micrometer/tagged/CircuitBreakerMetricNames.java
Patch:
@@ -7,7 +7,7 @@ public class CircuitBreakerMetricNames {
     private static final String DEFAULT_PREFIX = "resilience4j.circuitbreaker";
 
     public static final String DEFAULT_CIRCUIT_BREAKER_CALLS = DEFAULT_PREFIX + ".calls";
-    public static final String DEFAULT_CIRCUIT_BREAKER_NOT_PERMITTED_CALLS = DEFAULT_PREFIX + "not.permitted.calls";
+    public static final String DEFAULT_CIRCUIT_BREAKER_NOT_PERMITTED_CALLS = DEFAULT_PREFIX + ".not.permitted.calls";
     public static final String DEFAULT_CIRCUIT_BREAKER_STATE = DEFAULT_PREFIX + ".state";
     public static final String DEFAULT_CIRCUIT_BREAKER_BUFFERED_CALLS =
         DEFAULT_PREFIX + ".buffered.calls";

File: resilience4j-core/src/main/java/io/github/resilience4j/core/IntervalFunction.java
Patch:
@@ -247,9 +247,9 @@ static double randomize(final double current, final double randomizationFactor)
     }
 
     static void checkInterval(long interval) {
-        if (interval < 10) {
+        if (interval < 1) {
             throw new IllegalArgumentException(
-                "Illegal argument interval: " + interval + " millis");
+                "Illegal argument interval: " + interval + " millis is less than 1");
         }
     }
 

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/retry/RetryAutoConfigurationAsyncTest.java
Patch:
@@ -92,7 +92,7 @@ public void testRetryAutoConfigurationAsync() throws Throwable {
         assertThat(retry).isNotNull();
 
         // expect retry is configured as defined in application.yml
-        assertThat(retry.getRetryConfig().getMaxAttempts()).isEqualTo(3);
+        assertThat(retry.getRetryConfig().getMaxAttempts()).isEqualTo(4);
         assertThat(retry.getName()).isEqualTo(RETRY_BACKEND_B);
         assertThat(retry.getRetryConfig().getExceptionPredicate().test(new IOException())).isTrue();
 
@@ -106,11 +106,11 @@ public void testRetryAutoConfigurationAsync() throws Throwable {
         // expect retry-event actuator endpoint recorded both events
         RetryEventsEndpointResponse retryEventList = retryEvents("/actuator/retryevents");
         assertThat(retryEventList.getRetryEvents())
-            .hasSize(retryEventListBefore.getRetryEvents().size() + 3);
+            .hasSize(retryEventListBefore.getRetryEvents().size() + 4);
 
         retryEventList = retryEvents("/actuator/retryevents/" + RETRY_BACKEND_B);
         assertThat(retryEventList.getRetryEvents())
-            .hasSize(retryEventListForBBefore.getRetryEvents().size() + 3);
+            .hasSize(retryEventListForBBefore.getRetryEvents().size() + 4);
 
         assertThat(retry.getRetryConfig().getExceptionPredicate().test(new IOException())).isTrue();
         assertThat(retry.getRetryConfig().getExceptionPredicate().test(new IgnoredException()))

File: resilience4j-spring/src/main/java/io/github/resilience4j/utils/AspectJOnClasspathCondition.java
Patch:
@@ -29,7 +29,7 @@ public class AspectJOnClasspathCondition implements Condition {
     @Override
     public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
         return AspectUtil.checkClassIfFound(context, CLASS_TO_CHECK, (e) -> logger
-            .info("Aspects are not activated because AspectJ is not on the classpath."));
+            .debug("Aspects are not activated because AspectJ is not on the classpath."));
     }
 
 }

File: resilience4j-spring/src/main/java/io/github/resilience4j/utils/ReactorOnClasspathCondition.java
Patch:
@@ -33,9 +33,9 @@ public class ReactorOnClasspathCondition implements Condition {
 
     @Override
     public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
-        return AspectUtil.checkClassIfFound(context, CLASS_TO_CHECK, (e) -> logger.info(
+        return AspectUtil.checkClassIfFound(context, CLASS_TO_CHECK, (e) -> logger.debug(
             "Reactor related Aspect extensions are not activated because Reactor is not on the classpath."))
-            && AspectUtil.checkClassIfFound(context, R4J_REACTOR, (e) -> logger.info(
+            && AspectUtil.checkClassIfFound(context, R4J_REACTOR, (e) -> logger.debug(
             "Reactor related Aspect extensions are not activated because Resilience4j Reactor module is not on the classpath."));
     }
 

File: resilience4j-spring/src/main/java/io/github/resilience4j/utils/RxJava2OnClasspathCondition.java
Patch:
@@ -33,9 +33,9 @@ public class RxJava2OnClasspathCondition implements Condition {
 
     @Override
     public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
-        return AspectUtil.checkClassIfFound(context, CLASS_TO_CHECK, (e) -> logger.info(
+        return AspectUtil.checkClassIfFound(context, CLASS_TO_CHECK, (e) -> logger.debug(
             "RxJava2 related Aspect extensions are not activated, because RxJava2 is not on the classpath."))
-            && AspectUtil.checkClassIfFound(context, R4J_RXJAVA, (e) -> logger.info(
+            && AspectUtil.checkClassIfFound(context, R4J_RXJAVA, (e) -> logger.debug(
             "RxJava2 related Aspect extensions are not activated because Resilience4j RxJava2 module is not on the classpath."));
     }
 }

File: resilience4j-metrics/src/main/java/io/github/resilience4j/metrics/publisher/CircuitBreakerMetricsPublisher.java
Patch:
@@ -82,7 +82,8 @@ public void publishMetrics(CircuitBreaker circuitBreaker) {
             (Gauge<Float>) () -> circuitBreaker.getMetrics().getSlowCallRate());
 
         List<String> metricNames = Arrays
-            .asList(state, successful, failed, notPermitted, numberOfBufferedCalls, failureRate);
+            .asList(state, successful, failed, notPermitted, numberOfBufferedCalls, failureRate,
+                slow, slowSuccess, slowFailed, slowCallRate);
         metricsNameMap.put(name, new HashSet<>(metricNames));
     }
 

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerStateMachineTest.java
Patch:
@@ -33,6 +33,7 @@
 import java.time.ZoneId;
 import java.util.concurrent.TimeUnit;
 
+import static io.github.resilience4j.circuitbreaker.CircuitBreaker.State.FORCED_OPEN;
 import static io.github.resilience4j.circuitbreaker.CircuitBreakerConfig.SlidingWindowType;
 import static io.github.resilience4j.circuitbreaker.CircuitBreakerConfig.custom;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
@@ -518,7 +519,7 @@ public void shouldForceOpenCircuitBreaker() {
             .transitionToForcedOpenState(); // Should create a CircuitBreakerOnStateTransitionEvent
 
         assertThat(circuitBreaker.getState()).isEqualTo(
-            CircuitBreaker.State.FORCED_OPEN); // Should create a CircuitBreakerOnStateTransitionEvent
+            FORCED_OPEN); // Should create a CircuitBreakerOnStateTransitionEvent
 
         assertThat(circuitBreaker.tryAcquirePermission()).isEqualTo(false);
 
@@ -529,7 +530,7 @@ public void shouldForceOpenCircuitBreaker() {
         // The CircuitBreaker should not transition to half open, even if the wait duration of 5 seconds is elapsed.
 
         assertThat(circuitBreaker.getState()).isEqualTo(
-            CircuitBreaker.State.FORCED_OPEN); // Should create a CircuitBreakerOnStateTransitionEvent
+            FORCED_OPEN); // Should create a CircuitBreakerOnStateTransitionEvent
         assertCircuitBreakerMetricsEqualTo(-1f, 0, 0, 0, 2L);
     }
 

File: resilience4j-micrometer/src/main/java/io/github/resilience4j/micrometer/tagged/AbstractCircuitBreakerMetrics.java
Patch:
@@ -130,7 +130,7 @@ private void registerMetrics(
             .tags(customTags)
             .register(meterRegistry);
 
-        Counter notPermittedCalls = Counter.builder(names.getCallsMetricName())
+        Counter notPermittedCalls = Counter.builder(names.getNotPermittedCallsMetricName())
             .description("Total number of not permitted calls")
             .tag(TagNames.NAME, circuitBreaker.getName())
             .tag(TagNames.KIND, KIND_NOT_PERMITTED)

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedCircuitBreakerMetricsPublisherTest.java
Patch:
@@ -107,7 +107,7 @@ public void notPermittedCallsCounterReportsCorrespondingValue() {
         List<Meter> meters = meterRegistry.getMeters();
         assertThat(meters).hasSize(16);
 
-        Collection<Counter> counters = meterRegistry.get(DEFAULT_CIRCUIT_BREAKER_CALLS).counters();
+        Collection<Counter> counters = meterRegistry.get(DEFAULT_CIRCUIT_BREAKER_NOT_PERMITTED_CALLS).counters();
 
         Optional<Counter> notPermitted = findMeterByKindAndNameTags(counters, "not_permitted",
             circuitBreaker.getName());
@@ -195,6 +195,7 @@ public void metricsAreRegisteredWithCustomName() {
         TaggedCircuitBreakerMetricsPublisher taggedCircuitBreakerMetricsPublisher = new TaggedCircuitBreakerMetricsPublisher(
             CircuitBreakerMetricNames.custom()
                 .callsMetricName("custom_calls")
+                .notPermittedCallsMetricName("custom_not_permitted_calls")
                 .stateMetricName("custom_state")
                 .bufferedCallsMetricName("custom_buffered_calls")
                 .slowCallsMetricName("custom_slow_calls")
@@ -214,6 +215,7 @@ public void metricsAreRegisteredWithCustomName() {
 
         assertThat(metricNames).hasSameElementsAs(Arrays.asList(
             "custom_calls",
+            "custom_not_permitted_calls",
             "custom_state",
             "custom_buffered_calls",
             "custom_slow_calls",

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedCircuitBreakerMetricsTest.java
Patch:
@@ -118,7 +118,7 @@ public void notPermittedCallsCounterReportsCorrespondingValue() {
         List<Meter> meters = meterRegistry.getMeters();
         assertThat(meters).hasSize(16);
 
-        Collection<Counter> counters = meterRegistry.get(DEFAULT_CIRCUIT_BREAKER_CALLS).counters();
+        Collection<Counter> counters = meterRegistry.get(DEFAULT_CIRCUIT_BREAKER_NOT_PERMITTED_CALLS).counters();
 
         Optional<Counter> notPermitted = findMeterByKindAndNameTags(counters, "not_permitted",
             circuitBreaker.getName());
@@ -210,6 +210,7 @@ public void metricsAreRegisteredWithCustomName() {
         TaggedCircuitBreakerMetrics.ofCircuitBreakerRegistry(
             CircuitBreakerMetricNames.custom()
                 .callsMetricName("custom_calls")
+                .notPermittedCallsMetricName("custom_not_permitted_calls")
                 .stateMetricName("custom_state")
                 .bufferedCallsMetricName("custom_buffered_calls")
                 .slowCallsMetricName("custom_slow_calls")
@@ -227,6 +228,7 @@ public void metricsAreRegisteredWithCustomName() {
 
         assertThat(metricNames).hasSameElementsAs(Arrays.asList(
             "custom_calls",
+            "custom_not_permitted_calls",
             "custom_state",
             "custom_buffered_calls",
             "custom_slow_calls",

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/SemaphoreBulkhead.java
Patch:
@@ -81,7 +81,7 @@ public SemaphoreBulkhead(String name, @Nullable BulkheadConfig bulkheadConfig,
         this.config = requireNonNull(bulkheadConfig, CONFIG_MUST_NOT_BE_NULL);
         this.tags = requireNonNull(tags, TAGS_MUST_NOTE_BE_NULL);
         // init semaphore
-        this.semaphore = new Semaphore(this.config.getMaxConcurrentCalls(), true);
+        this.semaphore = new Semaphore(config.getMaxConcurrentCalls(), config.isFairCallHandlingEnabled());
 
         this.metrics = new BulkheadMetrics();
         this.eventProcessor = new BulkheadEventProcessor();

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/internal/SemaphoreBulkheadTest.java
Patch:
@@ -38,8 +38,7 @@
 import java.util.function.Supplier;
 
 import static com.jayway.awaitility.Awaitility.await;
-import static io.github.resilience4j.bulkhead.BulkheadConfig.DEFAULT_MAX_CONCURRENT_CALLS;
-import static io.github.resilience4j.bulkhead.BulkheadConfig.DEFAULT_WRITABLE_STACK_TRACE_ENABLED;
+import static io.github.resilience4j.bulkhead.BulkheadConfig.*;
 import static io.github.resilience4j.bulkhead.event.BulkheadEvent.Type.*;
 import static java.lang.Thread.State.*;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -113,6 +112,8 @@ public void testCreateWithDefaults() {
             .isEqualTo(DEFAULT_MAX_CONCURRENT_CALLS);
         assertThat(bulkhead.getBulkheadConfig().isWritableStackTraceEnabled())
             .isEqualTo(DEFAULT_WRITABLE_STACK_TRACE_ENABLED);
+        assertThat(bulkhead.getBulkheadConfig().isFairCallHandlingEnabled())
+            .isEqualTo(DEFAULT_FAIR_CALL_HANDLING_STRATEGY_ENABLED);
     }
 
     @Test

File: resilience4j-spring/src/test/java/io/github/resilience4j/bulkhead/configure/BulkHeadConfigurationSpringTest.java
Patch:
@@ -134,7 +134,7 @@ private class ThreadPoolBulkheadConfigurationPropertiesTest extends ThreadPoolBu
 
             ThreadPoolBulkheadConfigurationPropertiesTest() {
                 InstanceProperties instanceProperties = new InstanceProperties();
-                instanceProperties.setContextPropagator(TestThreadLocalContextPropagator.class);
+                instanceProperties.setContextPropagators(TestThreadLocalContextPropagator.class);
                 getConfigs().put("sharedBackend", instanceProperties);
             }
 

File: resilience4j-spring/src/test/java/io/github/resilience4j/bulkhead/configure/BulkHeadConfigurationTest.java
Patch:
@@ -30,7 +30,7 @@ public void tesFixedThreadPoolBulkHeadRegistry() {
         //Given
         ThreadPoolBulkheadConfigurationProperties.InstanceProperties backendProperties1 = new ThreadPoolBulkheadConfigurationProperties.InstanceProperties();
         backendProperties1.setCoreThreadPoolSize(1);
-        backendProperties1.setContextPropagator(TestThreadLocalContextPropagator.class);
+        backendProperties1.setContextPropagators(TestThreadLocalContextPropagator.class);
 
         ThreadPoolBulkheadConfigurationProperties.InstanceProperties backendProperties2 = new ThreadPoolBulkheadConfigurationProperties.InstanceProperties();
         backendProperties2.setCoreThreadPoolSize(2);
@@ -79,7 +79,7 @@ public void testCreateThreadPoolBulkHeadRegistryWithSharedConfigs() {
         ThreadPoolBulkheadConfigurationProperties.InstanceProperties sharedProperties = new ThreadPoolBulkheadConfigurationProperties.InstanceProperties();
         sharedProperties.setCoreThreadPoolSize(2);
         sharedProperties.setQueueCapacity(2);
-        sharedProperties.setContextPropagator(TestThreadLocalContextPropagator.class);
+        sharedProperties.setContextPropagators(TestThreadLocalContextPropagator.class);
 
         ThreadPoolBulkheadConfigurationProperties.InstanceProperties backendWithDefaultConfig = new ThreadPoolBulkheadConfigurationProperties.InstanceProperties();
         backendWithDefaultConfig.setBaseConfig("default");
@@ -88,7 +88,7 @@ public void testCreateThreadPoolBulkHeadRegistryWithSharedConfigs() {
         ThreadPoolBulkheadConfigurationProperties.InstanceProperties backendWithSharedConfig = new ThreadPoolBulkheadConfigurationProperties.InstanceProperties();
         backendWithSharedConfig.setBaseConfig("sharedConfig");
         backendWithSharedConfig.setCoreThreadPoolSize(4);
-        backendWithSharedConfig.setContextPropagator(TestThreadLocalContextPropagator.class);
+        backendWithSharedConfig.setContextPropagators(TestThreadLocalContextPropagator.class);
 
         ThreadPoolBulkheadConfigurationProperties bulkheadConfigurationProperties = new ThreadPoolBulkheadConfigurationProperties();
         bulkheadConfigurationProperties.getConfigs().put("default", defaultProperties);

File: resilience4j-spring/src/test/java/io/github/resilience4j/bulkhead/configure/BulkheadBuilderCustomizerTest.java
Patch:
@@ -184,7 +184,7 @@ private class ThreadPoolBulkheadConfigurationPropertiesTest extends
                 InstanceProperties properties1 = new InstanceProperties();
                 properties1.setCoreThreadPoolSize(2);
                 properties1.setMaxThreadPoolSize(4);
-                properties1.setContextPropagator(TestThreadLocalContextPropagator.class);
+                properties1.setContextPropagators(TestThreadLocalContextPropagator.class);
                 getConfigs().put("backendA", properties1);
 
                 InstanceProperties properties2 = new InstanceProperties();

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/ThreadPoolBulkhead.java
Patch:
@@ -33,7 +33,7 @@
 /**
  * A Bulkhead instance is thread-safe can be used to decorate multiple requests.
  */
-public interface ThreadPoolBulkhead {
+public interface ThreadPoolBulkhead extends AutoCloseable {
 
     /**
      * Returns a supplier which submits a value-returning task for execution and

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/ThreadPoolBulkheadRegistry.java
Patch:
@@ -36,7 +36,7 @@
  * stores all bulkhead instances in a registry.
  */
 public interface ThreadPoolBulkheadRegistry extends
-    Registry<ThreadPoolBulkhead, ThreadPoolBulkheadConfig> {
+    Registry<ThreadPoolBulkhead, ThreadPoolBulkheadConfig>, AutoCloseable {
 
     /**
      * Creates a BulkheadRegistry with a custom Bulkhead configuration.

File: resilience4j-timelimiter/src/main/java/io/github/resilience4j/timelimiter/internal/TimeLimiterImpl.java
Patch:
@@ -76,7 +76,7 @@ public <T, F extends CompletionStage<T>> Supplier<CompletionStage<T>> decorateCo
             CompletableFuture<T> future = supplier.get().toCompletableFuture();
             ScheduledFuture<?> timeoutFuture =
                 Timeout
-                    .of(future, scheduler, getTimeLimiterConfig().getTimeoutDuration().toMillis(),
+                    .of(future, scheduler, name, getTimeLimiterConfig().getTimeoutDuration().toMillis(),
                         TimeUnit.MILLISECONDS);
 
             return future.whenComplete((result, throwable) -> {
@@ -177,11 +177,11 @@ private Timeout() {
         }
 
         static ScheduledFuture<?> of(
-            CompletableFuture<?> future, ScheduledExecutorService scheduler, long delay,
+            CompletableFuture<?> future, ScheduledExecutorService scheduler, String name, long delay,
             TimeUnit unit) {
             return scheduler.schedule(() -> {
                 if (future != null && !future.isDone()) {
-                    future.completeExceptionally(new TimeoutException());
+                    future.completeExceptionally(new TimeoutException(String.format("TimeLimiter '%s' recorded a timeout exception." , name)));
                 }
             }, delay, unit);
         }

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/retry/configuration/RetryConfigurationProperties.java
Patch:
@@ -276,9 +276,9 @@ public Duration getWaitDuration() {
 
         public InstanceProperties setWaitDuration(Duration waitDuration) {
             Objects.requireNonNull(waitDuration);
-            if (waitDuration.toMillis() < 100) {
+            if (waitDuration.toMillis() < 0) {
                 throw new IllegalArgumentException(
-                    "waitDurationInOpenStateMillis must be greater than or equal to 100 millis.");
+                    "waitDuration must be a positive value");
             }
 
             this.waitDuration = waitDuration;

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/retry/configuration/RetryConfigurationPropertiesTest.java
Patch:
@@ -154,7 +154,7 @@ public void testIllegalArgumentOnEventConsumerBufferSize() {
     @Test(expected = IllegalArgumentException.class)
     public void testIllegalArgumentOnWaitDuration() {
         RetryConfigurationProperties.InstanceProperties defaultProperties = new RetryConfigurationProperties.InstanceProperties();
-        defaultProperties.setWaitDuration(Duration.ofMillis(50));
+        defaultProperties.setWaitDuration(Duration.ofMillis(-1));
     }
 
     @Test(expected = IllegalArgumentException.class)

File: resilience4j-spring-cloud2/src/test/java/io/github/resilience4j/bulkhead/autoconfigure/RefreshScopedBulkheadConfigurationTest.java
Patch:
@@ -31,11 +31,11 @@
 import static java.util.Collections.emptyList;
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class AbstractRefreshScopedBulkheadConfigurationTest {
+public class RefreshScopedBulkheadConfigurationTest {
 
     @Test
     public void shouldHaveRefreshScopeAnnotation() {
-        Arrays.stream(AbstractRefreshScopedBulkheadConfiguration.class.getMethods())
+        Arrays.stream(RefreshScopedBulkheadAutoConfiguration.class.getMethods())
             .filter(method -> method.isAnnotationPresent(Bean.class))
             .forEach(method -> assertThat(method.isAnnotationPresent(RefreshScope.class)).isTrue());
     }
@@ -55,7 +55,7 @@ public void testBulkheadCloudCommonConfig() {
             new CompositeCustomizer<>(Collections.emptyList()))).isNotNull();
     }
 
-    static class BulkheadConfig extends AbstractRefreshScopedBulkheadConfiguration {
+    static class BulkheadConfig extends RefreshScopedBulkheadAutoConfiguration {
 
     }
 }
\ No newline at end of file

File: resilience4j-spring-cloud2/src/test/java/io/github/resilience4j/circuitbreaker/autoconfigure/RefreshScopedCircuitBreakerConfigurationTest.java
Patch:
@@ -30,11 +30,11 @@
 import static java.util.Collections.emptyList;
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class AbstractRefreshScopedCircuitBreakerConfigurationTest {
+public class RefreshScopedCircuitBreakerConfigurationTest {
 
     @Test
     public void testRefreshScopedCircuitBreakerConfig() {
-        Arrays.stream(AbstractRefreshScopedCircuitBreakerConfiguration.class.getMethods())
+        Arrays.stream(RefreshScopedCircuitBreakerAutoConfiguration.class.getMethods())
             .filter(method -> method.isAnnotationPresent(Bean.class))
             .forEach(method -> assertThat(method.isAnnotationPresent(RefreshScope.class)).isTrue());
     }
@@ -51,7 +51,7 @@ public void testCircuitBreakerCloudCommonConfig() {
             .isNotNull();
     }
 
-    static class CircuitBreakerConfig extends AbstractRefreshScopedCircuitBreakerConfiguration {
+    static class CircuitBreakerConfig extends RefreshScopedCircuitBreakerAutoConfiguration {
 
         CircuitBreakerConfig(CircuitBreakerConfigurationProperties circuitBreakerProperties) {
             super(circuitBreakerProperties);

File: resilience4j-spring-cloud2/src/test/java/io/github/resilience4j/timelimiter/autoconfigure/RefreshScopedTimeLimiterConfigurationTest.java
Patch:
@@ -13,11 +13,11 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class AbstractRefreshScopedTimeLimiterConfigurationTest {
+public class RefreshScopedTimeLimiterConfigurationTest {
 
     @Test
     public void testRefreshScopedTimeLimiterConfig() {
-        Arrays.stream(AbstractRefreshScopedTimeLimiterConfiguration.class.getMethods())
+        Arrays.stream(RefreshScopedTimeLimiterAutoConfiguration.class.getMethods())
             .filter(method -> method.isAnnotationPresent(Bean.class))
             .forEach(method -> assertThat(method.isAnnotationPresent(RefreshScope.class)).isTrue());
     }
@@ -33,7 +33,7 @@ public void testTimeLimiterCloudCommonConfig() {
     }
 
 
-    static class TimeLimiterConfig extends AbstractRefreshScopedTimeLimiterConfiguration {
+    static class TimeLimiterConfig extends RefreshScopedTimeLimiterAutoConfiguration {
 
     }
 }
\ No newline at end of file

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerProperties.java
Patch:
@@ -1,4 +1,3 @@
-package io.github.resilience4j.circuitbreaker.autoconfigure;
 /*
  * Copyright 2017 Robert Winkler
  *
@@ -14,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package io.github.resilience4j.circuitbreaker.autoconfigure;
 
 import io.github.resilience4j.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
 import org.springframework.boot.context.properties.ConfigurationProperties;

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/service/test/DummyServiceImpl.java
Patch:
@@ -3,7 +3,6 @@
 
 import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
 import io.github.resilience4j.ratelimiter.annotation.RateLimiter;
-import io.github.resilience4j.retry.annotation.Retry;
 import io.github.resilience4j.timelimiter.annotation.TimeLimiter;
 import org.springframework.stereotype.Component;
 

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/service/test/TestApplication.java
Patch:
@@ -2,7 +2,6 @@
 
 import io.github.resilience4j.bulkhead.BulkheadConfig;
 import io.github.resilience4j.bulkhead.ContextPropagator;
-import io.github.resilience4j.bulkhead.ThreadPoolBulkheadConfig;
 import io.github.resilience4j.common.bulkhead.configuration.BulkheadConfigCustomizer;
 import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigCustomizer;
 import io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigCustomizer;

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerStateMachine.java
Patch:
@@ -354,6 +354,9 @@ private void publishEventIfPossible(CircuitBreakerEvent event) {
     }
 
     private void publishStateTransitionEvent(final StateTransition stateTransition) {
+        if (StateTransition.isInternalTransition(stateTransition)) {
+            return;
+        }
         final CircuitBreakerOnStateTransitionEvent event = new CircuitBreakerOnStateTransitionEvent(
             name, stateTransition);
         publishEventIfPossible(event);

File: resilience4j-prometheus/src/main/java/io/github/resilience4j/prometheus/AbstractCircuitBreakerMetrics.java
Patch:
@@ -274,7 +274,7 @@ public MetricNames build() {
      */
     public static class MetricOptions {
 
-        public static final double[] DEFAULT_BUCKETS = new double[]{.005, .01, .025, .05, .075, .1,
+        private static final double[] DEFAULT_BUCKETS = new double[]{.005, .01, .025, .05, .075, .1,
             .25, .5, .75, 1, 2.5, 5, 7.5, 10};
         private double[] buckets = DEFAULT_BUCKETS;
 

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/ThreadPoolBulkheadConfigTest.java
Patch:
@@ -193,7 +193,7 @@ public void testContextPropagatorSetAsBeanOverrideSetAsClass() {
         assertThat(config.getContextPropagator()).isNotNull();
         assertThat(config.getContextPropagator()).hasSize(2);
         List<Class<? extends ContextPropagator>> ctxPropagators = config.getContextPropagator()
-            .stream().map(ct -> ((ContextPropagator) ct).getClass()).collect(Collectors.toList());
+            .stream().map(ct -> ct.getClass()).collect(Collectors.toList());
         assertThat(ctxPropagators).containsExactlyInAnyOrder(TestCtxPropagator.class, TestCtxPropagator2.class);
 
     }

File: resilience4j-spring/src/main/java/io/github/resilience4j/timelimiter/configure/TimeLimiterAspect.java
Patch:
@@ -67,6 +67,7 @@ public TimeLimiterAspect(TimeLimiterRegistry timeLimiterRegistry,
 
     @Pointcut(value = "@within(timeLimiter) || @annotation(timeLimiter)", argNames = "timeLimiter")
     public void matchAnnotatedClassOrMethod(TimeLimiter timeLimiter) {
+        // a marker method
     }
 
     @Around(value = "matchAnnotatedClassOrMethod(timeLimiterAnnotation)", argNames = "proceedingJoinPoint, timeLimiterAnnotation")

File: resilience4j-spring/src/main/java/io/github/resilience4j/timelimiter/configure/TimeLimiterConfigurationProperties.java
Patch:
@@ -18,6 +18,7 @@
 
 import org.springframework.core.Ordered;
 
+@SuppressWarnings("squid:S2176")
 public class TimeLimiterConfigurationProperties extends
     io.github.resilience4j.common.timelimiter.configuration.TimeLimiterConfigurationProperties {
 

File: resilience4j-core/src/main/java/io/github/resilience4j/core/IntervalFunction.java
Patch:
@@ -59,10 +59,10 @@ static IntervalFunction of(long intervalMillis) {
     }
 
     /**
-     * Creates an IntervalFunction which returns a fixed interval in milliseconds.
+     * Creates an IntervalFunction which returns a fixed interval specified by a given {@link Duration}.
      *
      * @param interval the interval
-     * @return an IntervalFunction which returns a fixed interval in milliseconds.
+     * @return an IntervalFunction which returns a fixed interval specified by a given {@link Duration}.
      */
     static IntervalFunction of(Duration interval) {
         return of(interval.toMillis());
@@ -215,4 +215,4 @@ static void checkAttempt(long attempt) {
             throw new IllegalArgumentException("Illegal argument attempt: " + attempt);
         }
     }
-}
\ No newline at end of file
+}

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/Retry.java
Patch:
@@ -488,9 +488,9 @@ default <T> CompletionStage<T> executeCompletionStage(ScheduledExecutorService s
     }
 
     /**
-     * Get the Metrics of this RateLimiter.
+     * Get the Metrics of this Retry instance.
      *
-     * @return the Metrics of this RateLimiter
+     * @return the Metrics of this Retry instance
      */
     Metrics getMetrics();
 

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/RetryConfig.java
Patch:
@@ -77,7 +77,7 @@ public static RetryConfig ofDefaults() {
     }
 
     /**
-     * @return the maximum allowed retries to make.
+     * @return the maximum allowed attempts to make.
      */
     public int getMaxAttempts() {
         return maxAttempts;
@@ -169,7 +169,7 @@ public Builder<T> retryOnResult(Predicate<T> predicate) {
          * stays the same.
          *
          * @param f Function to modify the interval after a failure
-         * @return the CircuitBreakerConfig.Builder
+         * @return the RetryConfig.Builder
          */
         public Builder<T> intervalFunction(IntervalFunction f) {
             this.intervalFunction = f;

File: resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java
Patch:
@@ -42,7 +42,7 @@
  * This results in the following composition when executing the supplier: <br>
  * <pre>Fallback(Retry(CircuitBreaker(Supplier)))</pre>
  *
- * This means the Supplier is called first, then it’s result is handled by the CircuitBreaker, then Retry and then Fallback.
+ * This means the Supplier is called first, then its result is handled by the CircuitBreaker, then Retry and then Fallback.
  * Each Decorator makes its own determination whether an exception represents a failure.
  */
 public interface Decorators {

File: resilience4j-spring/src/main/java/io/github/resilience4j/fallback/DefaultFallbackDecorator.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.github.resilience4j.fallback;
 
+import io.github.resilience4j.timelimiter.configure.IllegalReturnTypeException;
 import io.vavr.CheckedFunction0;
 
 /**
@@ -33,6 +34,8 @@ public CheckedFunction0<Object> decorate(FallbackMethod fallbackMethod,
         return () -> {
             try {
                 return supplier.apply();
+            } catch (IllegalReturnTypeException e) {
+                throw e;
             } catch (Throwable throwable) {
                 return fallbackMethod.fallback(throwable);
             }

File: resilience4j-spring/src/main/java/io/github/resilience4j/timelimiter/configure/TimeLimiterAspect.java
Patch:
@@ -109,7 +109,8 @@ private Object proceed(ProceedingJoinPoint proceedingJoinPoint, String methodNam
         }
 
         if (!CompletionStage.class.isAssignableFrom(returnType)) {
-            throw new IllegalStateException("Not supported type by TimeLimiterAspect");
+            throw new IllegalReturnTypeException(returnType, methodName,
+                "CompletionStage expected.");
         }
 
         return handleJoinPointCompletableFuture(proceedingJoinPoint, timeLimiter);

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/FixedThreadPoolBulkhead.java
Patch:
@@ -143,6 +143,9 @@ public <T> CompletableFuture<T> submit(Callable<T> callable) {
                     publishBulkheadEvent(() -> new BulkheadOnCallPermittedEvent(name));
                     return callable.call();
                 } catch (Exception e) {
+                    if(e instanceof CompletionException){
+                        throw (CompletionException)e;
+                    }
                     throw new CompletionException(e);
                 }
             }), executorService).whenComplete((result, throwable) -> {

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationTest.java
Patch:
@@ -110,8 +110,7 @@ public void testCircuitBreakerAutoConfiguration() throws IOException {
         CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(
             "/actuator/circuitbreakerevents");
         CircuitBreakerEventsEndpointResponse circuitBreakerEventsForABefore = circuitBreakerEvents(
-            "/actuator" +
-                "/circuitbreakerevents/backendA");
+            "/actuator/circuitbreakerevents/backendA");
 
         try {
             dummyService.doSomething(true);

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/service/test/DummyServiceImpl.java
Patch:
@@ -3,6 +3,8 @@
 
 import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
 import io.github.resilience4j.ratelimiter.annotation.RateLimiter;
+import io.github.resilience4j.retry.annotation.Retry;
+import io.github.resilience4j.timelimiter.annotation.TimeLimiter;
 import org.springframework.stereotype.Component;
 
 import java.io.IOException;
@@ -21,6 +23,7 @@ public void doSomething(boolean throwBackendTrouble) throws IOException {
     }
 
     @Override
+    @TimeLimiter(name = DummyService.BACKEND)
     public CompletableFuture<String> doSomethingAsync(boolean throwBackendTrouble)
         throws IOException {
         if (throwBackendTrouble) {

File: resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/BulkheadAspectExt.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.github.resilience4j.bulkhead.configure;
 
+import io.github.resilience4j.bulkhead.Bulkhead;
 import org.aspectj.lang.ProceedingJoinPoint;
 
 /**
@@ -24,6 +25,6 @@ public interface BulkheadAspectExt {
 
     boolean canHandleReturnType(Class returnType);
 
-    Object handle(ProceedingJoinPoint proceedingJoinPoint,
-        io.github.resilience4j.bulkhead.Bulkhead bulkhead, String methodName) throws Throwable;
+	Object handle(ProceedingJoinPoint proceedingJoinPoint, Bulkhead bulkhead, String methodName)
+        throws Throwable;
 }

File: resilience4j-spring/src/main/java/io/github/resilience4j/circuitbreaker/configure/CircuitBreakerAspectExt.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.github.resilience4j.circuitbreaker.configure;
 
+import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import org.aspectj.lang.ProceedingJoinPoint;
 
 /**
@@ -25,6 +26,5 @@ public interface CircuitBreakerAspectExt {
     boolean canHandleReturnType(Class returnType);
 
     Object handle(ProceedingJoinPoint proceedingJoinPoint,
-        io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker, String methodName)
-        throws Throwable;
+        CircuitBreaker circuitBreaker, String methodName) throws Throwable;
 }

File: resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java
Patch:
@@ -23,8 +23,8 @@
 import java.util.function.*;
 
 /**
- * A Decorator builder which can be used to apply multiple decorators to a (Checked-)Supplier,
- * (Checked-)Function, (Checked-)Runnable, (Checked-)CompletionStage or (Checked-)Consumer.
+ * A Decorator builder which can be used to apply multiple decorators to a Supplier, Callable
+ * Function, Runnable, CompletionStage or Consumer.
  * <p></p>
  * Decorators are applied in the order of the builder chain. For example, consider:
  *

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/RetryImpl.java
Patch:
@@ -233,7 +233,7 @@ private void throwOrSleepAfterRuntimeException() {
         }
 
         private void waitIntervalAfterFailure(int currentNumOfAttempts,
-            @Nullable Throwable throwable) {
+                                              @Nullable Throwable throwable) {
             // wait interval until the next attempt should start
             long interval = intervalFunction.apply(numOfAttempts.get());
             publishRetryEvent(

File: resilience4j-spring-boot-common/src/main/java/io/github/resilience4j/bulkhead/autoconfigure/AbstractBulkheadConfigurationOnMissingBean.java
Patch:
@@ -129,7 +129,6 @@ public ThreadPoolBulkheadRegistry threadPoolBulkheadRegistry(
         EventConsumerRegistry<BulkheadEvent> bulkheadEventConsumerRegistry,
         RegistryEventConsumer<ThreadPoolBulkhead> threadPoolBulkheadRegistryEventConsumer,
         @Qualifier("compositeThreadPoolBulkheadCustomizer") CompositeCustomizer<ThreadPoolBulkheadConfigCustomizer> compositeThreadPoolBulkheadCustomizer) {
-
         return threadPoolBulkheadConfiguration.threadPoolBulkheadRegistry(
             threadPoolBulkheadConfigurationProperties, bulkheadEventConsumerRegistry,
             threadPoolBulkheadRegistryEventConsumer, compositeThreadPoolBulkheadCustomizer);

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/service/test/bulkhead/BulkheadDummyService.java
Patch:
@@ -6,8 +6,11 @@ public interface BulkheadDummyService {
 
     String BACKEND = "backendA";
     String BACKEND_C = "backendC";
+    String BACKEND_D = "backendD";
 
     void doSomething();
 
     CompletableFuture<String> doSomethingAsync() throws InterruptedException;
+
+    CompletableFuture<Object> doSomethingAsyncWithThreadLocal() throws InterruptedException;
 }

File: resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/BulkheadConfiguration.java
Patch:
@@ -102,7 +102,6 @@ private BulkheadRegistry createBulkheadRegistry(
             .entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey,
                 entry -> bulkheadConfigurationProperties.createBulkheadConfig(entry.getValue(),
                     compositeBulkheadCustomizer, entry.getKey())));
-
         return BulkheadRegistry.of(configs, bulkheadRegistryEventConsumer,
             io.vavr.collection.HashMap.ofAll(bulkheadConfigurationProperties.getTags()));
     }

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/utils/CircuitBreakerUtil.java
Patch:
@@ -15,6 +15,6 @@ public final class CircuitBreakerUtil {
      */
     public static boolean isCallPermitted(CircuitBreaker circuitBreaker) {
         State state = circuitBreaker.getState();
-        return state == CLOSED || state == HALF_OPEN || state == DISABLED;
+        return state == CLOSED || state == HALF_OPEN || state == DISABLED || state == METRICS_ONLY;
     }
 }

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerMetricsTest.java
Patch:
@@ -53,7 +53,7 @@ public void testCircuitBreakerMetrics() {
         // The failure rate must be -1, because the number of measured calls is below the buffer size of 10
         assertThat(circuitBreakerMetrics.getFailureRate()).isEqualTo(-1);
         assertThat(result)
-            .isEqualTo(Result.BELOW_MINIMUM_CALLS_THRESHOLD);
+            .isEqualTo(CircuitBreakerMetrics.Result.BELOW_MINIMUM_CALLS_THRESHOLD);
 
         circuitBreakerMetrics.onError(0, TimeUnit.NANOSECONDS);
         circuitBreakerMetrics.onError(0, TimeUnit.NANOSECONDS);
@@ -70,12 +70,12 @@ public void testCircuitBreakerMetrics() {
         assertThat(circuitBreakerMetrics.getNumberOfFailedCalls()).isEqualTo(6);
         assertThat(circuitBreakerMetrics.getNumberOfSuccessfulCalls()).isEqualTo(4);
         assertThat(circuitBreakerMetrics.getFailureRate()).isEqualTo(60);
-        assertThat(result).isEqualTo(Result.ABOVE_THRESHOLDS);
+        assertThat(Result.hasExceededThresholds(result)).isEqualTo(true);
 
         circuitBreakerMetrics.onSuccess(0, TimeUnit.NANOSECONDS);
         circuitBreakerMetrics.onSuccess(0, TimeUnit.NANOSECONDS);
         result = circuitBreakerMetrics.onSuccess(0, TimeUnit.NANOSECONDS);
-        assertThat(result).isEqualTo(Result.BELOW_THRESHOLDS);
+        assertThat(result).isEqualTo(CircuitBreakerMetrics.Result.BELOW_THRESHOLDS);
         assertThat(circuitBreakerMetrics.getFailureRate()).isEqualTo(30);
 
 

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/utils/CircuitBreakerUtilTest.java
Patch:
@@ -14,6 +14,6 @@ public void shouldConsiderAllKnownStatusesUsingIsCallPermitted() {
             .describedAs("List of statuses changed." +
                 "Please consider updating CircuitBreakerUtil#isCallPermitted to handle" +
                 "new status properly.")
-            .containsOnly(DISABLED, CLOSED, OPEN, FORCED_OPEN, HALF_OPEN);
+            .containsOnly(DISABLED, CLOSED, OPEN, FORCED_OPEN, HALF_OPEN, METRICS_ONLY);
     }
 }

File: resilience4j-consumer/src/test/java/io/github/resilience4j/consumer/CircularEventConsumerTest.java
Patch:
@@ -75,10 +75,11 @@ public void shouldBufferAllEvents() {
         assertThat(resetMetrics.getNumberOfBufferedCalls()).isEqualTo(0);
         assertThat(resetMetrics.getNumberOfFailedCalls()).isEqualTo(0);
         //Because circuit emits 2 error events and one state transition event
-        assertThat(ringBuffer.getBufferedEvents()).hasSize(7);
+        assertThat(ringBuffer.getBufferedEvents()).hasSize(8);
         assertThat(ringBuffer.getBufferedEvents()).extracting("eventType")
             .containsExactly(Type.SUCCESS, Type.ERROR, Type.IGNORED_ERROR, Type.ERROR,
-                Type.STATE_TRANSITION, Type.STATE_TRANSITION, Type.RESET);
+                Type.FAILURE_RATE_EXCEEDED, Type.STATE_TRANSITION, Type.STATE_TRANSITION,
+                Type.RESET);
     }
 
     @Test

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedRateLimiterMetricsPublisherTest.java
Patch:
@@ -31,7 +31,7 @@
 
 import static io.github.resilience4j.micrometer.tagged.AbstractRateLimiterMetrics.MetricNames.DEFAULT_AVAILABLE_PERMISSIONS_METRIC_NAME;
 import static io.github.resilience4j.micrometer.tagged.AbstractRateLimiterMetrics.MetricNames.DEFAULT_WAITING_THREADS_METRIC_NAME;
-import static io.github.resilience4j.micrometer.tagged.MetricsTestHelper.findGaugeByNamesTag;
+import static io.github.resilience4j.micrometer.tagged.MetricsTestHelper.findMeterByNamesTag;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class TaggedRateLimiterMetricsPublisherTest {
@@ -66,7 +66,7 @@ public void shouldAddMetricsForANewlyCreatedRateLimiter() {
         Collection<Gauge> gauges = meterRegistry.get(DEFAULT_AVAILABLE_PERMISSIONS_METRIC_NAME)
             .gauges();
 
-        Optional<Gauge> successful = findGaugeByNamesTag(gauges, newRateLimiter.getName());
+        Optional<Gauge> successful = findMeterByNamesTag(gauges, newRateLimiter.getName());
         assertThat(successful).isPresent();
         assertThat(successful.get().value())
             .isEqualTo(newRateLimiter.getMetrics().getAvailablePermissions());

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedRateLimiterMetricsTest.java
Patch:
@@ -30,7 +30,7 @@
 
 import static io.github.resilience4j.micrometer.tagged.AbstractRateLimiterMetrics.MetricNames.DEFAULT_AVAILABLE_PERMISSIONS_METRIC_NAME;
 import static io.github.resilience4j.micrometer.tagged.AbstractRateLimiterMetrics.MetricNames.DEFAULT_WAITING_THREADS_METRIC_NAME;
-import static io.github.resilience4j.micrometer.tagged.MetricsTestHelper.findGaugeByNamesTag;
+import static io.github.resilience4j.micrometer.tagged.MetricsTestHelper.findMeterByNamesTag;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class TaggedRateLimiterMetricsTest {
@@ -65,7 +65,7 @@ public void shouldAddMetricsForANewlyCreatedRateLimiter() {
         Collection<Gauge> gauges = meterRegistry.get(DEFAULT_AVAILABLE_PERMISSIONS_METRIC_NAME)
             .gauges();
 
-        Optional<Gauge> successful = findGaugeByNamesTag(gauges, newRateLimiter.getName());
+        Optional<Gauge> successful = findMeterByNamesTag(gauges, newRateLimiter.getName());
         assertThat(successful).isPresent();
         assertThat(successful.get().value())
             .isEqualTo(newRateLimiter.getMetrics().getAvailablePermissions());

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/Bulkhead.java
Patch:
@@ -465,7 +465,7 @@ static Bulkhead of(String name, Supplier<BulkheadConfig> bulkheadConfigSupplier,
     Metrics getMetrics();
 
     /**
-     * Returns an unmodifiable map with tags assigned to this Blukhead.
+     * Returns an unmodifiable map with tags assigned to this Bulkhead.
      *
      * @return the tags assigned to this Retry in an unmodifiable map
      */

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/event/AbstractBulkheadEvent.java
Patch:
@@ -11,7 +11,7 @@
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the speci`fic language governing permissions and
+ *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  *

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/SemaphoreBulkhead.java
Patch:
@@ -73,7 +73,7 @@ public SemaphoreBulkhead(String name, @Nullable BulkheadConfig bulkheadConfig) {
      *
      * @param name           the name of this bulkhead
      * @param bulkheadConfig custom bulkhead configuration
-     * @param tags           the tags to add to the Bulkdhead
+     * @param tags           the tags to add to the Bulkhead
      */
     public SemaphoreBulkhead(String name, @Nullable BulkheadConfig bulkheadConfig,
         Map<String, String> tags) {

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java
Patch:
@@ -566,7 +566,7 @@ static void waitForPermission(final RateLimiter rateLimiter) {
      * Will wait for required number of permits within default timeout duration.
      *
      * @param rateLimiter the RateLimiter to get permission from
-     * @param permits     numer of permits we have to acquire
+     * @param permits     number of permits we have to acquire
      * @throws RequestNotPermitted                 if waiting time elapsed before a permit was
      *                                             acquired.
      * @throws AcquirePermissionCancelledException if thread was interrupted during permission wait

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/SemaphoreBasedRateLimiter.java
Patch:
@@ -177,7 +177,7 @@ public boolean acquirePermission(int permits) {
     }
 
     /**
-     * Reserving permissions is not supported in the spemaphore based implementation. Semaphores are
+     * Reserving permissions is not supported in the semaphore based implementation. Semaphores are
      * totally blocking by it's nature. So this non-blocking API isn't supported. Use {@link
      * #acquirePermission()}
      *
@@ -186,7 +186,7 @@ public boolean acquirePermission(int permits) {
     @Override
     public long reservePermission() {
         throw new UnsupportedOperationException(
-            "Reserving permissions is not supported in the spemaphore based implementation");
+            "Reserving permissions is not supported in the semaphore based implementation");
     }
 
     /**
@@ -196,7 +196,7 @@ public long reservePermission() {
     @Override
     public long reservePermission(int permits) {
         throw new UnsupportedOperationException(
-            "Reserving permissions is not supported in the spemaphore based implementation");
+            "Reserving permissions is not supported in the semaphore based implementation");
     }
 
     /**

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/retry/monitoring/endpoint/RetryEventsEndpoint.java
Patch:
@@ -47,7 +47,7 @@ public RetryEventsEndpoint(EventConsumerRegistry<RetryEvent> eventConsumerRegist
 
     @GetMapping(value = "events", produces = MediaType.APPLICATION_JSON_VALUE)
     @ResponseBody
-    public RetryEventsEndpointResponse getAllRetryEvenets() {
+    public RetryEventsEndpointResponse getAllRetryEvents() {
         return new RetryEventsEndpointResponse(eventConsumerRegistry.getAllEventConsumer()
             .flatMap(CircularEventConsumer::getBufferedEvents)
             .sorted(Comparator.comparing(RetryEvent::getCreationTime))
@@ -56,7 +56,7 @@ public RetryEventsEndpointResponse getAllRetryEvenets() {
 
     @GetMapping(value = "events/{name}", produces = MediaType.APPLICATION_JSON_VALUE)
     @ResponseBody
-    public RetryEventsEndpointResponse getEventsFilteredByRetryrName(
+    public RetryEventsEndpointResponse getEventsFilteredByRetryName(
         @PathVariable("name") String name) {
         return new RetryEventsEndpointResponse(getRetryEvents(name)
             .map(RetryEventDTOFactory::createRetryEventDTO).toJavaList());

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/retry/monitoring/endpoint/RetryEventsEndpoint.java
Patch:
@@ -45,7 +45,7 @@ public RetryEventsEndpoint(EventConsumerRegistry<RetryEvent> eventConsumerRegist
      * @return all retry generated events
      */
     @ReadOperation
-    public RetryEventsEndpointResponse getAllRetryEvenets() {
+    public RetryEventsEndpointResponse getAllRetryEvents() {
         return new RetryEventsEndpointResponse(eventConsumerRegistry.getAllEventConsumer()
             .flatMap(CircularEventConsumer::getBufferedEvents)
             .sorted(Comparator.comparing(RetryEvent::getCreationTime))
@@ -57,7 +57,7 @@ public RetryEventsEndpointResponse getAllRetryEvenets() {
      * @return the retry events generated for this backend
      */
     @ReadOperation
-    public RetryEventsEndpointResponse getEventsFilteredByRetryrName(@Selector String name) {
+    public RetryEventsEndpointResponse getEventsFilteredByRetryName(@Selector String name) {
         return new RetryEventsEndpointResponse(getRetryEvents(name)
             .map(RetryEventDTOFactory::createRetryEventDTO).toJavaList());
     }

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/bulkhead/autoconfigure/BulkheadMicrometerAutoConfiguration.java
Patch:
@@ -22,6 +22,7 @@
 import io.micrometer.core.instrument.MeterRegistry;
 import io.micrometer.spring.autoconfigure.MetricsAutoConfiguration;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
@@ -47,6 +48,7 @@ public TaggedBulkheadMetrics registerBulkheadMetrics(BulkheadRegistry bulkheadRe
     }
 
     @Bean
+    @ConditionalOnBean(MeterRegistry.class)
     @ConditionalOnProperty(value = "resilience4j.bulkhead.metrics.legacy.enabled", havingValue = "false", matchIfMissing = true)
     @ConditionalOnMissingBean
     public TaggedBulkheadMetricsPublisher taggedBulkheadMetricsPublisher(

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/bulkhead/autoconfigure/ThreadPoolBulkheadMicrometerAutoConfiguration.java
Patch:
@@ -23,6 +23,7 @@
 import io.micrometer.core.instrument.MeterRegistry;
 import io.micrometer.spring.autoconfigure.MetricsAutoConfiguration;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
@@ -46,6 +47,7 @@ public TaggedThreadPoolBulkheadMetrics registerThreadPoolBulkheadMetrics(
     }
 
     @Bean
+    @ConditionalOnBean(MeterRegistry.class)
     @ConditionalOnProperty(value = "resilience4j.thread-pool-bulkhead.metrics.legacy.enabled", havingValue = "false", matchIfMissing = true)
     @ConditionalOnMissingBean
     public TaggedThreadPoolBulkheadMetricsPublisher taggedThreadPoolBulkheadMetricsPublisher(

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerMicrometerAutoConfiguration.java
Patch:
@@ -22,6 +22,7 @@
 import io.micrometer.core.instrument.MeterRegistry;
 import io.micrometer.spring.autoconfigure.MetricsAutoConfiguration;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
@@ -48,6 +49,7 @@ public TaggedCircuitBreakerMetrics registerCircuitBreakerMetrics(
     }
 
     @Bean
+    @ConditionalOnBean(MeterRegistry.class)
     @ConditionalOnProperty(value = "resilience4j.circuitbreaker.metrics.legacy.enabled", havingValue = "false", matchIfMissing = true)
     @ConditionalOnMissingBean
     public TaggedCircuitBreakerMetricsPublisher taggedCircuitBreakerMetricsPublisher(

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterMicrometerAutoConfiguration.java
Patch:
@@ -22,6 +22,7 @@
 import io.micrometer.core.instrument.MeterRegistry;
 import io.micrometer.spring.autoconfigure.MetricsAutoConfiguration;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
@@ -48,6 +49,7 @@ public TaggedRateLimiterMetrics registerRateLimiterMetrics(
     }
 
     @Bean
+    @ConditionalOnBean(MeterRegistry.class)
     @ConditionalOnProperty(value = "resilience4j.ratelimiter.metrics.legacy.enabled", havingValue = "false", matchIfMissing = true)
     @ConditionalOnMissingBean
     public TaggedRateLimiterMetricsPublisher taggedRateLimiterMetricsPublisher(

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/retry/autoconfigure/RetryMicrometerAutoConfiguration.java
Patch:
@@ -22,6 +22,7 @@
 import io.micrometer.core.instrument.MeterRegistry;
 import io.micrometer.spring.autoconfigure.MetricsAutoConfiguration;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
@@ -47,6 +48,7 @@ public TaggedRetryMetrics registerRetryMetrics(RetryRegistry retryRegistry) {
     }
 
     @Bean
+    @ConditionalOnBean(MeterRegistry.class)
     @ConditionalOnProperty(value = "resilience4j.retry.metrics.legacy.enabled", havingValue = "false", matchIfMissing = true)
     @ConditionalOnMissingBean
     public TaggedRetryMetricsPublisher taggedRetryMetricsPublisher(MeterRegistry meterRegistry) {

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/bulkhead/configuration/ThreadPoolBulkheadConfigurationProperties.java
Patch:
@@ -194,8 +194,8 @@ public Boolean getWritableStackTraceEnabled() {
             return writableStackTraceEnabled;
         }
 
-        public InstanceProperties setWritableStackTraceEnabled(Integer eventConsumerBufferSize) {
-            this.eventConsumerBufferSize = eventConsumerBufferSize;
+        public InstanceProperties setWritableStackTraceEnabled(boolean writableStackTraceEnabled) {
+            this.writableStackTraceEnabled = writableStackTraceEnabled;
             return this;
         }
 

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/ratelimiter/configuration/RateLimiterConfigurationPropertiesTest.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.github.resilience4j.common.ratelimiter.configuration;
 
+import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.core.ConfigurationNotFoundException;
 import io.github.resilience4j.ratelimiter.RateLimiterConfig;
 import org.junit.Test;
@@ -178,8 +179,8 @@ public void testIllegalArgumentOnEventConsumerBufferSize() {
         defaultProperties.setEventConsumerBufferSize(-1);
     }
 
-    private CompositeRateLimiterCustomizer compositeRateLimiterCustomizer() {
-        return new CompositeRateLimiterCustomizer(Collections.emptyList());
+    private CompositeCustomizer<RateLimiterConfigCustomizer> compositeRateLimiterCustomizer() {
+        return new CompositeCustomizer<>(Collections.emptyList());
     }
 
 }
\ No newline at end of file

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/retry/configuration/RetryConfigurationPropertiesTest.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.github.resilience4j.common.retry.configuration;
 
+import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.RecordFailurePredicate;
 import io.github.resilience4j.core.ConfigurationNotFoundException;
 import io.github.resilience4j.retry.RetryConfig;
@@ -162,7 +163,7 @@ public void testIllegalArgumentOnMaxRetryAttempts() {
         defaultProperties.setMaxRetryAttempts(0);
     }
 
-    private CompositeRetryCustomizer compositeRetryCustomizer() {
-        return new CompositeRetryCustomizer(Collections.emptyList());
+    private CompositeCustomizer<RetryConfigCustomizer> compositeRetryCustomizer() {
+        return new CompositeCustomizer<>(Collections.emptyList());
     }
 }
\ No newline at end of file

File: resilience4j-spring-cloud-common/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/AbstractRefreshScopedCircuitBreakerConfiguration.java
Patch:
@@ -9,6 +9,7 @@
 import io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigCustomizer;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.registry.RegistryEventConsumer;
+import org.springframework.beans.factory.annotation.Qualifier;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.cloud.context.config.annotation.RefreshScope;
 import org.springframework.context.annotation.Bean;
@@ -37,7 +38,7 @@ protected AbstractRefreshScopedCircuitBreakerConfiguration(
     public CircuitBreakerRegistry circuitBreakerRegistry(
         EventConsumerRegistry<CircuitBreakerEvent> eventConsumerRegistry,
         RegistryEventConsumer<CircuitBreaker> circuitBreakerRegistryEventConsumer,
-        CompositeCustomizer<CircuitBreakerConfigCustomizer> compositeCircuitBreakerCustomizer) {
+        @Qualifier("compositeCircuitBreakerCustomizer") CompositeCustomizer<CircuitBreakerConfigCustomizer> compositeCircuitBreakerCustomizer) {
         return circuitBreakerConfiguration
             .circuitBreakerRegistry(eventConsumerRegistry, circuitBreakerRegistryEventConsumer,
                 compositeCircuitBreakerCustomizer);

File: resilience4j-spring-cloud-common/src/test/java/io/github/resilience4j/ratelimiter/autoconfigure/AbstractRefreshScopedRateLimiterConfigurationTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package io.github.resilience4j.ratelimiter.autoconfigure;
 
-import io.github.resilience4j.common.ratelimiter.configuration.CompositeRateLimiterCustomizer;
+import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.core.registry.CompositeRegistryEventConsumer;
 import io.github.resilience4j.ratelimiter.configure.RateLimiterConfigurationProperties;
@@ -46,7 +46,7 @@ public void testRateLimiterCloudCommonConfig() {
 
         assertThat(rateLimiterConfig.rateLimiterRegistry(
             new RateLimiterConfigurationProperties(), new DefaultEventConsumerRegistry<>(),
-            new CompositeRegistryEventConsumer<>(emptyList()), new CompositeRateLimiterCustomizer(
+            new CompositeRegistryEventConsumer<>(emptyList()), new CompositeCustomizer<>(
                 Collections.emptyList()))).isNotNull();
     }
 

File: resilience4j-spring-cloud-common/src/test/java/io/github/resilience4j/retry/autoconfigure/AbstractRefreshScopedRetryConfigurationTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package io.github.resilience4j.retry.autoconfigure;
 
-import io.github.resilience4j.common.retry.configuration.CompositeRetryCustomizer;
+import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.core.registry.CompositeRegistryEventConsumer;
 import io.github.resilience4j.ratelimiter.autoconfigure.AbstractRefreshScopedRateLimiterConfiguration;
@@ -46,7 +46,7 @@ public void testRetryCloudCommonConfig() {
 
         assertThat(retryConfig.retryRegistry(
             new RetryConfigurationProperties(), new DefaultEventConsumerRegistry<>(),
-            new CompositeRegistryEventConsumer<>(emptyList()), new CompositeRetryCustomizer(
+            new CompositeRegistryEventConsumer<>(emptyList()), new CompositeCustomizer<>(
                 Collections.emptyList()))).isNotNull();
     }
 

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/circuitbreaker/configuration/CircuitBreakerConfigurationPropertiesTest.java
Patch:
@@ -16,6 +16,7 @@
 package io.github.resilience4j.common.circuitbreaker.configuration;
 
 import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
+import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.RecordFailurePredicate;
 import io.github.resilience4j.core.ConfigurationNotFoundException;
 import org.junit.Test;
@@ -286,7 +287,7 @@ public void testIllegalArgumentOnSlowCallDurationThreshold() {
         defaultProperties.setSlowCallDurationThreshold(Duration.ZERO);
     }
 
-    private CompositeCircuitBreakerCustomizer compositeCircuitBreakerCustomizer() {
-        return new CompositeCircuitBreakerCustomizer(Collections.emptyList());
+    private CompositeCustomizer<CircuitBreakerConfigCustomizer> compositeCircuitBreakerCustomizer() {
+        return new CompositeCustomizer<>(Collections.emptyList());
     }
 }

File: resilience4j-spring-boot-common/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/AbstractCircuitBreakerConfigurationOnMissingBean.java
Patch:
@@ -19,7 +19,8 @@
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
 import io.github.resilience4j.circuitbreaker.configure.*;
 import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;
-import io.github.resilience4j.common.circuitbreaker.configuration.CompositeCircuitBreakerCustomizer;
+import io.github.resilience4j.common.CompositeCustomizer;
+import io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigCustomizer;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.registry.RegistryEventConsumer;
 import io.github.resilience4j.fallback.FallbackDecorators;
@@ -53,7 +54,7 @@ public AbstractCircuitBreakerConfigurationOnMissingBean(
     public CircuitBreakerRegistry circuitBreakerRegistry(
         EventConsumerRegistry<CircuitBreakerEvent> eventConsumerRegistry,
         RegistryEventConsumer<CircuitBreaker> circuitBreakerRegistryEventConsumer,
-        CompositeCircuitBreakerCustomizer compositeCircuitBreakerCustomizer) {
+        CompositeCustomizer<CircuitBreakerConfigCustomizer> compositeCircuitBreakerCustomizer) {
         return circuitBreakerConfiguration
             .circuitBreakerRegistry(eventConsumerRegistry, circuitBreakerRegistryEventConsumer,
                 compositeCircuitBreakerCustomizer);

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerConfigurationOnMissingBean.java
Patch:
@@ -17,10 +17,10 @@
 
 import io.github.resilience4j.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
 import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;
+import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.IntegerToDurationConverter;
 import io.github.resilience4j.common.StringToDurationConverter;
 import io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigCustomizer;
-import io.github.resilience4j.common.circuitbreaker.configuration.CompositeCircuitBreakerCustomizer;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
@@ -47,9 +47,9 @@ public EventConsumerRegistry<CircuitBreakerEvent> eventConsumerRegistry() {
 
     @Bean
     @ConditionalOnMissingBean
-    public CompositeCircuitBreakerCustomizer circuitBreakerCustomizerFinder(
+    public CompositeCustomizer<CircuitBreakerConfigCustomizer> circuitBreakerCustomizerFinder(
         @Autowired(required = false) List<CircuitBreakerConfigCustomizer> customizers) {
-        return new CompositeCircuitBreakerCustomizer(customizers);
+        return new CompositeCustomizer<>(customizers);
     }
 
 }

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerConfigurationOnMissingBean.java
Patch:
@@ -17,8 +17,8 @@
 
 import io.github.resilience4j.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
 import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;
+import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigCustomizer;
-import io.github.resilience4j.common.circuitbreaker.configuration.CompositeCircuitBreakerCustomizer;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.context.annotation.Bean;
@@ -44,9 +44,9 @@ public EventConsumerRegistry<CircuitBreakerEvent> eventConsumerRegistry() {
 
     @Bean
     @ConditionalOnMissingBean
-    public CompositeCircuitBreakerCustomizer circuitBreakerCustomizerFinder(
+    public CompositeCustomizer<CircuitBreakerConfigCustomizer> circuitBreakerCustomizerFinder(
         @Nullable List<CircuitBreakerConfigCustomizer> customizers) {
-        return new CompositeCircuitBreakerCustomizer(customizers);
+        return new CompositeCustomizer<>(customizers);
     }
 
 }

File: resilience4j-spring-cloud-common/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/AbstractRefreshScopedCircuitBreakerConfiguration.java
Patch:
@@ -5,7 +5,8 @@
 import io.github.resilience4j.circuitbreaker.configure.CircuitBreakerConfiguration;
 import io.github.resilience4j.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
 import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;
-import io.github.resilience4j.common.circuitbreaker.configuration.CompositeCircuitBreakerCustomizer;
+import io.github.resilience4j.common.CompositeCustomizer;
+import io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigCustomizer;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.core.registry.RegistryEventConsumer;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
@@ -36,7 +37,7 @@ protected AbstractRefreshScopedCircuitBreakerConfiguration(
     public CircuitBreakerRegistry circuitBreakerRegistry(
         EventConsumerRegistry<CircuitBreakerEvent> eventConsumerRegistry,
         RegistryEventConsumer<CircuitBreaker> circuitBreakerRegistryEventConsumer,
-        CompositeCircuitBreakerCustomizer compositeCircuitBreakerCustomizer) {
+        CompositeCustomizer<CircuitBreakerConfigCustomizer> compositeCircuitBreakerCustomizer) {
         return circuitBreakerConfiguration
             .circuitBreakerRegistry(eventConsumerRegistry, circuitBreakerRegistryEventConsumer,
                 compositeCircuitBreakerCustomizer);

File: resilience4j-spring-cloud-common/src/test/java/io/github/resilience4j/circuitbreaker/autoconfigure/AbstractRefreshScopedCircuitBreakerConfigurationTest.java
Patch:
@@ -17,7 +17,7 @@
 package io.github.resilience4j.circuitbreaker.autoconfigure;
 
 import io.github.resilience4j.circuitbreaker.configure.CircuitBreakerConfigurationProperties;
-import io.github.resilience4j.common.circuitbreaker.configuration.CompositeCircuitBreakerCustomizer;
+import io.github.resilience4j.common.CompositeCustomizer;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.core.registry.CompositeRegistryEventConsumer;
 import org.junit.Test;
@@ -47,7 +47,7 @@ public void testCircuitBreakerCloudCommonConfig() {
         assertThat(circuitBreakerConfig.circuitBreakerRegistry(
             new DefaultEventConsumerRegistry<>(),
             new CompositeRegistryEventConsumer<>(emptyList()),
-            new CompositeCircuitBreakerCustomizer(Collections.emptyList())))
+            new CompositeCustomizer<>(Collections.emptyList())))
             .isNotNull();
     }
 

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/circuitbreaker/configuration/CompositeCircuitBreakerCustomizer.java
Patch:
@@ -12,7 +12,7 @@
  */
 public class CompositeCircuitBreakerCustomizer {
 
-    final Map<String, CircuitBreakerConfigCustomizer> customizerMap = new HashMap<>();
+    private final Map<String, CircuitBreakerConfigCustomizer> customizerMap = new HashMap<>();
 
     public CompositeCircuitBreakerCustomizer(List<CircuitBreakerConfigCustomizer> customizers) {
 

File: resilience4j-spring-boot-common/src/test/java/io/github/resilience4j/SpringBootCommonTest.java
Patch:
@@ -25,6 +25,7 @@
 import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigurationProperties;
 import io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigCustomizer;
 import io.github.resilience4j.common.circuitbreaker.configuration.CompositeCircuitBreakerCustomizer;
+import io.github.resilience4j.common.retry.configuration.CompositeRetryCustomizer;
 import io.github.resilience4j.consumer.DefaultEventConsumerRegistry;
 import io.github.resilience4j.core.registry.CompositeRegistryEventConsumer;
 import io.github.resilience4j.fallback.CompletionStageFallbackDecorator;
@@ -94,7 +95,8 @@ public void testRetryCommonConfig() {
         assertThat(retryConfigurationOnMissingBean.rxJava2RetryAspectExt()).isNotNull();
         assertThat(retryConfigurationOnMissingBean
             .retryRegistry(new RetryConfigurationProperties(), new DefaultEventConsumerRegistry<>(),
-                new CompositeRegistryEventConsumer<>(emptyList()))).isNotNull();
+                new CompositeRegistryEventConsumer<>(emptyList()),
+                new CompositeRetryCustomizer(Collections.emptyList()))).isNotNull();
         assertThat(retryConfigurationOnMissingBean
             .retryAspect(new RetryConfigurationProperties(), RetryRegistry.ofDefaults(),
                 Collections.emptyList(),

File: resilience4j-annotations/src/main/java/io/github/resilience4j/circuitbreaker/annotation/CircuitBreaker.java
Patch:
@@ -21,7 +21,8 @@
  * This annotation can be applied to a class or a specific method. Applying it on a class is
  * equivalent to applying it on all its public methods. The annotation enables backend monitoring
  * for all methods where it is applied. Backend monitoring is performed via a circuit breaker. See
- * {@link io.github.resilience4j.circuitbreaker.CircuitBreaker} for details.
+ * {@link io.github.resilience4j.circuitbreaker.CircuitBreaker} for details. If using Spring,
+ * {@code fallbackMethod} can be resolved using Spring Expression Language (SpEL).
  */
 @Retention(value = RetentionPolicy.RUNTIME)
 @Target(value = {ElementType.METHOD, ElementType.TYPE})

File: resilience4j-annotations/src/main/java/io/github/resilience4j/ratelimiter/annotation/RateLimiter.java
Patch:
@@ -21,7 +21,8 @@
  * This annotation can be applied to a class or a specific method. Applying it on a class is
  * equivalent to applying it on all its public methods. The annotation enables throttling for all
  * methods where it is applied. Throttling monitoring is performed via a rate limiter. See {@link
- * io.github.resilience4j.ratelimiter.RateLimiter} for details.
+ * io.github.resilience4j.ratelimiter.RateLimiter} for details. If using Spring,
+ * {@code fallbackMethod} can be resolved using Spring Expression Language (SpEL).
  */
 @Retention(value = RetentionPolicy.RUNTIME)
 @Target(value = {ElementType.METHOD, ElementType.TYPE})

File: resilience4j-annotations/src/main/java/io/github/resilience4j/retry/annotation/Retry.java
Patch:
@@ -20,7 +20,8 @@
 /**
  * This annotation can be applied to a class or a specific method. Applying it on a class is
  * equivalent to applying it on all its public methods. The annotation enables backend retry for all
- * methods where it is applied. Backend retry is performed via a retry
+ * methods where it is applied. Backend retry is performed via a retry. If using Spring,
+ * {@code fallbackMethod} can be resolved using Spring Expression Language (SpEL).
  */
 @Retention(value = RetentionPolicy.RUNTIME)
 @Target(value = {ElementType.METHOD, ElementType.TYPE})

File: resilience4j-spring/src/test/java/io/github/resilience4j/TestDummyService.java
Patch:
@@ -49,6 +49,8 @@ public interface TestDummyService {
 
     Flowable<String> flowable();
 
+    String spelSync();
+
     default String syncError() {
         throw new RuntimeException("Test");
     }

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationTest.java
Patch:
@@ -177,11 +177,14 @@ public void testCircuitBreakerAutoConfiguration() throws IOException {
         CircuitBreaker sharedA = circuitBreakerRegistry.circuitBreaker("backendSharedA");
         CircuitBreaker sharedB = circuitBreakerRegistry.circuitBreaker("backendSharedB");
         CircuitBreaker backendB = circuitBreakerRegistry.circuitBreaker("backendB");
+        CircuitBreaker backendC = circuitBreakerRegistry.circuitBreaker("backendC");
 
         Duration defaultWaitDuration = Duration.ofSeconds(10);
         float defaultFailureRate = 60f;
         int defaultPermittedNumberOfCallsInHalfOpenState = 10;
         int defaultRingBufferSizeInClosedState = 100;
+        // test the customizer effect which overload the sliding widow size
+        assertThat(backendC.getCircuitBreakerConfig().getSlidingWindowSize()).isEqualTo(100);
 
         assertThat(backendB.getCircuitBreakerConfig().getSlidingWindowType())
             .isEqualTo(CircuitBreakerConfig.SlidingWindowType.TIME_BASED);

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerConfigurationOnMissingBeanTest.java
Patch:
@@ -64,11 +64,11 @@ public void testAllCircuitBreakerConfigurationBeansOverridden() {
     @Configuration
     public static class ConfigWithOverrides {
 
-        public CircuitBreakerRegistry circuitBreakerRegistry;
+        CircuitBreakerRegistry circuitBreakerRegistry;
 
-        public CircuitBreakerAspect circuitBreakerAspect;
+        CircuitBreakerAspect circuitBreakerAspect;
 
-        public EventConsumerRegistry<CircuitBreakerEvent> circuitEventConsumerBreakerRegistry;
+        EventConsumerRegistry<CircuitBreakerEvent> circuitEventConsumerBreakerRegistry;
 
         @Bean
         public CircuitBreakerRegistry circuitBreakerRegistry() {

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreaker.java
Patch:
@@ -550,11 +550,11 @@ static <T> Supplier<Future<T>> decorateFuture(CircuitBreaker circuitBreaker,
     void onError(long duration, TimeUnit durationUnit, Throwable throwable);
 
     /**
-     * Records a successful call.
+     * Records a successful call. This method must be invoked when a call was
+     * successful.
      *
      * @param duration     The elapsed time duration of the call
-     * @param durationUnit The duration unit This method must be invoked when a call was
-     *                     successful.
+     * @param durationUnit The duration unit
      */
     void onSuccess(long duration, TimeUnit durationUnit);
 

File: resilience4j-core/src/main/java/io/github/resilience4j/core/registry/AbstractRegistry.java
Patch:
@@ -153,7 +153,7 @@ public EventPublisher<E> getEventPublisher() {
      * @param tags Tags of the instance.
      * @return Map containing all tags
      */
-    protected io.vavr.collection.Map getAllTags(io.vavr.collection.Map<String, String> tags) {
+    protected io.vavr.collection.Map<String, String> getAllTags(io.vavr.collection.Map<String, String> tags) {
         return Objects.requireNonNull(tags, TAGS_MUST_NOT_BE_NULL).merge(registryTags);
     }
 

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/bulkhead/configuration/BulkheadConfigurationProperties.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2019 Dan Maas
+ * Copyright 2019 Dan Maas , Mahmoud Romeh
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,7 @@
 package io.github.resilience4j.common.bulkhead.configuration;
 
 import io.github.resilience4j.bulkhead.BulkheadConfig;
+import io.github.resilience4j.common.CommonProperties;
 import io.github.resilience4j.common.utils.ConfigUtils;
 import io.github.resilience4j.core.ConfigurationNotFoundException;
 import io.github.resilience4j.core.StringUtils;
@@ -26,7 +27,7 @@
 import java.util.Map;
 import java.util.Objects;
 
-public class BulkheadConfigurationProperties {
+public class BulkheadConfigurationProperties extends CommonProperties {
 
     private Map<String, InstanceProperties> instances = new HashMap<>();
     private Map<String, InstanceProperties> configs = new HashMap<>();

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/bulkhead/configuration/ThreadPoolBulkheadConfigurationProperties.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2019 Dan Maas
+ * Copyright 2019 Dan Maas, Mahmoud Romeh
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 
 import io.github.resilience4j.bulkhead.Bulkhead;
 import io.github.resilience4j.bulkhead.ThreadPoolBulkheadConfig;
+import io.github.resilience4j.common.CommonProperties;
 import io.github.resilience4j.core.ConfigurationNotFoundException;
 import io.github.resilience4j.core.StringUtils;
 import io.github.resilience4j.core.lang.Nullable;
@@ -26,7 +27,7 @@
 import java.util.Map;
 import java.util.Objects;
 
-public class ThreadPoolBulkheadConfigurationProperties {
+public class ThreadPoolBulkheadConfigurationProperties extends CommonProperties {
 
     private Map<String, InstanceProperties> instances = new HashMap<>();
     private Map<String, InstanceProperties> configs = new HashMap<>();

File: resilience4j-spring-boot-common/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/AbstractCircuitBreakerConfigurationOnMissingBean.java
Patch:
@@ -55,11 +55,9 @@ public CircuitBreakerRegistry circuitBreakerRegistry(
         CircuitBreakerRegistry circuitBreakerRegistry =
             circuitBreakerConfiguration.createCircuitBreakerRegistry(circuitBreakerProperties,
                 circuitBreakerRegistryEventConsumer);
-
         // Register the event consumers
         circuitBreakerConfiguration
             .registerEventConsumer(circuitBreakerRegistry, eventConsumerRegistry);
-
         // Initialize backends that were initially configured.
         circuitBreakerConfiguration.initCircuitBreakerRegistry(circuitBreakerRegistry);
 

File: resilience4j-spring-cloud-common/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/AbstractRefreshScopedCircuitBreakerConfiguration.java
Patch:
@@ -38,11 +38,9 @@ public CircuitBreakerRegistry circuitBreakerRegistry(
         CircuitBreakerRegistry circuitBreakerRegistry =
             circuitBreakerConfiguration.createCircuitBreakerRegistry(circuitBreakerProperties,
                 circuitBreakerRegistryEventConsumer);
-
         // Register the event consumers
         circuitBreakerConfiguration
             .registerEventConsumer(circuitBreakerRegistry, eventConsumerRegistry);
-
         // Initialize backends that were initially configured.
         circuitBreakerConfiguration.initCircuitBreakerRegistry(circuitBreakerRegistry);
 

File: resilience4j-spring/src/main/java/io/github/resilience4j/circuitbreaker/configure/CircuitBreakerConfiguration.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 Robert Winkler
+ * Copyright 2017 Robert Winkler,Mahmoud Romeh
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -120,7 +120,8 @@ public CircuitBreakerRegistry createCircuitBreakerRegistry(
             .entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey,
                 entry -> circuitBreakerProperties.createCircuitBreakerConfig(entry.getValue())));
 
-        return CircuitBreakerRegistry.of(configs, circuitBreakerRegistryEventConsumer);
+        return CircuitBreakerRegistry.of(configs, circuitBreakerRegistryEventConsumer,
+            io.vavr.collection.HashMap.ofAll(circuitBreakerProperties.getTags()));
     }
 
     /**

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerMetrics.java
Patch:
@@ -63,7 +63,7 @@ private CircuitBreakerMetrics(int slidingWindowSize,
         this(slidingWindowSize, circuitBreakerConfig.getSlidingWindowType(), circuitBreakerConfig);
     }
 
-    static CircuitBreakerMetrics forCosed(CircuitBreakerConfig circuitBreakerConfig) {
+    static CircuitBreakerMetrics forClosed(CircuitBreakerConfig circuitBreakerConfig) {
         return new CircuitBreakerMetrics(circuitBreakerConfig.getSlidingWindowSize(),
             circuitBreakerConfig);
     }

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerStateMachine.java
Patch:
@@ -484,7 +484,7 @@ private class ClosedState implements CircuitBreakerState {
         private final AtomicBoolean isClosed;
 
         ClosedState() {
-            this.circuitBreakerMetrics = CircuitBreakerMetrics.forCosed(getCircuitBreakerConfig());
+            this.circuitBreakerMetrics = CircuitBreakerMetrics.forClosed(getCircuitBreakerConfig());
             this.isClosed = new AtomicBoolean(true);
         }
 

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerMetricsTest.java
Patch:
@@ -35,7 +35,7 @@ public void testCircuitBreakerMetrics() {
             .build();
 
         CircuitBreakerMetrics circuitBreakerMetrics = CircuitBreakerMetrics
-            .forCosed(circuitBreakerConfig);
+            .forClosed(circuitBreakerConfig);
 
         circuitBreakerMetrics.onSuccess(0, TimeUnit.NANOSECONDS);
         circuitBreakerMetrics.onSuccess(0, TimeUnit.NANOSECONDS);

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/circuitbreaker/configuration/CircuitBreakerConfigurationPropertiesTest.java
Patch:
@@ -37,6 +37,7 @@ public void testCreateCircuitBreakerRegistry() {
         instanceProperties1.setWaitDurationInOpenState(Duration.ofMillis(100));
         instanceProperties1.setEventConsumerBufferSize(100);
         instanceProperties1.setRegisterHealthIndicator(true);
+        instanceProperties1.setAllowHealthIndicatorToFail(true);
         instanceProperties1.setSlidingWindowType(CircuitBreakerConfig.SlidingWindowType.TIME_BASED);
         instanceProperties1.setSlidingWindowSize(200);
         instanceProperties1.setMinimumNumberOfCalls(10);
@@ -84,6 +85,8 @@ public void testCreateCircuitBreakerRegistry() {
             .getBackendProperties("backend1");
         assertThat(circuitBreakerConfigurationProperties.findCircuitBreakerProperties("backend1"))
             .isNotEmpty();
+        assertThat(circuitBreakerConfigurationProperties.findCircuitBreakerProperties("backend1").get().getRegisterHealthIndicator()).isTrue();
+        assertThat(circuitBreakerConfigurationProperties.findCircuitBreakerProperties("backend1").get().getAllowHealthIndicatorToFail()).isTrue();
         CircuitBreakerConfig circuitBreaker2 = circuitBreakerConfigurationProperties
             .createCircuitBreakerConfig(instanceProperties2);
         assertThat(circuitBreaker2).isNotNull();

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/event/BulkheadOnCallRejectedEvent.java
Patch:
@@ -35,8 +35,8 @@ public Type getEventType() {
     @Override
     public String toString() {
         return String.format("%s: Bulkhead '%s' rejected a call.",
-                   getCreationTime(),
-                   getBulkheadName()
-               );
+            getCreationTime(),
+            getBulkheadName()
+        );
     }
 }

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/utils/MetricNames.java
Patch:
@@ -1,13 +1,13 @@
 package io.github.resilience4j.bulkhead.utils;
 
 public class MetricNames {
-    private MetricNames() {
-    }
+
     public static final String DEFAULT_PREFIX = "resilience4j.bulkhead";
     public static final String AVAILABLE_CONCURRENT_CALLS = "available_concurrent_calls";
     public static final String MAX_ALLOWED_CONCURRENT_CALLS = "max_allowed_concurrent_calls";
-
     public static final String DEFAULT_PREFIX_THREAD_POOL = "resilience4j.thread_pool_bulkhead";
     public static final String CURRENT_THREAD_POOL_SIZE = "current_thread_pool_size";
     public static final String AVAILABLE_QUEUE_CAPACITY = "available_queue_capacity";
+    private MetricNames() {
+    }
 }

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/event/BulkheadEventTest.java
Patch:
@@ -18,8 +18,9 @@
  */
 package io.github.resilience4j.bulkhead.event;
 
-import org.junit.Test;
 import io.github.resilience4j.bulkhead.event.BulkheadEvent.Type;
+import org.junit.Test;
+
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class BulkheadEventTest {

File: resilience4j-cache/src/main/java/io/github/resilience4j/cache/event/CacheOnErrorEvent.java
Patch:
@@ -42,8 +42,8 @@ public Throwable getThrowable() {
     @Override
     public String toString() {
         return String.format("%s: Cache '%s' recorded an error: '%s'.",
-                getCreationTime(),
-                getCacheName(),
-                getThrowable().toString());
+            getCreationTime(),
+            getCacheName(),
+            getThrowable().toString());
     }
 }

File: resilience4j-cache/src/main/java/io/github/resilience4j/cache/event/CacheOnHitEvent.java
Patch:
@@ -42,8 +42,8 @@ public K getCacheKey() {
     @Override
     public String toString() {
         return String.format("%s: Cache '%s' recorded a cache hit on cache key '%s'.",
-                getCreationTime(),
-                getCacheName(),
-                getCacheKey().toString());
+            getCreationTime(),
+            getCacheName(),
+            getCacheKey().toString());
     }
 }

File: resilience4j-cache/src/main/java/io/github/resilience4j/cache/event/CacheOnMissEvent.java
Patch:
@@ -42,8 +42,8 @@ public K getCacheKey() {
     @Override
     public String toString() {
         return String.format("%s: Cache '%s' recorded a cache miss on cache key '%s'.",
-                getCreationTime(),
-                getCacheName(),
-                getCacheKey().toString());
+            getCreationTime(),
+            getCacheName(),
+            getCacheKey().toString());
     }
 }

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/event/CircuitBreakerOnErrorEvent.java
Patch:
@@ -28,7 +28,8 @@ public class CircuitBreakerOnErrorEvent extends AbstractCircuitBreakerEvent {
     private final Throwable throwable;
     private final Duration elapsedDuration;
 
-    public CircuitBreakerOnErrorEvent(String circuitBreakerName, Duration elapsedDuration, Throwable throwable) {
+    public CircuitBreakerOnErrorEvent(String circuitBreakerName, Duration elapsedDuration,
+        Throwable throwable) {
         super(circuitBreakerName);
         this.throwable = throwable;
         this.elapsedDuration = elapsedDuration;

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/utils/MetricNames.java
Patch:
@@ -1,6 +1,7 @@
 package io.github.resilience4j.circuitbreaker.utils;
 
 public class MetricNames {
+
     public static final String DEFAULT_PREFIX = "resilience4j.circuitbreaker";
     public static final String SUCCESSFUL = "successful";
     public static final String FAILED = "failed";

File: resilience4j-circularbuffer/src/test/java/io/github/resilience4j/circularbuffer/CircularFifoBufferTest.java
Patch:
@@ -19,18 +19,18 @@
 package io.github.resilience4j.circularbuffer;
 
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 import io.vavr.collection.List;
 import org.junit.Test;
 
 import java.io.IOException;
 import java.net.UnknownHostException;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 public class CircularFifoBufferTest {
 
     @Test
-    public void testCircularFifoBuffer(){
+    public void testCircularFifoBuffer() {
         CircularFifoBuffer<Exception> exceptionBuffer = new ConcurrentCircularFifoBuffer<>(4);
 
         assertThat(exceptionBuffer.size()).isEqualTo(0);

File: resilience4j-circularbuffer/src/test/java/io/github/resilience4j/circularbuffer/ConcurrentEvictingQueueGeneralTest.java
Patch:
@@ -18,9 +18,6 @@
  */
 package io.github.resilience4j.circularbuffer;
 
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -30,6 +27,9 @@
 import java.util.NoSuchElementException;
 import java.util.Queue;
 
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+
 
 public class ConcurrentEvictingQueueGeneralTest {
 

File: resilience4j-consumer/src/main/java/io/github/resilience4j/consumer/DefaultEventConsumerRegistry.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
-public class DefaultEventConsumerRegistry<T> implements EventConsumerRegistry<T>{
+public class DefaultEventConsumerRegistry<T> implements EventConsumerRegistry<T> {
 
     /**
      * The CircularEventConsumers, indexed by name of the backend.
@@ -43,12 +43,12 @@ public CircularEventConsumer<T> createEventConsumer(String id, int bufferSize) {
     }
 
     @Override
-    public CircularEventConsumer<T> getEventConsumer(String id){
+    public CircularEventConsumer<T> getEventConsumer(String id) {
         return registry.get(id);
     }
 
     @Override
-    public Seq<CircularEventConsumer<T>> getAllEventConsumer(){
+    public Seq<CircularEventConsumer<T>> getAllEventConsumer() {
         return Array.ofAll(registry.values());
     }
 }

File: resilience4j-consumer/src/main/java/io/github/resilience4j/consumer/EventConsumerRegistry.java
Patch:
@@ -24,7 +24,7 @@ public interface EventConsumerRegistry<T> {
     /**
      * Creates a new EventConsumer and stores the instance in the registry.
      *
-     * @param id the id of the EventConsumer
+     * @param id         the id of the EventConsumer
      * @param bufferSize the size of the EventConsumer
      * @return a new EventConsumer
      */

File: resilience4j-core/src/main/java/io/github/resilience4j/core/StopWatch.java
Patch:
@@ -30,7 +30,7 @@ public class StopWatch {
     private final Instant startTime;
     private Clock clock;
 
-    StopWatch(Clock clock){
+    StopWatch(Clock clock) {
         this.clock = clock;
         this.startTime = clock.instant();
     }

File: resilience4j-core/src/main/java/io/github/resilience4j/core/lang/NonNullApi.java
Patch:
@@ -23,8 +23,8 @@
 import java.lang.annotation.*;
 
 /**
- * A common annotation to declare that parameters and return values
- * are to be considered as non-nullable by default for a given package.
+ * A common annotation to declare that parameters and return values are to be considered as
+ * non-nullable by default for a given package.
  * <p>
  * <p>Leverages JSR-305 meta-annotations to indicate nullability in Java to common
  * tools with JSR-305 support and used by Kotlin to infer nullability of the API.
@@ -42,4 +42,5 @@
 @Nonnull
 @TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})
 public @interface NonNullApi {
+
 }
\ No newline at end of file

File: resilience4j-core/src/main/java/io/github/resilience4j/core/metrics/PartialAggregation.java
Patch:
@@ -22,7 +22,7 @@ public class PartialAggregation extends AbstractAggregation {
 
     private long epochSecond;
 
-    PartialAggregation(long epochSecond){
+    PartialAggregation(long epochSecond) {
         this.epochSecond = epochSecond;
     }
 

File: resilience4j-core/src/main/java/io/github/resilience4j/core/metrics/SnapshotImpl.java
Patch:
@@ -59,7 +59,7 @@ public int getNumberOfSlowFailedCalls() {
 
     @Override
     public float getSlowCallRate() {
-        if(totalNumberOfCalls == 0){
+        if (totalNumberOfCalls == 0) {
             return 0;
         }
         return totalNumberOfSlowCalls * 100.0f / totalNumberOfCalls;
@@ -82,15 +82,15 @@ public int getTotalNumberOfCalls() {
 
     @Override
     public float getFailureRate() {
-        if(totalNumberOfCalls == 0){
+        if (totalNumberOfCalls == 0) {
             return 0;
         }
         return totalNumberOfFailedCalls * 100.0f / totalNumberOfCalls;
     }
 
     @Override
     public Duration getAverageDuration() {
-        if(totalNumberOfCalls == 0){
+        if (totalNumberOfCalls == 0) {
             return Duration.ZERO;
         }
         return Duration.ofMillis(totalDurationInMillis / totalNumberOfCalls);

File: resilience4j-core/src/main/java/io/github/resilience4j/core/metrics/TotalAggregation.java
Patch:
@@ -20,7 +20,7 @@
 
 class TotalAggregation extends AbstractAggregation {
 
-    void removeBucket(AbstractAggregation bucket){
+    void removeBucket(AbstractAggregation bucket) {
         this.totalDurationInMillis -= bucket.totalDurationInMillis;
         this.numberOfSlowCalls -= bucket.numberOfSlowCalls;
         this.numberOfSlowFailedCalls -= bucket.numberOfSlowFailedCalls;

File: resilience4j-core/src/main/java/io/github/resilience4j/core/registry/EntryAddedEvent.java
Patch:
@@ -23,7 +23,7 @@ public class EntryAddedEvent<E> extends AbstractRegistryEvent {
 
     private E addedEntry;
 
-    EntryAddedEvent(E addedEntry){
+    EntryAddedEvent(E addedEntry) {
         this.addedEntry = addedEntry;
     }
 

File: resilience4j-core/src/main/java/io/github/resilience4j/core/registry/EntryRemovedEvent.java
Patch:
@@ -18,11 +18,11 @@
  */
 package io.github.resilience4j.core.registry;
 
-public class EntryRemovedEvent<E> extends AbstractRegistryEvent{
+public class EntryRemovedEvent<E> extends AbstractRegistryEvent {
 
     private E removedEntry;
 
-    EntryRemovedEvent(E removedEntry){
+    EntryRemovedEvent(E removedEntry) {
         this.removedEntry = removedEntry;
     }
 

File: resilience4j-core/src/main/java/io/github/resilience4j/core/registry/EntryReplacedEvent.java
Patch:
@@ -23,7 +23,7 @@ public class EntryReplacedEvent<E> extends AbstractRegistryEvent {
     private final E oldEntry;
     private final E newEntry;
 
-    EntryReplacedEvent(E oldEntry, E newEntry){
+    EntryReplacedEvent(E oldEntry, E newEntry) {
         super();
         this.oldEntry = oldEntry;
         this.newEntry = newEntry;

File: resilience4j-core/src/test/java/io/github/resilience4j/core/EventProcessorTest.java
Patch:
@@ -32,12 +32,12 @@ public class EventProcessorTest {
     private Logger logger;
 
     @Before
-    public void setUp(){
+    public void setUp() {
         logger = mock(Logger.class);
     }
 
     @Test
-    public void testRegisterOnEventConsumer(){
+    public void testRegisterOnEventConsumer() {
         EventProcessor<Number> eventProcessor = new EventProcessor<>();
         EventConsumer<Number> eventConsumer = event -> logger.info(event.toString());
 

File: resilience4j-core/src/test/java/io/github/resilience4j/core/StringUtilsTest.java
Patch:
@@ -7,17 +7,17 @@
 public class StringUtilsTest {
 
     @Test
-    public void testString(){
+    public void testString() {
         assertThat(StringUtils.isNotEmpty("bla")).isEqualTo(true);
     }
 
     @Test
-    public void testEmptyString(){
+    public void testEmptyString() {
         assertThat(StringUtils.isNotEmpty("")).isEqualTo(false);
     }
 
     @Test
-    public void testNull(){
+    public void testNull() {
         assertThat(StringUtils.isNotEmpty(null)).isEqualTo(false);
     }
 }

File: resilience4j-core/src/test/java/io/github/resilience4j/core/functions/OnceConsumerTest.java
Patch:
@@ -6,9 +6,7 @@
 import java.util.List;
 import java.util.function.Consumer;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatCode;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.Assertions.*;
 
 /**
  * Class OnceConsumer test.

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/retry/RetryMethodInterceptor.java
Patch:
@@ -137,7 +137,7 @@ private CompletionStage<?> executeCompletionStage(MethodInvocation invocation, C
                     completeFailedFuture(t2, recoveryFunction, promise);
                 }
             } else {
-                context.onSuccess();
+                context.onComplete();
                 promise.complete(v);
             }
         });

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/retry/RetryTransformer.java
Patch:
@@ -61,7 +61,7 @@ public Upstream<T> apply(Upstream<? extends T> upstream) {
 
                 @Override
                 public void success(T value) {
-                    context.onSuccess();
+                    context.onComplete();
                     down.success(value);
                 }
 

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/retry/RetryOperator.java
Patch:
@@ -17,14 +17,13 @@
 
 import io.github.resilience4j.reactor.IllegalPublisherException;
 import io.github.resilience4j.retry.Retry;
+import org.reactivestreams.Publisher;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
 import java.util.function.Consumer;
 import java.util.function.UnaryOperator;
 
-import org.reactivestreams.Publisher;
-
 /**
  * A Reactor Retry operator which wraps a reactive type in a Retry.
  * @param <T> the value type of the upstream and downstream
@@ -76,7 +75,7 @@ private static class Context<T> {
 		}
 
 		void onComplete() {
-			this.context.onSuccess();
+			this.context.onComplete();
 		}
 
 		void throwExceptionToForceRetryOnResult(T value) {

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/retry/RetryOperatorTest.java
Patch:
@@ -233,7 +233,7 @@ public void retryOnResultUsingFlux() {
 
 		Retry.Metrics metrics = retry.getMetrics();
 		assertThat(metrics.getNumberOfFailedCallsWithoutRetryAttempt()).isEqualTo(0);
-		assertThat(metrics.getNumberOfSuccessfulCallsWithRetryAttempt()).isEqualTo(1);
+		assertThat(metrics.getNumberOfFailedCallsWithRetryAttempt()).isEqualTo(1);
 	}
 
 	@Test
@@ -252,7 +252,7 @@ public void retryOnResultFailAfterMaxAttemptsUsingFlux() {
 
 		Retry.Metrics metrics = retry.getMetrics();
 		assertThat(metrics.getNumberOfFailedCallsWithoutRetryAttempt()).isEqualTo(0);
-		assertThat(metrics.getNumberOfSuccessfulCallsWithRetryAttempt()).isEqualTo(1);
+		assertThat(metrics.getNumberOfFailedCallsWithRetryAttempt()).isEqualTo(1);
 	}
 
 	private RetryConfig retryConfig() {

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedThreadPoolBulkheadMetricsPublisherTest.java
Patch:
@@ -94,7 +94,7 @@ public void shouldReplaceMetrics() {
         assertThat(successful.get().value()).isEqualTo(bulkhead.getMetrics().getMaximumThreadPoolSize());
 
         ThreadPoolBulkhead newBulkhead = ThreadPoolBulkhead.of(bulkhead.getName(), ThreadPoolBulkheadConfig.custom()
-                .maxThreadPoolSize(10).build());
+                .maxThreadPoolSize(Runtime.getRuntime().availableProcessors() + 1).build());
 
         bulkheadRegistry.replace(bulkhead.getName(), newBulkhead);
 

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerStateMachine.java
Patch:
@@ -34,6 +34,7 @@
 import java.time.Instant;
 import java.util.Objects;
 import java.util.concurrent.CompletionException;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -190,7 +191,7 @@ public void acquirePermission() {
     public void onError(long duration, TimeUnit durationUnit, Throwable throwable) {
         // Handle the case if the completable future throws a CompletionException wrapping the original exception
         // where original exception is the the one to retry not the CompletionException.
-        if (throwable instanceof CompletionException) {
+        if (throwable instanceof CompletionException || throwable instanceof ExecutionException) {
             Throwable cause = throwable.getCause();
             handleThrowable(duration, durationUnit, cause);
         }else{

File: resilience4j-test/src/main/java/io/github/resilience4j/test/HelloWorldService.java
Patch:
@@ -22,11 +22,14 @@
 import io.vavr.control.Try;
 
 import java.io.IOException;
+import java.util.concurrent.Future;
 
 public interface HelloWorldService {
 
     String returnHelloWorld();
 
+    Future<String> returnHelloWorldFuture();
+
     Either<HelloWorldException, String> returnEither();
 
     Try<String> returnTry();

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/Retry.java
Patch:
@@ -568,6 +568,8 @@ interface Context<T> {
 	/**
 	 * An EventPublisher which subscribes to the reactive stream of RetryEvents and
 	 * can be used to register event consumers.
+	 *
+	 * To understand when the handlers are called, see the documentation of the respective events.
 	 */
 	interface EventPublisher extends io.github.resilience4j.core.EventPublisher<RetryEvent> {
 

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/event/RetryOnRetryEvent.java
Patch:
@@ -5,7 +5,7 @@
 import java.time.Duration;
 
 /**
- * A RetryEvent which informs that a call is to be retried.
+ * A RetryEvent which informs that a call failed, and is to be retried.
  */
 public class RetryOnRetryEvent extends AbstractRetryEvent {
 

File: resilience4j-retry/src/test/java/io/github/resilience4j/retry/event/RetryEventTest.java
Patch:
@@ -35,7 +35,7 @@ public void testRetryOnErrorEvent() {
         assertThat(retryOnErrorEvent.getNumberOfRetryAttempts()).isEqualTo(2);
         assertThat(retryOnErrorEvent.getEventType()).isEqualTo(Type.ERROR);
         assertThat(retryOnErrorEvent.getLastThrowable()).isInstanceOf(IOException.class);
-        assertThat(retryOnErrorEvent.toString()).contains("Retry 'test' recorded a failed retry attempt. Number of retry attempts: '2', Last exception was: 'java.io.IOException: Bla'.");
+        assertThat(retryOnErrorEvent.toString()).contains("Retry 'test' recorded a failed retry attempt. Number of retry attempts: '2'. Giving up. Last exception was: 'java.io.IOException: Bla'.");
     }
 
     @Test

File: resilience4j-spring/src/main/java/io/github/resilience4j/circuitbreaker/configure/CircuitBreakerConfigurationProperties.java
Patch:
@@ -15,8 +15,6 @@
  */
 package io.github.resilience4j.circuitbreaker.configure;
 
-
-import org.springframework.context.annotation.Configuration;
 import org.springframework.core.Ordered;
 
 public class CircuitBreakerConfigurationProperties extends io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigurationProperties {

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/InMemoryBulkheadRegistry.java
Patch:
@@ -51,7 +51,7 @@ public InMemoryBulkheadRegistry(io.vavr.collection.Map<String, String> tags) {
 	}
 
 	public InMemoryBulkheadRegistry(Map<String, BulkheadConfig> configs) {
-		this(configs.getOrDefault(DEFAULT_CONFIG, BulkheadConfig.ofDefaults()), HashMap.empty());
+		this(configs, HashMap.empty());
 	}
 
 	public InMemoryBulkheadRegistry(Map<String, BulkheadConfig> configs, io.vavr.collection.Map<String, String> tags) {

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/InMemoryCircuitBreakerRegistry.java
Patch:
@@ -51,7 +51,7 @@ public InMemoryCircuitBreakerRegistry(io.vavr.collection.Map<String, String> tag
 	}
 
 	public InMemoryCircuitBreakerRegistry(Map<String, CircuitBreakerConfig> configs) {
-		this(configs.getOrDefault(DEFAULT_CONFIG, CircuitBreakerConfig.ofDefaults()), HashMap.empty());
+		this(configs, HashMap.empty());
 	}
 
 	public InMemoryCircuitBreakerRegistry(Map<String, CircuitBreakerConfig> configs, io.vavr.collection.Map<String, String> tags) {

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/SemaphoreBasedRateLimiterImplTest.java
Patch:
@@ -261,13 +261,13 @@ public void getDetailedMetrics() throws Exception {
     public void constructionWithNullName() throws Exception {
         exception.expect(NullPointerException.class);
         exception.expectMessage(NAME_MUST_NOT_BE_NULL);
-        new SemaphoreBasedRateLimiter(null, config, null);
+        new SemaphoreBasedRateLimiter(null, config, (ScheduledExecutorService) null);
     }
 
     @Test
     public void constructionWithNullConfig() throws Exception {
         exception.expect(NullPointerException.class);
         exception.expectMessage(CONFIG_MUST_NOT_BE_NULL);
-        new SemaphoreBasedRateLimiter("test", null, null);
+        new SemaphoreBasedRateLimiter("test", null, (ScheduledExecutorService) null);
     }
 }

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerConfigTest.java
Patch:
@@ -22,8 +22,6 @@
 import org.junit.Test;
 
 import java.time.Duration;
-import java.time.temporal.TemporalUnit;
-import java.util.concurrent.TimeUnit;
 import java.util.function.Predicate;
 
 import static io.github.resilience4j.circuitbreaker.CircuitBreakerConfig.*;

File: resilience4j-spring/src/main/java/io/github/resilience4j/circuitbreaker/configure/CircuitBreakerAspect.java
Patch:
@@ -119,9 +119,8 @@ private io.github.resilience4j.circuitbreaker.CircuitBreaker getOrCreateCircuitB
 		io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(backend);
 
 		if (logger.isDebugEnabled()) {
-			logger.debug("Created or retrieved circuit breaker '{}' with failure rate '{}' and wait interval '{}' for method: '{}'",
-					backend, circuitBreaker.getCircuitBreakerConfig().getFailureRateThreshold(),
-					circuitBreaker.getCircuitBreakerConfig().getWaitDurationInOpenState(), methodName);
+			logger.debug("Created or retrieved circuit breaker '{}' with failure rate '{}' for method: '{}'",
+					backend, circuitBreaker.getCircuitBreakerConfig().getFailureRateThreshold(), methodName);
 		}
 
 		return circuitBreaker;

File: resilience4j-core/src/test/java/io/github/resilience4j/core/IntervalFunctionTest.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.retry;
+package io.github.resilience4j.core;
 
 import io.vavr.collection.List;
 import io.vavr.control.Try;

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/retry/configuration/RetryConfigurationProperties.java
Patch:
@@ -18,9 +18,9 @@
 import io.github.resilience4j.common.utils.ConfigUtils;
 import io.github.resilience4j.core.ClassUtils;
 import io.github.resilience4j.core.ConfigurationNotFoundException;
+import io.github.resilience4j.core.IntervalFunction;
 import io.github.resilience4j.core.StringUtils;
 import io.github.resilience4j.core.lang.Nullable;
-import io.github.resilience4j.retry.IntervalFunction;
 import io.github.resilience4j.retry.RetryConfig;
 
 import java.time.Duration;

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/RetryConfig.java
Patch:
@@ -19,6 +19,7 @@
 package io.github.resilience4j.retry;
 
 
+import io.github.resilience4j.core.IntervalFunction;
 import io.github.resilience4j.core.lang.Nullable;
 import io.github.resilience4j.core.predicate.PredicateCreator;
 

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/RetryImpl.java
Patch:
@@ -20,6 +20,7 @@
 
 import io.github.resilience4j.core.EventConsumer;
 import io.github.resilience4j.core.EventProcessor;
+import io.github.resilience4j.core.IntervalFunction;
 import io.github.resilience4j.core.lang.Nullable;
 import io.github.resilience4j.retry.Retry;
 import io.github.resilience4j.retry.RetryConfig;

File: resilience4j-retry/src/test/java/io/github/resilience4j/retry/internal/RunnableRetryTest.java
Patch:
@@ -18,7 +18,7 @@
  */
 package io.github.resilience4j.retry.internal;
 
-import io.github.resilience4j.retry.IntervalFunction;
+import io.github.resilience4j.core.IntervalFunction;
 import io.github.resilience4j.retry.Retry;
 import io.github.resilience4j.retry.RetryConfig;
 import io.github.resilience4j.test.HelloWorldException;

File: resilience4j-retry/src/test/java/io/github/resilience4j/retry/internal/SupplierRetryTest.java
Patch:
@@ -18,7 +18,7 @@
  */
 package io.github.resilience4j.retry.internal;
 
-import io.github.resilience4j.retry.IntervalFunction;
+import io.github.resilience4j.core.IntervalFunction;
 import io.github.resilience4j.retry.Retry;
 import io.github.resilience4j.retry.RetryConfig;
 import io.github.resilience4j.test.AsyncHelloWorldService;

File: resilience4j-spring/src/test/java/io/github/resilience4j/fallback/FallbackMethodTest.java
Patch:
@@ -22,7 +22,7 @@
 
 import org.junit.Test;
 
-@SuppressWarnings({"WeakerAccess", "unused"})
+@SuppressWarnings("unused")
 public class FallbackMethodTest {
     @Test
     public void recoverRuntimeExceptionTest() throws Throwable {
@@ -94,7 +94,7 @@ public void notFoundRecoveryMethod_shouldThrowsNoSuchMethodException() throws Th
     }
 
     public String testMethod(String parameter) {
-        return null;
+        return "test";
     }
 
     public String fallbackMethod(String parameter, RuntimeException exception) {

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakersHealthIndicatorAutoConfiguration.java
Patch:
@@ -11,6 +11,7 @@
 import org.springframework.boot.autoconfigure.AutoConfigureBefore;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 
@@ -22,6 +23,7 @@ public class CircuitBreakersHealthIndicatorAutoConfiguration {
 
     @Bean
     @ConditionalOnMissingBean(name = "circuitBreakersHealthIndicator")
+    @ConditionalOnProperty(prefix = "management.health.circuitbreakers", name = "enabled")
     public CircuitBreakersHealthIndicator circuitBreakersHealthIndicator(CircuitBreakerRegistry circuitBreakerRegistry,
                                                                          CircuitBreakerConfigurationProperties circuitBreakerProperties,
                                                                          HealthAggregator healthAggregator) {

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimitersHealthIndicatorAutoConfiguration.java
Patch:
@@ -11,6 +11,7 @@
 import org.springframework.boot.autoconfigure.AutoConfigureBefore;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 
@@ -22,6 +23,7 @@ public class RateLimitersHealthIndicatorAutoConfiguration {
 
     @Bean
     @ConditionalOnMissingBean(name = "rateLimitersHealthIndicator")
+    @ConditionalOnProperty(prefix = "management.health.ratelimiters", name = "enabled")
     public RateLimitersHealthIndicator rateLimitersHealthIndicator(RateLimiterRegistry rateLimiterRegistry,
                                                                    RateLimiterConfigurationProperties rateLimiterProperties,
                                                                    HealthAggregator healthAggregator) {

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakersHealthIndicatorAutoConfiguration.java
Patch:
@@ -11,6 +11,7 @@
 import org.springframework.boot.autoconfigure.AutoConfigureBefore;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 
@@ -22,6 +23,7 @@ public class CircuitBreakersHealthIndicatorAutoConfiguration {
 
     @Bean
     @ConditionalOnMissingBean(name = "circuitBreakersHealthIndicator")
+    @ConditionalOnProperty(prefix = "management.health.circuitbreakers", name = "enabled")
     public CircuitBreakersHealthIndicator circuitBreakersHealthIndicator(CircuitBreakerRegistry circuitBreakerRegistry,
                                                                          CircuitBreakerConfigurationProperties circuitBreakerProperties,
                                                                          HealthAggregator healthAggregator) {

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimitersHealthIndicatorAutoConfiguration.java
Patch:
@@ -11,6 +11,7 @@
 import org.springframework.boot.autoconfigure.AutoConfigureBefore;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 
@@ -22,6 +23,7 @@ public class RateLimitersHealthIndicatorAutoConfiguration {
 
     @Bean
     @ConditionalOnMissingBean(name = "rateLimitersHealthIndicator")
+    @ConditionalOnProperty(prefix = "management.health.ratelimiters", name = "enabled")
     public RateLimitersHealthIndicator rateLimitersHealthIndicator(RateLimiterRegistry rateLimiterRegistry,
                                                                    RateLimiterConfigurationProperties rateLimiterProperties,
                                                                    HealthAggregator healthAggregator) {

File: resilience4j-metrics/src/test/java/io/github/resilience4j/metrics/AbstractTimeLimiterMetricsTest.java
Patch:
@@ -33,7 +33,8 @@ public abstract class AbstractTimeLimiterMetricsTest {
     protected static final String FAILED = "failed";
     protected static final String TIMEOUT = "timeout";
 
-    protected MetricRegistry metricRegistry;
+    // fix visibility
+    protected volatile MetricRegistry metricRegistry;
 
     @Before
     public void setUp() {

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/SemaphoreBasedRateLimiter.java
Patch:
@@ -127,6 +127,9 @@ public void changeLimitForPeriod(int limitForPeriod) {
         rateLimiterConfig.set(newConfig);
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public boolean acquirePermission() {
         try {

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterTest.java
Patch:
@@ -280,6 +280,7 @@ public void waitForPermissionWithInterruption() throws Exception {
             Boolean interrupted = Match(cause).of(
                 Case($(instanceOf(IllegalStateException.class)), true)
             );
+            interrupted = interrupted && Thread.currentThread().isInterrupted();
             wasInterrupted.set(interrupted);
         });
         thread.setDaemon(true);

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/AtomicRateLimiterTest.java
Patch:
@@ -42,7 +42,7 @@
 public class AtomicRateLimiterTest {
 
     private static final String LIMITER_NAME = "test";
-    private static final long CYCLE_IN_NANOS = 500_000_000L;
+    private static final long CYCLE_IN_NANOS = 250_000_000L;
     private static final long POLL_INTERVAL_IN_NANOS = 2_000_000L;
     private static final int PERMISSIONS_RER_CYCLE = 1;
     private AtomicRateLimiter rateLimiter;

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/IntervalFunction.java
Patch:
@@ -152,10 +152,12 @@ final class IntervalFunctionCompanion {
     private IntervalFunctionCompanion() {
     }
 
+    @SuppressWarnings("squid:S2245") // this is not security-sensitive code
     static double randomize(final double current, final double randomizationFactor) {
         final double delta = randomizationFactor * current;
         final double min = current - delta;
         final double max = current + delta;
+
         return (min + (Math.random() * (max - min + 1)));
     }
 

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/AtomicRateLimiterTest.java
Patch:
@@ -42,7 +42,7 @@
 public class AtomicRateLimiterTest {
 
     private static final String LIMITER_NAME = "test";
-    private static final long CYCLE_IN_NANOS = 50_000_000L;
+    private static final long CYCLE_IN_NANOS = 500_000_000L;
     private static final long POLL_INTERVAL_IN_NANOS = 2_000_000L;
     private static final int PERMISSIONS_RER_CYCLE = 1;
     private AtomicRateLimiter rateLimiter;

File: resilience4j-spring-boot-common/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/health/CircuitBreakersHealthIndicator.java
Patch:
@@ -27,6 +27,8 @@
 import java.util.Map;
 import java.util.stream.Collectors;
 
+import static io.github.resilience4j.circuitbreaker.configure.CircuitBreakerConfigurationProperties.*;
+
 /**
  * A Spring Boot health indicators which adds the state of a CircuitBreaker and it's metrics to the health endpoints
  */
@@ -65,7 +67,7 @@ public Health health() {
 
     private boolean isRegisterHealthIndicator(CircuitBreaker circuitBreaker) {
         return circuitBreakerProperties.findCircuitBreakerProperties(circuitBreaker.getName())
-                .map(CircuitBreakerConfigurationProperties.InstanceProperties::getRegisterHealthIndicator)
+                .map(InstanceProperties::getRegisterHealthIndicator)
                 .orElse(false);
     }
 

File: resilience4j-spring-boot-common/src/main/java/io/github/resilience4j/ratelimiter/monitoring/health/RateLimitersHealthIndicator.java
Patch:
@@ -27,6 +27,8 @@
 import java.util.Map;
 import java.util.stream.Collectors;
 
+import static io.github.resilience4j.ratelimiter.configure.RateLimiterConfigurationProperties.*;
+
 public class RateLimitersHealthIndicator implements HealthIndicator {
 
     private final RateLimiterRegistry rateLimiterRegistry;
@@ -52,7 +54,7 @@ public Health health() {
 
     private boolean isRegisterHealthIndicator(RateLimiter rateLimiter) {
         return rateLimiterProperties.findRateLimiterProperties(rateLimiter.getName())
-                .map(RateLimiterConfigurationProperties.InstanceProperties::getRegisterHealthIndicator)
+                .map(InstanceProperties::getRegisterHealthIndicator)
                 .orElse(false);
     }
 

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/BulkheadFullException.java
Patch:
@@ -28,7 +28,7 @@ public class BulkheadFullException extends RuntimeException {
      *
      * @param bulkhead the Bulkhead.
      */
-    public static BulkheadFullException getBulkheadFullException(Bulkhead bulkhead) {
+    public static BulkheadFullException createBulkheadFullException(Bulkhead bulkhead) {
         boolean writableStackTraceEnabled = bulkhead.getBulkheadConfig().isWritableStackTraceEnabled();
 
         String message = String.format("Bulkhead '%s' is full and does not permit further calls", bulkhead.getName());
@@ -41,7 +41,7 @@ public static BulkheadFullException getBulkheadFullException(Bulkhead bulkhead)
      *
      * @param bulkhead the Bulkhead.
      */
-    public static BulkheadFullException getBulkheadFullException(ThreadPoolBulkhead bulkhead) {
+    public static BulkheadFullException createBulkheadFullException(ThreadPoolBulkhead bulkhead) {
         boolean writableStackTraceEnabled = bulkhead.getBulkheadConfig().isWritableStackTraceEnabled();
 
         String message = String.format("Bulkhead '%s' is full and does not permit further calls", bulkhead.getName());

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/FixedThreadPoolBulkhead.java
Patch:
@@ -19,6 +19,7 @@
 package io.github.resilience4j.bulkhead.internal;
 
 
+import io.github.resilience4j.bulkhead.BulkheadFullException;
 import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;
 import io.github.resilience4j.bulkhead.ThreadPoolBulkheadConfig;
 import io.github.resilience4j.bulkhead.event.BulkheadEvent;
@@ -32,7 +33,6 @@
 import java.util.concurrent.*;
 import java.util.function.Supplier;
 
-import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -117,7 +117,7 @@ public <T> CompletableFuture<T> submit(Callable<T> callable) {
 			});
 		} catch (RejectedExecutionException rejected) {
 			publishBulkheadEvent(() -> new BulkheadOnCallRejectedEvent(name));
-			throw getBulkheadFullException(this);
+			throw BulkheadFullException.createBulkheadFullException(this);
 		}
 		return promise;
 	}
@@ -138,7 +138,7 @@ public void submit(Runnable runnable) {
 			}, executorService).whenComplete((voidResult, throwable) -> publishBulkheadEvent(() -> new BulkheadOnCallFinishedEvent(name)));
 		} catch (RejectedExecutionException rejected) {
 			publishBulkheadEvent(() -> new BulkheadOnCallRejectedEvent(name));
-			throw getBulkheadFullException(this);
+			throw BulkheadFullException.createBulkheadFullException(this);
 		}
 	}
 

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/SemaphoreBulkhead.java
Patch:
@@ -34,7 +34,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
 
-import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+import static io.github.resilience4j.bulkhead.BulkheadFullException.createBulkheadFullException;
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -117,7 +117,7 @@ public boolean tryAcquirePermission() {
     @Override
     public void acquirePermission() {
         if(!tryAcquirePermission()) {
-            throw BulkheadFullException.getBulkheadFullException(this);
+            throw BulkheadFullException.createBulkheadFullException(this);
         }
     }
 

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CallNotPermittedException.java
Patch:
@@ -29,7 +29,7 @@ public class CallNotPermittedException extends RuntimeException {
      *
      * @param circuitBreaker the CircuitBreaker.
      */
-    public static CallNotPermittedException getCallNotPermittedException(CircuitBreaker circuitBreaker) {
+    public static CallNotPermittedException createCallNotPermittedException(CircuitBreaker circuitBreaker) {
         boolean writableStackTraceEnabled = circuitBreaker.getCircuitBreakerConfig().isWritableStackTraceEnabled();
 
         String message = String.format("CircuitBreaker '%s' is %s and does not permit further calls", circuitBreaker.getName(), circuitBreaker.getState());

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/CallNotPermittedExceptionTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.junit.Test;
 
-import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.createCallNotPermittedException;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class CallNotPermittedExceptionTest {
@@ -11,13 +11,13 @@ public class CallNotPermittedExceptionTest {
     public void shouldReturnCorrectMessageWhenStateIsOpen(){
         CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("testName");
         circuitBreaker.transitionToOpenState();
-        assertThat(getCallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is OPEN and does not permit further calls");
+        assertThat(createCallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is OPEN and does not permit further calls");
     }
 
     @Test
     public void shouldReturnCorrectMessageWhenStateIsForcedOpen(){
         CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("testName");
         circuitBreaker.transitionToForcedOpenState();
-        assertThat(getCallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is FORCED_OPEN and does not permit further calls");
+        assertThat(createCallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is FORCED_OPEN and does not permit further calls");
     }
 }

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerOpenExceptionTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.junit.Test;
 
-import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.createCallNotPermittedException;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class CircuitBreakerOpenExceptionTest {
@@ -11,13 +11,13 @@ public class CircuitBreakerOpenExceptionTest {
     public void shouldReturnCorrectMessageWhenStateIsOpen(){
         CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("testName");
         circuitBreaker.transitionToOpenState();
-        assertThat(getCallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is OPEN and does not permit further calls");
+        assertThat(createCallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is OPEN and does not permit further calls");
     }
 
     @Test
     public void shouldReturnCorrectMessageWhenStateIsForcedOpen(){
         CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("testName");
         circuitBreaker.transitionToForcedOpenState();
-        assertThat(getCallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is FORCED_OPEN and does not permit further calls");
+        assertThat(createCallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is FORCED_OPEN and does not permit further calls");
     }
 }

File: resilience4j-prometheus/src/main/java/io/github/resilience4j/prometheus/collectors/TimeLimiterMetricsCollector.java
Patch:
@@ -36,7 +36,7 @@ public class TimeLimiterMetricsCollector extends AbstractTimeLimiterMetrics {
      * @param names    the custom metric names
      * @param timeLimiterRegistry the source of time limiters
      */
-    public static TimeLimiterMetricsCollector ofTimeLimiterRegistry(TimeLimiterMetricsCollector.MetricNames names, TimeLimiterRegistry timeLimiterRegistry) {
+    public static TimeLimiterMetricsCollector ofTimeLimiterRegistry(MetricNames names, TimeLimiterRegistry timeLimiterRegistry) {
         return new TimeLimiterMetricsCollector(names, timeLimiterRegistry);
     }
 
@@ -46,7 +46,7 @@ public static TimeLimiterMetricsCollector ofTimeLimiterRegistry(TimeLimiterMetri
      * @param timeLimiterRegistry the source of time limiters
      */
     public static TimeLimiterMetricsCollector ofTimeLimiterRegistry(TimeLimiterRegistry timeLimiterRegistry) {
-        return new TimeLimiterMetricsCollector(TimeLimiterMetricsCollector.MetricNames.ofDefaults(), timeLimiterRegistry);
+        return new TimeLimiterMetricsCollector(MetricNames.ofDefaults(), timeLimiterRegistry);
     }
 
     private final TimeLimiterRegistry timeLimiterRegistry;

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java
Patch:
@@ -37,8 +37,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 
-import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
-
 /**
  * A RateLimiter instance is thread-safe can be used to decorate multiple requests.
  * <p>
@@ -286,7 +284,7 @@ static void waitForPermission(final RateLimiter rateLimiter) {
 			throw new IllegalStateException("Thread was interrupted during permission wait");
 		}
 		if (!permission) {
-			throw getRequestNotPermitted(rateLimiter);
+			throw RequestNotPermitted.createRequestNotPermitted(rateLimiter);
 		}
 	}
 

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RequestNotPermitted.java
Patch:
@@ -29,7 +29,7 @@ public class RequestNotPermitted extends RuntimeException {
      *
      * @param rateLimiter the RateLimiter.
      */
-    public static RequestNotPermitted getRequestNotPermitted(RateLimiter rateLimiter) {
+    public static RequestNotPermitted createRequestNotPermitted(RateLimiter rateLimiter) {
         boolean writableStackTraceEnabled = rateLimiter.getRateLimiterConfig().isWritableStackTraceEnabled();
 
         String message = String.format("RateLimiter '%s' does not permit further calls", rateLimiter.getName());

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/bulkhead/BulkheadMethodInterceptor.java
Patch:
@@ -34,8 +34,6 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
 
-import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
-
 /**
  * A {@link MethodInterceptor} to handle all methods annotated with {@link Bulkhead}. It will
  *  handle methods that return a {@link Promise}, {@link reactor.core.publisher.Flux}, {@link reactor.core.publisher.Mono}, {@link java.util.concurrent.CompletionStage}, or value.
@@ -121,7 +119,7 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
                     });
                 }
             } else {
-                Throwable t = BulkheadFullException.getBulkheadFullException(bulkhead);
+                Throwable t = BulkheadFullException.createBulkheadFullException(bulkhead);
                 completeFailedFuture(t, fallbackMethod, promise);
             }
             return promise;

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/bulkhead/BulkheadTransformer.java
Patch:
@@ -22,8 +22,6 @@
 import ratpack.exec.Upstream;
 import ratpack.func.Function;
 
-import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
-
 
 public class BulkheadTransformer<T> extends AbstractTransformer<T> {
 
@@ -83,7 +81,7 @@ public void complete() {
                     }
                 });
             } else {
-                Throwable t = BulkheadFullException.getBulkheadFullException(bulkhead);
+                Throwable t = BulkheadFullException.createBulkheadFullException(bulkhead);
                 handleRecovery(down, t);
             }
         };

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/circuitbreaker/CircuitBreakerMethodInterceptor.java
Patch:
@@ -16,7 +16,6 @@
 package io.github.resilience4j.ratpack.circuitbreaker;
 
 import com.google.inject.Inject;
-import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
 import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
 import io.github.resilience4j.core.lang.Nullable;
@@ -35,7 +34,7 @@
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.TimeUnit;
 
-import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.createCallNotPermittedException;
 
 /**
  * A {@link MethodInterceptor} to handle all methods annotated with {@link CircuitBreaker}. It will
@@ -126,7 +125,7 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
                     });
                 }
             } else {
-                Throwable t = getCallNotPermittedException(breaker);
+                Throwable t = createCallNotPermittedException(breaker);
                 completeFailedFuture(t, fallbackMethod, promise);
             }
             return promise;

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/circuitbreaker/CircuitBreakerTransformer.java
Patch:
@@ -24,8 +24,6 @@
 
 import java.util.concurrent.TimeUnit;
 
-import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
-
 public class CircuitBreakerTransformer<T> extends AbstractTransformer<T> {
     private CircuitBreaker circuitBreaker;
 
@@ -86,7 +84,7 @@ public void complete() {
                     }
                 });
             } else {
-                Throwable t = getCallNotPermittedException(circuitBreaker);
+                Throwable t = CallNotPermittedException.createCallNotPermittedException(circuitBreaker);
                 handleRecovery(down, t);
             }
         };

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/ratelimiter/RateLimiterHandler.java
Patch:
@@ -18,11 +18,10 @@
 
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
-import io.github.resilience4j.ratelimiter.RequestNotPermitted;
 import ratpack.handling.Context;
 import ratpack.handling.Handler;
 
-import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.createRequestNotPermitted;
 
 public class RateLimiterHandler implements Handler {
 
@@ -43,7 +42,7 @@ public void handle(Context ctx) throws Exception {
             throw new IllegalStateException("Thread was interrupted during permission wait");
         }
         if (!permission) {
-            Throwable t = getRequestNotPermitted(rateLimiter);
+            Throwable t = createRequestNotPermitted(rateLimiter);
             ctx.error(t);
         } else {
             ctx.next();

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/ratelimiter/RateLimiterMethodInterceptor.java
Patch:
@@ -19,7 +19,6 @@
 import com.google.inject.Inject;
 import io.github.resilience4j.core.lang.Nullable;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
-import io.github.resilience4j.ratelimiter.RequestNotPermitted;
 import io.github.resilience4j.ratelimiter.annotation.RateLimiter;
 import io.github.resilience4j.ratpack.internal.AbstractMethodInterceptor;
 import io.github.resilience4j.ratpack.recovery.DefaultRecoveryFunction;
@@ -35,7 +34,7 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
 
-import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.createRequestNotPermitted;
 
 /**
  * A {@link MethodInterceptor} to handle all methods annotated with {@link RateLimiter}. It will
@@ -111,7 +110,7 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
                 return proceed(invocation);
             } else {
                 final CompletableFuture promise = new CompletableFuture<>();
-                Throwable t = getRequestNotPermitted(rateLimiter);
+                Throwable t = createRequestNotPermitted(rateLimiter);
                 completeFailedFuture(t, fallbackMethod, promise);
                 return promise;
             }

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/ratelimiter/RateLimiterTransformer.java
Patch:
@@ -22,8 +22,6 @@
 import ratpack.exec.Upstream;
 import ratpack.func.Function;
 
-import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
-
 public class RateLimiterTransformer<T> extends AbstractTransformer<T> {
 
     private final RateLimiter rateLimiter;
@@ -63,7 +61,7 @@ public Upstream<T> apply(Upstream<? extends T> upstream) throws Exception {
                 throw new IllegalStateException("Thread was interrupted during permission wait");
             }
             if (!permission) {
-                Throwable t = getRequestNotPermitted(rateLimiter);
+                Throwable t = RequestNotPermitted.createRequestNotPermitted(rateLimiter);
                 if (recoverer != null) {
                     down.success(recoverer.apply(t));
                 } else {

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/bulkhead/operator/BulkheadSubscriber.java
Patch:
@@ -20,9 +20,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
 
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
 import static java.util.Objects.requireNonNull;
 

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/bulkhead/operator/FluxBulkhead.java
Patch:
@@ -22,7 +22,7 @@
 import reactor.core.publisher.FluxOperator;
 import reactor.core.publisher.Operators;
 
-import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+import static io.github.resilience4j.bulkhead.BulkheadFullException.createBulkheadFullException;
 
 class FluxBulkhead<T> extends FluxOperator<T, T> {
 
@@ -38,7 +38,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
         if(bulkhead.tryAcquirePermission()){
             source.subscribe(new BulkheadSubscriber<>(bulkhead, actual, false));
         }else{
-            Operators.error(actual, BulkheadFullException.getBulkheadFullException(bulkhead));
+            Operators.error(actual, BulkheadFullException.createBulkheadFullException(bulkhead));
         }
     }
 

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/bulkhead/operator/MonoBulkhead.java
Patch:
@@ -22,7 +22,7 @@
 import reactor.core.publisher.MonoOperator;
 import reactor.core.publisher.Operators;
 
-import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+import static io.github.resilience4j.bulkhead.BulkheadFullException.createBulkheadFullException;
 
 class MonoBulkhead<T> extends MonoOperator<T, T> {
     private final Bulkhead bulkhead;
@@ -37,7 +37,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
         if(bulkhead.tryAcquirePermission()){
             source.subscribe(new BulkheadSubscriber<>(bulkhead, actual, true));
         }else{
-            Operators.error(actual, BulkheadFullException.getBulkheadFullException(bulkhead));
+            Operators.error(actual, BulkheadFullException.createBulkheadFullException(bulkhead));
         }
     }
 }

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/circuitbreaker/operator/FluxCircuitBreaker.java
Patch:
@@ -15,14 +15,13 @@
  */
 package io.github.resilience4j.reactor.circuitbreaker.operator;
 
-import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import reactor.core.CoreSubscriber;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.FluxOperator;
 import reactor.core.publisher.Operators;
 
-import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.createCallNotPermittedException;
 
 class FluxCircuitBreaker<T> extends FluxOperator<T, T> {
 
@@ -38,7 +37,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
         if(circuitBreaker.tryAcquirePermission()){
             source.subscribe(new CircuitBreakerSubscriber<>(circuitBreaker, actual, false));
         }else{
-            Operators.error(actual, getCallNotPermittedException(circuitBreaker));
+            Operators.error(actual, createCallNotPermittedException(circuitBreaker));
         }
     }
 

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/circuitbreaker/operator/MonoCircuitBreaker.java
Patch:
@@ -15,14 +15,13 @@
  */
 package io.github.resilience4j.reactor.circuitbreaker.operator;
 
-import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import reactor.core.CoreSubscriber;
 import reactor.core.publisher.Mono;
 import reactor.core.publisher.MonoOperator;
 import reactor.core.publisher.Operators;
 
-import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.createCallNotPermittedException;
 
 class MonoCircuitBreaker<T> extends MonoOperator<T, T> {
 
@@ -38,7 +37,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
         if(circuitBreaker.tryAcquirePermission()){
             source.subscribe(new CircuitBreakerSubscriber<>(circuitBreaker, actual, true));
         }else{
-            Operators.error(actual, getCallNotPermittedException(circuitBreaker));
+            Operators.error(actual, createCallNotPermittedException(circuitBreaker));
         }
     }
 }

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/ratelimiter/operator/FluxRateLimiter.java
Patch:
@@ -16,7 +16,6 @@
 package io.github.resilience4j.reactor.ratelimiter.operator;
 
 import io.github.resilience4j.ratelimiter.RateLimiter;
-import io.github.resilience4j.ratelimiter.RequestNotPermitted;
 import reactor.core.CoreSubscriber;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.FluxOperator;
@@ -25,7 +24,7 @@
 
 import java.time.Duration;
 
-import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.createRequestNotPermitted;
 
 class FluxRateLimiter<T> extends FluxOperator<T, T> {
 
@@ -47,7 +46,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
                 source.subscribe(new RateLimiterSubscriber<>(actual));
             }
         }else{
-            Operators.error(actual, getRequestNotPermitted(rateLimiter));
+            Operators.error(actual, createRequestNotPermitted(rateLimiter));
         }
     }
 

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/ratelimiter/operator/MonoRateLimiter.java
Patch:
@@ -16,15 +16,14 @@
 package io.github.resilience4j.reactor.ratelimiter.operator;
 
 import io.github.resilience4j.ratelimiter.RateLimiter;
-import io.github.resilience4j.ratelimiter.RequestNotPermitted;
 import reactor.core.CoreSubscriber;
 import reactor.core.publisher.Mono;
 import reactor.core.publisher.MonoOperator;
 import reactor.core.publisher.Operators;
 
 import java.time.Duration;
 
-import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.createRequestNotPermitted;
 
 class MonoRateLimiter<T> extends MonoOperator<T, T> {
     private final RateLimiter rateLimiter;
@@ -45,7 +44,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
                 source.subscribe(new RateLimiterSubscriber<>(actual));
             }
         }else{
-            Operators.error(actual, getRequestNotPermitted(rateLimiter));
+            Operators.error(actual, createRequestNotPermitted(rateLimiter));
         }
     }
 }

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/CompletableBulkhead.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.CompletableObserver;
 import io.reactivex.internal.disposables.EmptyDisposable;
 
-import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+import static io.github.resilience4j.bulkhead.BulkheadFullException.createBulkheadFullException;
 
 class CompletableBulkhead extends Completable {
 
@@ -40,7 +40,7 @@ protected void subscribeActual(CompletableObserver downstream) {
             upstream.subscribe(new BulkheadCompletableObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(BulkheadFullException.getBulkheadFullException(bulkhead));
+            downstream.onError(BulkheadFullException.createBulkheadFullException(bulkhead));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/FlowableBulkhead.java
Patch:
@@ -25,7 +25,7 @@
 
 import java.util.Objects;
 
-import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+import static io.github.resilience4j.bulkhead.BulkheadFullException.createBulkheadFullException;
 import static java.util.Objects.requireNonNull;
 
 class FlowableBulkhead<T> extends Flowable<T> {
@@ -44,7 +44,7 @@ protected void subscribeActual(Subscriber<? super T> downstream) {
             upstream.subscribe(new BulkheadSubscriber(downstream));
         }else{
             downstream.onSubscribe(EmptySubscription.INSTANCE);
-            downstream.onError(BulkheadFullException.getBulkheadFullException(bulkhead));
+            downstream.onError(BulkheadFullException.createBulkheadFullException(bulkhead));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/MaybeBulkhead.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.MaybeObserver;
 import io.reactivex.internal.disposables.EmptyDisposable;
 
-import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+import static io.github.resilience4j.bulkhead.BulkheadFullException.createBulkheadFullException;
 
 class MaybeBulkhead<T> extends Maybe<T> {
 
@@ -40,7 +40,7 @@ protected void subscribeActual(MaybeObserver<? super T> downstream) {
             upstream.subscribe(new BulkheadMaybeObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(BulkheadFullException.getBulkheadFullException(bulkhead));
+            downstream.onError(BulkheadFullException.createBulkheadFullException(bulkhead));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/ObserverBulkhead.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.Observer;
 import io.reactivex.internal.disposables.EmptyDisposable;
 
-import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+import static io.github.resilience4j.bulkhead.BulkheadFullException.createBulkheadFullException;
 
 class ObserverBulkhead<T> extends Observable<T> {
 
@@ -40,7 +40,7 @@ protected void subscribeActual(Observer<? super T> downstream) {
             upstream.subscribe(new BulkheadObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(BulkheadFullException.getBulkheadFullException(bulkhead));
+            downstream.onError(BulkheadFullException.createBulkheadFullException(bulkhead));
         }
     }
     class BulkheadObserver extends AbstractObserver<T> {

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/SingleBulkhead.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.SingleObserver;
 import io.reactivex.internal.disposables.EmptyDisposable;
 
-import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+import static io.github.resilience4j.bulkhead.BulkheadFullException.createBulkheadFullException;
 
 class SingleBulkhead<T> extends Single<T> {
 
@@ -40,7 +40,7 @@ protected void subscribeActual(SingleObserver<? super T> downstream) {
             upstream.subscribe(new BulkheadSingleObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(BulkheadFullException.getBulkheadFullException(bulkhead));
+            downstream.onError(BulkheadFullException.createBulkheadFullException(bulkhead));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/CompletableCircuitBreaker.java
Patch:
@@ -16,15 +16,14 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
 import io.github.resilience4j.AbstractCompletableObserver;
-import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.reactivex.Completable;
 import io.reactivex.CompletableObserver;
 import io.reactivex.internal.disposables.EmptyDisposable;
 
 import java.util.concurrent.TimeUnit;
 
-import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.createCallNotPermittedException;
 
 class CompletableCircuitBreaker extends Completable {
 
@@ -42,7 +41,7 @@ protected void subscribeActual(CompletableObserver downstream) {
             upstream.subscribe(new CircuitBreakerCompletableObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(getCallNotPermittedException(circuitBreaker));
+            downstream.onError(createCallNotPermittedException(circuitBreaker));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/FlowableCircuitBreaker.java
Patch:
@@ -16,7 +16,6 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
 import io.github.resilience4j.AbstractSubscriber;
-import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.reactivex.Flowable;
 import io.reactivex.internal.subscriptions.EmptySubscription;
@@ -26,7 +25,7 @@
 import java.util.Objects;
 import java.util.concurrent.TimeUnit;
 
-import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.createCallNotPermittedException;
 import static java.util.Objects.requireNonNull;
 
 class FlowableCircuitBreaker<T> extends Flowable<T> {
@@ -45,7 +44,7 @@ protected void subscribeActual(Subscriber<? super T> downstream) {
             upstream.subscribe(new CircuitBreakerSubscriber(downstream));
         }else{
             downstream.onSubscribe(EmptySubscription.INSTANCE);
-            downstream.onError(getCallNotPermittedException(circuitBreaker));
+            downstream.onError(createCallNotPermittedException(circuitBreaker));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/MaybeCircuitBreaker.java
Patch:
@@ -16,15 +16,14 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
 import io.github.resilience4j.AbstractMaybeObserver;
-import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.reactivex.Maybe;
 import io.reactivex.MaybeObserver;
 import io.reactivex.internal.disposables.EmptyDisposable;
 
 import java.util.concurrent.TimeUnit;
 
-import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.createCallNotPermittedException;
 
 class MaybeCircuitBreaker<T> extends Maybe<T> {
 
@@ -42,7 +41,7 @@ protected void subscribeActual(MaybeObserver<? super T> downstream) {
             upstream.subscribe(new CircuitBreakerMaybeObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(getCallNotPermittedException(circuitBreaker));
+            downstream.onError(createCallNotPermittedException(circuitBreaker));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/ObserverCircuitBreaker.java
Patch:
@@ -16,15 +16,14 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
 import io.github.resilience4j.AbstractObserver;
-import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.reactivex.Observable;
 import io.reactivex.Observer;
 import io.reactivex.internal.disposables.EmptyDisposable;
 
 import java.util.concurrent.TimeUnit;
 
-import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.createCallNotPermittedException;
 
 class ObserverCircuitBreaker<T> extends Observable<T> {
 
@@ -42,7 +41,7 @@ protected void subscribeActual(Observer<? super T> downstream) {
             upstream.subscribe(new CircuitBreakerObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(getCallNotPermittedException(circuitBreaker));
+            downstream.onError(createCallNotPermittedException(circuitBreaker));
         }
     }
     class CircuitBreakerObserver extends AbstractObserver<T> {

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/SingleCircuitBreaker.java
Patch:
@@ -16,15 +16,14 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
 import io.github.resilience4j.AbstractSingleObserver;
-import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.reactivex.Single;
 import io.reactivex.SingleObserver;
 import io.reactivex.internal.disposables.EmptyDisposable;
 
 import java.util.concurrent.TimeUnit;
 
-import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.createCallNotPermittedException;
 
 class SingleCircuitBreaker<T> extends Single<T> {
 
@@ -42,7 +41,7 @@ protected void subscribeActual(SingleObserver<? super T> downstream) {
             upstream.subscribe(new CircuitBreakerSingleObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(getCallNotPermittedException(circuitBreaker));
+            downstream.onError(createCallNotPermittedException(circuitBreaker));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/CompletableRateLimiter.java
Patch:
@@ -24,8 +24,6 @@
 
 import java.util.concurrent.TimeUnit;
 
-import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
-
 class CompletableRateLimiter extends Completable {
 
     private final Completable upstream;
@@ -48,7 +46,7 @@ protected void subscribeActual(CompletableObserver downstream) {
             }
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(getRequestNotPermitted(rateLimiter));
+            downstream.onError(RequestNotPermitted.createRequestNotPermitted(rateLimiter));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/FlowableRateLimiter.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.github.resilience4j.AbstractSubscriber;
 import io.github.resilience4j.ratelimiter.RateLimiter;
-import io.github.resilience4j.ratelimiter.RequestNotPermitted;
 import io.reactivex.Completable;
 import io.reactivex.Flowable;
 import io.reactivex.internal.subscriptions.EmptySubscription;
@@ -27,7 +26,7 @@
 import java.util.Objects;
 import java.util.concurrent.TimeUnit;
 
-import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.createRequestNotPermitted;
 import static java.util.Objects.requireNonNull;
 
 class FlowableRateLimiter<T> extends Flowable<T> {
@@ -52,7 +51,7 @@ protected void subscribeActual(Subscriber<? super T> downstream) {
             }
         }else{
             downstream.onSubscribe(EmptySubscription.INSTANCE);
-            downstream.onError(getRequestNotPermitted(rateLimiter));
+            downstream.onError(createRequestNotPermitted(rateLimiter));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/MaybeRateLimiter.java
Patch:
@@ -25,8 +25,6 @@
 
 import java.util.concurrent.TimeUnit;
 
-import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
-
 class MaybeRateLimiter<T> extends Maybe<T> {
 
     private final Maybe<T> upstream;
@@ -49,7 +47,7 @@ protected void subscribeActual(MaybeObserver<? super T> downstream) {
             }
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(getRequestNotPermitted(rateLimiter));
+            downstream.onError(RequestNotPermitted.createRequestNotPermitted(rateLimiter));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/ObserverRateLimiter.java
Patch:
@@ -17,15 +17,14 @@
 
 import io.github.resilience4j.AbstractObserver;
 import io.github.resilience4j.ratelimiter.RateLimiter;
-import io.github.resilience4j.ratelimiter.RequestNotPermitted;
 import io.reactivex.Completable;
 import io.reactivex.Observable;
 import io.reactivex.Observer;
 import io.reactivex.internal.disposables.EmptyDisposable;
 
 import java.util.concurrent.TimeUnit;
 
-import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.createRequestNotPermitted;
 
 class ObserverRateLimiter<T> extends Observable<T> {
 
@@ -49,7 +48,7 @@ protected void subscribeActual(Observer<? super T> downstream) {
             }
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(getRequestNotPermitted(rateLimiter));
+            downstream.onError(createRequestNotPermitted(rateLimiter));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/SingleRateLimiter.java
Patch:
@@ -25,8 +25,6 @@
 
 import java.util.concurrent.TimeUnit;
 
-import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
-
 class SingleRateLimiter<T> extends Single<T> {
 
     private final RateLimiter rateLimiter;
@@ -49,7 +47,7 @@ protected void subscribeActual(SingleObserver<? super T> downstream) {
             }
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(getRequestNotPermitted(rateLimiter));
+            downstream.onError(RequestNotPermitted.createRequestNotPermitted(rateLimiter));
         }
     }
 

File: resilience4j-vertx/src/main/java/io/github/resilience4j/circuitbreaker/VertxCircuitBreaker.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
 
-import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.createCallNotPermittedException;
 
 /**
  * CircuitBreaker decorators for Vert.x
@@ -55,7 +55,7 @@ static <T> Supplier<Future<T>> decorateFuture(CircuitBreaker circuitBreaker, Sup
             final Future<T> future = Future.future();
 
             if (!circuitBreaker.tryAcquirePermission()) {
-                future.fail(getCallNotPermittedException(circuitBreaker));
+                future.fail(createCallNotPermittedException(circuitBreaker));
 
             } else {
                 long start = System.nanoTime();

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/utils/MetricNames.java
Patch:
@@ -4,9 +4,10 @@ public class MetricNames {
     public static final String DEFAULT_PREFIX = "resilience4j.circuitbreaker";
     public static final String SUCCESSFUL = "successful";
     public static final String FAILED = "failed";
+    public static final String SLOW = "slow";
     public static final String NOT_PERMITTED = "not_permitted";
     public static final String BUFFERED = "buffered";
-    public static final String BUFFERED_MAX = "buffered_max";
     public static final String STATE = "state";
     public static final String FAILURE_RATE = "failure_rate";
+    public static final String SLOW_CALL_RATE = "slow_call_rate";
 }

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/SemaphoreBasedRateLimiterImplTest.java
Patch:
@@ -36,7 +36,6 @@
 import static com.jayway.awaitility.Awaitility.await;
 import static io.vavr.control.Try.run;
 import static java.lang.Thread.State.*;
-import static java.time.LocalDateTime.now;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.hamcrest.CoreMatchers.equalTo;
@@ -47,7 +46,7 @@
 public class SemaphoreBasedRateLimiterImplTest {
 
     private static final int LIMIT = 2;
-    private static final Duration TIMEOUT = Duration.ofMillis(50);
+    private static final Duration TIMEOUT = Duration.ofMillis(100);
     private static final Duration REFRESH_PERIOD = Duration.ofMillis(100);
     private static final String CONFIG_MUST_NOT_BE_NULL = "Config must not be null";
     private static final String NAME_MUST_NOT_BE_NULL = "Name must not be null";

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/FixedThreadPoolBulkhead.java
Patch:
@@ -19,7 +19,6 @@
 package io.github.resilience4j.bulkhead.internal;
 
 
-import io.github.resilience4j.bulkhead.BulkheadFullException;
 import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;
 import io.github.resilience4j.bulkhead.ThreadPoolBulkheadConfig;
 import io.github.resilience4j.bulkhead.event.BulkheadEvent;
@@ -33,6 +32,7 @@
 import java.util.concurrent.*;
 import java.util.function.Supplier;
 
+import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -117,7 +117,7 @@ public <T> CompletableFuture<T> submit(Callable<T> callable) {
 			});
 		} catch (RejectedExecutionException rejected) {
 			publishBulkheadEvent(() -> new BulkheadOnCallRejectedEvent(name));
-			throw new BulkheadFullException(this);
+			throw getBulkheadFullException(this);
 		}
 		return promise;
 	}
@@ -138,7 +138,7 @@ public void submit(Runnable runnable) {
 			}, executorService).whenComplete((voidResult, throwable) -> publishBulkheadEvent(() -> new BulkheadOnCallFinishedEvent(name)));
 		} catch (RejectedExecutionException rejected) {
 			publishBulkheadEvent(() -> new BulkheadOnCallRejectedEvent(name));
-			throw new BulkheadFullException(this);
+			throw getBulkheadFullException(this);
 		}
 	}
 

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/SemaphoreBulkhead.java
Patch:
@@ -34,6 +34,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
 
+import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -116,7 +117,7 @@ public boolean tryAcquirePermission() {
     @Override
     public void acquirePermission() {
         if(!tryAcquirePermission()) {
-            throw new BulkheadFullException(this);
+            throw BulkheadFullException.getBulkheadFullException(this);
         }
     }
 

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/internal/SemaphoreBulkheadTest.java
Patch:
@@ -32,6 +32,7 @@
 
 import static com.jayway.awaitility.Awaitility.await;
 import static io.github.resilience4j.bulkhead.BulkheadConfig.DEFAULT_MAX_CONCURRENT_CALLS;
+import static io.github.resilience4j.bulkhead.BulkheadConfig.DEFAULT_WRITABLE_STACK_TRACE_ENABLED;
 import static io.github.resilience4j.bulkhead.event.BulkheadEvent.Type.*;
 import static java.lang.Thread.State.*;
 import static java.util.concurrent.TimeUnit.SECONDS;
@@ -115,6 +116,7 @@ public void testCreateWithDefaults() {
 		assertThat(bulkhead).isNotNull();
 		assertThat(bulkhead.getBulkheadConfig()).isNotNull();
 		assertThat(bulkhead.getBulkheadConfig().getMaxConcurrentCalls()).isEqualTo(DEFAULT_MAX_CONCURRENT_CALLS);
+		assertThat(bulkhead.getBulkheadConfig().isWritableStackTraceEnabled()).isEqualTo(DEFAULT_WRITABLE_STACK_TRACE_ENABLED);
 	}
 
 	@Test

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/circuitbreaker/configuration/CircuitBreakerConfigurationPropertiesTest.java
Patch:
@@ -45,7 +45,7 @@ public void testCreateCircuitBreakerRegistry() {
 		instanceProperties1.setSlowCallRateThreshold(50f);
 		instanceProperties1.setPermittedNumberOfCallsInHalfOpenState(100);
 		instanceProperties1.setAutomaticTransitionFromOpenToHalfOpenEnabled(true);
-		instanceProperties1.writableStackTraceEnabled(false);
+		instanceProperties1.setWritableStackTraceEnabled(false);
 		//noinspection unchecked
 		instanceProperties1.setIgnoreExceptions(new Class[]{IllegalStateException.class});
 		//noinspection unchecked

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java
Patch:
@@ -37,6 +37,8 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+
 /**
  * A RateLimiter instance is thread-safe can be used to decorate multiple requests.
  * <p>
@@ -284,7 +286,7 @@ static void waitForPermission(final RateLimiter rateLimiter) {
 			throw new IllegalStateException("Thread was interrupted during permission wait");
 		}
 		if (!permission) {
-			throw new RequestNotPermitted(rateLimiter);
+			throw getRequestNotPermitted(rateLimiter);
 		}
 	}
 

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/bulkhead/BulkheadMethodInterceptor.java
Patch:
@@ -34,6 +34,8 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
 
+import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+
 /**
  * A {@link MethodInterceptor} to handle all methods annotated with {@link Bulkhead}. It will
  *  handle methods that return a {@link Promise}, {@link reactor.core.publisher.Flux}, {@link reactor.core.publisher.Mono}, {@link java.util.concurrent.CompletionStage}, or value.
@@ -119,7 +121,7 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
                     });
                 }
             } else {
-                Throwable t = new BulkheadFullException(bulkhead);
+                Throwable t = BulkheadFullException.getBulkheadFullException(bulkhead);
                 completeFailedFuture(t, fallbackMethod, promise);
             }
             return promise;

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/bulkhead/BulkheadTransformer.java
Patch:
@@ -22,6 +22,8 @@
 import ratpack.exec.Upstream;
 import ratpack.func.Function;
 
+import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+
 
 public class BulkheadTransformer<T> extends AbstractTransformer<T> {
 
@@ -81,7 +83,7 @@ public void complete() {
                     }
                 });
             } else {
-                Throwable t = new BulkheadFullException(bulkhead);
+                Throwable t = BulkheadFullException.getBulkheadFullException(bulkhead);
                 handleRecovery(down, t);
             }
         };

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/ratelimiter/RateLimiterHandler.java
Patch:
@@ -22,6 +22,8 @@
 import ratpack.handling.Context;
 import ratpack.handling.Handler;
 
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+
 public class RateLimiterHandler implements Handler {
 
     private final RateLimiter rateLimiter;
@@ -41,7 +43,7 @@ public void handle(Context ctx) throws Exception {
             throw new IllegalStateException("Thread was interrupted during permission wait");
         }
         if (!permission) {
-            Throwable t = new RequestNotPermitted(rateLimiter);
+            Throwable t = getRequestNotPermitted(rateLimiter);
             ctx.error(t);
         } else {
             ctx.next();

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/ratelimiter/RateLimiterMethodInterceptor.java
Patch:
@@ -35,6 +35,8 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
 
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+
 /**
  * A {@link MethodInterceptor} to handle all methods annotated with {@link RateLimiter}. It will
  * handle methods that return a {@link Promise}, {@link reactor.core.publisher.Flux}, {@link reactor.core.publisher.Mono}, {@link java.util.concurrent.CompletionStage}, or value.
@@ -109,7 +111,7 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
                 return proceed(invocation);
             } else {
                 final CompletableFuture promise = new CompletableFuture<>();
-                Throwable t = new RequestNotPermitted(rateLimiter);
+                Throwable t = getRequestNotPermitted(rateLimiter);
                 completeFailedFuture(t, fallbackMethod, promise);
                 return promise;
             }

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/ratelimiter/RateLimiterTransformer.java
Patch:
@@ -22,6 +22,8 @@
 import ratpack.exec.Upstream;
 import ratpack.func.Function;
 
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+
 public class RateLimiterTransformer<T> extends AbstractTransformer<T> {
 
     private final RateLimiter rateLimiter;
@@ -61,7 +63,7 @@ public Upstream<T> apply(Upstream<? extends T> upstream) throws Exception {
                 throw new IllegalStateException("Thread was interrupted during permission wait");
             }
             if (!permission) {
-                Throwable t = new RequestNotPermitted(rateLimiter);
+                Throwable t = getRequestNotPermitted(rateLimiter);
                 if (recoverer != null) {
                     down.success(recoverer.apply(t));
                 } else {

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/bulkhead/operator/FluxBulkhead.java
Patch:
@@ -22,6 +22,8 @@
 import reactor.core.publisher.FluxOperator;
 import reactor.core.publisher.Operators;
 
+import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+
 class FluxBulkhead<T> extends FluxOperator<T, T> {
 
     private final Bulkhead bulkhead;
@@ -36,7 +38,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
         if(bulkhead.tryAcquirePermission()){
             source.subscribe(new BulkheadSubscriber<>(bulkhead, actual, false));
         }else{
-            Operators.error(actual, new BulkheadFullException(bulkhead));
+            Operators.error(actual, BulkheadFullException.getBulkheadFullException(bulkhead));
         }
     }
 

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/bulkhead/operator/MonoBulkhead.java
Patch:
@@ -22,6 +22,8 @@
 import reactor.core.publisher.MonoOperator;
 import reactor.core.publisher.Operators;
 
+import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+
 class MonoBulkhead<T> extends MonoOperator<T, T> {
     private final Bulkhead bulkhead;
 
@@ -35,7 +37,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
         if(bulkhead.tryAcquirePermission()){
             source.subscribe(new BulkheadSubscriber<>(bulkhead, actual, true));
         }else{
-            Operators.error(actual, new BulkheadFullException(bulkhead));
+            Operators.error(actual, BulkheadFullException.getBulkheadFullException(bulkhead));
         }
     }
 }

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/ratelimiter/operator/FluxRateLimiter.java
Patch:
@@ -25,6 +25,8 @@
 
 import java.time.Duration;
 
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+
 class FluxRateLimiter<T> extends FluxOperator<T, T> {
 
     private final RateLimiter rateLimiter;
@@ -45,7 +47,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
                 source.subscribe(new RateLimiterSubscriber<>(actual));
             }
         }else{
-            Operators.error(actual, new RequestNotPermitted(rateLimiter));
+            Operators.error(actual, getRequestNotPermitted(rateLimiter));
         }
     }
 

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/ratelimiter/operator/MonoRateLimiter.java
Patch:
@@ -24,6 +24,8 @@
 
 import java.time.Duration;
 
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+
 class MonoRateLimiter<T> extends MonoOperator<T, T> {
     private final RateLimiter rateLimiter;
 
@@ -43,7 +45,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
                 source.subscribe(new RateLimiterSubscriber<>(actual));
             }
         }else{
-            Operators.error(actual, new RequestNotPermitted(rateLimiter));
+            Operators.error(actual, getRequestNotPermitted(rateLimiter));
         }
     }
 }

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/bulkhead/operator/FluxBulkheadTest.java
Patch:
@@ -38,7 +38,7 @@ public class FluxBulkheadTest {
 
     @Before
     public void setUp(){
-        bulkhead = Mockito.mock(Bulkhead.class);
+        bulkhead = Mockito.mock(Bulkhead.class, RETURNS_DEEP_STUBS);
     }
 
     @Test

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/bulkhead/operator/MonoBulkheadTest.java
Patch:
@@ -35,7 +35,7 @@ public class MonoBulkheadTest {
 
     @Before
     public void setUp(){
-        bulkhead = Mockito.mock(Bulkhead.class);
+        bulkhead = Mockito.mock(Bulkhead.class, RETURNS_DEEP_STUBS);
     }
 
     @Test

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/ratelimiter/operator/FluxRateLimiterTest.java
Patch:
@@ -27,14 +27,15 @@
 import java.time.Duration;
 
 import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
 
 public class FluxRateLimiterTest {
 
     private RateLimiter rateLimiter;
 
     @Before
     public void setUp(){
-        rateLimiter = Mockito.mock(RateLimiter.class);
+        rateLimiter = Mockito.mock(RateLimiter.class, RETURNS_DEEP_STUBS);
     }
 
     @Test

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/ratelimiter/operator/MonoRateLimiterTest.java
Patch:
@@ -27,14 +27,15 @@
 import java.time.Duration;
 
 import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
 
 public class MonoRateLimiterTest {
 
     private RateLimiter rateLimiter;
 
     @Before
     public void setUp(){
-        rateLimiter = Mockito.mock(RateLimiter.class);
+        rateLimiter = Mockito.mock(RateLimiter.class, RETURNS_DEEP_STUBS);
     }
 
     @Test

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/CompletableBulkhead.java
Patch:
@@ -22,6 +22,8 @@
 import io.reactivex.CompletableObserver;
 import io.reactivex.internal.disposables.EmptyDisposable;
 
+import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+
 class CompletableBulkhead extends Completable {
 
     private final Completable upstream;
@@ -38,7 +40,7 @@ protected void subscribeActual(CompletableObserver downstream) {
             upstream.subscribe(new BulkheadCompletableObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(new BulkheadFullException(bulkhead));
+            downstream.onError(BulkheadFullException.getBulkheadFullException(bulkhead));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/FlowableBulkhead.java
Patch:
@@ -25,6 +25,7 @@
 
 import java.util.Objects;
 
+import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
 import static java.util.Objects.requireNonNull;
 
 class FlowableBulkhead<T> extends Flowable<T> {
@@ -43,7 +44,7 @@ protected void subscribeActual(Subscriber<? super T> downstream) {
             upstream.subscribe(new BulkheadSubscriber(downstream));
         }else{
             downstream.onSubscribe(EmptySubscription.INSTANCE);
-            downstream.onError(new BulkheadFullException(bulkhead));
+            downstream.onError(BulkheadFullException.getBulkheadFullException(bulkhead));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/MaybeBulkhead.java
Patch:
@@ -22,6 +22,8 @@
 import io.reactivex.MaybeObserver;
 import io.reactivex.internal.disposables.EmptyDisposable;
 
+import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+
 class MaybeBulkhead<T> extends Maybe<T> {
 
     private final Maybe<T> upstream;
@@ -38,7 +40,7 @@ protected void subscribeActual(MaybeObserver<? super T> downstream) {
             upstream.subscribe(new BulkheadMaybeObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(new BulkheadFullException(bulkhead));
+            downstream.onError(BulkheadFullException.getBulkheadFullException(bulkhead));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/ObserverBulkhead.java
Patch:
@@ -22,6 +22,8 @@
 import io.reactivex.Observer;
 import io.reactivex.internal.disposables.EmptyDisposable;
 
+import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+
 class ObserverBulkhead<T> extends Observable<T> {
 
     private final Observable<T> upstream;
@@ -38,7 +40,7 @@ protected void subscribeActual(Observer<? super T> downstream) {
             upstream.subscribe(new BulkheadObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(new BulkheadFullException(bulkhead));
+            downstream.onError(BulkheadFullException.getBulkheadFullException(bulkhead));
         }
     }
     class BulkheadObserver extends AbstractObserver<T> {

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/SingleBulkhead.java
Patch:
@@ -22,6 +22,8 @@
 import io.reactivex.SingleObserver;
 import io.reactivex.internal.disposables.EmptyDisposable;
 
+import static io.github.resilience4j.bulkhead.BulkheadFullException.getBulkheadFullException;
+
 class SingleBulkhead<T> extends Single<T> {
 
     private final Bulkhead bulkhead;
@@ -38,7 +40,7 @@ protected void subscribeActual(SingleObserver<? super T> downstream) {
             upstream.subscribe(new BulkheadSingleObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(new BulkheadFullException(bulkhead));
+            downstream.onError(BulkheadFullException.getBulkheadFullException(bulkhead));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/CompletableRateLimiter.java
Patch:
@@ -24,6 +24,8 @@
 
 import java.util.concurrent.TimeUnit;
 
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+
 class CompletableRateLimiter extends Completable {
 
     private final Completable upstream;
@@ -46,7 +48,7 @@ protected void subscribeActual(CompletableObserver downstream) {
             }
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(new RequestNotPermitted(rateLimiter));
+            downstream.onError(getRequestNotPermitted(rateLimiter));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/FlowableRateLimiter.java
Patch:
@@ -27,6 +27,7 @@
 import java.util.Objects;
 import java.util.concurrent.TimeUnit;
 
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
 import static java.util.Objects.requireNonNull;
 
 class FlowableRateLimiter<T> extends Flowable<T> {
@@ -51,7 +52,7 @@ protected void subscribeActual(Subscriber<? super T> downstream) {
             }
         }else{
             downstream.onSubscribe(EmptySubscription.INSTANCE);
-            downstream.onError(new RequestNotPermitted(rateLimiter));
+            downstream.onError(getRequestNotPermitted(rateLimiter));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/MaybeRateLimiter.java
Patch:
@@ -25,6 +25,8 @@
 
 import java.util.concurrent.TimeUnit;
 
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+
 class MaybeRateLimiter<T> extends Maybe<T> {
 
     private final Maybe<T> upstream;
@@ -47,7 +49,7 @@ protected void subscribeActual(MaybeObserver<? super T> downstream) {
             }
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(new RequestNotPermitted(rateLimiter));
+            downstream.onError(getRequestNotPermitted(rateLimiter));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/ObserverRateLimiter.java
Patch:
@@ -25,6 +25,8 @@
 
 import java.util.concurrent.TimeUnit;
 
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+
 class ObserverRateLimiter<T> extends Observable<T> {
 
     private final Observable<T> upstream;
@@ -47,7 +49,7 @@ protected void subscribeActual(Observer<? super T> downstream) {
             }
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(new RequestNotPermitted(rateLimiter));
+            downstream.onError(getRequestNotPermitted(rateLimiter));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/SingleRateLimiter.java
Patch:
@@ -25,6 +25,8 @@
 
 import java.util.concurrent.TimeUnit;
 
+import static io.github.resilience4j.ratelimiter.RequestNotPermitted.getRequestNotPermitted;
+
 class SingleRateLimiter<T> extends Single<T> {
 
     private final RateLimiter rateLimiter;
@@ -47,7 +49,7 @@ protected void subscribeActual(SingleObserver<? super T> downstream) {
             }
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(new RequestNotPermitted(rateLimiter));
+            downstream.onError(getRequestNotPermitted(rateLimiter));
         }
     }
 

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/CompletableBulkheadTest.java
Patch:
@@ -21,7 +21,7 @@ public class CompletableBulkheadTest {
 
     @Before
     public void setUp(){
-        bulkhead = Mockito.mock(Bulkhead.class);
+        bulkhead = Mockito.mock(Bulkhead.class, RETURNS_DEEP_STUBS);
     }
 
     @Test

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/FlowableBulkheadTest.java
Patch:
@@ -21,7 +21,7 @@ public class FlowableBulkheadTest {
 
     @Before
     public void setUp(){
-        bulkhead = Mockito.mock(Bulkhead.class);
+        bulkhead = Mockito.mock(Bulkhead.class, RETURNS_DEEP_STUBS);
     }
 
     @Test

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/MaybeBulkheadTest.java
Patch:
@@ -23,7 +23,7 @@ public class MaybeBulkheadTest {
 
     @Before
     public void setUp(){
-        bulkhead = Mockito.mock(Bulkhead.class);
+        bulkhead = Mockito.mock(Bulkhead.class, RETURNS_DEEP_STUBS);
     }
 
     @Test

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/ObserverBulkheadTest.java
Patch:
@@ -21,7 +21,7 @@ public class ObserverBulkheadTest {
 
     @Before
     public void setUp(){
-        bulkhead = Mockito.mock(Bulkhead.class);
+        bulkhead = Mockito.mock(Bulkhead.class, RETURNS_DEEP_STUBS);
     }
 
     @Test

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/SingleBulkheadTest.java
Patch:
@@ -24,7 +24,7 @@ public class SingleBulkheadTest {
 
     @Before
     public void setUp(){
-        bulkhead = Mockito.mock(Bulkhead.class);
+        bulkhead = Mockito.mock(Bulkhead.class, RETURNS_DEEP_STUBS);
     }
 
     @Test

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/CompletableRateLimiterTest.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.concurrent.TimeUnit;
 
 import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
 
 /**
  * Unit test for {@link CompletableRateLimiter}.
@@ -22,7 +23,7 @@ public class CompletableRateLimiterTest {
 
     @Before
     public void setUp(){
-        rateLimiter = Mockito.mock(RateLimiter.class);
+        rateLimiter = Mockito.mock(RateLimiter.class, RETURNS_DEEP_STUBS);
     }
 
     @Test

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/FlowableRateLimiterTest.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.concurrent.TimeUnit;
 
 import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
 
 /**
  * Unit test for {@link FlowableRateLimiter}.
@@ -22,7 +23,7 @@ public class FlowableRateLimiterTest {
 
     @Before
     public void setUp(){
-        rateLimiter = Mockito.mock(RateLimiter.class);
+        rateLimiter = Mockito.mock(RateLimiter.class, RETURNS_DEEP_STUBS);
     }
 
     @Test

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/MaybeRateLimiterTest.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.concurrent.TimeUnit;
 
 import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
 
 /**
  * Unit test for {@link MaybeRateLimiter}.
@@ -22,7 +23,7 @@ public class MaybeRateLimiterTest {
 
     @Before
     public void setUp(){
-        rateLimiter = Mockito.mock(RateLimiter.class);
+        rateLimiter = Mockito.mock(RateLimiter.class, RETURNS_DEEP_STUBS);
     }
 
     @Test

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/ObserverRateLimiterTest.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.concurrent.TimeUnit;
 
 import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
 
 /**
  * Unit test for {@link ObserverRateLimiter}.
@@ -22,7 +23,7 @@ public class ObserverRateLimiterTest {
 
     @Before
     public void setUp(){
-        rateLimiter = Mockito.mock(RateLimiter.class);
+        rateLimiter = Mockito.mock(RateLimiter.class, RETURNS_DEEP_STUBS);
     }
 
     @Test

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/SingleRateLimiterTest.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.concurrent.TimeUnit;
 
 import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
 
 /**
  * Unit test for {@link SingleRateLimiter}.
@@ -22,7 +23,7 @@ public class SingleRateLimiterTest {
 
     @Before
     public void setUp(){
-        rateLimiter = Mockito.mock(RateLimiter.class);
+        rateLimiter = Mockito.mock(RateLimiter.class, RETURNS_DEEP_STUBS);
     }
 
     @Test

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/CallNotPermittedExceptionTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.junit.Test;
 
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class CallNotPermittedExceptionTest {
@@ -10,13 +11,13 @@ public class CallNotPermittedExceptionTest {
     public void shouldReturnCorrectMessageWhenStateIsOpen(){
         CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("testName");
         circuitBreaker.transitionToOpenState();
-        assertThat(new CallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is OPEN and does not permit further calls");
+        assertThat(getCallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is OPEN and does not permit further calls");
     }
 
     @Test
     public void shouldReturnCorrectMessageWhenStateIsForcedOpen(){
         CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("testName");
         circuitBreaker.transitionToForcedOpenState();
-        assertThat(new CallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is FORCED_OPEN and does not permit further calls");
+        assertThat(getCallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is FORCED_OPEN and does not permit further calls");
     }
 }

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerOpenExceptionTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.junit.Test;
 
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class CircuitBreakerOpenExceptionTest {
@@ -10,13 +11,13 @@ public class CircuitBreakerOpenExceptionTest {
     public void shouldReturnCorrectMessageWhenStateIsOpen(){
         CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("testName");
         circuitBreaker.transitionToOpenState();
-        assertThat(new CallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is OPEN and does not permit further calls");
+        assertThat(getCallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is OPEN and does not permit further calls");
     }
 
     @Test
     public void shouldReturnCorrectMessageWhenStateIsForcedOpen(){
         CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("testName");
         circuitBreaker.transitionToForcedOpenState();
-        assertThat(new CallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is FORCED_OPEN and does not permit further calls");
+        assertThat(getCallNotPermittedException(circuitBreaker).getMessage()).isEqualTo("CircuitBreaker 'testName' is FORCED_OPEN and does not permit further calls");
     }
 }

File: resilience4j-framework-common/src/test/java/io/github/resilience4j/common/circuitbreaker/configuration/CircuitBreakerConfigurationPropertiesTest.java
Patch:
@@ -45,6 +45,7 @@ public void testCreateCircuitBreakerRegistry() {
 		instanceProperties1.setSlowCallRateThreshold(50f);
 		instanceProperties1.setPermittedNumberOfCallsInHalfOpenState(100);
 		instanceProperties1.setAutomaticTransitionFromOpenToHalfOpenEnabled(true);
+		instanceProperties1.writableStackTraceEnabled(false);
 		//noinspection unchecked
 		instanceProperties1.setIgnoreExceptions(new Class[]{IllegalStateException.class});
 		//noinspection unchecked
@@ -75,6 +76,7 @@ public void testCreateCircuitBreakerRegistry() {
 		assertThat(circuitBreaker1.getSlowCallRateThreshold()).isEqualTo(50f);
 		assertThat(circuitBreaker1.getWaitDurationInOpenState().toMillis()).isEqualTo(100);
 		assertThat(circuitBreaker1.isAutomaticTransitionFromOpenToHalfOpenEnabled()).isTrue();
+		assertThat(circuitBreaker1.isWritableStackTraceEnabled()).isFalse();
 
 		final CircuitBreakerConfigurationProperties.InstanceProperties backend1 = circuitBreakerConfigurationProperties.getBackendProperties("backend1");
 		assertThat(circuitBreakerConfigurationProperties.findCircuitBreakerProperties("backend1")).isNotEmpty();

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/circuitbreaker/CircuitBreakerMethodInterceptor.java
Patch:
@@ -35,6 +35,8 @@
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.TimeUnit;
 
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+
 /**
  * A {@link MethodInterceptor} to handle all methods annotated with {@link CircuitBreaker}. It will
  * handle methods that return a {@link Promise}, {@link reactor.core.publisher.Flux}, {@link reactor.core.publisher.Mono}, {@link java.util.concurrent.CompletionStage}, or value.
@@ -124,7 +126,7 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
                     });
                 }
             } else {
-                Throwable t = new CallNotPermittedException(breaker);
+                Throwable t = getCallNotPermittedException(breaker);
                 completeFailedFuture(t, fallbackMethod, promise);
             }
             return promise;

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/circuitbreaker/CircuitBreakerTransformer.java
Patch:
@@ -24,6 +24,8 @@
 
 import java.util.concurrent.TimeUnit;
 
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+
 public class CircuitBreakerTransformer<T> extends AbstractTransformer<T> {
     private CircuitBreaker circuitBreaker;
 
@@ -84,7 +86,7 @@ public void complete() {
                     }
                 });
             } else {
-                Throwable t = new CallNotPermittedException(circuitBreaker);
+                Throwable t = getCallNotPermittedException(circuitBreaker);
                 handleRecovery(down, t);
             }
         };

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/circuitbreaker/operator/FluxCircuitBreaker.java
Patch:
@@ -22,6 +22,8 @@
 import reactor.core.publisher.FluxOperator;
 import reactor.core.publisher.Operators;
 
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+
 class FluxCircuitBreaker<T> extends FluxOperator<T, T> {
 
     private CircuitBreaker circuitBreaker;
@@ -36,7 +38,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
         if(circuitBreaker.tryAcquirePermission()){
             source.subscribe(new CircuitBreakerSubscriber<>(circuitBreaker, actual, false));
         }else{
-            Operators.error(actual, new CallNotPermittedException(circuitBreaker));
+            Operators.error(actual, getCallNotPermittedException(circuitBreaker));
         }
     }
 

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/circuitbreaker/operator/MonoCircuitBreaker.java
Patch:
@@ -22,6 +22,8 @@
 import reactor.core.publisher.MonoOperator;
 import reactor.core.publisher.Operators;
 
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+
 class MonoCircuitBreaker<T> extends MonoOperator<T, T> {
 
     private CircuitBreaker circuitBreaker;
@@ -36,7 +38,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
         if(circuitBreaker.tryAcquirePermission()){
             source.subscribe(new CircuitBreakerSubscriber<>(circuitBreaker, actual, true));
         }else{
-            Operators.error(actual, new CallNotPermittedException(circuitBreaker));
+            Operators.error(actual, getCallNotPermittedException(circuitBreaker));
         }
     }
 }

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/circuitbreaker/operator/FluxCircuitBreakerTest.java
Patch:
@@ -37,7 +37,7 @@ public class FluxCircuitBreakerTest {
 
     @Before
     public void setUp(){
-        circuitBreaker = Mockito.mock(CircuitBreaker.class);
+        circuitBreaker = Mockito.mock(CircuitBreaker.class, RETURNS_DEEP_STUBS);
     }
 
     @Test

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/circuitbreaker/operator/MonoCircuitBreakerTest.java
Patch:
@@ -43,7 +43,7 @@ public class MonoCircuitBreakerTest  {
 
     @Before
     public void setUp(){
-        circuitBreaker = Mockito.mock(CircuitBreaker.class);
+        circuitBreaker = Mockito.mock(CircuitBreaker.class, RETURNS_DEEP_STUBS);
         helloWorldService = Mockito.mock(HelloWorldService.class);
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/CompletableCircuitBreaker.java
Patch:
@@ -24,6 +24,8 @@
 
 import java.util.concurrent.TimeUnit;
 
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+
 class CompletableCircuitBreaker extends Completable {
 
     private final Completable upstream;
@@ -40,7 +42,7 @@ protected void subscribeActual(CompletableObserver downstream) {
             upstream.subscribe(new CircuitBreakerCompletableObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(new CallNotPermittedException(circuitBreaker));
+            downstream.onError(getCallNotPermittedException(circuitBreaker));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/FlowableCircuitBreaker.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.Objects;
 import java.util.concurrent.TimeUnit;
 
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
 import static java.util.Objects.requireNonNull;
 
 class FlowableCircuitBreaker<T> extends Flowable<T> {
@@ -44,7 +45,7 @@ protected void subscribeActual(Subscriber<? super T> downstream) {
             upstream.subscribe(new CircuitBreakerSubscriber(downstream));
         }else{
             downstream.onSubscribe(EmptySubscription.INSTANCE);
-            downstream.onError(new CallNotPermittedException(circuitBreaker));
+            downstream.onError(getCallNotPermittedException(circuitBreaker));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/MaybeCircuitBreaker.java
Patch:
@@ -24,6 +24,8 @@
 
 import java.util.concurrent.TimeUnit;
 
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+
 class MaybeCircuitBreaker<T> extends Maybe<T> {
 
     private final Maybe<T> upstream;
@@ -40,7 +42,7 @@ protected void subscribeActual(MaybeObserver<? super T> downstream) {
             upstream.subscribe(new CircuitBreakerMaybeObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(new CallNotPermittedException(circuitBreaker));
+            downstream.onError(getCallNotPermittedException(circuitBreaker));
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/ObserverCircuitBreaker.java
Patch:
@@ -24,6 +24,8 @@
 
 import java.util.concurrent.TimeUnit;
 
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+
 class ObserverCircuitBreaker<T> extends Observable<T> {
 
     private final Observable<T> upstream;
@@ -40,7 +42,7 @@ protected void subscribeActual(Observer<? super T> downstream) {
             upstream.subscribe(new CircuitBreakerObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(new CallNotPermittedException(circuitBreaker));
+            downstream.onError(getCallNotPermittedException(circuitBreaker));
         }
     }
     class CircuitBreakerObserver extends AbstractObserver<T> {

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/SingleCircuitBreaker.java
Patch:
@@ -24,6 +24,8 @@
 
 import java.util.concurrent.TimeUnit;
 
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+
 class SingleCircuitBreaker<T> extends Single<T> {
 
     private final CircuitBreaker circuitBreaker;
@@ -40,7 +42,7 @@ protected void subscribeActual(SingleObserver<? super T> downstream) {
             upstream.subscribe(new CircuitBreakerSingleObserver(downstream));
         }else{
             downstream.onSubscribe(EmptyDisposable.INSTANCE);
-            downstream.onError(new CallNotPermittedException(circuitBreaker));
+            downstream.onError(getCallNotPermittedException(circuitBreaker));
         }
     }
 

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/circuitbreaker/operator/BaseCircuitBreakerTest.java
Patch:
@@ -15,7 +15,7 @@ abstract class BaseCircuitBreakerTest {
 
     @Before
     public void setUp(){
-        circuitBreaker = Mockito.mock(CircuitBreaker.class);
+        circuitBreaker = Mockito.mock(CircuitBreaker.class, Mockito.RETURNS_DEEP_STUBS);
         helloWorldService = Mockito.mock(HelloWorldService.class);
     }
 }

File: resilience4j-vertx/src/main/java/io/github/resilience4j/circuitbreaker/VertxCircuitBreaker.java
Patch:
@@ -23,6 +23,8 @@
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
 
+import static io.github.resilience4j.circuitbreaker.CallNotPermittedException.getCallNotPermittedException;
+
 /**
  * CircuitBreaker decorators for Vert.x
  */
@@ -53,7 +55,7 @@ static <T> Supplier<Future<T>> decorateFuture(CircuitBreaker circuitBreaker, Sup
             final Future<T> future = Future.future();
 
             if (!circuitBreaker.tryAcquirePermission()) {
-                future.fail(new CallNotPermittedException(circuitBreaker));
+                future.fail(getCallNotPermittedException(circuitBreaker));
 
             } else {
                 long start = System.nanoTime();

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedThreadPoolBulkheadMetricsTest.java
Patch:
@@ -94,7 +94,7 @@ public void shouldReplaceMetrics() {
         assertThat(successful.get().value()).isEqualTo(bulkhead.getMetrics().getMaximumThreadPoolSize());
 
         ThreadPoolBulkhead newBulkhead = ThreadPoolBulkhead.of(bulkhead.getName(), ThreadPoolBulkheadConfig.custom()
-                .maxThreadPoolSize(10).build());
+                .maxThreadPoolSize(ThreadPoolBulkheadConfig.DEFAULT_MAX_THREAD_POOL_SIZE + 1).build());
 
         bulkheadRegistry.replace(bulkhead.getName(), newBulkhead);
 

File: resilience4j-feign/src/test/java/io/github/resilience4j/feign/Resilience4jRateLimiterTest.java
Patch:
@@ -40,7 +40,7 @@ public class Resilience4jRateLimiterTest {
 
     private static final RateLimiterConfig config = RateLimiterConfig.custom()
             .timeoutDuration(ofMillis(50))
-            .limitRefreshPeriod(ofSeconds(5))
+            .limitRefreshPeriod(ofSeconds(1))
             .limitForPeriod(1)
             .build();
 
@@ -77,9 +77,7 @@ public void testRateLimiterNotLimiting() throws Exception {
         setupStub(200);
 
         testService.greeting();
-        Thread.sleep(1_000);
         testService.greeting();
-        Thread.sleep(1_000);
         testService.greeting();
 
         verify(1, getRequestedFor(urlPathEqualTo("/greeting")));

File: resilience4j-metrics/src/test/java/io/github/resilience4j/metrics/StateTransitionMetricsTest.java
Patch:
@@ -23,7 +23,7 @@ public class StateTransitionMetricsTest {
     public void testWithCircuitBreakerMetrics() throws Exception {
         CircuitBreakerConfig config =
                 CircuitBreakerConfig.custom()
-                        .waitDurationInOpenState(Duration.ofSeconds(1))
+                        .waitDurationInOpenState(Duration.ofMillis(150))
                         .failureRateThreshold(50)
                         .permittedNumberOfCallsInHalfOpenState(3)
                         .slidingWindowSize(10)

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/AtomicRateLimiterTest.java
Patch:
@@ -42,7 +42,7 @@
 public class AtomicRateLimiterTest {
 
     private static final String LIMITER_NAME = "test";
-    private static final long CYCLE_IN_NANOS = 500_000_000L;
+    private static final long CYCLE_IN_NANOS = 50_000_000L;
     private static final long POLL_INTERVAL_IN_NANOS = 2_000_000L;
     private static final int PERMISSIONS_RER_CYCLE = 1;
     private AtomicRateLimiter rateLimiter;

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/SemaphoreBasedRateLimiterImplTest.java
Patch:
@@ -36,6 +36,7 @@
 import static com.jayway.awaitility.Awaitility.await;
 import static io.vavr.control.Try.run;
 import static java.lang.Thread.State.*;
+import static java.time.LocalDateTime.now;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.hamcrest.CoreMatchers.equalTo;
@@ -46,7 +47,7 @@
 public class SemaphoreBasedRateLimiterImplTest {
 
     private static final int LIMIT = 2;
-    private static final Duration TIMEOUT = Duration.ofSeconds(5);
+    private static final Duration TIMEOUT = Duration.ofMillis(50);
     private static final Duration REFRESH_PERIOD = Duration.ofMillis(100);
     private static final String CONFIG_MUST_NOT_BE_NULL = "Config must not be null";
     private static final String NAME_MUST_NOT_BE_NULL = "Name must not be null";
@@ -109,6 +110,7 @@ public void rateLimiterCreationWithProvidedScheduler() throws Exception {
         then(limit.acquirePermission()).isTrue();
         then(limit.acquirePermission()).isTrue();
         then(limit.acquirePermission()).isFalse();
+
     }
 
     @Test

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/ratelimiter/operator/MonoRateLimiterTest.java
Patch:
@@ -62,15 +62,15 @@ public void shouldPropagateError() {
 
     @Test
     public void shouldDelaySubscription() {
-        given(rateLimiter.reservePermission()).willReturn(Duration.ofSeconds(2).toNanos());
+        given(rateLimiter.reservePermission()).willReturn(Duration.ofMillis(50).toNanos());
 
         StepVerifier.create(
                 Mono.error(new IOException("BAM!"))
                         .log()
                         .compose(RateLimiterOperator.of(rateLimiter)))
                 .expectSubscription()
                 .expectError(IOException.class)
-                .verify(Duration.ofSeconds(3));
+                .verify(Duration.ofMillis(150));
     }
 
 

File: resilience4j-retrofit/src/test/java/io/github/resilience4j/retrofit/RetrofitCircuitBreakerTest.java
Patch:
@@ -54,7 +54,7 @@ public class RetrofitCircuitBreakerTest {
 
     private static final CircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.custom()
             .slidingWindowSize(3)
-            .waitDurationInOpenState(Duration.ofMillis(1000))
+            .waitDurationInOpenState(Duration.ofMillis(150))
             .build();
 
     private CircuitBreaker circuitBreaker;
@@ -65,7 +65,7 @@ public class RetrofitCircuitBreakerTest {
     public void setUp() {
         this.circuitBreaker = CircuitBreaker.of("test", circuitBreakerConfig);
 
-        final long TIMEOUT = 300; // ms
+        final long TIMEOUT = 150; // ms
         this.client = new OkHttpClient.Builder()
                 .connectTimeout(TIMEOUT, TimeUnit.MILLISECONDS)
                 .readTimeout(TIMEOUT, TimeUnit.MILLISECONDS)

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/CompletableRateLimiterTest.java
Patch:
@@ -42,7 +42,7 @@ public void shouldDelaySubscription() {
         Completable.complete()
                 .compose(RateLimiterOperator.of(rateLimiter))
                 .test()
-                .awaitTerminalEvent(2, TimeUnit.SECONDS);
+                .awaitTerminalEvent(1, TimeUnit.SECONDS);
     }
 
     @Test

File: resilience4j-prometheus/src/test/java/io/github/resilience4j/prometheus/collectors/BulkheadMetricsCollectorTest.java
Patch:
@@ -21,8 +21,8 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static io.github.resilience4j.prometheus.AbstractBulkheadMetrics.MetricNames.DEFAULT_BULKHEAD_AVAILABLE_CONCURRENT_CALLS_METRIC_NAME;
-import static io.github.resilience4j.prometheus.AbstractBulkheadMetrics.MetricNames.DEFAULT_BULKHEAD_MAX_ALLOWED_CONCURRENT_CALLS_METRIC_NAME;
+import static io.github.resilience4j.prometheus.collectors.BulkheadMetricsCollector.MetricNames.DEFAULT_BULKHEAD_AVAILABLE_CONCURRENT_CALLS_METRIC_NAME;
+import static io.github.resilience4j.prometheus.collectors.BulkheadMetricsCollector.MetricNames.DEFAULT_BULKHEAD_MAX_ALLOWED_CONCURRENT_CALLS_METRIC_NAME;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class BulkheadMetricsCollectorTest {

File: resilience4j-prometheus/src/test/java/io/github/resilience4j/prometheus/collectors/RateLimiterMetricsCollectorTest.java
Patch:
@@ -21,8 +21,8 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static io.github.resilience4j.prometheus.AbstractRateLimiterMetrics.MetricNames.DEFAULT_AVAILABLE_PERMISSIONS_METRIC_NAME;
-import static io.github.resilience4j.prometheus.AbstractRateLimiterMetrics.MetricNames.DEFAULT_WAITING_THREADS_METRIC_NAME;
+import static io.github.resilience4j.prometheus.collectors.RateLimiterMetricsCollector.MetricNames.DEFAULT_AVAILABLE_PERMISSIONS_METRIC_NAME;
+import static io.github.resilience4j.prometheus.collectors.RateLimiterMetricsCollector.MetricNames.DEFAULT_WAITING_THREADS_METRIC_NAME;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class RateLimiterMetricsCollectorTest {

File: resilience4j-prometheus/src/test/java/io/github/resilience4j/prometheus/collectors/RetryMetricsCollectorTest.java
Patch:
@@ -25,7 +25,7 @@
 
 import java.util.function.Supplier;
 
-import static io.github.resilience4j.prometheus.AbstractRetryMetrics.MetricNames.DEFAULT_RETRY_CALLS;
+import static io.github.resilience4j.prometheus.collectors.RetryMetricsCollector.MetricNames.DEFAULT_RETRY_CALLS;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class RetryMetricsCollectorTest {

File: resilience4j-spring-cloud/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/RefreshScopedCircuitBreakerAutoConfiguration.java
Patch:
@@ -16,9 +16,8 @@
 @AutoConfigureBefore(CircuitBreakerAutoConfiguration.class)
 public class RefreshScopedCircuitBreakerAutoConfiguration extends AbstractRefreshScopedCircuitBreakerConfiguration {
 
-    public RefreshScopedCircuitBreakerAutoConfiguration(ConfigurableBeanFactory beanFactory,
-                                                        CircuitBreakerConfigurationProperties circuitBreakerProperties) {
-        super(beanFactory, circuitBreakerProperties);
+    public RefreshScopedCircuitBreakerAutoConfiguration(CircuitBreakerConfigurationProperties circuitBreakerProperties) {
+        super(circuitBreakerProperties);
     }
 
 }

File: resilience4j-spring-boot-common/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/health/CircuitBreakersHealthIndicator.java
Patch:
@@ -65,8 +65,8 @@ public Health health() {
 
     private boolean isRegisterHealthIndicator(CircuitBreaker circuitBreaker) {
         return circuitBreakerProperties.findCircuitBreakerProperties(circuitBreaker.getName())
-                .map(io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigurationProperties.InstanceProperties::getRegisterHealthIndicator)
-                .orElse(true);
+                .map(CircuitBreakerConfigurationProperties.InstanceProperties::getRegisterHealthIndicator)
+                .orElse(false);
     }
 
     private static Health mapBackendMonitorState(CircuitBreaker circuitBreaker) {

File: resilience4j-spring-boot-common/src/main/java/io/github/resilience4j/ratelimiter/monitoring/health/RateLimitersHealthIndicator.java
Patch:
@@ -52,8 +52,8 @@ public Health health() {
 
     private boolean isRegisterHealthIndicator(RateLimiter rateLimiter) {
         return rateLimiterProperties.findRateLimiterProperties(rateLimiter.getName())
-                .map(io.github.resilience4j.common.ratelimiter.configuration.RateLimiterConfigurationProperties.InstanceProperties::getRegisterHealthIndicator)
-                .orElse(true);
+                .map(RateLimiterConfigurationProperties.InstanceProperties::getRegisterHealthIndicator)
+                .orElse(false);
     }
 
     private Health mapRateLimiterHealth(RateLimiter rateLimiter) {

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedBulkheadMetricsTest.java
Patch:
@@ -28,9 +28,9 @@
 import java.util.*;
 import java.util.stream.Collectors;
 
+import static io.github.resilience4j.micrometer.tagged.AbstractBulkheadMetrics.MetricNames.DEFAULT_BULKHEAD_AVAILABLE_CONCURRENT_CALLS_METRIC_NAME;
+import static io.github.resilience4j.micrometer.tagged.AbstractBulkheadMetrics.MetricNames.DEFAULT_BULKHEAD_MAX_ALLOWED_CONCURRENT_CALLS_METRIC_NAME;
 import static io.github.resilience4j.micrometer.tagged.MetricsTestHelper.findGaugeByNamesTag;
-import static io.github.resilience4j.micrometer.tagged.TaggedBulkheadMetrics.MetricNames.DEFAULT_BULKHEAD_AVAILABLE_CONCURRENT_CALLS_METRIC_NAME;
-import static io.github.resilience4j.micrometer.tagged.TaggedBulkheadMetrics.MetricNames.DEFAULT_BULKHEAD_MAX_ALLOWED_CONCURRENT_CALLS_METRIC_NAME;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class TaggedBulkheadMetricsTest {

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedCircuitBreakerMetricsTest.java
Patch:
@@ -29,9 +29,9 @@
 import java.util.concurrent.TimeUnit;
 import java.util.stream.Collectors;
 
+import static io.github.resilience4j.micrometer.tagged.AbstractCircuitBreakerMetrics.MetricNames.*;
 import static io.github.resilience4j.micrometer.tagged.MetricsTestHelper.findCounterByKindAndNameTags;
 import static io.github.resilience4j.micrometer.tagged.MetricsTestHelper.findGaugeByKindAndNameTags;
-import static io.github.resilience4j.micrometer.tagged.TaggedCircuitBreakerMetrics.MetricNames.*;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class TaggedCircuitBreakerMetricsTest {

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedRateLimiterMetricsTest.java
Patch:
@@ -28,9 +28,9 @@
 import java.util.*;
 import java.util.stream.Collectors;
 
+import static io.github.resilience4j.micrometer.tagged.AbstractRateLimiterMetrics.MetricNames.DEFAULT_AVAILABLE_PERMISSIONS_METRIC_NAME;
+import static io.github.resilience4j.micrometer.tagged.AbstractRateLimiterMetrics.MetricNames.DEFAULT_WAITING_THREADS_METRIC_NAME;
 import static io.github.resilience4j.micrometer.tagged.MetricsTestHelper.findGaugeByNamesTag;
-import static io.github.resilience4j.micrometer.tagged.TaggedRateLimiterMetrics.MetricNames.DEFAULT_AVAILABLE_PERMISSIONS_METRIC_NAME;
-import static io.github.resilience4j.micrometer.tagged.TaggedRateLimiterMetrics.MetricNames.DEFAULT_WAITING_THREADS_METRIC_NAME;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class TaggedRateLimiterMetricsTest {

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedRetryMetricsTest.java
Patch:
@@ -28,8 +28,8 @@
 import java.util.*;
 import java.util.stream.Collectors;
 
+import static io.github.resilience4j.micrometer.tagged.AbstractRetryMetrics.MetricNames.DEFAULT_RETRY_CALLS;
 import static io.github.resilience4j.micrometer.tagged.MetricsTestHelper.findGaugeByKindAndNameTags;
-import static io.github.resilience4j.micrometer.tagged.TaggedRetryMetrics.MetricNames.DEFAULT_RETRY_CALLS;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class TaggedRetryMetricsTest {

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedThreadPoolBulkheadMetricsTest.java
Patch:
@@ -28,8 +28,8 @@
 import java.util.*;
 import java.util.stream.Collectors;
 
+import static io.github.resilience4j.micrometer.tagged.AbstractThreadPoolBulkheadMetrics.MetricNames.*;
 import static io.github.resilience4j.micrometer.tagged.MetricsTestHelper.findGaugeByNamesTag;
-import static io.github.resilience4j.micrometer.tagged.TaggedThreadPoolBulkheadMetrics.MetricNames.*;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class TaggedThreadPoolBulkheadMetricsTest {

File: resilience4j-prometheus/src/main/java/io/github/resilience4j/prometheus/LabelNames.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.prometheus.collectors;
+package io.github.resilience4j.prometheus;
 
 import java.util.Arrays;
 import java.util.Collections;
@@ -27,5 +27,4 @@ private LabelNames() {}
     public static final List<String> NAME = Collections.singletonList("name");
     public static final List<String> NAME_AND_KIND = Arrays.asList("name", "kind");
 
-
 }

File: resilience4j-prometheus/src/test/java/io/github/resilience4j/prometheus/collectors/BulkheadMetricsCollectorTest.java
Patch:
@@ -21,8 +21,8 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static io.github.resilience4j.prometheus.collectors.BulkheadMetricsCollector.MetricNames.DEFAULT_BULKHEAD_AVAILABLE_CONCURRENT_CALLS_METRIC_NAME;
-import static io.github.resilience4j.prometheus.collectors.BulkheadMetricsCollector.MetricNames.DEFAULT_BULKHEAD_MAX_ALLOWED_CONCURRENT_CALLS_METRIC_NAME;
+import static io.github.resilience4j.prometheus.AbstractBulkheadMetrics.MetricNames.DEFAULT_BULKHEAD_AVAILABLE_CONCURRENT_CALLS_METRIC_NAME;
+import static io.github.resilience4j.prometheus.AbstractBulkheadMetrics.MetricNames.DEFAULT_BULKHEAD_MAX_ALLOWED_CONCURRENT_CALLS_METRIC_NAME;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class BulkheadMetricsCollectorTest {

File: resilience4j-prometheus/src/test/java/io/github/resilience4j/prometheus/collectors/CircuitBreakerMetricsCollectorTest.java
Patch:
@@ -23,7 +23,7 @@
 
 import java.util.concurrent.TimeUnit;
 
-import static io.github.resilience4j.prometheus.collectors.CircuitBreakerMetricsCollector.MetricNames.*;
+import static io.github.resilience4j.prometheus.AbstractCircuitBreakerMetrics.MetricNames.*;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class CircuitBreakerMetricsCollectorTest {

File: resilience4j-prometheus/src/test/java/io/github/resilience4j/prometheus/collectors/RateLimiterMetricsCollectorTest.java
Patch:
@@ -21,8 +21,8 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static io.github.resilience4j.prometheus.collectors.RateLimiterMetricsCollector.MetricNames.DEFAULT_AVAILABLE_PERMISSIONS_METRIC_NAME;
-import static io.github.resilience4j.prometheus.collectors.RateLimiterMetricsCollector.MetricNames.DEFAULT_WAITING_THREADS_METRIC_NAME;
+import static io.github.resilience4j.prometheus.AbstractRateLimiterMetrics.MetricNames.DEFAULT_AVAILABLE_PERMISSIONS_METRIC_NAME;
+import static io.github.resilience4j.prometheus.AbstractRateLimiterMetrics.MetricNames.DEFAULT_WAITING_THREADS_METRIC_NAME;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class RateLimiterMetricsCollectorTest {

File: resilience4j-prometheus/src/test/java/io/github/resilience4j/prometheus/collectors/RetryMetricsCollectorTest.java
Patch:
@@ -25,7 +25,7 @@
 
 import java.util.function.Supplier;
 
-import static io.github.resilience4j.prometheus.collectors.RetryMetricsCollector.MetricNames.DEFAULT_RETRY_CALLS;
+import static io.github.resilience4j.prometheus.AbstractRetryMetrics.MetricNames.DEFAULT_RETRY_CALLS;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class RetryMetricsCollectorTest {

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/bulkhead/autoconfigure/BulkheadConfigurationOnMissingBeanTest.java
Patch:
@@ -75,8 +75,9 @@ public void testAllBeansFromBulkHeadHasOnMissingBean() throws NoSuchMethodExcept
 
 				assertThat(methodOnMissing.isAnnotationPresent(Bean.class)).isTrue();
 
-				if (!methodOnMissing.getName().equals("bulkheadEventConsumerRegistry")) {
-					assertThat(methodOnMissing.isAnnotationPresent(ConditionalOnMissingBean.class)).isTrue();
+				if (!"bulkheadEventConsumerRegistry".equals(methodOnMissing.getName()) &&
+					!"bulkheadRegistryEventConsumer".equals(methodOnMissing.getName())) {
+						assertThat(methodOnMissing.isAnnotationPresent(ConditionalOnMissingBean.class)).isTrue();
 				}
 			}
 		}

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerConfigurationOnMissingBeanTest.java
Patch:
@@ -75,7 +75,8 @@ public void testAllBeansFromCircuitBreakerConfigurationHasOnMissingBean() throws
 
                 assertThat(methodOnMissing.isAnnotationPresent(Bean.class)).isTrue();
 
-                if (!methodOnMissing.getName().equals("eventConsumerRegistry")) {
+                if (!"eventConsumerRegistry".equals(methodOnMissing.getName()) &&
+                        !"circuitBreakerRegistryEventConsumer".equals(methodOnMissing.getName())) {
                     assertThat(methodOnMissing.isAnnotationPresent(ConditionalOnMissingBean.class)).isTrue();
                 }
             }

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterConfigurationOnMissingBeanTest.java
Patch:
@@ -78,7 +78,8 @@ public void testAllBeansFromCircuitBreakerConfigurationHasOnMissingBean() throws
 
                 assertThat(methodOnMissing.isAnnotationPresent(Bean.class)).isTrue();
 
-                if (!methodOnMissing.getName().equals("rateLimiterEventsConsumerRegistry")) {
+                if (!"rateLimiterEventsConsumerRegistry".equals(methodOnMissing.getName()) &&
+                        !"rateLimiterRegistryEventConsumer".equals(methodOnMissing.getName())) {
                     assertThat(methodOnMissing.isAnnotationPresent(ConditionalOnMissingBean.class)).isTrue();
                 }
             }

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/retry/autoconfigure/RetryConfigurationOnMissingBeanTest.java
Patch:
@@ -74,7 +74,8 @@ public void testAllBeansFromRetryHasOnMissingBean() throws NoSuchMethodException
 
 				assertThat(methodOnMissing.isAnnotationPresent(Bean.class)).isTrue();
 
-				if (!methodOnMissing.getName().equals("retryEventConsumerRegistry")) {
+				if (!"retryEventConsumerRegistry".equals(methodOnMissing.getName()) &&
+						!"retryRegistryEventConsumer".equals(methodOnMissing.getName())) {
 					assertThat(methodOnMissing.isAnnotationPresent(ConditionalOnMissingBean.class)).isTrue();
 				}
 			}

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/bulkhead/autoconfigure/BulkheadConfigurationOnMissingBeanTest.java
Patch:
@@ -64,7 +64,7 @@ public class BulkheadConfigurationOnMissingBeanTest {
 	public void testAllBeansFromBulkHeadHasOnMissingBean() throws NoSuchMethodException {
 		final Class<BulkheadConfiguration> originalClass = BulkheadConfiguration.class;
 		final Class<BulkheadConfigurationOnMissingBean> onMissingBeanClass = BulkheadConfigurationOnMissingBean.class;
-		TestUtils.assertAnnaations(originalClass, onMissingBeanClass);
+		TestUtils.assertAnnotations(originalClass, onMissingBeanClass);
 	}
 
 	@Test

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerConfigurationOnMissingBeanTest.java
Patch:
@@ -50,7 +50,7 @@ public class CircuitBreakerConfigurationOnMissingBeanTest {
     public void testAllBeansFromCircuitBreakerConfigurationHasOnMissingBean() throws NoSuchMethodException {
         final Class<CircuitBreakerConfiguration> originalClass = CircuitBreakerConfiguration.class;
         final Class<CircuitBreakerConfigurationOnMissingBean> onMissingBeanClass = CircuitBreakerConfigurationOnMissingBean.class;
-        TestUtils.assertAnnaations(originalClass, onMissingBeanClass);
+        TestUtils.assertAnnotations(originalClass, onMissingBeanClass);
     }
 
     @Test

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterConfigurationOnMissingBeanTest.java
Patch:
@@ -52,7 +52,7 @@ public class RateLimiterConfigurationOnMissingBeanTest {
 	public void testAllBeansFromCircuitBreakerConfigurationHasOnMissingBean() throws NoSuchMethodException {
 		final Class<RateLimiterConfiguration> originalClass = RateLimiterConfiguration.class;
 		final Class<RateLimiterConfigurationOnMissingBean> onMissingBeanClass = RateLimiterConfigurationOnMissingBean.class;
-		TestUtils.assertAnnaations(originalClass, onMissingBeanClass);
+		TestUtils.assertAnnotations(originalClass, onMissingBeanClass);
 	}
 
 	@Test

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/retry/autoconfigure/RetryConfigurationOnMissingBeanTest.java
Patch:
@@ -63,7 +63,7 @@ public class RetryConfigurationOnMissingBeanTest {
 	public void testAllBeansFromRetryHasOnMissingBean() throws NoSuchMethodException {
 		final Class<RetryConfiguration> originalClass = RetryConfiguration.class;
 		final Class<RetryConfigurationOnMissingBean> onMissingBeanClass = RetryConfigurationOnMissingBean.class;
-		TestUtils.assertAnnaations(originalClass, onMissingBeanClass);
+		TestUtils.assertAnnotations(originalClass, onMissingBeanClass);
 	}
 
 	@Test

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreakerConfig.java
Patch:
@@ -265,6 +265,7 @@ public Builder permittedNumberOfCallsInHalfOpenState(int permittedNumberOfCallsI
         /**
          * @deprecated Use {@link #permittedNumberOfCallsInHalfOpenState(int)} instead.
          */
+        @Deprecated
         public Builder ringBufferSizeInHalfOpenState(int ringBufferSizeInHalfOpenState) {
             if (ringBufferSizeInHalfOpenState < 1) {
                 throw new IllegalArgumentException("ringBufferSizeInHalfOpenState must be greater than 0");
@@ -276,6 +277,7 @@ public Builder ringBufferSizeInHalfOpenState(int ringBufferSizeInHalfOpenState)
         /**
          * @deprecated Use {@link #slidingWindow(int, int, SlidingWindowType)} instead.
          */
+        @Deprecated
         public Builder ringBufferSizeInClosedState(int ringBufferSizeInClosedState) {
             if (ringBufferSizeInClosedState < 1) {
                 throw new IllegalArgumentException("ringBufferSizeInClosedState must be greater than 0");

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerConfigTest.java
Patch:
@@ -45,6 +45,7 @@ public void zeroSlowCallDurationThresholdShouldFail() {
     }
 
     @Test(expected = IllegalArgumentException.class)
+    @SuppressWarnings("deprecation") // Left this use for testing purposes
     public void ringBufferSizeInHalfOpenStateBelowOneShouldFail() {
         custom().ringBufferSizeInHalfOpenState(0).build();
     }
@@ -75,6 +76,7 @@ public void zeroMinimumNumberOfCallsShouldFai2l() {
     }
 
     @Test(expected = IllegalArgumentException.class)
+    @SuppressWarnings("deprecation") // Left this use for testing purposes
     public void zeroRingBufferSizeInClosedStateShouldFail() {
         custom().ringBufferSizeInClosedState(0).build();
     }
@@ -138,6 +140,7 @@ public void shouldSetLowFailureRateThreshold() {
     }
 
     @Test
+    @SuppressWarnings("deprecation") // Left this use for testing purposes
     public void shouldSetRingBufferSizeInClosedState() {
         CircuitBreakerConfig circuitBreakerConfig = custom().ringBufferSizeInClosedState(1000).build();
         then(circuitBreakerConfig.getSlidingWindowSize()).isEqualTo(1000);

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreakerConfig.java
Patch:
@@ -265,6 +265,7 @@ public Builder permittedNumberOfCallsInHalfOpenState(int permittedNumberOfCallsI
         /**
          * @deprecated Use {@link #permittedNumberOfCallsInHalfOpenState(int)} instead.
          */
+        @Deprecated
         public Builder ringBufferSizeInHalfOpenState(int ringBufferSizeInHalfOpenState) {
             if (ringBufferSizeInHalfOpenState < 1) {
                 throw new IllegalArgumentException("ringBufferSizeInHalfOpenState must be greater than 0");
@@ -276,6 +277,7 @@ public Builder ringBufferSizeInHalfOpenState(int ringBufferSizeInHalfOpenState)
         /**
          * @deprecated Use {@link #slidingWindow(int, int, SlidingWindowType)} instead.
          */
+        @Deprecated
         public Builder ringBufferSizeInClosedState(int ringBufferSizeInClosedState) {
             if (ringBufferSizeInClosedState < 1) {
                 throw new IllegalArgumentException("ringBufferSizeInClosedState must be greater than 0");

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerConfigTest.java
Patch:
@@ -45,6 +45,7 @@ public void zeroSlowCallDurationThresholdShouldFail() {
     }
 
     @Test(expected = IllegalArgumentException.class)
+    @SuppressWarnings("deprecation") // Left this use for testing purposes
     public void ringBufferSizeInHalfOpenStateBelowOneShouldFail() {
         custom().ringBufferSizeInHalfOpenState(0).build();
     }
@@ -75,6 +76,7 @@ public void zeroMinimumNumberOfCallsShouldFai2l() {
     }
 
     @Test(expected = IllegalArgumentException.class)
+    @SuppressWarnings("deprecation") // Left this use for testing purposes
     public void zeroRingBufferSizeInClosedStateShouldFail() {
         custom().ringBufferSizeInClosedState(0).build();
     }
@@ -138,6 +140,7 @@ public void shouldSetLowFailureRateThreshold() {
     }
 
     @Test
+    @SuppressWarnings("deprecation") // Left this use for testing purposes
     public void shouldSetRingBufferSizeInClosedState() {
         CircuitBreakerConfig circuitBreakerConfig = custom().ringBufferSizeInClosedState(1000).build();
         then(circuitBreakerConfig.getSlidingWindowSize()).isEqualTo(1000);

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterMetricsAutoConfiguration.java
Patch:
@@ -15,7 +15,6 @@
  */
 package io.github.resilience4j.ratelimiter.autoconfigure;
 
-import io.github.resilience4j.circuitbreaker.autoconfigure.CircuitBreakerAutoConfiguration;
 import io.github.resilience4j.micrometer.tagged.TaggedRateLimiterMetrics;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
 import org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration;
@@ -32,7 +31,7 @@
  */
 @Configuration
 @ConditionalOnClass(MetricsAutoConfiguration.class)
-@AutoConfigureAfter(value = {CircuitBreakerAutoConfiguration.class, MetricsAutoConfiguration.class})
+@AutoConfigureAfter(value = {RateLimiterAutoConfiguration.class, MetricsAutoConfiguration.class})
 @ConditionalOnProperty(value = "resilience4j.ratelimiter.metrics.enabled", matchIfMissing = true)
 public class RateLimiterMetricsAutoConfiguration {
 

File: resilience4j-spring/src/main/java/io/github/resilience4j/circuitbreaker/configure/CircuitBreakerConfigurationProperties.java
Patch:
@@ -19,7 +19,6 @@
 import org.springframework.context.annotation.Configuration;
 import org.springframework.core.Ordered;
 
-@Configuration
 public class CircuitBreakerConfigurationProperties extends io.github.resilience4j.common.circuitbreaker.configuration.CircuitBreakerConfigurationProperties {
 	private int circuitBreakerAspectOrder = Ordered.LOWEST_PRECEDENCE - 2;
 	/**

File: resilience4j-micrometer/src/main/java/io/github/resilience4j/micrometer/tagged/TaggedRateLimiterMetrics.java
Patch:
@@ -35,17 +35,17 @@
 public class TaggedRateLimiterMetrics extends AbstractMetrics implements MeterBinder {
 
     /**
-     * Creates a new binder that uses given {@code registry} as source of retries.
+     * Creates a new binder that uses given {@code registry} as source of rate limiters.
      *
-     * @param rateLimiterRegistry the source of retries
+     * @param rateLimiterRegistry the source of rate limiters
      * @return The {@link TaggedRateLimiterMetrics} instance.
      */
     public static TaggedRateLimiterMetrics ofRateLimiterRegistry(RateLimiterRegistry rateLimiterRegistry) {
         return new TaggedRateLimiterMetrics(MetricNames.ofDefaults(), rateLimiterRegistry);
     }
 
     /**
-     * Creates a new binder that uses given {@code registry} as source of retries.
+     * Creates a new binder that uses given {@code registry} as source of rate limiters.
      *
      * @param names custom metric names
      * @param rateLimiterRegistry the source of rate limiters

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerMetrics.java
Patch:
@@ -41,7 +41,7 @@ class CircuitBreakerMetrics implements CircuitBreaker.Metrics {
     private final LongAdder numberOfNotPermittedCalls;
 
     private CircuitBreakerMetrics(int slidingWindowSize, CircuitBreakerConfig.SlidingWindowType slidingWindowType, CircuitBreakerConfig circuitBreakerConfig) {
-        if(circuitBreakerConfig.getSlidingWindowType() == slidingWindowType){
+        if(slidingWindowType == CircuitBreakerConfig.SlidingWindowType.COUNT_BASED){
             this.metrics = new FixedSizeSlidingWindowMetrics(slidingWindowSize);
             this.minimumNumberOfCalls = Math.min(circuitBreakerConfig.getMinimumNumberOfCalls(), slidingWindowSize);
         }else{
@@ -67,11 +67,11 @@ static CircuitBreakerMetrics forHalfOpen(int permittedNumberOfCallsInHalfOpenSta
     }
 
     static CircuitBreakerMetrics forForcedOpen(CircuitBreakerConfig circuitBreakerConfig) {
-        return new CircuitBreakerMetrics(0, circuitBreakerConfig);
+        return new CircuitBreakerMetrics(0, CircuitBreakerConfig.SlidingWindowType.COUNT_BASED, circuitBreakerConfig);
     }
 
     static CircuitBreakerMetrics forDisabled(CircuitBreakerConfig circuitBreakerConfig) {
-        return new CircuitBreakerMetrics(0, circuitBreakerConfig);
+        return new CircuitBreakerMetrics(0, CircuitBreakerConfig.SlidingWindowType.COUNT_BASED, circuitBreakerConfig);
     }
 
     /**

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerStateMachineTest.java
Patch:
@@ -47,7 +47,7 @@ public void setUp() {
                 .permittedNumberOfCallsInHalfOpenState(4)
                 .slowCallDurationThreshold(Duration.ofSeconds(4))
                 .slowCallRateThreshold(50)
-                .slidingWindow(5, 5, SlidingWindowType.COUNT_BASED)
+                .slidingWindow(5, 5, SlidingWindowType.TIME_BASED)
                 .waitDurationInOpenState(Duration.ofSeconds(5))
                 .ignoreExceptions(NumberFormatException.class)
                 .build(), mockClock);

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerAutoTransitionStateMachineTest.java
Patch:
@@ -41,7 +41,7 @@ public class CircuitBreakerAutoTransitionStateMachineTest {
     public void setUp() {
         CircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.custom()
                 .failureRateThreshold(50)
-                .slidingWindow(5, 5, CircuitBreakerConfig.SlidingWindow.COUNT_BASED)
+                .slidingWindow(5, 5, CircuitBreakerConfig.SlidingWindowType.COUNT_BASED)
                 .permittedNumberOfCallsInHalfOpenState(3)
                 .automaticTransitionFromOpenToHalfOpenEnabled(true)
                 .waitDurationInOpenState(Duration.ofSeconds(2))

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerMetricsTest.java
Patch:
@@ -31,11 +31,10 @@ public class CircuitBreakerMetricsTest {
     @Test
     public void testCircuitBreakerMetrics(){
         CircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.custom()
-                .slidingWindow(10, 10, CircuitBreakerConfig.SlidingWindow.COUNT_BASED)
+                .slidingWindow(10, 10, CircuitBreakerConfig.SlidingWindowType.COUNT_BASED)
                 .build();
 
-        CircuitBreakerMetrics circuitBreakerMetrics = new CircuitBreakerMetrics(circuitBreakerConfig.getSlidingWindowSize(),
-                circuitBreakerConfig);
+        CircuitBreakerMetrics circuitBreakerMetrics = CircuitBreakerMetrics.forCosed(circuitBreakerConfig);
 
         circuitBreakerMetrics.onSuccess(0, TimeUnit.NANOSECONDS);
         circuitBreakerMetrics.onSuccess(0, TimeUnit.NANOSECONDS);

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerStateMachineTest.java
Patch:
@@ -29,7 +29,7 @@
 import java.time.ZoneId;
 import java.util.concurrent.TimeUnit;
 
-import static io.github.resilience4j.circuitbreaker.CircuitBreakerConfig.SlidingWindow;
+import static io.github.resilience4j.circuitbreaker.CircuitBreakerConfig.SlidingWindowType;
 import static io.github.resilience4j.circuitbreaker.CircuitBreakerConfig.custom;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.assertj.core.api.BDDAssertions.assertThat;
@@ -47,7 +47,7 @@ public void setUp() {
                 .permittedNumberOfCallsInHalfOpenState(4)
                 .slowCallDurationThreshold(Duration.ofSeconds(4))
                 .slowCallRateThreshold(50)
-                .slidingWindow(5, 5, SlidingWindow.COUNT_BASED)
+                .slidingWindow(5, 5, SlidingWindowType.COUNT_BASED)
                 .waitDurationInOpenState(Duration.ofSeconds(5))
                 .ignoreExceptions(NumberFormatException.class)
                 .build(), mockClock);

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/circuitbreaker/configuration/CircuitBreakerConfigurationProperties.java
Patch:
@@ -182,7 +182,7 @@ public static class InstanceProperties {
 		private Integer ringBufferSizeInClosedState;
 
 		@Nullable
-		private SlidingWindow slidingWindowType;
+		private SlidingWindowType slidingWindowType;
 
 		@Min(1)
 		@Nullable
@@ -441,11 +441,11 @@ public void setSlowCallDurationThreshold(@Nullable Duration slowCallDurationThre
 		}
 
 		@Nullable
-		public SlidingWindow getSlidingWindowType() {
+		public SlidingWindowType getSlidingWindowType() {
 			return slidingWindowType;
 		}
 
-		public void setSlidingWindowType(SlidingWindow slidingWindowType) {
+		public void setSlidingWindowType(SlidingWindowType slidingWindowType) {
 			this.slidingWindowType = slidingWindowType;
 		}
 	}

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationTest.java
Patch:
@@ -30,7 +30,6 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;
-import org.springframework.boot.actuate.health.Health;
 import org.springframework.boot.test.context.SpringBootTest;
 import org.springframework.boot.test.web.client.TestRestTemplate;
 import org.springframework.http.ResponseEntity;
@@ -183,15 +182,15 @@ public void testCircuitBreakerAutoConfiguration() throws IOException {
 		int defaultPermittedNumberOfCallsInHalfOpenState = 10;
 		int defaultRingBufferSizeInClosedState = 100;
 
-		assertThat(backendB.getCircuitBreakerConfig().getSlidingWindowType()).isEqualTo(CircuitBreakerConfig.SlidingWindow.TIME_BASED);
+		assertThat(backendB.getCircuitBreakerConfig().getSlidingWindowType()).isEqualTo(CircuitBreakerConfig.SlidingWindowType.TIME_BASED);
 
 		assertThat(sharedA.getCircuitBreakerConfig().getSlidingWindowSize()).isEqualTo(6);
 		assertThat(sharedA.getCircuitBreakerConfig().getPermittedNumberOfCallsInHalfOpenState()).isEqualTo(defaultPermittedNumberOfCallsInHalfOpenState);
 		assertThat(sharedA.getCircuitBreakerConfig().getFailureRateThreshold()).isEqualTo(defaultFailureRate);
 		assertThat(sharedA.getCircuitBreakerConfig().getWaitDurationInOpenState()).isEqualTo(defaultWaitDuration);
 
 		assertThat(sharedB.getCircuitBreakerConfig().getSlidingWindowSize()).isEqualTo(defaultRingBufferSizeInClosedState);
-		assertThat(sharedB.getCircuitBreakerConfig().getSlidingWindowType()).isEqualTo(CircuitBreakerConfig.SlidingWindow.TIME_BASED);
+		assertThat(sharedB.getCircuitBreakerConfig().getSlidingWindowType()).isEqualTo(CircuitBreakerConfig.SlidingWindowType.TIME_BASED);
 		assertThat(sharedB.getCircuitBreakerConfig().getPermittedNumberOfCallsInHalfOpenState()).isEqualTo(defaultPermittedNumberOfCallsInHalfOpenState);
 		assertThat(sharedB.getCircuitBreakerConfig().getFailureRateThreshold()).isEqualTo(defaultFailureRate);
 		assertThat(sharedB.getCircuitBreakerConfig().getWaitDurationInOpenState()).isEqualTo(defaultWaitDuration);

File: resilience4j-micrometer/src/main/java/io/github/resilience4j/micrometer/tagged/TaggedBulkheadMetrics.java
Patch:
@@ -29,7 +29,7 @@
 import static java.util.Objects.requireNonNull;
 
 /**
- * A micrometer binder that is used to register bulkhead exposed {@link Metrics metrics}.
+ * A micrometer binder that is used to register Bulkhead exposed {@link Metrics metrics}.
  */
 public class TaggedBulkheadMetrics extends AbstractMetrics implements MeterBinder {
 

File: resilience4j-micrometer/src/main/java/io/github/resilience4j/micrometer/tagged/TaggedCircuitBreakerMetrics.java
Patch:
@@ -27,7 +27,7 @@
 import static java.util.Objects.requireNonNull;
 
 /**
- * A micrometer binder that is used to register circuit breaker exposed {@link Metrics metrics}.
+ * A micrometer binder that is used to register CircuitBreaker exposed {@link Metrics metrics}.
  */
 public class TaggedCircuitBreakerMetrics extends AbstractMetrics implements MeterBinder {
 

File: resilience4j-micrometer/src/main/java/io/github/resilience4j/micrometer/tagged/TaggedRateLimiterMetrics.java
Patch:
@@ -30,7 +30,7 @@
 import static java.util.Objects.requireNonNull;
 
 /**
- * A micrometer binder that is used to register retry exposed {@link Metrics metrics}.
+ * A micrometer binder that is used to register RateLimiter exposed {@link Metrics metrics}.
  */
 public class TaggedRateLimiterMetrics extends AbstractMetrics implements MeterBinder {
 

File: resilience4j-micrometer/src/main/java/io/github/resilience4j/micrometer/tagged/TaggedRetryMetrics.java
Patch:
@@ -29,7 +29,7 @@
 import static java.util.Objects.requireNonNull;
 
 /**
- * A micrometer binder that is used to register retry exposed {@link Metrics metrics}.
+ * A micrometer binder that is used to register Retry exposed {@link Metrics metrics}.
  */
 public class TaggedRetryMetrics extends AbstractMetrics implements MeterBinder {
 

File: resilience4j-micrometer/src/main/java/io/github/resilience4j/micrometer/tagged/TaggedThreadPoolBulkheadMetrics.java
Patch:
@@ -29,7 +29,7 @@
 import static java.util.Objects.requireNonNull;
 
 /**
- * A micrometer binder that is used to register bulkhead exposed {@link Metrics metrics}.
+ * A micrometer binder that is used to register ThreadPoolBulkheadM exposed {@link Metrics metrics}.
  */
 public class TaggedThreadPoolBulkheadMetrics extends AbstractMetrics implements MeterBinder {
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/AbstractSubscriber.java
Patch:
@@ -20,6 +20,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
 import static io.reactivex.internal.subscriptions.SubscriptionHelper.CANCELLED;
@@ -29,6 +30,7 @@ public abstract class AbstractSubscriber<T> implements Subscriber<T>, Subscripti
 
     protected final Subscriber<? super T> downstreamSubscriber;
     private final AtomicReference<Subscription> subscription = new AtomicReference<>();
+    protected final AtomicBoolean eventWasEmitted = new AtomicBoolean(false);
 
     protected AbstractSubscriber(Subscriber<? super T> downstreamSubscriber) {
         this.downstreamSubscriber = requireNonNull(downstreamSubscriber);
@@ -44,6 +46,7 @@ public void onSubscribe(Subscription s) {
     @Override
     public void onNext(T value) {
         if(!isDisposed()){
+            eventWasEmitted.set(true);
             downstreamSubscriber.onNext(value);
         }
 

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationRxJava2Test.java
Patch:
@@ -87,7 +87,7 @@ public void testCircuitBreakerAutoConfigurationReactiveRxJava2() throws IOExcept
 
 		// expect circuitbreakers actuator endpoint contains both circuitbreakers
 		ResponseEntity<CircuitBreakerEndpointResponse> circuitBreakerList = restTemplate.getForEntity("/actuator/circuitbreakers", CircuitBreakerEndpointResponse.class);
-		assertThat(circuitBreakerList.getBody().getCircuitBreakers()).hasSize(4).containsExactly("backendA", "backendB", "backendSharedA", "backendSharedB");
+		assertThat(circuitBreakerList.getBody().getCircuitBreakers()).hasSize(5).containsExactly("backendA", "backendB", "backendSharedA", "backendSharedB", "dummyFeignClient");
 
 		// expect circuitbreaker-event actuator endpoint recorded both events
 		ResponseEntity<CircuitBreakerEventsEndpointResponse> circuitBreakerEventList = restTemplate.getForEntity("/actuator/circuitbreakerevents", CircuitBreakerEventsEndpointResponse.class);

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/retry/RetryAutoConfigurationAsyncTest.java
Patch:
@@ -16,6 +16,7 @@
 package io.github.resilience4j.retry;
 
 import static io.github.resilience4j.service.test.retry.ReactiveRetryDummyService.BACKEND_C;
+import static io.github.resilience4j.service.test.retry.RetryDummyFeignClient.RETRY_DUMMY_FEIGN_CLIENT_NAME;
 import static io.github.resilience4j.service.test.retry.RetryDummyService.RETRY_BACKEND_A;
 import static io.github.resilience4j.service.test.retry.RetryDummyService.RETRY_BACKEND_B;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -94,7 +95,7 @@ public void testRetryAutoConfigurationAsync() throws Throwable {
 
 		// expect retry actuator endpoint contains both retries
 		ResponseEntity<RetryEndpointResponse> retriesList = restTemplate.getForEntity("/actuator/retries", RetryEndpointResponse.class);
-		assertThat(retriesList.getBody().getRetries()).hasSize(3).containsOnly(RETRY_BACKEND_A, RETRY_BACKEND_B, BACKEND_C);
+		assertThat(retriesList.getBody().getRetries()).hasSize(4).containsOnly(RETRY_BACKEND_A, RETRY_BACKEND_B, BACKEND_C, RETRY_DUMMY_FEIGN_CLIENT_NAME);
 
 		// expect retry-event actuator endpoint recorded both events
 		ResponseEntity<RetryEventsEndpointResponse> retryEventList = restTemplate.getForEntity("/actuator/retryevents", RetryEventsEndpointResponse.class);

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/retry/RetryAutoConfigurationReactorTest.java
Patch:
@@ -88,7 +88,7 @@ public void testRetryAutoConfigurationReactor() throws IOException {
 
 		// expect retry actuator endpoint contains both retries
 		ResponseEntity<RetryEndpointResponse> retriesList = restTemplate.getForEntity("/actuator/retries", RetryEndpointResponse.class);
-		assertThat(retriesList.getBody().getRetries()).hasSize(3);
+		assertThat(retriesList.getBody().getRetries()).hasSize(4);
 
 		// expect retry-event actuator endpoint recorded both events
 		ResponseEntity<RetryEventsEndpointResponse> retryEventList = restTemplate.getForEntity("/actuator/retryevents", RetryEventsEndpointResponse.class);

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/retry/RetryAutoConfigurationRxJavaTest.java
Patch:
@@ -88,7 +88,7 @@ public void testRetryAutoConfigurationRxJava2() throws IOException {
 
 		// expect retry actuator endpoint contains both retries
 		ResponseEntity<RetryEndpointResponse> retriesList = restTemplate.getForEntity("/actuator/retries", RetryEndpointResponse.class);
-		assertThat(retriesList.getBody().getRetries()).hasSize(3);
+		assertThat(retriesList.getBody().getRetries()).hasSize(4);
 
 		// expect retry-event actuator endpoint recorded both events
 		ResponseEntity<RetryEventsEndpointResponse> retryEventList = restTemplate.getForEntity("/actuator/retryevents", RetryEventsEndpointResponse.class);

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/service/test/TestApplication.java
Patch:
@@ -2,11 +2,13 @@
 
 import org.springframework.boot.SpringApplication;
 import org.springframework.boot.autoconfigure.SpringBootApplication;
+import org.springframework.cloud.openfeign.EnableFeignClients;
 
 /**
  * @author bstorozhuk
  */
 @SpringBootApplication
+@EnableFeignClients
 public class TestApplication {
 	public static void main(String[] args) {
 		SpringApplication.run(TestApplication.class, args);

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationTest.java
Patch:
@@ -109,9 +109,9 @@ public void testCircuitBreakerAutoConfiguration() throws IOException {
 		// expect no health indicator for backendB, as it is disabled via properties
 		ResponseEntity<String> healthResponse = restTemplate.getForEntity("/health", String.class);
 		assertThat(healthResponse.getBody()).isNotNull();
-		assertThat(healthResponse.getBody()).contains("backendACircuitBreaker");
-		assertThat(healthResponse.getBody()).doesNotContain("backendBCircuitBreaker");
-		assertThat(healthResponse.getBody()).doesNotContain("dynamicBackend");
+		assertThat(healthResponse.getBody()).contains("backendA");
+		assertThat(healthResponse.getBody()).doesNotContain("backendB");
+		assertThat(healthResponse.getBody()).contains("dynamicBackend");
 
 		// Verify that an exception for which setRecordFailurePredicate returns false and it is not included in
 		// setRecordExceptions evaluates to false.

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerConfigurationOnMissingBeanTest.java
Patch:
@@ -26,6 +26,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.actuate.autoconfigure.HealthIndicatorAutoConfiguration;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
 import org.springframework.context.annotation.Bean;
@@ -42,6 +43,7 @@
 
 @RunWith(SpringJUnit4ClassRunner.class)
 @ContextConfiguration(classes = {
+        HealthIndicatorAutoConfiguration.class,
         CircuitBreakerConfigurationOnMissingBeanTest.ConfigWithOverrides.class,
         CircuitBreakerAutoConfiguration.class,
         CircuitBreakerConfigurationOnMissingBean.class

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterConfigurationOnMissingBeanTest.java
Patch:
@@ -25,6 +25,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.actuate.autoconfigure.HealthIndicatorAutoConfiguration;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
 import org.springframework.context.annotation.Bean;
@@ -45,6 +46,7 @@
 
 @RunWith(SpringJUnit4ClassRunner.class)
 @ContextConfiguration(classes = {
+        HealthIndicatorAutoConfiguration.class,
         RateLimiterConfigurationOnMissingBeanTest.ConfigWithOverrides.class,
         RateLimiterAutoConfiguration.class,
         RateLimiterConfigurationOnMissingBean.class

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerConfigurationOnMissingBeanTest.java
Patch:
@@ -7,6 +7,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.actuate.autoconfigure.health.HealthIndicatorAutoConfiguration;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
@@ -25,6 +26,7 @@
 
 @RunWith(SpringJUnit4ClassRunner.class)
 @ContextConfiguration(classes = {
+        HealthIndicatorAutoConfiguration.class,
         CircuitBreakerConfigurationOnMissingBeanTest.ConfigWithOverrides.class,
         CircuitBreakerAutoConfiguration.class,
         CircuitBreakerConfigurationOnMissingBean.class

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterConfigurationOnMissingBeanTest.java
Patch:
@@ -7,6 +7,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.actuate.autoconfigure.health.HealthIndicatorAutoConfiguration;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
@@ -27,6 +28,7 @@
 
 @RunWith(SpringJUnit4ClassRunner.class)
 @ContextConfiguration(classes = {
+		HealthIndicatorAutoConfiguration.class,
 		RateLimiterConfigurationOnMissingBeanTest.ConfigWithOverrides.class,
 		RateLimiterAutoConfiguration.class,
 		RateLimiterConfigurationOnMissingBean.class

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerStateMachine.java
Patch:
@@ -152,7 +152,7 @@ public void acquirePermission() {
 
     @Override
     public void onError(long duration, TimeUnit durationUnit, Throwable throwable) {
-        // Handle the case if the completable future throw CompletionException wrapping the original exception
+        // Handle the case if the completable future throws a CompletionException wrapping the original exception
         // where original exception is the the one to retry not the CompletionException.
         if (throwable instanceof CompletionException) {
             Throwable cause = throwable.getCause();
@@ -278,9 +278,9 @@ private boolean shouldPublishEvents(CircuitBreakerEvent event) {
     private void publishEventIfPossible(CircuitBreakerEvent event) {
         if(shouldPublishEvents(event)) {
             if (eventProcessor.hasConsumers()) {
-                LOG.debug("Event {} published: {}", event.getEventType(), event);
                 try{
                     eventProcessor.consumeEvent(event);
+                    LOG.debug("Event {} published: {}", event.getEventType(), event);
                 }catch (Throwable t){
                     LOG.warn("Failed to handle event {}", event.getEventType(), t);
                 }

File: resilience4j-timelimiter/src/main/java/io/github/resilience4j/timelimiter/internal/TimeLimiterEventProcessor.java
Patch:
@@ -23,7 +23,7 @@
 import io.github.resilience4j.core.EventProcessor;
 import io.github.resilience4j.timelimiter.TimeLimiter;
 import io.github.resilience4j.timelimiter.event.TimeLimiterEvent;
-import io.github.resilience4j.timelimiter.event.TimeLimiterOnFailureEvent;
+import io.github.resilience4j.timelimiter.event.TimeLimiterOnErrorEvent;
 import io.github.resilience4j.timelimiter.event.TimeLimiterOnSuccessEvent;
 import io.github.resilience4j.timelimiter.event.TimeLimiterOnTimeoutEvent;
 
@@ -41,8 +41,8 @@ public TimeLimiter.EventPublisher onSuccess(EventConsumer<TimeLimiterOnSuccessEv
     }
 
     @Override
-    public TimeLimiter.EventPublisher onFailure(EventConsumer<TimeLimiterOnFailureEvent> onOnFailureEventConsumer) {
-        registerConsumer(TimeLimiterOnFailureEvent.class.getSimpleName(), onOnFailureEventConsumer);
+    public TimeLimiter.EventPublisher onError(EventConsumer<TimeLimiterOnErrorEvent> onOnFailureEventConsumer) {
+        registerConsumer(TimeLimiterOnErrorEvent.class.getSimpleName(), onOnFailureEventConsumer);
         return this;
     }
 

File: resilience4j-timelimiter/src/test/java/io/github/resilience4j/timelimiter/internal/TimeLimiterImplTest.java
Patch:
@@ -24,7 +24,7 @@ public void init() {
         timeLimiterConfig = TimeLimiterConfig.custom()
                 .timeoutDuration(Duration.ZERO)
                 .build();
-        TimeLimiterImpl testTimeout = new TimeLimiterImpl(timeLimiterConfig);
+        TimeLimiterImpl testTimeout = new TimeLimiterImpl("name", timeLimiterConfig);
         timeout = PowerMockito.spy(testTimeout);
     }
 

File: resilience4j-feign/src/main/java/io/github/resilience4j/feign/DefaultFallbackHandler.java
Patch:
@@ -40,6 +40,7 @@ public CheckedFunction1<Object[], Object> decorate(CheckedFunction1<Object[], Ob
                                                        Predicate<Exception> filter) {
         validateFallback(fallback, method);
         Method fallbackMethod = getFallbackMethod(fallback, method);
+        fallbackMethod.setAccessible(true);
         return args -> {
             try {
                 return invocationCall.apply(args);

File: resilience4j-core/src/main/java/io/github/resilience4j/core/metrics/FixedSizeSlidingWindowMetrics.java
Patch:
@@ -28,10 +28,10 @@
  * If the time window size is 10, the circular array has always 10 measurements.
  *
  * The sliding window incrementally updates a total aggregation.
- * The total aggregation is updated incrementally when a new call outcome is recorded. When the oldest bucket is evicted, the partial totalAggregation of that bucket
- * is subtracted from the total totalAggregation and the bucket is reset. (Subtract-on-Evict)
+ * The total aggregation is updated incrementally when a new call outcome is recorded. When the oldest measurement is evicted, the measurement
+ * is subtracted from the total aggregation. (Subtract-on-Evict)
  *
- * The time to retrieve a Snapshot is constant 0(1), since the Snapshot is pre-aggregated and is independent of the time window size.
+ * The time to retrieve a Snapshot is constant 0(1), since the Snapshot is pre-aggregated and is independent of the window size.
  * The space requirement (memory consumption) of this implementation should be O(n).
  */
 public class FixedSizeSlidingWindowMetrics implements Metrics {

File: resilience4j-core/src/main/java/io/github/resilience4j/core/metrics/SlidingTimeWindowMetrics.java
Patch:
@@ -34,7 +34,7 @@
  *
  * The sliding window does not store call outcomes (tuples) individually, but incrementally updates partial aggregations (bucket) and a total aggregation.
  * The total total aggregation is updated incrementally when a new call outcome is recorded. When the oldest bucket is evicted, the partial total aggregation of that bucket
- * is subtracted from the total totalAggregation and the bucket is reset. (Subtract-on-Evict)
+ * is subtracted from the total aggregation. (Subtract-on-Evict)
  *
  * The time to retrieve a Snapshot is constant 0(1), since the Snapshot is pre-aggregated and is independent of the time window size.
  * The space requirement (memory consumption) of this implementation should be nearly constant O(n), since the call outcomes (tuples) are not stored individually.

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerStateMachineTest.java
Patch:
@@ -49,7 +49,7 @@ public void setUp() {
                 .slowCallRateThreshold(50)
                 .slidingWindow(5, 5, SlidingWindow.COUNT_BASED)
                 .waitDurationInOpenState(Duration.ofSeconds(5))
-                .recordFailure(error -> !(error instanceof NumberFormatException))
+                .ignoreExceptions(NumberFormatException.class)
                 .build(), mockClock);
     }
 

File: resilience4j-core/src/main/java/io/github/resilience4j/core/predicate/PredicateCreator.java
Patch:
@@ -9,12 +9,12 @@ public class PredicateCreator {
     private PredicateCreator() {}
 
     @SafeVarargs
-    public static Optional<Predicate<Throwable>> createRecordExceptionsPredicate(Class<? extends Throwable> ...recordExceptions) {
+    public static Optional<Predicate<Throwable>> createExceptionsPredicate(Class<? extends Throwable> ...recordExceptions) {
         return exceptionPredicate(recordExceptions);
     }
 
     @SafeVarargs
-    public static Optional<Predicate<Throwable>> createIgnoreExceptionsPredicate(Class<? extends Throwable> ...ignoreExceptions) {
+    public static Optional<Predicate<Throwable>> createNegatedExceptionsPredicate(Class<? extends Throwable> ...ignoreExceptions) {
         return exceptionPredicate(ignoreExceptions)
                 .map(Predicate::negate);
     }

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationTest.java
Patch:
@@ -103,8 +103,8 @@ public void testCircuitBreakerAutoConfiguration() throws IOException {
 		ResponseEntity<CircuitBreakerEventsEndpointResponse> circuitBreakerEventList = restTemplate.getForEntity("/circuitbreaker/events", CircuitBreakerEventsEndpointResponse.class);
 		assertThat(circuitBreakerEventList.getBody().getCircuitBreakerEvents()).hasSize(2);
 
-		assertThat(circuitBreaker.getCircuitBreakerConfig().getRecordFailurePredicate().test(new RecordedException())).isTrue();
-		assertThat(circuitBreaker.getCircuitBreakerConfig().getRecordFailurePredicate().test(new IgnoredException())).isFalse();
+		assertThat(circuitBreaker.getCircuitBreakerConfig().getRecordExceptionPredicate().test(new RecordedException())).isTrue();
+		assertThat(circuitBreaker.getCircuitBreakerConfig().getIgnoreExceptionPredicate().test(new IgnoredException())).isTrue();
 
 		// expect no health indicator for backendB, as it is disabled via properties
 		ResponseEntity<String> healthResponse = restTemplate.getForEntity("/health", String.class);
@@ -115,7 +115,7 @@ public void testCircuitBreakerAutoConfiguration() throws IOException {
 
 		// Verify that an exception for which setRecordFailurePredicate returns false and it is not included in
 		// setRecordExceptions evaluates to false.
-		assertThat(circuitBreaker.getCircuitBreakerConfig().getRecordFailurePredicate().test(new Exception())).isFalse();
+		assertThat(circuitBreaker.getCircuitBreakerConfig().getRecordExceptionPredicate().test(new Exception())).isFalse();
 
 		assertThat(circuitBreakerAspect.getOrder()).isEqualTo(400);
 

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerAutoConfiguration.java
Patch:
@@ -16,6 +16,7 @@
 package io.github.resilience4j.circuitbreaker.autoconfigure;
 
 import org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration;
+import org.springframework.boot.actuate.endpoint.Endpoint;
 import org.springframework.boot.autoconfigure.AutoConfigureBefore;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
@@ -42,11 +43,13 @@
 public class CircuitBreakerAutoConfiguration {
 
     @Bean
+    @ConditionalOnClass(value = {Endpoint.class})
     public CircuitBreakerEndpoint circuitBreakerEndpoint(CircuitBreakerRegistry circuitBreakerRegistry) {
         return new CircuitBreakerEndpoint(circuitBreakerRegistry);
     }
 
     @Bean
+    @ConditionalOnClass(value = {Endpoint.class})
     public CircuitBreakerEventsEndpoint circuitBreakerEventsEndpoint(EventConsumerRegistry<CircuitBreakerEvent> eventConsumerRegistry) {
         return new CircuitBreakerEventsEndpoint(eventConsumerRegistry);
     }

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/retry/autoconfigure/RetryAutoConfiguration.java
Patch:
@@ -16,6 +16,7 @@
 package io.github.resilience4j.retry.autoconfigure;
 
 import org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration;
+import org.springframework.boot.actuate.endpoint.Endpoint;
 import org.springframework.boot.autoconfigure.AutoConfigureBefore;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
@@ -43,11 +44,13 @@
 public class RetryAutoConfiguration {
 
 	@Bean
+	@ConditionalOnClass(value = {Endpoint.class})
 	public RetryEndpoint retryEndpoint(RetryRegistry retryRegistry) {
 		return new RetryEndpoint(retryRegistry);
 	}
 
 	@Bean
+	@ConditionalOnClass(value = {Endpoint.class})
 	public RetryEventsEndpoint retryEventsEndpoint(EventConsumerRegistry<RetryEvent> eventConsumerRegistry) {
 		return new RetryEventsEndpoint(eventConsumerRegistry);
 	}

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerAutoTransitionStateMachineTest.java
Patch:
@@ -41,8 +41,8 @@ public class CircuitBreakerAutoTransitionStateMachineTest {
     public void setUp() {
         CircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.custom()
                 .failureRateThreshold(50)
-                .ringBufferSizeInClosedState(5)
-                .ringBufferSizeInHalfOpenState(3)
+                .slidingWindow(5, 5, CircuitBreakerConfig.SlidingWindow.COUNT_BASED)
+                .permittedNumberOfCallsInHalfOpenState(3)
                 .automaticTransitionFromOpenToHalfOpenEnabled(true)
                 .waitDurationInOpenState(Duration.ofSeconds(2))
                 .recordFailure(error -> !(error instanceof NumberFormatException))

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerMetricsTest.java
Patch:
@@ -31,7 +31,7 @@ public class CircuitBreakerMetricsTest {
     @Test
     public void testCircuitBreakerMetrics(){
         CircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.custom()
-                .slidingWindowInClosedState(10, 10, CircuitBreakerConfig.SlidingWindow.COUNT_BASED)
+                .slidingWindow(10, 10, CircuitBreakerConfig.SlidingWindow.COUNT_BASED)
                 .build();
 
         CircuitBreakerMetrics circuitBreakerMetrics = new CircuitBreakerMetrics(circuitBreakerConfig.getSlidingWindowSize(),

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerStateMachineTest.java
Patch:
@@ -47,7 +47,7 @@ public void setUp() {
                 .permittedNumberOfCallsInHalfOpenState(4)
                 .slowCallDurationThreshold(Duration.ofSeconds(4))
                 .slowCallRateThreshold(50)
-                .slidingWindowInClosedState(5, 5, SlidingWindow.COUNT_BASED)
+                .slidingWindow(5, 5, SlidingWindow.COUNT_BASED)
                 .waitDurationInOpenState(Duration.ofSeconds(5))
                 .recordFailure(error -> !(error instanceof NumberFormatException))
                 .build(), mockClock);

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreaker.java
Patch:
@@ -470,11 +470,10 @@ enum StateTransition {
         private static final Map<Tuple2<State, State>, StateTransition> STATE_TRANSITION_MAP = Arrays.stream(StateTransition.values())
                         .collect(Collectors.toMap(v -> Tuple.of(v.fromState, v.toState), Function.identity()));
 
-        public static StateTransition transitionBetween(State fromState, State toState){
+        public static StateTransition transitionBetween(String name, State fromState, State toState){
             final StateTransition stateTransition = STATE_TRANSITION_MAP.get(Tuple.of(fromState, toState));
             if(stateTransition == null) {
-                throw new IllegalStateException(
-                        String.format("Illegal state transition from %s to %s", fromState.toString(), toState.toString()));
+                throw new IllegalStateTransitionException(name, fromState, toState);
             }
             return stateTransition;
         }

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/InMemoryCircuitBreakerRegistryTest.java
Patch:
@@ -74,7 +74,7 @@ public void testCreateCircuitBreakerWithConfigName() {
 		final CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("circuitBreaker",
 				"testConfig");
 		assertThat(circuitBreaker).isNotNull();
-		assertThat(circuitBreaker.getCircuitBreakerConfig().getRingBufferSizeInClosedState()).isEqualTo(5);
+		assertThat(circuitBreaker.getCircuitBreakerConfig().getSlidingWindowSize()).isEqualTo(5);
 	}
 
 	@Test

File: resilience4j-spring-boot-common/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/health/CircuitBreakerHealthIndicator.java
Patch:
@@ -33,7 +33,6 @@ public class CircuitBreakerHealthIndicator implements HealthIndicator {
     private static final String BUFFERED_CALLS = "bufferedCalls";
     private static final String FAILED_CALLS = "failedCalls";
     private static final String NOT_PERMITTED = "notPermittedCalls";
-    private static final String MAX_BUFFERED_CALLS = "maxBufferedCalls";
     private static final String STATE = "state";
     private final CircuitBreaker circuitBreaker;
 
@@ -66,7 +65,6 @@ private Health.Builder addDetails(Health.Builder builder, CircuitBreaker circuit
         CircuitBreakerConfig config = circuitBreaker.getCircuitBreakerConfig();
         builder.withDetail(FAILURE_RATE, metrics.getFailureRate() + "%")
             .withDetail(FAILURE_RATE_THRESHOLD, config.getFailureRateThreshold() + "%")
-            .withDetail(MAX_BUFFERED_CALLS, metrics.getMaxNumberOfBufferedCalls())
             .withDetail(BUFFERED_CALLS, metrics.getNumberOfBufferedCalls())
             .withDetail(FAILED_CALLS, metrics.getNumberOfFailedCalls())
             .withDetail(NOT_PERMITTED, metrics.getNumberOfNotPermittedCalls())

File: resilience4j-spring-boot-common/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/health/CircuitBreakerHealthIndicatorTest.java
Patch:
@@ -32,7 +32,6 @@ public void healthMetricsAndConfig() {
         when(config.getFailureRateThreshold()).thenReturn(0.3f);
 
         when(metrics.getFailureRate()).thenReturn(0.2f);
-        when(metrics.getMaxNumberOfBufferedCalls()).thenReturn(100);
         when(metrics.getNumberOfBufferedCalls()).thenReturn(100);
         when(metrics.getNumberOfFailedCalls()).thenReturn(20);
         when(metrics.getNumberOfNotPermittedCalls()).thenReturn(0L);
@@ -50,8 +49,7 @@ public void healthMetricsAndConfig() {
                         entry("setFailureRateThreshold", "0.3%"),
                         entry("bufferedCalls", 100),
                         entry("failedCalls", 20),
-                        entry("notPermittedCalls", 0L),
-                        entry("maxBufferedCalls", 100)
+                        entry("notPermittedCalls", 0L)
                 );
     }
 

File: resilience4j-vertx/src/test/java/io/github/resilience4j/circuitbreaker/VertxCircuitBreakerTest.java
Patch:
@@ -30,6 +30,7 @@
 import org.mockito.Mockito;
 
 import java.time.Duration;
+import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -131,8 +132,8 @@ public void shouldReturnFailureWithCircuitBreakerOpenException() {
         // Create a CircuitBreakerRegistry with a custom global configuration
         CircuitBreaker circuitBreaker = CircuitBreaker.of("testName", circuitBreakerConfig);
 
-        circuitBreaker.onError(0, new RuntimeException());
-        circuitBreaker.onError(0, new RuntimeException());
+        circuitBreaker.onError(0, TimeUnit.NANOSECONDS, new RuntimeException());
+        circuitBreaker.onError(0, TimeUnit.NANOSECONDS, new RuntimeException());
         assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.OPEN);
         CircuitBreaker.Metrics metrics = circuitBreaker.getMetrics();
         assertThat(metrics.getNumberOfBufferedCalls()).isEqualTo(2);

File: resilience4j-spring-boot-common/src/test/java/io/github/resilience4j/SpringBootCommonTest.java
Patch:
@@ -77,7 +77,7 @@ public void testRetryCommonConfig() {
 	public void testRateLimiterCommonConfig() {
 		RateLimiterConfigurationOnMissingBean rateLimiterConfigurationOnMissingBean = new RateLimiterConfigurationOnMissingBean();
 		assertThat(rateLimiterConfigurationOnMissingBean.reactorRateLimiterAspectExt()).isNotNull();
-		assertThat(rateLimiterConfigurationOnMissingBean.rxJava2RateLimterAspectExt()).isNotNull();
+		assertThat(rateLimiterConfigurationOnMissingBean.rxJava2RateLimiterAspectExt()).isNotNull();
 		assertThat(rateLimiterConfigurationOnMissingBean.rateLimiterRegistry(new RateLimiterConfigurationProperties(), new DefaultEventConsumerRegistry<>())).isNotNull();
 		assertThat(rateLimiterConfigurationOnMissingBean.rateLimiterAspect(new RateLimiterConfigurationProperties(), RateLimiterRegistry.ofDefaults(), Collections.emptyList(), new FallbackDecorators(Arrays.asList(new CompletionStageFallbackDecorator()))));
 	}

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerStateMachine.java
Patch:
@@ -167,6 +167,7 @@ private void handleThrowable(long durationInNanos, Predicate<Throwable> recordFa
             publishCircuitErrorEvent(name, durationInNanos, throwable);
             stateReference.get().onError(throwable);
         } else {
+            releasePermission();
             publishCircuitIgnoredErrorEvent(name, durationInNanos, throwable);
         }
     }

File: resilience4j-spring/src/main/java/io/github/resilience4j/utils/ReactorOnClasspathCondition.java
Patch:
@@ -29,10 +29,11 @@ public class ReactorOnClasspathCondition implements Condition {
 
 	private static final Logger logger = LoggerFactory.getLogger(ReactorOnClasspathCondition.class);
 	private static final String CLASS_TO_CHECK = "reactor.core.publisher.Flux";
-
+	private static final String R4J_REACTOR = "io.github.resilience4j.reactor.AbstractSubscriber";
 	@Override
 	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
-		return AspectUtil.checkClassIfFound(context, CLASS_TO_CHECK, (e) -> logger.info("Reactor related Aspect extensions are not activated because Reactor is not on the classpath."));
+		return AspectUtil.checkClassIfFound(context, CLASS_TO_CHECK, (e) -> logger.info("Reactor related Aspect extensions are not activated because Reactor is not on the classpath."))
+				&& AspectUtil.checkClassIfFound(context, R4J_REACTOR, (e) -> logger.info("Reactor related Aspect extensions are not activated because Resilience4j Reactor module is not on the classpath."));
 	}
 
 }

File: resilience4j-spring/src/main/java/io/github/resilience4j/utils/RxJava2OnClasspathCondition.java
Patch:
@@ -29,9 +29,10 @@ public class RxJava2OnClasspathCondition implements Condition {
 
 	private static final Logger logger = LoggerFactory.getLogger(RxJava2OnClasspathCondition.class);
 	private static final String CLASS_TO_CHECK = "io.reactivex.Flowable";
-
+	private static final String R4J_RXJAVA = "io.github.resilience4j.AbstractSubscriber";
 	@Override
 	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
-		return AspectUtil.checkClassIfFound(context, CLASS_TO_CHECK, (e) -> logger.info("RxJava2 related Aspect extensions are not activated, because RxJava2 is not on the classpath."));
+		return AspectUtil.checkClassIfFound(context, CLASS_TO_CHECK, (e) -> logger.info("RxJava2 related Aspect extensions are not activated, because RxJava2 is not on the classpath."))
+				&& AspectUtil.checkClassIfFound(context, R4J_RXJAVA, (e) -> logger.info("RxJava2 related Aspect extensions are not activated because Resilience4j RxJava2 module is not on the classpath."));
 	}
 }

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreakerConfig.java
Patch:
@@ -236,7 +236,7 @@ public final Builder recordExceptions(@Nullable Class<? extends Throwable>... er
          * Configures a list of error classes that are ignored as a failure and thus do not increase the failure rate.
          * Any exception matching or inheriting from one of the list will not count as a failure, even if marked via
          *
-         * @param errorClasses the error classes that are recorded
+         * @param errorClasses the error classes that are ignored
          * @return the CircuitBreakerConfig.Builder
          * @see #recordExceptions(Class[]) . Ignoring an exception has priority over recording an exception.
          * <p>

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationTest.java
Patch:
@@ -27,7 +27,6 @@
 import org.springframework.beans.factory.annotation.Qualifier;
 import org.springframework.boot.test.context.SpringBootTest;
 import org.springframework.boot.test.web.client.TestRestTemplate;
-import org.springframework.core.Ordered;
 import org.springframework.http.ResponseEntity;
 import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
 
@@ -119,7 +118,7 @@ public void testCircuitBreakerAutoConfiguration() throws IOException {
 		// setRecordExceptions evaluates to false.
 		assertThat(circuitBreaker.getCircuitBreakerConfig().getRecordFailurePredicate().test(new Exception())).isFalse();
 
-		assertThat(circuitBreakerAspect.getOrder()).isEqualTo(Ordered.LOWEST_PRECEDENCE - 2);
+		assertThat(circuitBreakerAspect.getOrder()).isEqualTo(400);
 
 		// expect all shared configs share the same values and are from the application.yml file
 		CircuitBreaker sharedA = circuitBreakerRegistry.circuitBreaker("backendSharedA");

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterAutoConfigurationTest.java
Patch:
@@ -30,7 +30,6 @@
 import org.springframework.beans.factory.annotation.Qualifier;
 import org.springframework.boot.test.context.SpringBootTest;
 import org.springframework.boot.test.web.client.TestRestTemplate;
-import org.springframework.core.Ordered;
 import org.springframework.http.ResponseEntity;
 import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
 
@@ -129,6 +128,6 @@ public void testRateLimiterAutoConfiguration() throws IOException {
             .until(() -> rateLimiter.getMetrics().getAvailablePermissions() == 10);
 
 
-	    assertThat(rateLimiterAspect.getOrder()).isEqualTo(Ordered.LOWEST_PRECEDENCE - 1);
+        assertThat(rateLimiterAspect.getOrder()).isEqualTo(401);
     }
 }

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/retry/RetryAutoConfigurationTest.java
Patch:
@@ -26,7 +26,6 @@
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.context.SpringBootTest;
 import org.springframework.boot.test.web.client.TestRestTemplate;
-import org.springframework.core.Ordered;
 import org.springframework.http.ResponseEntity;
 import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
 
@@ -99,6 +98,6 @@ public void testRetryAutoConfiguration() throws IOException {
 		assertThat(retry.getRetryConfig().getExceptionPredicate().test(new IgnoredException())).isFalse();
 
 		// expect aspect configured as defined in application.yml
-		assertThat(retryAspect.getOrder()).isEqualTo(Ordered.LOWEST_PRECEDENCE - 3);
+		assertThat(retryAspect.getOrder()).isEqualTo(399);
 	}
 }

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationTest.java
Patch:
@@ -28,7 +28,6 @@
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.context.SpringBootTest;
 import org.springframework.boot.test.web.client.TestRestTemplate;
-import org.springframework.core.Ordered;
 import org.springframework.http.ResponseEntity;
 import org.springframework.test.annotation.DirtiesContext;
 import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@@ -125,7 +124,7 @@ public void testCircuitBreakerAutoConfiguration() throws IOException {
 		// setRecordExceptions evaluates to false.
 		assertThat(circuitBreaker.getCircuitBreakerConfig().getRecordFailurePredicate().test(new Exception())).isFalse();
 
-		assertThat(circuitBreakerAspect.getOrder()).isEqualTo(Ordered.LOWEST_PRECEDENCE - 2);
+		assertThat(circuitBreakerAspect.getOrder()).isEqualTo(400);
 
 		// expect all shared configs share the same values and are from the application.yml file
 		CircuitBreaker sharedA = circuitBreakerRegistry.circuitBreaker("backendSharedA");
@@ -246,7 +245,7 @@ public void testCircuitBreakerAutoConfigurationReactive() throws IOException {
 		assertThat(healthResponse.getBody().getDetails().get("backendACircuitBreaker")).isNotNull();
 		assertThat(healthResponse.getBody().getDetails().get("backendBCircuitBreaker")).isNull();
 
-		assertThat(circuitBreakerAspect.getOrder()).isEqualTo(Ordered.LOWEST_PRECEDENCE - 2);
+		assertThat(circuitBreakerAspect.getOrder()).isEqualTo(400);
 		assertThat(circuitBreaker.getMetrics().getNumberOfBufferedCalls()).isEqualTo(2);
 		assertThat(circuitBreaker.getMetrics().getNumberOfSuccessfulCalls()).isEqualTo(1);
 		assertThat(circuitBreaker.getMetrics().getNumberOfFailedCalls()).isEqualTo(1);

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterAutoConfigurationTest.java
Patch:
@@ -28,7 +28,6 @@
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.context.SpringBootTest;
 import org.springframework.boot.test.web.client.TestRestTemplate;
-import org.springframework.core.Ordered;
 import org.springframework.http.ResponseEntity;
 import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
 
@@ -119,6 +118,6 @@ public void testRateLimiterAutoConfiguration() throws IOException {
             .until(() -> rateLimiter.getMetrics().getAvailablePermissions() == 10);
 
 
-	    assertThat(rateLimiterAspect.getOrder()).isEqualTo(Ordered.LOWEST_PRECEDENCE - 1);
+        assertThat(rateLimiterAspect.getOrder()).isEqualTo(401);
     }
 }

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/retry/RetryAutoConfigurationAsyncTest.java
Patch:
@@ -31,7 +31,6 @@
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.context.SpringBootTest;
 import org.springframework.boot.test.web.client.TestRestTemplate;
-import org.springframework.core.Ordered;
 import org.springframework.http.ResponseEntity;
 import org.springframework.test.annotation.DirtiesContext;
 import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@@ -111,7 +110,7 @@ public void testRetryAutoConfigurationAsync() throws Throwable {
 		assertThat(retry.getMetrics().getNumberOfFailedCallsWithRetryAttempt()).isEqualTo(1);
 		assertThat(retry.getMetrics().getNumberOfSuccessfulCallsWithoutRetryAttempt()).isEqualTo(1);
 		assertThat(retry.getMetrics().getNumberOfSuccessfulCallsWithRetryAttempt()).isEqualTo(0);
-		assertThat(retryAspect.getOrder()).isEqualTo(Ordered.LOWEST_PRECEDENCE - 3);
+		assertThat(retryAspect.getOrder()).isEqualTo(399);
 	}
 
 

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/retry/RetryAutoConfigurationReactorTest.java
Patch:
@@ -25,7 +25,6 @@
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.context.SpringBootTest;
 import org.springframework.boot.test.web.client.TestRestTemplate;
-import org.springframework.core.Ordered;
 import org.springframework.http.ResponseEntity;
 import org.springframework.test.annotation.DirtiesContext;
 import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@@ -101,7 +100,7 @@ public void testRetryAutoConfigurationReactor() throws IOException {
 		assertThat(retry.getRetryConfig().getExceptionPredicate().test(new IllegalArgumentException())).isTrue();
 		assertThat(retry.getRetryConfig().getExceptionPredicate().test(new IgnoredException())).isFalse();
 
-		assertThat(retryAspect.getOrder()).isEqualTo(Ordered.LOWEST_PRECEDENCE - 3);
+		assertThat(retryAspect.getOrder()).isEqualTo(399);
 
 		assertThat(retry.getMetrics().getNumberOfFailedCallsWithoutRetryAttempt()).isEqualTo(0);
 		assertThat(retry.getMetrics().getNumberOfFailedCallsWithRetryAttempt()).isEqualTo(1);

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/retry/RetryAutoConfigurationRxJavaTest.java
Patch:
@@ -25,7 +25,6 @@
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.context.SpringBootTest;
 import org.springframework.boot.test.web.client.TestRestTemplate;
-import org.springframework.core.Ordered;
 import org.springframework.http.ResponseEntity;
 import org.springframework.test.annotation.DirtiesContext;
 import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@@ -101,7 +100,7 @@ public void testRetryAutoConfigurationRxJava2() throws IOException {
 		assertThat(retry.getRetryConfig().getExceptionPredicate().test(new IllegalArgumentException())).isTrue();
 		assertThat(retry.getRetryConfig().getExceptionPredicate().test(new IgnoredException())).isFalse();
 
-		assertThat(retryAspect.getOrder()).isEqualTo(Ordered.LOWEST_PRECEDENCE - 3);
+		assertThat(retryAspect.getOrder()).isEqualTo(399);
 
 		assertThat(retry.getMetrics().getNumberOfFailedCallsWithoutRetryAttempt()).isEqualTo(0);
 		assertThat(retry.getMetrics().getNumberOfFailedCallsWithRetryAttempt()).isEqualTo(1);

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/retry/RetryAutoConfigurationTest.java
Patch:
@@ -27,7 +27,6 @@
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.context.SpringBootTest;
 import org.springframework.boot.test.web.client.TestRestTemplate;
-import org.springframework.core.Ordered;
 import org.springframework.http.ResponseEntity;
 import org.springframework.test.annotation.DirtiesContext;
 import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@@ -104,6 +103,6 @@ public void testRetryAutoConfiguration() throws IOException {
 
 		assertThat(retry.getRetryConfig().getExceptionPredicate().test(new IOException())).isTrue();
 		assertThat(retry.getRetryConfig().getExceptionPredicate().test(new IgnoredException())).isFalse();
-		assertThat(retryAspect.getOrder()).isEqualTo(Ordered.LOWEST_PRECEDENCE - 3);
+		assertThat(retryAspect.getOrder()).isEqualTo(399);
 	}
 }

File: resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/BulkheadConfigurationProperties.java
Patch:
@@ -20,7 +20,7 @@
 public class BulkheadConfigurationProperties extends io.github.resilience4j.common.bulkhead.configuration.BulkheadConfigurationProperties {
 
 	/**
-	 * As of release 0.16.0 as we set an implicit spring aspect order now which is retry then circuit breaker then rate limiter then bulkhead
+	 * As of release 0.16.0 as we set an implicit spring aspect order for bulkhead to cover the async case of threadPool bulkhead
 	 */
 	public int getBulkheadAspectOrder() {
 		return Ordered.LOWEST_PRECEDENCE;

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/bulkhead/BulkheadMethodInterceptor.java
Patch:
@@ -72,6 +72,9 @@ public class BulkheadMethodInterceptor extends AbstractMethodInterceptor {
     @Override
     public Object invoke(MethodInvocation invocation) throws Throwable {
         Bulkhead annotation = invocation.getMethod().getAnnotation(Bulkhead.class);
+        if (annotation == null) {
+            annotation = invocation.getMethod().getDeclaringClass().getAnnotation(Bulkhead.class);
+        }
         final RecoveryFunction<?> fallbackMethod = Optional
                 .ofNullable(createRecoveryFunction(invocation, annotation.fallbackMethod()))
                 .orElse(new DefaultRecoveryFunction<>());

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/circuitbreaker/CircuitBreakerMethodInterceptor.java
Patch:
@@ -73,6 +73,9 @@ public class CircuitBreakerMethodInterceptor extends AbstractMethodInterceptor {
     @Override
     public Object invoke(MethodInvocation invocation) throws Throwable {
         CircuitBreaker annotation = invocation.getMethod().getAnnotation(CircuitBreaker.class);
+        if (annotation == null) {
+            annotation = invocation.getMethod().getDeclaringClass().getAnnotation(CircuitBreaker.class);
+        }
         final RecoveryFunction<?> fallbackMethod = Optional
                 .ofNullable(createRecoveryFunction(invocation, annotation.fallbackMethod()))
                 .orElse(new DefaultRecoveryFunction<>());

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/ratelimiter/RateLimiterMethodInterceptor.java
Patch:
@@ -72,6 +72,9 @@ public class RateLimiterMethodInterceptor extends AbstractMethodInterceptor {
     @Override
     public Object invoke(MethodInvocation invocation) throws Throwable {
         RateLimiter annotation = invocation.getMethod().getAnnotation(RateLimiter.class);
+        if (annotation == null) {
+            annotation = invocation.getMethod().getDeclaringClass().getAnnotation(RateLimiter.class);
+        }
         final RecoveryFunction<?> fallbackMethod = Optional
                 .ofNullable(createRecoveryFunction(invocation, annotation.fallbackMethod()))
                 .orElse(new DefaultRecoveryFunction<>());

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/retry/RetryMethodInterceptor.java
Patch:
@@ -69,6 +69,9 @@ public class RetryMethodInterceptor extends AbstractMethodInterceptor {
     @Override
     public Object invoke(MethodInvocation invocation) throws Throwable {
         Retry annotation = invocation.getMethod().getAnnotation(Retry.class);
+        if (annotation == null) {
+            annotation = invocation.getMethod().getDeclaringClass().getAnnotation(Retry.class);
+        }
         if(registry == null) {
             registry = RetryRegistry.ofDefaults();
         }

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/service/test/bulkhead/BulkheadDummyServiceImpl.java
Patch:
@@ -5,6 +5,7 @@
 import org.springframework.stereotype.Component;
 
 import io.github.resilience4j.bulkhead.annotation.Bulkhead;
+import io.github.resilience4j.retry.annotation.Retry;
 
 
 @Component
@@ -21,6 +22,7 @@ public void doSomething() {
     }
 
     @Override
+    @Retry(name = BulkheadDummyService.BACKEND_C)
     @Bulkhead(name = BulkheadDummyService.BACKEND_C, type = Bulkhead.Type.THREADPOOL)
     public CompletableFuture<String> doSomethingAsync() throws InterruptedException {
         Thread.sleep(500);

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerTest.java
Patch:
@@ -666,7 +666,7 @@ public void shouldThrowCircuitBreakerOpenException() {
         // Then the call fails, because CircuitBreaker is OPEN
         assertThat(result.isFailure()).isTrue();
         // Exception is CircuitBreakerOpenException
-        assertThat(result.failed().get()).isInstanceOf(CircuitBreakerOpenException.class);
+        assertThat(result.failed().get()).isInstanceOf(CallNotPermittedException.class);
         // end::shouldThrowCircuitBreakerOpenException[]
 
         CircuitBreaker.Metrics metrics = circuitBreaker.getMetrics();

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/bulkhead/configuration/BulkheadConfigurationProperties.java
Patch:
@@ -104,7 +104,7 @@ public InstanceProperties setBaseConfig(String baseConfig) {
             return this;
         }
 
-        public InstanceProperties eventConsumerBufferSize(Integer eventConsumerBufferSize) {
+        public InstanceProperties setEventConsumerBufferSize(Integer eventConsumerBufferSize) {
             this.eventConsumerBufferSize = eventConsumerBufferSize;
             return this;
         }

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/bulkhead/configuration/ThreadPoolProperties.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.bulkhead.configure.threadpool;
+package io.github.resilience4j.common.bulkhead.configuration;
 
 /**
  * common spring configuration properties fir {@link io.github.resilience4j.bulkhead.ThreadPoolBulkhead}

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/ratelimiter/configuration/RateLimiterConfigurationProperties.java
Patch:
@@ -20,6 +20,7 @@
 import io.github.resilience4j.core.lang.Nullable;
 import io.github.resilience4j.ratelimiter.RateLimiterConfig;
 
+import javax.validation.constraints.Min;
 import java.time.Duration;
 import java.util.HashMap;
 import java.util.Map;
@@ -106,6 +107,7 @@ public static class InstanceProperties {
 		private Integer timeoutInMillis;
 		private Boolean subscribeForEvents = false;
 		private Boolean registerHealthIndicator = false;
+		@Min(1)
 		private Integer eventConsumerBufferSize = 100;
 		@Nullable
 		private String baseConfig;

File: resilience4j-framework-common/src/main/java/io/github/resilience4j/common/retry/configuration/RetryConfigurationProperties.java
Patch:
@@ -296,7 +296,6 @@ public InstanceProperties setIgnoreExceptions(Class<? extends Throwable>[] ignor
 			return this;
 		}
 
-		@Nullable
 		public Integer getEventConsumerBufferSize() {
 			return eventConsumerBufferSize;
 		}

File: resilience4j-spring-boot-common/src/main/java/io/github/resilience4j/bulkhead/autoconfigure/ThreadPoolBulkheadProperties.java
Patch:
@@ -15,9 +15,9 @@
  */
 package io.github.resilience4j.bulkhead.autoconfigure;
 
+import io.github.resilience4j.common.bulkhead.configuration.ThreadPoolBulkheadConfigurationProperties;
 import org.springframework.boot.context.properties.ConfigurationProperties;
 
-import io.github.resilience4j.bulkhead.configure.threadpool.ThreadPoolBulkheadConfigurationProperties;
 
 @ConfigurationProperties(prefix = "resilience4j.thread-pool-bulkhead")
 public class ThreadPoolBulkheadProperties extends ThreadPoolBulkheadConfigurationProperties {

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterAutoConfigurationTest.java
Patch:
@@ -70,7 +70,7 @@ public void testRateLimiterAutoConfiguration() throws IOException {
 
         RateLimiter rateLimiter = rateLimiterRegistry.rateLimiter(DummyService.BACKEND);
         assertThat(rateLimiter).isNotNull();
-        rateLimiter.acquirePermission(Duration.ZERO);
+        rateLimiter.acquirePermission();
         await()
             .atMost(2, TimeUnit.SECONDS)
             .until(() -> rateLimiter.getMetrics().getAvailablePermissions() == 10);

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreaker.java
Patch:
@@ -71,7 +71,7 @@ public interface CircuitBreaker {
      * If the state is HALF_OPEN, the number of allowed test calls is decreased. Important: Make sure to call onSuccess or onError
      * after the call is finished. If the call is cancelled before it is invoked, you have to release the permission again.
      *
-     * @return {@code true} if a permission was acquired and {@code true} otherwise
+     * @return {@code true} if a permission was acquired and {@code false} otherwise
      */
     boolean tryAcquirePermission();
 

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/ratelimiter/RateLimiterMethodInterceptor.java
Patch:
@@ -31,7 +31,6 @@
 import ratpack.exec.Promise;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
-import reactor.core.scheduler.Schedulers;
 
 import java.time.Duration;
 import java.util.Optional;
@@ -93,14 +92,14 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
         } else if (Flux.class.isAssignableFrom(returnType)) {
             Flux<?> result = (Flux<?>) proceed(invocation, rateLimiter, fallbackMethod);
             if (result != null) {
-                RateLimiterOperator operator = RateLimiterOperator.of(rateLimiter, Schedulers.immediate());
+                RateLimiterOperator operator = RateLimiterOperator.of(rateLimiter);
                 result = fallbackMethod.onErrorResume(result.transform(operator));
             }
             return result;
         } else if (Mono.class.isAssignableFrom(returnType)) {
             Mono<?> result = (Mono<?>) proceed(invocation, rateLimiter, fallbackMethod);
             if (result != null) {
-                RateLimiterOperator operator = RateLimiterOperator.of(rateLimiter, Schedulers.immediate());
+                RateLimiterOperator operator = RateLimiterOperator.of(rateLimiter);
                 result = fallbackMethod.onErrorResume(result.transform(operator));
             }
             return result;

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/CombinedOperatorsTest.java
Patch:
@@ -16,7 +16,6 @@
 import org.junit.Test;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
-import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 
 import java.io.IOException;
@@ -108,7 +107,7 @@ public void shouldEmitErrorWithCircuitBreakerOpenExceptionEvenWhenErrorDuringSub
                 Flux.error(new IOException("BAM!"))
                         .compose(CircuitBreakerOperator.of(circuitBreaker))
                         .compose(BulkheadOperator.of(bulkhead))
-                        .compose(RateLimiterOperator.of(rateLimiter, Schedulers.immediate()))
+                        .compose(RateLimiterOperator.of(rateLimiter))
         ).expectError(CallNotPermittedException.class)
                 .verify(Duration.ofSeconds(1));
     }
@@ -120,7 +119,7 @@ public void shouldEmitErrorWithCircuitBreakerOpenExceptionEvenWhenErrorNotOnSubs
                 Flux.error(new IOException("BAM!"), true)
                         .compose(CircuitBreakerOperator.of(circuitBreaker))
                         .compose(BulkheadOperator.of(bulkhead))
-                        .compose(RateLimiterOperator.of(rateLimiter, Schedulers.immediate()))
+                        .compose(RateLimiterOperator.of(rateLimiter))
         ).expectError(CallNotPermittedException.class)
                 .verify(Duration.ofSeconds(1));
     }

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/ratelimiter/operator/FluxRateLimiterTest.java
Patch:
@@ -21,7 +21,6 @@
 import org.junit.Test;
 import org.mockito.Mockito;
 import reactor.core.publisher.Flux;
-import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 
 import java.io.IOException;
@@ -69,7 +68,7 @@ public void shouldEmitRequestNotPermittedException() {
 
         StepVerifier.create(
                 Flux.just("Event")
-                        .compose(RateLimiterOperator.of(rateLimiter, Schedulers.immediate())))
+                        .compose(RateLimiterOperator.of(rateLimiter)))
                 .expectSubscription()
                 .expectError(RequestNotPermitted.class)
                 .verify(Duration.ofSeconds(1));

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/ratelimiter/operator/MonoRateLimiterTest.java
Patch:
@@ -21,7 +21,6 @@
 import org.junit.Test;
 import org.mockito.Mockito;
 import reactor.core.publisher.Mono;
-import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 
 import java.io.IOException;
@@ -79,7 +78,7 @@ public void shouldEmitRequestNotPermittedExceptionEvenWhenErrorDuringSubscribe()
 
         StepVerifier.create(
                 Mono.error(new IOException("BAM!"))
-                        .compose(RateLimiterOperator.of(rateLimiter, Schedulers.immediate())))
+                        .compose(RateLimiterOperator.of(rateLimiter)))
                 .expectError(RequestNotPermitted.class)
                 .verify(Duration.ofSeconds(1));
     }

File: resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java
Patch:
@@ -49,7 +49,7 @@ static <T> DecorateCompletionStage<T> ofCompletionStage(Supplier<CompletionStage
 		return new DecorateCompletionStage<>(stageSupplier);
 	}
 
-	public static <T> DecorateConsumer<T> ofConsumer(Consumer<T> consumer) {
+	static <T> DecorateConsumer<T> ofConsumer(Consumer<T> consumer) {
 		return new DecorateConsumer<>(consumer);
 	}
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/BaseRateLimiterObserver.java
Patch:
@@ -41,5 +41,6 @@ protected void onError(Throwable t) {
     @Override
     public void hookOnCancel() {
         // Release permission in RateLimiter?
+        // rateLimiter.releasePermission
     }
 }

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreakerConfig.java
Patch:
@@ -34,7 +34,7 @@ public class CircuitBreakerConfig {
     public static final int DEFAULT_WAIT_DURATION_IN_OPEN_STATE = 60; // Seconds
     public static final int DEFAULT_RING_BUFFER_SIZE_IN_HALF_OPEN_STATE = 10;
     public static final int DEFAULT_RING_BUFFER_SIZE_IN_CLOSED_STATE = 100;
-    private static final Predicate<Throwable> DEFAULT_RECORD_FAILURE_PREDICATE = (throwable) -> true;
+    private static final Predicate<Throwable> DEFAULT_RECORD_FAILURE_PREDICATE = throwable -> true;
 
     @SuppressWarnings("unchecked")
     private Class<? extends Throwable>[] recordExceptions = new Class[0];

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/ResilienceBaseSubscriber.java
Patch:
@@ -183,9 +183,7 @@ public final void onSubscribe(Subscription s) {
                 if (acquireCallPermit()) {
                     actual.onSubscribe(this);
                 } else {
-                    cancel();
-                    actual.onSubscribe(this);
-                    actual.onError(getThrowable());
+                    Operators.error(actual, Operators.onOperatorError(s, getThrowable(), actual.currentContext()));
                 }
             }
             catch (Throwable throwable) {

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/RetryConfig.java
Patch:
@@ -30,8 +30,8 @@ public class RetryConfig {
 
 	private static final int DEFAULT_MAX_ATTEMPTS = 3;
 	public static final long DEFAULT_WAIT_DURATION = 500;
-	private static final IntervalFunction DEFAULT_INTERVAL_FUNCTION = (numOfAttempts) -> DEFAULT_WAIT_DURATION;
-	private static final Predicate<Throwable> DEFAULT_RECORD_FAILURE_PREDICATE = (throwable) -> true;
+	private static final IntervalFunction DEFAULT_INTERVAL_FUNCTION = numOfAttempts -> DEFAULT_WAIT_DURATION;
+	private static final Predicate<Throwable> DEFAULT_RECORD_FAILURE_PREDICATE = throwable -> true;
 
 	@SuppressWarnings("unchecked")
 	private Class<? extends Throwable>[] retryExceptions = new Class[0];

File: resilience4j-prometheus/src/main/java/io/github/resilience4j/prometheus/collectors/LabelNames.java
Patch:
@@ -26,7 +26,6 @@ private LabelNames() {}
 
     public static final List<String> NAME = Collections.singletonList("name");
     public static final List<String> NAME_AND_KIND = Arrays.asList("name", "kind");
-    public static final List<String> NAME_AND_STATE = Arrays.asList("name", "state");
 
 
 }

File: resilience4j-core/src/main/java/io/github/resilience4j/core/predicate/PredicateCreator.java
Patch:
@@ -6,6 +6,8 @@
 
 public class PredicateCreator {
 
+    private PredicateCreator() {}
+
     @SafeVarargs
     public static Optional<Predicate<Throwable>> createRecordExceptionsPredicate(Class<? extends Throwable> ...recordExceptions) {
         return exceptionPredicate(recordExceptions);
@@ -24,9 +26,7 @@ private static Optional<Predicate<Throwable>> exceptionPredicate(Class<? extends
                 .reduce(Predicate::or);
     }
 
-
-
-    static private Predicate<Throwable> makePredicate(Class<? extends Throwable> exClass) {
+    private static Predicate<Throwable> makePredicate(Class<? extends Throwable> exClass) {
         return (Throwable e) -> exClass.isAssignableFrom(e.getClass());
     }
 }

File: resilience4j-micrometer/src/main/java/io/github/resilience4j/micrometer/tagged/TaggedCircuitBreakerMetrics.java
Patch:
@@ -72,7 +72,7 @@ private void addMetrics(MeterRegistry registry, CircuitBreaker circuitBreaker) {
 
         final CircuitBreaker.State[] states = CircuitBreaker.State.values();
         for (CircuitBreaker.State state : states) {
-            idSet.add(Gauge.builder(names.getStateMetricName(), circuitBreaker, (cb) -> cb.getState() == state ? 1 : 0)
+            idSet.add(Gauge.builder(names.getStateMetricName(), circuitBreaker, cb -> cb.getState() == state ? 1 : 0)
                     .description("The states of the circuit breaker")
                     .tag(TagNames.NAME, circuitBreaker.getName())
                     .tag(KIND_STATE, state.name().toLowerCase())

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterConfigurationOnMissingBeanTest.java
Patch:
@@ -22,6 +22,7 @@
 import java.lang.reflect.Method;
 import java.util.List;
 
+import io.github.resilience4j.recovery.RecoveryDecorators;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;
@@ -105,8 +106,8 @@ public RateLimiterRegistry rateLimiterRegistry() {
         }
 
         @Bean
-        public RateLimiterAspect rateLimiterAspect(RateLimiterRegistry rateLimiterRegistry, @Autowired(required = false) List<RateLimiterAspectExt> rateLimiterAspectExtList) {
-            rateLimiterAspect = new RateLimiterAspect(rateLimiterRegistry, new RateLimiterConfigurationProperties(), rateLimiterAspectExtList);
+        public RateLimiterAspect rateLimiterAspect(RateLimiterRegistry rateLimiterRegistry, @Autowired(required = false) List<RateLimiterAspectExt> rateLimiterAspectExtList, RecoveryDecorators recoveryDecorators) {
+            rateLimiterAspect = new RateLimiterAspect(rateLimiterRegistry, new RateLimiterConfigurationProperties(), rateLimiterAspectExtList, recoveryDecorators);
             return rateLimiterAspect;
         }
 

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/bulkhead/autoconfigure/BulkheadAutoConfiguration.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.github.resilience4j.bulkhead.autoconfigure;
 
+import io.github.resilience4j.recovery.autoconfigure.RecoveryConfigurationOnMissingBean;
 import org.springframework.boot.actuate.autoconfigure.endpoint.EndpointAutoConfiguration;
 import org.springframework.boot.actuate.autoconfigure.endpoint.condition.ConditionalOnEnabledEndpoint;
 import org.springframework.boot.autoconfigure.AutoConfigureBefore;
@@ -38,7 +39,7 @@
 @Configuration
 @ConditionalOnClass(Bulkhead.class)
 @EnableConfigurationProperties(BulkheadProperties.class)
-@Import(BulkheadConfigurationOnMissingBean.class)
+@Import({BulkheadConfigurationOnMissingBean.class,  RecoveryConfigurationOnMissingBean.class})
 @AutoConfigureBefore(EndpointAutoConfiguration.class)
 public class BulkheadAutoConfiguration {
 	@Bean

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerAutoConfiguration.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.github.resilience4j.circuitbreaker.autoconfigure;
 
+import io.github.resilience4j.recovery.autoconfigure.RecoveryConfigurationOnMissingBean;
 import org.springframework.boot.actuate.autoconfigure.endpoint.EndpointAutoConfiguration;
 import org.springframework.boot.actuate.autoconfigure.endpoint.condition.ConditionalOnEnabledEndpoint;
 import org.springframework.boot.autoconfigure.AutoConfigureBefore;
@@ -39,7 +40,7 @@
 @Configuration
 @ConditionalOnClass(CircuitBreaker.class)
 @EnableConfigurationProperties(CircuitBreakerProperties.class)
-@Import(CircuitBreakerConfigurationOnMissingBean.class)
+@Import({CircuitBreakerConfigurationOnMissingBean.class,  RecoveryConfigurationOnMissingBean.class})
 @AutoConfigureBefore(EndpointAutoConfiguration.class)
 public class CircuitBreakerAutoConfiguration {
 

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterAutoConfiguration.java
Patch:
@@ -17,6 +17,7 @@
 
 import javax.annotation.PostConstruct;
 
+import io.github.resilience4j.recovery.autoconfigure.RecoveryConfigurationOnMissingBean;
 import org.springframework.beans.factory.config.ConfigurableBeanFactory;
 import org.springframework.boot.actuate.autoconfigure.endpoint.EndpointAutoConfiguration;
 import org.springframework.boot.actuate.autoconfigure.endpoint.condition.ConditionalOnEnabledEndpoint;
@@ -42,7 +43,7 @@
 @Configuration
 @ConditionalOnClass(RateLimiter.class)
 @EnableConfigurationProperties(RateLimiterProperties.class)
-@Import(RateLimiterConfigurationOnMissingBean.class)
+@Import({RateLimiterConfigurationOnMissingBean.class, RecoveryConfigurationOnMissingBean.class})
 @AutoConfigureBefore(EndpointAutoConfiguration.class)
 public class RateLimiterAutoConfiguration {
     private final RateLimiterProperties rateLimiterProperties;

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/retry/autoconfigure/RetryAutoConfiguration.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.github.resilience4j.retry.autoconfigure;
 
+import io.github.resilience4j.recovery.autoconfigure.RecoveryConfigurationOnMissingBean;
 import org.springframework.boot.actuate.autoconfigure.endpoint.condition.ConditionalOnEnabledEndpoint;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.context.properties.EnableConfigurationProperties;
@@ -37,7 +38,7 @@
 @Configuration
 @ConditionalOnClass(Retry.class)
 @EnableConfigurationProperties(RetryProperties.class)
-@Import(RetryConfigurationOnMissingBean.class)
+@Import({RetryConfigurationOnMissingBean.class, RecoveryConfigurationOnMissingBean.class})
 public class RetryAutoConfiguration {
 	@Bean
 	@ConditionalOnEnabledEndpoint

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterConfigurationOnMissingBeanTest.java
Patch:
@@ -4,6 +4,7 @@
 
 import java.util.List;
 
+import io.github.resilience4j.recovery.RecoveryDecorators;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;
@@ -75,8 +76,8 @@ public RateLimiterRegistry rateLimiterRegistry() {
 		}
 
 		@Bean
-		public RateLimiterAspect rateLimiterAspect(RateLimiterRegistry rateLimiterRegistry, @Autowired(required = false) List<RateLimiterAspectExt> rateLimiterAspectExtList) {
-			rateLimiterAspect = new RateLimiterAspect(rateLimiterRegistry, new RateLimiterConfigurationProperties(), rateLimiterAspectExtList);
+		public RateLimiterAspect rateLimiterAspect(RateLimiterRegistry rateLimiterRegistry, @Autowired(required = false) List<RateLimiterAspectExt> rateLimiterAspectExtList, RecoveryDecorators recoveryDecorators) {
+			rateLimiterAspect = new RateLimiterAspect(rateLimiterRegistry, new RateLimiterConfigurationProperties(), rateLimiterAspectExtList, recoveryDecorators);
 			return rateLimiterAspect;
 		}
 

File: resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/ReactorBulkheadAspectExt.java
Patch:
@@ -37,7 +37,6 @@ public class ReactorBulkheadAspectExt implements BulkheadAspectExt {
 	 * @param returnType the AOP method return type class
 	 * @return boolean if the method has Reactor return type
 	 */
-	@SuppressWarnings("unchecked")
 	@Override
 	public boolean canHandleReturnType(Class returnType) {
 		return (Flux.class.isAssignableFrom(returnType)) || (Mono.class.isAssignableFrom(returnType));
@@ -53,7 +52,6 @@ public boolean canHandleReturnType(Class returnType) {
 	 * @return the result object
 	 * @throws Throwable exception in case of faulty flow
 	 */
-	@SuppressWarnings("unchecked")
 	@Override
 	public Object handle(ProceedingJoinPoint proceedingJoinPoint, Bulkhead bulkhead, String methodName) throws Throwable {
 		Object returnValue = proceedingJoinPoint.proceed();

File: resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/RxJava2BulkheadAspectExt.java
Patch:
@@ -61,7 +61,6 @@ public boolean canHandleReturnType(Class returnType) {
 	 * @return the result object
 	 * @throws Throwable exception in case of faulty flow
 	 */
-	@SuppressWarnings("unchecked")
 	@Override
 	public Object handle(ProceedingJoinPoint proceedingJoinPoint, Bulkhead bulkhead, String methodName) throws Throwable {
 		BulkheadOperator<?> bulkheadOperator = BulkheadOperator.of(bulkhead);

File: resilience4j-spring/src/main/java/io/github/resilience4j/circuitbreaker/configure/ReactorCircuitBreakerAspectExt.java
Patch:
@@ -36,7 +36,6 @@ public class ReactorCircuitBreakerAspectExt implements CircuitBreakerAspectExt {
 	 * @param returnType the AOP method return type class
 	 * @return boolean if the method has Reactor return type
 	 */
-	@SuppressWarnings("unchecked")
 	@Override
 	public boolean canHandleReturnType(Class returnType) {
 		return (Flux.class.isAssignableFrom(returnType)) || (Mono.class.isAssignableFrom(returnType));

File: resilience4j-spring/src/main/java/io/github/resilience4j/ratelimiter/configure/RateLimiterConfiguration.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.Map;
 import java.util.stream.Collectors;
 
+import io.github.resilience4j.recovery.RecoveryDecorators;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Conditional;
@@ -85,8 +86,8 @@ private void registerEventConsumer(EventConsumerRegistry<RateLimiterEvent> event
 	}
 
 	@Bean
-	public RateLimiterAspect rateLimiterAspect(RateLimiterConfigurationProperties rateLimiterProperties, RateLimiterRegistry rateLimiterRegistry, @Autowired(required = false) List<RateLimiterAspectExt> rateLimiterAspectExtList) {
-		return new RateLimiterAspect(rateLimiterRegistry, rateLimiterProperties, rateLimiterAspectExtList);
+	public RateLimiterAspect rateLimiterAspect(RateLimiterConfigurationProperties rateLimiterProperties, RateLimiterRegistry rateLimiterRegistry, @Autowired(required = false) List<RateLimiterAspectExt> rateLimiterAspectExtList, RecoveryDecorators recoveryDecorators) {
+		return new RateLimiterAspect(rateLimiterRegistry, rateLimiterProperties, rateLimiterAspectExtList, recoveryDecorators);
 	}
 
 	@Bean

File: resilience4j-spring/src/main/java/io/github/resilience4j/ratelimiter/configure/ReactorRateLimiterAspectExt.java
Patch:
@@ -37,7 +37,6 @@ public class ReactorRateLimiterAspectExt implements RateLimiterAspectExt {
 	 * @param returnType the AOP method return type class
 	 * @return boolean if the method has Reactor return type
 	 */
-	@SuppressWarnings("unchecked")
 	@Override
 	public boolean canHandleReturnType(Class returnType) {
 		return (Flux.class.isAssignableFrom(returnType)) || (Mono.class.isAssignableFrom(returnType));
@@ -53,7 +52,6 @@ public boolean canHandleReturnType(Class returnType) {
 	 * @return the result object
 	 * @throws Throwable exception in case of faulty flow
 	 */
-	@SuppressWarnings("unchecked")
 	@Override
 	public Object handle(ProceedingJoinPoint proceedingJoinPoint, RateLimiter rateLimiter, String methodName) throws Throwable {
 		Object returnValue = proceedingJoinPoint.proceed();

File: resilience4j-spring/src/main/java/io/github/resilience4j/ratelimiter/configure/RxJava2RateLimiterAspectExt.java
Patch:
@@ -61,7 +61,6 @@ public boolean canHandleReturnType(Class returnType) {
 	 * @return the result object
 	 * @throws Throwable exception in case of faulty flow
 	 */
-	@SuppressWarnings("unchecked")
 	@Override
 	public Object handle(ProceedingJoinPoint proceedingJoinPoint, RateLimiter rateLimiter, String methodName) throws Throwable {
 		RateLimiterOperator<?> rateLimiterOperator = RateLimiterOperator.of(rateLimiter);

File: resilience4j-spring/src/main/java/io/github/resilience4j/retry/configure/RxJava2RetryAspectExt.java
Patch:
@@ -61,7 +61,6 @@ public boolean canHandleReturnType(Class returnType) {
 	 * @return the result object
 	 * @throws Throwable exception in case of faulty flow
 	 */
-	@SuppressWarnings("unchecked")
 	@Override
 	public Object handle(ProceedingJoinPoint proceedingJoinPoint, Retry retry, String methodName) throws Throwable {
 		RetryTransformer<?> retryTransformer = RetryTransformer.of(retry);

File: resilience4j-prometheus/src/main/java/io/github/resilience4j/prometheus/collectors/LabelNames.java
Patch:
@@ -26,4 +26,5 @@ private LabelNames() {}
 
     public static final List<String> NAME = Collections.singletonList("name");
     public static final List<String> NAME_AND_KIND = Arrays.asList("name", "kind");
+    public static final List<String> NAME_AND_STATE = Arrays.asList("name", "state");
 }

File: resilience4j-spring-boot-common/src/test/java/io/github/resilience4j/bulkhead/monitoring/endpoint/BulkheadEventDTOFactoryTest.java
Patch:
@@ -18,6 +18,7 @@ public void shouldMapBulkheadOnCallFinishedEvent(){
 
         assertThat(eventDTO.getBulkheadName()).isEqualTo("name");
         assertThat(eventDTO.getType()).isEqualTo(CALL_FINISHED);
+        assertThat(eventDTO.getCreationTime()).isNotNull();
     }
 
     @Test
@@ -28,6 +29,7 @@ public void shouldMapBulkheadOnCallPermittedEvent(){
 
         assertThat(eventDTO.getBulkheadName()).isEqualTo("name");
         assertThat(eventDTO.getType()).isEqualTo(CALL_PERMITTED);
+        assertThat(eventDTO.getCreationTime()).isNotNull();
     }
 
     @Test
@@ -38,6 +40,7 @@ public void shouldMapBulkheadOnCallRejectedEvent(){
 
         assertThat(eventDTO.getBulkheadName()).isEqualTo("name");
         assertThat(eventDTO.getType()).isEqualTo(CALL_REJECTED);
+        assertThat(eventDTO.getCreationTime()).isNotNull();
     }
 }
 

File: resilience4j-spring-boot-common/src/test/java/io/github/resilience4j/ratelimiter/monitoring/endpoint/RateLimiterEventDTOTest.java
Patch:
@@ -18,6 +18,7 @@ public void shouldMapRateLimiterOnFailureEvent(){
 
         assertThat(eventDTO.getRateLimiterName()).isEqualTo("name");
         assertThat(eventDTO.getType()).isEqualTo(FAILED_ACQUIRE);
+        assertThat(eventDTO.getCreationTime()).isNotNull();
     }
 
     @Test
@@ -28,5 +29,6 @@ public void shouldMapRateLimiterOnSuccessEvent(){
 
         assertThat(eventDTO.getRateLimiterName()).isEqualTo("name");
         assertThat(eventDTO.getType()).isEqualTo(SUCCESSFUL_ACQUIRE);
+        assertThat(eventDTO.getCreationTime()).isNotNull();
     }
 }

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/InMemoryCircuitBreakerRegistryTest.java
Patch:
@@ -42,7 +42,7 @@ public void testGetNotFoundCircuitBreakerRegistry() {
 	public void testUpdateDefaultCircuitBreakerRegistry() {
 		CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.ofDefaults();
 		Assertions.assertThatThrownBy(() -> circuitBreakerRegistry.addConfiguration("default", CircuitBreakerConfig.custom().build()))
-				.isExactlyInstanceOf(IllegalArgumentException.class).hasMessageStartingWith("you can not use 'default'");
+				.isExactlyInstanceOf(IllegalArgumentException.class);
 
 	}
 

File: resilience4j-micrometer/src/main/java/io/github/resilience4j/micrometer/tagged/TaggedBulkheadMetrics.java
Patch:
@@ -83,10 +83,10 @@ public void bindTo(MeterRegistry registry) {
     private void addMetrics(MeterRegistry registry, Bulkhead bulkhead) {
         Set<Meter.Id> idSet = new HashSet<>();
 
-        idSet.add(Gauge.builder(names.getAvailableConcurrentCallsMetricName(), bulkhead, (bh) -> bh.getMetrics().getAvailableConcurrentCalls())
+        idSet.add(Gauge.builder(names.getAvailableConcurrentCallsMetricName(), bulkhead, bh -> bh.getMetrics().getAvailableConcurrentCalls())
                 .tag(TagNames.NAME, bulkhead.getName())
                 .register(registry).getId());
-        idSet.add(Gauge.builder(names.getMaxAllowedConcurrentCallsMetricName(), bulkhead, (bh) -> bh.getMetrics().getMaxAllowedConcurrentCalls())
+        idSet.add(Gauge.builder(names.getMaxAllowedConcurrentCallsMetricName(), bulkhead, bh -> bh.getMetrics().getMaxAllowedConcurrentCalls())
                 .tag(TagNames.NAME, bulkhead.getName())
                 .register(registry).getId());
 

File: resilience4j-micrometer/src/main/java/io/github/resilience4j/micrometer/tagged/TaggedRateLimiterMetrics.java
Patch:
@@ -83,10 +83,10 @@ public void bindTo(MeterRegistry registry) {
     private void addMetrics(MeterRegistry registry, RateLimiter rateLimiter) {
         Set<Meter.Id> idSet = new HashSet<>();
 
-        idSet.add(Gauge.builder(names.getAvailablePermissionsMetricName(), rateLimiter, (rl) -> rl.getMetrics().getAvailablePermissions())
+        idSet.add(Gauge.builder(names.getAvailablePermissionsMetricName(), rateLimiter, rl -> rl.getMetrics().getAvailablePermissions())
                 .tag(TagNames.NAME, rateLimiter.getName())
                 .register(registry).getId());
-        idSet.add(Gauge.builder(names.getWaitingThreadsMetricName(), rateLimiter, (rl) -> rl.getMetrics().getNumberOfWaitingThreads())
+        idSet.add(Gauge.builder(names.getWaitingThreadsMetricName(), rateLimiter, rl -> rl.getMetrics().getNumberOfWaitingThreads())
                 .tag(TagNames.NAME, rateLimiter.getName())
                 .register(registry).getId());
 

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/bulkhead/BulkheadMethodInterceptor.java
Patch:
@@ -94,8 +94,8 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
                 Throwable t = new BulkheadFullException(String.format("Bulkhead '%s' is full", bulkhead.getName()));
                 try {
                     promise.complete(recoveryFunction.apply(t));
-                } catch (Throwable t2) {
-                    promise.completeExceptionally(t2);
+                } catch (Exception exception) {
+                    promise.completeExceptionally(exception);
                 }
                 return promise;
             }

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/circuitbreaker/CircuitBreakerMethodInterceptor.java
Patch:
@@ -98,8 +98,8 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
                 Throwable t = new CallNotPermittedException(breaker);
                 try {
                     promise.complete(recoveryFunction.apply((Throwable) t));
-                } catch (Throwable t2) {
-                    promise.completeExceptionally(t2);
+                } catch (Exception exception) {
+                    promise.completeExceptionally(exception);
                 }
             }
             return promise;

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/internal/AbstractTransformer.java
Patch:
@@ -33,8 +33,8 @@ protected void handleRecovery(Downstream<? super T> down, Throwable throwable) {
             } else {
                 down.error(throwable);
             }
-        } catch (Throwable t) {
-            down.error(t);
+        } catch (Exception ex) {
+            down.error(ex);
         }
     }
 }

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/ratelimiter/RateLimiterMethodInterceptor.java
Patch:
@@ -90,8 +90,8 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
                 Throwable t = new RequestNotPermitted("Request not permitted for limiter: " + rateLimiter.getName());
                 try {
                     promise.complete(recoveryFunction.apply(t));
-                } catch (Throwable t2) {
-                    promise.completeExceptionally(t2);
+                } catch (Exception exception) {
+                    promise.completeExceptionally(exception);
                 }
                 return promise;
             }

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/utils/MetricNames.java
Patch:
@@ -8,4 +8,5 @@ public class MetricNames {
     public static final String BUFFERED = "buffered";
     public static final String BUFFERED_MAX = "buffered_max";
     public static final String STATE = "state";
+    public static final String FAILURE_RATE = "failure_rate";
 }

File: resilience4j-metrics/src/main/java/io/github/resilience4j/metrics/CircuitBreakerMetrics.java
Patch:
@@ -48,7 +48,7 @@ private CircuitBreakerMetrics(String prefix, Iterable<CircuitBreaker> circuitBre
         requireNonNull(circuitBreakers);
         circuitBreakers.forEach((CircuitBreaker circuitBreaker) -> {
                 String name = circuitBreaker.getName();
-            //state as an integer
+                //state as an integer
                 metricRegistry.register(name(prefix, name, STATE),
                       (Gauge<Integer>)()-> circuitBreaker.getState().getOrder());
                 metricRegistry.register(name(prefix, name, SUCCESSFUL),
@@ -61,6 +61,8 @@ private CircuitBreakerMetrics(String prefix, Iterable<CircuitBreaker> circuitBre
                     (Gauge<Integer>) () -> circuitBreaker.getMetrics().getNumberOfBufferedCalls());
                 metricRegistry.register(name(prefix, name, BUFFERED_MAX),
                     (Gauge<Integer>) () -> circuitBreaker.getMetrics().getMaxNumberOfBufferedCalls());
+                metricRegistry.register(name(prefix, name, FAILURE_RATE),
+                    (Gauge<Float>) () -> circuitBreaker.getMetrics().getFailureRate());
             }
         );
     }

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/FixedThreadPoolBulkhead.java
Patch:
@@ -204,19 +204,19 @@ private class BulkheadEventProcessor extends EventProcessor<BulkheadEvent> imple
 
 		@Override
 		public ThreadPoolBulkheadEventPublisher onCallPermitted(EventConsumer<BulkheadOnCallPermittedEvent> onCallPermittedEventConsumer) {
-			registerConsumer(BulkheadOnCallPermittedEvent.class, onCallPermittedEventConsumer);
+			registerConsumer(BulkheadOnCallPermittedEvent.class.getSimpleName(), onCallPermittedEventConsumer);
 			return this;
 		}
 
 		@Override
 		public ThreadPoolBulkheadEventPublisher onCallRejected(EventConsumer<BulkheadOnCallRejectedEvent> onCallRejectedEventConsumer) {
-			registerConsumer(BulkheadOnCallRejectedEvent.class, onCallRejectedEventConsumer);
+			registerConsumer(BulkheadOnCallRejectedEvent.class.getSimpleName(), onCallRejectedEventConsumer);
 			return this;
 		}
 
 		@Override
 		public ThreadPoolBulkheadEventPublisher onCallFinished(EventConsumer<BulkheadOnCallFinishedEvent> onCallFinishedEventConsumer) {
-			registerConsumer(BulkheadOnCallFinishedEvent.class, onCallFinishedEventConsumer);
+			registerConsumer(BulkheadOnCallFinishedEvent.class.getSimpleName(), onCallFinishedEventConsumer);
 			return this;
 		}
 

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/InMemoryBulkheadRegistry.java
Patch:
@@ -21,7 +21,7 @@
 import io.github.resilience4j.bulkhead.Bulkhead;
 import io.github.resilience4j.bulkhead.BulkheadConfig;
 import io.github.resilience4j.bulkhead.BulkheadRegistry;
-import io.github.resilience4j.core.AbstractRegistry;
+import io.github.resilience4j.core.registry.AbstractRegistry;
 import io.github.resilience4j.core.ConfigurationNotFoundException;
 import io.vavr.collection.Array;
 import io.vavr.collection.Seq;
@@ -62,7 +62,7 @@ public InMemoryBulkheadRegistry(BulkheadConfig defaultConfig) {
 	 */
 	@Override
 	public Seq<Bulkhead> getAllBulkheads() {
-		return Array.ofAll(targetMap.values());
+		return Array.ofAll(entryMap.values());
 	}
 
 	/**

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/InMemoryThreadPoolBulkheadRegistry.java
Patch:
@@ -21,7 +21,7 @@
 import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;
 import io.github.resilience4j.bulkhead.ThreadPoolBulkheadConfig;
 import io.github.resilience4j.bulkhead.ThreadPoolBulkheadRegistry;
-import io.github.resilience4j.core.AbstractRegistry;
+import io.github.resilience4j.core.registry.AbstractRegistry;
 import io.github.resilience4j.core.ConfigurationNotFoundException;
 import io.vavr.collection.Array;
 import io.vavr.collection.Seq;
@@ -62,7 +62,7 @@ public InMemoryThreadPoolBulkheadRegistry(ThreadPoolBulkheadConfig defaultConfig
 	 */
 	@Override
 	public Seq<ThreadPoolBulkhead> getAllBulkheads() {
-		return Array.ofAll(targetMap.values());
+		return Array.ofAll(entryMap.values());
 	}
 
 	/**

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/SemaphoreBulkhead.java
Patch:
@@ -173,19 +173,19 @@ private class BulkheadEventProcessor extends EventProcessor<BulkheadEvent> imple
 
         @Override
         public EventPublisher onCallPermitted(EventConsumer<BulkheadOnCallPermittedEvent> onCallPermittedEventConsumer) {
-            registerConsumer(BulkheadOnCallPermittedEvent.class, onCallPermittedEventConsumer);
+            registerConsumer(BulkheadOnCallPermittedEvent.class.getSimpleName(), onCallPermittedEventConsumer);
             return this;
         }
 
         @Override
         public EventPublisher onCallRejected(EventConsumer<BulkheadOnCallRejectedEvent> onCallRejectedEventConsumer) {
-            registerConsumer(BulkheadOnCallRejectedEvent.class, onCallRejectedEventConsumer);
+            registerConsumer(BulkheadOnCallRejectedEvent.class.getSimpleName(), onCallRejectedEventConsumer);
             return this;
         }
 
         @Override
         public EventPublisher onCallFinished(EventConsumer<BulkheadOnCallFinishedEvent> onCallFinishedEventConsumer) {
-            registerConsumer(BulkheadOnCallFinishedEvent.class, onCallFinishedEventConsumer);
+            registerConsumer(BulkheadOnCallFinishedEvent.class.getSimpleName(), onCallFinishedEventConsumer);
             return this;
         }
 

File: resilience4j-cache/src/main/java/io/github/resilience4j/cache/internal/CacheImpl.java
Patch:
@@ -127,19 +127,19 @@ private class CacheEventProcessor extends EventProcessor<CacheEvent> implements
 
         @Override
         public EventPublisher onCacheHit(EventConsumer<CacheOnHitEvent> eventConsumer) {
-            registerConsumer(CacheOnHitEvent.class, eventConsumer);
+            registerConsumer(CacheOnHitEvent.class.getSimpleName(), eventConsumer);
             return this;
         }
 
         @Override
         public EventPublisher onCacheMiss(EventConsumer<CacheOnMissEvent> eventConsumer) {
-            registerConsumer(CacheOnMissEvent.class, eventConsumer);
+            registerConsumer(CacheOnMissEvent.class.getSimpleName(), eventConsumer);
             return this;
         }
 
         @Override
         public EventPublisher onError(EventConsumer<CacheOnErrorEvent> eventConsumer) {
-            registerConsumer(CacheOnErrorEvent.class, eventConsumer);
+            registerConsumer(CacheOnErrorEvent.class.getSimpleName(), eventConsumer);
             return this;
         }
 

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/InMemoryCircuitBreakerRegistry.java
Patch:
@@ -21,7 +21,7 @@
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
-import io.github.resilience4j.core.AbstractRegistry;
+import io.github.resilience4j.core.registry.AbstractRegistry;
 import io.github.resilience4j.core.ConfigurationNotFoundException;
 import io.vavr.collection.Array;
 import io.vavr.collection.Seq;
@@ -62,7 +62,7 @@ public InMemoryCircuitBreakerRegistry(CircuitBreakerConfig defaultConfig) {
 	 */
 	@Override
 	public Seq<CircuitBreaker> getAllCircuitBreakers() {
-		return Array.ofAll(targetMap.values());
+		return Array.ofAll(entryMap.values());
 	}
 
 	/**

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/InMemoryRateLimiterRegistry.java
Patch:
@@ -18,7 +18,7 @@
  */
 package io.github.resilience4j.ratelimiter.internal;
 
-import io.github.resilience4j.core.AbstractRegistry;
+import io.github.resilience4j.core.registry.AbstractRegistry;
 import io.github.resilience4j.core.ConfigurationNotFoundException;
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.ratelimiter.RateLimiterConfig;
@@ -62,7 +62,7 @@ public InMemoryRateLimiterRegistry(RateLimiterConfig defaultConfig) {
 	 */
 	@Override
 	public Seq<RateLimiter> getAllRateLimiters() {
-		return Array.ofAll(targetMap.values());
+		return Array.ofAll(entryMap.values());
 	}
 
 	/**

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/RateLimiterEventProcessor.java
Patch:
@@ -34,13 +34,13 @@ public void consumeEvent(RateLimiterEvent event) {
 
     @Override
     public RateLimiter.EventPublisher onSuccess(EventConsumer<RateLimiterOnSuccessEvent> onSuccessEventConsumer) {
-        registerConsumer(RateLimiterOnSuccessEvent.class, onSuccessEventConsumer);
+        registerConsumer(RateLimiterOnSuccessEvent.class.getSimpleName(), onSuccessEventConsumer);
         return this;
     }
 
     @Override
     public RateLimiter.EventPublisher onFailure(EventConsumer<RateLimiterOnFailureEvent> onOnFailureEventConsumer) {
-        registerConsumer(RateLimiterOnFailureEvent.class, onOnFailureEventConsumer);
+        registerConsumer(RateLimiterOnFailureEvent.class.getSimpleName(), onOnFailureEventConsumer);
         return this;
     }
 }
\ No newline at end of file

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/InMemoryRetryRegistry.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.github.resilience4j.retry.internal;
 
-import io.github.resilience4j.core.AbstractRegistry;
+import io.github.resilience4j.core.registry.AbstractRegistry;
 import io.github.resilience4j.core.ConfigurationNotFoundException;
 import io.github.resilience4j.retry.Retry;
 import io.github.resilience4j.retry.RetryConfig;
@@ -59,7 +59,7 @@ public InMemoryRetryRegistry(RetryConfig defaultConfig) {
 	 */
 	@Override
 	public Seq<Retry> getAllRetries() {
-		return Array.ofAll(targetMap.values());
+		return Array.ofAll(entryMap.values());
 	}
 
 	/**

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerConfigurationOnMissingBean.java
Patch:
@@ -43,7 +43,7 @@ public EventConsumerRegistry<CircuitBreakerEvent> eventConsumerRegistry() {
 		return circuitBreakerConfiguration.eventConsumerRegistry();
 	}
 
-	protected void createHeathIndicatorForCircuitBreaker(CircuitBreaker circuitBreaker) {
+	protected void createHealthIndicatorForCircuitBreaker(CircuitBreaker circuitBreaker) {
 		BackendProperties backendProperties = circuitBreakerProperties.findCircuitBreakerBackend(circuitBreaker, circuitBreaker.getCircuitBreakerConfig());
 
 		if (backendProperties != null && backendProperties.getRegisterHealthIndicator()) {

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/BulkheadConfig.java
Patch:
@@ -69,8 +69,8 @@ public static class Builder {
 		 * @return the BulkheadConfig.Builder
 		 */
 		public Builder maxConcurrentCalls(int maxConcurrentCalls) {
-			if (maxConcurrentCalls < 1) {
-				throw new IllegalArgumentException("maxConcurrentCalls must be a positive integer value >= 1");
+			if (maxConcurrentCalls < 0) {
+				throw new IllegalArgumentException("maxConcurrentCalls must be an integer value >= 0");
 			}
 			config.maxConcurrentCalls = maxConcurrentCalls;
 			return this;

File: resilience4j-micrometer/src/main/java/io/github/resilience4j/micrometer/BulkheadMetrics.java
Patch:
@@ -46,6 +46,7 @@ private BulkheadMetrics(Iterable<Bulkhead> bulkheads, String prefix) {
      * a {@link BulkheadRegistry} as a source.
      *
      * @param bulkheadRegistry the registry of bulkheads
+     * @return The BulkheadMetrics {@link BulkheadMetrics}.
      */
     public static BulkheadMetrics ofBulkheadRegistry(BulkheadRegistry bulkheadRegistry) {
         return new BulkheadMetrics(bulkheadRegistry.getAllBulkheads());

File: resilience4j-micrometer/src/main/java/io/github/resilience4j/micrometer/RateLimiterMetrics.java
Patch:
@@ -46,6 +46,7 @@ private RateLimiterMetrics(Iterable<RateLimiter> rateLimiters, String prefix) {
      * a {@link RateLimiterRegistry} as a source.
      *
      * @param rateLimiterRegistry the registry of rate limiters
+     * @return The RateLimiterMetrics {@link RateLimiterMetrics}.
      */
     public static RateLimiterMetrics ofRateLimiterRegistry(RateLimiterRegistry rateLimiterRegistry) {
         return new RateLimiterMetrics(rateLimiterRegistry.getAllRateLimiters());

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiterConfig.java
Patch:
@@ -53,6 +53,7 @@ public static Builder custom() {
     /**
      * Returns a builder to create a custom RateLimiterConfig using specified config as prototype
      *
+     * @param prototype A {@link RateLimiterConfig} prototype.
      * @return a {@link RateLimiterConfig.Builder}
      */
     public static Builder from(RateLimiterConfig prototype) {

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/bulkhead/autoconfigure/BulkheadMetricsAutoConfiguration.java
Patch:
@@ -20,6 +20,7 @@
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.AutoConfigureBefore;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 
@@ -38,6 +39,7 @@
 @AutoConfigureBefore(MetricRepositoryAutoConfiguration.class)
 public class BulkheadMetricsAutoConfiguration {
 	@Bean
+	@ConditionalOnMissingBean
 	public BulkheadMetrics registerBulkheadMetrics(BulkheadRegistry bulkheadRegistry, MetricRegistry metricRegistry) {
 		BulkheadMetrics bulkheadMetrics = BulkheadMetrics.ofBulkheadRegistry(bulkheadRegistry);
 		metricRegistry.registerAll(bulkheadMetrics);

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerPrometheusAutoConfiguration.java
Patch:
@@ -20,6 +20,7 @@
 import io.github.resilience4j.prometheus.collectors.CircuitBreakerMetricsCollector;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
@@ -34,6 +35,7 @@
 public class CircuitBreakerPrometheusAutoConfiguration {
 
     @Bean
+    @ConditionalOnMissingBean
     @ConditionalOnProperty(value = "resilience4j.circuitbreaker.metrics.use_legacy_collector", havingValue = "true")
     public CircuitBreakerExports legacyCircuitBreakerPrometheusCollector(CircuitBreakerRegistry circuitBreakerRegistry) {
         CircuitBreakerExports collector = CircuitBreakerExports.ofCircuitBreakerRegistry(circuitBreakerRegistry);
@@ -42,6 +44,7 @@ public CircuitBreakerExports legacyCircuitBreakerPrometheusCollector(CircuitBrea
     }
 
     @Bean
+    @ConditionalOnMissingBean
     @ConditionalOnProperty(
         value = "resilience4j.circuitbreaker.metrics.use_legacy_collector",
         havingValue = "false",

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterPrometheusAutoConfiguration.java
Patch:
@@ -20,6 +20,7 @@
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
@@ -35,13 +36,15 @@ public class RateLimiterPrometheusAutoConfiguration {
 
     @ConditionalOnProperty(value = "resilience4j.ratelimiter.metrics.use_legacy_collector", havingValue = "true")
     @Bean
+    @ConditionalOnMissingBean
     public RateLimiterExports legacyRateLimiterPrometheusCollector(RateLimiterRegistry rateLimiterRegistry){
         RateLimiterExports collector = RateLimiterExports.ofRateLimiterRegistry(rateLimiterRegistry);
         collector.register();
         return collector;
     }
 
     @Bean
+    @ConditionalOnMissingBean
     @ConditionalOnProperty(
         value = "resilience4j.ratelimiter.metrics.use_legacy_collector",
         havingValue = "false",

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/retry/autoconfigure/RetryMetricsAutoConfiguration.java
Patch:
@@ -20,6 +20,7 @@
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.AutoConfigureBefore;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 
@@ -40,6 +41,7 @@
 public class RetryMetricsAutoConfiguration {
 
 	@Bean
+	@ConditionalOnMissingBean
 	public RetryMetrics registerRetryMetrics(RetryRegistry retryRegistry, MetricRegistry metricRegistry) {
 		RetryMetrics retryMetrics = RetryMetrics.ofRetryRegistry(retryRegistry);
 		metricRegistry.registerAll(retryMetrics);

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerMetricsAutoConfiguration.java
Patch:
@@ -21,6 +21,7 @@
 import org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
@@ -36,12 +37,14 @@
 public class CircuitBreakerMetricsAutoConfiguration {
 
     @Bean
+    @ConditionalOnMissingBean
     @ConditionalOnProperty(value = "resilience4j.circuitbreaker.metrics.use_legacy_binder", havingValue = "true")
     public CircuitBreakerMetrics registerLegacyCircuitBreakerMetrics(CircuitBreakerRegistry circuitBreakerRegistry) {
         return CircuitBreakerMetrics.ofCircuitBreakerRegistry(circuitBreakerRegistry);
     }
 
     @Bean
+    @ConditionalOnMissingBean
     @ConditionalOnProperty(
         value = "resilience4j.circuitbreaker.metrics.use_legacy_binder",
         havingValue = "false",

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerEventDTOBuilder.java
Patch:
@@ -22,9 +22,9 @@
 import io.github.resilience4j.core.lang.Nullable;
 
 class CircuitBreakerEventDTOBuilder {
-    private String circuitBreakerName;
-    private CircuitBreakerEvent.Type type;
-    private String creationTime;
+    private final String circuitBreakerName;
+    private final CircuitBreakerEvent.Type type;
+    private final String creationTime;
     @Nullable
     private String throwable = null;
     @Nullable

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/health/CircuitBreakerHealthIndicator.java
Patch:
@@ -16,14 +16,14 @@
 package io.github.resilience4j.circuitbreaker.monitoring.health;
 
 
+import java.util.Optional;
+
 import org.springframework.boot.actuate.health.Health;
 import org.springframework.boot.actuate.health.HealthIndicator;
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
 
-import java.util.Optional;
-
 /**
  * A Spring Boot health indicators which adds the state of a CircuitBreaker and it's metrics to the health endpoints
  */
@@ -36,7 +36,7 @@ public class CircuitBreakerHealthIndicator implements HealthIndicator {
     private static final String NOT_PERMITTED = "notPermittedCalls";
     private static final String MAX_BUFFERED_CALLS = "maxBufferedCalls";
     private static final String STATE = "state";
-    private CircuitBreaker circuitBreaker;
+    private final CircuitBreaker circuitBreaker;
 
     public CircuitBreakerHealthIndicator(CircuitBreaker circuitBreaker) {
         this.circuitBreaker = circuitBreaker;

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterMetricsAutoConfiguration.java
Patch:
@@ -22,6 +22,7 @@
 import org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
@@ -37,12 +38,14 @@
 public class RateLimiterMetricsAutoConfiguration {
 
     @Bean
+    @ConditionalOnMissingBean
     @ConditionalOnProperty(value = "resilience4j.ratelimiter.metrics.use_legacy_binder", havingValue = "true")
     public RateLimiterMetrics registerLegacyRateLimiterMetrics(RateLimiterRegistry rateLimiterRegistry) {
         return RateLimiterMetrics.ofRateLimiterRegistry(rateLimiterRegistry);
     }
 
     @Bean
+    @ConditionalOnMissingBean
     @ConditionalOnProperty(
         value = "resilience4j.ratelimiter.metrics.use_legacy_binder",
         havingValue = "false",

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/retry/autoconfigure/RetryAutoConfiguration.java
Patch:
@@ -25,7 +25,6 @@
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.retry.Retry;
 import io.github.resilience4j.retry.RetryRegistry;
-import io.github.resilience4j.retry.configure.RetryConfiguration;
 import io.github.resilience4j.retry.event.RetryEvent;
 import io.github.resilience4j.retry.monitoring.endpoint.RetryEndpoint;
 import io.github.resilience4j.retry.monitoring.endpoint.RetryEventsEndpoint;
@@ -38,7 +37,7 @@
 @Configuration
 @ConditionalOnClass(Retry.class)
 @EnableConfigurationProperties(RetryProperties.class)
-@Import(RetryConfiguration.class)
+@Import(RetryConfigurationOnMissingBean.class)
 public class RetryAutoConfiguration {
 	@Bean
 	@ConditionalOnEnabledEndpoint

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationRxJava2Test.java
Patch:
@@ -88,7 +88,7 @@ public void testCircuitBreakerAutoConfigurationReactiveRxJava2() throws IOExcept
 
 		// expect circuitbreakers actuator endpoint contains both circuitbreakers
 		ResponseEntity<CircuitBreakerEndpointResponse> circuitBreakerList = restTemplate.getForEntity("/actuator/circuitbreakers", CircuitBreakerEndpointResponse.class);
-		assertThat(circuitBreakerList.getBody().getCircuitBreakers()).hasSize(2).containsExactly("backendA", "backendB");
+		assertThat(circuitBreakerList.getBody().getCircuitBreakers()).hasSize(4).containsExactly("backendA", "backendB", "backendSharedA", "backendSharedB");
 
 		// expect circuitbreaker-event actuator endpoint recorded both events
 		ResponseEntity<CircuitBreakerEventsEndpointResponse> circuitBreakerEventList = restTemplate.getForEntity("/actuator/circuitbreakerevents", CircuitBreakerEventsEndpointResponse.class);

File: resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/RxJava2BulkheadAspectExt.java
Patch:
@@ -25,7 +25,6 @@
 
 import io.github.resilience4j.bulkhead.Bulkhead;
 import io.github.resilience4j.bulkhead.operator.BulkheadOperator;
-import io.github.resilience4j.circuitbreaker.configure.CircuitBreakerAspect;
 import io.reactivex.Completable;
 import io.reactivex.CompletableSource;
 import io.reactivex.Flowable;
@@ -42,7 +41,7 @@
  */
 public class RxJava2BulkheadAspectExt implements BulkheadAspectExt {
 
-	private static final Logger logger = LoggerFactory.getLogger(CircuitBreakerAspect.class);
+	private static final Logger logger = LoggerFactory.getLogger(RxJava2BulkheadAspectExt.class);
 	private final Set<Class> rxSupportedTypes = newHashSet(ObservableSource.class, SingleSource.class, CompletableSource.class, MaybeSource.class, Flowable.class);
 
 	/**

File: resilience4j-spring/src/main/java/io/github/resilience4j/circuitbreaker/configure/RxJava2CircuitBreakerAspectExt.java
Patch:
@@ -41,7 +41,7 @@
  */
 public class RxJava2CircuitBreakerAspectExt implements CircuitBreakerAspectExt {
 
-	private static final Logger logger = LoggerFactory.getLogger(CircuitBreakerAspect.class);
+	private static final Logger logger = LoggerFactory.getLogger(RxJava2CircuitBreakerAspectExt.class);
 	private final Set<Class> rxSupportedTypes = newHashSet(ObservableSource.class, SingleSource.class, CompletableSource.class, MaybeSource.class, Flowable.class);
 
 	/**

File: resilience4j-spring/src/main/java/io/github/resilience4j/ratelimiter/configure/RxJava2RateLimiterAspectExt.java
Patch:
@@ -23,7 +23,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import io.github.resilience4j.circuitbreaker.configure.CircuitBreakerAspect;
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.ratelimiter.operator.RateLimiterOperator;
 import io.reactivex.Completable;
@@ -40,9 +39,9 @@
  * the Rx RateLimiter logic support for the spring AOP
  * conditional on the presence of Rx classes on the spring class loader
  */
-public class RxJava2RateLimterAspectExt implements RateLimiterAspectExt {
+public class RxJava2RateLimiterAspectExt implements RateLimiterAspectExt {
 
-	private static final Logger logger = LoggerFactory.getLogger(CircuitBreakerAspect.class);
+	private static final Logger logger = LoggerFactory.getLogger(RxJava2RateLimiterAspectExt.class);
 	private final Set<Class> rxSupportedTypes = newHashSet(ObservableSource.class, SingleSource.class, CompletableSource.class, MaybeSource.class, Flowable.class);
 
 	/**

File: resilience4j-spring/src/main/java/io/github/resilience4j/retry/configure/RetryConfigurationProperties.java
Patch:
@@ -89,6 +89,7 @@ private BackendProperties getBackendProperties(String backend) {
 	 * @param properties the configured spring backend properties
 	 * @return retry config builder instance
 	 */
+	@SuppressWarnings("unchecked")
 	public RetryConfig.Builder buildRetryConfig(BackendProperties properties) {
 		if (properties == null) {
 			return new RetryConfig.Builder();

File: resilience4j-spring/src/main/java/io/github/resilience4j/retry/configure/RxJava2RetryAspectExt.java
Patch:
@@ -23,7 +23,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import io.github.resilience4j.circuitbreaker.configure.CircuitBreakerAspect;
 import io.github.resilience4j.retry.Retry;
 import io.github.resilience4j.retry.transformer.RetryTransformer;
 import io.reactivex.Completable;
@@ -42,7 +41,7 @@
  */
 public class RxJava2RetryAspectExt implements RetryAspectExt {
 
-	private static final Logger logger = LoggerFactory.getLogger(CircuitBreakerAspect.class);
+	private static final Logger logger = LoggerFactory.getLogger(RxJava2RetryAspectExt.class);
 	private final Set<Class> rxSupportedTypes = newHashSet(ObservableSource.class, SingleSource.class, CompletableSource.class, MaybeSource.class, Flowable.class);
 
 	/**

File: resilience4j-spring/src/main/java/io/github/resilience4j/utils/AnnotationExtractor.java
Patch:
@@ -17,6 +17,7 @@ private AnnotationExtractor() {
      *
      * @param targetClass target class
      * @param annotationClass annotation class
+     * @param <T> The annotation type.
      * @return annotation
      */
     @Nullable

File: resilience4j-bulkhead/src/jcstress/java/io/github/resilience4j/bulkhead/concurrent/ConcurrentBulkheadTest.java
Patch:
@@ -63,14 +63,14 @@ public ConcurrentBulkheadTest() {
 
     @Actor
     public void firstActor() {
-        if (bulkhead.isCallPermitted()) {
+        if (bulkhead.obtainPermission()) {
             bulkhead.onComplete();
         }
     }
 
     @Actor
     public void secondActor() {
-        if (bulkhead.isCallPermitted()) {
+        if (bulkhead.obtainPermission()) {
             bulkhead.onComplete();
         }
     }

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/BulkheadEventPublisherTest.java
Patch:
@@ -86,7 +86,7 @@ public void shouldConsumeOnCallRejectedEvent() {
                 .onCallRejected(event ->
                         logger.info(event.getEventType().toString()));
 
-        bulkhead.isCallPermitted();
+        bulkhead.tryObtainPermission();
 
         Try.ofSupplier(Bulkhead.decorateSupplier(bulkhead,helloWorldService::returnHelloWorld));
 

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/BulkheadTest.java
Patch:
@@ -402,8 +402,8 @@ public void shouldReturnFailureWithBulkheadFullException() {
         // Given
         BulkheadConfig config = BulkheadConfig.custom().maxConcurrentCalls(2).build();
         Bulkhead bulkhead = Bulkhead.of("test", config);
-        bulkhead.isCallPermitted();
-        bulkhead.isCallPermitted();
+        bulkhead.tryObtainPermission();
+        bulkhead.tryObtainPermission();
 
         // When
         CheckedRunnable checkedRunnable = Bulkhead.decorateCheckedRunnable(bulkhead, () -> {throw new RuntimeException("BAM!");});
@@ -421,7 +421,7 @@ public void shouldReturnFailureWithRuntimeException() {
         // Given
         BulkheadConfig config = BulkheadConfig.custom().maxConcurrentCalls(2).build();
         Bulkhead bulkhead = Bulkhead.of("test", config);
-        bulkhead.isCallPermitted();
+        bulkhead.tryObtainPermission();
 
         //v When
         CheckedRunnable checkedRunnable = Bulkhead.decorateCheckedRunnable(bulkhead, () -> {throw new RuntimeException("BAM!");});

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerState.java
Patch:
@@ -32,7 +32,9 @@ abstract class CircuitBreakerState{
         this.stateMachine = stateMachine;
     }
 
-    abstract boolean isCallPermitted();
+    abstract boolean tryObtainPermission();
+
+    abstract void obtainPermission();
 
     abstract void onError(Throwable throwable);
 

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerEventPublisherTest.java
Patch:
@@ -116,7 +116,7 @@ public void shouldConsumeCallNotPermittedEvent() {
 
         circuitBreaker.onError(1000, new IOException("BAM!"));
         circuitBreaker.onError(1000, new IOException("BAM!"));
-        circuitBreaker.isCallPermitted();
+        circuitBreaker.tryObtainPermission();
 
         then(logger).should(times(1)).info("NOT_PERMITTED");
     }
@@ -135,7 +135,7 @@ public void shouldNotProduceEventsInDisabledState() {
         //And we execute other calls that should generate events
         circuitBreaker.onError(1000, new IOException("BAM!"));
         circuitBreaker.onError(1000, new IOException("BAM!"));
-        circuitBreaker.isCallPermitted();
+        circuitBreaker.tryObtainPermission();
         circuitBreaker.onSuccess(0);
         circuitBreaker.onError(1000, new IOException("BAM!"));
 

File: resilience4j-metrics/src/test/java/io/github/resilience4j/metrics/StateTransitionMetricsTest.java
Patch:
@@ -75,7 +75,7 @@ public void circuitBreakerMetricsUsesFirstStateObjectInstance() throws Exception
 
         await().atMost(1500, TimeUnit.MILLISECONDS)
                 .until(() -> {
-                    circuitBreaker.isCallPermitted();
+                    circuitBreaker.tryObtainPermission();
                     return circuitBreaker.getState().equals(CircuitBreaker.State.HALF_OPEN);
                 });
 

File: resilience4j-micrometer/src/test/java/io/github/resilience4j/micrometer/tagged/TaggedBulkheadMetricsTest.java
Patch:
@@ -45,8 +45,8 @@ public void setUp() {
         bulkhead = bulkheadRegistry.bulkhead("backendA");
 
         // record some basic stats
-        bulkhead.isCallPermitted();
-        bulkhead.isCallPermitted();
+        bulkhead.tryObtainPermission();
+        bulkhead.tryObtainPermission();
 
         TaggedBulkheadMetrics.ofBulkheadRegistry(bulkheadRegistry).bindTo(meterRegistry);
     }

File: resilience4j-prometheus/src/test/java/io/github/resilience4j/prometheus/collectors/BulkheadMetricsCollectorTest.java
Patch:
@@ -35,8 +35,8 @@ public void setup() {
         registry = new CollectorRegistry();
         bulkhead = Bulkhead.ofDefaults("backendA");
         // record some basic stats
-        bulkhead.isCallPermitted();
-        bulkhead.isCallPermitted();
+        bulkhead.tryObtainPermission();
+        bulkhead.tryObtainPermission();
 
         BulkheadMetricsCollector.ofBulkhead(bulkhead).register(registry);
     }

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/bulkhead/BulkheadMethodInterceptor.java
Patch:
@@ -76,7 +76,7 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
             }
             return result;
         } else if (CompletionStage.class.isAssignableFrom(returnType)) {
-            if (bulkhead.isCallPermitted()) {
+            if (bulkhead.tryObtainPermission()) {
                 return ((CompletionStage<?>) invocation.proceed()).handle((o, throwable) -> {
                     bulkhead.onComplete();
                     if (throwable != null) {
@@ -104,7 +104,7 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
     }
 
     private Object handleOther(MethodInvocation invocation, io.github.resilience4j.bulkhead.Bulkhead bulkhead, RecoveryFunction<?> recoveryFunction) throws Throwable {
-        boolean permission = bulkhead.isCallPermitted();
+        boolean permission = bulkhead.tryObtainPermission();
 
         if (!permission) {
             Throwable t = new BulkheadFullException(String.format("Bulkhead '%s' is full", bulkhead.getName()));

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/bulkhead/BulkheadTransformer.java
Patch:
@@ -58,7 +58,7 @@ public BulkheadTransformer<T> recover(Function<Throwable, ? extends T> recoverer
     @Override
     public Upstream<T> apply(Upstream<? extends T> upstream) throws Exception {
         return down -> {
-            if (bulkhead.isCallPermitted()) {
+            if (bulkhead.tryObtainPermission()) {
                 // do not allow permits to leak
                 upstream.connect(new Downstream<T>() {
 

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/circuitbreaker/CircuitBreakerMethodInterceptor.java
Patch:
@@ -16,7 +16,7 @@
 package io.github.resilience4j.ratpack.circuitbreaker;
 
 import com.google.inject.Inject;
-import io.github.resilience4j.circuitbreaker.CircuitBreakerOpenException;
+import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
 import io.github.resilience4j.core.lang.Nullable;
 import io.github.resilience4j.ratpack.recovery.RecoveryFunction;
@@ -75,7 +75,7 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
             return result;
         } else if (CompletionStage.class.isAssignableFrom(returnType)) {
             final CompletableFuture promise = new CompletableFuture<>();
-            if (breaker.isCallPermitted()) {
+            if (breaker.tryObtainPermission()) {
                 CompletionStage<?> result = (CompletionStage<?>) proceed(invocation, breaker, recoveryFunction);
                 if (result != null) {
                     long start = System.nanoTime();
@@ -95,7 +95,7 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
                     });
                 }
             } else {
-                Throwable t = new CircuitBreakerOpenException(String.format("CircuitBreaker '%s' is open", breaker.getName()));
+                Throwable t = new CallNotPermittedException(breaker);
                 try {
                     promise.complete(recoveryFunction.apply((Throwable) t));
                 } catch (Throwable t2) {

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/circuitbreaker/CircuitBreakerTransformer.java
Patch:
@@ -15,8 +15,8 @@
  */
 package io.github.resilience4j.ratpack.circuitbreaker;
 
+import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
-import io.github.resilience4j.circuitbreaker.CircuitBreakerOpenException;
 import io.github.resilience4j.ratpack.internal.AbstractTransformer;
 import ratpack.exec.Downstream;
 import ratpack.exec.Upstream;
@@ -57,7 +57,7 @@ public CircuitBreakerTransformer<T> recover(Function<Throwable, ? extends T> rec
     public Upstream<T> apply(Upstream<? extends T> upstream) throws Exception {
         return down -> {
             long start;
-            if (circuitBreaker.isCallPermitted()) {
+            if (circuitBreaker.tryObtainPermission()) {
                 start = System.nanoTime();
                 upstream.connect(new Downstream<T>() {
 
@@ -81,7 +81,7 @@ public void complete() {
                     }
                 });
             } else {
-                Throwable t = new CircuitBreakerOpenException(String.format("CircuitBreaker '%s' is open", circuitBreaker.getName()));
+                Throwable t = new CallNotPermittedException(circuitBreaker);
                 handleRecovery(down, t);
             }
         };

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/ResilienceBaseSubscriber.java
Patch:
@@ -154,12 +154,12 @@ protected void hookOnPermitAcquired() {
     /**
      * @return true if call is permitted, false otherwise
      */
-    protected abstract boolean isCallPermitted();
+    protected abstract boolean obtainPermission();
 
     protected boolean acquireCallPermit() {
         boolean callPermitted = false;
         if (permitted.compareAndSet(Permit.PENDING, Permit.ACQUIRED)) {
-            callPermitted = isCallPermitted();
+            callPermitted = obtainPermission();
             if (!callPermitted) {
                 permitted.set(Permit.REJECTED);
             } else {

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/bulkhead/operator/BulkheadSubscriber.java
Patch:
@@ -59,8 +59,8 @@ public void hookOnError(Throwable t) {
     }
 
     @Override
-    protected boolean isCallPermitted() {
-        return bulkhead.isCallPermitted();
+    protected boolean obtainPermission() {
+        return bulkhead.tryObtainPermission();
     }
 
     @Override

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/ratelimiter/operator/RateLimiterSubscriber.java
Patch:
@@ -61,7 +61,7 @@ public void hookOnError(Throwable t) {
     }
 
     @Override
-    protected boolean isCallPermitted() {
+    protected boolean obtainPermission() {
         return rateLimiter.getPermission(rateLimiter.getRateLimiterConfig().getTimeoutDuration());
     }
 

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/bulkhead/operator/FluxBulkheadTest.java
Patch:
@@ -59,7 +59,7 @@ public void shouldPropagateError() {
 
     @Test
     public void shouldEmitErrorWithBulkheadFullException() {
-        bulkhead.isCallPermitted();
+        bulkhead.tryObtainPermission();
 
         StepVerifier.create(
                 Flux.just("Event")
@@ -73,7 +73,7 @@ public void shouldEmitErrorWithBulkheadFullException() {
 
     @Test
     public void shouldEmitBulkheadFullExceptionEvenWhenErrorDuringSubscribe() {
-        bulkhead.isCallPermitted();
+        bulkhead.tryObtainPermission();
 
         StepVerifier.create(
                 Flux.error(new IOException("BAM!"))
@@ -87,7 +87,7 @@ public void shouldEmitBulkheadFullExceptionEvenWhenErrorDuringSubscribe() {
 
     @Test
     public void shouldEmitBulkheadFullExceptionEvenWhenErrorNotOnSubscribe() {
-        bulkhead.isCallPermitted();
+        bulkhead.tryObtainPermission();
 
         StepVerifier.create(
                 Flux.error(new IOException("BAM!"), true)

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/bulkhead/operator/MonoBulkheadTest.java
Patch:
@@ -58,7 +58,7 @@ public void shouldPropagateError() {
 
     @Test
     public void shouldEmitErrorWithBulkheadFullException() {
-        bulkhead.isCallPermitted();
+        bulkhead.tryObtainPermission();
 
         StepVerifier.create(
                 Mono.just("Event")
@@ -72,7 +72,7 @@ public void shouldEmitErrorWithBulkheadFullException() {
 
     @Test
     public void shouldEmitBulkheadFullExceptionEvenWhenErrorDuringSubscribe() {
-        bulkhead.isCallPermitted();
+        bulkhead.tryObtainPermission();
 
         StepVerifier.create(
                 Mono.error(new IOException("BAM!"))
@@ -86,7 +86,7 @@ public void shouldEmitBulkheadFullExceptionEvenWhenErrorDuringSubscribe() {
 
     @Test
     public void shouldEmitBulkheadFullExceptionEvenWhenErrorNotOnSubscribe() {
-        bulkhead.isCallPermitted();
+        bulkhead.tryObtainPermission();
 
         StepVerifier.create(
                 Mono.error(new IOException("BAM!")).delayElement(Duration.ofMillis(1))

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/BulkheadSubscriber.java
Patch:
@@ -78,7 +78,7 @@ public void cancel() {
     private boolean acquireCallPermit() {
         boolean callPermitted = false;
         if (permitted.compareAndSet(Permit.PENDING, Permit.ACQUIRED)) {
-            callPermitted = bulkhead.isCallPermitted();
+            callPermitted = bulkhead.tryObtainPermission();
             if (!callPermitted) {
                 permitted.set(Permit.REJECTED);
             }

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/DisposableBulkhead.java
Patch:
@@ -124,7 +124,7 @@ private boolean isInvocationPermitted() {
     private boolean acquireCallPermit() {
         boolean callPermitted = false;
         if (permitted.compareAndSet(Permit.PENDING, Permit.ACQUIRED)) {
-            callPermitted = bulkhead.isCallPermitted();
+            callPermitted = bulkhead.tryObtainPermission();
             if (!callPermitted) {
                 permitted.set(Permit.REJECTED);
             }

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerSubscriber.java
Patch:
@@ -1,8 +1,8 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
 import io.github.resilience4j.adapter.Permit;
+import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
-import io.github.resilience4j.circuitbreaker.CircuitBreakerOpenException;
 import io.github.resilience4j.core.StopWatch;
 import io.github.resilience4j.core.lang.Nullable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
@@ -39,7 +39,7 @@ public void onSubscribe(Subscription subscription) {
             } else {
                 cancel();
                 childSubscriber.onSubscribe(this);
-                childSubscriber.onError(new CircuitBreakerOpenException(String.format("CircuitBreaker '%s' is open", circuitBreaker.getName())));
+                childSubscriber.onError(new CallNotPermittedException(circuitBreaker.getName()));
             }
         }
     }
@@ -80,7 +80,7 @@ public void cancel() {
     private boolean acquireCallPermit() {
         boolean callPermitted = false;
         if (permitted.compareAndSet(Permit.PENDING, Permit.ACQUIRED)) {
-            callPermitted = circuitBreaker.isCallPermitted();
+            callPermitted = circuitBreaker.tryObtainPermission();
             if (!callPermitted) {
                 permitted.set(Permit.REJECTED);
             } else {

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/DisposableCircuitBreaker.java
Patch:
@@ -1,8 +1,8 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
 import io.github.resilience4j.adapter.Permit;
+import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
-import io.github.resilience4j.circuitbreaker.CircuitBreakerOpenException;
 import io.github.resilience4j.core.StopWatch;
 import io.github.resilience4j.core.lang.Nullable;
 import io.reactivex.disposables.Disposable;
@@ -122,7 +122,7 @@ protected final void onNextInner(T value) {
     private boolean acquireCallPermit() {
         boolean callPermitted = false;
         if (permitted.compareAndSet(Permit.PENDING, Permit.ACQUIRED)) {
-            callPermitted = circuitBreaker.isCallPermitted();
+            callPermitted = circuitBreaker.tryObtainPermission();
             if (!callPermitted) {
                 permitted.set(Permit.REJECTED);
             } else {
@@ -137,7 +137,7 @@ private boolean isInvocationPermitted() {
     }
 
     private Exception circuitBreakerOpenException() {
-        return new CircuitBreakerOpenException(String.format("CircuitBreaker '%s' is open", circuitBreaker.getName()));
+        return new CallNotPermittedException(circuitBreaker);
     }
 
     private void markFailure(Throwable e) {

File: resilience4j-retry/src/test/java/io/github/resilience4j/retry/internal/AsyncRetryTest.java
Patch:
@@ -90,8 +90,6 @@ public void shouldNotRetryWithThatResult(){
 		// Then the helloWorldService should be invoked 1 time
 		BDDMockito.then(helloWorldService).should(Mockito.times(1)).returnHelloWorld();
 		Assertions.assertThat(result).isEqualTo("Hello world");
-		// for code quality scan , it does not not recognize assertJ do not why
-		Assert.assertEquals(result, "Hello world");
 	}
 
 	@Test

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerCompletableObserver.java
Patch:
@@ -8,7 +8,7 @@
  * A RxJava {@link CompletableObserver} to protect another observer by a CircuitBreaker.
  */
 final class CircuitBreakerCompletableObserver extends DisposableCircuitBreaker implements CompletableObserver {
-    private final CompletableObserver childObserver;
+    private final transient CompletableObserver childObserver;
 
     CircuitBreakerCompletableObserver(CircuitBreaker circuitBreaker, CompletableObserver childObserver) {
         super(circuitBreaker);

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerSubscriber.java
Patch:
@@ -24,7 +24,7 @@ final class CircuitBreakerSubscriber<T> extends AtomicReference<Subscription> im
     private final transient Subscriber<? super T> childSubscriber;
     private final AtomicReference<Permit> permitted = new AtomicReference<>(Permit.PENDING);
     @Nullable
-    private StopWatch stopWatch;
+    private transient StopWatch stopWatch;
 
     CircuitBreakerSubscriber(CircuitBreaker circuitBreaker, Subscriber<? super T> childSubscriber) {
         this.circuitBreaker = requireNonNull(circuitBreaker);
@@ -100,13 +100,13 @@ private boolean notCancelled() {
 
     private void markFailure(Throwable e) {
         if (wasCallPermitted()) {
-            circuitBreaker.onError(stopWatch.stop().toNanos(), e);
+            circuitBreaker.onError(stopWatch != null ? stopWatch.stop().toNanos() : 0, e);
         }
     }
 
     private void markSuccess() {
         if (wasCallPermitted()) {
-            circuitBreaker.onSuccess(stopWatch.stop().toNanos());
+            circuitBreaker.onSuccess(stopWatch != null ? stopWatch.stop().toNanos() : 0);
         }
     }
 

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/circuitbreaker/endpoint/CircuitBreakerEventDTOFactory.java
Patch:
@@ -19,6 +19,8 @@
 
 class CircuitBreakerEventDTOFactory {
 
+    private CircuitBreakerEventDTOFactory(){}
+
     static CircuitBreakerEventDTO createCircuitBreakerEventDTO(CircuitBreakerEvent event){
         switch(event.getEventType()) {
             case ERROR:

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/circuitbreaker/operator/CircuitBreakerSubscriber.java
Patch:
@@ -86,7 +86,7 @@ protected void hookOnError(Throwable t) {
 
     @Override
     protected void hookOnPermitAcquired() {
-        stopWatch = StopWatch.start(circuitBreaker.getName());
+        stopWatch = StopWatch.start();
     }
 
     @Override
@@ -102,13 +102,13 @@ protected Throwable getThrowable() {
 
     private void markFailure(Throwable e) {
         if (wasCallPermitted()) {
-            circuitBreaker.onError(stopWatch.stop().getProcessingDuration().toNanos(), e);
+            circuitBreaker.onError(stopWatch != null ? stopWatch.stop().toNanos() : 0, e);
         }
     }
 
     private void markSuccess() {
         if (wasCallPermitted()) {
-            circuitBreaker.onSuccess(stopWatch.stop().getProcessingDuration().toNanos());
+            circuitBreaker.onSuccess(stopWatch != null ? stopWatch.stop().toNanos() : 0);
         }
     }
 }

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerSubscriber.java
Patch:
@@ -84,7 +84,7 @@ private boolean acquireCallPermit() {
             if (!callPermitted) {
                 permitted.set(Permit.REJECTED);
             } else {
-                stopWatch = StopWatch.start(circuitBreaker.getName());
+                stopWatch = StopWatch.start();
             }
         }
         return callPermitted;
@@ -100,13 +100,13 @@ private boolean notCancelled() {
 
     private void markFailure(Throwable e) {
         if (wasCallPermitted()) {
-            circuitBreaker.onError(stopWatch.stop().getProcessingDuration().toNanos(), e);
+            circuitBreaker.onError(stopWatch.stop().toNanos(), e);
         }
     }
 
     private void markSuccess() {
         if (wasCallPermitted()) {
-            circuitBreaker.onSuccess(stopWatch.stop().getProcessingDuration().toNanos());
+            circuitBreaker.onSuccess(stopWatch.stop().toNanos());
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/DisposableCircuitBreaker.java
Patch:
@@ -126,7 +126,7 @@ private boolean acquireCallPermit() {
             if (!callPermitted) {
                 permitted.set(Permit.REJECTED);
             } else {
-                stopWatch = StopWatch.start(circuitBreaker.getName());
+                stopWatch = StopWatch.start();
             }
         }
         return callPermitted;
@@ -142,13 +142,13 @@ private Exception circuitBreakerOpenException() {
 
     private void markFailure(Throwable e) {
         if (wasCallPermitted()) {
-            circuitBreaker.onError(stopWatch.stop().getProcessingDuration().toNanos(), e);
+            circuitBreaker.onError(stopWatch != null ? stopWatch.stop().toNanos() : 0, e);
         }
     }
 
     private void markSuccess() {
         if (wasCallPermitted()) {
-            circuitBreaker.onSuccess(stopWatch.stop().getProcessingDuration().toNanos());
+            circuitBreaker.onSuccess(stopWatch != null ? stopWatch.stop().toNanos() : 0);
         }
     }
 

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/RateLimiterCompletableObserver.java
Patch:
@@ -9,7 +9,7 @@
  * Consumes one permit when subscribed.
  */
 final class RateLimiterCompletableObserver extends DisposableRateLimiter implements CompletableObserver {
-    private final CompletableObserver childObserver;
+    private final transient CompletableObserver childObserver;
 
     RateLimiterCompletableObserver(RateLimiter rateLimiter, CompletableObserver childObserver) {
         super(rateLimiter);

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerEventDTOFactory.java
Patch:
@@ -19,6 +19,8 @@
 
 class CircuitBreakerEventDTOFactory {
 
+    private CircuitBreakerEventDTOFactory(){}
+
     static CircuitBreakerEventDTO createCircuitBreakerEventDTO(CircuitBreakerEvent event){
         switch(event.getEventType()) {
             case ERROR:

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerEventDTOFactory.java
Patch:
@@ -19,6 +19,8 @@
 
 class CircuitBreakerEventDTOFactory {
 
+    private CircuitBreakerEventDTOFactory(){}
+
     static CircuitBreakerEventDTO createCircuitBreakerEventDTO(CircuitBreakerEvent event){
         switch(event.getEventType()) {
             case ERROR:

File: resilience4j-metrics/src/main/java/io/github/resilience4j/metrics/Timer.java
Patch:
@@ -69,7 +69,7 @@ static Timer of(String name) {
      *
      * @param runnable the original Callable
      */
-    default void executeRunnable(Runnable runnable) throws Exception {
+    default void executeRunnable(Runnable runnable) {
         decorateRunnable(this, runnable).run();
     }
 

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/bulkhead/autoconfigure/BulkheadAutoConfiguration.java
Patch:
@@ -48,7 +48,7 @@ public BulkheadEndpoint bulkheadEndpoint(BulkheadRegistry bulkheadRegistry) {
     }
 
 	@Bean
-	public BulkheadEventsEndpoint bulkheadEventsEndpoint(EventConsumerRegistry<BulkheadEvent> eventConsumerRegistry, BulkheadRegistry bulkheadRegistry) {
-		return new BulkheadEventsEndpoint(eventConsumerRegistry, bulkheadRegistry);
+	public BulkheadEventsEndpoint bulkheadEventsEndpoint(EventConsumerRegistry<BulkheadEvent> eventConsumerRegistry) {
+		return new BulkheadEventsEndpoint(eventConsumerRegistry);
 	}
 }

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/bulkhead/endpoint/BulkheadChain.java
Patch:
@@ -21,7 +21,7 @@
 import io.github.resilience4j.consumer.CircularEventConsumer;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.ratpack.Resilience4jConfig;
-import io.github.resilience4j.ratpack.adapter.ReactorAdapter;
+import io.github.resilience4j.reactor.adapter.ReactorAdapter;
 import io.vavr.collection.Seq;
 import ratpack.exec.Promise;
 import ratpack.func.Action;

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/event/AbstractBulkheadEvent.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.time.ZonedDateTime;
 
-abstract class AbstractBulkheadEvent implements io.github.resilience4j.bulkhead.event.BulkheadEvent {
+abstract class AbstractBulkheadEvent implements BulkheadEvent {
 
     private final String bulkheadName;
     private final ZonedDateTime creationTime;

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java
Patch:
@@ -238,7 +238,7 @@ static <T, R> Function<T, R> decorateFunction(RateLimiter rateLimiter, Function<
 	 * @throws RequestNotPermitted   if waiting time elapsed before a permit was acquired.
 	 * @throws IllegalStateException if thread was interrupted during permission wait
 	 */
-	static void waitForPermission(final RateLimiter rateLimiter) throws IllegalStateException, RequestNotPermitted {
+	static void waitForPermission(final RateLimiter rateLimiter) {
 		RateLimiterConfig rateLimiterConfig = rateLimiter.getRateLimiterConfig();
 		Duration timeoutDuration = rateLimiterConfig.getTimeoutDuration();
 		boolean permission = rateLimiter.getPermission(timeoutDuration);

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/event/AbstractRateLimiterEvent.java
Patch:
@@ -40,9 +40,6 @@ public ZonedDateTime getCreationTime() {
         return creationTime;
     }
 
-    @Override
-    public abstract Type getEventType();
-
     @Override
     public String toString() {
         return "RateLimiterEvent{" +

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/circuitbreaker/CircuitBreakerConfig.java
Patch:
@@ -18,6 +18,7 @@
 
 import java.util.Arrays;
 import java.util.List;
+import java.util.Objects;
 import java.util.stream.Collectors;
 
 import static io.github.resilience4j.circuitbreaker.CircuitBreakerConfig.*;
@@ -150,7 +151,7 @@ private List<Class<? extends Throwable>> buildArray(List<String> list) {
                         return null;
                     }
                 })
-                .filter(c -> c != null)
+                .filter(Objects::nonNull)
                 .collect(Collectors.toList());
     }
 

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/circuitbreaker/endpoint/CircuitBreakerChain.java
Patch:
@@ -22,10 +22,10 @@
 import io.github.resilience4j.consumer.CircularEventConsumer;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.ratpack.Resilience4jConfig;
-import io.github.resilience4j.ratpack.adapter.ReactorAdapter;
 import io.github.resilience4j.ratpack.circuitbreaker.endpoint.metrics.CircuitBreakerMetricsDTO;
 import io.github.resilience4j.ratpack.circuitbreaker.endpoint.states.CircuitBreakerStateDTO;
 import io.github.resilience4j.ratpack.circuitbreaker.endpoint.states.CircuitBreakerStatesEndpointResponse;
+import io.github.resilience4j.reactor.adapter.ReactorAdapter;
 import io.vavr.collection.Seq;
 import ratpack.exec.Promise;
 import ratpack.func.Action;

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/ratelimiter/endpoint/RateLimiterChain.java
Patch:
@@ -22,7 +22,7 @@
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
 import io.github.resilience4j.ratelimiter.event.RateLimiterEvent;
 import io.github.resilience4j.ratpack.Resilience4jConfig;
-import io.github.resilience4j.ratpack.adapter.ReactorAdapter;
+import io.github.resilience4j.reactor.adapter.ReactorAdapter;
 import io.vavr.collection.Seq;
 import ratpack.exec.Promise;
 import ratpack.func.Action;

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/retry/endpoint/RetryChain.java
Patch:
@@ -19,7 +19,7 @@
 import io.github.resilience4j.consumer.CircularEventConsumer;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.github.resilience4j.ratpack.Resilience4jConfig;
-import io.github.resilience4j.ratpack.adapter.ReactorAdapter;
+import io.github.resilience4j.reactor.adapter.ReactorAdapter;
 import io.github.resilience4j.retry.Retry;
 import io.github.resilience4j.retry.RetryRegistry;
 import io.github.resilience4j.retry.event.RetryEvent;
@@ -39,7 +39,6 @@
 /**
  * Provides event and stream event endpoints for circuitbreaker events.
  */
-// TODO test
 public class RetryChain implements Action<Chain> {
 
     private final EventConsumerRegistry<RetryEvent> eventConsumerRegistry;

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/adapter/ReactorAdapter.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.github.resilience4j.adapter;
+package io.github.resilience4j.reactor.adapter;
 
 
 import io.github.resilience4j.core.EventPublisher;
@@ -22,6 +22,8 @@
 
 public class ReactorAdapter {
 
+    private ReactorAdapter(){}
+
     /**
      * Converts the EventPublisher into a Flux.
      *

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/bulkhead/operator/BulkheadOperator.java
Patch:
@@ -24,14 +24,14 @@
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;
 
-import java.util.function.Function;
+import java.util.function.UnaryOperator;
 
 /**
  * A Reactor operator which wraps a reactive type in a bulkhead.
  *
  * @param <T> the value type of the upstream and downstream
  */
-public class BulkheadOperator<T> implements Function<Publisher<T>, Publisher<T>> {
+public class BulkheadOperator<T> implements UnaryOperator<Publisher<T>> {
     private final Bulkhead bulkhead;
     private final Scheduler scheduler;
 

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/circuitbreaker/operator/CircuitBreakerOperator.java
Patch:
@@ -22,14 +22,14 @@
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
-import java.util.function.Function;
+import java.util.function.UnaryOperator;
 
 /**
  * A Reactor operator which wraps a reactive type in a circuit breaker.
  *
  * @param <T> the value type of the upstream and downstream
  */
-public class CircuitBreakerOperator<T> implements Function<Publisher<T>, Publisher<T>> {
+public class CircuitBreakerOperator<T> implements UnaryOperator<Publisher<T>> {
 
     private final CircuitBreaker circuitBreaker;
 

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/ratelimiter/operator/RateLimiterOperator.java
Patch:
@@ -24,15 +24,15 @@
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;
 
-import java.util.function.Function;
+import java.util.function.UnaryOperator;
 
 
 /**
  * A Reactor operator which wraps a reactive type in a rate limiter.
  *
  * @param <T> the value type of the upstream and downstream
  */
-public class RateLimiterOperator<T> implements Function<Publisher<T>, Publisher<T>> {
+public class RateLimiterOperator<T> implements UnaryOperator<Publisher<T>> {
     private final RateLimiter rateLimiter;
     private final Scheduler scheduler;
 

File: resilience4j-retry/src/test/java/io/github/resilience4j/retry/internal/CompletionStageRetryTest.java
Patch:
@@ -39,7 +39,7 @@
 import static io.github.resilience4j.retry.utils.AsyncUtils.awaitResult;
 import static java.util.concurrent.CompletableFuture.completedFuture;
 
-public class CompletationStageRetryTest {
+public class CompletionStageRetryTest {
 
 	private AsyncHelloWorldService helloWorldService;
 	private ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
@@ -90,8 +90,6 @@ public void shouldNotRetryWithThatResult(){
 		// Then the helloWorldService should be invoked 1 time
 		BDDMockito.then(helloWorldService).should(Mockito.times(1)).returnHelloWorld();
 		Assertions.assertThat(result).isEqualTo("Hello world");
-		// for code quality scan , it does not not recognize assertJ do not why
-		Assert.assertEquals(result, "Hello world");
 	}
 
 	@Test

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/BulkheadCompletableObserver.java
Patch:
@@ -1,16 +1,16 @@
 package io.github.resilience4j.bulkhead.operator;
 
-import static java.util.Objects.requireNonNull;
-
 import io.github.resilience4j.bulkhead.Bulkhead;
 import io.reactivex.CompletableObserver;
 import io.reactivex.disposables.Disposable;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A RxJava {@link CompletableObserver} to wrap another observer in a bulkhead.
  */
 final class BulkheadCompletableObserver extends DisposableBulkhead implements CompletableObserver {
-    private final CompletableObserver childObserver;
+    private final transient CompletableObserver childObserver;
 
     BulkheadCompletableObserver(Bulkhead bulkhead, CompletableObserver childObserver) {
         super(bulkhead);

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/BulkheadMaybeObserver.java
Patch:
@@ -1,18 +1,18 @@
 package io.github.resilience4j.bulkhead.operator;
 
-import static java.util.Objects.requireNonNull;
-
 import io.github.resilience4j.bulkhead.Bulkhead;
 import io.reactivex.MaybeObserver;
 import io.reactivex.disposables.Disposable;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A RxJava {@link MaybeObserver} to wrap another observer in a bulkhead.
  *
  * @param <T> the value type of the upstream and downstream
  */
 final class BulkheadMaybeObserver<T> extends DisposableBulkhead<T> implements MaybeObserver<T> {
-    private final MaybeObserver<? super T> childObserver;
+    private final transient MaybeObserver<? super T> childObserver;
 
     BulkheadMaybeObserver(Bulkhead bulkhead, MaybeObserver<? super T> childObserver) {
         super(bulkhead);

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/BulkheadObserver.java
Patch:
@@ -1,18 +1,18 @@
 package io.github.resilience4j.bulkhead.operator;
 
-import static java.util.Objects.requireNonNull;
-
 import io.github.resilience4j.bulkhead.Bulkhead;
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A RxJava {@link Observer} to wrap another observer in a bulkhead.
  *
  * @param <T> the value type of the upstream and downstream
  */
 final class BulkheadObserver<T> extends DisposableBulkhead<T> implements Observer<T> {
-    private final Observer<? super T> childObserver;
+    private final transient Observer<? super T> childObserver;
 
     BulkheadObserver(Bulkhead bulkhead, Observer<? super T> childObserver) {
         super(bulkhead);

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/BulkheadSingleObserver.java
Patch:
@@ -1,18 +1,18 @@
 package io.github.resilience4j.bulkhead.operator;
 
-import static java.util.Objects.requireNonNull;
-
 import io.github.resilience4j.bulkhead.Bulkhead;
 import io.reactivex.SingleObserver;
 import io.reactivex.disposables.Disposable;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A RxJava {@link SingleObserver} to wrap another observer in a bulkhead.
  *
  * @param <T> the value type of the upstream and downstream
  */
 final class BulkheadSingleObserver<T> extends DisposableBulkhead<T> implements SingleObserver<T> {
-    private final SingleObserver<? super T> childObserver;
+    private final transient SingleObserver<? super T> childObserver;
 
     BulkheadSingleObserver(Bulkhead bulkhead, SingleObserver<? super T> childObserver) {
         super(bulkhead);

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerMaybeObserver.java
Patch:
@@ -1,18 +1,18 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
-import static java.util.Objects.requireNonNull;
-
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.reactivex.MaybeObserver;
 import io.reactivex.disposables.Disposable;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A RxJava {@link MaybeObserver} to protect another observer by a CircuitBreaker.
  *
  * @param <T> the value type of the upstream and downstream
  */
 final class CircuitBreakerMaybeObserver<T> extends DisposableCircuitBreaker<T> implements MaybeObserver<T> {
-    private final MaybeObserver<? super T> childObserver;
+    private final transient MaybeObserver<? super T> childObserver;
 
     CircuitBreakerMaybeObserver(CircuitBreaker circuitBreaker, MaybeObserver<? super T> childObserver) {
         super(circuitBreaker);

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerObserver.java
Patch:
@@ -1,18 +1,18 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
-import static java.util.Objects.requireNonNull;
-
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A RxJava {@link Observer} to protect another observer by a CircuitBreaker.
  *
  * @param <T> the value type of the upstream and downstream
  */
 final class CircuitBreakerObserver<T> extends DisposableCircuitBreaker<T> implements Observer<T> {
-    private final Observer<? super T> childObserver;
+    private final transient Observer<? super T> childObserver;
 
     CircuitBreakerObserver(CircuitBreaker circuitBreaker, Observer<? super T> childObserver) {
         super(circuitBreaker);

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerSingleObserver.java
Patch:
@@ -1,18 +1,18 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
-import static java.util.Objects.requireNonNull;
-
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.reactivex.SingleObserver;
 import io.reactivex.disposables.Disposable;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A RxJava {@link SingleObserver} to protect another observer by a CircuitBreaker.
  *
  * @param <T> the value type of the upstream and downstream
  */
 final class CircuitBreakerSingleObserver<T> extends DisposableCircuitBreaker<T> implements SingleObserver<T> {
-    private final SingleObserver<? super T> childObserver;
+    private final transient SingleObserver<? super T> childObserver;
 
     CircuitBreakerSingleObserver(CircuitBreaker circuitBreaker, SingleObserver<? super T> childObserver) {
         super(circuitBreaker);

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerSubscriber.java
Patch:
@@ -20,8 +20,8 @@
  * @param <T> the value type of the upstream and downstream
  */
 final class CircuitBreakerSubscriber<T> extends AtomicReference<Subscription> implements Subscriber<T>, Subscription {
-    private final CircuitBreaker circuitBreaker;
-    private final Subscriber<? super T> childSubscriber;
+    private final transient CircuitBreaker circuitBreaker;
+    private final transient Subscriber<? super T> childSubscriber;
     private final AtomicReference<Permit> permitted = new AtomicReference<>(Permit.PENDING);
     @Nullable
     private StopWatch stopWatch;

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/RateLimiterMaybeObserver.java
Patch:
@@ -1,19 +1,19 @@
 package io.github.resilience4j.ratelimiter.operator;
 
-import static java.util.Objects.requireNonNull;
-
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.reactivex.MaybeObserver;
 import io.reactivex.disposables.Disposable;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A RxJava {@link MaybeObserver} to protect another observer by a {@link RateLimiter}.
  * Consumes one permit when subscribed.
  *
  * @param <T> the value type of the upstream and downstream
  */
 final class RateLimiterMaybeObserver<T> extends DisposableRateLimiter<T> implements MaybeObserver<T> {
-    private final MaybeObserver<? super T> childObserver;
+    private final transient MaybeObserver<? super T> childObserver;
 
     RateLimiterMaybeObserver(RateLimiter rateLimiter, MaybeObserver<? super T> childObserver) {
         super(rateLimiter);

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/RateLimiterSingleObserver.java
Patch:
@@ -1,19 +1,19 @@
 package io.github.resilience4j.ratelimiter.operator;
 
-import static java.util.Objects.requireNonNull;
-
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.reactivex.SingleObserver;
 import io.reactivex.disposables.Disposable;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A RxJava {@link SingleObserver} to protect another observer by a {@link RateLimiter}.
  * Consumes one permit when subscribed.
  *
  * @param <T> the value type of the upstream and downstream
  */
 final class RateLimiterSingleObserver<T> extends DisposableRateLimiter<T> implements SingleObserver<T> {
-    private final SingleObserver<? super T> childObserver;
+    private final transient SingleObserver<? super T> childObserver;
 
     RateLimiterSingleObserver(RateLimiter rateLimiter, SingleObserver<? super T> childObserver) {
         super(rateLimiter);

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/ratelimiter/operator/RateLimiterSubscriber.java
Patch:
@@ -20,8 +20,8 @@
  * @param <T> the value type of the upstream and downstream
  */
 final class RateLimiterSubscriber<T> extends AtomicReference<Subscription> implements Subscriber<T>, Subscription {
-    private final RateLimiter rateLimiter;
-    private final Subscriber<? super T> childSubscriber;
+    private final transient RateLimiter rateLimiter;
+    private final transient Subscriber<? super T> childSubscriber;
     private final AtomicReference<Permit> permitted = new AtomicReference<>(Permit.PENDING);
     private final AtomicBoolean firstEvent = new AtomicBoolean(true);
 

File: resilience4j-consumer/src/main/java/io/github/resilience4j/consumer/EventConsumerRegistry.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.github.resilience4j.consumer;
 
+import io.github.resilience4j.core.lang.Nullable;
 import io.vavr.collection.Seq;
 
 
@@ -35,6 +36,7 @@ public interface EventConsumerRegistry<T> {
      * @param id the id of the EventConsumer
      * @return the EventConsumer to which the specified id is mapped
      */
+    @Nullable
     CircularEventConsumer<T> getEventConsumer(String id);
 
     /**

File: resilience4j-spring/src/main/java/io/github/resilience4j/utils/AnnotationExtractor.java
Patch:
@@ -1,5 +1,6 @@
 package io.github.resilience4j.utils;
 
+import io.github.resilience4j.core.lang.Nullable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -18,6 +19,7 @@ private AnnotationExtractor() {
      * @param annotationClass annotation class
      * @return annotation
      */
+    @Nullable
     public static <T extends Annotation> T extract(Class<?> targetClass, Class<T> annotationClass) {
         T annotation = null;
         if (targetClass.isAnnotationPresent(annotationClass)) {
@@ -30,7 +32,6 @@ public static <T extends Annotation> T extract(Class<?> targetClass, Class<T> an
                 }
             }
         }
-
         return annotation;
     }
 }

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/retry/RetryMethodInterceptor.java
Patch:
@@ -49,9 +49,6 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
         }
         io.github.resilience4j.retry.Retry retry = registry.retry(annotation.name());
         RecoveryFunction<?> recoveryFunction = annotation.recovery().newInstance();
-        if (registry == null) {
-            registry = RetryRegistry.ofDefaults();
-        }
         Class<?> returnType = invocation.getMethod().getReturnType();
         if (Promise.class.isAssignableFrom(returnType)) {
             Promise<?> result = (Promise<?>) proceed(invocation, retry, recoveryFunction);

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/utils/MetricNames.java
Patch:
@@ -1,6 +1,8 @@
 package io.github.resilience4j.bulkhead.utils;
 
 public class MetricNames {
+    private MetricNames() {
+    }
     public static final String DEFAULT_PREFIX = "resilience4j.bulkhead";
     public static final String AVAILABLE_CONCURRENT_CALLS = "available_concurrent_calls";
     public static final String MAX_ALLOWED_CONCURRENT_CALLS = "max_allowed_concurrent_calls";

File: resilience4j-prometheus/src/main/java/io/github/resilience4j/prometheus/collectors/LabelNames.java
Patch:
@@ -21,6 +21,9 @@
 
 /** Common constants for metric binder implementations based on tags. */
 public final class LabelNames {
+
+    private LabelNames() {}
+
     public static final List<String> NAME = Collections.singletonList("name");
     public static final List<String> NAME_AND_KIND = Arrays.asList("name", "kind");
 }

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/bulkhead/autoconfigure/BulkheadMetricsAutoConfiguration.java
Patch:
@@ -34,7 +34,7 @@
  */
 @Configuration
 @ConditionalOnClass(MetricRegistry.class)
-@AutoConfigureAfter(value = {BulkheadMetricsAutoConfiguration.class, MetricsDropwizardAutoConfiguration.class})
+@AutoConfigureAfter(value = {MetricsDropwizardAutoConfiguration.class})
 @AutoConfigureBefore(MetricRepositoryAutoConfiguration.class)
 public class BulkheadMetricsAutoConfiguration {
 	@Bean

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationRxJava2Test.java
Patch:
@@ -72,12 +72,12 @@ public void testCircuitBreakerAutoConfigurationReactiveRxJava2() throws IOExcept
 		assertThat(circuitBreakerProperties).isNotNull();
 
 		try {
-			reactiveDummyService.doSomethingFlowable(true).blockingSubscribe(String::toUpperCase, Throwable::getCause);
+			reactiveDummyService.doSomethingFlowable(true).blockingSubscribe(String::toUpperCase, throwable -> System.out.println("Exception received:" + throwable.getMessage()));
 		} catch (Exception ex) {
 			// Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.
 		}
 		// The invocation is recorded by the CircuitBreaker as a success.
-		reactiveDummyService.doSomethingFlowable(false).blockingSubscribe(String::toUpperCase, Throwable::getCause);
+		reactiveDummyService.doSomethingFlowable(false).blockingSubscribe(String::toUpperCase, throwable -> System.out.println("Exception received:" + throwable.getMessage()));
 
 		CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(ReactiveDummyService.BACKEND);
 		assertThat(circuitBreaker).isNotNull();

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationTest.java
Patch:
@@ -180,12 +180,12 @@ public void testCircuitBreakerAutoConfigurationReactive() throws IOException {
 		assertThat(circuitBreakerProperties).isNotNull();
 
 		try {
-			reactiveDummyService.doSomethingFlux(true).subscribe(String::toUpperCase, Throwable::printStackTrace);
+			reactiveDummyService.doSomethingFlux(true).subscribe(String::toUpperCase, throwable -> System.out.println("Exception received:" + throwable.getMessage()));
 		} catch (IOException ex) {
 			// Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.
 		}
 		// The invocation is recorded by the CircuitBreaker as a success.
-		reactiveDummyService.doSomethingFlux(false).subscribe(String::toUpperCase, Throwable::printStackTrace);
+		reactiveDummyService.doSomethingFlux(false).subscribe(String::toUpperCase, throwable -> System.out.println("Exception received:" + throwable.getMessage()));
 
 		CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(ReactiveDummyService.BACKEND);
 		assertThat(circuitBreaker).isNotNull();

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/retry/RetryAutoConfigurationRxJavaTest.java
Patch:
@@ -69,13 +69,13 @@ public void testRetryAutoConfigurationRxJava2() throws IOException {
 		assertThat(retryProperties).isNotNull();
 
 		try {
-			retryDummyService.doSomethingFlowable(true).subscribe(String::toUpperCase, throwable -> System.out.println("Exception received:" + throwable.getMessage()));
+			retryDummyService.doSomethingFlowable(true).blockingSubscribe(String::toUpperCase, throwable -> System.out.println("Exception received:" + throwable.getMessage()));
 		} catch (RetryExceptionWrapper ex) {
 			assertThat(ex.getCause()).hasCauseInstanceOf(IllegalArgumentException.class);
 			// Do nothing. The IOException is recorded by the retry as it is one of failure exceptions
 		}
 		// The invocation is recorded by the CircuitBreaker as a success.
-		retryDummyService.doSomethingFlowable(false).subscribe(String::toUpperCase, throwable -> System.out.println("Exception received:" + throwable.getMessage()));
+		retryDummyService.doSomethingFlowable(false).blockingSubscribe(String::toUpperCase, throwable -> System.out.println("Exception received:" + throwable.getMessage()));
 		;
 
 		Retry retry = retryRegistry.retry(BACKEND_C);

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/SemaphoreBulkhead.java
Patch:
@@ -27,6 +27,7 @@
 import io.github.resilience4j.bulkhead.event.BulkheadOnCallRejectedEvent;
 import io.github.resilience4j.core.EventConsumer;
 import io.github.resilience4j.core.EventProcessor;
+import io.github.resilience4j.core.lang.Nullable;
 
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
@@ -50,7 +51,7 @@ public class SemaphoreBulkhead implements Bulkhead {
      * @param name           the name of this bulkhead
      * @param bulkheadConfig custom bulkhead configuration
      */
-    public SemaphoreBulkhead(String name, BulkheadConfig bulkheadConfig) {
+    public SemaphoreBulkhead(String name, @Nullable BulkheadConfig bulkheadConfig) {
         this.name = name;
         this.config = bulkheadConfig != null ? bulkheadConfig
                 : BulkheadConfig.ofDefaults();

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerMetrics.java
Patch:
@@ -20,6 +20,7 @@
 
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
+import io.github.resilience4j.core.lang.Nullable;
 
 import java.util.concurrent.atomic.LongAdder;
 
@@ -33,7 +34,7 @@ class CircuitBreakerMetrics implements CircuitBreaker.Metrics {
         this(ringBufferSize, null);
     }
 
-    CircuitBreakerMetrics(int ringBufferSize, RingBitSet sourceSet) {
+    CircuitBreakerMetrics(int ringBufferSize, @Nullable RingBitSet sourceSet) {
         this.ringBufferSize = ringBufferSize;
         if(sourceSet != null) {
             this.ringBitSet = new RingBitSet(this.ringBufferSize, sourceSet);

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/ClosedState.java
Patch:
@@ -20,6 +20,7 @@
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
+import io.github.resilience4j.core.lang.Nullable;
 
 final class ClosedState extends CircuitBreakerState {
 
@@ -30,7 +31,7 @@ final class ClosedState extends CircuitBreakerState {
         this(stateMachine, null);
     }
 
-    ClosedState(CircuitBreakerStateMachine stateMachine, CircuitBreakerMetrics circuitBreakerMetrics) {
+    ClosedState(CircuitBreakerStateMachine stateMachine, @Nullable CircuitBreakerMetrics circuitBreakerMetrics) {
         super(stateMachine);
         CircuitBreakerConfig circuitBreakerConfig = stateMachine.getCircuitBreakerConfig();
         if(circuitBreakerMetrics == null){

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/InMemoryRateLimiterRegistry.java
Patch:
@@ -48,7 +48,7 @@ public class InMemoryRateLimiterRegistry implements RateLimiterRegistry {
 
     public InMemoryRateLimiterRegistry(final RateLimiterConfig defaultRateLimiterConfig) {
         this.defaultRateLimiterConfig = requireNonNull(defaultRateLimiterConfig, CONFIG_MUST_NOT_BE_NULL);
-        rateLimiters = new ConcurrentHashMap<>();
+        this.rateLimiters = new ConcurrentHashMap<>();
     }
 
     /**

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/SemaphoreBasedRateLimiter.java
Patch:
@@ -18,6 +18,7 @@
  */
 package io.github.resilience4j.ratelimiter.internal;
 
+import io.github.resilience4j.core.lang.Nullable;
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.ratelimiter.RateLimiterConfig;
 import io.github.resilience4j.ratelimiter.event.RateLimiterOnFailureEvent;
@@ -69,7 +70,7 @@ public SemaphoreBasedRateLimiter(final String name, final RateLimiterConfig rate
      * @param scheduler         executor that will refresh permissions
      */
     public SemaphoreBasedRateLimiter(String name, RateLimiterConfig rateLimiterConfig,
-                                     ScheduledExecutorService scheduler) {
+                                     @Nullable ScheduledExecutorService scheduler) {
         this.name = requireNonNull(name, NAME_MUST_NOT_BE_NULL);
         this.rateLimiterConfig = new AtomicReference<>(requireNonNull(rateLimiterConfig, CONFIG_MUST_NOT_BE_NULL));
 

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/EndpointsConfig.java
Patch:
@@ -16,6 +16,7 @@
 
 package io.github.resilience4j.ratpack;
 
+import io.github.resilience4j.core.lang.Nullable;
 import ratpack.func.Function;
 
 import static ratpack.util.Exceptions.uncheck;
@@ -81,6 +82,7 @@ public EndpointsConfig bulkheads(Function<? super EndpointConfig, ? extends Endp
 
     public static class EndpointConfig {
         private boolean enabled = true;
+        @Nullable
         private String path;
         private int eventConsumerBufferSize = 100;
 
@@ -100,6 +102,7 @@ public EndpointConfig enabled(boolean enabled) {
             return this;
         }
 
+        @Nullable
         public String getPath() {
             return path;
         }

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/bulkhead/BulkheadMethodInterceptor.java
Patch:
@@ -18,6 +18,7 @@
 import com.google.inject.Inject;
 import io.github.resilience4j.bulkhead.BulkheadFullException;
 import io.github.resilience4j.bulkhead.BulkheadRegistry;
+import io.github.resilience4j.core.lang.Nullable;
 import io.github.resilience4j.ratpack.recovery.RecoveryFunction;
 import io.github.resilience4j.reactor.bulkhead.operator.BulkheadOperator;
 import org.aopalliance.intercept.MethodInterceptor;
@@ -39,9 +40,11 @@
 public class BulkheadMethodInterceptor implements MethodInterceptor {
 
     @Inject(optional = true)
+    @Nullable
     private BulkheadRegistry registry;
 
     @SuppressWarnings("unchecked")
+    @Nullable
     @Override
     public Object invoke(MethodInvocation invocation) throws Throwable {
         Bulkhead annotation = invocation.getMethod().getAnnotation(Bulkhead.class);
@@ -50,9 +53,6 @@ public Object invoke(MethodInvocation invocation) throws Throwable {
             registry = BulkheadRegistry.ofDefaults();
         }
         io.github.resilience4j.bulkhead.Bulkhead bulkhead = registry.bulkhead(annotation.name());
-        if (bulkhead == null) {
-            return invocation.proceed();
-        }
         Class<?> returnType = invocation.getMethod().getReturnType();
         if (Promise.class.isAssignableFrom(returnType)) {
             Promise<?> result = (Promise<?>) invocation.proceed();

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/internal/AbstractTransformer.java
Patch:
@@ -16,12 +16,14 @@
 
 package io.github.resilience4j.ratpack.internal;
 
+import io.github.resilience4j.core.lang.Nullable;
 import ratpack.exec.Downstream;
 import ratpack.exec.Upstream;
 import ratpack.func.Function;
 
 public abstract class AbstractTransformer<T> implements Function<Upstream<? extends T>, Upstream<T>> {
 
+    @Nullable
     protected Function<Throwable, ? extends T> recoverer;
 
     protected void handleRecovery(Downstream<? super T> down, Throwable throwable) {

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/retry/RetryTransformer.java
Patch:
@@ -15,6 +15,7 @@
  */
 package io.github.resilience4j.ratpack.retry;
 
+import io.github.resilience4j.core.lang.Nullable;
 import io.github.resilience4j.ratpack.internal.AbstractTransformer;
 import io.github.resilience4j.retry.Retry;
 import ratpack.exec.Downstream;
@@ -47,7 +48,7 @@ public static <T> RetryTransformer<T> of(Retry retry) {
      * @param recoverer the recovery function
      * @return the transformer
      */
-    public RetryTransformer<T> recover(Function<Throwable, ? extends T> recoverer) {
+    public RetryTransformer<T> recover(@Nullable Function<Throwable, ? extends T> recoverer) {
         this.recoverer = recoverer;
         return this;
     }

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/circuitbreaker/operator/CircuitBreakerSubscriber.java
Patch:
@@ -18,6 +18,7 @@
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerOpenException;
 import io.github.resilience4j.core.StopWatch;
+import io.github.resilience4j.core.lang.Nullable;
 import io.github.resilience4j.reactor.ResilienceBaseSubscriber;
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
@@ -34,6 +35,7 @@
 class CircuitBreakerSubscriber<T> extends ResilienceBaseSubscriber<T> {
 
     private final CircuitBreaker circuitBreaker;
+    @Nullable
     private StopWatch stopWatch;
     private final boolean singleProducer;
 

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/event/RetryOnErrorEvent.java
Patch:
@@ -37,6 +37,6 @@ public String toString() {
                 getCreationTime(),
                 getName(),
                 getNumberOfRetryAttempts(),
-                getLastThrowable().toString());
+                getLastThrowable() != null ? getLastThrowable().toString() : "null");
     }
 }

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/event/RetryOnIgnoredErrorEvent.java
Patch:
@@ -36,6 +36,6 @@ public String toString() {
         return String.format("%s: Retry '%s' recorded an error which has been ignored: '%s'.",
                 getCreationTime(),
                 getName(),
-                getLastThrowable().toString());
+                getLastThrowable() != null ? getLastThrowable().toString() : "null");
     }
 }

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/event/RetryOnSuccessEvent.java
Patch:
@@ -39,6 +39,6 @@ public String toString() {
                 getCreationTime(),
                 getName(),
                 getNumberOfRetryAttempts(),
-                getLastThrowable().toString());
+                getLastThrowable() != null ? getLastThrowable().toString() : "null");
     }
 }

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/AsyncRetryImpl.java
Patch:
@@ -28,6 +28,7 @@
 
 import io.github.resilience4j.core.EventConsumer;
 import io.github.resilience4j.core.EventProcessor;
+import io.github.resilience4j.core.lang.Nullable;
 import io.github.resilience4j.retry.AsyncRetry;
 import io.github.resilience4j.retry.RetryConfig;
 import io.github.resilience4j.retry.event.RetryEvent;
@@ -47,6 +48,7 @@ public class AsyncRetryImpl<T> implements AsyncRetry {
 	private final Predicate<Throwable> exceptionPredicate;
 	private final RetryConfig config;
 	private final RetryEventProcessor eventProcessor;
+    @Nullable
 	private final Predicate<T> resultPredicate;
 
 	private LongAdder succeededAfterRetryCounter;

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerSubscriber.java
Patch:
@@ -4,6 +4,7 @@
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerOpenException;
 import io.github.resilience4j.core.StopWatch;
+import io.github.resilience4j.core.lang.Nullable;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
@@ -22,6 +23,7 @@ final class CircuitBreakerSubscriber<T> extends AtomicReference<Subscription> im
     private final CircuitBreaker circuitBreaker;
     private final Subscriber<? super T> childSubscriber;
     private final AtomicReference<Permit> permitted = new AtomicReference<>(Permit.PENDING);
+    @Nullable
     private StopWatch stopWatch;
 
     CircuitBreakerSubscriber(CircuitBreaker circuitBreaker, Subscriber<? super T> childSubscriber) {

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/circuitbreaker/operator/DisposableCircuitBreaker.java
Patch:
@@ -8,6 +8,7 @@
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerOpenException;
 import io.github.resilience4j.core.StopWatch;
+import io.github.resilience4j.core.lang.Nullable;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
 
@@ -18,6 +19,7 @@
  */
 class DisposableCircuitBreaker<T> extends AtomicReference<Disposable> implements Disposable {
     private final CircuitBreaker circuitBreaker;
+    @Nullable
     private StopWatch stopWatch;
     private final AtomicReference<Permit> permitted = new AtomicReference<>(Permit.PENDING);
 

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/ratelimiter/monitoring/health/RateLimiterHealthIndicator.java
Patch:
@@ -28,7 +28,7 @@ public class RateLimiterHealthIndicator implements HealthIndicator {
 
     public RateLimiterHealthIndicator(RateLimiter rateLimiter) {
         this.rateLimiter = rateLimiter;
-        timeoutInNanos = rateLimiter.getRateLimiterConfig().getTimeoutDuration().toNanos();
+        this.timeoutInNanos = rateLimiter.getRateLimiterConfig().getTimeoutDuration().toNanos();
     }
 
     @Override

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/retry/RetryAutoConfigurationReactorTest.java
Patch:
@@ -41,7 +41,6 @@
 @RunWith(SpringJUnit4ClassRunner.class)
 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
 		classes = TestApplication.class)
-@DirtiesContext
 public class RetryAutoConfigurationReactorTest {
 
 	@Autowired
@@ -64,6 +63,7 @@ public class RetryAutoConfigurationReactorTest {
 	 * that the Retry logic is properly handled
 	 */
 	@Test
+	@DirtiesContext
 	public void testRetryAutoConfigurationReactor() throws IOException {
 		assertThat(retryRegistry).isNotNull();
 		assertThat(retryProperties).isNotNull();

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/retry/RetryAutoConfigurationRxJavaTest.java
Patch:
@@ -41,7 +41,6 @@
 @RunWith(SpringJUnit4ClassRunner.class)
 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
 		classes = TestApplication.class)
-@DirtiesContext
 public class RetryAutoConfigurationRxJavaTest {
 
 	@Autowired
@@ -64,6 +63,7 @@ public class RetryAutoConfigurationRxJavaTest {
 	 * that the Retry logic is properly handled
 	 */
 	@Test
+	@DirtiesContext
 	public void testRetryAutoConfigurationRxJava2() throws IOException {
 		assertThat(retryRegistry).isNotNull();
 		assertThat(retryProperties).isNotNull();

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/service/test/DummyServiceImpl.java
Patch:
@@ -23,7 +23,9 @@ public void doSomething(boolean throwBackendTrouble) throws IOException {
 	@Override
 	public CompletableFuture<String> doSomethingAsync(boolean throwBackendTrouble) throws IOException {
 		if (throwBackendTrouble) {
-			throw new IOException("Test Message");
+			CompletableFuture<String> future = new CompletableFuture<>();
+			future.completeExceptionally(new IOException("Test Message"));
+			return future;
 		}
 		return CompletableFuture.supplyAsync(() -> "Test result");
 	}

File: resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/BulkheadAspect.java
Patch:
@@ -74,7 +74,8 @@ public Object bulkheadAroundAdvice(ProceedingJoinPoint proceedingJoinPoint, Bulk
 					return bulkHeadAspectExt.handle(proceedingJoinPoint, bulkhead, methodName);
 				}
 			}
-		} else if (CompletionStage.class.isAssignableFrom(returnType)) {
+		}
+		if (CompletionStage.class.isAssignableFrom(returnType)) {
 			return handleJoinPointCompletableFuture(proceedingJoinPoint, bulkhead, methodName);
 		}
 		return handleJoinPoint(proceedingJoinPoint, bulkhead, methodName);

File: resilience4j-spring/src/main/java/io/github/resilience4j/circuitbreaker/configure/CircuitBreakerAspect.java
Patch:
@@ -75,7 +75,8 @@ public Object circuitBreakerAroundAdvice(ProceedingJoinPoint proceedingJoinPoint
 					return circuitBreakerAspectExt.handle(proceedingJoinPoint, circuitBreaker, methodName);
 				}
 			}
-		} else if (CompletionStage.class.isAssignableFrom(returnType)) {
+		}
+		if (CompletionStage.class.isAssignableFrom(returnType)) {
 			return handleJoinPointCompletableFuture(proceedingJoinPoint, circuitBreaker);
 		}
 		return defaultHandling(proceedingJoinPoint, circuitBreaker, methodName);

File: resilience4j-spring/src/main/java/io/github/resilience4j/ratelimiter/configure/RateLimiterAspect.java
Patch:
@@ -82,7 +82,8 @@ public Object rateLimiterAroundAdvice(ProceedingJoinPoint proceedingJoinPoint, R
 					return rateLimiterAspectExt.handle(proceedingJoinPoint, rateLimiter, methodName);
 				}
 			}
-		} else if (CompletionStage.class.isAssignableFrom(returnType)) {
+		}
+		if (CompletionStage.class.isAssignableFrom(returnType)) {
 			return handleJoinPointCompletableFuture(proceedingJoinPoint, rateLimiter, methodName);
 		}
 		return handleJoinPoint(proceedingJoinPoint, rateLimiter, methodName);
@@ -134,7 +135,7 @@ private Object handleJoinPointCompletableFuture(ProceedingJoinPoint proceedingJo
 				logger.error("Exception being thrown during RateLimiter invocation {} ", methodName, throwable.getCause());
 				throw new CompletionException(throwable);
 			}
-		});
+		}).get();
 	}
 
 

File: resilience4j-spring/src/main/java/io/github/resilience4j/retry/configure/RetryAspect.java
Patch:
@@ -80,7 +80,8 @@ public Object retryAroundAdvice(ProceedingJoinPoint proceedingJoinPoint, Retry b
 		Class<?> returnType = method.getReturnType();
 		if (CompletionStage.class.isAssignableFrom(returnType)) {
 			return handleJoinPointCompletableFuture(proceedingJoinPoint, retry, methodName);
-		} else if (retryAspectExtList != null && !retryAspectExtList.isEmpty()) {
+		}
+		if (retryAspectExtList != null && !retryAspectExtList.isEmpty()) {
 			for (RetryAspectExt retryAspectExt : retryAspectExtList) {
 				if (retryAspectExt.canHandleReturnType(returnType)) {
 					return retryAspectExt.handle(proceedingJoinPoint, retry, methodName);

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/retry/autoconfigure/RetryMetricsAutoConfiguration.java
Patch:
@@ -17,7 +17,6 @@
 
 import org.springframework.boot.actuate.autoconfigure.MetricRepositoryAutoConfiguration;
 import org.springframework.boot.actuate.autoconfigure.MetricsDropwizardAutoConfiguration;
-import org.springframework.boot.actuate.metrics.repository.MetricRepository;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.AutoConfigureBefore;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
@@ -35,7 +34,7 @@
  */
 
 @Configuration
-@ConditionalOnClass(MetricRepository.class)
+@ConditionalOnClass(MetricRegistry.class)
 @AutoConfigureAfter(value = {RetryAutoConfiguration.class, MetricsDropwizardAutoConfiguration.class})
 @AutoConfigureBefore(MetricRepositoryAutoConfiguration.class)
 public class RetryMetricsAutoConfiguration {

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/retry/transformer/RetryTransformerTest.java
Patch:
@@ -235,7 +235,6 @@ public void retryOnResultFailAfterMaxAttemptsUsingSingle() {
         Single.fromCallable(helloWorldService::returnHelloWorld)
                 .compose(RetryTransformer.of(retry))
                 .test()
-                .assertValueCount(1)
                 .assertValue("retry")
                 .assertComplete()
                 .assertSubscribed();

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/service/test/DummyService.java
Patch:
@@ -2,9 +2,12 @@
 
 
 import java.io.IOException;
+import java.util.concurrent.CompletableFuture;
 
 public interface DummyService {
     String BACKEND = "backendA";
 
     void doSomething(boolean throwException) throws IOException;
+
+    CompletableFuture<String> doSomethingAsync(boolean throwException) throws IOException;
 }

File: resilience4j-spring/src/main/java/io/github/resilience4j/retry/configure/RetryAspect.java
Patch:
@@ -141,6 +141,7 @@ private Object handleSyncJoinPoint(ProceedingJoinPoint proceedingJoinPoint, io.g
 	 * @return the result object if any
 	 * @throws Throwable
 	 */
+	@SuppressWarnings("unchecked")
 	private Object handleAsyncJoinPoint(ProceedingJoinPoint proceedingJoinPoint, io.github.resilience4j.retry.Retry retry, String methodName) throws Throwable {
 		if (logger.isDebugEnabled()) {
 			logger.debug("async retry invocation of method {} ", methodName);

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/RetryImpl.java
Patch:
@@ -86,6 +86,7 @@ public Context context() {
 	}
 
 	@Override
+	@SuppressWarnings("unchecked")
 	public AsyncContext asyncContext() {
 		return new AsyncContextImpl();
 	}
@@ -147,7 +148,7 @@ public boolean onResult(T result) {
 			return false;
 		}
 
-		public void onError(Exception exception) throws Throwable {
+		public void onError(Exception exception) throws Exception {
 			if (exceptionPredicate.test(exception)) {
 				lastException.set(exception);
 				throwOrSleepAfterException();

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/retry/autoconfigure/RetryAutoConfiguration.java
Patch:
@@ -21,7 +21,6 @@
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.Import;
 
-import io.github.resilience4j.retry.AsyncRetryRegistry;
 import io.github.resilience4j.retry.Retry;
 import io.github.resilience4j.retry.RetryRegistry;
 import io.github.resilience4j.retry.configure.RetryConfiguration;
@@ -39,8 +38,8 @@
 public class RetryAutoConfiguration {
 
 	@Bean
-	public RetryEndpoint retryEndpoint(RetryRegistry retryRegistry, AsyncRetryRegistry asyncRetryRegistry) {
-		return new RetryEndpoint(retryRegistry, asyncRetryRegistry);
+	public RetryEndpoint retryEndpoint(RetryRegistry retryRegistry) {
+		return new RetryEndpoint(retryRegistry);
 	}
 
 }

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/retry/AsyncRetryAutoConfigurationTest.java
Patch:
@@ -47,7 +47,7 @@
 public class AsyncRetryAutoConfigurationTest {
 
 	@Autowired
-	AsyncRetryRegistry asyncRetryRegistry;
+	RetryRegistry retryRegistry;
 
 	@Autowired
 	RetryProperties retryProperties;
@@ -65,7 +65,7 @@ public class AsyncRetryAutoConfigurationTest {
 	 */
 	@Test
 	public void testRetryAutoConfigurationAsync() throws Throwable {
-		assertThat(asyncRetryRegistry).isNotNull();
+		assertThat(retryRegistry).isNotNull();
 
 		try {
 			final CompletionStage<String> stringCompletionStage = retryDummyService.doSomethingAsync(true);
@@ -79,7 +79,7 @@ public void testRetryAutoConfigurationAsync() throws Throwable {
 		// The invocation is recorded by the CircuitBreaker as a success.
 		String resultSuccess = awaitResult(retryDummyService.doSomethingAsync(false), 5);
 		assertThat(resultSuccess).isNotEmpty();
-		AsyncRetry retry = asyncRetryRegistry.retry(RETRY_BACKEND_B);
+		Retry retry = retryRegistry.retry(RETRY_BACKEND_B);
 		assertThat(retry).isNotNull();
 
 		// expect retry is configured as defined in application.yml

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/service/test/RetryDummyService.java
Patch:
@@ -5,8 +5,8 @@
 import java.util.concurrent.CompletionStage;
 
 public interface RetryDummyService {
-	String BACKEND_A = "retryBackendA";
-	String BACKEND_B = "retryBackendB";
+	String RETRY_BACKEND_A = "retryBackendA";
+	String RETRY_BACKEND_B = "retryBackendB";
 
 	void doSomething(boolean throwException) throws IOException;
 

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/service/test/RetryDummyService.java
Patch:
@@ -5,7 +5,8 @@
 import java.util.concurrent.CompletionStage;
 
 public interface RetryDummyService {
-	String BACKEND = "retryBackendA";
+	String RETRY_BACKEND_A = "retryBackendA";
+	String RETRY_BACKEND_B = "retryBackendB";
 
 	void doSomething(boolean throwException) throws IOException;
 

File: resilience4j-prometheus/src/main/java/io/github/resilience4j/prometheus/BulkheadExports.java
Patch:
@@ -34,7 +34,10 @@
 /**
  * An adapter from builtin {@link Bulkhead.Metrics} to prometheus
  * {@link io.prometheus.client.CollectorRegistry}.
+ *
+ * @deprecated use {@link io.github.resilience4j.prometheus.collectors.BulkheadMetricsCollector} instead
  */
+@Deprecated
 public class BulkheadExports extends Collector {
     private static final String DEFAULT_NAME = "resilience4j_bulkhead";
 

File: resilience4j-prometheus/src/main/java/io/github/resilience4j/prometheus/CircuitBreakerExports.java
Patch:
@@ -37,7 +37,10 @@
  * {@link io.prometheus.client.CollectorRegistry}.
  *
  * Also exports {@link CircuitBreaker} state as a labeled metric
+ *
+ * @deprecated use {@link io.github.resilience4j.prometheus.collectors.CircuitBreakerMetricsCollector} instead.
  */
+@Deprecated
 public class CircuitBreakerExports extends Collector {
 
     private static final String DEFAULT_NAME = "resilience4j_circuitbreaker";

File: resilience4j-prometheus/src/main/java/io/github/resilience4j/prometheus/RateLimiterExports.java
Patch:
@@ -34,7 +34,10 @@
 /**
  * An adapter from builtin {@link RateLimiter.Metrics} to prometheus
  * {@link io.prometheus.client.CollectorRegistry}.
+ *
+ * @deprecated use {@link io.github.resilience4j.prometheus.collectors.RateLimiterMetricsCollector} instead.
  */
+@Deprecated
 public class RateLimiterExports extends Collector {
     private static final String DEFAULT_NAME = "resilience4j_ratelimiter";
 

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationTest.java
Patch:
@@ -18,6 +18,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.beans.factory.annotation.Qualifier;
 import org.springframework.boot.test.context.SpringBootTest;
 import org.springframework.boot.test.web.client.TestRestTemplate;
 import org.springframework.http.ResponseEntity;
@@ -49,6 +50,7 @@ public class CircuitBreakerAutoConfigurationTest {
     CircuitBreakerAspect circuitBreakerAspect;
 
     @Autowired
+    @Qualifier("circuitBreakerDummyService")
     DummyService dummyService;
 
     @Autowired

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterAutoConfigurationTest.java
Patch:
@@ -26,6 +26,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.beans.factory.annotation.Qualifier;
 import org.springframework.boot.test.context.SpringBootTest;
 import org.springframework.boot.test.web.client.TestRestTemplate;
 import org.springframework.http.ResponseEntity;
@@ -54,6 +55,7 @@ public class RateLimiterAutoConfigurationTest {
     private RateLimiterAspect rateLimiterAspect;
 
     @Autowired
+    @Qualifier("rateLimiterDummyService")
     private DummyService dummyService;
 
     @Autowired

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/service/test/RetryDummyService.java
Patch:
@@ -5,7 +5,8 @@
 import java.util.concurrent.CompletionStage;
 
 public interface RetryDummyService {
-	String BACKEND = "retryBackendA";
+	String BACKEND_A = "retryBackendA";
+	String BACKEND_B = "retryBackendB";
 
 	void doSomething(boolean throwException) throws IOException;
 

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/service/test/RetryDummyServiceImpl.java
Patch:
@@ -13,15 +13,15 @@
 @Component
 public class RetryDummyServiceImpl implements RetryDummyService {
 
-	@Retry(name = RetryDummyService.BACKEND)
+	@Retry(name = RetryDummyService.BACKEND_A)
 	@Override
 	public void doSomething(boolean throwBackendTrouble) throws IOException {
 		if (throwBackendTrouble) {
 			throw new IOException("Test Message");
 		}
 	}
 
-	@AsyncRetry(name = RetryDummyService.BACKEND)
+	@AsyncRetry(name = RetryDummyService.BACKEND_B)
 	@Override
 	public CompletionStage<String> doSomethingAsync(boolean throwException) throws IOException {
 		if (throwException) {

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/BulkheadSubscriber.java
Patch:
@@ -1,5 +1,6 @@
 package io.github.resilience4j.bulkhead.operator;
 
+import static io.reactivex.internal.subscriptions.SubscriptionHelper.CANCELLED;
 import static java.util.Objects.requireNonNull;
 
 import java.util.concurrent.atomic.AtomicReference;
@@ -86,7 +87,7 @@ private boolean acquireCallPermit() {
     }
 
     private boolean isInvocationPermitted() {
-        return !SubscriptionHelper.isCancelled(get()) && wasCallPermitted();
+        return !(get() == CANCELLED) && wasCallPermitted();
     }
 
     private boolean wasCallPermitted() {

File: resilience4j-retrofit/src/main/java/io/github/resilience4j/retrofit/internal/DecoratedCall.java
Patch:
@@ -66,7 +66,7 @@ public boolean isCanceled() {
 
     @Override
     public Call<T> clone() {
-        return call.clone();
+        return new DecoratedCall<>(call.clone());
     }
 
     @Override

File: resilience4j-spring/src/main/java/io/github/resilience4j/retry/configure/RetryConfigurationProperties.java
Patch:
@@ -38,7 +38,7 @@ public class RetryConfigurationProperties {
 		By adjusting RateLimiterProperties.rateLimiterAspectOrder and CircuitBreakerProperties.circuitBreakerAspectOrder
 		you explicitly define aspects CircuitBreaker and RateLimiter execution sequence.
 	*/
-	private int retryAspectOrder = Integer.MAX_VALUE - 1;
+	private int retryAspectOrder = Integer.MAX_VALUE - 2;
 
 	/**
 	 * @param backend backend name

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationTest.java
Patch:
@@ -143,9 +143,9 @@ public void testCircuitBreakerAutoConfigurationReactive() throws IOException {
 		assertThat(circuitBreaker.getMetrics().getNumberOfFailedCalls()).isEqualTo(1);
 
 		// expect circuitbreaker is configured as defined in application.yml
-		assertThat(circuitBreaker.getCircuitBreakerConfig().getRingBufferSizeInClosedState()).isEqualTo(6);
-		assertThat(circuitBreaker.getCircuitBreakerConfig().getRingBufferSizeInHalfOpenState()).isEqualTo(2);
-		assertThat(circuitBreaker.getCircuitBreakerConfig().getFailureRateThreshold()).isEqualTo(70f);
+		assertThat(circuitBreaker.getCircuitBreakerConfig().getRingBufferSizeInClosedState()).isEqualTo(10);
+		assertThat(circuitBreaker.getCircuitBreakerConfig().getRingBufferSizeInHalfOpenState()).isEqualTo(5);
+		assertThat(circuitBreaker.getCircuitBreakerConfig().getFailureRateThreshold()).isEqualTo(50f);
 		assertThat(circuitBreaker.getCircuitBreakerConfig().getWaitDurationInOpenState()).isEqualByComparingTo(Duration.ofSeconds(5L));
 
 		// expect circuitbreakers actuator endpoint contains both circuitbreakers

File: resilience4j-spring/src/main/java/io/github/resilience4j/circuitbreaker/configure/CircuitBreakerConfigurationProperties.java
Patch:
@@ -132,13 +132,10 @@ public static class BackendProperties {
         @NotNull
         private Boolean registerHealthIndicator = true;
 
-        @NotNull
         private Class<Predicate<Throwable>> recordFailurePredicate;
 
-        @NotNull
         private Class<? extends Throwable>[] recordExceptions;
 
-        @NotNull
         private Class<? extends Throwable>[] ignoreExceptions;
         /**
          * Sets the wait duration in seconds the CircuitBreaker should stay open, before it switches to half closed.

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/utils/MetricNames.java
Patch:
@@ -3,4 +3,5 @@
 public class MetricNames {
     public static final String DEFAULT_PREFIX = "resilience4j.bulkhead";
     public static final String AVAILABLE_CONCURRENT_CALLS = "available_concurrent_calls";
+    public static final String MAX_ALLOWED_CONCURRENT_CALLS = "max_allowed_concurrent_calls";
 }

File: resilience4j-metrics/src/main/java/io/github/resilience4j/metrics/BulkheadMetrics.java
Patch:
@@ -28,6 +28,7 @@
 import static com.codahale.metrics.MetricRegistry.name;
 import static io.github.resilience4j.bulkhead.utils.MetricNames.AVAILABLE_CONCURRENT_CALLS;
 import static io.github.resilience4j.bulkhead.utils.MetricNames.DEFAULT_PREFIX;
+import static io.github.resilience4j.bulkhead.utils.MetricNames.MAX_ALLOWED_CONCURRENT_CALLS;
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -48,6 +49,8 @@ private BulkheadMetrics(String prefix, Iterable<Bulkhead> bulkheads) {
             //number of available concurrent calls as an integer
                     metricRegistry.register(name(prefix, name, AVAILABLE_CONCURRENT_CALLS),
                             (Gauge<Integer>) () -> bulkhead.getMetrics().getAvailableConcurrentCalls());
+                    metricRegistry.register(name(prefix, name, MAX_ALLOWED_CONCURRENT_CALLS),
+                            (Gauge<Integer>) () -> bulkhead.getMetrics().getMaxAllowedConcurrentCalls());
                 }
         );
     }

File: resilience4j-micrometer/src/main/java/io/github/resilience4j/micrometer/BulkheadMetrics.java
Patch:
@@ -23,6 +23,7 @@
 
 import static io.github.resilience4j.bulkhead.utils.MetricNames.AVAILABLE_CONCURRENT_CALLS;
 import static io.github.resilience4j.bulkhead.utils.MetricNames.DEFAULT_PREFIX;
+import static io.github.resilience4j.bulkhead.utils.MetricNames.MAX_ALLOWED_CONCURRENT_CALLS;
 import static io.github.resilience4j.micrometer.MetricUtils.getName;
 import static java.util.Objects.requireNonNull;
 
@@ -56,6 +57,8 @@ public void bindTo(MeterRegistry registry) {
             final String name = bulkhead.getName();
             Gauge.builder(getName(prefix, name, AVAILABLE_CONCURRENT_CALLS), bulkhead, (cb) -> cb.getMetrics().getAvailableConcurrentCalls())
                     .register(registry);
+            Gauge.builder(getName(prefix, name, MAX_ALLOWED_CONCURRENT_CALLS), bulkhead, (bh) -> bh.getMetrics().getMaxAllowedConcurrentCalls())
+                    .register(registry);
         }
     }
 }

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterTest.java
Patch:
@@ -22,7 +22,7 @@
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.hamcrest.CoreMatchers.equalTo;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/SemaphoreBasedRateLimiterImplTest.java
Patch:
@@ -40,7 +40,7 @@
 import static java.time.Duration.ZERO;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.hamcrest.CoreMatchers.equalTo;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.*;
 
 

File: resilience4j-retrofit/src/test/java/io/github/resilience4j/retrofit/internal/DecoratedCallTest.java
Patch:
@@ -8,7 +8,7 @@
 
 import java.io.IOException;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 
 @RunWith(JUnit4.class)

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/BulkheadCompletableObserverTest.java
Patch:
@@ -1,7 +1,7 @@
 package io.github.resilience4j.bulkhead.operator;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/BulkheadMaybeObserverTest.java
Patch:
@@ -1,7 +1,7 @@
 package io.github.resilience4j.bulkhead.operator;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/BulkheadObserverTest.java
Patch:
@@ -1,7 +1,7 @@
 package io.github.resilience4j.bulkhead.operator;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/BulkheadSingleObserverTest.java
Patch:
@@ -1,7 +1,7 @@
 package io.github.resilience4j.bulkhead.operator;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/BulkheadSubscriberTest.java
Patch:
@@ -1,7 +1,7 @@
 package io.github.resilience4j.bulkhead.operator;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerCompletableObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerMaybeObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerSingleObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerSubscriberTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/RateLimiterCompletableObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.ratelimiter.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/RateLimiterMaybeObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.ratelimiter.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/RateLimiterObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.ratelimiter.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/RateLimiterSingleObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.ratelimiter.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/RateLimiterSubscriberTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.ratelimiter.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterTest.java
Patch:
@@ -22,7 +22,7 @@
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.hamcrest.CoreMatchers.equalTo;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/SemaphoreBasedRateLimiterImplTest.java
Patch:
@@ -40,7 +40,7 @@
 import static java.time.Duration.ZERO;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.hamcrest.CoreMatchers.equalTo;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.*;
 
 

File: resilience4j-retrofit/src/test/java/io/github/resilience4j/retrofit/internal/DecoratedCallTest.java
Patch:
@@ -8,7 +8,7 @@
 
 import java.io.IOException;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 
 @RunWith(JUnit4.class)

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/BulkheadCompletableObserverTest.java
Patch:
@@ -1,7 +1,7 @@
 package io.github.resilience4j.bulkhead.operator;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/BulkheadMaybeObserverTest.java
Patch:
@@ -1,7 +1,7 @@
 package io.github.resilience4j.bulkhead.operator;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/BulkheadObserverTest.java
Patch:
@@ -1,7 +1,7 @@
 package io.github.resilience4j.bulkhead.operator;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/BulkheadSingleObserverTest.java
Patch:
@@ -1,7 +1,7 @@
 package io.github.resilience4j.bulkhead.operator;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/BulkheadSubscriberTest.java
Patch:
@@ -1,7 +1,7 @@
 package io.github.resilience4j.bulkhead.operator;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerCompletableObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerMaybeObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerSingleObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerSubscriberTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.circuitbreaker.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/RateLimiterCompletableObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.ratelimiter.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/RateLimiterMaybeObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.ratelimiter.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/RateLimiterObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.ratelimiter.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/RateLimiterSingleObserverTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.ratelimiter.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/ratelimiter/operator/RateLimiterSubscriberTest.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.ratelimiter.operator;
 
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/adapter/Permit.java
Patch:
@@ -4,5 +4,5 @@
  * Represents the possible states of a permit.
  */
 public enum Permit {
-    PENDING, ACQUIRED, REJECTED
+    PENDING, ACQUIRED, REJECTED, RELEASED
 }

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/DisposableBulkhead.java
Patch:
@@ -141,7 +141,7 @@ private boolean wasCallPermitted() {
     }
 
     private void releaseBulkhead() {
-        if (wasCallPermitted()) {
+        if (permitted.compareAndSet(Permit.ACQUIRED, Permit.RELEASED)) {
             bulkhead.onComplete();
         }
     }

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/adapter/Permit.java
Patch:
@@ -4,5 +4,5 @@
  * Represents the possible states of a permit.
  */
 public enum Permit {
-    PENDING, ACQUIRED, REJECTED
+    PENDING, ACQUIRED, REJECTED, RELEASED
 }

File: resilience4j-rxjava2/src/main/java/io/github/resilience4j/bulkhead/operator/DisposableBulkhead.java
Patch:
@@ -141,7 +141,7 @@ private boolean wasCallPermitted() {
     }
 
     private void releaseBulkhead() {
-        if (wasCallPermitted()) {
+        if (permitted.compareAndSet(Permit.ACQUIRED, Permit.RELEASED)) {
             bulkhead.onComplete();
         }
     }

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/circuitbreaker/operator/FluxCircuitBreaker.java
Patch:
@@ -31,7 +31,7 @@ public FluxCircuitBreaker(Flux<? extends T> source, CircuitBreaker circuitBreake
 
     @Override
     public void subscribe(CoreSubscriber<? super T> actual) {
-        source.subscribe(new CircuitBreakerSubscriber<>(circuitBreaker, actual));
+        source.subscribe(new CircuitBreakerSubscriber<>(circuitBreaker, actual, false));
     }
 
 }

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/circuitbreaker/operator/MonoCircuitBreaker.java
Patch:
@@ -30,6 +30,6 @@ public MonoCircuitBreaker(Mono<? extends T> source, CircuitBreaker circuitBreake
 
     @Override
     public void subscribe(CoreSubscriber<? super T> actual) {
-        source.subscribe(new CircuitBreakerSubscriber<>(circuitBreaker, actual));
+        source.subscribe(new CircuitBreakerSubscriber<>(circuitBreaker, actual, true));
     }
 }

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/circuitbreaker/operator/CircuitBreakerSubscriberWhiteboxVerification.java
Patch:
@@ -31,7 +31,7 @@ public CircuitBreakerSubscriberWhiteboxVerification() {
 
     @Override
     public Subscriber<Integer> createSubscriber(WhiteboxSubscriberProbe<Integer> probe) {
-        return new CircuitBreakerSubscriber<Integer>(CircuitBreaker.ofDefaults("verification"), MonoProcessor.create()) {
+        return new CircuitBreakerSubscriber<Integer>(CircuitBreaker.ofDefaults("verification"), MonoProcessor.create(), false) {
 
             @Override
             protected void hookOnSubscribe(Subscription subscription) {

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/circuitbreaker/operator/FluxCircuitBreaker.java
Patch:
@@ -31,7 +31,7 @@ public FluxCircuitBreaker(Flux<? extends T> source, CircuitBreaker circuitBreake
 
     @Override
     public void subscribe(CoreSubscriber<? super T> actual) {
-        source.subscribe(new CircuitBreakerSubscriber<>(circuitBreaker, actual));
+        source.subscribe(new CircuitBreakerSubscriber<>(circuitBreaker, actual, false));
     }
 
 }

File: resilience4j-reactor/src/main/java/io/github/resilience4j/reactor/circuitbreaker/operator/MonoCircuitBreaker.java
Patch:
@@ -30,6 +30,6 @@ public MonoCircuitBreaker(Mono<? extends T> source, CircuitBreaker circuitBreake
 
     @Override
     public void subscribe(CoreSubscriber<? super T> actual) {
-        source.subscribe(new CircuitBreakerSubscriber<>(circuitBreaker, actual));
+        source.subscribe(new CircuitBreakerSubscriber<>(circuitBreaker, actual, true));
     }
 }

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/circuitbreaker/operator/CircuitBreakerSubscriberWhiteboxVerification.java
Patch:
@@ -31,7 +31,7 @@ public CircuitBreakerSubscriberWhiteboxVerification() {
 
     @Override
     public Subscriber<Integer> createSubscriber(WhiteboxSubscriberProbe<Integer> probe) {
-        return new CircuitBreakerSubscriber<Integer>(CircuitBreaker.ofDefaults("verification"), MonoProcessor.create()) {
+        return new CircuitBreakerSubscriber<Integer>(CircuitBreaker.ofDefaults("verification"), MonoProcessor.create(), false) {
 
             @Override
             protected void hookOnSubscribe(Subscription subscription) {

File: resilience4j-retrofit/src/main/java/io/github/resilience4j/retrofit/RetrofitCircuitBreaker.java
Patch:
@@ -58,6 +58,7 @@ public void enqueue(final Callback<T> callback) {
                     CircuitBreakerUtils.isCallPermitted(circuitBreaker);
                 } catch (CircuitBreakerOpenException cb) {
                     callback.onFailure(call, cb);
+                    return;
                 }
 
                 final StopWatch stopWatch = StopWatch.start(circuitBreaker.getName());

File: resilience4j-retrofit/src/test/java/io/github/resilience4j/retrofit/RetrofitCircuitBreakerTest.java
Patch:
@@ -224,7 +224,7 @@ public void shouldNotCallServiceOnEnqueueWhenOpen() throws Throwable {
                         .withStatus(200)
                         .withHeader("Content-Type", "text/plain")
                         .withBody("hello world")));
-;
+
         circuitBreaker.transitionToOpenState();
 
         try {

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerMetricsAutoConfiguration.java
Patch:
@@ -18,6 +18,7 @@
 import org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 
@@ -35,6 +36,7 @@
 public class CircuitBreakerMetricsAutoConfiguration {
 
     @Bean
+    @ConditionalOnProperty(value = "resilience4j.circuitbreaker.metrics.enabled", matchIfMissing = true)
     public CircuitBreakerMetrics registerCircuitBreakerMetrics(CircuitBreakerRegistry circuitBreakerRegistry, MeterRegistry meterRegistry){
         CircuitBreakerMetrics circuitBreakerMetrics = CircuitBreakerMetrics.ofCircuitBreakerRegistry(circuitBreakerRegistry);
         circuitBreakerMetrics.bindTo(meterRegistry);

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/annotation/CircuitBreaker.java
Patch:
@@ -31,6 +31,8 @@
 
     /**
      * Name of the backend monitor.
+     *
+     * @return the name of the circuit breaker
      */
     String backend();
 

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/ratelimiter/annotation/RateLimiter.java
Patch:
@@ -34,6 +34,8 @@
 public @interface RateLimiter {
     /**
      * Name of the rate limiter
+     *
+     * @return the name of the rate limiter
      */
     String name();
 }

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/ratelimiter/monitoring/endpoint/RateLimiterEventsEndpoint.java
Patch:
@@ -46,9 +46,9 @@ public RateLimiterEventsEndpointResponse getAllRateLimiterEvents() {
     }
 
     @ReadOperation
-    public RateLimiterEventsEndpointResponse getEventsFilteredByRateLimiterName(@Selector String rateLimiterName) {
-        List<RateLimiterEventDTO> eventsList = eventsConsumerRegistry.getEventConsumer(rateLimiterName).getBufferedEvents()
-            .filter(event -> event.getRateLimiterName().equals(rateLimiterName))
+    public RateLimiterEventsEndpointResponse getEventsFilteredByRateLimiterName(@Selector String name) {
+        List<RateLimiterEventDTO> eventsList = eventsConsumerRegistry.getEventConsumer(name).getBufferedEvents()
+            .filter(event -> event.getRateLimiterName().equals(name))
             .map(RateLimiterEventDTO::createRateLimiterEventDTO).toJavaList();
         return new RateLimiterEventsEndpointResponse(eventsList);
     }

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerAutoConfiguration.java
Patch:
@@ -73,9 +73,8 @@ public CircuitBreakerEndpoint circuitBreakerEndpoint(CircuitBreakerRegistry circ
 
     @Bean
     @ConditionalOnEnabledEndpoint
-    public CircuitBreakerEventsEndpoint circuitBreakerEventsEndpoint(EventConsumerRegistry<CircuitBreakerEvent> eventConsumerRegistry,
-                                                               CircuitBreakerRegistry circuitBreakerRegistry) {
-        return new CircuitBreakerEventsEndpoint(eventConsumerRegistry, circuitBreakerRegistry);
+    public CircuitBreakerEventsEndpoint circuitBreakerEventsEndpoint(EventConsumerRegistry<CircuitBreakerEvent> eventConsumerRegistry) {
+        return new CircuitBreakerEventsEndpoint(eventConsumerRegistry);
     }
 
     @Bean

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerEndpoint.java
Patch:
@@ -18,14 +18,14 @@
 
 import java.util.List;
 
+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;
 import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;
-import org.springframework.boot.actuate.endpoint.web.annotation.WebEndpoint;
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
 
 
-@WebEndpoint(id = "circuitbreaker")
+@Endpoint(id = "circuitbreakers")
 public class CircuitBreakerEndpoint {
 
     private final CircuitBreakerRegistry circuitBreakerRegistry;

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterAutoConfiguration.java
Patch:
@@ -76,9 +76,8 @@ public RateLimiterEndpoint rateLimiterEndpoint(RateLimiterRegistry rateLimiterRe
 
     @Bean
     @ConditionalOnEnabledEndpoint
-    public RateLimiterEventsEndpoint rateLimiterEventsEndpoint(EventConsumerRegistry<RateLimiterEvent> eventConsumerRegistry,
-                                                            RateLimiterRegistry rateLimiterRegistry) {
-        return new RateLimiterEventsEndpoint(eventConsumerRegistry, rateLimiterRegistry);
+    public RateLimiterEventsEndpoint rateLimiterEventsEndpoint(EventConsumerRegistry<RateLimiterEvent> eventConsumerRegistry) {
+        return new RateLimiterEventsEndpoint(eventConsumerRegistry);
     }
 
     @Bean

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/ratelimiter/monitoring/endpoint/RateLimiterEndpoint.java
Patch:
@@ -17,14 +17,14 @@
 
 import java.util.List;
 
+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;
 import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;
-import org.springframework.boot.actuate.endpoint.web.annotation.WebEndpoint;
 
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
 import io.github.resilience4j.ratelimiter.monitoring.model.RateLimiterEndpointResponse;
 
-@WebEndpoint(id = "ratelimiter")
+@Endpoint(id = "ratelimiters")
 public class RateLimiterEndpoint {
 
     private final RateLimiterRegistry rateLimiterRegistry;

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterAutoConfigurationTest.java
Patch:
@@ -93,7 +93,7 @@ public void testRateLimiterAutoConfiguration() throws IOException {
         // Test Actuator endpoints
 
         ResponseEntity<RateLimiterEndpointResponse> rateLimiterList = restTemplate
-            .getForEntity("/actuator/ratelimiter", RateLimiterEndpointResponse.class);
+            .getForEntity("/actuator/ratelimiters", RateLimiterEndpointResponse.class);
 
         assertThat(rateLimiterList.getBody().getRateLimitersNames()).hasSize(2).containsExactly("backendA", "backendB");
 

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationTest.java
Patch:
@@ -84,11 +84,11 @@ public void testCircuitBreakerAutoConfiguration() throws IOException {
 
         // Test Actuator endpoints
 
-        ResponseEntity<CircuitBreakerEndpointResponse> circuitBreakerList = restTemplate.getForEntity("/circuitbreaker", CircuitBreakerEndpointResponse.class);
+        ResponseEntity<CircuitBreakerEndpointResponse> circuitBreakerList = restTemplate.getForEntity("/actuator/circuitbreaker", CircuitBreakerEndpointResponse.class);
         assertThat(circuitBreakerList.getBody().getCircuitBreakers()).hasSize(2).containsExactly("backendA", "backendB");
 
 
-        ResponseEntity<CircuitBreakerEventsEndpointResponse> circuitBreakerEventList = restTemplate.getForEntity("/circuitbreaker/events", CircuitBreakerEventsEndpointResponse.class);
+        ResponseEntity<CircuitBreakerEventsEndpointResponse> circuitBreakerEventList = restTemplate.getForEntity("/actuator/circuitbreaker-events", CircuitBreakerEventsEndpointResponse.class);
         assertThat(circuitBreakerEventList.getBody().getCircuitBreakerEvents()).hasSize(2);
 
         assertThat(circuitBreakerAspect.getOrder()).isEqualTo(400);

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterAutoConfigurationTest.java
Patch:
@@ -93,7 +93,7 @@ public void testRateLimiterAutoConfiguration() throws IOException {
         // Test Actuator endpoints
 
         ResponseEntity<RateLimiterEndpointResponse> rateLimiterList = restTemplate
-            .getForEntity("/ratelimiter", RateLimiterEndpointResponse.class);
+            .getForEntity("/actuator/ratelimiter", RateLimiterEndpointResponse.class);
 
         assertThat(rateLimiterList.getBody().getRateLimitersNames()).hasSize(2).containsExactly("backendA", "backendB");
 
@@ -106,7 +106,7 @@ public void testRateLimiterAutoConfiguration() throws IOException {
         }
 
         ResponseEntity<RateLimiterEventsEndpointResponse> rateLimiterEventList = restTemplate
-            .getForEntity("/ratelimiter/events", RateLimiterEventsEndpointResponse.class);
+            .getForEntity("/actuator/ratelimiter-events", RateLimiterEventsEndpointResponse.class);
 
         List<RateLimiterEventDTO> eventsList = rateLimiterEventList.getBody().getEventsList();
         assertThat(eventsList).isNotEmpty();

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerEventsEndpoint.java
Patch:
@@ -23,11 +23,11 @@
 
 import org.springframework.boot.actuate.endpoint.web.annotation.WebEndpoint;
 import org.springframework.http.MediaType;
-import org.springframework.stereotype.Controller;
 import org.springframework.web.bind.annotation.PathVariable;
 import org.springframework.web.bind.annotation.RequestMapping;
 import org.springframework.web.bind.annotation.RequestMethod;
 import org.springframework.web.bind.annotation.ResponseBody;
+import org.springframework.web.bind.annotation.RestController;
 import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
@@ -39,7 +39,7 @@
 import reactor.core.publisher.Flux;
 
 
-@Controller
+@RestController
 @WebEndpoint(id = "circuitbreaker")
 @RequestMapping(value = "circuitbreaker", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)
 public class CircuitBreakerEventsEndpoint {

File: resilience4j-spring-boot2/src/main/java/io/github/resilience4j/ratelimiter/annotation/RateLimiter.java
Patch:
@@ -34,7 +34,6 @@
 public @interface RateLimiter {
     /**
      * Name of the rate limiter
-     * @return
      */
     String name();
 }

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationTest.java
Patch:
@@ -84,11 +84,11 @@ public void testCircuitBreakerAutoConfiguration() throws IOException {
 
         // Test Actuator endpoints
 
-        ResponseEntity<CircuitBreakerEndpointResponse> circuitBreakerList = restTemplate.getForEntity("/actuator/circuitbreaker", CircuitBreakerEndpointResponse.class);
+        ResponseEntity<CircuitBreakerEndpointResponse> circuitBreakerList = restTemplate.getForEntity("/circuitbreaker", CircuitBreakerEndpointResponse.class);
         assertThat(circuitBreakerList.getBody().getCircuitBreakers()).hasSize(2).containsExactly("backendA", "backendB");
 
 
-        ResponseEntity<CircuitBreakerEventsEndpointResponse> circuitBreakerEventList = restTemplate.getForEntity("/actuator/circuitbreaker/events", CircuitBreakerEventsEndpointResponse.class);
+        ResponseEntity<CircuitBreakerEventsEndpointResponse> circuitBreakerEventList = restTemplate.getForEntity("/circuitbreaker/events", CircuitBreakerEventsEndpointResponse.class);
         assertThat(circuitBreakerEventList.getBody().getCircuitBreakerEvents()).hasSize(2);
 
         assertThat(circuitBreakerAspect.getOrder()).isEqualTo(400);

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterAutoConfigurationTest.java
Patch:
@@ -93,7 +93,7 @@ public void testRateLimiterAutoConfiguration() throws IOException {
         // Test Actuator endpoints
 
         ResponseEntity<RateLimiterEndpointResponse> rateLimiterList = restTemplate
-            .getForEntity("/actuator/ratelimiter", RateLimiterEndpointResponse.class);
+            .getForEntity("/ratelimiter", RateLimiterEndpointResponse.class);
 
         assertThat(rateLimiterList.getBody().getRateLimitersNames()).hasSize(2).containsExactly("backendA", "backendB");
 
@@ -106,7 +106,7 @@ public void testRateLimiterAutoConfiguration() throws IOException {
         }
 
         ResponseEntity<RateLimiterEventsEndpointResponse> rateLimiterEventList = restTemplate
-            .getForEntity("/actuator/ratelimiter/events", RateLimiterEventsEndpointResponse.class);
+            .getForEntity("/ratelimiter/events", RateLimiterEventsEndpointResponse.class);
 
         List<RateLimiterEventDTO> eventsList = rateLimiterEventList.getBody().getEventsList();
         assertThat(eventsList).isNotEmpty();

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationTest.java
Patch:
@@ -84,11 +84,11 @@ public void testCircuitBreakerAutoConfiguration() throws IOException {
 
         // Test Actuator endpoints
 
-        ResponseEntity<CircuitBreakerEndpointResponse> circuitBreakerList = restTemplate.getForEntity("/circuitbreaker", CircuitBreakerEndpointResponse.class);
+        ResponseEntity<CircuitBreakerEndpointResponse> circuitBreakerList = restTemplate.getForEntity("/actuator/circuitbreaker", CircuitBreakerEndpointResponse.class);
         assertThat(circuitBreakerList.getBody().getCircuitBreakers()).hasSize(2).containsExactly("backendA", "backendB");
 
 
-        ResponseEntity<CircuitBreakerEventsEndpointResponse> circuitBreakerEventList = restTemplate.getForEntity("/circuitbreaker/events", CircuitBreakerEventsEndpointResponse.class);
+        ResponseEntity<CircuitBreakerEventsEndpointResponse> circuitBreakerEventList = restTemplate.getForEntity("/actuator/circuitbreaker/events", CircuitBreakerEventsEndpointResponse.class);
         assertThat(circuitBreakerEventList.getBody().getCircuitBreakerEvents()).hasSize(2);
 
         assertThat(circuitBreakerAspect.getOrder()).isEqualTo(400);

File: resilience4j-spring-boot2/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterAutoConfigurationTest.java
Patch:
@@ -93,7 +93,7 @@ public void testRateLimiterAutoConfiguration() throws IOException {
         // Test Actuator endpoints
 
         ResponseEntity<RateLimiterEndpointResponse> rateLimiterList = restTemplate
-            .getForEntity("/ratelimiter", RateLimiterEndpointResponse.class);
+            .getForEntity("/actuator/ratelimiter", RateLimiterEndpointResponse.class);
 
         assertThat(rateLimiterList.getBody().getRateLimitersNames()).hasSize(2).containsExactly("backendA", "backendB");
 
@@ -106,7 +106,7 @@ public void testRateLimiterAutoConfiguration() throws IOException {
         }
 
         ResponseEntity<RateLimiterEventsEndpointResponse> rateLimiterEventList = restTemplate
-            .getForEntity("/ratelimiter/events", RateLimiterEventsEndpointResponse.class);
+            .getForEntity("/actuator/ratelimiter/events", RateLimiterEventsEndpointResponse.class);
 
         List<RateLimiterEventDTO> eventsList = rateLimiterEventList.getBody().getEventsList();
         assertThat(eventsList).isNotEmpty();

File: resilience4j-reactor/src/test/java/io/github/resilience4j/reactor/ratelimiter/operator/FluxRateLimiterTest.java
Patch:
@@ -18,6 +18,7 @@
 import io.github.resilience4j.ratelimiter.RequestNotPermitted;
 import org.junit.Test;
 import reactor.core.publisher.Flux;
+import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 
 import java.io.IOException;
@@ -55,7 +56,7 @@ public void shouldEmitErrorWithBulkheadFullException() {
 
         StepVerifier.create(
                 Flux.just("Event")
-                        .transform(RateLimiterOperator.of(rateLimiter)))
+                        .transform(RateLimiterOperator.of(rateLimiter, Schedulers.immediate())))
                 .expectSubscription()
                 .expectError(RequestNotPermitted.class)
                 .verify(Duration.ofSeconds(1));

File: resilience4j-feign/src/main/java/io/github/resilience4j/feign/FeignDecorator.java
Patch:
@@ -36,6 +36,7 @@ public interface FeignDecorator {
      *        implementing class.
      * @param method the method of the feign interface that is invoked.
      * @param methodHandler the feign methodHandler that executes the http request.
+     * @return the decorated invocationCall
      */
     CheckedFunction1<Object[], Object> decorate(CheckedFunction1<Object[], Object> invocationCall, Method method, MethodHandler methodHandler,
             Target<?> target);

File: resilience4j-feign/src/main/java/io/github/resilience4j/feign/FeignDecorators.java
Patch:
@@ -80,7 +80,7 @@ public static final class Builder {
         /**
          * Adds a {@link CircuitBreaker} to the decorator chain.
          *
-         * @param rateLimiter a fully configured {@link CircuitBreaker}.
+         * @param circuitBreaker a fully configured {@link CircuitBreaker}.
          * @return the builder
          */
         public Builder withCircuitBreaker(CircuitBreaker circuitBreaker) {

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/internal/CircuitBreakerStateMachineTest.java
Patch:
@@ -203,7 +203,6 @@ public void testCircuitBreakerStateMachine() throws InterruptedException {
 
         assertThat(circuitBreaker.isCallPermitted()).isEqualTo(false);
         assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.FORCED_OPEN); // Should create a CircuitBreakerOnStateTransitionEvent (21)
-        final CircuitBreaker.Metrics metrics = circuitBreaker.getMetrics();
         assertCircuitBreakerMetricsEqualTo(-1f, null, 0, null, 0, 2L);
 
 

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/ClosedState.java
Patch:
@@ -86,7 +86,7 @@ CircuitBreaker.State getState() {
     }
     /**
      *
-     * Get metricsof the CircuitBreaker
+     * Get metrics of the CircuitBreaker
      */
     @Override
     CircuitBreakerMetrics getMetrics() {

File: resilience4j-core/src/main/java/io/github/resilience4j/core/EventProcessor.java
Patch:
@@ -32,7 +32,7 @@ public boolean hasConsumers(){
     }
 
     @SuppressWarnings("unchecked")
-    public <E extends T> void registerConsumer(Class<E> eventType, EventConsumer<E> eventConsumer){
+    public <E extends T> void registerConsumer(Class<? extends E> eventType, EventConsumer<E> eventConsumer){
         consumerRegistered = true;
         eventConsumers.put(eventType, (EventConsumer<Object>) eventConsumer);
     }

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/BulkheadObserverTest.java
Patch:
@@ -66,6 +66,7 @@ public void shouldHonorDisposedWhenCallingOnNext() throws Exception {
         Disposable disposable = mock(Disposable.class);
         Observer childObserver = mock(Observer.class);
         Observer decoratedObserver = BulkheadOperator.of(bulkhead).apply(childObserver);
+        assertThat(bulkhead.getMetrics().getAvailableConcurrentCalls()).isEqualTo(1);
         decoratedObserver.onSubscribe(disposable);
 
         // When

File: resilience4j-rxjava2/src/test/java/io/github/resilience4j/bulkhead/operator/BulkheadSubscriberTest.java
Patch:
@@ -61,7 +61,7 @@ public void shouldEmitErrorWithBulkheadFullException() {
     }
 
     @Test
-    public void shouldHonorDisposedWhenCallingOnNext() throws Exception {
+    public void shouldHonorCancelledWhenCallingOnNext() throws Exception {
         // Given
         Subscription subscription = mock(Subscription.class);
         Subscriber childSubscriber = mock(Subscriber.class);
@@ -79,7 +79,7 @@ public void shouldHonorDisposedWhenCallingOnNext() throws Exception {
     }
 
     @Test
-    public void shouldHonorDisposedWhenCallingOnError() throws Exception {
+    public void shouldHonorCancelledWhenCallingOnError() throws Exception {
         // Given
         Subscription subscription = mock(Subscription.class);
         Subscriber childSubscriber = mock(Subscriber.class);
@@ -96,7 +96,7 @@ public void shouldHonorDisposedWhenCallingOnError() throws Exception {
     }
 
     @Test
-    public void shouldHonorDisposedWhenCallingOnComplete() throws Exception {
+    public void shouldHonorCancelledWhenCallingOnComplete() throws Exception {
         // Given
         Subscription subscription = mock(Subscription.class);
         Subscriber childSubscriber = mock(Subscriber.class);

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/event/CircuitBreakerEvent.java
Patch:
@@ -59,6 +59,8 @@ enum Type {
         /** A CircuitBreakerEvent which informs that a call was not permitted because the CircuitBreaker state is OPEN */
         NOT_PERMITTED,
         /** A CircuitBreakerEvent which informs the state of the CircuitBreaker has been changed */
-        STATE_TRANSITION;
+        STATE_TRANSITION,
+        /** A CircuitBreakerEvent which informs the CircuitBreaker has been reset */
+        RESET;
     }
 }

File: resilience4j-circuitbreaker/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerEventPublisherTest.java
Patch:
@@ -106,7 +106,6 @@ public void shouldConsumeOnStateTransitionEvent() {
         then(logger).should(times(1)).info("STATE_TRANSITION");
     }
 
-
     @Test
     public void shouldConsumeCallNotPermittedEvent() {
         circuitBreaker = CircuitBreaker.of("test", CircuitBreakerConfig.custom()

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/internal/SemaphoreBulkheadTest.java
Patch:
@@ -30,8 +30,7 @@
 import java.util.function.Supplier;
 
 import static com.jayway.awaitility.Awaitility.await;
-import static io.github.resilience4j.bulkhead.event.BulkheadEvent.Type.CALL_PERMITTED;
-import static io.github.resilience4j.bulkhead.event.BulkheadEvent.Type.CALL_REJECTED;
+import static io.github.resilience4j.bulkhead.event.BulkheadEvent.Type.*;
 import static java.lang.Thread.State.*;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.assertj.core.api.Assertions.assertThat;

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/Bulkhead.java
Patch:
@@ -19,6 +19,7 @@
 package io.github.resilience4j.bulkhead;
 
 import io.github.resilience4j.bulkhead.event.BulkheadEvent;
+import io.github.resilience4j.bulkhead.event.BulkheadOnCallFinishedEvent;
 import io.github.resilience4j.bulkhead.event.BulkheadOnCallPermittedEvent;
 import io.github.resilience4j.bulkhead.event.BulkheadOnCallRejectedEvent;
 import io.github.resilience4j.bulkhead.internal.SemaphoreBulkhead;
@@ -417,5 +418,6 @@ interface EventPublisher extends io.github.resilience4j.core.EventPublisher<Bulk
 
         EventPublisher onCallPermitted(EventConsumer<BulkheadOnCallPermittedEvent> eventConsumer);
 
+        EventPublisher onCallFinished(EventConsumer<BulkheadOnCallFinishedEvent> eventConsumer);
     }
 }

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/event/BulkheadEvent.java
Patch:
@@ -54,5 +54,7 @@ enum Type {
         CALL_PERMITTED,
         /** A BulkheadEvent which informs that a call was rejected due to bulkhead being full */
         CALL_REJECTED,
+        /** A BulkheadEvent which informs that a call was finished(success and failure is indistinguishable) */
+        CALL_FINISHED
     }
 }

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/event/BulkheadOnCallPermittedEvent.java
Patch:
@@ -40,6 +40,4 @@ public String toString() {
                    getBulkheadName()
                );
     }
-
-
 }

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/internal/SemaphoreBulkheadTest.java
Patch:
@@ -76,8 +76,8 @@ public void testBulkhead() throws InterruptedException {
 
         bulkhead.isCallPermitted();
 
-        testSubscriber.assertValueCount(4)
-                      .assertValues(CALL_PERMITTED, CALL_PERMITTED, CALL_REJECTED, CALL_PERMITTED);
+        testSubscriber.assertValueCount(6)
+                      .assertValues(CALL_PERMITTED, CALL_PERMITTED, CALL_REJECTED, CALL_FINISHED, CALL_FINISHED, CALL_PERMITTED);
     }
 
     @Test

File: resilience4j-metrics/src/main/java/io/github/resilience4j/metrics/BulkheadMetrics.java
Patch:
@@ -46,10 +46,9 @@ private BulkheadMetrics(String prefix, Iterable<Bulkhead> bulkheads) {
         requireNonNull(bulkheads);
         bulkheads.forEach(bulkhead -> {
                     String name = bulkhead.getName();
-                    Bulkhead.Metrics metrics = bulkhead.getMetrics();
-                    //number of available concurrent calls as an integer
+            //number of available concurrent calls as an integer
                     metricRegistry.register(name(prefix, name, AVAILABLE_CONCURRENT_CALLS),
-                            (Gauge<Integer>) metrics::getAvailableConcurrentCalls);
+                            (Gauge<Integer>) () -> bulkhead.getMetrics().getAvailableConcurrentCalls());
                 }
         );
     }

File: resilience4j-metrics/src/test/java/io/github/resilience4j/metrics/StateTransitionMetricsTest.java
Patch:
@@ -23,7 +23,7 @@ public class StateTransitionMetricsTest {
     private CircuitBreaker circuitBreaker;
 
     @Before
-    public void setup() throws Exception {
+    public void setUp() throws Exception {
         CircuitBreakerConfig config =
                 CircuitBreakerConfig.custom()
                         .waitDurationInOpenState(Duration.ofSeconds(1))

File: resilience4j-metrics/src/main/java/io/github/resilience4j/metrics/BulkheadMetrics.java
Patch:
@@ -46,10 +46,9 @@ private BulkheadMetrics(String prefix, Iterable<Bulkhead> bulkheads) {
         requireNonNull(bulkheads);
         bulkheads.forEach(bulkhead -> {
                     String name = bulkhead.getName();
-                    Bulkhead.Metrics metrics = bulkhead.getMetrics();
-                    //number of available concurrent calls as an integer
+            //number of available concurrent calls as an integer
                     metricRegistry.register(name(prefix, name, AVAILABLE_CONCURRENT_CALLS),
-                            (Gauge<Integer>) metrics::getAvailableConcurrentCalls);
+                            (Gauge<Integer>) () -> bulkhead.getMetrics().getAvailableConcurrentCalls());
                 }
         );
     }

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreaker.java
Patch:
@@ -354,7 +354,7 @@ static <T> CheckedFunction0<T> decorateCheckedSupplier(CircuitBreaker circuitBre
             long start = System.nanoTime();
             try {
                 T returnValue = supplier.apply();
-                
+
                 long durationInNanos = System.nanoTime() - start;
                 circuitBreaker.onSuccess(durationInNanos);
                 return returnValue;

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterAutoConfiguration.java
Patch:
@@ -66,8 +66,8 @@ public RateLimiterRegistry rateLimiterRegistry(RateLimiterProperties rateLimiter
     }
 
     @Bean
-    public RateLimiterAspect rateLimiterAspect(RateLimiterRegistry rateLimiterRegistry) {
-        return new RateLimiterAspect(rateLimiterRegistry);
+    public RateLimiterAspect rateLimiterAspect(RateLimiterProperties rateLimiterProperties, RateLimiterRegistry rateLimiterRegistry) {
+        return new RateLimiterAspect(rateLimiterRegistry, rateLimiterProperties);
     }
 
     @Bean

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerPrometheusAutoConfiguration.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
 import io.github.resilience4j.prometheus.CircuitBreakerExports;
-import io.prometheus.client.CollectorRegistry;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.context.annotation.Bean;
@@ -29,7 +28,7 @@
  */
 @Configuration
 @AutoConfigureAfter(value = CircuitBreakerAutoConfiguration.class)
-@ConditionalOnClass(CollectorRegistry.class)
+@ConditionalOnClass(CircuitBreakerExports.class)
 public class CircuitBreakerPrometheusAutoConfiguration {
     @Bean
     public CircuitBreakerExports circuitBreakerPrometheusCollector(CircuitBreakerRegistry circuitBreakerRegistry){

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterPrometheusAutoConfiguration.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.github.resilience4j.prometheus.RateLimiterExports;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
-import io.prometheus.client.CollectorRegistry;
 import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.context.annotation.Bean;
@@ -29,7 +28,7 @@
  */
 @Configuration
 @AutoConfigureAfter(value = RateLimiterAutoConfiguration.class)
-@ConditionalOnClass(CollectorRegistry.class)
+@ConditionalOnClass(RateLimiterExports.class)
 public class RateLimiterPrometheusAutoConfiguration {
     @Bean
     public RateLimiterExports rateLimiterPrometheusCollector(RateLimiterRegistry rateLimiterRegistry){

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/ratelimiter/autoconfigure/RateLimiterPrometheusAutoConfiguration.java
Patch:
@@ -18,6 +18,7 @@
 import io.github.resilience4j.prometheus.RateLimiterExports;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
 import io.prometheus.client.CollectorRegistry;
+import org.springframework.boot.autoconfigure.AutoConfigureAfter;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
@@ -27,6 +28,7 @@
  * Auto-configuration} for resilience4j-metrics.
  */
 @Configuration
+@AutoConfigureAfter(value = RateLimiterAutoConfiguration.class)
 @ConditionalOnClass(CollectorRegistry.class)
 public class RateLimiterPrometheusAutoConfiguration {
     @Bean

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/circuitbreaker/CircuitBreakerTransformer.java
Patch:
@@ -90,7 +90,7 @@ public void complete() {
                     }
                 });
             } else {
-                Throwable t = new CircuitBreakerOpenException("CircuitBreaker ${circuitBreaker.name} is open");
+                Throwable t = new CircuitBreakerOpenException(String.format("CircuitBreaker '%s' is open", circuitBreaker.getName()));
                 if (recoverer != null) {
                     try {
                         down.success(recoverer.apply(t));

File: resilience4j-circuitbreaker/src/jmh/java/io/github/resilience4j/circuitbreaker/CircuitBreakerBenchmark.java
Patch:
@@ -64,7 +64,6 @@ public void setUp() {
         protectedSupplier = CircuitBreaker.decorateSupplier(circuitBreaker, stringSupplier);
 
         CircuitBreaker circuitBreakerWithSubscriber = CircuitBreaker.ofDefaults("testCircuitBreakerWithSb");
-        circuitBreakerWithSubscriber.getEventStream().subscribe();
         protectedSupplierWithSb = CircuitBreaker.decorateSupplier(circuitBreakerWithSubscriber, stringSupplier);
     }
 

File: resilience4j-metrics/src/main/java/io/github/resilience4j/metrics/Timer.java
Patch:
@@ -47,7 +47,7 @@ public interface Timer {
      *
      * @param name the name of the timer
      * @param metricRegistry the MetricRegistry
-     * @return a Bulkhead instance
+     * @return a Timer instance
      */
     static Timer ofMetricRegistry(String name, MetricRegistry metricRegistry) {
         return new TimerImpl(name, metricRegistry);
@@ -57,7 +57,7 @@ static Timer ofMetricRegistry(String name, MetricRegistry metricRegistry) {
      * Creates a timer of a default MetricRegistry
      *
      * @param name the name of the timer
-     * @return a Bulkhead instance
+     * @return a Timer instance
      */
     static Timer of(String name) {
         return new TimerImpl(name, new MetricRegistry());

File: resilience4j-bulkhead/src/jcstress/java/io/github/resilience4j/bulkhead/concurrent/ConcurrentBulkheadTest.java
Patch:
@@ -18,6 +18,7 @@
  */
 package io.github.resilience4j.bulkhead.concurrent;
 
+import io.github.resilience4j.adapter.RxJava2Adapter;
 import io.github.resilience4j.bulkhead.Bulkhead;
 import io.github.resilience4j.bulkhead.BulkheadConfig;
 import io.github.resilience4j.bulkhead.event.BulkheadEvent;
@@ -54,7 +55,7 @@ public ConcurrentBulkheadTest() {
 
         bulkhead = Bulkhead.of("test", BulkheadConfig.custom().maxConcurrentCalls(1).build());
 
-        callRejectectedEventSubscriber = bulkhead.getEventStream()
+        callRejectectedEventSubscriber = RxJava2Adapter.toFlowable(bulkhead.getEventPublisher())
                                                  .filter(event -> event.getEventType() == Type.CALL_REJECTED)
                                                  .map(BulkheadEvent::getEventType)
                                                  .test();

File: resilience4j-bulkhead/src/jmh/java/io/github/resilience4j/bulkhead/BulkheadBenchmark.java
Patch:
@@ -18,6 +18,7 @@
  */
 package io.github.resilience4j.bulkhead;
 
+import io.github.resilience4j.adapter.RxJava2Adapter;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Fork;
@@ -76,7 +77,7 @@ public void setUp() {
         protectedSupplier = Bulkhead.decorateSupplier(bulkhead, stringSupplier);
 
         Bulkhead bulkheadWithSubscriber = Bulkhead.of("test-with-subscriber", config);
-        bulkheadWithSubscriber.getEventStream().subscribe();
+        RxJava2Adapter.toFlowable(bulkheadWithSubscriber.getEventPublisher()).subscribe();
         protectedSupplierWithSb = Bulkhead.decorateSupplier(bulkheadWithSubscriber, stringSupplier);
     }
 

File: resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/internal/SemaphoreBulkheadTest.java
Patch:
@@ -18,6 +18,7 @@
  */
 package io.github.resilience4j.bulkhead.internal;
 
+import io.github.resilience4j.adapter.RxJava2Adapter;
 import io.github.resilience4j.bulkhead.Bulkhead;
 import io.github.resilience4j.bulkhead.BulkheadConfig;
 import io.github.resilience4j.bulkhead.event.BulkheadEvent;
@@ -46,7 +47,7 @@ public void setUp(){
                                               .build();
 
         bulkhead = Bulkhead.of("test", config);
-        testSubscriber = bulkhead.getEventStream()
+        testSubscriber = RxJava2Adapter.toFlowable(bulkhead.getEventPublisher())
                                  .map(BulkheadEvent::getEventType)
                                  .test();
     }

File: resilience4j-consumer/src/main/java/io/github/resilience4j/consumer/CircularEventConsumer.java
Patch:
@@ -20,12 +20,13 @@
 
 import io.github.resilience4j.circularbuffer.CircularFifoBuffer;
 import io.github.resilience4j.circularbuffer.ConcurrentCircularFifoBuffer;
+import io.github.resilience4j.core.EventConsumer;
 import io.vavr.collection.List;
 
 /**
  * A RxJava consumer which stores CircuitBreakerEvents in a circular buffer with a fixed capacity.
  */
-public class CircularEventConsumer<T> implements EventConsumer<T>{
+public class CircularEventConsumer<T> implements EventConsumer<T> {
 
     private CircularFifoBuffer<T> eventCircularFifoBuffer;
 
@@ -41,7 +42,7 @@ public CircularEventConsumer(int capacity) {
     }
 
     @Override
-    public void accept(T event) throws Exception {
+    public void consumeEvent(T event){
         eventCircularFifoBuffer.add(event);
     }
 
@@ -50,7 +51,6 @@ public void accept(T event) throws Exception {
      *
      * @return a list containing all of the buffered events.
      */
-    @Override
     public List<T> getBufferedEvents(){
         return eventCircularFifoBuffer.toList();
     }

File: resilience4j-consumer/src/main/java/io/github/resilience4j/consumer/EventConsumerRegistry.java
Patch:
@@ -27,20 +27,20 @@ public interface EventConsumerRegistry<T> {
      * @param bufferSize the size of the EventConsumer
      * @return a new EventConsumer
      */
-    EventConsumer<T> createEventConsumer(String id, int bufferSize);
+    CircularEventConsumer<T> createEventConsumer(String id, int bufferSize);
 
     /**
      * Returns the EventConsumer to which the specified id is mapped.
      *
      * @param id the id of the EventConsumer
      * @return the EventConsumer to which the specified id is mapped
      */
-    EventConsumer<T> getEventConsumer(String id);
+    CircularEventConsumer<T> getEventConsumer(String id);
 
     /**
      * Returns all EventConsumer instances.
      *
      * @return all EventConsumer instances
      */
-    Seq<EventConsumer<T>> getAllEventConsumer();
+    Seq<CircularEventConsumer<T>> getAllEventConsumer();
 }

File: resilience4j-consumer/src/test/java/io/github/resilience4j/consumer/EventConsumerRegistryTest.java
Patch:
@@ -18,9 +18,9 @@
  */
 package io.github.resilience4j.consumer;
 
-import org.junit.Test;
-
 import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;
+import io.github.resilience4j.core.EventConsumer;
+import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -32,7 +32,6 @@ public void shouldCreateAnEventConsumer() {
         EventConsumer<CircuitBreakerEvent> eventEventConsumer = registry.createEventConsumer("testName", 5);
 
         assertThat(eventEventConsumer).isNotNull();
-        assertThat(eventEventConsumer.getBufferedEvents()).hasSize(0);
     }
 
     @Test

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/Resilience4jModule.java
Patch:
@@ -223,7 +223,7 @@ public void onStart(StartEvent event) throws Exception {
                             .build());
                 }
                 if (endpointsConfig.getCircuitBreakers().isEnabled()) {
-                    circuitBreaker.getEventStream().subscribe(cbConsumerRegistry.createEventConsumer(name, endpointsConfig.getCircuitBreakers().getEventConsumerBufferSize()));
+                    circuitBreaker.getEventPublisher().onEvent(cbConsumerRegistry.createEventConsumer(name, endpointsConfig.getCircuitBreakers().getEventConsumerBufferSize()));
                 }
             });
 
@@ -242,7 +242,7 @@ public void onStart(StartEvent event) throws Exception {
                             .build());
                 }
                 if (endpointsConfig.getRateLimiters().isEnabled()) {
-                    rateLimiter.getEventStream().subscribe(rlConsumerRegistry.createEventConsumer(name, endpointsConfig.getRateLimiters().getEventConsumerBufferSize()));
+                    rateLimiter.getEventPublisher().onEvent(rlConsumerRegistry.createEventConsumer(name, endpointsConfig.getRateLimiters().getEventConsumerBufferSize()));
                 }
             });
 
@@ -260,7 +260,7 @@ public void onStart(StartEvent event) throws Exception {
                             .build());
                 }
                 if (endpointsConfig.getRetries().isEnabled()) {
-                    retry.getEventStream().subscribe(rConsumerRegistry.createEventConsumer(name, endpointsConfig.getRetries().getEventConsumerBufferSize()));
+                    retry.getEventPublisher().onEvent(rConsumerRegistry.createEventConsumer(name, endpointsConfig.getRetries().getEventConsumerBufferSize()));
                 }
             });
 

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerAutoConfiguration.java
Patch:
@@ -49,8 +49,7 @@ public CircuitBreakerRegistry circuitBreakerRegistry(CircuitBreakerProperties ci
             (name, properties) -> {
                 CircuitBreakerConfig circuitBreakerConfig = circuitBreakerProperties.createCircuitBreakerConfig(name);
                 CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(name, circuitBreakerConfig);
-                circuitBreaker.getEventStream()
-                    .subscribe(eventConsumerRegistry.createEventConsumer(name, properties.getEventConsumerBufferSize()));
+                circuitBreaker.getEventPublisher().onEvent(eventConsumerRegistry.createEventConsumer(name, properties.getEventConsumerBufferSize()));
 
                 if (properties.getRegisterHealthIndicator()) {
                     CircuitBreakerHealthIndicator healthIndicator = new CircuitBreakerHealthIndicator(circuitBreaker);

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreakerConfig.java
Patch:
@@ -87,13 +87,13 @@ public static class Builder {
         /**
          * Configures the failure rate threshold in percentage above which the CircuitBreaker should trip open and start short-circuiting calls.
          *
-         * The threshold must be between 1 and 100. Default value is 50 percentage.
+         * The threshold must be greater than 0 and not greater than 100. Default value is 50 percentage.
          *
          * @param failureRateThreshold the failure rate threshold in percentage
          * @return the CircuitBreakerConfig.Builder
          */
-        public Builder failureRateThreshold(int failureRateThreshold) {
-            if (failureRateThreshold < 1 || failureRateThreshold > 100) {
+        public Builder failureRateThreshold(float failureRateThreshold) {
+            if (failureRateThreshold <= 0 || failureRateThreshold > 100) {
                 throw new IllegalArgumentException("failureRateThreshold must be between 1 and 100");
             }
             config.failureRateThreshold = failureRateThreshold;

File: resilience4j-retrofit/src/test/java/io/github/resilience4j/retrofit/RetrofitRateLimiterTest.java
Patch:
@@ -51,7 +51,7 @@ public class RetrofitRateLimiterTest {
 
     private static final RateLimiterConfig config = RateLimiterConfig.custom()
             .timeoutDuration(Duration.ofMillis(50))
-            .limitRefreshPeriod(Duration.ofSeconds(1))
+            .limitRefreshPeriod(Duration.ofSeconds(5))
             .limitForPeriod(1)
             .build();
 

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/event/RetryOnSuccessEvent.java
Patch:
@@ -19,7 +19,8 @@
 package io.github.resilience4j.retry.event;
 
 /**
- * A RetryEvent which informs that a call has been retried and a retry was successful
+ * A RetryEvent which informs that a call has been retried and a retry was successful.
+ * This event is not published when a call was successful without a retry attempt.
  */
 public class RetryOnSuccessEvent extends AbstractRetryEvent {
 

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/circuitbreaker/CircuitBreakerConfig.java
Patch:
@@ -23,7 +23,7 @@
 
 public class CircuitBreakerConfig {
     private boolean defaults = false;
-    private Integer waitIntervalInMillis = DEFAULT_WAIT_DURATION_IN_OPEN_STATE;
+    private Integer waitIntervalInMillis = DEFAULT_WAIT_DURATION_IN_OPEN_STATE * 1000;
     private Integer failureRateThreshold = DEFAULT_MAX_FAILURE_THRESHOLD;
     private Integer ringBufferSizeInClosedState = DEFAULT_RING_BUFFER_SIZE_IN_CLOSED_STATE;
     private Integer ringBufferSizeInHalfOpenState = DEFAULT_RING_BUFFER_SIZE_IN_HALF_OPEN_STATE;
@@ -78,4 +78,5 @@ public Integer getRingBufferSizeInClosedState() {
     public Integer getRingBufferSizeInHalfOpenState() {
         return ringBufferSizeInHalfOpenState;
     }
+
 }

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/Bulkhead.java
Patch:
@@ -35,6 +35,8 @@
 import java.util.function.Supplier;
 
 /**
+ *  A Bulkhead instance is thread-safe can be used to decorate multiple requests.
+ *
  * A {@link Bulkhead} represent an entity limiting the amount of parallel operations. It does not assume nor does it mandate usage
  * of any particular concurrency and/or io model. These details are left for the client to manage. This bulkhead, depending on the
  * underlying concurrency/io model can be used to shed load, and, where it makes sense, limit resource use (i.e. limit amount of

File: resilience4j-cache/src/main/java/io/github/resilience4j/cache/Cache.java
Patch:
@@ -19,7 +19,7 @@
 package io.github.resilience4j.cache;
 
 import io.github.resilience4j.cache.event.CacheEvent;
-import io.github.resilience4j.cache.internal.CacheContext;
+import io.github.resilience4j.cache.internal.CacheImpl;
 import io.reactivex.Flowable;
 import io.vavr.CheckedFunction0;
 import io.vavr.CheckedFunction1;
@@ -72,7 +72,7 @@ public interface Cache<K, V>  {
      */
     static <K,V> Cache<K,V> of(javax.cache.Cache<K, V> cache){
         Objects.requireNonNull(cache, "Cache must not be null");
-        return new CacheContext<>(cache);
+        return new CacheImpl<>(cache);
     }
 
     /**

File: resilience4j-cache/src/main/java/io/github/resilience4j/cache/internal/CacheImpl.java
Patch:
@@ -35,15 +35,15 @@
 import java.util.concurrent.atomic.LongAdder;
 import java.util.function.Supplier;
 
-public class CacheContext<K, V>  implements Cache<K,V> {
+public class CacheImpl<K, V>  implements Cache<K,V> {
 
-    private static final Logger LOG = LoggerFactory.getLogger(CacheContext.class);
+    private static final Logger LOG = LoggerFactory.getLogger(CacheImpl.class);
 
     private final javax.cache.Cache<K, V> cache;
     private final FlowableProcessor<CacheEvent> eventPublisher;
     private final CacheMetrics metrics;
 
-    public CacheContext(javax.cache.Cache<K, V> cache) {
+    public CacheImpl(javax.cache.Cache<K, V> cache) {
         this.cache = cache;
         PublishProcessor<CacheEvent> publisher = PublishProcessor.create();
         this.eventPublisher = publisher.toSerialized();

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreaker.java
Patch:
@@ -35,6 +35,8 @@
 import java.util.function.Supplier;
 
 /**
+ * A CircuitBreaker instance is thread-safe can be used to decorate multiple requests.
+ *
  * A {@link CircuitBreaker} manages the state of a backend system.
  * The CircuitBreaker is implemented via a finite state machine with three states: CLOSED, OPEN and HALF_OPEN.
  * The CircuitBreaker does not know anything about the backend’s state by itself, but uses the information provided by the decorators via

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java
Patch:
@@ -34,6 +34,8 @@
 import java.util.function.Supplier;
 
 /**
+ * A RateLimiter instance is thread-safe can be used to decorate multiple requests.
+ *
  * A RateLimiter distributes permits at a configurable rate. {@link #getPermission} blocks if necessary
  * until a permit is available, and then takes it. Once acquired, permits need not be released.
  */

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/retry/RetryTransformer.java
Patch:
@@ -55,18 +55,19 @@ public RetryTransformer<T> recover(Function<Throwable, ? extends T> recoverer) {
     @Override
     public Upstream<T> apply(Upstream<? extends T> upstream) throws Exception {
         return down -> {
+            Retry.Context context = retry.context();
             Downstream<T> downstream = new Downstream<T>() {
 
                 @Override
                 public void success(T value) {
-                    retry.onSuccess();
+                    context.onSuccess();
                     down.success(value);
                 }
 
                 @Override
                 public void error(Throwable throwable) {
                     try {
-                        retry.onError((Exception) throwable);
+                        context.onError((Exception) throwable);
                         upstream.connect(this);
                     } catch (Throwable t) {
                         if (recoverer != null) {

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/event/AbstractRetryEvent.java
Patch:
@@ -45,7 +45,7 @@ public ZonedDateTime getCreationTime() {
     }
 
     @Override
-    public int getNumberOfAttempts() {
+    public int getNumberOfRetryAttempts() {
         return numberOfAttempts;
     }
 

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/event/RetryOnErrorEvent.java
Patch:
@@ -36,7 +36,7 @@ public String toString() {
         return String.format("%s: Retry '%s' recorded a failed retry attempt. Number of retry attempts: '%d', Last exception was: '%s'.",
                 getCreationTime(),
                 getName(),
-                getNumberOfAttempts(),
+                getNumberOfRetryAttempts(),
                 getLastThrowable().toString());
     }
 }

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/event/RetryOnSuccessEvent.java
Patch:
@@ -37,7 +37,7 @@ public String toString() {
         return String.format("%s: Retry '%s' recorded a successful retry attempt. Number of retry attempts: '%d', Last exception was: '%s'.",
                 getCreationTime(),
                 getName(),
-                getNumberOfAttempts(),
+                getNumberOfRetryAttempts(),
                 getLastThrowable().toString());
     }
 }

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/AtomicRateLimiter.java
Patch:
@@ -339,7 +339,7 @@ private State(final long activeCycle, final int activePermissions, final long na
     /**
      * Enhanced {@link Metrics} with some implementation specific details
      */
-    private class AtomicRateLimiterMetrics implements Metrics {
+    public class AtomicRateLimiterMetrics implements Metrics {
 
         private AtomicRateLimiterMetrics() {
         }

File: resilience4j-bulkhead/src/jcstress/java/io/github/resilience4j/bulkhead/concurrent/ConcurrentBulkheadTest.java
Patch:
@@ -78,7 +78,7 @@ public void secondActor() {
     public void arbiter(StringResult1 result1) {
         String result = MessageFormat.format(
             "remainingDepth={0} events={1}",
-            bulkhead.getAvailableConcurrentCalls(),
+            bulkhead.getMetrics().getAvailableConcurrentCalls(),
             callRejectectedEventSubscriber.getEvents()
         );
         result1.r1 = result;

File: resilience4j-spring-boot/src/test/java/org/springframework/web/servlet/mvc/method/annotation/CircuitBreakerEventEmitterTest.java
Patch:
@@ -59,7 +59,7 @@ public void testEmitter() throws IOException {
         exec(ignore, 1);
         exec(fail, 3);
         sseEmitter.complete();
-        then(handler.isCompleted).isTrue();
+        assert handler.isCompleted;
 
         exec(run, 2);
 
@@ -78,8 +78,8 @@ private void exec(Runnable runnable, int times) {
     }
 
     private static class TestHandler implements ResponseBodyEmitter.Handler {
-        List<CircuitBreakerEventDTO> events = new ArrayList<>();
-        boolean isCompleted = false;
+        public List<CircuitBreakerEventDTO> events = new ArrayList<>();
+        public boolean isCompleted = false;
         private Runnable callback;
 
         @Override public void send(Object data, MediaType mediaType) throws IOException {

File: resilience4j-metrics/src/test/java/io/github/resilience4j/metrics/TimerTest.java
Patch:
@@ -19,7 +19,6 @@
 package io.github.resilience4j.metrics;
 
 import com.codahale.metrics.MetricRegistry;
-import com.codahale.metrics.SharedMetricRegistries;
 import io.github.resilience4j.test.HelloWorldService;
 import io.vavr.CheckedFunction0;
 import io.vavr.CheckedFunction1;
@@ -50,7 +49,7 @@ public class TimerTest {
 
     @Before
     public void setUp(){
-        metricRegistry = SharedMetricRegistries.getOrCreate("MyRegistry");
+        metricRegistry = new MetricRegistry();
         timer = Timer.ofMetricRegistry(TimerTest.class.getName(), metricRegistry);
         helloWorldService = mock(HelloWorldService.class);
     }

File: resilience4j-metrics/src/main/java/io/github/resilience4j/metrics/Timer.java
Patch:
@@ -270,7 +270,7 @@ interface Metrics {
         /**
          * Returns the fifteen-minute exponentially-weighted moving average rate at which events have
          * occurred since the meter was created.
-         * <p/>
+         *
          * This rate has the same exponential decay factor as the fifteen-minute load average in the
          * {@code top} Unix command.
          *
@@ -282,7 +282,7 @@ interface Metrics {
         /**
          * Returns the five-minute exponentially-weighted moving average rate at which events have
          * occurred since the meter was created.
-         * <p/>
+         *
          * This rate has the same exponential decay factor as the five-minute load average in the {@code
          * top} Unix command.
          *
@@ -301,7 +301,7 @@ interface Metrics {
         /**
          * Returns the one-minute exponentially-weighted moving average rate at which events have
          * occurred since the meter was created.
-         * <p/>
+         *
          * This rate has the same exponential decay factor as the one-minute load average in the {@code
          * top} Unix command.
          *

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/BulkheadRegistry.java
Patch:
@@ -20,7 +20,7 @@
 
 
 import io.github.resilience4j.bulkhead.internal.InMemoryBulkheadRegistry;
-import javaslang.collection.Seq;
+import io.vavr.collection.Seq;
 
 import java.util.function.Supplier;
 

File: resilience4j-bulkhead/src/main/java/io/github/resilience4j/bulkhead/internal/InMemoryBulkheadRegistry.java
Patch:
@@ -21,8 +21,8 @@
 import io.github.resilience4j.bulkhead.Bulkhead;
 import io.github.resilience4j.bulkhead.BulkheadConfig;
 import io.github.resilience4j.bulkhead.BulkheadRegistry;
-import javaslang.collection.Array;
-import javaslang.collection.Seq;
+import io.vavr.collection.Array;
+import io.vavr.collection.Seq;
 
 import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreakerRegistry.java
Patch:
@@ -20,7 +20,7 @@
 
 
 import io.github.resilience4j.circuitbreaker.internal.InMemoryCircuitBreakerRegistry;
-import javaslang.collection.Seq;
+import io.vavr.collection.Seq;
 
 import java.util.function.Supplier;
 

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/internal/InMemoryCircuitBreakerRegistry.java
Patch:
@@ -21,8 +21,8 @@
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
-import javaslang.collection.Array;
-import javaslang.collection.Seq;
+import io.vavr.collection.Array;
+import io.vavr.collection.Seq;
 
 import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;

File: resilience4j-circularbuffer/src/jmh/java/io/github/resilience4j/circularbuffer/CircularBufferBenchmark.java
Patch:
@@ -39,8 +39,8 @@
 
 import java.util.concurrent.TimeUnit;
 
-import javaslang.collection.List;
-import javaslang.control.Option;
+import io.vavr.collection.List;
+import io.vavr.control.Option;
 
 /**
  * @author bstorozhuk

File: resilience4j-circularbuffer/src/main/java/io/github/resilience4j/circularbuffer/CircularFifoBuffer.java
Patch:
@@ -18,8 +18,8 @@
  */
 package io.github.resilience4j.circularbuffer;
 
-import javaslang.collection.List;
-import javaslang.control.Option;
+import io.vavr.collection.List;
+import io.vavr.control.Option;
 
 /**
  * A {@link CircularFifoBuffer} is a first in first out buffer with a fixed size that replaces its oldest element if full.

File: resilience4j-circularbuffer/src/main/java/io/github/resilience4j/circularbuffer/ConcurrentCircularFifoBuffer.java
Patch:
@@ -18,8 +18,8 @@
  */
 package io.github.resilience4j.circularbuffer;
 
-import javaslang.collection.List;
-import javaslang.control.Option;
+import io.vavr.collection.List;
+import io.vavr.control.Option;
 
 import java.util.Arrays;
 

File: resilience4j-circularbuffer/src/test/java/io/github/resilience4j/circularbuffer/CircularFifoBufferTest.java
Patch:
@@ -21,7 +21,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import javaslang.collection.List;
+import io.vavr.collection.List;
 import org.junit.Test;
 
 import java.io.IOException;

File: resilience4j-consumer/src/main/java/io/github/resilience4j/consumer/CircularEventConsumer.java
Patch:
@@ -20,7 +20,7 @@
 
 import io.github.resilience4j.circularbuffer.CircularFifoBuffer;
 import io.github.resilience4j.circularbuffer.ConcurrentCircularFifoBuffer;
-import javaslang.collection.List;
+import io.vavr.collection.List;
 
 /**
  * A RxJava consumer which stores CircuitBreakerEvents in a circular buffer with a fixed capacity.

File: resilience4j-consumer/src/main/java/io/github/resilience4j/consumer/DefaultEventConsumerRegistry.java
Patch:
@@ -15,12 +15,12 @@
  */
 package io.github.resilience4j.consumer;
 
+import io.vavr.collection.Array;
+import io.vavr.collection.Seq;
+
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
-import javaslang.collection.Array;
-import javaslang.collection.Seq;
-
 public class DefaultEventConsumerRegistry<T> implements EventConsumerRegistry<T>{
 
     /**

File: resilience4j-consumer/src/main/java/io/github/resilience4j/consumer/EventConsumer.java
Patch:
@@ -19,7 +19,7 @@
 package io.github.resilience4j.consumer;
 
 import io.reactivex.functions.Consumer;
-import javaslang.collection.List;
+import io.vavr.collection.List;
 
 public interface EventConsumer<T> extends Consumer<T> {
 

File: resilience4j-consumer/src/main/java/io/github/resilience4j/consumer/EventConsumerRegistry.java
Patch:
@@ -15,7 +15,7 @@
  */
 package io.github.resilience4j.consumer;
 
-import javaslang.collection.Seq;
+import io.vavr.collection.Seq;
 
 
 public interface EventConsumerRegistry<T> {

File: resilience4j-metrics/src/main/java/io/github/resilience4j/metrics/CircuitBreakerMetrics.java
Patch:
@@ -27,7 +27,7 @@
 import com.codahale.metrics.MetricSet;
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
-import javaslang.collection.Array;
+import io.vavr.collection.Array;
 
 import java.util.Map;
 

File: resilience4j-metrics/src/main/java/io/github/resilience4j/metrics/RetryMetrics.java
Patch:
@@ -3,7 +3,7 @@
 import com.codahale.metrics.*;
 import io.github.resilience4j.retry.Retry;
 import io.github.resilience4j.retry.RetryRegistry;
-import javaslang.collection.Array;
+import io.vavr.collection.Array;
 
 import java.util.Map;
 

File: resilience4j-prometheus/src/main/java/io/github/resilience4j/prometheus/CircuitBreakerExports.java
Patch:
@@ -25,9 +25,9 @@
 import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
 import io.prometheus.client.Collector;
 import io.prometheus.client.GaugeMetricFamily;
-import javaslang.Tuple;
-import javaslang.Tuple2;
-import javaslang.collection.Array;
+import io.vavr.Tuple;
+import io.vavr.Tuple2;
+import io.vavr.collection.Array;
 
 import static java.util.Arrays.asList;
 import static java.util.Objects.requireNonNull;

File: resilience4j-prometheus/src/main/java/io/github/resilience4j/prometheus/RateLimiterExports.java
Patch:
@@ -25,7 +25,7 @@
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
 import io.prometheus.client.Collector;
 import io.prometheus.client.GaugeMetricFamily;
-import javaslang.collection.Array;
+import io.vavr.collection.Array;
 
 import static java.util.Arrays.asList;
 import static java.util.Collections.singletonList;

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiterRegistry.java
Patch:
@@ -19,7 +19,7 @@
 package io.github.resilience4j.ratelimiter;
 
 import io.github.resilience4j.ratelimiter.internal.InMemoryRateLimiterRegistry;
-import javaslang.collection.Seq;
+import io.vavr.collection.Seq;
 
 import java.util.function.Supplier;
 

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/InMemoryRateLimiterRegistry.java
Patch:
@@ -23,8 +23,8 @@
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.ratelimiter.RateLimiterConfig;
 import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
-import javaslang.collection.Array;
-import javaslang.collection.Seq;
+import io.vavr.collection.Array;
+import io.vavr.collection.Seq;
 
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/SemaphoreBasedRateLimiter.java
Patch:
@@ -29,7 +29,7 @@
 import io.reactivex.Flowable;
 import io.reactivex.processors.FlowableProcessor;
 import io.reactivex.processors.PublishProcessor;
-import javaslang.control.Option;
+import io.vavr.control.Option;
 
 import java.time.Duration;
 import java.util.concurrent.ScheduledExecutorService;

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/SemaphoreBasedRateLimiterImplTest.java
Patch:
@@ -39,7 +39,7 @@
 import static com.jayway.awaitility.Duration.FIVE_HUNDRED_MILLISECONDS;
 import static java.lang.Thread.State.*;
 import static java.time.Duration.ZERO;
-import static javaslang.control.Try.run;
+import static io.vavr.control.Try.run;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.hamcrest.CoreMatchers.equalTo;
 import static org.mockito.Matchers.eq;

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/operator/RateLimiterOperatorTest.java
Patch:
@@ -22,7 +22,7 @@
 import io.reactivex.Flowable;
 import io.reactivex.Observable;
 import io.reactivex.Single;
-import javaslang.collection.List;
+import io.vavr.collection.List;
 import org.junit.Test;
 
 import java.io.IOException;

File: resilience4j-retrofit/src/main/java/io/github/resilience4j/retrofit/RetrofitRateLimiter.java
Patch:
@@ -22,7 +22,8 @@
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.ratelimiter.RequestNotPermitted;
 import io.github.resilience4j.retrofit.internal.DecoratedCall;
-import javaslang.control.Try;
+import io.vavr.CheckedFunction0;
+import io.vavr.control.Try;
 import okhttp3.MediaType;
 import okhttp3.ResponseBody;
 import retrofit2.Call;
@@ -57,7 +58,7 @@ static <T> Call<T> decorateCall(final RateLimiter rateLimiter, final Call<T> cal
         return new DecoratedCall<T>(call) {
             @Override
             public Response<T> execute() throws IOException {
-                Try.CheckedSupplier<Response<T>> restrictedSupplier = RateLimiter.decorateCheckedSupplier(rateLimiter, call::execute);
+                CheckedFunction0<Response<T>> restrictedSupplier = RateLimiter.decorateCheckedSupplier(rateLimiter, call::execute);
                 final Try<Response<T>> response = Try.of(restrictedSupplier);
                 return response.isSuccess() ? response.get() : handleFailure(response);
             }

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/IntervalFunction.java
Patch:
@@ -1,6 +1,6 @@
 package io.github.resilience4j.retry;
 
-import javaslang.collection.Stream;
+import io.vavr.collection.Stream;
 
 import java.time.Duration;
 import java.util.function.Function;

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/RetryRegistry.java
Patch:
@@ -17,7 +17,7 @@
 
 
 import io.github.resilience4j.retry.internal.InMemoryRetryRegistry;
-import javaslang.collection.Seq;
+import io.vavr.collection.Seq;
 
 import java.util.function.Supplier;
 

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/InMemoryRetryRegistry.java
Patch:
@@ -18,8 +18,8 @@
 import io.github.resilience4j.retry.Retry;
 import io.github.resilience4j.retry.RetryConfig;
 import io.github.resilience4j.retry.RetryRegistry;
-import javaslang.collection.Array;
-import javaslang.collection.Seq;
+import io.vavr.collection.Array;
+import io.vavr.collection.Seq;
 
 import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;

File: resilience4j-retry/src/test/java/io/github/resilience4j/retry/IntervalFunctionTest.java
Patch:
@@ -1,13 +1,12 @@
 package io.github.resilience4j.retry;
 
+import io.vavr.collection.List;
+import io.vavr.control.Try;
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 
 import java.time.Duration;
 
-import javaslang.collection.List;
-import javaslang.control.Try;
-
 public class IntervalFunctionTest {
 
     @Test

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerEventsEndpoint.java
Patch:
@@ -30,7 +30,7 @@
 import io.github.resilience4j.consumer.EventConsumer;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 import io.reactivex.Flowable;
-import javaslang.collection.Seq;
+import io.vavr.collection.Seq;
 
 import java.util.Comparator;
 

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/ratelimiter/monitoring/endpoint/RateLimiterEventsEndpoint.java
Patch:
@@ -31,7 +31,7 @@
 import io.github.resilience4j.ratelimiter.monitoring.model.RateLimiterEventDTO;
 import io.github.resilience4j.ratelimiter.monitoring.model.RateLimiterEventsEndpointResponse;
 import io.reactivex.Flowable;
-import javaslang.collection.Seq;
+import io.vavr.collection.Seq;
 
 import java.util.Comparator;
 import java.util.List;

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreaker.java
Patch:
@@ -292,9 +292,9 @@ interface Metrics {
         int getMaxNumberOfBufferedCalls();
 
         /**
-         * Returns the maximum number of successful calls.
+         * Returns the current number of successful calls.
          *
-         * @return the maximum number of successful calls
+         * @return the current number of successful calls
          */
         int getNumberOfSuccessfulCalls();
     }

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterAutoConfigurationTest.java
Patch:
@@ -68,7 +68,7 @@ public void testRateLimiterAutoConfiguration() throws IOException {
         RateLimiter rateLimiter = rateLimiterRegistry.rateLimiter(DummyService.BACKEND);
         assertThat(rateLimiter).isNotNull();
         await()
-            .atMost(1, TimeUnit.SECONDS)
+            .atMost(2, TimeUnit.SECONDS)
             .until(() -> rateLimiter.getMetrics().getAvailablePermissions() == 10);
 
         try {
@@ -109,7 +109,7 @@ public void testRateLimiterAutoConfiguration() throws IOException {
         assertThat(lastEvent.getRateLimiterEventType()).isEqualTo(RateLimiterEvent.Type.FAILED_ACQUIRE);
 
         await()
-            .atMost(1, TimeUnit.SECONDS)
+            .atMost(2, TimeUnit.SECONDS)
             .until(() -> rateLimiter.getMetrics().getAvailablePermissions() == 10);
     }
 }

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/ratelimiter/RateLimiterAutoConfigurationTest.java
Patch:
@@ -68,7 +68,7 @@ public void testRateLimiterAutoConfiguration() throws IOException {
         RateLimiter rateLimiter = rateLimiterRegistry.rateLimiter(DummyService.BACKEND);
         assertThat(rateLimiter).isNotNull();
         await()
-            .atMost(1, TimeUnit.SECONDS)
+            .atMost(2, TimeUnit.SECONDS)
             .until(() -> rateLimiter.getMetrics().getAvailablePermissions() == 10);
 
         try {
@@ -109,7 +109,7 @@ public void testRateLimiterAutoConfiguration() throws IOException {
         assertThat(lastEvent.getRateLimiterEventType()).isEqualTo(RateLimiterEvent.Type.FAILED_ACQUIRE);
 
         await()
-            .atMost(1, TimeUnit.SECONDS)
+            .atMost(2, TimeUnit.SECONDS)
             .until(() -> rateLimiter.getMetrics().getAvailablePermissions() == 10);
     }
 }

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerAspect.java
Patch:
@@ -36,7 +36,7 @@
 @Aspect
 public class CircuitBreakerAspect {
 
-    private static Logger logger = LoggerFactory.getLogger(CircuitBreakerAspect.class);
+    private static final Logger logger = LoggerFactory.getLogger(CircuitBreakerAspect.class);
 
     private final CircuitBreakerProperties circuitBreakerProperties;
     private final CircuitBreakerRegistry circuitBreakerRegistry;

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerAutoConfiguration.java
Patch:
@@ -60,10 +60,9 @@ public CircuitBreakerEndpoint circuitBreakerEndpoint(CircuitBreakerRegistry circ
     }
 
     @Bean
-    public CircuitBreakerEventsEndpoint circuitBreakerEventsEndpoint(CircuitBreakerEndpoint circuitBreakerEndpoint,
-                                                                     EventConsumerRegistry<CircuitBreakerEvent> eventConsumerRegistry,
+    public CircuitBreakerEventsEndpoint circuitBreakerEventsEndpoint(EventConsumerRegistry<CircuitBreakerEvent> eventConsumerRegistry,
                                                                      CircuitBreakerRegistry circuitBreakerRegistry) {
-        return new CircuitBreakerEventsEndpoint(circuitBreakerEndpoint, eventConsumerRegistry, circuitBreakerRegistry);
+        return new CircuitBreakerEventsEndpoint(eventConsumerRegistry, circuitBreakerRegistry);
     }
 
     /**

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/service/test/DummyService.java
Patch:
@@ -1,4 +1,4 @@
-package io.github.resilience4j.circuitbreaker.test;
+package io.github.resilience4j.service.test;
 
 
 import java.io.IOException;

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/service/test/DummyServiceImpl.java
Patch:
@@ -1,13 +1,15 @@
-package io.github.resilience4j.circuitbreaker.test;
+package io.github.resilience4j.service.test;
 
 
 import org.springframework.stereotype.Component;
 
 import java.io.IOException;
 
 import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
+import io.github.resilience4j.ratelimiter.annotation.RateLimiter;
 
 @CircuitBreaker(backend = DummyService.BACKEND)
+@RateLimiter(name = DummyService.BACKEND)
 @Component
 public class DummyServiceImpl implements DummyService {
     @Override

File: resilience4j-circuitbreaker/src/jcstress/java/io/github/resilience4j/circuitbreaker/concurrent/ConcurrentCircuitBreakerTest.java
Patch:
@@ -71,12 +71,12 @@ public ConcurrentCircuitBreakerTest() {
 
     @Actor
     public void firstActor() {
-        circuitBreaker.onError(Duration.ZERO, new RuntimeException());
+        circuitBreaker.onError(0, new RuntimeException());
     }
 
     @Actor
     public void secondActor() {
-        circuitBreaker.onError(Duration.ZERO, new RuntimeException());
+        circuitBreaker.onError(0, new RuntimeException());
     }
 
     @Arbiter

File: resilience4j-retrofit/src/main/java/io/github/resilience4j/retrofit/RetrofitCircuitBreaker.java
Patch:
@@ -57,15 +57,15 @@ public Response<T> execute() throws IOException {
                     final Response<T> response = call.execute();
 
                     if (responseSuccess.test(response)) {
-                        circuitBreaker.onSuccess(stopWatch.stop().getProcessingDuration());
+                        circuitBreaker.onSuccess(stopWatch.stop().getProcessingDuration().toNanos());
                     } else {
                         final Throwable throwable = new Throwable("Response error: HTTP " + response.code() + " - " + response.message());
-                        circuitBreaker.onError(stopWatch.stop().getProcessingDuration(), throwable);
+                        circuitBreaker.onError(stopWatch.stop().getProcessingDuration().toNanos(), throwable);
                     }
 
                     return response;
                 } catch (Throwable throwable) {
-                    circuitBreaker.onError(stopWatch.stop().getProcessingDuration(), throwable);
+                    circuitBreaker.onError(stopWatch.stop().getProcessingDuration().toNanos(), throwable);
                     throw throwable;
                 }
             }

File: resilience4j-vertx/src/test/java/io/github/resilience4j/circuitbreaker/VertxCircuitBreakerTest.java
Patch:
@@ -132,8 +132,8 @@ public void shouldReturnFailureWithCircuitBreakerOpenException() {
         // Create a CircuitBreakerRegistry with a custom global configuration
         CircuitBreaker circuitBreaker = CircuitBreaker.of("testName", circuitBreakerConfig);
 
-        circuitBreaker.onError(Duration.ZERO, new RuntimeException());
-        circuitBreaker.onError(Duration.ZERO, new RuntimeException());
+        circuitBreaker.onError(0, new RuntimeException());
+        circuitBreaker.onError(0, new RuntimeException());
         assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.OPEN);
         CircuitBreaker.Metrics metrics = circuitBreaker.getMetrics();
         assertThat(metrics.getNumberOfBufferedCalls()).isEqualTo(2);

File: resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/SemaphoreBasedRateLimiterImplTest.java
Patch:
@@ -185,7 +185,8 @@ public void getPermissionInterruption() throws Exception {
 
         awaitImpatiently()
             .atMost(2, TimeUnit.SECONDS).until(thread::getState, equalTo(RUNNABLE));
-        then(thread.isInterrupted()).isTrue();
+        awaitImpatiently()
+            .atMost(100, TimeUnit.MILLISECONDS).until(thread::isInterrupted);
 
         ArrayList<String> eventStrings = events.get();
         then(eventStrings.get(0)).contains("type=SUCCESSFUL_ACQUIRE");

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/CircuitBreakerTransformer.java
Patch:
@@ -37,7 +37,7 @@ private CircuitBreakerTransformer(CircuitBreaker circuitBreaker) {
      * for the circuit breaker are exceeded.
      *
      * @param circuitBreaker the circuit breaker to use
-     * @param <T> the type of object
+     * @param <T>            the type of object
      * @return the transformer
      */
     public static <T> CircuitBreakerTransformer<T> of(CircuitBreaker circuitBreaker) {

File: resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/Resilience4jModule.java
Patch:
@@ -24,7 +24,7 @@
 import io.github.resilience4j.ratpack.internal.RateLimiterMethodInterceptor;
 import io.github.resilience4j.ratpack.internal.RetryMethodInterceptor;
 
-public class ResilienceModule extends AbstractModule {
+public class Resilience4jModule extends AbstractModule {
 
     @Override
     protected void configure() {

File: resilience4j-retrofit/src/main/java/io/github/resilience4j/retrofit/CircuitBreakerCallAdapter.java
Patch:
@@ -31,7 +31,7 @@
 
 /**
  * Creates a Retrofit {@link CallAdapter.Factory} that decorates a Call to provide integration with a
- * {@link CircuitBreaker} using {@link RetrofitCircuitBreaker}
+ * {@link CircuitBreaker}
  */
 public final class CircuitBreakerCallAdapter extends CallAdapter.Factory {
 
@@ -84,8 +84,7 @@ public <R> Call<R> adapt(Call<R> call) {
 
     private static Type getCallResponseType(Type returnType) {
         if (!(returnType instanceof ParameterizedType)) {
-            throw new IllegalArgumentException(
-                    "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+            throw new IllegalArgumentException("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
         }
         return getParameterUpperBound(0, (ParameterizedType) returnType);
     }

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/RetryContext.java
Patch:
@@ -91,7 +91,7 @@ private void throwOrSleepAfterException() throws Exception {
         }
     }
 
-    public void throwOrSleepAfterRuntimeException(){
+    private void throwOrSleepAfterRuntimeException(){
         int currentNumOfAttempts = numOfAttempts.incrementAndGet();
         if(currentNumOfAttempts >= maxAttempts){
             RuntimeException throwable = lastRuntimeException.get();

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/event/RetryEvent.java
Patch:
@@ -30,7 +30,7 @@ public interface RetryEvent {
      *
      * @return the ID of the Retry
      */
-    String getId();
+    String getName();
 
     /**
      * Returns the number of attempts.

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/event/RetryOnErrorEvent.java
Patch:
@@ -23,8 +23,8 @@
  */
 public class RetryOnErrorEvent extends AbstractRetryEvent {
 
-    public RetryOnErrorEvent(String id, int numberOfAttempts, Throwable lastThrowable) {
-        super(id, numberOfAttempts, lastThrowable);
+    public RetryOnErrorEvent(String name, int numberOfAttempts, Throwable lastThrowable) {
+        super(name, numberOfAttempts, lastThrowable);
     }
     @Override
     public Type getEventType() {
@@ -35,7 +35,7 @@ public Type getEventType() {
     public String toString() {
         return String.format("%s: Retry '%s' recorded a failed retry attempt. Number of retry attempts: '%d', Last exception was: '%s'.",
                 getCreationTime(),
-                getId(),
+                getName(),
                 getNumberOfAttempts(),
                 getLastThrowable().toString());
     }

File: resilience4j-retry/src/main/java/io/github/resilience4j/retry/event/RetryOnSuccessEvent.java
Patch:
@@ -23,8 +23,8 @@
  */
 public class RetryOnSuccessEvent extends AbstractRetryEvent {
 
-    public RetryOnSuccessEvent(String id, int currentNumOfAttempts, Throwable lastThrowable) {
-        super(id, currentNumOfAttempts, lastThrowable);
+    public RetryOnSuccessEvent(String name, int currentNumOfAttempts, Throwable lastThrowable) {
+        super(name, currentNumOfAttempts, lastThrowable);
     }
 
     @Override
@@ -36,7 +36,7 @@ public Type getEventType() {
     public String toString() {
         return String.format("%s: Retry '%s' recorded a successful retry attempt. Number of retry attempts: '%d', Last exception was: '%s'.",
                 getCreationTime(),
-                getId(),
+                getName(),
                 getNumberOfAttempts(),
                 getLastThrowable().toString());
     }

File: resilience4j-retry/src/test/java/io/github/resilience4j/retry/RetryRegistryTest.java
Patch:
@@ -35,7 +35,7 @@ public void setUp() {
     public void shouldReturnTheCorrectName() {
         Retry retry = retryRegistry.retry("testName");
         Assertions.assertThat(retry).isNotNull();
-        Assertions.assertThat(retry.getId()).isEqualTo("testName");
+        Assertions.assertThat(retry.getName()).isEqualTo("testName");
     }
 
     @Test

File: resilience4j-retry/src/test/java/io/github/resilience4j/retry/event/RetryEventTest.java
Patch:
@@ -31,7 +31,7 @@ public class RetryEventTest {
     public void testRetryOnErrorEvent() {
         RetryOnErrorEvent retryOnErrorEvent = new RetryOnErrorEvent("test", 2,
                 new IOException());
-        Assertions.assertThat(retryOnErrorEvent.getId()).isEqualTo("test");
+        Assertions.assertThat(retryOnErrorEvent.getName()).isEqualTo("test");
         Assertions.assertThat(retryOnErrorEvent.getNumberOfAttempts()).isEqualTo(2);
         Assertions.assertThat(retryOnErrorEvent.getEventType()).isEqualTo(Type.ERROR);
         Assertions.assertThat(retryOnErrorEvent.getLastThrowable()).isInstanceOf(IOException.class);
@@ -42,7 +42,7 @@ public void testRetryOnErrorEvent() {
     public void testRetryOnSuccessEvent() {
         RetryOnSuccessEvent retryOnSuccessEvent = new RetryOnSuccessEvent("test", 2,
                 new IOException());
-        Assertions.assertThat(retryOnSuccessEvent.getId()).isEqualTo("test");
+        Assertions.assertThat(retryOnSuccessEvent.getName()).isEqualTo("test");
         Assertions.assertThat(retryOnSuccessEvent.getNumberOfAttempts()).isEqualTo(2);
         Assertions.assertThat(retryOnSuccessEvent.getEventType()).isEqualTo(Type.SUCCESS);
         Assertions.assertThat(retryOnSuccessEvent.getLastThrowable()).isInstanceOf(IOException.class);

File: resilience4j-prometheus/src/main/java/io/github/resilience4j/prometheus/CircuitBreakerExports.java
Patch:
@@ -40,7 +40,7 @@
  */
 public class CircuitBreakerExports extends Collector {
 
-    private static final String DEFAULT_NAME = "circuit_breaker";
+    private static final String DEFAULT_NAME = "resilience4j_circuitbreaker";
     private static Array<Tuple2<CircuitBreaker.State, String>> STATE_NAME_MAP =
             Array.ofAll(asList(CircuitBreaker.State.values()))
                 .map(state -> Tuple.of(state, state.name().toLowerCase()));

File: resilience4j-prometheus/src/main/java/io/github/resilience4j/prometheus/RateLimiterExports.java
Patch:
@@ -36,7 +36,7 @@
  * {@link io.prometheus.client.CollectorRegistry}.
  */
 public class RateLimiterExports extends Collector {
-    private static final String DEFAULT_NAME = "rate_limiter";
+    private static final String DEFAULT_NAME = "resilience4j_ratelimiter";
 
     private final String name;
     private final Supplier<Iterable<RateLimiter>> rateLimitersSupplier;

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerAutoConfiguration.java
Patch:
@@ -31,7 +31,7 @@
 
 /**
  * {@link org.springframework.boot.autoconfigure.EnableAutoConfiguration
- * Auto-configuration} for resilience4j circuitbreaker.
+ * Auto-configuration} for resilience4j-circuitbreaker.
  */
 @Configuration
 @ConditionalOnClass(CircuitBreaker.class)

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/CircuitBreaker.java
Patch:
@@ -1,6 +1,6 @@
 /*
  *
- *  Copyright 2016 Robert Winkler
+ *  Copyright 2017: Robert Winkler
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -29,7 +29,7 @@
 import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;
 import io.github.resilience4j.circuitbreaker.internal.CircuitBreakerStateMachine;
 import io.github.resilience4j.circuitbreaker.utils.CircuitBreakerUtils;
-import io.github.resilience4j.metrics.StopWatch;
+import io.github.resilience4j.core.StopWatch;
 import io.reactivex.Flowable;
 import javaslang.control.Try;
 

File: resilience4j-circuitbreaker/src/main/java/io/github/resilience4j/circuitbreaker/operator/CircuitBreakerOperator.java
Patch:
@@ -1,6 +1,6 @@
 /*
  *
- *  Copyright 2016 Robert Winkler
+ *  Copyright 2017: Robert Winkler
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -28,7 +28,7 @@
 
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
 import io.github.resilience4j.circuitbreaker.CircuitBreakerOpenException;
-import io.github.resilience4j.metrics.StopWatch;
+import io.github.resilience4j.core.StopWatch;
 import io.reactivex.FlowableOperator;
 import io.reactivex.ObservableOperator;
 import io.reactivex.Observer;

File: resilience4j-core/src/main/java/io/github/resilience4j/core/StopWatch.java
Patch:
@@ -1,6 +1,6 @@
 /*
  *
- *  Copyright 2016 Robert Winkler
+ *  Copyright 2017: Robert Winkler
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -16,7 +16,7 @@
  *
  *
  */
-package io.github.resilience4j.metrics;
+package io.github.resilience4j.core;
 
 import java.time.Duration;
 
@@ -26,7 +26,7 @@
 public class StopWatch {
 
     private final String id;
-    private long startTime;
+    private final long startTime;
     private long elapsedTime;
 
     private StopWatch(String id){

File: resilience4j-core/src/test/java/io/github/resilience4j/core/StopWatchTest.java
Patch:
@@ -1,6 +1,6 @@
 /*
  *
- *  Copyright 2016 Robert Winkler
+ *  Copyright 2017: Robert Winkler
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -16,7 +16,7 @@
  *
  *
  */
-package io.github.resilience4j.metrics;
+package io.github.resilience4j.core;
 
 import org.assertj.core.api.Assertions;
 import org.junit.Test;

File: resilience4j-vertx/src/main/java/io/github/resilience4j/circuitbreaker/VertxCircuitBreaker.java
Patch:
@@ -1,6 +1,6 @@
 /*
  *
- *  Copyright 2016 Robert Winkler
+ *  Copyright 2017: Robert Winkler
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -21,7 +21,7 @@
 import java.time.Duration;
 import java.util.function.Supplier;
 
-import io.github.resilience4j.metrics.StopWatch;
+import io.github.resilience4j.core.StopWatch;
 import io.vertx.core.Future;
 
 /**

File: resilience4j-retrofit/src/main/java/io/github/resilience4j/retrofit/RetrofitCircuitBreaker.java
Patch:
@@ -16,7 +16,7 @@
  * All exceptions are marked as errors or responses not matching the supplied predicate.  For example:
  * <p>
  * <code>
- * RetrofitCircuitBreaker.decorateCall(circuitBreaker, call, (r) -> r.isSuccessful());
+ * RetrofitCircuitBreaker.decorateCall(circuitBreaker, call, Response::isSuccessful);
  * </code>
  */
 public interface RetrofitCircuitBreaker {

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerEventsEndpoint.java
Patch:
@@ -73,7 +73,7 @@ public CircuitBreakerEventsEndpointResponse getEventsFilteredByCircuitBreakerNam
                 .map(CircuitBreakerEventDTOFactory::createCircuitBreakerEventDTO).toJavaList());
     }
 
-    @RequestMapping(value = "stream/events", produces = MEDIA_TYPE_TEXT_EVENT_STREAM)
+    @RequestMapping(value = "stream/events/{circuitBreakerName}", produces = MEDIA_TYPE_TEXT_EVENT_STREAM)
     public SseEmitter getEventsStreamFilteredByCircuitBreakerName(@PathVariable("circuitBreakerName") String circuitBreakerName) {
         CircuitBreaker circuitBreaker = circuitBreakerRegistry.getAllCircuitBreakers()
                 .find(cb -> cb.getName().equals(circuitBreakerName))

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerAutoConfiguration.java
Patch:
@@ -56,8 +56,9 @@ public CircuitBreakerEndpoint circuitBreakerEndpoint(CircuitBreakerRegistry circ
 
     @Bean
     public CircuitBreakerEventsEndpoint circuitBreakerEventsEndpoint(CircuitBreakerEndpoint circuitBreakerEndpoint,
-                                                                     EventConsumerRegistry<CircuitBreakerEvent> eventConsumerRegistry) {
-        return new CircuitBreakerEventsEndpoint(circuitBreakerEndpoint, eventConsumerRegistry);
+                                                                     EventConsumerRegistry<CircuitBreakerEvent> eventConsumerRegistry,
+                                                                     CircuitBreakerRegistry circuitBreakerRegistry) {
+        return new CircuitBreakerEventsEndpoint(circuitBreakerEndpoint, eventConsumerRegistry, circuitBreakerRegistry);
     }
 
     /**

File: resilience4j-spring-boot/src/test/java/io/github/resilience4j/circuitbreaker/CircuitBreakerAutoConfigurationTest.java
Patch:
@@ -32,6 +32,7 @@
 import io.github.resilience4j.circuitbreaker.autoconfigure.CircuitBreakerProperties;
 import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;
 import io.github.resilience4j.circuitbreaker.monitoring.endpoint.CircuitBreakerEndpointResponse;
+import io.github.resilience4j.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;
 import io.github.resilience4j.circuitbreaker.monitoring.health.CircuitBreakerHealthIndicator;
 import io.github.resilience4j.circuitbreaker.test.DummyService;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
@@ -88,10 +89,9 @@ public void testCircuitBreakerAutoConfiguration() throws IOException {
         ResponseEntity<CircuitBreakerEndpointResponse> circuitBreakerList = restTemplate.getForEntity("/circuitbreaker", CircuitBreakerEndpointResponse.class);
         assertThat(circuitBreakerList.getBody().getCircuitBreakers()).hasSize(2).containsExactly("backendA", "backendB");
 
-        /*
+
         ResponseEntity<CircuitBreakerEventsEndpointResponse> circuitBreakerEventList = restTemplate.getForEntity("/circuitbreaker/events", CircuitBreakerEventsEndpointResponse.class);
-        assertThat(circuitBreakerEventList.getBody().getCircuitBreakerEvents()).hasSize(21);
-        */
+        assertThat(circuitBreakerEventList.getBody().getCircuitBreakerEvents()).hasSize(2);
     }
 
     @SpringBootApplication

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerEndpoint.java
Patch:
@@ -40,9 +40,9 @@ public CircuitBreakerEndpoint(CircuitBreakerRegistry circuitBreakerRegistry) {
     }
 
     @Override
-    public ResponseEntity<List<String>> invoke() {
+    public ResponseEntity<CircuitBreakerEndpointResponse> invoke() {
         List<String> circuitBreakers = circuitBreakerRegistry.getAllCircuitBreakers()
                 .map(CircuitBreaker::getName).sorted().toJavaList();
-        return ResponseEntity.ok(circuitBreakers);
+        return ResponseEntity.ok(new CircuitBreakerEndpointResponse(circuitBreakers));
     }
 }

File: resilience4j-spring-boot/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/health/CircuitBreakerHealthIndicator.java
Patch:
@@ -28,6 +28,9 @@
 import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;
 import io.github.resilience4j.consumer.EventConsumerRegistry;
 
+/**
+ * A Spring Boot health indicators which adds the state of a CircuitBreaker and it's metrics to the health endpoints
+ */
 public class CircuitBreakerHealthIndicator implements HealthIndicator {
 
     private static final String FAILURE_RATE = "failureRate";

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/SemaphoreBasedRateLimiter.java
Patch:
@@ -105,7 +105,8 @@ private void scheduleLimitRefresh() {
     }
 
     void refreshLimit() {
-        semaphore.release(this.rateLimiterConfig.getLimitForPeriod());
+        int permissionsToRelease = this.rateLimiterConfig.getLimitForPeriod() - semaphore.availablePermits();
+        semaphore.release(permissionsToRelease);
     }
 
     /**

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/SemaphoreBasedRateLimiter.java
Patch:
@@ -105,7 +105,8 @@ private void scheduleLimitRefresh() {
     }
 
     void refreshLimit() {
-        semaphore.release(this.rateLimiterConfig.getLimitForPeriod());
+        int permissionsToRelease = this.rateLimiterConfig.getLimitForPeriod() - semaphore.availablePermits();
+        semaphore.release(permissionsToRelease);
     }
 
     /**

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/AtomicRateLimiter.java
Patch:
@@ -66,7 +66,7 @@ public AtomicRateLimiter(String name, RateLimiterConfig rateLimiterConfig) {
         permissionsPerCycle = rateLimiterConfig.getLimitForPeriod();
 
         waitingThreads = new AtomicInteger(0);
-        state = new AtomicReference<>(new State(0, 0, 0));
+        state = new AtomicReference<>(new State(0, permissionsPerCycle, 0));
 
         PublishProcessor<RateLimiterEvent> publisher = PublishProcessor.create();
         this.eventPublisher = publisher.toSerialized();

File: resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/AtomicRateLimiter.java
Patch:
@@ -66,7 +66,7 @@ public AtomicRateLimiter(String name, RateLimiterConfig rateLimiterConfig) {
         permissionsPerCycle = rateLimiterConfig.getLimitForPeriod();
 
         waitingThreads = new AtomicInteger(0);
-        state = new AtomicReference<>(new State(0, 0, 0));
+        state = new AtomicReference<>(new State(0, permissionsPerCycle, 0));
 
         PublishProcessor<RateLimiterEvent> publisher = PublishProcessor.create();
         this.eventPublisher = publisher.toSerialized();

File: src/main/java/io/github/robwin/circularbuffer/CircularFifoBuffer.java
Patch:
@@ -59,6 +59,7 @@ public interface CircularFifoBuffer<T> {
      * Adds element to the {@link CircularFifoBuffer}
      * and overwrites the oldest element when {@link CircularFifoBuffer#isFull}.
      *
+     * @param element to add
      * @throws NullPointerException if the specified element is null
      */
     void add(T element);

File: src/main/java/io/github/robwin/circularbuffer/ConcurrentEvictingQueue.java
Patch:
@@ -196,11 +196,9 @@ public void clear() {
     /**
      * Returns an array containing all of the elements in this queue, in
      * proper sequence.
-     * <p>
      * <p>The returned array will be "safe" in that no references to it are
      * maintained by this queue.  (In other words, this method must allocate
      * a new array).  The caller is free to modify the returned array.
-     * <p>
      * <p>This method acts as bridge between array-based and collection-based
      * APIs.
      *

File: src/main/java/io/github/robwin/ratelimiter/internal/AtomicRateLimiter.java
Patch:
@@ -40,12 +40,10 @@
 /**
  * {@link AtomicRateLimiter} splits all nanoseconds from the start of epoch into cycles.
  * <p>Each cycle has duration of {@link RateLimiterConfig#limitRefreshPeriod} in nanoseconds.
- * <p>
  * <p>By contract on start of each cycle {@link AtomicRateLimiter} should
  * set {@link State#activePermissions} to {@link RateLimiterConfig#limitForPeriod}.
  * For the {@link AtomicRateLimiter} callers it is really looks so, but under the hood there is
  * some optimisations that will skip this refresh if {@link AtomicRateLimiter} is not used actively.
- * <p>
  * <p>All {@link AtomicRateLimiter} updates are atomic and state is encapsulated in {@link AtomicReference} to
  * {@link AtomicRateLimiter.State}
  */

File: src/main/java/io/github/robwin/retry/AsyncRetry.java
Patch:
@@ -26,6 +26,7 @@ public interface AsyncRetry {
 
     /**
      * Records an failed call.
+     * @param throwable the exception to handle
      * @return delay in milliseconds until the next try
      */
     long onError(Throwable throwable);

File: src/main/java/io/github/robwin/retry/RetryConfig.java
Patch:
@@ -92,6 +92,7 @@ public RetryConfig.Builder waitDuration(Duration waitDuration) {
          * the same.
          *
          * @param f Function to modify the interval after a failure
+         * @return the CircuitBreakerConfig.Builder
          */
         public RetryConfig.Builder intervalFunction(IntervalFunction f) {
             config.intervalFunction = f;

File: src/test/java/io/github/robwin/metrics/StopWatchTest.java
Patch:
@@ -35,6 +35,6 @@ public void testStopWatch() throws InterruptedException {
         Thread.sleep(100);
         Duration duration = watch.stop().getProcessingDuration();
         LOG.info(watch.toString());
-        Assertions.assertThat(duration.toMillis()).isGreaterThanOrEqualTo(100).isLessThan(110);
+        Assertions.assertThat(duration.toMillis()).isGreaterThanOrEqualTo(90).isLessThan(110);
     }
 }

File: src/main/java/io/github/robwin/consumer/CircularEventConsumer.java
Patch:
@@ -20,13 +20,12 @@
 
 import io.github.robwin.circularbuffer.CircularFifoBuffer;
 import io.github.robwin.circularbuffer.ConcurrentCircularFifoBuffer;
-import io.reactivex.functions.Consumer;
 import javaslang.collection.List;
 
 /**
  * A RxJava consumer which stores CircuitBreakerEvents in a circular buffer with a fixed capacity.
  */
-public class CircularEventConsumer<T> implements Consumer<T>{
+public class CircularEventConsumer<T> implements EventConsumer<T>{
 
     private CircularFifoBuffer<T> eventCircularFifoBuffer;
 
@@ -51,6 +50,7 @@ public void accept(T event) throws Exception {
      *
      * @return a list containing all of the buffered events.
      */
+    @Override
     public List<T> getBufferedEvents(){
         return eventCircularFifoBuffer.toList();
     }

File: src/test/java/io/github/robwin/circuitbreaker/CircuitBreakerRegistryTest.java
Patch:
@@ -18,8 +18,6 @@
  */
 package io.github.robwin.circuitbreaker;
 
-import io.github.robwin.circuitbreaker.CircuitBreaker;
-import io.github.robwin.circuitbreaker.CircuitBreakerRegistry;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -47,12 +45,15 @@ public void shouldBeTheSameCircuitBreaker() {
         CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("testName");
         CircuitBreaker circuitBreaker2 = circuitBreakerRegistry.circuitBreaker("testName");
         assertThat(circuitBreaker).isSameAs(circuitBreaker2);
+        assertThat(circuitBreakerRegistry.getAllCircuitBreakers()).hasSize(1);
     }
 
     @Test
     public void shouldBeNotTheSameCircuitBreaker() {
         CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("testName");
         CircuitBreaker circuitBreaker2 = circuitBreakerRegistry.circuitBreaker("otherTestName");
         assertThat(circuitBreaker).isNotSameAs(circuitBreaker2);
+
+        assertThat(circuitBreakerRegistry.getAllCircuitBreakers()).hasSize(2);
     }
 }

File: src/main/java/io/github/robwin/circuitbreaker/internal/BitSetMod.java
Patch:
@@ -76,7 +76,6 @@ int size() {
     boolean get(int bitIndex) {
         int wordIndex = wordIndex(bitIndex);
         long bitMask = 1L << bitIndex;
-        boolean bitValue = (words[wordIndex] & bitMask) != 0;
-        return bitValue;
+        return (words[wordIndex] & bitMask) != 0;
     }
 }
\ No newline at end of file

File: src/main/java/io/github/robwin/circuitbreaker/internal/CircuitBreakerStateMachine.java
Patch:
@@ -162,7 +162,7 @@ public void transitionToClosedState() {
             if (currentState.getState() == CLOSED) {
                 return currentState;
             }
-            return new ClosedState(this);
+            return new ClosedState(this, currentState.getMetrics());
         });
         if (previousState.getState() != CLOSED) {
             publishStateTransitionEvent(StateTransition.transitionToClosedState(previousState.getState()));

File: src/test/java/io/github/robwin/circuitbreaker/internal/RingBitSetTest.java
Patch:
@@ -134,7 +134,7 @@ public void testRingBitSetCopyFromTheSameSize() {
         RingBitSet setCopy = new RingBitSet(4, sourceSet);
 
         assertThat(setCopy.getIndex()).isEqualTo(3);
-        assertThat(setCopy.toString()).isEqualTo("0110");
+        assertThat(setCopy.toString()).isEqualTo("0011");
 
         assertThat(setCopy.cardinality()).isEqualTo(2);
 
@@ -185,9 +185,9 @@ public void testRingBitSetCopyFromTheLongerSet() {
         RingBitSet setCopy = new RingBitSet(4, sourceSet);
 
         assertThat(setCopy.getIndex()).isEqualTo(3);
-        assertThat(setCopy.toString()).isEqualTo("1110");
+        assertThat(setCopy.toString()).isEqualTo("1001");
 
-        assertThat(setCopy.cardinality()).isEqualTo(3);
+        assertThat(setCopy.cardinality()).isEqualTo(2);
 
         // The size is 64-bit, because the bits are stored in an array of one long value
         assertThat(setCopy.size()).isEqualTo(64);

File: src/main/java/io/github/robwin/cache/event/CacheOnErrorEvent.java
Patch:
@@ -19,7 +19,7 @@
 package io.github.robwin.cache.event;
 
 /**
- * A CacheEvent which informs about an exception
+ * A CacheEvent which informs that accessing the cache has caused an exception.
  */
 public class CacheOnErrorEvent extends AbstractCacheEvent {
 

File: src/main/java/io/github/robwin/cache/event/CacheOnHitEvent.java
Patch:
@@ -19,7 +19,7 @@
 package io.github.robwin.cache.event;
 
 /**
- * A CacheEvent which informs about a cache hit
+ * A CacheEvent which informs about a cache hit.
  */
 public class CacheOnHitEvent<K> extends AbstractCacheEvent {
 

File: src/main/java/io/github/robwin/cache/event/CacheOnMissEvent.java
Patch:
@@ -19,7 +19,7 @@
 package io.github.robwin.cache.event;
 
 /**
- * A CacheEvent which informs about a cache hit
+ * A CacheEvent which informs about a cache miss.
  */
 public class CacheOnMissEvent<K> extends AbstractCacheEvent {
 

File: src/test/java/io/github/robwin/cache/event/CacheEventTest.java
Patch:
@@ -51,7 +51,7 @@ public void testCacheOnMissEvent() {
                 "testKey");
         assertThat(cacheOnMissEvent.getCacheName()).isEqualTo("test");
         assertThat(cacheOnMissEvent.getCacheKey()).isEqualTo("testKey");
-        assertThat(cacheOnMissEvent.getEventType()).isEqualTo(Type.CACHE_HIT);
+        assertThat(cacheOnMissEvent.getEventType()).isEqualTo(Type.CACHE_MISS);
     }
 
 }

File: src/main/java/io/github/robwin/circuitbreaker/CircuitBreaker.java
Patch:
@@ -230,11 +230,12 @@ interface Metrics {
         int getNumberOfFailedCalls();
 
         /**
-         * Returns the current number of denied calls.
+         * Returns the current number of not permitted calls, when the state is OPEN.
+         *
          * The number of denied calls is always 0, when the CircuitBreaker state is CLOSED or HALF_OPEN.
          * The number of denied calls is only increased when the CircuitBreaker state is OPEN.
          *
-         * @return the current number of denied calls
+         * @return the current number of not permitted calls
          */
         long getNumberOfNotPermittedCalls();
 

File: src/main/java/io/github/robwin/circuitbreaker/event/CircuitBreakerEvent.java
Patch:
@@ -56,7 +56,9 @@ enum Type {
         IGNORED_ERROR,
         /** A CircuitBreakerEvent which informs that a success has been recorded */
         SUCCESS,
+        /** A CircuitBreakerEvent which informs that a call was not permitted because the CircuitBreaker state is OPEN */
+        NOT_PERMITTED,
         /** A CircuitBreakerEvent which informs the state of the CircuitBreaker has been changed */
-        STATE_TRANSITION
+        STATE_TRANSITION;
     }
 }

File: src/test/java/io/github/robwin/circuitbreaker/internal/CircuitBreakerMetricsTest.java
Patch:
@@ -33,10 +33,13 @@ public void testDefaultCircuitBreakerMetrics(){
         circuitBreakerMetrics.onSuccess();
         circuitBreakerMetrics.onError();
         circuitBreakerMetrics.onError();
+        circuitBreakerMetrics.onCallNotPermitted();
+        circuitBreakerMetrics.onCallNotPermitted();
 
         assertThat(circuitBreakerMetrics.getNumberOfBufferedCalls()).isEqualTo(4);
         assertThat(circuitBreakerMetrics.getNumberOfFailedCalls()).isEqualTo(2);
         assertThat(circuitBreakerMetrics.getNumberOfSuccessfulCalls()).isEqualTo(2);
+        assertThat(circuitBreakerMetrics.getNumberOfNotPermittedCalls()).isEqualTo(2);
 
         // The failure rate must be -1, because the number of measured calls is below the buffer size of 10
         assertThat(circuitBreakerMetrics.getFailureRate()).isEqualTo(-1);

File: src/main/java/io/github/robwin/circuitbreaker/CircuitBreaker.java
Patch:
@@ -86,11 +86,11 @@ public interface CircuitBreaker {
     void transitionToOpenState();
 
     /**
-     * Transitions the state machine to HALF_COSED state.
+     * Transitions the state machine to HALF_OPEN state.
      *
      * Should only be used, when you want to force a state transition. State transition are normally done internally.
      */
-    void transitionToHalfClosedState();
+    void transitionToHalfOpenState();
 
     /**
      * Returns the name of this CircuitBreaker.

File: src/main/java/io/github/robwin/circuitbreaker/internal/OpenState.java
Patch:
@@ -43,7 +43,7 @@ final class OpenState extends CircuitBreakerState {
     boolean isCallPermitted() {
         // Thread-safe
         if (Instant.now().isAfter(retryAfterWaitDuration)) {
-            stateMachine.transitionToHalfClosedState();
+            stateMachine.transitionToHalfOpenState();
             return true;
         }
         return false;

File: src/main/java/io/github/robwin/circuitbreaker/CircuitBreaker.java
Patch:
@@ -175,7 +175,7 @@ public static StateTransition transitionToClosedState(State fromState){
                 case OPEN:
                     return FORCED_OPEN_TO_CLOSED;
                 default:
-                    throw new IllegalStateException("Illegal state transition");
+                    throw new IllegalStateException(String.format("Illegal state transition from %s to %s", fromState.toString(), State.CLOSED.toString()));
             }
         }
 
@@ -186,7 +186,7 @@ public static StateTransition transitionToOpenState(State fromState){
                 case CLOSED:
                     return CLOSED_TO_OPEN;
                 default:
-                    throw new IllegalStateException("Illegal state transition");
+                    throw new IllegalStateException(String.format("Illegal state transition from %s to %s", fromState.toString(), State.OPEN.toString()));
             }
         }
 
@@ -195,7 +195,7 @@ public static StateTransition transitionToHalfOpenState(State fromState){
                 case OPEN:
                     return OPEN_TO_HALF_OPEN;
                 default:
-                    throw new IllegalStateException("Illegal state transition");
+                    throw new IllegalStateException(String.format("Illegal state transition from %s to %s", fromState.toString(), State.HALF_OPEN.toString()));
             }
         }
 

File: src/main/java/io/github/robwin/circuitbreaker/internal/CircuitBreakerState.java
Patch:
@@ -39,5 +39,5 @@ abstract class CircuitBreakerState{
 
     abstract CircuitBreaker.State getState();
 
-    abstract CircuitBreaker.Metrics getMetrics();
+    abstract CircuitBreakerMetrics getMetrics();
 }

File: src/main/java/io/github/robwin/circuitbreaker/internal/ClosedState.java
Patch:
@@ -63,7 +63,7 @@ synchronized void onSuccess() {
     private void checkFailureRate(float currentFailureRate) {
         if (currentFailureRate >= failureRateThreshold) {
             // Transition the state machine to OPEN state, because the failure rate is above the threshold
-            stateMachine.transitionToOpenState(CircuitBreaker.StateTransition.CLOSED_TO_OPEN, circuitBreakerMetrics);
+            stateMachine.transitionToOpenState(circuitBreakerMetrics);
         }
     }
 

File: src/main/java/io/github/robwin/circuitbreaker/internal/HalfOpenState.java
Patch:
@@ -64,9 +64,9 @@ synchronized void onSuccess() {
     private void checkFailureRate(float currentFailureRate) {
         if(currentFailureRate != -1){
             if(currentFailureRate >= failureRateThreshold) {
-                stateMachine.transitionToOpenState(CircuitBreaker.StateTransition.HALF_OPEN_TO_OPEN, circuitBreakerMetrics);
+                stateMachine.transitionToOpenState(circuitBreakerMetrics);
             }else{
-                stateMachine.transitionToClosedState(CircuitBreaker.StateTransition.HALF_OPEN_TO_CLOSED);
+                stateMachine.transitionToClosedState();
             }
         }
     }

File: src/jmh/java/io/github/robwin/circuitbreaker/CircuitBreakerWithSubscriberBenchmark.java
Patch:
@@ -33,11 +33,10 @@ public class CircuitBreakerWithSubscriberBenchmark {
     private static final int WARMUP_COUNT = 10;
     private static final int THREAD_COUNT = 10;
     private static final int FORK_COUNT = 1;
-    private CircuitBreaker circuitBreaker;
 
     @Setup
     public void setUp() {
-        circuitBreaker = CircuitBreaker.ofDefaults("testCircuitBreaker");
+        CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("testCircuitBreaker");
         circuitBreaker.getEventStream().subscribe();
         supplier = CircuitBreaker.decorateSupplier(circuitBreaker, () -> "Hello Benchmark");
     }

File: src/jmh/java/io/github/robwin/ratelimiter/RateLimiterBenchmark.java
Patch:
@@ -42,7 +42,7 @@
 @BenchmarkMode(Mode.All)
 public class RateLimiterBenchmark {
 
-    public static final int FORK_COUNT = 2;
+    private static final int FORK_COUNT = 2;
     private static final int WARMUP_COUNT = 10;
     private static final int ITERATION_COUNT = 10;
     private static final int THREAD_COUNT = 2;

File: src/test/java/io/github/robwin/cache/CacheTest.java
Patch:
@@ -37,6 +37,7 @@ public class CacheTest {
 
     private javax.cache.Cache<String, String> cache;
 
+    @SuppressWarnings("unchecked")
     @Before
     public void setUp(){
         cache = mock(javax.cache.Cache.class);

File: src/test/java/io/github/robwin/decorators/DecoratorsTest.java
Patch:
@@ -235,6 +235,7 @@ private void alignTime() {
         System.out.println(state);
     }
 
+    @SuppressWarnings("unchecked")
     @Test
     public void testDecorateCheckedSupplierWithCache() {
         javax.cache.Cache<String, String> cache = mock(javax.cache.Cache.class);
@@ -251,6 +252,7 @@ public void testDecorateCheckedSupplierWithCache() {
     }
 
 
+    @SuppressWarnings("unchecked")
     @Test
     public void testDecorateSupplierWithCache() {
         javax.cache.Cache<String, String> cache = mock(javax.cache.Cache.class);

File: src/main/java/io/github/robwin/circuitbreaker/CircuitBreakerConfig.java
Patch:
@@ -37,7 +37,7 @@ public class CircuitBreakerConfig {
     private int ringBufferSizeInClosedState = DEFAULT_RING_BUFFER_SIZE_IN_CLOSED_STATE;
     private Duration waitDurationInOpenState = Duration.ofSeconds(DEFAULT_WAIT_DURATION_IN_OPEN_STATE);
     // The default exception predicate counts all exceptions as failures.
-    private Predicate<Throwable> recordFailurePredicate = (exception) -> true;
+    private Predicate<? super Throwable> recordFailurePredicate = (exception) -> true;
 
     private CircuitBreakerConfig(){
     }
@@ -58,7 +58,7 @@ public int getRingBufferSizeInClosedState() {
         return ringBufferSizeInClosedState;
     }
 
-    public Predicate<Throwable> getRecordFailurePredicate() {
+    public Predicate<? super Throwable> getRecordFailurePredicate() {
         return recordFailurePredicate;
     }
 
@@ -158,7 +158,7 @@ public Builder ringBufferSizeInClosedState(int ringBufferSizeInClosedState) {
          * @param predicate the Predicate which evaluates if an exception should be recorded as a failure and thus trigger the CircuitBreaker
          * @return the CircuitBreakerConfig.Builder
          */
-        public Builder recordFailure(Predicate<Throwable> predicate) {
+        public Builder recordFailure(Predicate<? super Throwable> predicate) {
             config.recordFailurePredicate = predicate;
             return this;
         }

File: src/main/java/io/github/robwin/consumer/CircularEventConsumer.java
Patch:
@@ -18,7 +18,8 @@
  */
 package io.github.robwin.consumer;
 
-import io.github.robwin.circuitbreaker.internal.CircularFifoBuffer;
+import io.github.robwin.circularbuffer.CircularFifoBuffer;
+import io.github.robwin.circularbuffer.ConcurrentCircularFifoBuffer;
 import io.reactivex.functions.Consumer;
 import javaslang.collection.List;
 
@@ -37,7 +38,7 @@ public class CircularEventConsumer<T> implements Consumer<T>{
      * @throws IllegalArgumentException if {@code capacity < 1}
      */
     public CircularEventConsumer(int capacity) {
-        this.eventCircularFifoBuffer = new CircularFifoBuffer<>(capacity);
+        this.eventCircularFifoBuffer = new ConcurrentCircularFifoBuffer<>(capacity);
     }
 
     @Override

File: src/main/java/io/github/robwin/retry/internal/RetryContext.java
Patch:
@@ -77,7 +77,7 @@ public void onSuccess() {
 
     private void throwOrSleepAfterException() throws Exception {
         int currentNumOfAttempts = numOfAttempts.incrementAndGet();
-        if(currentNumOfAttempts == maxAttempts){
+        if(currentNumOfAttempts >= maxAttempts){
             Exception throwable = lastException.get();
             publishRetryEvent(() -> new RetryOnErrorEvent(getId(), currentNumOfAttempts, throwable));
             throw throwable;
@@ -88,7 +88,7 @@ private void throwOrSleepAfterException() throws Exception {
 
     public void throwOrSleepAfterRuntimeException(){
         int currentNumOfAttempts = numOfAttempts.incrementAndGet();
-        if(currentNumOfAttempts == maxAttempts){
+        if(currentNumOfAttempts >= maxAttempts){
             RuntimeException throwable = lastRuntimeException.get();
             publishRetryEvent(() -> new RetryOnErrorEvent(getId(), currentNumOfAttempts, throwable));
             throw throwable;

File: src/main/java/io/github/robwin/circuitbreaker/internal/CircuitBreakerStateMachine.java
Patch:
@@ -95,8 +95,9 @@ public void onError(Duration duration, Throwable throwable) {
             }
             publishCircuitBreakerEvent(() -> new CircuitBreakerOnErrorEvent(getName(), duration, throwable));
             stateReference.get().onError(throwable);
+        }else{
+            publishCircuitBreakerEvent(() -> new CircuitBreakerOnIgnoredErrorEvent(getName(), duration, throwable));
         }
-        publishCircuitBreakerEvent(() -> new CircuitBreakerOnIgnoredErrorEvent(getName(), duration, throwable));
     }
 
 

File: src/main/java/io/github/robwin/ratelimiter/RateLimiter.java
Patch:
@@ -55,7 +55,7 @@ static RateLimiter of(String name, Supplier<RateLimiterConfig> rateLimiterConfig
     }
 
     /**
-     * Creates a RateLimiter with a a default RateLimiterConfig configuration.
+     * Creates a RateLimiter with a default RateLimiterConfig configuration.
      *
      * @param name                      the name of the RateLimiter
      * @return The {@link RateLimiter}

File: src/jmh/java/io/github/robwin/ratelimiter/RateLimiterBenchmark.java
Patch:
@@ -55,7 +55,7 @@ public class RateLimiterBenchmark {
 
     @Setup
     public void setUp() {
-        RateLimiterConfig rateLimiterConfig = RateLimiterConfig.builder()
+        RateLimiterConfig rateLimiterConfig = RateLimiterConfig.custom()
             .limitForPeriod(Integer.MAX_VALUE)
             .limitRefreshPeriod(Duration.ofNanos(10))
             .timeoutDuration(Duration.ofSeconds(5))

File: src/test/java/io/github/robwin/decorators/DecoratorsTest.java
Patch:
@@ -99,7 +99,7 @@ public void testDecoratorBuilderWithRateLimiter(){
         given(helloWorldService.returnHelloWorld()).willReturn("Hello world");
 
         // Create a custom RateLimiter configuration
-        RateLimiterConfig config = RateLimiterConfig.builder()
+        RateLimiterConfig config = RateLimiterConfig.custom()
                 .timeoutDuration(Duration.ofMillis(100))
                 .limitRefreshPeriod(Duration.ofSeconds(1))
                 .limitForPeriod(1)

File: src/test/java/io/github/robwin/ratelimiter/RateLimiterTest.java
Patch:
@@ -48,7 +48,7 @@ public class RateLimiterTest {
 
     @Before
     public void init() {
-        config = RateLimiterConfig.builder()
+        config = RateLimiterConfig.custom()
             .timeoutDuration(TIMEOUT)
             .limitRefreshPeriod(REFRESH_PERIOD)
             .limitForPeriod(LIMIT)

File: src/test/java/io/github/robwin/ratelimiter/internal/AtomicRateLimiterTest.java
Patch:
@@ -63,7 +63,7 @@ private void setTimeOnNanos(long nanoTime) throws Exception {
 
     @Before
     public void setup() {
-        rateLimiterConfig = RateLimiterConfig.builder()
+        rateLimiterConfig = RateLimiterConfig.custom()
             .limitForPeriod(1)
             .limitRefreshPeriod(Duration.ofNanos(CYCLE_IN_NANOS))
             .timeoutDuration(Duration.ZERO)

File: src/test/java/io/github/robwin/ratelimiter/internal/InMemoryRateLimiterRegistryTest.java
Patch:
@@ -48,7 +48,7 @@ public class InMemoryRateLimiterRegistryTest {
 
     @Before
     public void init() {
-        config = RateLimiterConfig.builder()
+        config = RateLimiterConfig.custom()
             .timeoutDuration(TIMEOUT)
             .limitRefreshPeriod(REFRESH_PERIOD)
             .limitForPeriod(LIMIT)

File: src/main/java/io/github/robwin/ratelimiter/internal/AtomicRateLimiter.java
Patch:
@@ -273,7 +273,7 @@ public AtomicRateLimiterMetrics getDetailedMetrics() {
      * by the last {@link AtomicRateLimiter#getPermission(Duration)} call.</li>
      * <p>
      * <li>activePermissions - count of available permissions after
-     * last the last {@link AtomicRateLimiter#getPermission(Duration)} call.
+     * the last {@link AtomicRateLimiter#getPermission(Duration)} call.
      * Can be negative if some permissions where reserved.</li>
      * <p>
      * <li>nanosToWait - count of nanoseconds to wait for permission for
@@ -283,7 +283,6 @@ public AtomicRateLimiterMetrics getDetailedMetrics() {
     private static class State {
 
         private final long activeCycle;
-
         private final int activePermissions;
         private final long nanosToWait;
 

File: src/test/java/io/github/robwin/ratelimiter/internal/AtomicRateLimiterTest.java
Patch:
@@ -117,7 +117,7 @@ public void reserveAndRefresh() throws Exception {
 
         setTimeOnNanos(CYCLE_IN_NANOS * 2 + 10);
         awaitImpatiently()
-            .atMost(CYCLE_IN_NANOS, NANOSECONDS)
+            .atMost(CYCLE_IN_NANOS + POLL_INTERVAL_IN_NANOS, NANOSECONDS)
             .until(reservedPermission::get, equalTo(true));
 
         then(metrics.getAvailablePermissions()).isEqualTo(0);

File: src/main/java/io/github/robwin/ratelimiter/internal/InMemoryRateLimiterRegistry.java
Patch:
@@ -66,7 +66,7 @@ public RateLimiter rateLimiter(final String name, final RateLimiterConfig rateLi
         requireNonNull(rateLimiterConfig, CONFIG_MUST_NOT_BE_NULL);
         return rateLimiters.computeIfAbsent(
             name,
-            limitName -> new SemaphoreBasedRateLimiter(name, rateLimiterConfig)
+            limitName -> new AtomicRateLimiter(name, rateLimiterConfig)
         );
     }
 
@@ -82,7 +82,7 @@ public RateLimiter rateLimiter(final String name, final Supplier<RateLimiterConf
             limitName -> {
                 RateLimiterConfig rateLimiterConfig = rateLimiterConfigSupplier.get();
                 requireNonNull(rateLimiterConfig, CONFIG_MUST_NOT_BE_NULL);
-                return new SemaphoreBasedRateLimiter(limitName, rateLimiterConfig);
+                return new AtomicRateLimiter(limitName, rateLimiterConfig);
             }
         );
     }

File: src/jmh/java/io/github/robwin/circuitbreaker/RingBitSetBenachmark.java
Patch:
@@ -46,4 +46,4 @@ public void setBits(){
         ringBitSet.setNextBit(true);
         ringBitSet.setNextBit(false);
     }
-}
\ No newline at end of file
+}

File: src/jmh/java/io/github/robwin/ratelimiter/RateLimiterBenchmark.java
Patch:
@@ -1,6 +1,6 @@
 /*
  *
- *  Copyright 2015 Robert Winkler and Bohdan Storozhuk
+ *  Copyright 2016 Robert Winkler and Bohdan Storozhuk
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.

File: src/jmh/java/io/github/robwin/circuitbreaker/RingBitSetBenachmark.java
Patch:
@@ -46,4 +46,4 @@ public void setBits(){
         ringBitSet.setNextBit(true);
         ringBitSet.setNextBit(false);
     }
-}
+}
\ No newline at end of file

File: src/main/java/io/github/robwin/ratelimiter/RateLimiter.java
Patch:
@@ -1,4 +1,4 @@
-package javaslang.ratelimiter;
+package io.github.robwin.ratelimiter;
 
 import javaslang.control.Try;
 

File: src/main/java/io/github/robwin/ratelimiter/RateLimiterConfig.java
Patch:
@@ -1,4 +1,4 @@
-package javaslang.ratelimiter;
+package io.github.robwin.ratelimiter;
 
 import static java.util.Objects.requireNonNull;
 

File: src/main/java/io/github/robwin/ratelimiter/RateLimiterRegistry.java
Patch:
@@ -1,6 +1,6 @@
-package javaslang.ratelimiter;
+package io.github.robwin.ratelimiter;
 
-import javaslang.ratelimiter.internal.InMemoryRateLimiterRegistry;
+import io.github.robwin.ratelimiter.internal.InMemoryRateLimiterRegistry;
 
 import java.util.function.Supplier;
 

File: src/main/java/io/github/robwin/ratelimiter/RequestNotPermitted.java
Patch:
@@ -1,4 +1,4 @@
-package javaslang.ratelimiter;
+package io.github.robwin.ratelimiter;
 
 /**
  * Exception that indicates that current thread was not able to acquire permission

File: src/main/java/io/github/robwin/ratelimiter/internal/AtomicRateLimiter.java
Patch:
@@ -1,12 +1,12 @@
-package javaslang.ratelimiter.internal;
+package io.github.robwin.ratelimiter.internal;
 
 import static java.lang.Long.min;
 import static java.lang.System.nanoTime;
 import static java.lang.Thread.currentThread;
 import static java.util.concurrent.locks.LockSupport.parkNanos;
 
-import javaslang.ratelimiter.RateLimiter;
-import javaslang.ratelimiter.RateLimiterConfig;
+import io.github.robwin.ratelimiter.RateLimiter;
+import io.github.robwin.ratelimiter.RateLimiterConfig;
 
 import java.time.Duration;
 import java.util.concurrent.atomic.AtomicInteger;

File: src/main/java/io/github/robwin/ratelimiter/internal/SemaphoreBasedRateLimiter.java
Patch:
@@ -1,11 +1,11 @@
-package javaslang.ratelimiter.internal;
+package io.github.robwin.ratelimiter.internal;
 
 import static java.util.Objects.requireNonNull;
 import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;
 
 import javaslang.control.Option;
-import javaslang.ratelimiter.RateLimiter;
-import javaslang.ratelimiter.RateLimiterConfig;
+import io.github.robwin.ratelimiter.RateLimiter;
+import io.github.robwin.ratelimiter.RateLimiterConfig;
 
 import java.time.Duration;
 import java.util.concurrent.ScheduledExecutorService;

File: src/test/java/io/github/robwin/ratelimiter/RateLimiterConfigTest.java
Patch:
@@ -1,4 +1,4 @@
-package javaslang.ratelimiter;
+package io.github.robwin.ratelimiter;
 
 import static org.assertj.core.api.BDDAssertions.then;
 

File: src/test/java/io/github/robwin/ratelimiter/RateLimiterTest.java
Patch:
@@ -1,4 +1,4 @@
-package javaslang.ratelimiter;
+package io.github.robwin.ratelimiter;
 
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.mockito.Matchers.any;

File: src/test/java/io/github/robwin/ratelimiter/internal/AtomicRateLimiterTest.java
Patch:
@@ -1,4 +1,4 @@
-package javaslang.ratelimiter.internal;
+package io.github.robwin.ratelimiter.internal;
 
 import static com.jayway.awaitility.Awaitility.await;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -7,7 +7,7 @@
 import static org.hamcrest.CoreMatchers.equalTo;
 
 import com.jayway.awaitility.core.ConditionFactory;
-import javaslang.ratelimiter.RateLimiterConfig;
+import io.github.robwin.ratelimiter.RateLimiterConfig;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: src/test/java/io/github/robwin/ratelimiter/internal/SemaphoreBasedRateLimiterImplTest.java
Patch:
@@ -1,4 +1,4 @@
-package javaslang.ratelimiter.internal;
+package io.github.robwin.ratelimiter.internal;
 
 import static com.jayway.awaitility.Awaitility.await;
 import static com.jayway.awaitility.Duration.FIVE_HUNDRED_MILLISECONDS;
@@ -16,8 +16,8 @@
 import static org.mockito.Mockito.verify;
 
 import com.jayway.awaitility.core.ConditionFactory;
-import javaslang.ratelimiter.RateLimiter;
-import javaslang.ratelimiter.RateLimiterConfig;
+import io.github.robwin.ratelimiter.RateLimiter;
+import io.github.robwin.ratelimiter.RateLimiterConfig;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;

File: src/main/java/javaslang/ratelimiter/internal/AtomicRateLimiter.java
Patch:
@@ -264,7 +264,7 @@ public long getAvailablePermissions() {
     /**
      * Created only for test purposes. Simply calls {@link System#nanoTime()}
      */
-    private long currentNanoTime() {
+    public long currentNanoTime() {
         return nanoTime();
     }
 }

File: src/main/java/javaslang/ratelimiter/RateLimiterConfig.java
Patch:
@@ -7,8 +7,7 @@
 public class RateLimiterConfig {
     private static final String TIMEOUT_DURATION_MUST_NOT_BE_NULL = "TimeoutDuration must not be null";
     private static final String LIMIT_REFRESH_PERIOD_MUST_NOT_BE_NULL = "LimitRefreshPeriod must not be null";
-
-    private static final Duration ACCEPTABLE_REFRESH_PERIOD = Duration.ofNanos(1L); // TODO: use jmh to find real one
+    private static final Duration ACCEPTABLE_REFRESH_PERIOD = Duration.ofNanos(1L);
 
     private final Duration timeoutDuration;
     private final Duration limitRefreshPeriod;

File: src/test/java/javaslang/ratelimiter/RateLimiterConfigTest.java
Patch:
@@ -76,7 +76,7 @@ public void builderRefreshPeriodTooShort() throws Exception {
         exception.expectMessage("RefreshPeriod is too short");
         RateLimiterConfig.builder()
             .timeoutDuration(TIMEOUT)
-            .limitRefreshPeriod(Duration.ofNanos(499L))
+            .limitRefreshPeriod(Duration.ZERO)
             .limitForPeriod(LIMIT)
             .build();
     }

File: src/test/java/javaslang/ratelimiter/internal/InMemoryRateLimiterRegistryTest.java
Patch:
@@ -17,8 +17,6 @@
 import java.time.Duration;
 import java.util.function.Supplier;
 
-
-@SuppressWarnings("unchecked")
 public class InMemoryRateLimiterRegistryTest {
 
     private static final int LIMIT = 50;
@@ -51,6 +49,7 @@ public void rateLimiterPositive() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("unchecked")
     public void rateLimiterPositiveWithSupplier() throws Exception {
         RateLimiterRegistry registry = new InMemoryRateLimiterRegistry(config);
         Supplier<RateLimiterConfig> rateLimiterConfigSupplier = mock(Supplier.class);

File: src/main/java/javaslang/ratelimiter/RateLimiterConfig.java
Patch:
@@ -8,7 +8,7 @@ public class RateLimiterConfig {
     private static final String TIMEOUT_DURATION_MUST_NOT_BE_NULL = "TimeoutDuration must not be null";
     private static final String LIMIT_REFRESH_PERIOD_MUST_NOT_BE_NULL = "LimitRefreshPeriod must not be null";
 
-    private static final Duration ACCEPTABLE_REFRESH_PERIOD = Duration.ofNanos(500L); // TODO: use jmh to find real one
+    private static final Duration ACCEPTABLE_REFRESH_PERIOD = Duration.ofNanos(1L); // TODO: use jmh to find real one
 
     private final Duration timeoutDuration;
     private final Duration limitRefreshPeriod;

File: src/main/java/javaslang/ratelimiter/internal/InMemoryRateLimiterRegistry.java
Patch:
@@ -48,7 +48,7 @@ public RateLimiter rateLimiter(final String name, final RateLimiterConfig rateLi
         requireNonNull(rateLimiterConfig, CONFIG_MUST_NOT_BE_NULL);
         return rateLimiters.computeIfAbsent(
             name,
-            limitName -> new SemaphoreBasedRateLimiterImpl(name, rateLimiterConfig)
+            limitName -> new SemaphoreBasedRateLimiter(name, rateLimiterConfig)
         );
     }
 
@@ -64,7 +64,7 @@ public RateLimiter rateLimiter(final String name, final Supplier<RateLimiterConf
             limitName -> {
                 RateLimiterConfig rateLimiterConfig = rateLimiterConfigSupplier.get();
                 requireNonNull(rateLimiterConfig, CONFIG_MUST_NOT_BE_NULL);
-                return new SemaphoreBasedRateLimiterImpl(limitName, rateLimiterConfig);
+                return new SemaphoreBasedRateLimiter(limitName, rateLimiterConfig);
             }
         );
     }

File: src/test/java/javaslang/ratelimiter/internal/InMemoryRateLimiterRegistryTest.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.function.Supplier;
 
 
+@SuppressWarnings("unchecked")
 public class InMemoryRateLimiterRegistryTest {
 
     private static final int LIMIT = 50;

File: src/main/java/javaslang/ratelimiter/internal/AtomicRateLimiter.java
Patch:
@@ -264,7 +264,7 @@ public long getAvailablePermissions() {
     /**
      * Created only for test purposes. Simply calls {@link System#nanoTime()}
      */
-    private long currentNanoTime() {
+    public long currentNanoTime() {
         return nanoTime();
     }
 }

File: src/main/java/javaslang/ratelimiter/RateLimiterConfig.java
Patch:
@@ -7,8 +7,7 @@
 public class RateLimiterConfig {
     private static final String TIMEOUT_DURATION_MUST_NOT_BE_NULL = "TimeoutDuration must not be null";
     private static final String LIMIT_REFRESH_PERIOD_MUST_NOT_BE_NULL = "LimitRefreshPeriod must not be null";
-
-    private static final Duration ACCEPTABLE_REFRESH_PERIOD = Duration.ofNanos(1L); // TODO: use jmh to find real one
+    private static final Duration ACCEPTABLE_REFRESH_PERIOD = Duration.ofNanos(1L);
 
     private final Duration timeoutDuration;
     private final Duration limitRefreshPeriod;

File: src/test/java/javaslang/ratelimiter/RateLimiterConfigTest.java
Patch:
@@ -76,7 +76,7 @@ public void builderRefreshPeriodTooShort() throws Exception {
         exception.expectMessage("RefreshPeriod is too short");
         RateLimiterConfig.builder()
             .timeoutDuration(TIMEOUT)
-            .limitRefreshPeriod(Duration.ofNanos(499L))
+            .limitRefreshPeriod(Duration.ZERO)
             .limitForPeriod(LIMIT)
             .build();
     }

File: src/test/java/javaslang/ratelimiter/internal/InMemoryRateLimiterRegistryTest.java
Patch:
@@ -17,8 +17,6 @@
 import java.time.Duration;
 import java.util.function.Supplier;
 
-
-@SuppressWarnings("unchecked")
 public class InMemoryRateLimiterRegistryTest {
 
     private static final int LIMIT = 50;
@@ -51,6 +49,7 @@ public void rateLimiterPositive() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("unchecked")
     public void rateLimiterPositiveWithSupplier() throws Exception {
         RateLimiterRegistry registry = new InMemoryRateLimiterRegistry(config);
         Supplier<RateLimiterConfig> rateLimiterConfigSupplier = mock(Supplier.class);

File: src/main/java/javaslang/ratelimiter/RateLimiterConfig.java
Patch:
@@ -8,7 +8,7 @@ public class RateLimiterConfig {
     private static final String TIMEOUT_DURATION_MUST_NOT_BE_NULL = "TimeoutDuration must not be null";
     private static final String LIMIT_REFRESH_PERIOD_MUST_NOT_BE_NULL = "LimitRefreshPeriod must not be null";
 
-    private static final Duration ACCEPTABLE_REFRESH_PERIOD = Duration.ofNanos(500L); // TODO: use jmh to find real one
+    private static final Duration ACCEPTABLE_REFRESH_PERIOD = Duration.ofNanos(1L); // TODO: use jmh to find real one
 
     private final Duration timeoutDuration;
     private final Duration limitRefreshPeriod;

File: src/main/java/javaslang/ratelimiter/internal/InMemoryRateLimiterRegistry.java
Patch:
@@ -48,7 +48,7 @@ public RateLimiter rateLimiter(final String name, final RateLimiterConfig rateLi
         requireNonNull(rateLimiterConfig, CONFIG_MUST_NOT_BE_NULL);
         return rateLimiters.computeIfAbsent(
             name,
-            limitName -> new SemaphoreBasedRateLimiterImpl(name, rateLimiterConfig)
+            limitName -> new SemaphoreBasedRateLimiter(name, rateLimiterConfig)
         );
     }
 
@@ -64,7 +64,7 @@ public RateLimiter rateLimiter(final String name, final Supplier<RateLimiterConf
             limitName -> {
                 RateLimiterConfig rateLimiterConfig = rateLimiterConfigSupplier.get();
                 requireNonNull(rateLimiterConfig, CONFIG_MUST_NOT_BE_NULL);
-                return new SemaphoreBasedRateLimiterImpl(limitName, rateLimiterConfig);
+                return new SemaphoreBasedRateLimiter(limitName, rateLimiterConfig);
             }
         );
     }

File: src/test/java/javaslang/ratelimiter/internal/InMemoryRateLimiterRegistryTest.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.function.Supplier;
 
 
+@SuppressWarnings("unchecked")
 public class InMemoryRateLimiterRegistryTest {
 
     private static final int LIMIT = 50;

File: src/main/java/io/github/robwin/circuitbreaker/event/CircuitBreakerOnIgnoredErrorEvent.java
Patch:
@@ -21,11 +21,11 @@
 /**
  * A CircuitBreakerEvent which informs that an error has been ignored
  */
-public class CircuitBreakerOnErrorIgnoredEvent extends AbstractCircuitBreakerEvent{
+public class CircuitBreakerOnIgnoredErrorEvent extends AbstractCircuitBreakerEvent{
 
     private final Throwable throwable;
 
-    public CircuitBreakerOnErrorIgnoredEvent(String circuitBreakerName, Throwable throwable) {
+    public CircuitBreakerOnIgnoredErrorEvent(String circuitBreakerName, Throwable throwable) {
         super(circuitBreakerName);
         this.throwable = throwable;
     }

File: src/main/java/io/github/robwin/circuitbreaker/internal/CircuitBreakerStateMachine.java
Patch:
@@ -96,7 +96,7 @@ public synchronized void onError(Throwable throwable) {
             publishCircuitBreakerEvent(new CircuitBreakerOnErrorEvent(getName(), throwable));
             stateReference.get().onError(throwable);
         }
-        publishCircuitBreakerEvent(new CircuitBreakerOnErrorIgnoredEvent(getName(), throwable));
+        publishCircuitBreakerEvent(new CircuitBreakerOnIgnoredErrorEvent(getName(), throwable));
     }
 
     /**

File: src/main/java/io/github/robwin/circuitbreaker/event/CircuitBreakerEvent.java
Patch:
@@ -52,6 +52,8 @@ public interface CircuitBreakerEvent {
     enum Type {
         /** A CircuitBreakerEvent which informs that an error has been recorded */
         ERROR,
+        /** A CircuitBreakerEvent which informs that an error has been ignored */
+        IGNORED_ERROR,
         /** A CircuitBreakerEvent which informs that a success has been recorded */
         SUCCESS,
         /** A CircuitBreakerEvent which informs the state of the CircuitBreaker has been changed */

File: src/main/java/io/github/robwin/circuitbreaker/event/CircuitBreakerOnErrorIgnoredEvent.java
Patch:
@@ -36,7 +36,7 @@ public Throwable getThrowable() {
 
     @Override
     public Type getEventType() {
-        return Type.ERROR;
+        return Type.IGNORED_ERROR;
     }
 
     @Override

File: src/test/java/io/github/robwin/circuitbreaker/internal/CircuitBreakerMetricsTest.java
Patch:
@@ -41,6 +41,7 @@ public void testDefaultCircuitBreakerMetrics(){
 
         assertThat(circuitBreakerMetrics.getNumberOfBufferedCalls()).isEqualTo(4);
         assertThat(circuitBreakerMetrics.getNumberOfFailedCalls()).isEqualTo(2);
+        assertThat(circuitBreakerMetrics.getNumberOfSuccessfulCalls()).isEqualTo(2);
 
         // The failure rate must be -1, because the number of measured calls is below the buffer size of 10
         assertThat(circuitBreakerMetrics.getFailureRate()).isEqualTo(-1);
@@ -58,6 +59,7 @@ public void testDefaultCircuitBreakerMetrics(){
         // The failure rate must be 60%, because the number of measured calls is above the minimum number of measured calls.
         assertThat(circuitBreakerMetrics.getNumberOfBufferedCalls()).isEqualTo(10);
         assertThat(circuitBreakerMetrics.getNumberOfFailedCalls()).isEqualTo(6);
+        assertThat(circuitBreakerMetrics.getNumberOfSuccessfulCalls()).isEqualTo(4);
         assertThat(circuitBreakerMetrics.getFailureRate()).isEqualTo(60);
     }
 }

File: src/main/java/io/github/robwin/circuitbreaker/CircuitBreaker.java
Patch:
@@ -19,9 +19,9 @@
 package io.github.robwin.circuitbreaker;
 
 import io.github.robwin.circuitbreaker.event.CircuitBreakerEvent;
-import io.github.robwin.circuitbreaker.utils.CircuitBreakerUtils;
-import io.reactivex.Observable;
 import io.github.robwin.circuitbreaker.internal.CircuitBreakerStateMachine;
+import io.github.robwin.circuitbreaker.utils.CircuitBreakerUtils;
+import io.reactivex.Flowable;
 import javaslang.control.Try;
 
 import java.util.function.Consumer;
@@ -90,7 +90,7 @@ public interface CircuitBreaker {
      *
      * @return a reactive stream of CircuitBreakerEvents
      */
-    Observable<CircuitBreakerEvent> getEventStream();
+    Flowable<CircuitBreakerEvent> getEventStream();
 
     /**
      * States of the CircuitBreaker state machine.

File: src/main/java/io/github/robwin/circuitbreaker/event/AbstractCircuitBreakerEvent.java
Patch:
@@ -25,7 +25,7 @@ abstract class AbstractCircuitBreakerEvent implements CircuitBreakerEvent {
     private final String circuitBreakerName;
     private final ZonedDateTime creationTime;
 
-    public AbstractCircuitBreakerEvent(String circuitBreakerName) {
+    AbstractCircuitBreakerEvent(String circuitBreakerName) {
         this.circuitBreakerName = circuitBreakerName;
         this.creationTime = ZonedDateTime.now();
     }

File: src/test/java/io/github/robwin/circuitbreaker/operator/CircuitBreakerOperatorTest.java
Patch:
@@ -18,7 +18,6 @@
  */
 package io.github.robwin.circuitbreaker.operator;
 
-import io.github.robwin.circuitbreaker.operator.CircuitBreakerOperator;
 import io.reactivex.Flowable;
 import io.reactivex.Observable;
 import io.github.robwin.circuitbreaker.CircuitBreaker;

File: src/main/java/javaslang/circuitbreaker/consumer/CircuitBreakerEventConsumer.java
Patch:
@@ -20,7 +20,7 @@
 
 
 import io.reactivex.functions.Consumer;
-import javaslang.circuitbreaker.CircuitBreakerEvent;
+import javaslang.circuitbreaker.event.CircuitBreakerEvent;
 import javaslang.circuitbreaker.internal.CircularFifoBuffer;
 import javaslang.collection.List;
 

File: src/main/java/javaslang/circuitbreaker/internal/CircuitBreakerState.java
Patch:
@@ -33,9 +33,9 @@ abstract class CircuitBreakerState{
 
     abstract boolean isCallPermitted();
 
-    abstract void recordFailure(Throwable throwable);
+    abstract void onError(Throwable throwable);
 
-    abstract void recordSuccess();
+    abstract void onSuccess();
 
     abstract CircuitBreaker.State getState();
 

File: src/main/java/javaslang/circuitbreaker/internal/InMemoryCircuitBreakerRegistry.java
Patch:
@@ -86,6 +86,6 @@ public CircuitBreaker circuitBreaker(String name, Supplier<CircuitBreakerConfig>
      * Reset the circuitBreaker states.
      */
     public void resetMonitorStates() {
-        circuitBreakers.values().forEach(CircuitBreaker::recordSuccess);
+        circuitBreakers.values().forEach(CircuitBreaker::onSuccess);
     }
 }

File: src/main/java/javaslang/circuitbreaker/internal/OpenState.java
Patch:
@@ -54,7 +54,7 @@ boolean isCallPermitted() {
      * Should never be called, because isCallPermitted returns false.
      */
     @Override
-    void recordFailure(Throwable throwable) {
+    synchronized void onError(Throwable throwable) {
         // Should never be called, because isCallPermitted returns false
         throw new CircuitBreakerOpenException(String.format("CircuitBreaker '%s' is open", stateMachine.getName()));
     }
@@ -63,7 +63,7 @@ void recordFailure(Throwable throwable) {
      * Should never be called, because isCallPermitted returns false.
      */
     @Override
-    void recordSuccess() {
+    synchronized void onSuccess() {
         // Should never be called, because isCallPermitted returns false
         throw new CircuitBreakerOpenException(String.format("CircuitBreaker '%s' is open", stateMachine.getName()));
     }

File: src/main/java/javaslang/circuitbreaker/internal/CircuitBreakerMetrics.java
Patch:
@@ -42,7 +42,7 @@ class CircuitBreakerMetrics implements CircuitBreaker.Metrics {
      *
      * @return the current failure rate  in percentage.
      */
-    public synchronized float recordFailure(Throwable throwable){
+    public synchronized float recordFailure(){
         ringBitSet.setNextBit(true);
         return getFailureRate();
     }

File: src/main/java/javaslang/circuitbreaker/internal/ClosedState.java
Patch:
@@ -46,7 +46,7 @@ boolean isCallPermitted() {
 
     @Override
     void recordFailure(Throwable throwable) {
-        checkFailureRate(circuitBreakerMetrics.recordFailure(throwable));
+        checkFailureRate(circuitBreakerMetrics.recordFailure());
     }
 
     @Override

File: src/main/java/javaslang/circuitbreaker/internal/HalfOpenState.java
Patch:
@@ -47,7 +47,7 @@ boolean isCallPermitted() {
     @Override
     void recordFailure(Throwable throwable) {
         // Thread-safe
-        checkFailureRate(circuitBreakerMetrics.recordFailure(throwable));
+        checkFailureRate(circuitBreakerMetrics.recordFailure());
     }
 
     @Override

File: src/test/java/javaslang/circuitbreaker/CircuitBreakerTest.java
Patch:
@@ -76,7 +76,6 @@ public void shouldReturnFailureWithRuntimeException() {
         // Given
         CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.ofDefaults();
         CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("testName");
-        circuitBreaker.observeCircuitBreakerEvents().subscribe((event) -> LOG.info(event.toString()));
         assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED);
 
         //When

File: src/main/java/javaslang/circuitbreaker/CircuitBreakerEventListener.java
Patch:
@@ -18,10 +18,10 @@
  */
 package javaslang.circuitbreaker;
 
-@FunctionalInterface
 /**
  * A listener to handle CircuitBreaker events.
- */
+ **/
+@FunctionalInterface
 public interface CircuitBreakerEventListener{
 
     /**

File: src/main/java/javaslang/circuitbreaker/internal/ClosedState.java
Patch:
@@ -30,8 +30,7 @@ final class ClosedState extends CircuitBreakerState {
         super(stateMachine);
         CircuitBreakerConfig circuitBreakerConfig = stateMachine.getCircuitBreakerConfig();
         this.circuitBreakerMetrics = new CircuitBreakerMetrics(
-                circuitBreakerConfig.getRingBufferSizeInClosedState(),
-                circuitBreakerConfig.getExceptionRingBufferSize());
+                circuitBreakerConfig.getRingBufferSizeInClosedState());
         this.failureRateThreshold = stateMachine.getCircuitBreakerConfig().getFailureRateThreshold();
     }
 

File: src/main/java/javaslang/circuitbreaker/internal/HalfOpenState.java
Patch:
@@ -30,8 +30,7 @@ final class HalfOpenState extends CircuitBreakerState {
         super(stateMachine);
         CircuitBreakerConfig circuitBreakerConfig = stateMachine.getCircuitBreakerConfig();
         this.circuitBreakerMetrics = new CircuitBreakerMetrics(
-                circuitBreakerConfig.getRingBufferSizeInHalfOpenState(),
-                circuitBreakerConfig.getExceptionRingBufferSize());
+                circuitBreakerConfig.getRingBufferSizeInHalfOpenState());
         this.failureRateThreshold = stateMachine.getCircuitBreakerConfig().getFailureRateThreshold();
     }
 

File: src/main/java/javaslang/retry/RetryContext.java
Patch:
@@ -22,7 +22,7 @@ public class RetryContext implements Retry {
 
     private RetryContext(int maxAttempts, Duration waitDuration, Predicate<Throwable> exceptionPredicate){
         this.maxAttempts = maxAttempts;
-        this.waitDuration = waitDuration.getSeconds() * 1000;
+        this.waitDuration = waitDuration.toMillis();
         this.exceptionPredicate = exceptionPredicate;
         this.numOfAttempts = new AtomicInteger(0);
         this.lastException = new AtomicReference<>();

File: src/main/java/javaslang/circuitbreaker/internal/CircuitBreakerState.java
Patch:
@@ -33,7 +33,7 @@ abstract class CircuitBreakerState{
 
     abstract boolean isCallPermitted();
 
-    abstract void recordFailure();
+    abstract void recordFailure(Throwable throwable);
 
     abstract void recordSuccess();
 

File: src/main/java/javaslang/circuitbreaker/internal/CircuitBreakerStateMachine.java
Patch:
@@ -62,7 +62,7 @@ public boolean isCallPermitted() {
     @Override
     public void recordFailure(Throwable throwable) {
         if(circuitBreakerConfig.getExceptionPredicate().test(throwable)){
-            stateReference.get().recordFailure();
+            stateReference.get().recordFailure(throwable);
         }
     }
 

File: src/main/java/javaslang/circuitbreaker/internal/OpenState.java
Patch:
@@ -54,7 +54,7 @@ boolean isCallPermitted() {
      * Should never be called, because isCallPermitted returns false.
      */
     @Override
-    void recordFailure() {
+    void recordFailure(Throwable throwable) {
         // Should never be called, because isCallPermitted returns false
         throw new CircuitBreakerOpenException(String.format("CircuitBreaker '%s' is open", stateMachine.getName()));
     }

File: src/test/java/javaslang/reactivestreams/ReactiveStreamsTest.java
Patch:
@@ -68,7 +68,7 @@ public void shouldReturnSuccessfullyAfterSecondAttempt() {
         // Create a Retry with default configuration
         Retry retryContext = Retry.ofDefaults();
         // Decorate the supplier of the HelloWorldService with Retry functionality
-        Supplier<String> retryableSupplier = Retry.decorateSupplier(helloWorldService::returnHelloWorld, retryContext);
+        Supplier<String> retryableSupplier = Retry.decorateSupplier(retryContext, helloWorldService::returnHelloWorld);
 
         TestSubscriber<String> testSubscriber = new TestSubscriber<>();
 
@@ -98,7 +98,7 @@ public void shouldReturnFailureWithCircuitBreakerOpenException() {
         assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.OPEN);
 
         // Decorate the supplier of the HelloWorldService with CircuitBreaker functionality
-        Supplier<String> supplier = CircuitBreaker.decorateSupplier(helloWorldService::returnHelloWorld, circuitBreaker);
+        Supplier<String> supplier = CircuitBreaker.decorateSupplier(circuitBreaker, helloWorldService::returnHelloWorld);
 
         TestSubscriber<String> testSubscriber = new TestSubscriber<>();
 

File: src/main/java/javaslang/retry/RetryContext.java
Patch:
@@ -93,8 +93,8 @@ public Builder maxAttempts(int maxAttempts) {
         }
 
         public Builder waitDuration(Duration waitDuration) {
-            if (waitDuration.getSeconds() < 0.01) {
-                throw new IllegalArgumentException("waitDurationInOpenState must be at least than 10[ms]");
+            if (waitDuration.toMillis() < 10) {
+                throw new IllegalArgumentException("waitDurationInOpenState must be at least 10ms");
             }
             this.waitDuration = waitDuration;
             return this;

File: src/main/java/javaslang/retry/RetryContext.java
Patch:
@@ -93,8 +93,8 @@ public Builder maxAttempts(int maxAttempts) {
         }
 
         public Builder waitDuration(Duration waitDuration) {
-            if (waitDuration.getSeconds() < 0.01) {
-                throw new IllegalArgumentException("waitDurationInOpenState must be at least than 10[ms]");
+            if (waitDuration.toMillis() < 10) {
+                throw new IllegalArgumentException("waitDurationInOpenState must be at least 10ms");
             }
             this.waitDuration = waitDuration;
             return this;

File: src/main/java/javaslang/circuitbreaker/internal/ClosedState.java
Patch:
@@ -58,7 +58,7 @@ void recordSuccess() {
      * @param currentFailureRate the current failure rate
      */
     private void checkFailureRate(float currentFailureRate) {
-        if (currentFailureRate > failureRateThreshold) {
+        if (currentFailureRate >= failureRateThreshold) {
             // Transition the state machine to OPEN state, because the failure rate is above the threshold
             stateMachine.transitionToOpenState(CircuitBreaker.StateTransition.CLOSED_TO_OPEN, circuitBreakerMetrics);
         }

File: src/main/java/javaslang/circuitbreaker/internal/HalfOpenState.java
Patch:
@@ -62,7 +62,7 @@ void recordSuccess() {
      */
     private void checkFailureRate(float currentFailureRate) {
         if(currentFailureRate != -1){
-            if(currentFailureRate > failureRateThreshold) {
+            if(currentFailureRate >= failureRateThreshold) {
                 stateMachine.transitionToOpenState(CircuitBreaker.StateTransition.HALF_OPEN_TO_OPEN, circuitBreakerMetrics);
             }else{
                 stateMachine.transitionToClosedState(CircuitBreaker.StateTransition.HALF_OPEN_TO_CLOSED);

File: src/main/java/io/github/robwin/circuitbreaker/CircuitBreakerEvent.java
Patch:
@@ -19,4 +19,5 @@
 package io.github.robwin.circuitbreaker;
 
 public interface CircuitBreakerEvent {
+    String getCircuitBreakerName();
 }

File: src/main/java/io/github/robwin/circuitbreaker/CircuitBreakerRegistry.java
Patch:
@@ -25,15 +25,15 @@
 public interface CircuitBreakerRegistry {
 
     /**
-     * Returns the managed {@link CircuitBreaker} or creates a new one with the default configuration.
+     * Returns a managed {@link CircuitBreaker} or creates a new one with the default configuration.
      *
      * @param name the name of the CircuitBreaker
      * @return The {@link CircuitBreaker}
      */
     CircuitBreaker circuitBreaker(String name);
 
     /**
-     * Returns the managed {@link CircuitBreaker} or creates a new one with a custom configuration.
+     * Returns a managed {@link CircuitBreaker} or creates a new one with a custom configuration.
      *
      * @param name      the name of the CircuitBreaker
      * @param circuitBreakerConfig  the CircuitBreaker configuration

File: src/main/java/io/github/robwin/circuitbreaker/ClosedState.java
Patch:
@@ -45,7 +45,7 @@ public void recordFailure() {
         if (currentNumOfFailures > this.maxFailures) {
             // Too many failures, set new retryAfter to current time + wait interval
             retryAfter.set(System.currentTimeMillis() + this.waitInterval);
-            stateMachine.transitionToOpenState(this);
+            stateMachine.transitionToOpenState(this, CircuitBreaker.StateTransition.CLOSED_TO_OPEN);
         }
     }
 
@@ -55,7 +55,7 @@ public void recordFailure() {
      */
     @Override
     public void recordSuccess() {
-        stateMachine.resetState(this);
+        stateMachine.resetState(CircuitBreaker.StateTransition.CLOSED_TO_CLOSED);
     }
 
     /**

File: src/main/java/io/github/robwin/circuitbreaker/HalfClosedState.java
Patch:
@@ -42,7 +42,7 @@ public boolean isCallPermitted() {
     public void recordFailure() {
         numOfFailures.incrementAndGet();
         retryAfter.set(System.currentTimeMillis() + this.waitInterval);
-        stateMachine.transitionToOpenState(this);
+        stateMachine.transitionToOpenState(this, CircuitBreaker.StateTransition.HALF_CLOSED_TO_OPEN);
     }
 
     /**
@@ -51,7 +51,7 @@ public void recordFailure() {
      */
     @Override
     public void recordSuccess() {
-        stateMachine.resetState(this);
+        stateMachine.resetState(CircuitBreaker.StateTransition.HALF_CLOSED_TO_CLOSED);
     }
 
     /**

File: src/main/java/io/github/robwin/circuitbreaker/OpenState.java
Patch:
@@ -32,7 +32,7 @@ final public class OpenState extends CircuitBreakerState {
     @Override
     public boolean isCallPermitted() {
         if (System.currentTimeMillis() >= retryAfter.get()) {
-            stateMachine.transitionToHalfClosedState(this);
+            stateMachine.transitionToHalfClosedState(this, CircuitBreaker.StateTransition.OPEN_TO_HALF_CLOSED);
             return true;
         }
         return false;
@@ -53,7 +53,7 @@ public void recordFailure() {
      */
     @Override
     public void recordSuccess() {
-        stateMachine.resetState(this);
+        stateMachine.resetState(CircuitBreaker.StateTransition.OPEN_TO_CLOSED);
     }
 
     /**

File: src/main/java/io/github/robwin/circuitbreaker/ClosedState.java
Patch:
@@ -55,7 +55,7 @@ public void recordFailure() {
      */
     @Override
     public void recordSuccess() {
-        stateMachine.resetState();
+        stateMachine.resetState(this);
     }
 
     /**

File: src/main/java/io/github/robwin/circuitbreaker/HalfClosedState.java
Patch:
@@ -51,7 +51,7 @@ public void recordFailure() {
      */
     @Override
     public void recordSuccess() {
-        stateMachine.resetState();
+        stateMachine.resetState(this);
     }
 
     /**

File: src/main/java/io/github/robwin/circuitbreaker/OpenState.java
Patch:
@@ -53,7 +53,7 @@ public void recordFailure() {
      */
     @Override
     public void recordSuccess() {
-        stateMachine.resetState();
+        stateMachine.resetState(this);
     }
 
     /**

File: src/test/java/io/github/robwin/circuitbreaker/CircuitBreakerRegistryTest.java
Patch:
@@ -24,7 +24,7 @@
 import static org.assertj.core.api.BDDAssertions.assertThat;
 
 
-public class MonitorRegistryTest {
+public class CircuitBreakerRegistryTest {
 
     private CircuitBreakerRegistry circuitBreakerRegistry;
 

File: src/test/java/io/github/robwin/circuitbreaker/CircuitBreakerTest.java
Patch:
@@ -36,7 +36,7 @@ public class CircuitBreakerTest {
 
     @Before
     public void setUp(){
-        circuitBreakerRegistry = CircuitBreakerRegistry.of(new CircuitBreakerConfig.Builder()
+        circuitBreakerRegistry = CircuitBreakerRegistry.of(CircuitBreakerConfig.custom()
                 .maxFailures(1)
                 .waitInterval(1000)
                 .build());

File: src/test/java/io/github/robwin/circuitbreaker/CircuitBreakerTest.java
Patch:
@@ -221,7 +221,7 @@ public void shouldChainDecoratedFunctions() throws ExecutionException, Interrupt
         // You can chain other functions with map and flatMap. The Try Monad returns a Success<String>, if the all
         // functions run successfully.
         Try<String> result = Try.of(decoratedSupplier)
-                .map(decoratedFunction);
+                .mapTry(decoratedFunction::apply);
 
         // Then
         assertThat(result.isSuccess()).isTrue();

File: src/main/java/io/github/robwin/circuitbreaker/CircuitBreakerRegistry.java
Patch:
@@ -21,7 +21,6 @@
 
 /**
  * Backend circuitBreaker manager.
- * <p/>
  * Manages backend circuitBreaker objects for the respective backends.
  */
 public interface CircuitBreakerRegistry {

File: src/main/java/io/github/robwin/circuitbreaker/DefaultCircuitBreaker.java
Patch:
@@ -23,11 +23,9 @@
 
 /**
  * CircuitBreaker state machine.
- * <p/>
  * This CircuitBreaker is implemented via a (timed) state machine. It does not have a way to know anything about the
  * backend's state by itself, but uses only the information provided by calls to {@link #recordSuccess()} and
  * {@link #recordFailure()}.
- * <p/>
  * The state changes from CLOSED to OPEN after {@link #maxFailures} attempts have failed consecutively. Then, all access to
  * the backend is blocked for the time interval given by {@link #waitInterval}. After that, the backend is unblocked
  * tentatively, to see if it is still dead or has become available again (state: HALF_CLOSED). On success or failure, the

File: src/main/java/io/github/robwin/circuitbreaker/InMemoryCircuitBreakerRegistry.java
Patch:
@@ -24,7 +24,6 @@
 
 /**
  * Backend circuitBreaker manager.
- * <p/>
  * Constructs backend monitors according to configuration values.
  */
 public class InMemoryCircuitBreakerRegistry implements CircuitBreakerRegistry {

File: src/main/java/io/github/robwin/circuitbreaker/InMemoryCircuitBreakerRegistry.java
Patch:
@@ -40,7 +40,7 @@ public class InMemoryCircuitBreakerRegistry implements CircuitBreakerRegistry {
      * The constructor with default circuitBreaker properties.
      */
     public InMemoryCircuitBreakerRegistry() {
-        this.defaultCircuitBreakerConfig = new CircuitBreakerConfigBuilder().createCircuitBreakerConfig();
+        this.defaultCircuitBreakerConfig = new CircuitBreakerConfig.Builder().build();
         this.monitors = new ConcurrentHashMap<>();
     }
 

