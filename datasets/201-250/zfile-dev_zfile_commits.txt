File: src/main/java/im/zhaojun/zfile/core/config/FlywayDbInitializer.java
Patch:
@@ -1 +1 @@
-package im.zhaojun.zfile.core.config;import cn.hutool.core.util.StrUtil;import org.flywaydb.core.Flyway;import org.springframework.context.annotation.Configuration;import javax.annotation.PostConstruct;import javax.annotation.Resource;import javax.sql.DataSource;import java.sql.SQLException;import java.util.Locale;/** * 数据库初始化 * * @author zhaojun */@Configurationpublic class FlywayDbInitializer {	public static final String[] SUPPORT_DB_TYPE = new String[]{"mysql", "sqlite"};	@Resource	private DataSource dataSource;	/**	 * 启动时根据当前数据库类型执行数据库初始化	 */	@PostConstruct	public void migrateFlyway() {		try {			String databaseProductName = dataSource.getConnection().getMetaData().getDatabaseProductName();			String dbType = databaseProductName.toLowerCase(Locale.ROOT);			// 检查当前数据库类型是否支持			if (!StrUtil.equalsAnyIgnoreCase(dbType, SUPPORT_DB_TYPE)) {				throw new RuntimeException("不支持的数据库类型 [" + dbType + "]");			}			Flyway load = Flyway.configure().dataSource(dataSource).outOfOrder(true).locations("db/migration-" + dbType).load();			load.migrate();		} catch (SQLException e) {			e.printStackTrace();		}	}}
\ No newline at end of file
+package im.zhaojun.zfile.core.config;import cn.hutool.core.util.StrUtil;import org.flywaydb.core.Flyway;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.DependsOn;import javax.annotation.PostConstruct;import javax.annotation.Resource;import javax.sql.DataSource;import java.sql.SQLException;import java.util.Locale;/** * 数据库初始化 * * @author zhaojun */@DependsOn("myBatisPlusConfig")@Configurationpublic class FlywayDbInitializer {	public static final String[] SUPPORT_DB_TYPE = new String[]{"mysql", "sqlite"};	@Resource	private DataSource dataSource;	/**	 * 启动时根据当前数据库类型执行数据库初始化	 */	@PostConstruct	public void migrateFlyway() {		try {			String databaseProductName = dataSource.getConnection().getMetaData().getDatabaseProductName();			String dbType = databaseProductName.toLowerCase(Locale.ROOT);			// 检查当前数据库类型是否支持			if (!StrUtil.equalsAnyIgnoreCase(dbType, SUPPORT_DB_TYPE)) {				throw new RuntimeException("不支持的数据库类型 [" + dbType + "]");			}			Flyway load = Flyway.configure().dataSource(dataSource).outOfOrder(true).locations("db/migration-" + dbType).load();			load.migrate();		} catch (SQLException e) {			e.printStackTrace();		}	}}
\ No newline at end of file

File: src/main/java/im/zhaojun/zfile/core/util/RequestHolder.java
Patch:
@@ -57,7 +57,7 @@ public static void writeFile(Function<String, InputStream> function, String path
             String fileName = FileUtil.getName(path);
 
             response.addHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment;filename=" + StringUtils.encodeAllIgnoreSlashes(fileName));
-            response.setContentType(MediaType.APPLICATION_OCTET_STREAM.getType());
+            response.setContentType(MediaType.APPLICATION_OCTET_STREAM_VALUE);
 
             OutputStream outputStream = response.getOutputStream();
 

File: src/main/java/im/zhaojun/zfile/core/exception/handler/GlobalExceptionHandler.java
Patch:
@@ -1 +1 @@
-package im.zhaojun.zfile.core.exception.handler;import cn.dev33.satoken.exception.NotLoginException;import cn.hutool.core.io.IORuntimeException;import cn.hutool.core.util.StrUtil;import com.alibaba.fastjson2.JSON;import im.zhaojun.zfile.core.exception.*;import im.zhaojun.zfile.core.exception.file.init.InitializeStorageSourceException;import im.zhaojun.zfile.core.exception.file.operator.DisableProxyDownloadException;import im.zhaojun.zfile.core.exception.file.operator.StorageSourceFileOperatorException;import im.zhaojun.zfile.core.util.AjaxJson;import im.zhaojun.zfile.core.util.RequestHolder;import im.zhaojun.zfile.core.util.StringUtils;import im.zhaojun.zfile.module.config.service.SystemConfigService;import lombok.extern.slf4j.Slf4j;import org.apache.catalina.connector.ClientAbortException;import org.springframework.core.annotation.Order;import org.springframework.http.HttpStatus;import org.springframework.http.converter.HttpMessageNotReadableException;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.web.HttpMediaTypeNotAcceptableException;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.ResponseStatus;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import java.io.FileNotFoundException;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.Optional;/** * 全局异常处理 * * @author zhaojun */@ControllerAdvice@Slf4j@Order(1)public class GlobalExceptionHandler {    @Resource    private SystemConfigService systemConfigService;    /**     * 存储源文件操作相关异常处理     */    @ExceptionHandler(value = StorageSourceException.class)    @ResponseBody    @ResponseStatus    public AjaxJson<String> storageSourceException(StorageSourceException e) {        log.error("存储源 {} 出现异常", e.getStorageId(), e);        return AjaxJson.getError(e.getResultMessage());    }    /**     * 存储源初始化相关异常处理     */    @ExceptionHandler(value = InitializeStorageSourceException.class)    @ResponseBody    @ResponseStatus    public AjaxJson<String> initializeException(InitializeStorageSourceException e) {        log.error("初始化存储源 {} 失败", e.getStorageId(), e);        return AjaxJson.getError(e.getResultMessage());    }    /**     * 存储源文件操作相关异常处理     */    @ExceptionHandler(value = StorageSourceFileOperatorException.class)    @ResponseBody    @ResponseStatus    public AjaxJson<String> storageSourceFileOperatorException(StorageSourceFileOperatorException e) {        log.error("存储源 {} 文件操作异常", e.getStorageId(), e);        return AjaxJson.getError(e.getResultMessage());    }    @ExceptionHandler({ZFileRuntimeException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<String> getFileInfoException(ZFileRuntimeException e) {        if (e.getCause() != null) {            log.error("ZFileRuntimeException", e);        }        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler({InvalidShortLinkException.class})    @ResponseBody    @ResponseStatus(HttpStatus.NOT_FOUND)    public AjaxJson<String> getFileInfoException(InvalidShortLinkException e) {        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler({IllegalDownloadLinkException.class})    @ResponseBody    @ResponseStatus(HttpStatus.FORBIDDEN)    public AjaxJson<String> getFileInfoException(IllegalDownloadLinkException e) {        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler({LoginVerifyException.class})    @ResponseBody    @ResponseStatus(HttpStatus.FORBIDDEN)    public AjaxJson<String> loginVerifyException(LoginVerifyException e) {        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler(value = {MethodArgumentNotValidException.class, BindException.class})    @ResponseBody    public AjaxJson<Map<String, String>> handleValidException(Exception e) {        BindingResult bindingResult = null;        if (e instanceof MethodArgumentNotValidException) {            bindingResult = ((MethodArgumentNotValidException) e).getBindingResult();        } else if (e instanceof BindException) {            bindingResult = ((BindException) e).getBindingResult();        }        Map<String, String> errorMap = new HashMap<>(16);        Optional.ofNullable(bindingResult)                .map(BindingResult::getFieldErrors)                .ifPresent(fieldErrors -> {                    for (FieldError fieldError : fieldErrors) {                        errorMap.put(fieldError.getField(), fieldError.getDefaultMessage());                    }                });        return new AjaxJson<>(400, "非法参数 !", errorMap);    }    @ExceptionHandler({FileNotFoundException.class})    @ResponseBody    @ResponseStatus(HttpStatus.NOT_FOUND)    public AjaxJson<String> fileNotFound() {        return AjaxJson.getError("文件不存在");    }    /**     * 密码校验异常     */    @ExceptionHandler({PasswordVerifyException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<?> passwordVerifyException(PasswordVerifyException ex) {        return AjaxJson.get(ex.getCode(), ex.getMessage());    }    /**     * 初始化时自动设置 cors 异常     */    @ExceptionHandler({StorageSourceAutoConfigCorsException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<String> autoConfigCorsException(StorageSourceAutoConfigCorsException ex) {        log.error("跨域配置失败, 存储源初始化信息 {}, 异常信息: ", JSON.toJSON(ex.getIStorageParam()), ex);        return AjaxJson.getError(ex.getMessage());    }    @ExceptionHandler({StorageSourceNotSupportProxyUploadException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> storageSourceNotSupportProxyUploadException(StorageSourceNotSupportProxyUploadException e) {        return AjaxJson.getError("非法操作, 当前存储源不支持此方式上传.");    }    @ExceptionHandler(value = DisableProxyDownloadException.class)    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> disableProxyDownloadException(DisableProxyDownloadException e) {        return AjaxJson.getError(e.getResultMessage());    }    @ExceptionHandler({HttpMessageNotReadableException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> handlerHttpMessageNotReadableException(HttpMessageNotReadableException e) {        return AjaxJson.getBadRequestError("请求参数不合法");    }    /**     * 捕获 ClientAbortException 异常, 不做任何处理, 防止出现大量堆栈日志输出, 此异常不影响功能.     */    @ExceptionHandler({HttpMediaTypeNotAcceptableException.class, ClientAbortException.class})    @ResponseBody    @ResponseStatus    public void clientAbortException() {        // if (log.isDebugEnabled()) {        //     log.debug("出现了断开异常:", ex);        // }    }    /**     * 捕获 IORuntimeException 异常, 如果 cause 是 ClientAbortException, 不做任何处理, 防止出现大量堆栈日志输出, 此异常不影响功能.     */    @ExceptionHandler({ IORuntimeException.class })    @ResponseBody    @ResponseStatus    public void ioRuntimeException(IORuntimeException e) {        if (e.getCause() instanceof ClientAbortException) {//            log.info("捕获 ClientAbortException 异常, 不做任何处理, 防止出现大量堆栈日志输出, 此异常不影响功能.");            return;        }        log.error(e.getMessage(), e);    }    @ExceptionHandler    @ResponseBody    @ResponseStatus    public AjaxJson<String> extraExceptionHandler(Exception e) {        log.error(e.getMessage(), e);        if (e.getClass() == Exception.class) {            return AjaxJson.getError("系统异常, 请联系管理员");        } else {            return AjaxJson.getError(e.getMessage());        }    }    /**     * 登录异常拦截器     */    @ExceptionHandler(NotLoginException.class)    @ResponseStatus(HttpStatus.UNAUTHORIZED)    @ResponseBody    public AjaxJson handlerNotLoginException(NotLoginException e) {        HttpServletRequest request = RequestHolder.getRequest();        String axiosRequest = request.getHeader("axios-request");        if (StrUtil.isNotEmpty(axiosRequest)){        	return AjaxJson.getNotLogin();        }        try {            String domain = systemConfigService.getRealFrontDomain();            String loginUrl = StringUtils.removeDuplicateSlashes(domain + "/login");            RequestHolder.getResponse().sendRedirect(loginUrl);        } catch (IOException ex) {            throw new RuntimeException(ex);        }        return null;    }}
\ No newline at end of file
+package im.zhaojun.zfile.core.exception.handler;import cn.dev33.satoken.exception.NotLoginException;import cn.hutool.core.io.IORuntimeException;import cn.hutool.core.util.StrUtil;import com.alibaba.fastjson2.JSON;import im.zhaojun.zfile.core.exception.*;import im.zhaojun.zfile.core.exception.file.init.InitializeStorageSourceException;import im.zhaojun.zfile.core.exception.file.operator.DisableProxyDownloadException;import im.zhaojun.zfile.core.exception.file.operator.StorageSourceFileOperatorException;import im.zhaojun.zfile.core.util.AjaxJson;import im.zhaojun.zfile.core.util.RequestHolder;import im.zhaojun.zfile.core.util.StringUtils;import im.zhaojun.zfile.module.config.service.SystemConfigService;import lombok.extern.slf4j.Slf4j;import org.apache.catalina.connector.ClientAbortException;import org.springframework.core.annotation.Order;import org.springframework.http.HttpStatus;import org.springframework.http.converter.HttpMessageNotReadableException;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.web.HttpMediaTypeNotAcceptableException;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.ResponseStatus;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import java.io.FileNotFoundException;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.Optional;/** * 全局异常处理 * * @author zhaojun */@ControllerAdvice@Slf4j@Order(1)public class GlobalExceptionHandler {    @Resource    private SystemConfigService systemConfigService;    /**     * 存储源文件操作相关异常处理     */    @ExceptionHandler(value = StorageSourceException.class)    @ResponseBody    @ResponseStatus    public AjaxJson<String> storageSourceException(StorageSourceException e) {        log.error("存储源 {} 出现异常", e.getStorageId(), e);        return AjaxJson.getError(e.getResultMessage());    }    /**     * 存储源初始化相关异常处理     */    @ExceptionHandler(value = InitializeStorageSourceException.class)    @ResponseBody    @ResponseStatus    public AjaxJson<String> initializeException(InitializeStorageSourceException e) {        log.error("初始化存储源 {} 失败", e.getStorageId(), e);        return AjaxJson.getError(e.getResultMessage());    }    /**     * 存储源文件操作相关异常处理     */    @ExceptionHandler(value = StorageSourceFileOperatorException.class)    @ResponseBody    @ResponseStatus    public AjaxJson<String> storageSourceFileOperatorException(StorageSourceFileOperatorException e) {        log.error("存储源 {} 文件操作异常", e.getStorageId(), e);        return AjaxJson.getError(e.getResultMessage());    }    @ExceptionHandler({ZFileRuntimeException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<String> getFileInfoException(ZFileRuntimeException e) {        if (e.getCause() != null) {            log.error("ZFileRuntimeException", e);        }        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler({InvalidShortLinkException.class})    @ResponseBody    @ResponseStatus(HttpStatus.NOT_FOUND)    public AjaxJson<String> getFileInfoException(InvalidShortLinkException e) {        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler({IllegalDownloadLinkException.class})    @ResponseBody    @ResponseStatus(HttpStatus.FORBIDDEN)    public AjaxJson<String> getFileInfoException(IllegalDownloadLinkException e) {        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler({LoginVerifyException.class})    @ResponseBody    @ResponseStatus(HttpStatus.FORBIDDEN)    public AjaxJson<String> loginVerifyException(LoginVerifyException e) {        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler(value = {MethodArgumentNotValidException.class, BindException.class})    @ResponseBody    public AjaxJson<Map<String, String>> handleValidException(Exception e) {        BindingResult bindingResult = null;        if (e instanceof MethodArgumentNotValidException) {            bindingResult = ((MethodArgumentNotValidException) e).getBindingResult();        } else if (e instanceof BindException) {            bindingResult = ((BindException) e).getBindingResult();        }        Map<String, String> errorMap = new HashMap<>(16);        Optional.ofNullable(bindingResult)                .map(BindingResult::getFieldErrors)                .ifPresent(fieldErrors -> {                    for (FieldError fieldError : fieldErrors) {                        errorMap.put(fieldError.getField(), fieldError.getDefaultMessage());                    }                });        return new AjaxJson<>(400, "非法参数 !", errorMap);    }    @ExceptionHandler({FileNotFoundException.class})    @ResponseBody    @ResponseStatus(HttpStatus.NOT_FOUND)    public AjaxJson<String> fileNotFound() {        return AjaxJson.getError("文件不存在");    }    /**     * 密码校验异常     */    @ExceptionHandler({PasswordVerifyException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<?> passwordVerifyException(PasswordVerifyException ex) {        return AjaxJson.get(ex.getCode(), ex.getMessage());    }    /**     * 初始化时自动设置 cors 异常     */    @ExceptionHandler({StorageSourceAutoConfigCorsException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<String> autoConfigCorsException(StorageSourceAutoConfigCorsException ex) {        log.error("跨域配置失败, 存储源初始化信息 {}, 异常信息: ", JSON.toJSON(ex.getIStorageParam()), ex);        return AjaxJson.getError(ex.getMessage());    }    @ExceptionHandler({StorageSourceNotSupportProxyUploadException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> storageSourceNotSupportProxyUploadException(StorageSourceNotSupportProxyUploadException e) {        return AjaxJson.getError("非法操作, 当前存储源不支持此方式上传.");    }    @ExceptionHandler(value = DisableProxyDownloadException.class)    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> disableProxyDownloadException(DisableProxyDownloadException e) {        return AjaxJson.getError(e.getResultMessage());    }    @ExceptionHandler({HttpMessageNotReadableException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> handlerHttpMessageNotReadableException(HttpMessageNotReadableException e) {        return AjaxJson.getBadRequestError("请求参数不合法");    }    /**     * 捕获 ClientAbortException 异常, 不做任何处理, 防止出现大量堆栈日志输出, 此异常不影响功能.     */    @ExceptionHandler({HttpMediaTypeNotAcceptableException.class, ClientAbortException.class})    @ResponseBody    @ResponseStatus    public void clientAbortException() {        // if (log.isDebugEnabled()) {        //     log.debug("出现了断开异常:", ex);        // }    }    /**     * 捕获 IORuntimeException 异常, 如果 cause 是 ClientAbortException, 不做任何处理, 防止出现大量堆栈日志输出, 此异常不影响功能.     */    @ExceptionHandler({ IORuntimeException.class })    @ResponseBody    @ResponseStatus    public void ioRuntimeException(IORuntimeException e) {        if (e.getCause() instanceof ClientAbortException) {//            log.info("捕获 ClientAbortException 异常, 不做任何处理, 防止出现大量堆栈日志输出, 此异常不影响功能.");            return;        }        log.error(e.getMessage(), e);    }    @ExceptionHandler    @ResponseBody    @ResponseStatus    public AjaxJson<String> extraExceptionHandler(Exception e) {        log.error(e.getMessage(), e);        if (e.getClass() == Exception.class) {            return AjaxJson.getError("系统异常, 请联系管理员");        } else {            return AjaxJson.getError(e.getMessage());        }    }    /**     * 登录异常拦截器     */    @ExceptionHandler(NotLoginException.class)    @ResponseStatus(HttpStatus.UNAUTHORIZED)    @ResponseBody    public AjaxJson handlerNotLoginException(NotLoginException e) {        HttpServletRequest request = RequestHolder.getRequest();        String axiosRequest = request.getHeader("axios-request");        if (StrUtil.isNotEmpty(axiosRequest)){        	return AjaxJson.getNotLogin();        }        try {            String domain = systemConfigService.getRealFrontDomain();            if (StrUtil.isEmpty(domain)) {                domain = "/";            }            String loginUrl = StringUtils.removeDuplicateSlashes(domain + "/login");            RequestHolder.getResponse().sendRedirect(loginUrl);        } catch (IOException ex) {            throw new RuntimeException(ex);        }        return null;    }}
\ No newline at end of file

File: src/main/java/im/zhaojun/zfile/module/storage/service/impl/LocalServiceImpl.java
Patch:
@@ -257,7 +257,7 @@ private FileItemResult fileToFileItem(File file, String folderPath) {
     private static void checkPathSecurity(String... paths) {
         for (String path : paths) {
             // 路径中不能包含 .. 不然可能会获取到上层文件夹的内容
-            if (StrUtil.containsAny(path, "../", "..\\")) {
+            if (StrUtil.startWith(path, "/..") || StrUtil.containsAny(path, "../", "..\\")) {
                 throw new IllegalArgumentException("文件路径存在安全隐患: " + path);
             }
         }

File: src/main/java/im/zhaojun/zfile/module/storage/service/impl/LocalServiceImpl.java
Patch:
@@ -257,7 +257,7 @@ private FileItemResult fileToFileItem(File file, String folderPath) {
     private static void checkPathSecurity(String... paths) {
         for (String path : paths) {
             // 路径中不能包含 .. 不然可能会获取到上层文件夹的内容
-            if (StrUtil.containsAny(path, "../", "..\\")) {
+            if (StrUtil.startWith(path, "/..") || StrUtil.containsAny(path, "../", "..\\")) {
                 throw new IllegalArgumentException("文件路径存在安全隐患: " + path);
             }
         }

File: src/main/java/im/zhaojun/zfile/module/storage/service/impl/LocalServiceImpl.java
Patch:
@@ -189,6 +189,8 @@ public void uploadFile(String pathAndName, InputStream inputStream) {
         File uploadToFileObj = new File(uploadPath);
         BufferedOutputStream outputStream = FileUtil.getOutputStream(uploadToFileObj);
         IoUtil.copy(inputStream, outputStream);
+        IoUtil.close(outputStream);
+        IoUtil.close(inputStream);
     }
 
 

File: src/main/java/im/zhaojun/zfile/module/storage/service/impl/LocalServiceImpl.java
Patch:
@@ -189,6 +189,8 @@ public void uploadFile(String pathAndName, InputStream inputStream) {
         File uploadToFileObj = new File(uploadPath);
         BufferedOutputStream outputStream = FileUtil.getOutputStream(uploadToFileObj);
         IoUtil.copy(inputStream, outputStream);
+        IoUtil.close(outputStream);
+        IoUtil.close(inputStream);
     }
 
 

File: src/main/java/im/zhaojun/zfile/module/storage/service/impl/LocalServiceImpl.java
Patch:
@@ -238,6 +238,8 @@ private FileItemResult fileToFileItem(File file, String folderPath) {
 
         if (fileItemResult.getType() == FileTypeEnum.FILE) {
             fileItemResult.setUrl(getDownloadUrl(StringUtils.concat(folderPath, file.getName())));
+        } else {
+            fileItemResult.setSize(null);
         }
         return fileItemResult;
     }

File: src/main/java/im/zhaojun/zfile/module/link/aspect/RefererCheckAspect.java
Patch:
@@ -75,6 +75,8 @@ public Object around(ProceedingJoinPoint point) throws Throwable {
 			log.warn("请求路径 {}, referer 不允许为空，当前请求 referer 为空，禁止访问.", requestUrl);
 			httpServletResponse.sendRedirect(forbiddenUrl);
 			return null;
+		} else if (refererAllowEmpty && StrUtil.isEmpty(referer)) { // 如果 referer 允许为空，且当前 referer 为空，则跳过校验
+			return point.proceed();
 		}
 
 		// 获取允许的 referer 地址
@@ -86,8 +88,6 @@ public Object around(ProceedingJoinPoint point) throws Throwable {
 			log.warn("请求路径 {}, referer 为白名单模式，当前请求 referer {} 未在白名单中，禁止访问.", requestUrl, referer);
 			httpServletResponse.sendRedirect(forbiddenUrl);
 			return null;
-		} else if (refererAllowEmpty && StrUtil.isEmpty(referer)) { // 如果 referer 允许为空，且当前 referer 为空，则跳过校验
-			return point.proceed();
 		}
 
 		// 如果是黑名单模式，则校验当前 referer 是否在列表中，则禁止访问.

File: src/main/java/im/zhaojun/zfile/module/storage/model/request/base/FileListConfigRequest.java
Patch:
@@ -21,5 +21,8 @@ public class FileListConfigRequest {
 
 	@ApiModelProperty(value = "请求路径", example = "/")
 	private String path = "/";
+	
+	@ApiModelProperty(value = "文件夹密码", example = "123456")
+	private String password;
 
 }
\ No newline at end of file

File: src/main/java/im/zhaojun/zfile/module/storage/controller/proxy/ProxyUploadController.java
Patch:
@@ -38,8 +38,8 @@ public class ProxyUploadController {
 	@PostMapping("/file/upload/{storageKey}/**")
 	@ResponseBody
 	public AjaxJson<?> upload(@RequestParam MultipartFile file, @PathVariable("storageKey") String storageKey) throws IOException {
-		if (file == null || file.isEmpty()) {
-			return AjaxJson.getError("文件为空，无法上传.");
+		if (file == null) {
+			throw new RuntimeException("空文件不能为空");
 		}
 
 		// 获取上传路径

File: src/main/java/im/zhaojun/zfile/module/link/aspect/RefererCheckAspect.java
Patch:
@@ -86,6 +86,8 @@ public Object around(ProceedingJoinPoint point) throws Throwable {
 			log.warn("请求路径 {}, referer 为白名单模式，当前请求 referer {} 未在白名单中，禁止访问.", requestUrl, referer);
 			httpServletResponse.sendRedirect(forbiddenUrl);
 			return null;
+		} else if (refererAllowEmpty && StrUtil.isEmpty(referer)) { // 如果 referer 允许为空，且当前 referer 为空，则跳过校验
+			return point.proceed();
 		}
 
 		// 如果是黑名单模式，则校验当前 referer 是否在列表中，则禁止访问.

File: src/main/java/im/zhaojun/zfile/module/link/service/ShortLinkService.java
Patch:
@@ -8,6 +8,7 @@
 import cn.hutool.core.util.StrUtil;
 import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
 import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
+import im.zhaojun.zfile.module.storage.annotation.RefererCheck;
 import im.zhaojun.zfile.module.storage.context.StorageSourceContext;
 import im.zhaojun.zfile.core.exception.file.InvalidStorageSourceException;
 import im.zhaojun.zfile.core.exception.file.operator.StorageSourceFileOperatorException;
@@ -146,6 +147,7 @@ public ShortLink generatorShortLink(Integer storageId, String fullPath) {
      *
      * @throws  IOException 可能抛出的 IO 异常
      */
+    @RefererCheck
     public void handlerDownload(String storageKey, String filePath, String shortKey) throws IOException {
         HttpServletRequest request = RequestHolder.getRequest();
         HttpServletResponse response = RequestHolder.getResponse();

File: src/main/java/im/zhaojun/zfile/module/storage/service/StorageSourceConfigService.java
Patch:
@@ -80,7 +80,7 @@ public StorageSourceConfig findByStorageIdAndName(Integer storageId, String name
      * @param   storageId
      *          存储源 ID
      */
-    @CacheEvict(key = "#storageId")
+    @CacheEvict(key = "#storageId", beforeInvocation = true)
     public int deleteByStorageId(Integer storageId) {
         int deleteSize = storageSourceConfigMapper.deleteByStorageId(storageId);
         log.info("删除存储源 ID 为 {} 的参数配置 {} 条", storageId, deleteSize);

File: src/main/java/im/zhaojun/zfile/common/exception/GlobalException.java
Patch:
@@ -1 +1 @@
-package im.zhaojun.zfile.common.exception;import cn.dev33.satoken.exception.NotLoginException;import cn.hutool.core.util.StrUtil;import com.alibaba.fastjson.JSON;import im.zhaojun.zfile.admin.exception.ForbidFileOperationException;import im.zhaojun.zfile.admin.exception.StorageSourceAutoConfigCorsException;import im.zhaojun.zfile.common.exception.file.operator.GetFileInfoException;import im.zhaojun.zfile.common.exception.file.operator.ProxyDownloadFileException;import im.zhaojun.zfile.common.util.AjaxJson;import im.zhaojun.zfile.common.util.RequestHolder;import lombok.extern.slf4j.Slf4j;import org.apache.catalina.connector.ClientAbortException;import org.springframework.http.HttpStatus;import org.springframework.http.converter.HttpMessageNotReadableException;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.web.HttpMediaTypeNotAcceptableException;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.ResponseStatus;import javax.servlet.http.HttpServletRequest;import java.io.IOException;import java.util.HashMap;import java.util.Map;/** * 全局异常处理 * * @author zhaojun */@ControllerAdvice@Slf4jpublic class GlobalException {    @ExceptionHandler({IllegalDownloadLinkException.class})    @ResponseBody    @ResponseStatus(HttpStatus.FORBIDDEN)    public AjaxJson<String> getFileInfoException(IllegalDownloadLinkException e) {        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler({GetFileInfoException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> getFileInfoException(GetFileInfoException e) {        log.error("获取文件信息异常 {}. 存储源 ID: {}, 文件路径: {}", e.getMessage(), e.getStorageId(), e.getPathAndName());        return AjaxJson.getError("获取文件信息异常, 请联系管理员");    }    @ExceptionHandler({ProxyDownloadFileException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> proxyDownloadFileException(ProxyDownloadFileException e) {        log.error("代理下载文件异常 {}. 存储源 ID: {}, 下载路径: {}", e.getMessage(), e.getStorageId(), e.getPathAndName());        return AjaxJson.getError("下载文件异常, 请联系管理员!");    }    @ExceptionHandler({LoginVerifyException.class})    @ResponseBody    @ResponseStatus(HttpStatus.FORBIDDEN)    public AjaxJson<String> loginVerifyException(LoginVerifyException e) {        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler({StorageSourceNotSupportProxyUploadException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> storageSourceNotSupportProxyUploadException(StorageSourceNotSupportProxyUploadException e) {        return AjaxJson.getError("非法操作, 当前存储源不支持此方式上传.");    }    @ExceptionHandler({DisableProxyDownloadException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> disableProxyDownloadException(DisableProxyDownloadException e) {        return AjaxJson.getError("非法操作, 当前文件不支持此类下载方式.");    }    @ExceptionHandler({UnsupportedOperationException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> handleFileUploadException(UnsupportedOperationException e) {        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler({FileUploadException.class})    @ResponseBody    @ResponseStatus(HttpStatus.UNAUTHORIZED)    public AjaxJson<String> handleFileUploadException(FileUploadException e) {        if (log.isDebugEnabled()) {            log.debug("上传文件失败: 存储类型: {}, 存储源 id: {}, 存储源路径: {}",                    e.getStorageTypeEnum(), e.getStorageId(), e.getPath(), e);        }        return AjaxJson.getError("上传失败");    }    @ExceptionHandler({FileAccessException.class})    @ResponseBody    @ResponseStatus(HttpStatus.UNAUTHORIZED)    public AjaxJson<String> handleFileAccessException(FileAccessException e) {        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler({HttpMessageNotReadableException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> handlerHttpMessageNotReadableException(HttpMessageNotReadableException e) {        return AjaxJson.getBadRequestError("请求参数不合法");    }    @ExceptionHandler({NotEnabledStorageSourceException.class})    @ResponseStatus(HttpStatus.FORBIDDEN)    @ResponseBody    public AjaxJson<String> notEnabledDrive() {        return AjaxJson.getError("存储源已关闭");    }    @ExceptionHandler({NotExistFileException.class})    @ResponseBody    public AjaxJson<String> notExistFile() {        return AjaxJson.getError("文件不存在");    }    /**     * 捕获 ClientAbortException 异常, 不做任何处理, 防止出现大量堆栈日志输出, 此异常不影响功能.     */    @ExceptionHandler({HttpMediaTypeNotAcceptableException.class, ClientAbortException.class})    @ResponseBody    @ResponseStatus    public void clientAbortException() {        // if (log.isDebugEnabled()) {        //     log.debug("出现了断开异常:", ex);        // }    }    @ExceptionHandler(value = {MethodArgumentNotValidException.class, BindException.class})    @ResponseBody    public AjaxJson handleValidException(Exception e) {        BindingResult bindingResult = null;        if (e instanceof MethodArgumentNotValidException) {            bindingResult = ((MethodArgumentNotValidException) e).getBindingResult();        } else if (e instanceof BindException) {            bindingResult = ((BindException) e).getBindingResult();        }        Map<String, String> errorMap = new HashMap<>(16);        bindingResult.getFieldErrors().forEach((fieldError) ->                errorMap.put(fieldError.getField(), fieldError.getDefaultMessage())        );        return new AjaxJson(400, "非法参数 !", errorMap);    }    /**     * 密码校验异常     */    @ExceptionHandler({PasswordVerifyException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<?> passwordVerifyException(PasswordVerifyException ex) {        return AjaxJson.get(ex.getCode(), ex.getMessage());    }    /**     * 无效的存储源异常     */    @ExceptionHandler({InvalidStorageSourceException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> invalidDriveException() {        return AjaxJson.getBadRequestError("此存储源不存在或初始化失败, 请检查后台参数配置");    }    /**     * 文件预览异常     */    @ExceptionHandler({PreviewException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<String> previewException(PreviewException ex) {        return AjaxJson.getError(ex.getMessage());    }    /**     * 初始化异常     */    @ExceptionHandler({InitializeStorageSourceException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<String> initializeException(InitializeStorageSourceException ex) {        return AjaxJson.getError(ex.getMessage());    }    /**     * 初始化时自动设置 cors 异常     */    @ExceptionHandler({StorageSourceAutoConfigCorsException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<String> autoConfigCorsException(StorageSourceAutoConfigCorsException ex) {        log.error("跨域配置失败, 存储源初始化信息 {}, 异常信息: ", JSON.toJSON(ex.getIStorageParam()), ex);        return AjaxJson.getError(ex.getMessage());    }    /**     * 无权限时，进行文件操作异常.     */    @ExceptionHandler({ForbidFileOperationException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<String> autoConfigCorsException(ForbidFileOperationException ex) {        log.error("存储源 {} 拦截非法的文件操作 {}", ex.getStorageId(), ex.getAction());        return AjaxJson.getError("非法操作");    }    @ExceptionHandler    @ResponseBody    @ResponseStatus    public AjaxJson<String> extraExceptionHandler(Exception e) {        log.error(e.getMessage(), e);        if (e.getClass() == Exception.class) {            return AjaxJson.getError("系统异常, 请联系管理员");        } else {            return AjaxJson.getError(e.getMessage());        }    }    /**     * 登录异常拦截器     */    @ExceptionHandler(NotLoginException.class)    @ResponseStatus(HttpStatus.UNAUTHORIZED)    @ResponseBody    public AjaxJson handlerNotLoginException(NotLoginException e) {        HttpServletRequest request = RequestHolder.getRequest();        String axiosRequest = request.getHeader("axios-request");        if (StrUtil.isNotEmpty(axiosRequest)){        	return AjaxJson.getNotLogin();        }        try {            RequestHolder.getResponse().sendRedirect("/login");        } catch (IOException ex) {            throw new RuntimeException(ex);        }        return null;    }}
\ No newline at end of file
+package im.zhaojun.zfile.common.exception;import cn.dev33.satoken.exception.NotLoginException;import cn.hutool.core.util.StrUtil;import com.alibaba.fastjson.JSON;import im.zhaojun.zfile.admin.exception.ForbidFileOperationException;import im.zhaojun.zfile.admin.exception.StorageSourceAutoConfigCorsException;import im.zhaojun.zfile.admin.service.SystemConfigService;import im.zhaojun.zfile.common.exception.file.operator.GetFileInfoException;import im.zhaojun.zfile.common.exception.file.operator.ProxyDownloadFileException;import im.zhaojun.zfile.common.util.AjaxJson;import im.zhaojun.zfile.common.util.RequestHolder;import im.zhaojun.zfile.common.util.StringUtils;import lombok.extern.slf4j.Slf4j;import org.apache.catalina.connector.ClientAbortException;import org.springframework.http.HttpStatus;import org.springframework.http.converter.HttpMessageNotReadableException;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.web.HttpMediaTypeNotAcceptableException;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.ResponseStatus;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import java.io.IOException;import java.util.HashMap;import java.util.Map;/** * 全局异常处理 * * @author zhaojun */@ControllerAdvice@Slf4jpublic class GlobalException {        @Resource    private SystemConfigService systemConfigService;        @ExceptionHandler({IllegalDownloadLinkException.class})    @ResponseBody    @ResponseStatus(HttpStatus.FORBIDDEN)    public AjaxJson<String> getFileInfoException(IllegalDownloadLinkException e) {        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler({GetFileInfoException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> getFileInfoException(GetFileInfoException e) {        log.error("获取文件信息异常 {}. 存储源 ID: {}, 文件路径: {}", e.getMessage(), e.getStorageId(), e.getPathAndName());        return AjaxJson.getError("获取文件信息异常, 请联系管理员");    }    @ExceptionHandler({ProxyDownloadFileException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> proxyDownloadFileException(ProxyDownloadFileException e) {        log.error("代理下载文件异常 {}. 存储源 ID: {}, 下载路径: {}", e.getMessage(), e.getStorageId(), e.getPathAndName());        return AjaxJson.getError("下载文件异常, 请联系管理员!");    }    @ExceptionHandler({LoginVerifyException.class})    @ResponseBody    @ResponseStatus(HttpStatus.FORBIDDEN)    public AjaxJson<String> loginVerifyException(LoginVerifyException e) {        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler({StorageSourceNotSupportProxyUploadException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> storageSourceNotSupportProxyUploadException(StorageSourceNotSupportProxyUploadException e) {        return AjaxJson.getError("非法操作, 当前存储源不支持此方式上传.");    }    @ExceptionHandler({DisableProxyDownloadException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> disableProxyDownloadException(DisableProxyDownloadException e) {        return AjaxJson.getError("非法操作, 当前文件不支持此类下载方式.");    }    @ExceptionHandler({UnsupportedOperationException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> handleFileUploadException(UnsupportedOperationException e) {        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler({FileUploadException.class})    @ResponseBody    @ResponseStatus(HttpStatus.UNAUTHORIZED)    public AjaxJson<String> handleFileUploadException(FileUploadException e) {        if (log.isDebugEnabled()) {            log.debug("上传文件失败: 存储类型: {}, 存储源 id: {}, 存储源路径: {}",                    e.getStorageTypeEnum(), e.getStorageId(), e.getPath(), e);        }        return AjaxJson.getError("上传失败");    }    @ExceptionHandler({FileAccessException.class})    @ResponseBody    @ResponseStatus(HttpStatus.UNAUTHORIZED)    public AjaxJson<String> handleFileAccessException(FileAccessException e) {        return AjaxJson.getError(e.getMessage());    }    @ExceptionHandler({HttpMessageNotReadableException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> handlerHttpMessageNotReadableException(HttpMessageNotReadableException e) {        return AjaxJson.getBadRequestError("请求参数不合法");    }    @ExceptionHandler({NotEnabledStorageSourceException.class})    @ResponseStatus(HttpStatus.FORBIDDEN)    @ResponseBody    public AjaxJson<String> notEnabledDrive() {        return AjaxJson.getError("存储源已关闭");    }    @ExceptionHandler({NotExistFileException.class})    @ResponseBody    public AjaxJson<String> notExistFile() {        return AjaxJson.getError("文件不存在");    }    /**     * 捕获 ClientAbortException 异常, 不做任何处理, 防止出现大量堆栈日志输出, 此异常不影响功能.     */    @ExceptionHandler({HttpMediaTypeNotAcceptableException.class, ClientAbortException.class})    @ResponseBody    @ResponseStatus    public void clientAbortException() {        // if (log.isDebugEnabled()) {        //     log.debug("出现了断开异常:", ex);        // }    }    @ExceptionHandler(value = {MethodArgumentNotValidException.class, BindException.class})    @ResponseBody    public AjaxJson handleValidException(Exception e) {        BindingResult bindingResult = null;        if (e instanceof MethodArgumentNotValidException) {            bindingResult = ((MethodArgumentNotValidException) e).getBindingResult();        } else if (e instanceof BindException) {            bindingResult = ((BindException) e).getBindingResult();        }        Map<String, String> errorMap = new HashMap<>(16);        bindingResult.getFieldErrors().forEach((fieldError) ->                errorMap.put(fieldError.getField(), fieldError.getDefaultMessage())        );        return new AjaxJson(400, "非法参数 !", errorMap);    }    /**     * 密码校验异常     */    @ExceptionHandler({PasswordVerifyException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<?> passwordVerifyException(PasswordVerifyException ex) {        return AjaxJson.get(ex.getCode(), ex.getMessage());    }    /**     * 无效的存储源异常     */    @ExceptionHandler({InvalidStorageSourceException.class})    @ResponseBody    @ResponseStatus(HttpStatus.BAD_REQUEST)    public AjaxJson<String> invalidDriveException() {        return AjaxJson.getBadRequestError("此存储源不存在或初始化失败, 请检查后台参数配置");    }    /**     * 文件预览异常     */    @ExceptionHandler({PreviewException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<String> previewException(PreviewException ex) {        return AjaxJson.getError(ex.getMessage());    }    /**     * 初始化异常     */    @ExceptionHandler({InitializeStorageSourceException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<String> initializeException(InitializeStorageSourceException ex) {        return AjaxJson.getError(ex.getMessage());    }    /**     * 初始化时自动设置 cors 异常     */    @ExceptionHandler({StorageSourceAutoConfigCorsException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<String> autoConfigCorsException(StorageSourceAutoConfigCorsException ex) {        log.error("跨域配置失败, 存储源初始化信息 {}, 异常信息: ", JSON.toJSON(ex.getIStorageParam()), ex);        return AjaxJson.getError(ex.getMessage());    }    /**     * 无权限时，进行文件操作异常.     */    @ExceptionHandler({ForbidFileOperationException.class})    @ResponseBody    @ResponseStatus    public AjaxJson<String> autoConfigCorsException(ForbidFileOperationException ex) {        log.error("存储源 {} 拦截非法的文件操作 {}", ex.getStorageId(), ex.getAction());        return AjaxJson.getError("非法操作");    }    @ExceptionHandler    @ResponseBody    @ResponseStatus    public AjaxJson<String> extraExceptionHandler(Exception e) {        log.error(e.getMessage(), e);        if (e.getClass() == Exception.class) {            return AjaxJson.getError("系统异常, 请联系管理员");        } else {            return AjaxJson.getError(e.getMessage());        }    }    /**     * 登录异常拦截器     */    @ExceptionHandler(NotLoginException.class)    @ResponseStatus(HttpStatus.UNAUTHORIZED)    @ResponseBody    public AjaxJson handlerNotLoginException(NotLoginException e) {        HttpServletRequest request = RequestHolder.getRequest();        String axiosRequest = request.getHeader("axios-request");        if (StrUtil.isNotEmpty(axiosRequest)){        	return AjaxJson.getNotLogin();        }        try {            String domain = systemConfigService.getRealFrontDomain();            String loginUrl = StringUtils.removeDuplicateSlashes(domain + "/login");            RequestHolder.getResponse().sendRedirect(loginUrl);        } catch (IOException ex) {            throw new RuntimeException(ex);        }        return null;    }}
\ No newline at end of file

File: src/main/java/im/zhaojun/zfile/admin/service/StorageSourceService.java
Patch:
@@ -495,6 +495,7 @@ public boolean updateById(StorageSource entity) {
         if (entity != null) {
             Integer id = entity.getId();
             storageIdMapCache.put(id, entity);
+            storageKeyMapCache.put(entity.getKey(), entity);
         }
         return super.updateById(entity);
     }

File: src/main/java/im/zhaojun/zfile/admin/model/param/SharePointChinaParam.java
Patch:
@@ -1,12 +1,14 @@
 package im.zhaojun.zfile.admin.model.param;
 
 import im.zhaojun.zfile.admin.annotation.StorageParamItem;
+import lombok.Getter;
 
 /**
  * SharePoint 世纪互联初始化参数
  *
  * @author zhaojun
  */
+@Getter
 public class SharePointChinaParam extends SharePointParam {
 
 	@StorageParamItem(name = "clientId", defaultValue = "${zfile.onedrive-china.clientId}", order = 1)

File: src/main/java/im/zhaojun/zfile/admin/service/StorageSourceConfigService.java
Patch:
@@ -7,6 +7,7 @@
 import im.zhaojun.zfile.admin.model.entity.StorageSourceConfig;
 import lombok.extern.slf4j.Slf4j;
 import org.springframework.stereotype.Service;
+import org.springframework.transaction.annotation.Transactional;
 
 import javax.annotation.Resource;
 import java.util.ArrayList;
@@ -73,6 +74,7 @@ public StorageSourceConfig findByStorageIdAndName(Integer storageId, String name
      * @param   storageSourceConfigList
      *          存储源设置列表
      */
+    @Transactional(rollbackFor = Exception.class)
     public void updateStorageConfig(List<StorageSourceConfig> storageSourceConfigList) {
         super.updateBatchById(storageSourceConfigList);
         if (CollUtil.isNotEmpty(storageSourceConfigList)) {
@@ -89,6 +91,7 @@ public void updateStorageConfig(List<StorageSourceConfig> storageSourceConfigLis
      * @param   id
      *          存储源 ID
      */
+    @Transactional(rollbackFor = Exception.class)
     public void deleteByStorageId(Integer id) {
         storageSourceConfigMapper.deleteByStorageId(id);
         sourceConfigConfigMapCache.remove(id);

File: src/main/java/im/zhaojun/zfile/admin/service/ShortLinkService.java
Patch:
@@ -204,6 +204,7 @@ public void handlerDownload(String storageKey, String filePath, String shortKey)
             OutputStream outputStream = response.getOutputStream();
             byte[] textContentBytes = EncodingUtils.getBytes(textContent, CharsetUtil.CHARSET_UTF_8.displayName());
             IoUtil.write(outputStream, true, textContentBytes);
+            return;
         }
 
         // 禁止直链被浏览器 302 缓存.

File: src/main/java/im/zhaojun/zfile/home/service/impl/LocalServiceImpl.java
Patch:
@@ -185,11 +185,12 @@ public ResponseEntity<Resource> downloadToStream(String pathAndName) {
 
         String fileName = file.getName();
         headers.setContentDispositionFormData("attachment", StringUtils.encodeAllIgnoreSlashes(fileName));
-
+        
         return ResponseEntity
                 .ok()
                 .headers(headers)
                 .contentLength(file.length())
+                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                 .body(new FileSystemResource(file));
     }
 

File: src/main/java/im/zhaojun/zfile/home/service/impl/MinIOServiceImpl.java
Patch:
@@ -27,8 +27,6 @@ public void init() {
                 .withPathStyleAccessEnabled(true)
                 .withCredentials(new AWSStaticCredentialsProvider(credentials))
                 .withEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration(param.getEndPoint(), "minio")).build();
-
-        setUploadCors();
     }
 
     @Override

File: src/main/java/im/zhaojun/zfile/home/controller/SiteController.java
Patch:
@@ -95,7 +95,7 @@ public AjaxJson<StorageSourceConfigResult> storageList(@Valid @RequestBody FileL
 		Integer storageId = storageSource.getId();
 
 		// 获取指定目录 readme 文件
-		ReadmeConfig readmeByPath = readmeConfigService.findReadmeByPath(storageId, "");
+		ReadmeConfig readmeByPath = readmeConfigService.findReadmeByPath(storageId, path);
 
 		if (ObjectUtil.isNotNull(readmeByPath)) {
 			String readmeText = readmeByPath.getReadmeText();

File: src/main/java/im/zhaojun/zfile/home/service/base/AbstractS3BaseFileService.java
Patch:
@@ -58,7 +58,7 @@ public String getDownloadUrl(String pathAndName) {
 
         // 如果不是私有空间, 且指定了加速域名, 则直接返回下载地址.
         if (BooleanUtil.isFalse(param.isPrivate()) && StrUtil.isNotEmpty(domain)) {
-            return StringUtils.concat(domain, fullPath);
+            return StringUtils.concat(domain, StringUtils.encodeAllIgnoreSlashes(fullPath));
         }
 
         Integer tokenTime = param.getTokenTime();

File: src/main/java/im/zhaojun/zfile/home/controller/FileController.java
Patch:
@@ -1 +1 @@
-package im.zhaojun.zfile.home.controller;import com.github.xiaoymin.knife4j.annotations.ApiOperationSupport;import com.github.xiaoymin.knife4j.annotations.ApiSort;import im.zhaojun.zfile.admin.model.entity.StorageSource;import im.zhaojun.zfile.admin.service.StorageSourceService;import im.zhaojun.zfile.common.context.StorageSourceContext;import im.zhaojun.zfile.common.util.AjaxJson;import im.zhaojun.zfile.home.chain.FileChain;import im.zhaojun.zfile.home.chain.FileContext;import im.zhaojun.zfile.home.convert.StorageSourceConvert;import im.zhaojun.zfile.home.model.request.FileListRequest;import im.zhaojun.zfile.home.model.request.SearchStorageRequest;import im.zhaojun.zfile.home.model.result.FileInfoResult;import im.zhaojun.zfile.home.model.result.FileItemResult;import im.zhaojun.zfile.home.model.result.StorageSourceResult;import im.zhaojun.zfile.home.service.base.AbstractBaseFileService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import javax.validation.Valid;import java.util.List;/** * 文件列表相关接口, 如展示存储源列表, 展示文件列表, 搜索文件列表等. * * @author zhaojun */@Api(tags = "文件列表模块")@ApiSort(2)@Slf4j@RequestMapping("/api/storage")@RestControllerpublic class FileController {	@Resource	private StorageSourceContext storageSourceContext;	@Resource	private StorageSourceService storageSourceService;	@Resource	private FileChain fileChain;	@Resource	private StorageSourceConvert storageSourceConvert;	@ApiOperationSupport(order = 1)	@ApiOperation(value = "获取存储源列表", notes = "获取所有已启用的存储源, 并且按照后台顺序排序")	@GetMapping("/list")	public AjaxJson<List<StorageSourceResult>> storageList() {		List<StorageSource> storageList = storageSourceService.findListByEnableOrderByOrderNum();		List<StorageSourceResult> storageSourceResultList =				storageSourceConvert.entityToResultList(storageList);		return AjaxJson.getSuccessData(storageSourceResultList);	}	@ApiOperationSupport(order = 2)	@ApiOperation(value = "获取文件列表", notes = "获取某个存储源下, 指定路径的文件&文件夹列表")	@PostMapping("/files")	public AjaxJson<FileInfoResult> list(@Valid @RequestBody FileListRequest fileListRequest) throws Exception {		StorageSource storageSource = storageSourceService.findByStorageKey(fileListRequest.getStorageKey());		Integer storageId = storageSource.getId();		// 处理请求参数默认值		fileListRequest.handleDefaultValue();		// 获取文件列表		AbstractBaseFileService<?> fileService = storageSourceContext.get(storageId);		List<FileItemResult> fileItemList = fileService.fileList(fileListRequest.getPath());		// 执行责任链		FileContext fileContext = FileContext.builder()				.storageId(storageId)				.fileListRequest(fileListRequest)				.fileItemList(fileItemList).build();		fileChain.execute(fileContext);		return AjaxJson.getSuccessData(new FileInfoResult(fileContext.getFileItemList(), fileContext.getPasswordPattern()));	}	@ApiOperationSupport(order = 3)	@ApiOperation(value = "搜索文件", notes = "搜索指定存储源下的文件和文件夹")	@PostMapping("/search")	public AjaxJson<List<FileItemResult>> search(@Valid @RequestBody SearchStorageRequest searchStorageRequest) {		AbstractBaseFileService<?> fileService = storageSourceContext.getByKey(searchStorageRequest.getStorageKey());		List<FileItemResult> search = fileService.search(searchStorageRequest.getSearchVal());		return AjaxJson.getSuccessData(search);	}}
\ No newline at end of file
+package im.zhaojun.zfile.home.controller;import com.github.xiaoymin.knife4j.annotations.ApiOperationSupport;import com.github.xiaoymin.knife4j.annotations.ApiSort;import im.zhaojun.zfile.admin.model.entity.StorageSource;import im.zhaojun.zfile.admin.service.StorageSourceService;import im.zhaojun.zfile.common.context.StorageSourceContext;import im.zhaojun.zfile.common.exception.InvalidStorageSourceException;import im.zhaojun.zfile.common.util.AjaxJson;import im.zhaojun.zfile.home.chain.FileChain;import im.zhaojun.zfile.home.chain.FileContext;import im.zhaojun.zfile.home.convert.StorageSourceConvert;import im.zhaojun.zfile.home.model.request.FileListRequest;import im.zhaojun.zfile.home.model.request.SearchStorageRequest;import im.zhaojun.zfile.home.model.result.FileInfoResult;import im.zhaojun.zfile.home.model.result.FileItemResult;import im.zhaojun.zfile.home.model.result.StorageSourceResult;import im.zhaojun.zfile.home.service.base.AbstractBaseFileService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import javax.validation.Valid;import java.util.List;/** * 文件列表相关接口, 如展示存储源列表, 展示文件列表, 搜索文件列表等. * * @author zhaojun */@Api(tags = "文件列表模块")@ApiSort(2)@Slf4j@RequestMapping("/api/storage")@RestControllerpublic class FileController {	@Resource	private StorageSourceContext storageSourceContext;	@Resource	private StorageSourceService storageSourceService;	@Resource	private FileChain fileChain;	@Resource	private StorageSourceConvert storageSourceConvert;	@ApiOperationSupport(order = 1)	@ApiOperation(value = "获取存储源列表", notes = "获取所有已启用的存储源, 并且按照后台顺序排序")	@GetMapping("/list")	public AjaxJson<List<StorageSourceResult>> storageList() {		List<StorageSource> storageList = storageSourceService.findListByEnableOrderByOrderNum();		List<StorageSourceResult> storageSourceResultList =				storageSourceConvert.entityToResultList(storageList);		return AjaxJson.getSuccessData(storageSourceResultList);	}	@ApiOperationSupport(order = 2)	@ApiOperation(value = "获取文件列表", notes = "获取某个存储源下, 指定路径的文件&文件夹列表")	@PostMapping("/files")	public AjaxJson<FileInfoResult> list(@Valid @RequestBody FileListRequest fileListRequest) throws Exception {		StorageSource storageSource = storageSourceService.findByStorageKey(fileListRequest.getStorageKey());		if (storageSource == null) {			throw new InvalidStorageSourceException("存储源不存在");		}		Integer storageId = storageSource.getId();		// 处理请求参数默认值		fileListRequest.handleDefaultValue();		// 获取文件列表		AbstractBaseFileService<?> fileService = storageSourceContext.get(storageId);		List<FileItemResult> fileItemList = fileService.fileList(fileListRequest.getPath());		// 执行责任链		FileContext fileContext = FileContext.builder()				.storageId(storageId)				.fileListRequest(fileListRequest)				.fileItemList(fileItemList).build();		fileChain.execute(fileContext);		return AjaxJson.getSuccessData(new FileInfoResult(fileContext.getFileItemList(), fileContext.getPasswordPattern()));	}	@ApiOperationSupport(order = 3)	@ApiOperation(value = "搜索文件", notes = "搜索指定存储源下的文件和文件夹")	@PostMapping("/search")	public AjaxJson<List<FileItemResult>> search(@Valid @RequestBody SearchStorageRequest searchStorageRequest) {		AbstractBaseFileService<?> fileService = storageSourceContext.getByKey(searchStorageRequest.getStorageKey());		List<FileItemResult> search = fileService.search(searchStorageRequest.getSearchVal());		return AjaxJson.getSuccessData(search);	}}
\ No newline at end of file

File: src/main/java/im/zhaojun/zfile/home/service/base/AbstractSharePointServiceBase.java
Patch:
@@ -16,7 +16,7 @@ public String getType() {
 
     @Override
     public String getDownloadUrl(String pathAndName) {
-        return null;
+        return getFileItem(pathAndName).getUrl();
     }
 
 }
\ No newline at end of file

File: src/main/java/im/zhaojun/zfile/service/impl/WebdavServiceImpl.java
Patch:
@@ -55,7 +55,7 @@ public void init(Integer driveId) {
 		} else {
 			// 如果用户名和密码为空，则使用默认用户名和密码
 			if (StrUtil.isNotEmpty(username) && StrUtil.isNotEmpty(password)) {
-				sardine = SardineFactory.begin("admin", "YgSBFCbH");
+				sardine = SardineFactory.begin(username, password);
 			} else {
 				sardine = SardineFactory.begin();
 			}

File: src/main/java/im/zhaojun/zfile/config/webdav/adapter/WebDavUrlAdapterImpl.java
Patch:
@@ -27,7 +27,7 @@ public class WebDavUrlAdapterImpl implements UrlAdapter {
     @Override
     public String getUrl(Request request) {
         // 匹配url前缀和驱动器ID
-        Matcher matcher = RegexMatchUtils.match("^" + ZFileConstant.WEB_DAV_PREFIX + "/(\\d+?)(.*)",
+        Matcher matcher = RegexMatchUtils.match("^" + ZFileConstant.WEB_DAV_PREFIX + "/(\\d+)(.*)",
                 HttpManager.decodeUrl(request.getAbsolutePath()));
         final String driveId = RegexMatchUtils.getIndexResult(matcher, 1);
         if (driveId == null) {

File: src/main/java/im/zhaojun/zfile/controller/home/WebDavController.java
Patch:
@@ -153,7 +153,7 @@ public Long getContentLength(WebDavEntity entity) {
      */
     private Integer getDriveId() {
         String requestUrl = HttpManager.decodeUrl(HttpManager.request().getAbsolutePath());
-        final String driveId = RegexMatchUtils.matchByIndex("^" + ZFileConstant.WEB_DAV_PREFIX + "/(\\d+?)(.*)", requestUrl, 1);
+        final String driveId = RegexMatchUtils.matchByIndex("^" + ZFileConstant.WEB_DAV_PREFIX + "/(\\d+)(.*)", requestUrl, 1);
         return driveId != null ? Integer.valueOf(driveId) : null;
     }
 }
\ No newline at end of file

File: src/main/java/im/zhaojun/zfile/config/webdav/adapter/WebDavUrlAdapterImpl.java
Patch:
@@ -27,7 +27,7 @@ public class WebDavUrlAdapterImpl implements UrlAdapter {
     @Override
     public String getUrl(Request request) {
         // 匹配url前缀和驱动器ID
-        Matcher matcher = RegexMatchUtils.match("^" + ZFileConstant.WEB_DAV_PREFIX + "/(\\d+?)(.*)",
+        Matcher matcher = RegexMatchUtils.match("^" + ZFileConstant.WEB_DAV_PREFIX + "/(\\d+)(.*)",
                 HttpManager.decodeUrl(request.getAbsolutePath()));
         final String driveId = RegexMatchUtils.getIndexResult(matcher, 1);
         if (driveId == null) {

File: src/main/java/im/zhaojun/zfile/controller/home/WebDavController.java
Patch:
@@ -153,7 +153,7 @@ public Long getContentLength(WebDavEntity entity) {
      */
     private Integer getDriveId() {
         String requestUrl = HttpManager.decodeUrl(HttpManager.request().getAbsolutePath());
-        final String driveId = RegexMatchUtils.matchByIndex("^" + ZFileConstant.WEB_DAV_PREFIX + "/(\\d+?)(.*)", requestUrl, 1);
+        final String driveId = RegexMatchUtils.matchByIndex("^" + ZFileConstant.WEB_DAV_PREFIX + "/(\\d+)(.*)", requestUrl, 1);
         return driveId != null ? Integer.valueOf(driveId) : null;
     }
 }
\ No newline at end of file

File: src/main/java/im/zhaojun/zfile/model/entity/ShortLinkConfig.java
Patch:
@@ -13,11 +13,10 @@ public class ShortLinkConfig {
     @GeneratedValue(strategy = GenerationType.IDENTITY)
     private Integer id;
 
-    @Column(name = "`key`")
     private String key;
 
     private String url;
 
     private Date createDate;
 
-}
+}
\ No newline at end of file

File: src/main/java/im/zhaojun/zfile/service/impl/UpYunServiceImpl.java
Patch:
@@ -22,6 +22,7 @@
 
 import javax.annotation.Resource;
 import java.io.IOException;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.HashMap;
@@ -121,7 +122,7 @@ public FileItemDTO getFileItem(String path) {
             int lastDelimiterIndex = path.lastIndexOf("/");
             String name = path.substring(lastDelimiterIndex + 1);
 
-            Map<String, String> fileInfo = upYun.getFileInfo(StringUtils.removeDuplicateSeparator(basePath + ZFileConstant.PATH_SEPARATOR + path));
+            Map<String, String> fileInfo = upYun.getFileInfo(URLUtil.encode(StringUtils.removeDuplicateSeparator(basePath + ZFileConstant.PATH_SEPARATOR + path), StandardCharsets.UTF_8));
 
             if (fileInfo == null) {
                 throw new NotExistFileException();

File: src/main/java/im/zhaojun/zfile/service/impl/LocalServiceImpl.java
Patch:
@@ -74,7 +74,7 @@ public void init(Integer driveId) {
 
     @Override
     public List<FileItemDTO> fileList(String path) throws FileNotFoundException {
-        if (StrUtil.startWith(path, "..")) {
+        if (StrUtil.startWith(path, "..") || StrUtil.startWith(path, "/..")) {
             return Collections.emptyList();
         }
         List<FileItemDTO> fileItemList = new ArrayList<>();

File: src/main/java/im/zhaojun/zfile/schedule/OneDriveTokenRefreshSchedule.java
Patch:
@@ -40,6 +40,9 @@ public void autoRefreshOneDriveToken() {
 
             List<DriveConfig> driveConfigList = driveConfigService.findByType(StorageTypeEnum.ONE_DRIVE);
             driveConfigList.addAll(driveConfigService.findByType(StorageTypeEnum.ONE_DRIVE_CHINA));
+            driveConfigList.addAll(driveConfigService.findByType(StorageTypeEnum.SHAREPOINT_DRIVE));
+            driveConfigList.addAll(driveConfigService.findByType(StorageTypeEnum.SHAREPOINT_DRIVE_CHINA));
+
 
             driveConfigList.forEach(driveConfig -> {
                 try {

File: src/main/java/im/zhaojun/zfile/model/dto/StorageStrategyConfig.java
Patch:
@@ -48,4 +48,6 @@ public class StorageStrategyConfig {
 
     private String proxyDomain;
 
+    private String region;
+
 }
\ No newline at end of file

File: src/main/java/im/zhaojun/zfile/controller/install/InstallController.java
Patch:
@@ -30,7 +30,7 @@ public ResultBean isInstall() {
     }
 
 
-    @PostMapping("/install")
+    @PostMapping("/doInstall")
     public ResultBean install(SystemConfigDTO systemConfigDTO) {
         if (!StringUtils.isEmpty(systemConfigService.getAdminUsername())) {
             return ResultBean.error("请勿重复初始化.");

File: src/main/java/im/zhaojun/zfile/service/impl/FtpServiceImpl.java
Patch:
@@ -13,7 +13,6 @@
 import im.zhaojun.zfile.util.StringUtils;
 import lombok.SneakyThrows;
 import org.apache.commons.net.ftp.FTP;
-import org.apache.commons.net.ftp.FTPClientConfig;
 import org.apache.commons.net.ftp.FTPFile;
 import org.springframework.beans.factory.config.ConfigurableBeanFactory;
 import org.springframework.context.annotation.Scope;
@@ -65,7 +64,6 @@ public void init(Integer driveId) {
             isInitialized = false;
         } else {
             ftp = new Ftp(host, Integer.parseInt(port), username, password, StandardCharsets.UTF_8);
-            ftp.getClient().configure(new FTPClientConfig(FTPClientConfig.SYST_UNIX));
             ftp.getClient().type(FTP.BINARY_FILE_TYPE);
             testConnection();
             isInitialized = true;
@@ -83,7 +81,6 @@ public List<FileItemDTO> fileList(String path) {
             ftpFiles = ftp.getClient().listFiles(fullPath);
         } catch (Exception e) {
             e.printStackTrace();
-            // ignore
         }
 
         List<FileItemDTO> fileItemList = new ArrayList<>();

File: src/main/java/im/zhaojun/zfile/controller/admin/LogController.java
Patch:
@@ -9,7 +9,6 @@
 import org.springframework.web.bind.annotation.RequestMapping;
 import org.springframework.web.bind.annotation.RestController;
 
-import javax.servlet.http.HttpServletResponse;
 import java.io.File;
 import java.util.Date;
 
@@ -26,14 +25,14 @@ public class LogController {
      * 系统日志下载
      */
     @GetMapping("/log")
-    public ResponseEntity<Object> downloadLog(HttpServletResponse response) {
+    public ResponseEntity<Object> downloadLog() {
         if (log.isDebugEnabled()) {
             log.debug("下载诊断日志");
         }
         String userHome = System.getProperty("user.home");
         File fileZip = ZipUtil.zip(userHome + "/.zfile/logs");
         String currentDate = DateUtil.format(new Date(), "yyyy-MM-dd HH:mm:ss");
-        return FileUtil.export(fileZip, "ZFile 诊断日志 - " + currentDate + ".zip");
+        return FileUtil.exportSingleThread(fileZip, "ZFile 诊断日志 - " + currentDate + ".zip");
     }
 
 }
\ No newline at end of file

File: src/main/java/im/zhaojun/zfile/controller/home/LocalController.java
Patch:
@@ -32,8 +32,6 @@ public class LocalController {
      *
      * @param   driveId
      *          驱动器 ID
-     *
-     * @return  文件
      */
     @GetMapping("/file/{driveId}/**")
     @ResponseBody

File: src/main/java/im/zhaojun/zfile/repository/ShortLinkConfigRepository.java
Patch:
@@ -23,7 +23,7 @@ public interface ShortLinkConfigRepository extends JpaRepository<ShortLinkConfig
      * @param       key
      *              短链 Key
      */
-    ShortLinkConfig findByKey(String key);
+    ShortLinkConfig findFirstByKey(String key);
 
     @Query(nativeQuery = true,
             value = " select * from SHORT_LINK where " +
@@ -57,7 +57,7 @@ public interface ShortLinkConfigRepository extends JpaRepository<ShortLinkConfig
      * @param       url
      *              短链 URL
      */
-    ShortLinkConfig findByUrl(String url);
+    ShortLinkConfig findFirstByUrl(String url);
 
 
     /**

File: src/main/java/im/zhaojun/zfile/service/ShortLinkConfigService.java
Patch:
@@ -25,7 +25,7 @@ public class ShortLinkConfigService {
     private ShortLinkConfigRepository shortLinkConfigRepository;
 
     public ShortLinkConfig findByKey(String key) {
-        return shortLinkConfigRepository.findByKey(key);
+        return shortLinkConfigRepository.findFirstByKey(key);
     }
 
     public ShortLinkConfig findById(Integer id) {
@@ -34,7 +34,7 @@ public ShortLinkConfig findById(Integer id) {
     }
 
     public ShortLinkConfig findByUrl(String url) {
-        return shortLinkConfigRepository.findByUrl(url);
+        return shortLinkConfigRepository.findFirstByUrl(url);
     }
 
     public void save(ShortLinkConfig shortLinkConfig) {

File: src/main/java/im/zhaojun/zfile/controller/home/FileController.java
Patch:
@@ -20,6 +20,7 @@
 import im.zhaojun.zfile.util.HttpUtil;
 import im.zhaojun.zfile.util.StringUtils;
 import lombok.extern.slf4j.Slf4j;
+import org.springframework.beans.factory.annotation.Value;
 import org.springframework.web.bind.annotation.GetMapping;
 import org.springframework.web.bind.annotation.PathVariable;
 import org.springframework.web.bind.annotation.RequestMapping;

File: src/main/java/im/zhaojun/zfile/controller/admin/DebugController.java
Patch:
@@ -6,6 +6,7 @@
 import org.springframework.beans.factory.annotation.Value;
 import org.springframework.stereotype.Controller;
 import org.springframework.web.bind.annotation.GetMapping;
+import org.springframework.web.bind.annotation.ResponseBody;
 
 import javax.annotation.Resource;
 
@@ -18,6 +19,7 @@ public class DebugController {
     @Resource
     private SystemConfigService systemConfigService;
 
+    @ResponseBody
     @GetMapping("/debug/resetPwd")
     public ResultBean resetPwd() {
         if (debug) {

File: src/main/java/im/zhaojun/zfile/model/dto/SystemFrontConfigDTO.java
Patch:
@@ -41,4 +41,6 @@ public class SystemFrontConfigDTO {
 
     private String readme;
 
+    private Boolean debugMode;
+
 }
\ No newline at end of file

File: src/main/java/im/zhaojun/zfile/aspect/FileListCacheAspect.java
Patch:
@@ -11,6 +11,7 @@
 import org.springframework.stereotype.Component;
 
 import javax.annotation.Resource;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -50,7 +51,7 @@ public Object around(ProceedingJoinPoint point) throws Throwable {
         if (enableCache) {
             List<FileItemDTO> cacheFileList = zFileCache.get(driveId, path);
             if (cacheFileList == null) {
-                result = (List<FileItemDTO>) point.proceed();
+                result = Collections.unmodifiableList((List<FileItemDTO>) point.proceed());
                 zFileCache.put(driveId, path, result);
             } else {
                 result = cacheFileList;

File: src/main/java/im/zhaojun/zfile/util/FileComparator.java
Patch:
@@ -1,5 +1,6 @@
 package im.zhaojun.zfile.util;
 
+import cn.hutool.core.comparator.CompareUtil;
 import im.zhaojun.zfile.model.dto.FileItemDTO;
 import im.zhaojun.zfile.model.enums.FileTypeEnum;
 
@@ -43,8 +44,8 @@ public int compare(FileItemDTO o1, FileItemDTO o2) {
         if (o1Type.equals(o2Type)) {
             int result;
             switch (sortBy) {
-                case "time": result = o1.getTime().compareTo(o2.getTime()); break;
-                case "size": result = o1.getSize().compareTo(o2.getSize()); break;
+                case "time": result = CompareUtil.compare(o1.getTime(), o2.getTime()); break;
+                case "size": result = CompareUtil.compare(o1.getSize(), o2.getSize()); break;
                 default: result = naturalOrderComparator.compare(o1.getName(), o2.getName()); break;
             }
             return "asc".equals(order) ? result : -result;

File: src/main/java/im/zhaojun/zfile/service/impl/LocalServiceImpl.java
Patch:
@@ -69,7 +69,7 @@ public void init(Integer driveId) {
     public List<FileItemDTO> fileList(String path) throws FileNotFoundException {
         List<FileItemDTO> fileItemList = new ArrayList<>();
 
-        String fullPath = StringUtils.concatPath(filePath, path);
+        String fullPath = StringUtils.removeDuplicateSeparator(filePath + path);
 
         File file = new File(fullPath);
 

File: src/main/java/im/zhaojun/zfile/model/entity/SystemConfig.java
Patch:
@@ -7,6 +7,7 @@
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
+import javax.persistence.Lob;
 
 /**
  * @author zhaojun
@@ -22,6 +23,7 @@ public class SystemConfig {
     @Column(name = "k")
     private String key;
 
+    @Lob
     private String value;
 
     private String remark;

File: src/main/java/im/zhaojun/zfile/model/entity/StorageConfig.java
Patch:
@@ -8,6 +8,7 @@
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
+import javax.persistence.Lob;
 
 /**
  * @author zhaojun
@@ -27,7 +28,7 @@ public class StorageConfig {
 
     private String title;
 
-    @Column(length = 4000)
+    @Lob
     private String value;
 
     private Integer driveId;

File: src/main/java/im/zhaojun/zfile/model/dto/StorageStrategyConfig.java
Patch:
@@ -12,7 +12,7 @@ public class StorageStrategyConfig {
 
     private String pathStyle;
 
-    private boolean isPrivate;
+    private Boolean isPrivate;
 
     private String accessKey;
 

File: src/main/java/im/zhaojun/zfile/service/base/AbstractBaseFileService.java
Patch:
@@ -29,11 +29,11 @@ public abstract class AbstractBaseFileService implements BaseFileService {
      */
     protected boolean isInitialized = false;
 
+
     /**
      * 基路径
      */
     protected String basePath;
-
     /**
      * 驱动器 ID
      */

File: src/main/java/im/zhaojun/zfile/service/base/AbstractS3BaseFileService.java
Patch:
@@ -93,6 +93,7 @@ public List<FileItemDTO> s3FileList(String path) {
      * @return  S3 对象访问地址
      */
     public String s3ObjectUrl(String path) {
+        basePath = basePath == null ? "" : basePath;
         String fullPath = StringUtils.removeFirstSeparator(StringUtils.removeDuplicateSeparator(basePath + "/" + path));
 
         // 如果不是私有空间, 且指定了加速域名, 则直接返回下载地址.

File: src/main/java/im/zhaojun/zfile/service/impl/AliyunServiceImpl.java
Patch:
@@ -57,7 +57,7 @@ public void init(Integer driveId) {
                 isInitialized = testConnection();
             }
         } catch (Exception e) {
-            log.debug(getStorageTypeEnum().getDescription() + " 初始化异常, 已跳过");
+            log.debug(getStorageTypeEnum().getDescription() + " 初始化异常, 已跳过", e);
         }
     }
 
@@ -75,6 +75,7 @@ public List<StorageConfig> storageStrategyConfigList() {
             add(new StorageConfig("domain", "Bucket 域名 / CDN 加速域名"));
             add(new StorageConfig("endPoint", "区域"));
             add(new StorageConfig("basePath", "基路径"));
+            add(new StorageConfig("isPrivate", "是否是私有空间"));
         }};
     }
 }
\ No newline at end of file

File: src/main/java/im/zhaojun/aliyun/service/AliyunServiceImpl.java
Patch:
@@ -1,5 +1,6 @@
 package im.zhaojun.aliyun.service;
 
+import cn.hutool.core.convert.Convert;
 import com.amazonaws.auth.AWSStaticCredentialsProvider;
 import com.amazonaws.auth.BasicAWSCredentials;
 import com.amazonaws.client.builder.AwsClientBuilder;
@@ -36,6 +37,7 @@ public void init() {
             super.domain = stringStorageConfigMap.get(StorageConfigConstant.DOMAIN_KEY).getValue();
             super.basePath = stringStorageConfigMap.get(StorageConfigConstant.BASE_PATH).getValue();
             super.bucketName = stringStorageConfigMap.get(StorageConfigConstant.BUCKET_NAME_KEY).getValue();
+            super.isPrivate = Convert.toBool(stringStorageConfigMap.get(StorageConfigConstant.IS_PRIVATE).getValue(), true);
 
             if (Objects.isNull(accessKey) || Objects.isNull(secretKey) || Objects.isNull(endPoint) || Objects.isNull(bucketName)) {
                 log.debug("初始化存储策略 [{}] 失败: 参数不完整", getStorageTypeEnum().getDescription());

File: src/main/java/im/zhaojun/huawei/service/HuaweiServiceImpl.java
Patch:
@@ -1,5 +1,6 @@
 package im.zhaojun.huawei.service;
 
+import cn.hutool.core.convert.Convert;
 import com.amazonaws.auth.AWSStaticCredentialsProvider;
 import com.amazonaws.auth.BasicAWSCredentials;
 import com.amazonaws.client.builder.AwsClientBuilder;
@@ -36,6 +37,7 @@ public void init() {
             bucketName = stringStorageConfigMap.get(StorageConfigConstant.BUCKET_NAME_KEY).getValue();
             domain = stringStorageConfigMap.get(StorageConfigConstant.DOMAIN_KEY).getValue();
             basePath = stringStorageConfigMap.get(StorageConfigConstant.BASE_PATH).getValue();
+            isPrivate = Convert.toBool(stringStorageConfigMap.get(StorageConfigConstant.IS_PRIVATE).getValue(), true);
 
             if (Objects.isNull(accessKey) || Objects.isNull(secretKey) || Objects.isNull(endPoint) || Objects.isNull(bucketName)) {
                 log.debug("初始化存储策略 [{}] 失败: 参数不完整", getStorageTypeEnum().getDescription());

File: src/main/java/im/zhaojun/minio/MinIOServiceImpl.java
Patch:
@@ -1,5 +1,6 @@
 package im.zhaojun.minio;
 
+import cn.hutool.core.convert.Convert;
 import com.amazonaws.auth.AWSStaticCredentialsProvider;
 import com.amazonaws.auth.BasicAWSCredentials;
 import com.amazonaws.client.builder.AwsClientBuilder;
@@ -34,6 +35,7 @@ public void init() {
             String endPoint = stringStorageConfigMap.get(StorageConfigConstant.ENDPOINT_KEY).getValue();
             bucketName = stringStorageConfigMap.get(StorageConfigConstant.BUCKET_NAME_KEY).getValue();
             basePath = stringStorageConfigMap.get(StorageConfigConstant.BASE_PATH).getValue();
+            isPrivate = Convert.toBool(stringStorageConfigMap.get(StorageConfigConstant.IS_PRIVATE).getValue(), true);
 
             if (Objects.isNull(accessKey) || Objects.isNull(secretKey) || Objects.isNull(endPoint) || Objects.isNull(bucketName)) {
                 log.debug("初始化存储策略 [{}] 失败: 参数不完整", getStorageTypeEnum().getDescription());

File: src/main/java/im/zhaojun/qiniu/service/QiniuServiceImpl.java
Patch:
@@ -1,5 +1,6 @@
 package im.zhaojun.qiniu.service;
 
+import cn.hutool.core.convert.Convert;
 import com.amazonaws.auth.AWSStaticCredentialsProvider;
 import com.amazonaws.auth.BasicAWSCredentials;
 import com.amazonaws.client.builder.AwsClientBuilder;
@@ -36,6 +37,7 @@ public void init() {
             bucketName = stringStorageConfigMap.get(StorageConfigConstant.BUCKET_NAME_KEY).getValue();
             domain = stringStorageConfigMap.get(StorageConfigConstant.DOMAIN_KEY).getValue();
             basePath = stringStorageConfigMap.get(StorageConfigConstant.BASE_PATH).getValue();
+            isPrivate = Convert.toBool(stringStorageConfigMap.get(StorageConfigConstant.IS_PRIVATE).getValue(), true);
 
             if (Objects.isNull(accessKey) || Objects.isNull(secretKey) || Objects.isNull(endPoint) || Objects.isNull(bucketName)) {
                 log.debug("初始化存储策略 [{}] 失败: 参数不完整", getStorageTypeEnum().getDescription());

File: src/main/java/im/zhaojun/tencent/TencentServiceImpl.java
Patch:
@@ -1,5 +1,6 @@
 package im.zhaojun.tencent;
 
+import cn.hutool.core.convert.Convert;
 import com.amazonaws.auth.AWSStaticCredentialsProvider;
 import com.amazonaws.auth.BasicAWSCredentials;
 import com.amazonaws.client.builder.AwsClientBuilder;
@@ -35,6 +36,7 @@ public void init() {
             bucketName = stringStorageConfigMap.get(StorageConfigConstant.BUCKET_NAME_KEY).getValue();
             domain = stringStorageConfigMap.get(StorageConfigConstant.DOMAIN_KEY).getValue();
             basePath = stringStorageConfigMap.get(StorageConfigConstant.BASE_PATH).getValue();
+            isPrivate = Convert.toBool(stringStorageConfigMap.get(StorageConfigConstant.IS_PRIVATE).getValue(), true);
 
             if (Objects.isNull(secretId) || Objects.isNull(secretKey) || Objects.isNull(endPoint) || Objects.isNull(bucketName)) {
                 log.debug("初始化存储策略 [{}] 失败: 参数不完整", getStorageTypeEnum().getDescription());

File: src/main/java/im/zhaojun/local/controller/LocalController.java
Patch:
@@ -37,7 +37,7 @@ public ResponseEntity<Object> downAttachment(final HttpServletRequest request) {
         AntPathMatcher apm = new AntPathMatcher();
         String filePath = apm.extractPathWithinPattern(bestMatchPattern, path);
 
-        return export(new File(StringUtils.concatPath(localServiceImpl.getFilePath(), URLUtil.decode(filePath))));
+        return export(new File(StringUtils.concatPath(localServiceImpl.getFilePath(), filePath)));
     }
 
     private ResponseEntity<Object> export(File file) {

File: src/main/java/im/zhaojun/local/service/LocalServiceImpl.java
Patch:
@@ -90,7 +90,7 @@ public List<FileItemDTO> fileList(String path) {
     @Override
     public String getDownloadUrl(String path) {
         SystemConfig usernameConfig = systemConfigRepository.findByKey(SystemConfigConstant.DOMAIN);
-        return URLUtil.encode(StringUtils.removeDuplicateSeparator(usernameConfig.getValue() + "/file/" + path));
+        return StringUtils.removeDuplicateSeparator(usernameConfig.getValue() + "/file/" + path);
     }
 
     public String getFilePath() {

File: src/main/java/im/zhaojun/onedrive/common/service/AbstractOneDriveService.java
Patch:
@@ -20,6 +20,8 @@
 import org.springframework.web.client.RestTemplate;
 
 import javax.annotation.Resource;
+import java.net.URLDecoder;
+import java.net.URLEncoder;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -100,6 +102,7 @@ public List<FileItemDTO> fileList(String path) {
             String requestUrl;
 
             if (nextLink != null) {
+                nextLink = nextLink.replace("+", "%2B");
                 requestUrl = URLUtil.decode(nextLink);
             }else if ("/".equalsIgnoreCase(fullPath) || "".equalsIgnoreCase(fullPath)) {
                 requestUrl = DRIVER_ROOT_URL;

File: src/main/java/im/zhaojun/common/model/StorageConfig.java
Patch:
@@ -27,7 +27,7 @@ public class StorageConfig {
 
     private String title;
 
-    @Column(length = 2048)
+    @Column(length = 4000)
     private String value;
 
     public Integer getId() {

File: src/main/java/im/zhaojun/onedrive/common/service/AbstractOneDriveService.java
Patch:
@@ -1,5 +1,6 @@
 package im.zhaojun.onedrive.common.service;
 
+import cn.hutool.core.util.URLUtil;
 import cn.hutool.http.HttpRequest;
 import cn.hutool.http.HttpResponse;
 import cn.hutool.http.HttpUtil;
@@ -18,6 +19,7 @@
 import org.springframework.web.client.RestTemplate;
 
 import javax.annotation.Resource;
+import java.net.URLDecoder;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -95,7 +97,7 @@ public List<FileItemDTO> list(String basePath, String path) {
             String requestUrl;
 
             if (nextLink != null) {
-                requestUrl = nextLink;
+                requestUrl = URLUtil.decode(nextLink);
             }else if ("/".equalsIgnoreCase(fullPath) || "".equalsIgnoreCase(fullPath)) {
                 requestUrl = DRIVER_ROOT_URL;
             } else {

File: src/main/java/im/zhaojun/common/config/GlobalScheduleTask.java
Patch:
@@ -80,9 +80,9 @@ public void refreshOneDriveToken(StorageTypeEnum storageType) {
 
         OneDriveToken refreshToken;
         if (Objects.equals(storageType, StorageTypeEnum.ONE_DRIVE_CHINA)) {
-            refreshToken = oneDriveChinaService.getRefreshToken();
+            refreshToken = oneDriveChinaService.getRefreshToken(storageType);
         } else {
-            refreshToken = oneDriveService.getRefreshToken();
+            refreshToken = oneDriveService.getRefreshToken(storageType);
         }
 
 

File: src/main/java/im/zhaojun/onedrive/common/service/AbstractOneDriveService.java
Patch:
@@ -43,9 +43,9 @@ public abstract class AbstractOneDriveService {
     @Resource
     private StorageConfigRepository storageConfigRepository;
 
-    public OneDriveToken getRefreshToken() {
+    public OneDriveToken getRefreshToken(StorageTypeEnum storageType) {
         StorageConfig refreshStorageConfig =
-                storageConfigRepository.findByTypeAndKey(StorageTypeEnum.ONE_DRIVE, StorageConfigConstant.REFRESH_TOKEN_KEY);
+                storageConfigRepository.findByTypeAndKey(storageType, StorageConfigConstant.REFRESH_TOKEN_KEY);
 
         String param = "client_id=" + getClientId() +
                 "&redirect_uri=" + getRedirectUri() +

File: src/main/java/im/zhaojun/onedrive/service/OneDriveService.java
Patch:
@@ -29,11 +29,11 @@
 @Service
 public class OneDriveService {
 
-    private static final String DRIVER_INFO_URL = "https://graph.microsoft.com/v1.0/drive";
+    private static final String DRIVER_INFO_URL = "https://graph.microsoft.com/v1.0/me/drives";
 
-    private static final String DRIVER_ROOT_URL = "https://graph.microsoft.com/v1.0/drive/root/children";
+    private static final String DRIVER_ROOT_URL = "https://graph.microsoft.com/v1.0/me/drive/root/children";
 
-    private static final String DRIVER_ITEMS_URL = "https://graph.microsoft.com/v1.0/drive/root:{path}:/children";
+    private static final String DRIVER_ITEMS_URL = "https://graph.microsoft.com/v1.0/me/drive/root:{path}:/children";
 
     private static final String AUTHENTICATE_URL = "https://login.microsoftonline.com/common/oauth2/v2.0/token";
 

File: src/main/java/im/zhaojun/common/controller/FileController.java
Patch:
@@ -54,7 +54,7 @@ public ResultBean list(@RequestParam(defaultValue = "/") String path,
                            @RequestParam(required = false) String password,
                            @RequestParam(defaultValue = "1") Integer page) throws Exception {
         AbstractFileService fileService = systemConfigService.getCurrentFileService();
-        List<FileItemDTO> fileItemList = fileService.fileList(StringUtils.removeDuplicateSeparator("/" + URLUtil.decode(path) + "/"));
+        List<FileItemDTO> fileItemList = fileService.fileList(StringUtils.removeDuplicateSeparator("/" + path + "/"));
         for (FileItemDTO fileItemDTO : fileItemList) {
             if (ZFileConstant.PASSWORD_FILE_NAME.equals(fileItemDTO.getName())
                 && !HttpUtil.getTextContent(fileItemDTO.getUrl()).equals(password)) {
@@ -77,7 +77,7 @@ public ResultBean list(@RequestParam(defaultValue = "/") String path,
     @CheckStorageStrategyInit
     @GetMapping("/config")
     public ResultBean getConfig(String path) throws Exception {
-        SiteConfigDTO config = systemService.getConfig(URLUtil.decode(StringUtils.removeDuplicateSeparator("/" + path + "/")));
+        SiteConfigDTO config = systemService.getConfig(StringUtils.removeDuplicateSeparator("/" + path + "/"));
         config.setSystemConfigDTO(systemConfigService.getSystemConfig());
         return ResultBean.successData(config);
     }

File: src/main/java/im/zhaojun/onedrive/service/OneDriveService.java
Patch:
@@ -12,6 +12,7 @@
 import im.zhaojun.common.model.enums.FileTypeEnum;
 import im.zhaojun.common.model.enums.StorageTypeEnum;
 import im.zhaojun.common.repository.StorageConfigRepository;
+import im.zhaojun.common.util.StringUtils;
 import org.springframework.beans.factory.annotation.Value;
 import org.springframework.http.ResponseEntity;
 import org.springframework.stereotype.Service;
@@ -105,6 +106,7 @@ public List<FileItemDTO> list(String path) {
             } else {
                 requestUrl = DRIVER_ITEMS_URL;
             }
+            path = StringUtils.removeLastSeparator(path);
 
             ResponseEntity<String> responseEntity = oneDriveRestTemplate.getForEntity(requestUrl, String.class, path);
             String body = responseEntity.getBody();

File: src/main/java/im/zhaojun/common/service/FileCacheService.java
Patch:
@@ -1,5 +1,6 @@
 package im.zhaojun.common.service;
 
+import org.springframework.context.annotation.Lazy;
 import org.springframework.stereotype.Service;
 
 import javax.annotation.Resource;
@@ -15,6 +16,7 @@ public class FileCacheService {
     private SystemConfigService systemConfigService;
 
     @Resource
+    @Lazy
     private FileAsyncCacheService fileAsyncCacheService;
 
     public void enableCache() {

File: src/main/java/im/zhaojun/common/controller/AdminController.java
Patch:
@@ -148,22 +148,22 @@ public ResultBean save(@RequestParam Map<String, String> storageStrategyConfig,
     /**
      * 更新存储策略
      */
-    public void refreshStorageStrategy() {
+    public void refreshStorageStrategy() throws Exception {
         StorageTypeEnum storageStrategy = systemConfigService.getCurrentStorageStrategy();
         refreshStorageStrategy(storageStrategy);
     }
 
     /**
      * 更新存储策略
      */
-    public void refreshStorageStrategy(StorageTypeEnum storageStrategy) {
+    public void refreshStorageStrategy(StorageTypeEnum storageStrategy) throws Exception {
         if (storageStrategy == null) {
             log.info("尚未配置存储策略.");
         } else {
             AbstractFileService fileService = systemConfigService.getCurrentFileService();
             fileService.init();
+            fileService.clearFileCache();
             log.info("切换至存储类型: {}", storageStrategy.getDescription());
-
             fileAsyncCacheService.cacheGlobalFile();
         }
     }

File: src/main/java/im/zhaojun/ftp/service/FtpServiceImpl.java
Patch:
@@ -49,7 +49,7 @@ public void init() {
             domain = stringStorageConfigMap.get(StorageConfigConstant.DOMAIN_KEY).getValue();
 
             if (Objects.isNull(host) || Objects.isNull(port) || Objects.isNull(username) || Objects.isNull(password)) {
-                isInitialized = true;
+                isInitialized = false;
             } else {
                 ftp = new Ftp(host, Integer.parseInt(port), username, password);
                 isInitialized = testConnection();

File: src/main/java/im/zhaojun/common/controller/AdminController.java
Patch:
@@ -58,7 +58,6 @@ public ResultBean getConfig() {
     @PostMapping("/config")
     public ResultBean updateConfig(SystemConfigDTO systemConfigDTO) throws Exception {
         AbstractFileService currentFileService = systemConfigService.getCurrentFileService();
-        currentFileService.clearFileCache();
         systemConfigDTO.setId(1);
         systemConfigService.updateSystemConfig(systemConfigDTO);
 

File: src/main/java/im/zhaojun/common/controller/AdminController.java
Patch:
@@ -54,11 +54,12 @@ public ResultBean getConfig() {
      */
     @PostMapping("/config")
     public ResultBean updateConfig(SystemConfigDTO systemConfigDTO) throws Exception {
-        StorageTypeEnum currentStorageStrategy = systemConfigService.getCurrentStorageStrategy();
-
+        AbstractFileService currentFileService = systemConfigService.getCurrentFileService();
+        currentFileService.clearFileCache();
         systemConfigDTO.setId(1);
         systemConfigService.updateSystemConfig(systemConfigDTO);
 
+        StorageTypeEnum currentStorageStrategy = currentFileService.getStorageTypeEnum();
         if (!Objects.equals(currentStorageStrategy, systemConfigDTO.getStorageStrategy())) {
             log.info("已将存储策略由 {} 切换为 {}", currentStorageStrategy, systemConfigDTO.getStorageStrategy());
             refreshStorageStrategy();

File: src/main/java/im/zhaojun/common/controller/CacheController.java
Patch:
@@ -68,7 +68,6 @@ public ResultBean refreshCache(String key) throws Exception {
     public ResultBean clearCache(String key) throws Exception {
         AbstractFileService fileService = systemConfigService.getCurrentFileService();
         fileService.clearFileCache();
-        fileAsyncCacheService.resetCacheCount();
         return ResultBean.success();
     }
 

File: src/main/java/im/zhaojun/minio/MinIOServiceImpl.java
Patch:
@@ -40,6 +40,7 @@ public void init() {
             } else {
                 BasicAWSCredentials credentials = new BasicAWSCredentials(accessKey, secretKey);
                 s3Client = AmazonS3ClientBuilder.standard()
+                        .withPathStyleAccessEnabled(true)
                         .withCredentials(new AWSStaticCredentialsProvider(credentials))
                         .withEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration(endPoint, "minio")).build();
 

File: src/main/java/im/zhaojun/common/controller/AdminController.java
Patch:
@@ -60,6 +60,7 @@ public ResultBean updateConfig(SystemConfigDTO systemConfigDTO) throws Exception
         systemConfigService.updateSystemConfig(systemConfigDTO);
 
         if (!Objects.equals(currentStorageStrategy, systemConfigDTO.getStorageStrategy())) {
+            log.info("已将存储策略由 {} 切换为 {}", currentStorageStrategy, systemConfigDTO.getStorageStrategy());
             refreshStorageStrategy();
         }
 
@@ -136,9 +137,8 @@ public void refreshStorageStrategy(StorageTypeEnum storageStrategy) {
         } else {
             AbstractFileService fileService = systemConfigService.getCurrentFileService();
             fileService.init();
-            log.info("当前启用存储类型: {}", storageStrategy.getDescription());
+            log.info("切换至存储类型: {}", storageStrategy.getDescription());
 
-            // if 判断是否开启搜索.
             fileAsyncCacheService.cacheGlobalFile();
         }
     }

File: src/main/java/im/zhaojun/common/controller/AdminController.java
Patch:
@@ -18,6 +18,7 @@
 
 import javax.annotation.Resource;
 import java.util.List;
+import java.util.Objects;
 import java.util.Set;
 
 /**
@@ -58,7 +59,7 @@ public ResultBean updateConfig(SystemConfigDTO systemConfigDTO) throws Exception
         systemConfigDTO.setId(1);
         systemConfigService.updateSystemConfig(systemConfigDTO);
 
-        if (!currentStorageStrategy.equals(systemConfigDTO.getStorageStrategy())) {
+        if (!Objects.equals(currentStorageStrategy, systemConfigDTO.getStorageStrategy())) {
             refreshStorageStrategy();
         }
 

File: src/main/java/im/zhaojun/local/service/LocalServiceImpl.java
Patch:
@@ -1,5 +1,6 @@
 package im.zhaojun.local.service;
 
+import cn.hutool.core.util.URLUtil;
 import im.zhaojun.common.model.StorageConfig;
 import im.zhaojun.common.model.SystemConfig;
 import im.zhaojun.common.model.constant.StorageConfigConstant;
@@ -87,7 +88,7 @@ public List<FileItemDTO> fileList(String path) {
     @Override
     public String getDownloadUrl(String path) {
         SystemConfig usernameConfig = systemConfigRepository.findByKey(SystemConfigConstant.DOMAIN);
-        return StringUtils.removeDuplicateSeparator(usernameConfig.getValue() + "/file/" + path);
+        return URLUtil.encode(StringUtils.removeDuplicateSeparator(usernameConfig.getValue() + "/file/" + path));
     }
 
     public String getFilePath() {

File: src/main/java/im/zhaojun/common/service/AbstractFileService.java
Patch:
@@ -164,6 +164,7 @@ public Set<String> getCacheKeys() throws Exception {
                 return null;
             }).collect(Collectors.toSet());
             collect.remove(null);
+            collect.add("/");
             return collect;
         } else {
             return Collections.emptySet();

File: src/main/java/im/zhaojun/common/service/SystemConfigService.java
Patch:
@@ -2,6 +2,7 @@
 
 import cn.hutool.crypto.SecureUtil;
 import com.alicp.jetcache.Cache;
+import com.alicp.jetcache.anno.CacheType;
 import com.alicp.jetcache.anno.CreateCache;
 import im.zhaojun.common.config.StorageTypeFactory;
 import im.zhaojun.common.model.SystemConfig;
@@ -28,7 +29,7 @@ public class SystemConfigService {
 
     public static final String SYSTEM_CONFIG_CACHE_KEY = "1";
 
-    @CreateCache(name = SYSTEM_CONFIG_CACHE_PREFIX)
+    @CreateCache(name = SYSTEM_CONFIG_CACHE_PREFIX, cacheType = CacheType.LOCAL)
     private Cache<String, Object> configCache;
 
     @Resource

File: src/main/java/im/zhaojun/common/service/AbstractS3FileService.java
Patch:
@@ -96,7 +96,7 @@ public String s3ObjectUrl(String path) {
         if (StringUtils.isNotNullOrEmpty(domain)) {
             defaultUrl = URLUtil.complateUrl(domain, url.getFile());
         }
-        return defaultUrl;
+        return URLUtil.decode(defaultUrl);
     }
 
     /**

File: src/main/java/im/zhaojun/common/util/HttpUtil.java
Patch:
@@ -1,6 +1,5 @@
 package im.zhaojun.common.util;
 
-import cn.hutool.core.util.URLUtil;
 import org.springframework.web.client.RestTemplate;
 
 /**
@@ -10,7 +9,7 @@ public class HttpUtil {
 
     public static String getTextContent(String url) {
         RestTemplate restTemplate = SpringContextHolder.getBean(RestTemplate.class);
-        String result = restTemplate.getForObject(URLUtil.decode(url), String.class);
+        String result = restTemplate.getForObject(url, String.class);
         return result == null ? "" : result;
     }
 

File: src/main/java/im/zhaojun/common/util/AudioHelper.java
Patch:
@@ -37,7 +37,7 @@ public static AudioInfoDTO getAudioInfo(String url) throws Exception {
 
         File file = new File(ZFileConstant.USER_HOME + ZFileConstant.AUDIO_TMP_PATH + UUID.fastUUID());
         FileUtil.mkParentDirs(file);
-        HttpUtil.downloadFile(URLUtil.decode(url), file);
+        HttpUtil.downloadFile(url, file);
         AudioInfoDTO audioInfoDTO = parseAudioInfo(file);
         audioInfoDTO.setSrc(url);
         file.deleteOnExit();

File: src/main/java/im/zhaojun/common/util/StringUtils.java
Patch:
@@ -57,7 +57,7 @@ public static String removeDuplicateSeparator(String path) {
         if (path.indexOf("http://") == 0) {
             sb.append("http://");
         } else if (path.indexOf("https://") == 0) {
-            sb.append("http://");
+            sb.append("https://");
         }
 
         for (int i = sb.length(); i < path.length() - 1; i++) {

File: src/main/java/im/zhaojun/common/util/AudioHelper.java
Patch:
@@ -32,7 +32,7 @@ public static AudioInfoDTO getAudioInfo(String url) throws Exception {
 
         File file = new File(ZFileConstant.USER_HOME + ZFileConstant.AUDIO_TMP_PATH + UUID.fastUUID());
         FileUtil.mkParentDirs(file);
-        HttpUtil.downloadFile(url, file);
+        HttpUtil.downloadFile(URLUtil.decode(url), file);
         AudioInfoDTO audioInfoDTO = parseAudioInfo(file);
         audioInfoDTO.setSrc(url);
         file.deleteOnExit();

File: src/main/java/im/zhaojun/minio/MinIOServiceImpl.java
Patch:
@@ -21,10 +21,10 @@
 import java.util.Map;
 
 @Service
-public class MinIOService implements FileService {
+public class MinIOServiceImpl implements FileService {
 
 
-    private static final Logger log = LoggerFactory.getLogger(MinIOService.class);
+    private static final Logger log = LoggerFactory.getLogger(MinIOServiceImpl.class);
 
     private String bucketName;
 
@@ -58,7 +58,7 @@ public void init() {
             minioClient = new MinioClient(endPoint, accessKey, secretKey);
             isInitialized = true;
         } catch (Exception e) {
-            log.debug(StorageTypeEnum.HUAWEI.getDescription() + "初始化异常, 已跳过");
+            log.debug(StorageTypeEnum.MINIO.getDescription() + "初始化异常, 已跳过");
         }
     }
 

File: src/main/java/im/zhaojun/common/service/SystemService.java
Patch:
@@ -19,7 +19,7 @@ public class SystemService {
      * 构建指定路径下标题, 页头, 页尾
      * @param path          路径
      */
-    public SiteConfigDTO getConfig(String path) throws Exception {
+    public synchronized SiteConfigDTO getConfig(String path) throws Exception {
 
         SiteConfigDTO siteConfigDTO = new SiteConfigDTO();
         FileService fileService = systemConfigService.getCurrentFileService();

File: src/main/java/im/zhaojun/common/model/dto/SiteConfigDTO.java
Patch:
@@ -1,5 +1,7 @@
 package im.zhaojun.common.model.dto;
 
+import com.fasterxml.jackson.annotation.JsonProperty;
+
 import java.io.Serializable;
 
 public class SiteConfigDTO implements Serializable {
@@ -10,6 +12,7 @@ public class SiteConfigDTO implements Serializable {
 
     private String footer;
 
+    @JsonProperty("viewConfig")
     private SystemConfigDTO systemConfigDTO;
 
     public String getHeader() {

File: src/main/java/im/zhaojun/common/service/SystemConfigService.java
Patch:
@@ -48,6 +48,9 @@ public SystemConfigDTO getSystemConfig() {
                 case SystemConfigConstant.PASSWORD:
                     systemConfigDTO.setPassword(systemConfig.getValue());
                     break;
+                case SystemConfigConstant.DOMAIN:
+                    systemConfigDTO.setDomain(systemConfig.getValue());
+                    break;
                 default:break;
             }
         }

File: src/main/java/im/zhaojun/local/service/LocalServiceImpl.java
Patch:
@@ -84,7 +84,7 @@ public List<FileItemDTO> fileList(String path) throws Exception {
     @Override
     public String getDownloadUrl(String path) throws Exception {
         SystemConfig usernameConfig = systemConfigRepository.findByKey(SystemConfigConstant.DOMAIN);
-        return StringUtils.concatPath( usernameConfig.getValue(), "file" + path);
+        return StringUtils.removeDuplicateSeparator(usernameConfig.getValue() + "/file/" + path);
     }
 
     public String getFilePath() {

File: src/main/java/im/zhaojun/common/controller/InstallController.java
Patch:
@@ -59,6 +59,7 @@ public ResultBean install(InstallModelDTO installModelDTO) {
         systemConfigDTO.setStorageStrategy(storageTypeEnum);
         systemConfigDTO.setUsername(installModelDTO.getUsername());
         systemConfigDTO.setPassword(new BCryptPasswordEncoder().encode(installModelDTO.getPassword()));
+        systemConfigDTO.setDomain(installModelDTO.getDomain());
         systemConfigService.updateSystemConfig(systemConfigDTO);
 
         Map<String, String> storageStrategyConfig = installModelDTO.getStorageStrategyConfig();

File: src/main/java/im/zhaojun/common/model/constant/SystemConfigConstant.java
Patch:
@@ -16,4 +16,6 @@ public class SystemConfigConstant {
 
     public static final String PASSWORD = "password";
 
+    public static final String DOMAIN = "domain";
+
 }

