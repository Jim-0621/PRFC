File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -1124,7 +1124,7 @@ static Class tagToClass(Object tag) {
 		throw new IllegalArgumentException("Unable to resolve classname: " + tag);
 	}
 
-	static Class maybeArrayClass(Symbol sym) {
+	public static Class maybeArrayClass(Symbol sym) {
 		if(sym.ns == null || !Util.isPosDigit(sym.name))
 			return null;
 

File: src/jvm/clojure/lang/LispReader.java
Patch:
@@ -956,8 +956,10 @@ public Object invoke(Object reader, Object caret, Object opts, Object pendingFor
 			meta = RT.map(RT.TAG_KEY, meta);
 		else if (meta instanceof Keyword)
 			meta = RT.map(meta, RT.T);
+		else if (meta instanceof IPersistentVector)
+			meta = RT.map(RT.PARAM_TAGS_KEY, meta);
 		else if(!(meta instanceof IPersistentMap))
-			throw new IllegalArgumentException("Metadata must be Symbol,Keyword,String or Map");
+			throw new IllegalArgumentException("Metadata must be Symbol,Keyword,String,Vector or Map");
 
 		Object o = read(r, true, null, true, opts, pendingForms);
 		if(o instanceof IMeta)

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -189,6 +189,7 @@ else if(s.equals("false"))
 		Var.intern(CLOJURE_NS, Symbol.intern("*err*"),
 		           new PrintWriter(new OutputStreamWriter(System.err), true)).setDynamic();
 final static Keyword TAG_KEY = Keyword.intern(null, "tag");
+final static Keyword PARAM_TAGS_KEY = Keyword.intern(null, "param-tags");
 final static Keyword CONST_KEY = Keyword.intern(null, "const");
 final static public Var AGENT = Var.intern(CLOJURE_NS, Symbol.intern("*agent*"), null).setDynamic();
 static Object readeval = readTrueFalseUnknown(System.getProperty("clojure.read.eval","true"));

File: src/jvm/clojure/lang/IDrop.java
Patch:
@@ -20,7 +20,7 @@ public interface IDrop{
      * useful if the returned coll implements IDrop for subsequent use in a
      * partition-like scenario.
      *
-     * @param n Items to drop, must be > 0
+     * @param n Items to drop, must be &gt; 0
      * @return Collection that is Sequential, ISeq, and IReduceInit, or null if past the end
      */
     Sequential drop(int n);

File: src/jvm/clojure/lang/ArityException.java
Patch:
@@ -26,7 +26,7 @@ public ArityException(int actual, String name) {
 	}
 
 	public ArityException(int actual, String name, Throwable cause) {
-		super("Wrong number of args (" + actual + ") passed to: " + Compiler.demunge(name), cause);
+		super("Wrong number of args (" + (actual <= 20 ? actual : "> 20") + ") passed to: " + Compiler.demunge(name), cause);
 		this.actual = actual;
 		this.name = name;
 	}

File: src/jvm/clojure/lang/Range.java
Patch:
@@ -101,7 +101,7 @@ public static ISeq create(final Object start, Object end, Object step) {
 public Obj withMeta(IPersistentMap meta){
 	if(meta == _meta)
 		return this;
-	return new Range(meta, end, start, step, boundsCheck, _chunk, _chunkNext);
+	return new Range(meta, start, end, step, boundsCheck, _chunk, _chunkNext);
 }
 
 public Object first(){

File: src/jvm/clojure/lang/IDrop.java
Patch:
@@ -20,7 +20,7 @@ public interface IDrop{
      * useful if the returned coll implements IDrop for subsequent use in a
      * partition-like scenario.
      *
-     * If n is <= 0, return this.
+     * If n is &lt;= 0, return this.
      * If n drops to or past the end of the collection, return null.
      *
      * @param n Items to drop

File: src/jvm/clojure/lang/AFunction.java
Patch:
@@ -17,6 +17,8 @@
 
 public abstract class AFunction extends AFn implements IObj, Comparator, Fn, Serializable {
 
+private static final long serialVersionUID = 4469383498184457675L;
+
 public volatile MethodImplCache __methodImplCache;
 
 public IPersistentMap meta(){

File: src/jvm/clojure/lang/AMapEntry.java
Patch:
@@ -16,6 +16,8 @@
 
 public abstract class AMapEntry extends APersistentVector implements IMapEntry{
 
+private static final long serialVersionUID = -5007980429903443802L;
+
 public Object nth(int i){
 	if(i == 0)
 		return key();

File: src/jvm/clojure/lang/APersistentMap.java
Patch:
@@ -14,6 +14,9 @@
 import java.util.*;
 
 public abstract class APersistentMap extends AFn implements IPersistentMap, Map, Iterable, Serializable, MapEquivalence, IHashEq {
+
+private static final long serialVersionUID = 6736310834519110267L;
+
 int _hash;
 int _hasheq;
 

File: src/jvm/clojure/lang/APersistentSet.java
Patch:
@@ -18,6 +18,9 @@
 import java.util.Set;
 
 public abstract class APersistentSet extends AFn implements IPersistentSet, Collection, Set, Serializable, IHashEq {
+
+private static final long serialVersionUID = 889908853183699706L;
+
 int _hash;
 int _hasheq;
 final IPersistentMap impl;

File: src/jvm/clojure/lang/APersistentVector.java
Patch:
@@ -19,6 +19,9 @@ public abstract class APersistentVector extends AFn implements IPersistentVector
                                                                List,
                                                                RandomAccess, Comparable,
                                                                Serializable, IHashEq {
+
+private static final long serialVersionUID = 4667575149454420891L;
+
 int _hash;
 int _hasheq;
 

File: src/jvm/clojure/lang/ASeq.java
Patch:
@@ -14,6 +14,9 @@
 import java.util.*;
 
 public abstract class ASeq extends Obj implements ISeq, Sequential, List, Serializable, IHashEq {
+
+private static final long serialVersionUID = 4748650717905139299L;
+
 transient int _hash;
 transient int _hasheq;
 

File: src/jvm/clojure/lang/ArityException.java
Patch:
@@ -15,6 +15,8 @@
  */
 public class ArityException extends IllegalArgumentException {
 
+	private static final long serialVersionUID = 2265783180488869950L;
+
 	final public int actual;
 
 	final public String name;

File: src/jvm/clojure/lang/ArrayChunk.java
Patch:
@@ -16,6 +16,8 @@
 
 public final class ArrayChunk implements IChunk, Serializable {
 
+private static final long serialVersionUID = -8302142882294545702L;
+
 final Object[] array;
 final int off;
 final int end;

File: src/jvm/clojure/lang/BigInt.java
Patch:
@@ -17,6 +17,8 @@
 
 public final class BigInt extends Number implements IHashEq{
 
+private static final long serialVersionUID = 5097771279236135022L;
+
 final public long lpart;
 final public BigInteger bipart;
 

File: src/jvm/clojure/lang/ChunkedCons.java
Patch:
@@ -14,6 +14,8 @@
 
 final public class ChunkedCons extends ASeq implements IChunkedSeq{
 
+private static final long serialVersionUID = 2773920188566401743L;
+
 final IChunk chunk;
 final ISeq _more;
 

File: src/jvm/clojure/lang/Cons.java
Patch:
@@ -16,6 +16,8 @@
 
 final public class Cons extends ASeq implements Serializable {
 
+private static final long serialVersionUID = 6682587018567831263L;
+
 private final Object _first;
 private final ISeq _more;
 

File: src/jvm/clojure/lang/Cycle.java
Patch:
@@ -14,6 +14,8 @@
 
 public class Cycle extends ASeq implements IReduce, IPending {
 
+private static final long serialVersionUID = 4007270937279943908L;
+
 private final ISeq all;      // never null
 private final ISeq prev;
 private volatile ISeq _current; // lazily realized

File: src/jvm/clojure/lang/EnumerationSeq.java
Patch:
@@ -17,6 +17,9 @@
 import java.util.Enumeration;
 
 public class EnumerationSeq extends ASeq{
+
+private static final long serialVersionUID = 5227192199685595994L;
+
 final Enumeration iter;
 final State state;
 

File: src/jvm/clojure/lang/ExceptionInfo.java
Patch:
@@ -16,6 +16,9 @@
  * exception classes.
  */
 public class ExceptionInfo extends RuntimeException implements IExceptionInfo {
+
+    private static final long serialVersionUID = -1073473305916521986L;
+
     public final IPersistentMap data;
 
     public ExceptionInfo(String s, IPersistentMap data) {

File: src/jvm/clojure/lang/FnLoaderThunk.java
Patch:
@@ -14,6 +14,8 @@
 
 public class FnLoaderThunk extends RestFn{
 
+private static final long serialVersionUID = 2194257205455463687L;
+
 final Var v;
 final ClassLoader loader;
 final String fnClassName;

File: src/jvm/clojure/lang/Iterate.java
Patch:
@@ -14,6 +14,8 @@
 
 public class Iterate extends ASeq implements IReduce, IPending {
 
+private static final long serialVersionUID = -78221705247226450L;
+
 private static final Object UNREALIZED_SEED = new Object();
 private final IFn f;      // never null
 private final Object prevSeed;

File: src/jvm/clojure/lang/IteratorSeq.java
Patch:
@@ -15,6 +15,9 @@
 import java.util.Iterator;
 
 public class IteratorSeq extends ASeq{
+
+private static final long serialVersionUID = -2631916503522522760L;
+
 final Iterator iter;
 final State state;
 

File: src/jvm/clojure/lang/LazySeq.java
Patch:
@@ -16,6 +16,8 @@
 
 public final class LazySeq extends Obj implements ISeq, Sequential, List, IPending, IHashEq{
 
+private static final long serialVersionUID = 7700080124382322592L;
+
 private IFn fn;
 private Object sv;
 private ISeq s;

File: src/jvm/clojure/lang/MapEntry.java
Patch:
@@ -13,6 +13,9 @@
 import java.util.Iterator;
 
 public class MapEntry extends AMapEntry{
+
+private static final long serialVersionUID = -3752414622414469244L;
+
 final Object _key;
 final Object _val;
 

File: src/jvm/clojure/lang/Namespace.java
Patch:
@@ -18,6 +18,9 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 public class Namespace extends AReference implements Serializable {
+
+private static final long serialVersionUID = -3134444395801383865L;
+
 final public Symbol name;
 transient final AtomicReference<IPersistentMap> mappings = new AtomicReference<IPersistentMap>();
 transient final AtomicReference<IPersistentMap> aliases = new AtomicReference<IPersistentMap>();

File: src/jvm/clojure/lang/Obj.java
Patch:
@@ -16,6 +16,8 @@
 
 public abstract class Obj implements IObj, Serializable {
 
+private static final long serialVersionUID = 802029099426284526L;
+
 final IPersistentMap _meta;
 
 public Obj(IPersistentMap meta){

File: src/jvm/clojure/lang/PersistentArrayMap.java
Patch:
@@ -29,6 +29,8 @@
 
 public class PersistentArrayMap extends APersistentMap implements IObj, IEditableCollection, IMapIterable, IKVReduce, IDrop{
 
+private static final long serialVersionUID = -2074065891090893601L;
+
 final Object[] array;
 static final int HASHTABLE_THRESHOLD = 16;
 

File: src/jvm/clojure/lang/PersistentHashMap.java
Patch:
@@ -27,6 +27,8 @@
 
 public class PersistentHashMap extends APersistentMap implements IEditableCollection, IObj, IMapIterable, IKVReduce {
 
+private static final long serialVersionUID = -8682496769319143320L;
+
 final int count;
 final INode root;
 final boolean hasNull;

File: src/jvm/clojure/lang/PersistentHashSet.java
Patch:
@@ -16,6 +16,8 @@
 
 public class PersistentHashSet extends APersistentSet implements IObj, IEditableCollection {
 
+private static final long serialVersionUID = 6973890746204954938L;
+
 static public final PersistentHashSet EMPTY = new PersistentHashSet(null, PersistentHashMap.EMPTY);
 
 final IPersistentMap _meta;

File: src/jvm/clojure/lang/PersistentList.java
Patch:
@@ -15,6 +15,8 @@
 
 public class PersistentList extends ASeq implements IPersistentList, IReduce, List, Counted {
 
+private static final long serialVersionUID = -8833289659955219995L;
+
 private final Object _first;
 private final IPersistentList _rest;
 private final int _count;

File: src/jvm/clojure/lang/PersistentQueue.java
Patch:
@@ -24,6 +24,8 @@
 
 public class PersistentQueue extends Obj implements IPersistentList, Collection, Counted, IHashEq{
 
+private static final long serialVersionUID = 8247184423915313132L;
+
 final public static PersistentQueue EMPTY = new PersistentQueue(null, 0, null, null);
 
 //*

File: src/jvm/clojure/lang/PersistentStructMap.java
Patch:
@@ -19,6 +19,8 @@
 
 public class PersistentStructMap extends APersistentMap implements IObj{
 
+private static final long serialVersionUID = -2701411408470234065L;
+
 public static class Def implements Serializable{
 	final ISeq keys;
 	final IPersistentMap keyslots;

File: src/jvm/clojure/lang/PersistentVector.java
Patch:
@@ -21,6 +21,8 @@
 
 public class PersistentVector extends APersistentVector implements IObj, IEditableCollection, IReduce, IKVReduce, IDrop{
 
+private static final long serialVersionUID = -7896022351281214157L;
+
 public static class Node implements Serializable {
 	transient public final AtomicReference<Thread> edit;
 	public final Object[] array;

File: src/jvm/clojure/lang/Range.java
Patch:
@@ -18,6 +18,8 @@
  */
 public class Range extends ASeq implements IChunkedSeq, IReduce {
 
+private static final long serialVersionUID = -71973733672395145L;
+
 private static final int CHUNK_SIZE = 32;
 
 // Invariants guarantee this is never an "empty" seq

File: src/jvm/clojure/lang/Ratio.java
Patch:
@@ -17,6 +17,9 @@
 import java.math.MathContext;
 
 public class Ratio extends Number implements Comparable{
+
+private static final long serialVersionUID = -576272795628662988L;
+
 final public BigInteger numerator;
 final public BigInteger denominator;
 

File: src/jvm/clojure/lang/Repeat.java
Patch:
@@ -14,6 +14,8 @@
 
 public class Repeat extends ASeq implements IReduce, IDrop {
 
+private static final long serialVersionUID = -5140377547192202551L;
+
 private static final long INFINITE = -1;
 
 private final long count;  // always INFINITE or >0

File: src/jvm/clojure/lang/RestFn.java
Patch:
@@ -10,6 +10,9 @@
 package clojure.lang;
 
 public abstract class RestFn extends AFunction{
+
+private static final long serialVersionUID = -4319097849151802009L;
+
 abstract public int getRequiredArity();
 
 protected Object doInvoke(Object args) {

File: src/jvm/clojure/lang/StringSeq.java
Patch:
@@ -16,6 +16,9 @@
 import java.util.NoSuchElementException;
 
 public class StringSeq extends ASeq implements IndexedSeq,IDrop,IReduceInit{
+
+private static final long serialVersionUID = 7975525539139301753L;
+
 public final CharSequence s;
 public final int i;
 

File: src/jvm/clojure/lang/Symbol.java
Patch:
@@ -17,6 +17,9 @@
 
 
 public class Symbol extends AFn implements IObj, Comparable, Named, Serializable, IHashEq{
+
+private static final long serialVersionUID = 1191039485148212259L;
+
 final String ns;
 final String name;
 private int _hasheq;

File: src/jvm/clojure/lang/Var.java
Patch:
@@ -19,6 +19,8 @@
 
 public final class Var extends ARef implements IFn, IRef, Settable, Serializable{
 
+private static final long serialVersionUID = 8368961370796295279L;
+
 static class TBox{
 
 volatile Object val;

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -965,7 +965,8 @@ else if(coll instanceof RandomAccess) {
 	}
 	else if(coll instanceof Matcher) {
 		Matcher m = (Matcher) coll;
-		if(n < m.groupCount())
+		int groups = m.groupCount();
+		if(groups > 0 && n <= m.groupCount())
 			return m.group(n);
 		return notFound;
 	}

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -4997,7 +4997,7 @@ public Object eval() {
 			return null;
 		try
 			{
-			return getCompiledClass().newInstance();
+			return getCompiledClass().getDeclaredConstructor().newInstance();
 			}
 		catch(Exception e)
 			{

File: src/jvm/clojure/lang/FnLoaderThunk.java
Patch:
@@ -51,7 +51,7 @@ private void load() {
 		{
 		try
 			{
-			fn = (IFn) Class.forName(fnClassName,true,loader).newInstance();
+			fn = (IFn) Class.forName(fnClassName,true,loader).getDeclaredConstructor().newInstance();
 			}
 		catch(Exception e)
 			{

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -1796,7 +1796,7 @@ public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen){
 				{
 				Type type = Type.getType(c);
 				Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method));
-				gen.invokeStatic(type, m);
+				gen.visitMethodInsn(INVOKESTATIC, type.getInternalName(), methodName, m.getDescriptor(), c.isInterface());
 				}
 			}
 		else

File: test/java/compilation/JDK8InterfaceMethods.java
Patch:
@@ -3,4 +3,5 @@
 public interface JDK8InterfaceMethods {
     public static long staticMethod0(long v) { return v; }
     public static String staticMethod1(String s) { return s; }
+    public static boolean staticMethod2(boolean b) { return b; }
 }

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -198,6 +198,7 @@ else if(s.equals("false"))
 final static public Var SUPPRESS_READ = Var.intern(CLOJURE_NS, Symbol.intern("*suppress-read*"), null).setDynamic();
 final static public Var ASSERT = Var.intern(CLOJURE_NS, Symbol.intern("*assert*"), T).setDynamic();
 final static public Var MATH_CONTEXT = Var.intern(CLOJURE_NS, Symbol.intern("*math-context*"), null).setDynamic();
+static Keyword EVAL_FILE_KEY = Keyword.intern("clojure.core", "eval-file");
 static Keyword LINE_KEY = Keyword.intern(null, "line");
 static Keyword COLUMN_KEY = Keyword.intern(null, "column");
 static Keyword FILE_KEY = Keyword.intern(null, "file");

File: src/jvm/clojure/lang/AFn.java
Patch:
@@ -425,7 +425,7 @@ static public Object applyToHelper(IFn ifn, ISeq arglist) {
 }
 
 public Object throwArity(int n){
-	String name = getClass().getSimpleName();
-	throw new ArityException(n, Compiler.demunge(name));
+	String name = getClass().getName();
+	throw new ArityException(n, name);
 }
 }

File: src/jvm/clojure/lang/ArityException.java
Patch:
@@ -24,7 +24,7 @@ public ArityException(int actual, String name) {
 	}
 
 	public ArityException(int actual, String name, Throwable cause) {
-		super("Wrong number of args (" + actual + ") passed to: " + name, cause);
+		super("Wrong number of args (" + actual + ") passed to: " + Compiler.demunge(name), cause);
 		this.actual = actual;
 		this.name = name;
 	}

File: src/jvm/clojure/lang/Keyword.java
Patch:
@@ -132,7 +132,6 @@ private Object readResolve() throws ObjectStreamException{
  *
  * @param obj - must be IPersistentMap
  * @return the value at the key or nil if not found
- * @
  */
 final public Object invoke(Object obj) {
 	if(obj instanceof ILookup)

File: src/jvm/clojure/lang/PersistentTreeMap.java
Patch:
@@ -333,6 +333,8 @@ public int doCompare(Object k1, Object k2){
 Node add(Node t, Object key, Object val, Box found){
 	if(t == null)
 		{
+		if(comp == RT.DEFAULT_COMPARATOR && !( key == null || (key instanceof Number) || (key instanceof Comparable)))
+			throw new ClassCastException("Default comparator requires nil, Number, or Comparable: " + key);
 		if(val == null)
 			return new Red(key);
 		return new RedVal(key, val);

File: src/jvm/clojure/lang/LineNumberingPushbackReader.java
Patch:
@@ -101,6 +101,8 @@ public String readLine() throws IOException{
     default:
         String first = String.valueOf((char) c);
         String rest = ((LineNumberReader)in).readLine();
+        if (sb != null)
+          sb.append(rest+"\n");
         line = (rest == null) ? first : first + rest;
         _prev = false;
         _atLineStart = true;

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -1038,7 +1038,7 @@ public static Class maybeClass(Object form, boolean stringOk) {
 				if(Util.equals(sym,COMPILE_STUB_SYM.get()))
 					return (Class) COMPILE_STUB_CLASS.get();
 				if(sym.name.indexOf('.') > 0 || sym.name.charAt(0) == '[')
-					c = RT.classForName(sym.name);
+					c = RT.classForNameNonLoading(sym.name);
 				else
 					{
 					Object o = currentNS().getMapping(sym);
@@ -1049,7 +1049,7 @@ else if(LOCAL_ENV.deref() != null && ((java.util.Map)LOCAL_ENV.deref()).contains
 					else
 						{
 						try{
-						c = RT.classForName(sym.name);
+						c = RT.classForNameNonLoading(sym.name);
 						}
 						catch(Exception e){
 							// aargh
@@ -1060,7 +1060,7 @@ else if(LOCAL_ENV.deref() != null && ((java.util.Map)LOCAL_ENV.deref()).contains
 				}
 			}
 		else if(stringOk && form instanceof String)
-			c = RT.classForName((String) form);
+			c = RT.classForNameNonLoading((String) form);
 		return c;
 	}
 

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -36,7 +36,7 @@ public class RT{
 static final public String LOADER_SUFFIX = "__init";
 
 //simple-symbol->class
-final static IPersistentMap DEFAULT_IMPORTS = map(
+final static public IPersistentMap DEFAULT_IMPORTS = map(
 //												  Symbol.intern("RT"), "clojure.lang.RT",
 //                                                  Symbol.intern("Num"), "clojure.lang.Num",
 //                                                  Symbol.intern("Symbol"), "clojure.lang.Symbol",

File: src/jvm/clojure/lang/LispReader.java
Patch:
@@ -1025,8 +1025,10 @@ else if(sym.ns == null){
                         rsym = resolver.resolveVar(sym);
                     if(rsym != null)
                         sym = rsym;
+                    else
+                        sym = Symbol.intern(resolver.currentNS().name,sym.name);
                 }
-                //leave alone if no resolution
+                //leave alone if qualified
                 }
 			else
 				{

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -4012,9 +4012,9 @@ else if(methodArray[f.reqParms.count()] == null)
 						{
 						for(LocalBinding lb : (Collection<LocalBinding>)RT.keys(fm.locals))
 							{
-							lb.idx -= 1;
+							if(lb.isArg)
+								lb.idx -= 1;
 							}
-						fm.maxLocal -= 1;
 						}
 					}
 				}

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -5270,7 +5270,7 @@ static FnMethod parse(ObjExpr objx, ISeq form, Object rettag) {
             if(rettag != null)
                 {
                 String retstr = ((Symbol)rettag).getName();
-                if(!retstr.equals("long") || !retstr.equals("double"))
+                if(!(retstr.equals("long") || retstr.equals("double")))
                    rettag = null;
                 }
 			method.retClass = tagClass(tagOf(parms)!=null?tagOf(parms):rettag);

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -1224,12 +1224,12 @@ public void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen,
 		if(targetClass != null && field != null)
 			{
 			target.emit(C.EXPRESSION, objx, gen);
-			gen.checkCast(Type.getType(targetClass));
+			gen.checkCast(getType(targetClass));
 			val.emit(C.EXPRESSION, objx, gen);
 			gen.visitLineNumber(line, gen.mark());
 			gen.dupX1();
 			HostExpr.emitUnboxArg(objx, gen, field.getType());
-			gen.putField(Type.getType(targetClass), fieldName, Type.getType(field.getType()));
+			gen.putField(getType(targetClass), fieldName, Type.getType(field.getType()));
 			}
 		else
 			{

File: src/jvm/clojure/lang/Reflector.java
Patch:
@@ -83,7 +83,7 @@ else if(methods.size() == 1)
 		{
 		//public method of non-public class, try to find it in hierarchy
 		Method oldm = m;
-		m = getAsMethodOfPublicBase(m.getDeclaringClass(), m);
+		m = getAsMethodOfPublicBase(target.getClass(), m);
 		if(m == null)
 			throw new IllegalArgumentException("Can't call public method of non-public class: " +
 			                                    oldm.toString());

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -4687,7 +4687,7 @@ else if(value instanceof IType)
 				{
 				Symbol field = (Symbol) s.first();
 				Class k = tagClass(tagOf(field));
-				Object val = Reflector.getInstanceField(value, field.name);
+				Object val = Reflector.getInstanceField(value, munge(field.name));
 				emitValue(val, gen);
 
 				if(k.isPrimitive())

File: src/jvm/clojure/lang/PersistentStructMap.java
Patch:
@@ -195,9 +195,9 @@ public boolean hasNext(){
         public Object next(){
             if(ks != null)
             {
-                Object ret = ks.first();
+                Object key = ks.first();
                 ks = ks.next();
-                return ret;
+                return entryAt(key);
             }
             else if(extIter != null && extIter.hasNext())
                 return extIter.next();

File: src/jvm/clojure/lang/LongRange.java
Patch:
@@ -156,9 +156,9 @@ public ISeq chunkedMore() {
 }
 
 public int absCount(long start, long end, long step) {
-    double c = (end - start) / step;
+    double c = (double) (end - start) / step;
     int ic = (int) c;
-    if(c < ic)
+    if(c > ic)
         return ic + 1;
     else
         return ic;

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -3070,7 +3070,7 @@ else if(keysConstant)
 				throw new IllegalArgumentException("Duplicate constant keys in map");
 			if(valsConstant)
 				{
-				IPersistentMap m = PersistentHashMap.EMPTY;
+				IPersistentMap m = PersistentArrayMap.EMPTY;
 				for(int i=0;i<keyvals.length();i+= 2)
 					{
 					m = m.assoc(((LiteralExpr)keyvals.nth(i)).val(), ((LiteralExpr)keyvals.nth(i+1)).val());

File: src/jvm/clojure/lang/PersistentArrayMap.java
Patch:
@@ -201,9 +201,9 @@ public IPersistentMap assoc(Object key, Object val){
 			return createHT(array).assoc(key, val);
 		newArray = new Object[array.length + 2];
 		if(array.length > 0)
-			System.arraycopy(array, 0, newArray, 2, array.length);
-		newArray[0] = key;
-		newArray[1] = val;
+			System.arraycopy(array, 0, newArray, 0, array.length);
+		newArray[newArray.length-2] = key;
+		newArray[newArray.length-1] = val;
 		}
 	return create(newArray);
 }

File: src/jvm/clojure/lang/PersistentList.java
Patch:
@@ -29,7 +29,7 @@ final protected Object doInvoke(Object args) {
 			{
 			Object[] argsarray = ((ArraySeq) args).array;
 			IPersistentList ret = EMPTY;
-			for(int i = argsarray.length - 1; i >= 0; --i)
+			for(int i = argsarray.length - 1; i >= ((ArraySeq)args).i; --i)
 				ret = (IPersistentList) ret.cons(argsarray[i]);
 			return ret;
 			}

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -716,7 +716,7 @@ public Class getJavaClass() {
 
 public static class ImportExpr implements Expr{
 	public final String c;
-	final static Method forNameMethod = Method.getMethod("Class forName(String)");
+	final static Method forNameMethod = Method.getMethod("Class classForNameNonLoading(String)");
 	final static Method importClassMethod = Method.getMethod("Class importClass(Class)");
 	final static Method derefMethod = Method.getMethod("Object deref()");
 
@@ -726,7 +726,7 @@ public ImportExpr(String c){
 
 	public Object eval() {
 		Namespace ns = (Namespace) RT.CURRENT_NS.deref();
-		ns.importClass(RT.classForName(c));
+		ns.importClass(RT.classForNameNonLoading(c));
 		return null;
 	}
 
@@ -735,7 +735,7 @@ public void emit(C context, ObjExpr objx, GeneratorAdapter gen){
 		gen.invokeVirtual(VAR_TYPE, derefMethod);
 		gen.checkCast(NS_TYPE);
 		gen.push(c);
-		gen.invokeStatic(CLASS_TYPE, forNameMethod);
+		gen.invokeStatic(RT_TYPE, forNameMethod);
 		gen.invokeVirtual(NS_TYPE, importClassMethod);
 		if(context == C.STATEMENT)
 			gen.pop();

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -2115,7 +2115,7 @@ static public Class classForName(String name) {
 		}
 }
 
-static Class classForNameNonLoading(String name) {
+static public Class classForNameNonLoading(String name) {
 	try
 		{
 		return Class.forName(name, false, baseLoader());

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -514,7 +514,10 @@ else if(!(RT.second(form) instanceof Symbol))
 			if(!v.ns.equals(currentNS()))
 				{
 				if(sym.ns == null)
+					{
 					v = currentNS().intern(sym);
+					registerVar(v);
+					}
 //					throw Util.runtimeException("Name conflict, can't def " + sym + " because namespace: " + currentNS().name +
 //					                    " refers to:" + v);
 				else

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -3779,7 +3779,7 @@ boolean supportsMeta(){
 	}
 
 	public Class getJavaClass() {
-		return AFunction.class;
+		return tag != null ? HostExpr.tagToClass(tag) : AFunction.class;
 	}
 
 	protected void emitMethods(ClassVisitor cv){

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -502,8 +502,7 @@ else if(coll instanceof Map)
 	else {
 		Class c = coll.getClass();
 		Class sc = c.getSuperclass();
-		throw new ExceptionInfo("Don't know how to create ISeq from: " + c.getName(),
-                                        map(Keyword.intern("instance"), coll));
+		throw new IllegalArgumentException("Don't know how to create ISeq from: " + c.getName());
 	}
 }
 

File: src/jvm/clojure/lang/PersistentHashMap.java
Patch:
@@ -441,7 +441,7 @@ static public Object foldTasks(List<Callable> tasks, final IFn combinef,
 				}
 			catch(Exception e)
 				{
-				//aargh
+				throw Util.sneakyThrow(e);
 				}
 			}
 

File: src/jvm/clojure/lang/TransactionalHashMap.java
Patch:
@@ -86,7 +86,6 @@ public V remove(Object k){
 	Ref r = bins[binFor(k)];
 	IPersistentMap map = (IPersistentMap) r.deref();
 	Object ret = map.valAt(k);
-	//checked exceptions are a bad idea, especially in an interface
 	r.set(map.without(k));
 	return (V) ret;
 }
@@ -149,7 +148,6 @@ public boolean remove(Object k, Object v){
 	Entry e = map.entryAt(k);
 	if(e != null && e.getValue().equals(v))
 		{
-		//checked exceptions are a bad idea, especially in an interface
 		r.set(map.without(k));
 		return true;
 		}

File: src/jvm/clojure/lang/LispReader.java
Patch:
@@ -67,8 +67,6 @@ public class LispReader{
 				"([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?");
 static Pattern ratioPat = Pattern.compile("([-+]?[0-9]+)/([0-9]+)");
 static Pattern floatPat = Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?");
-static final Symbol SLASH = Symbol.intern("/");
-static final Symbol CLOJURE_SLASH = Symbol.intern("clojure.core","/");
 //static Pattern accessorPat = Pattern.compile("\\.[a-zA-Z_]\\w*");
 //static Pattern instanceMemberPat = Pattern.compile("\\.([a-zA-Z_][\\w\\.]*)\\.([a-zA-Z_]\\w*)");
 //static Pattern staticMemberPat = Pattern.compile("([a-zA-Z_][\\w\\.]*)\\.([a-zA-Z_]\\w*)");

File: src/jvm/clojure/lang/EdnReader.java
Patch:
@@ -24,7 +24,7 @@ public class EdnReader{
 
 static IFn[] macros = new IFn[256];
 static IFn[] dispatchMacros = new IFn[256];
-static Pattern symbolPat = Pattern.compile("[:]?+([\\D&&[^/]].*/)?([\\D&&[^/]][^/]*)");
+static Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?([\\D&&[^/]][^/]*)");
 static Pattern intPat =
 		Pattern.compile(
 				"([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?");

File: src/jvm/clojure/lang/LispReader.java
Patch:
@@ -59,7 +59,7 @@ public class LispReader{
 static IFn[] macros = new IFn[256];
 static IFn[] dispatchMacros = new IFn[256];
 //static Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^:/]][^:/]*/)?[\\D&&[^:/]][^:/]*");
-static Pattern symbolPat = Pattern.compile("[:]?+([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)");
+static Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)");
 //static Pattern varPat = Pattern.compile("([\\D&&[^:\\.]][^:\\.]*):([\\D&&[^:\\.]][^:\\.]*)");
 //static Pattern intPat = Pattern.compile("[-+]?[0-9]+\\.?");
 static Pattern intPat =

File: src/jvm/clojure/lang/EdnReader.java
Patch:
@@ -24,7 +24,7 @@ public class EdnReader{
 
 static IFn[] macros = new IFn[256];
 static IFn[] dispatchMacros = new IFn[256];
-static Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?([\\D&&[^/]][^/]*)");
+static Pattern symbolPat = Pattern.compile("[:]?+([\\D&&[^/]].*/)?([\\D&&[^/]][^/]*)");
 static Pattern intPat =
 		Pattern.compile(
 				"([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?");

File: src/jvm/clojure/lang/LispReader.java
Patch:
@@ -59,7 +59,7 @@ public class LispReader{
 static IFn[] macros = new IFn[256];
 static IFn[] dispatchMacros = new IFn[256];
 //static Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^:/]][^:/]*/)?[\\D&&[^:/]][^:/]*");
-static Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)");
+static Pattern symbolPat = Pattern.compile("[:]?+([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)");
 //static Pattern varPat = Pattern.compile("([\\D&&[^:\\.]][^:\\.]*):([\\D&&[^:\\.]][^:\\.]*)");
 //static Pattern intPat = Pattern.compile("[-+]?[0-9]+\\.?");
 static Pattern intPat =

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -502,7 +502,8 @@ else if(coll instanceof Map)
 	else {
 		Class c = coll.getClass();
 		Class sc = c.getSuperclass();
-		throw new IllegalArgumentException("Don't know how to create ISeq from: " + c.getName());
+		throw new ExceptionInfo("Don't know how to create ISeq from: " + c.getName(),
+                                        map(Keyword.intern("instance"), coll));
 	}
 }
 

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -2153,7 +2153,7 @@ public Expr parse(C context, Object frm) {
                                             if(bodyExpr == null)
                                                 try {
                                                     Var.pushThreadBindings(RT.map(NO_RECUR, true));
-						    bodyExpr = (new BodyExpr.Parser()).parse(C.EXPRESSION, RT.seq(body));
+						                            bodyExpr = (new BodyExpr.Parser()).parse(context, RT.seq(body));
                                                 } finally {
                                                     Var.popThreadBindings();
                                                 }

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -7043,6 +7043,7 @@ public static Object load(Reader rdr, String sourcePath, String sourceName) {
 			       LOCAL_ENV, null,
 					LOOP_LOCALS, null,
 					NEXT_LOCAL_NUM, 0,
+					RT.READEVAL, RT.T,
 			       RT.CURRENT_NS, RT.CURRENT_NS.deref(),
 			       LINE_BEFORE, pushbackReader.getLineNumber(),
 			       COLUMN_BEFORE, pushbackReader.getColumnNumber(),

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -181,12 +181,13 @@ public class RT{
 final static Keyword TAG_KEY = Keyword.intern(null, "tag");
 final static Keyword CONST_KEY = Keyword.intern(null, "const");
 final static public Var AGENT = Var.intern(CLOJURE_NS, Symbol.intern("*agent*"), null).setDynamic();
-final static public Var READEVAL = Var.intern(CLOJURE_NS, Symbol.intern("*read-eval*"), F).setDynamic();
+final static public Var READEVAL = Var.intern(CLOJURE_NS, Symbol.intern("*read-eval*"),
+                                              Keyword.intern(null, "default")
+                                              ).setDynamic();
 final static public Var READWHITELIST = Var.intern(CLOJURE_NS, Symbol.intern("*read-whitelist*"),
                                                    RT.vector(java.lang.Number.class,
                                                           java.util.Collection.class,
                                                           java.util.Map.class,
-                                                          clojure.lang.Namespace.class,
                                                           clojure.lang.Fn.class)).setDynamic();
 final static public Var DATA_READERS = Var.intern(CLOJURE_NS, Symbol.intern("*data-readers*"), RT.map()).setDynamic();
 final static public Var DEFAULT_DATA_READER_FN = Var.intern(CLOJURE_NS, Symbol.intern("*default-data-reader-fn*"), RT.map()).setDynamic();

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -183,6 +183,7 @@ public class RT{
 final static public Var AGENT = Var.intern(CLOJURE_NS, Symbol.intern("*agent*"), null).setDynamic();
 final static public Var READEVAL = Var.intern(CLOJURE_NS, Symbol.intern("*read-eval*"), T).setDynamic();
 final static public Var DATA_READERS = Var.intern(CLOJURE_NS, Symbol.intern("*data-readers*"), RT.map()).setDynamic();
+final static public Var DEFAULT_DATA_READER_FN = Var.intern(CLOJURE_NS, Symbol.intern("*default-data-reader-fn*"), RT.map()).setDynamic();
 final static public Var DEFAULT_DATA_READERS = Var.intern(CLOJURE_NS, Symbol.intern("default-data-readers"), RT.map());
 final static public Var ASSERT = Var.intern(CLOJURE_NS, Symbol.intern("*assert*"), T).setDynamic();
 final static public Var MATH_CONTEXT = Var.intern(CLOJURE_NS, Symbol.intern("*math-context*"), null).setDynamic();

File: src/jvm/clojure/lang/LispReader.java
Patch:
@@ -718,7 +718,7 @@ public Object invoke(Object reader, Object caret) {
 		if(r instanceof LineNumberingPushbackReader)
       {
 			line = ((LineNumberingPushbackReader) r).getLineNumber();
-			column = ((LineNumberingPushbackReader) r).getColumnNumber();
+			column = ((LineNumberingPushbackReader) r).getColumnNumber()-1;
       }
 		Object meta = read(r, true, null, true);
 		if(meta instanceof Symbol || meta instanceof String)
@@ -974,7 +974,7 @@ public Object invoke(Object reader, Object leftparen) {
 		if(r instanceof LineNumberingPushbackReader)
       {
 			line = ((LineNumberingPushbackReader) r).getLineNumber();
-			column = ((LineNumberingPushbackReader) r).getColumnNumber();
+			column = ((LineNumberingPushbackReader) r).getColumnNumber()-1;
       }
 		List list = readDelimitedList(')', r, true);
 		if(list.isEmpty())

File: src/jvm/clojure/lang/PersistentHashMap.java
Patch:
@@ -304,7 +304,7 @@ Object doValAt(Object key, Object notFound) {
 			else
 				return notFound;
 		if (root == null)
-			return null;
+			return notFound;
 		return root.find(0, hash(key), key, notFound);
 	}
 

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -6285,9 +6285,12 @@ else if(form instanceof IPersistentSet)
 static public class CompilerException extends RuntimeException{
 	final public String source;
 	
+	final public int line;
+
 	public CompilerException(String source, int line, Throwable cause){
 		super(errorMsg(source, line, cause.toString()), cause);
 		this.source = source;
+		this.line = line;
 	}
 
 	public String toString(){

File: src/jvm/clojure/lang/LispReader.java
Patch:
@@ -811,7 +811,9 @@ else if(isUnquoteSplicing(form))
 			throw new IllegalStateException("splice not in list");
 		else if(form instanceof IPersistentCollection)
 			{
-			if(form instanceof IPersistentMap)
+			if(form instanceof IRecord)
+				ret = form;
+			else if(form instanceof IPersistentMap)
 				{
 				IPersistentVector keyvals = flattenMap(form);
                 ret = RT.list(APPLY, HASHMAP, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(keyvals.seq()))));

File: src/jvm/clojure/lang/LispReader.java
Patch:
@@ -262,7 +262,7 @@ static private int readUnicodeChar(String token, int offset, int length, int bas
 		{
 		int d = Character.digit(token.charAt(i), base);
 		if(d == -1)
-			throw new IllegalArgumentException("Invalid digit: " + (char) d);
+			throw new IllegalArgumentException("Invalid digit: " + token.charAt(i));
 		uc = uc * base + d;
 		}
 	return (char) uc;
@@ -271,7 +271,7 @@ static private int readUnicodeChar(String token, int offset, int length, int bas
 static private int readUnicodeChar(PushbackReader r, int initch, int base, int length, boolean exact) {
 	int uc = Character.digit(initch, base);
 	if(uc == -1)
-		throw new IllegalArgumentException("Invalid digit: " + initch);
+		throw new IllegalArgumentException("Invalid digit: " + (char) initch);
 	int i = 1;
 	for(; i < length; ++i)
 		{

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -183,6 +183,7 @@ public class RT{
 final static public Var AGENT = Var.intern(CLOJURE_NS, Symbol.intern("*agent*"), null).setDynamic();
 final static public Var READEVAL = Var.intern(CLOJURE_NS, Symbol.intern("*read-eval*"), T).setDynamic();
 final static public Var DATA_READERS = Var.intern(CLOJURE_NS, Symbol.intern("*data-readers*"), RT.map()).setDynamic();
+final static public Var DEFAULT_DATA_READERS = Var.intern(CLOJURE_NS, Symbol.intern("default-data-readers"), RT.map());
 final static public Var ASSERT = Var.intern(CLOJURE_NS, Symbol.intern("*assert*"), T).setDynamic();
 final static public Var MATH_CONTEXT = Var.intern(CLOJURE_NS, Symbol.intern("*math-context*"), null).setDynamic();
 static Keyword LINE_KEY = Keyword.intern(null, "line");

File: src/jvm/clojure/lang/Var.java
Patch:
@@ -103,9 +103,9 @@ public static Object getThreadBindingFrame(){
 }
 
 public static Object cloneThreadBindingFrame(){
-	Frame f = (Frame) dvals.get().clone();
+	Frame f = dvals.get();
 	if(f != null)
-		return f;
+		return f.clone();
 	return new Frame();
 }
 

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -7247,7 +7247,7 @@ static ObjExpr build(IPersistentVector interfaceSyms, IPersistentVector fieldSym
 			//use array map to preserve ctor order
 			ret.closes = new PersistentArrayMap(closesvec);
 			ret.fields = fmap;
-			for(int i=fieldSyms.count()-1;i >= 0 && ((Symbol)fieldSyms.nth(i)).name.startsWith("__");--i)
+			for(int i=fieldSyms.count()-1;i >= 0 && (((Symbol)fieldSyms.nth(i)).name.equals("__meta") || ((Symbol)fieldSyms.nth(i)).name.equals("__extmap"));--i)
 				ret.altCtorDrops++;
 			}
 		//todo - set up volatiles

File: src/jvm/clojure/lang/Numbers.java
Patch:
@@ -1493,7 +1493,7 @@ static public long clearBit(long x, Object y){
     return clearBit(x,bitOpsCast(y));
 }
 static public long clearBit(long x, long n){
-    return x & (1L << n);
+    return x & ~(1L << n);
 }
 
 static public long setBit(Object x, Object y){

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -4571,8 +4571,8 @@ String thunkNameStatic(int n){
 
 	Type constantType(int id){
 		Object o = constants.nth(id);
-		Class c = o.getClass();
-		if(Modifier.isPublic(c.getModifiers()))
+		Class c = clojure.lang.Util.classOf(o);
+		if(c!= null && Modifier.isPublic(c.getModifiers()))
 			{
 			//can't emit derived fn types due to visibility
 			if(LazySeq.class.isAssignableFrom(c))

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -3221,7 +3221,7 @@ public Object eval() throws Exception{
 			PersistentVector argvs = PersistentVector.EMPTY;
 			for(int i = 0; i < args.count(); i++)
 				argvs = argvs.cons(((Expr) args.nth(i)).eval());
-			return fn.applyTo(RT.seq(argvs));
+			return fn.applyTo(RT.seq( Util.ret1(argvs, argvs = null) ));
 			}
 		catch(Throwable e)
 			{

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -2532,7 +2532,8 @@ else if(form.count() < 3)
 '!', "_BANG_",
 '@', "_CIRCA_",
 '#', "_SHARP_",
-'$', "_DOLLARSIGN_",
+'\'', "_SINGLEQUOTE_",
+'"', "_DOUBLEQUOTE_",
 '%', "_PERCENT_",
 '^', "_CARET_",
 '&', "_AMPERSAND_",

File: src/jvm/clojure/lang/Keyword.java
Patch:
@@ -27,6 +27,8 @@ public final class Keyword implements IFn, Comparable, Named, Serializable {
 final int hash;
 
 public static Keyword intern(Symbol sym){
+	if(sym.meta() != null)
+		sym = (Symbol) sym.withMeta(null);
 	Util.clearCache(rq, table);
 	Keyword k = new Keyword(sym);
 	SoftReference<Keyword> existingRef = table.putIfAbsent(sym, new SoftReference<Keyword>(k,rq));

File: src/jvm/clojure/lang/Agent.java
Patch:
@@ -128,7 +128,7 @@ static void doRun(Action action){
 				}
 			else
 				{
-				nested.set(PersistentVector.EMPTY);
+				nested.set(null); // allow errorHandler to send
 				if(action.agent.errorHandler != null)
 					{
 					try

File: src/jvm/clojure/lang/AFn.java
Patch:
@@ -436,7 +436,6 @@ static public Object applyToHelper(IFn ifn, ISeq arglist) throws Exception{
 public Object throwArity(int n){
 	String name = getClass().getSimpleName();
 	int suffix = name.lastIndexOf("__");
-	throw new IllegalArgumentException("Wrong number of args (" + n + ") passed to: "
-	                                   + (suffix == -1 ? name : name.substring(0, suffix)).replace('_', '-'));
+	throw new ArityException(n, (suffix == -1 ? name : name.substring(0, suffix)).replace('_', '-'));
 }
 }

File: src/jvm/clojure/lang/DynamicClassLoader.java
Patch:
@@ -54,6 +54,8 @@ protected Class<?> findClass(String name) throws ClassNotFoundException{
 		Class c = cr.get();
         if(c != null)
             return c;
+		else
+	        classCache.remove(name, cr);
 		}
 	return super.findClass(name);
 }

File: src/jvm/clojure/lang/Keyword.java
Patch:
@@ -36,6 +36,7 @@ public static Keyword intern(Symbol sym){
 	if(existingk != null)
 		return existingk;
 	//entry died in the interim, do over
+	table.remove(sym, existingRef);
 	return intern(sym);
 }
 

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -725,7 +725,7 @@ static Object nthFrom(Object coll, int n){
 	else if(coll instanceof CharSequence)
 		return Character.valueOf(((CharSequence) coll).charAt(n));
 	else if(coll.getClass().isArray())
-		return Reflector.prepRet(Array.get(coll, n));
+		return Reflector.prepRet(coll.getClass().getComponentType(),Array.get(coll, n));
 	else if(coll instanceof RandomAccess)
 		return ((List) coll).get(n);
 	else if(coll instanceof Matcher)
@@ -776,7 +776,7 @@ else if(coll instanceof CharSequence) {
 	}
 	else if(coll.getClass().isArray()) {
 		if(n < Array.getLength(coll))
-			return Reflector.prepRet(Array.get(coll, n));
+			return Reflector.prepRet(coll.getClass().getComponentType(),Array.get(coll, n));
 		return notFound;
 	}
 	else if(coll instanceof RandomAccess) {

File: src/jvm/clojure/lang/LazySeq.java
Patch:
@@ -108,6 +108,9 @@ public boolean equiv(Object o){
 }
 
 public int hashCode(){
+	ISeq s = seq();
+	if(s == null)
+		return 1;
 	return Util.hash(seq());
 }
 

File: src/jvm/clojure/lang/LispReader.java
Patch:
@@ -330,7 +330,7 @@ private static Object matchNumber(String s){
 			{
 			if(m.group(8) != null)
 				return BigInteger.ZERO;			
-			return new Long(0);
+			return Numbers.num(0);
 			}
 		boolean negate = (m.group(1).equals("-"));
 		String n;

File: src/jvm/clojure/lang/PersistentVector.java
Patch:
@@ -625,7 +625,7 @@ public TransientVector pop(){
 			}
 		if(shift > 5 && newroot.array[1] == null)
 			{
-			newroot = (Node) newroot.array[0];
+			newroot = ensureEditable((Node) newroot.array[0]);
 			newshift -= 5;
 			}
 		root = newroot;

File: src/jvm/clojure/lang/PersistentVector.java
Patch:
@@ -621,7 +621,7 @@ public TransientVector pop(){
 		int newshift = shift;
 		if(newroot == null)
 			{
-			newroot = EMPTY_NODE;
+			newroot = new Node(root.edit);
 			}
 		if(shift > 5 && newroot.array[1] == null)
 			{

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -5313,7 +5313,7 @@ public static Object eval(Object form) throws Exception{
 
 public static Object eval(Object form, boolean freshLoader) throws Exception{
 	boolean createdLoader = false;
-	if(freshLoader)//!LOADER.isBound())
+	if(true)//!LOADER.isBound())
 		{
 		Var.pushThreadBindings(RT.map(LOADER, RT.makeClassLoader()));
 		createdLoader = true;

File: src/jvm/clojure/lang/Compile.java
Patch:
@@ -31,7 +31,7 @@ public class Compile{
 public static void main(String[] args) throws Exception{
 
 	OutputStreamWriter out = (OutputStreamWriter) RT.OUT.deref();
-	PrintWriter err = (PrintWriter) RT.ERR.deref();
+	PrintWriter err = RT.errPrintWriter();
 	String path = System.getProperty(PATH_PROP);
 	int count = args.length;
 

File: src/jvm/clojure/lang/Namespace.java
Patch:
@@ -14,7 +14,6 @@
 
 import java.io.ObjectStreamException;
 import java.io.Serializable;
-import java.io.PrintWriter;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -82,7 +81,7 @@ public Var intern(Symbol sym){
 }
 
 private void warnOnReplace(Symbol sym, Object o, Object v){
-	((PrintWriter) RT.ERR.deref()).println("WARNING: " + sym + " already refers to: " + o + " in namespace: " + name
+	RT.errPrintWriter().println("WARNING: " + sym + " already refers to: " + o + " in namespace: " + name
 		+ ", being replaced by: " + v);
 }
 

File: src/jvm/clojure/lang/AFn.java
Patch:
@@ -12,9 +12,7 @@
 
 package clojure.lang;
 
-import java.io.Serializable;
-
-public abstract class AFn implements IFn, Serializable{
+public abstract class AFn implements IFn {
 
 public Object call() throws Exception{
 	return invoke();

File: src/jvm/clojure/lang/AFunction.java
Patch:
@@ -12,9 +12,10 @@
 
 package clojure.lang;
 
+import java.io.Serializable;
 import java.util.Comparator;
 
-public abstract class AFunction extends AFn implements IObj, Comparator, Fn{
+public abstract class AFunction extends AFn implements IObj, Comparator, Fn, Serializable {
 
 public volatile MethodImplCache __methodImplCache;
 

File: src/jvm/clojure/lang/APersistentMap.java
Patch:
@@ -10,9 +10,10 @@
 
 package clojure.lang;
 
+import java.io.Serializable;
 import java.util.*;
 
-public abstract class APersistentMap extends AFn implements IPersistentMap, Map, Iterable{
+public abstract class APersistentMap extends AFn implements IPersistentMap, Map, Iterable, Serializable {
 int _hash = -1;
 
 public String toString(){

File: src/jvm/clojure/lang/APersistentSet.java
Patch:
@@ -12,11 +12,12 @@
 
 package clojure.lang;
 
+import java.io.Serializable;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Set;
 
-public abstract class APersistentSet extends AFn implements IPersistentSet, Collection, Set{
+public abstract class APersistentSet extends AFn implements IPersistentSet, Collection, Set, Serializable {
 int _hash = -1;
 final IPersistentMap impl;
 

File: src/jvm/clojure/lang/APersistentVector.java
Patch:
@@ -12,11 +12,13 @@
 
 package clojure.lang;
 
+import java.io.Serializable;
 import java.util.*;
 
 public abstract class APersistentVector extends AFn implements IPersistentVector, Iterable,
                                                                List,
-                                                               RandomAccess, Comparable{
+                                                               RandomAccess, Comparable,
+                                                               Serializable {
 int _hash = -1;
 
 public String toString(){

File: src/jvm/clojure/lang/ASeq.java
Patch:
@@ -10,9 +10,10 @@
 
 package clojure.lang;
 
+import java.io.Serializable;
 import java.util.*;
 
-public abstract class ASeq extends Obj implements ISeq, List{
+public abstract class ASeq extends Obj implements ISeq, List, Serializable {
 transient int _hash = -1;
 
 public String toString(){

File: src/jvm/clojure/lang/ArrayChunk.java
Patch:
@@ -12,7 +12,9 @@
 
 package clojure.lang;
 
-public final class ArrayChunk implements IChunk{
+import java.io.Serializable;
+
+public final class ArrayChunk implements IChunk, Serializable {
 
 final Object[] array;
 final int off;

File: src/jvm/clojure/lang/Cons.java
Patch:
@@ -12,7 +12,9 @@
 
 package clojure.lang;
 
-final public class Cons extends ASeq{
+import java.io.Serializable;
+
+final public class Cons extends ASeq implements Serializable {
 
 private final Object _first;
 private final ISeq _more;

File: src/jvm/clojure/lang/Obj.java
Patch:
@@ -12,7 +12,9 @@
 
 package clojure.lang;
 
-public abstract class Obj implements IObj{
+import java.io.Serializable;
+
+public abstract class Obj implements IObj, Serializable {
 
 final IPersistentMap _meta;
 

File: src/jvm/clojure/lang/PersistentArrayMap.java
Patch:
@@ -10,6 +10,7 @@
 
 package clojure.lang;
 
+import java.io.Serializable;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.Map;

File: src/jvm/clojure/lang/PersistentHashMap.java
Patch:
@@ -10,6 +10,7 @@
 
 package clojure.lang;
 
+import java.io.Serializable;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -292,7 +293,7 @@ void ensureEditable(){
 	}
 }
 
-static interface INode{
+static interface INode extends Serializable {
 	INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf);
 
 	INode without(int shift, int hash, Object key);

File: src/jvm/clojure/lang/PersistentList.java
Patch:
@@ -10,9 +10,10 @@
 
 package clojure.lang;
 
+import java.io.Serializable;
 import java.util.*;
 
-public class PersistentList extends ASeq implements IPersistentList, IReduce, List, Counted{
+public class PersistentList extends ASeq implements IPersistentList, IReduce, List, Counted {
 
 private final Object _first;
 private final IPersistentList _rest;

File: src/jvm/clojure/lang/PersistentVector.java
Patch:
@@ -12,13 +12,14 @@
 
 package clojure.lang;
 
+import java.io.Serializable;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicReference;
 
 public class PersistentVector extends APersistentVector implements IObj, IEditableCollection{
 
-static class Node{
-	final AtomicReference<Thread> edit;
+static class Node implements Serializable {
+	transient final AtomicReference<Thread> edit;
 	final Object[] array;
 
 	Node(AtomicReference<Thread> edit, Object[] array){

File: src/jvm/clojure/lang/Range.java
Patch:
@@ -12,8 +12,6 @@
 
 package clojure.lang;
 
-import java.util.concurrent.atomic.AtomicInteger;
-
 public class Range extends ASeq implements IReduce, Counted{
 final int end;
 final int n;

File: src/jvm/clojure/lang/PersistentQueue.java
Patch:
@@ -47,7 +47,7 @@ public boolean equiv(Object obj){
 		if(ms == null || !Util.equiv(s.first(), ms.first()))
 			return false;
 		}
-	return ms.next() == null;
+	return ms == null;
 
 }
 
@@ -61,7 +61,7 @@ public boolean equals(Object obj){
 		if(ms == null || !Util.equals(s.first(), ms.first()))
 			return false;
 		}
-	return ms.next() == null;
+	return ms == null;
 
 }
 

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -2755,7 +2755,7 @@ public boolean canEmitPrimitive(){
 	}
 
 	public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen){
-		expr.emit(context,objx,gen);
+		expr.emit(C.EXPRESSION,objx,gen);
 		gen.instanceOf(Type.getType(c));
 	}
 

File: src/jvm/clojure/lang/Numbers.java
Patch:
@@ -295,6 +295,8 @@ static public Number divide(BigInteger n, BigInteger d){
 	d = d.divide(gcd);
 	if(d.equals(BigInteger.ONE))
 		return reduce(n);
+	else if(d.equals(BigInteger.ONE.negate()))
+		return reduce(n.negate());
 	return new Ratio((d.signum() < 0 ? n.negate() : n),
 	                 (d.signum() < 0 ? d.negate() : d));
 }

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -6767,7 +6767,7 @@ public Expr parse(C context, Object frm) throws Exception{
                 try {
                     Var.pushThreadBindings(
                             RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH,branch)));
-                    thenExpr = analyze(C.EXPRESSION, me.getValue());
+                    thenExpr = analyze(context, me.getValue());
                     }
                 finally{
                     Var.popThreadBindings();
@@ -6779,7 +6779,7 @@ public Expr parse(C context, Object frm) throws Exception{
             try {
                 Var.pushThreadBindings(
                         RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH,branch)));
-                defaultExpr = analyze(C.EXPRESSION, args.nth(5));
+                defaultExpr = analyze(context, args.nth(5));
                 }
             finally{
                 Var.popThreadBindings();

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -4014,7 +4014,9 @@ public boolean hasJavaClass() throws Exception{
 	}
 
 	public Class getJavaClass() throws Exception{
-		return (tag != null) ? HostExpr.tagToClass(tag) : IFn.class;
+		return (compiledClass != null) ? compiledClass
+			: (tag != null) ? HostExpr.tagToClass(tag)
+			: IFn.class;
 	}
 
 	public void emitAssignLocal(GeneratorAdapter gen, LocalBinding lb,Expr val){

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -1018,8 +1018,8 @@ static public IPersistentMap map(Object... init){
 	if(init == null)
 		return PersistentArrayMap.EMPTY;
 	else if(init.length <= PersistentArrayMap.HASHTABLE_THRESHOLD)
-		return new PersistentArrayMap(init);
-	return PersistentHashMap.create(init);
+		return PersistentArrayMap.createWithCheck(init);
+	return PersistentHashMap.createWithCheck(init);
 }
 
 static public IPersistentSet set(Object... init){

File: src/jvm/clojure/lang/PersistentTreeMap.java
Patch:
@@ -137,7 +137,7 @@ public ISeq seq(){
 }
 
 public IPersistentCollection empty(){
-	return EMPTY.withMeta(meta());	
+	return new PersistentTreeMap(meta(), comp);	
 }
 
 public ISeq rseq() throws Exception{

File: src/jvm/clojure/lang/PersistentTreeSet.java
Patch:
@@ -53,7 +53,7 @@ public IPersistentSet cons(Object o){
 }
 
 public IPersistentCollection empty(){
-	return EMPTY.withMeta(meta());	
+	return new PersistentTreeSet(meta(),(PersistentTreeMap)impl.empty());
 }
 
 public ISeq rseq() throws Exception{

File: src/jvm/clojure/lang/PersistentHashMap.java
Patch:
@@ -270,8 +270,8 @@ void ensureEditable(){
 		if(owner == Thread.currentThread())
 			return;
 		if(owner != null)
-			throw new IllegalAccessError("Mutable used by non-owner thread");
-		throw new IllegalAccessError("Mutable used after immutable call");
+			throw new IllegalAccessError("Transient used by non-owner thread");
+		throw new IllegalAccessError("Transient used after persistent! call");
 	}
 }
 

File: src/jvm/clojure/lang/PersistentVector.java
Patch:
@@ -402,8 +402,8 @@ void ensureEditable(){
 		if(owner == Thread.currentThread())
 			return;
 		if(owner != null)
-			throw new IllegalAccessError("Mutable used by non-owner thread");
-		throw new IllegalAccessError("Mutable used after immutable call");
+			throw new IllegalAccessError("Transient used by non-owner thread");
+		throw new IllegalAccessError("Transient used after persistent! call");
 
 //		root = editableRoot(root);
 //		tail = editableTail(tail);

File: src/jvm/clojure/lang/ILookupThunk.java
Patch:
@@ -14,6 +14,6 @@
 
 public interface ILookupThunk{
 
-Object get(Object target, ILookupSite site);
+Object get(Object target);
 
 }

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -352,7 +352,7 @@ public Expr parse(C context, Object form) throws Exception{
 			else if(RT.count(form) < 2)
 				throw new Exception("Too few arguments to def");
 			else if(!(RT.second(form) instanceof Symbol))
-					throw new Exception("Second argument to def must be a Symbol");
+					throw new Exception("First argument to def must be a Symbol");
 			Symbol sym = (Symbol) RT.second(form);
 			Var v = lookupVar(sym, true);
 			if(v == null)

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -4439,8 +4439,8 @@ public static Object eval(Object form, boolean freshLoader) throws Exception{
 				{
 				ISeq s = RT.next(form);
 				for(; RT.next(s) != null; s = RT.next(s))
-					eval(RT.first(s));
-				return eval(RT.first(s));
+					eval(RT.first(s),false);
+				return eval(RT.first(s),false);
 				}
 			else if(form instanceof IPersistentCollection
 			        && !(RT.first(form) instanceof Symbol

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -476,7 +476,7 @@ else if(coll instanceof Map)
 	else {
 		Class c = coll.getClass();
 		Class sc = c.getSuperclass();
-		throw new IllegalArgumentException("Don't know how to create ISeq from: " + c.getSimpleName());
+		throw new IllegalArgumentException("Don't know how to create ISeq from: " + c.getName());
 	}
 }
 

File: src/jvm/clojure/lang/Symbol.java
Patch:
@@ -42,7 +42,7 @@ static public Symbol intern(String ns, String name){
 
 static public Symbol intern(String nsname){
 	int i = nsname.lastIndexOf('/');
-	if(i == -1)
+	if(i == -1 || nsname.equals("/"))
 		return new Symbol(null, nsname.intern());
 	else
 		return new Symbol(nsname.substring(0, i).intern(), nsname.substring(i + 1).intern());

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -866,7 +866,9 @@ static Class tagToClass(Object tag) throws Exception{
 			Symbol sym = (Symbol) tag;
 			if(sym.ns == null) //if ns-qualified can't be classname
 				{
-				if(sym.name.equals("ints"))
+				if(sym.name.equals("objects"))
+					c = Object[].class;
+				else if(sym.name.equals("ints"))
 					c = int[].class;
 				else if(sym.name.equals("longs"))
 					c = long[].class;

File: src/jvm/clojure/lang/PersistentHashMap.java
Patch:
@@ -770,15 +770,15 @@ public int findIndex(Object key){
 	private HashCollisionNode ensureEditable(AtomicReference<Thread> edit){
 		if(this.edit == edit)
 			return this;
-		return new HashCollisionNode(edit, count, hash, array);
+		return new HashCollisionNode(edit, hash, count, array);
 	}
 
 	private HashCollisionNode ensureEditable(AtomicReference<Thread> edit, int count, Object[] array){
 		if(this.edit == edit) {
 			this.array = array;
 			return this;
 		}
-		return new HashCollisionNode(edit, count, hash, array);
+		return new HashCollisionNode(edit, hash, count, array);
 	}
 
 	private HashCollisionNode editAndSet(AtomicReference<Thread> edit, int i, Object a) {

File: src/jvm/clojure/lang/PersistentHashMap.java
Patch:
@@ -747,7 +747,7 @@ public INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf){
 			return new HashCollisionNode(edit, hash, count + 1, newArray);
 		}
 		// nest it in a bitmap node
-		return new BitmapIndexedNode(null, bitpos(this.hash, shift), new Object[] {this})
+		return new BitmapIndexedNode(null, bitpos(this.hash, shift), new Object[] {null, this})
 			.assoc(shift, hash, key, val, addedLeaf);
 	}
 
@@ -839,7 +839,7 @@ public INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key
 			return ensureEditable(edit, count + 1, newArray);
 		}
 		// nest it in a bitmap node
-		return new BitmapIndexedNode(edit, bitpos(this.hash, shift), new Object[] {this})
+		return new BitmapIndexedNode(edit, bitpos(this.hash, shift), new Object[] {null, this})
 			.assoc(edit, shift, hash, key, val, addedLeaf);
 	}	
 

File: src/jvm/clojure/lang/PersistentHashMap2.java
Patch:
@@ -714,7 +714,7 @@ public INode without(int shift, int hash, Object key){
 			return this;
 		if(array.length == 2)
 			return null;
-		return new HashCollisionNode(null, hash, removePair(array, idx));
+		return new HashCollisionNode(null, hash, count - 1, removePair(array, idx/2));
 	}
 
 	public IMapEntry find(int shift, int hash, Object key){

File: src/jvm/clojure/lang/PersistentHashMap.java
Patch:
@@ -221,7 +221,7 @@ ITransientMap doWithout(Object key) {
 		Box removedLeaf = new Box(null);
 		INode newroot = root.without(edit, Util.hash(key), key, removedLeaf);
 		this.root = newroot == null ? EMPTY.root : newroot;
-		if (removedLeaf != null) this.count--;
+		if (removedLeaf.val != null) this.count--;
 		return this;
 	}
 

File: src/jvm/clojure/lang/ITransientMap.java
Patch:
@@ -17,4 +17,6 @@ public interface ITransientMap extends ITransientAssociative, Counted{
 ITransientMap assoc(Object key, Object val);
 
 ITransientMap without(Object key);
+
+IPersistentMap persistent();
 }

File: src/jvm/clojure/lang/PersistentHashMap.java
Patch:
@@ -66,7 +66,7 @@ static public IPersistentMap create(Map other){
 		Map.Entry e = (Entry) o;
 		ret = ret.assoc(e.getKey(), e.getValue());
 		}
-	return (IPersistentMap) ret.persistent();
+	return ret.persistent();
 }
 
 /*

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -1026,7 +1026,7 @@ public void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen,
 static Class maybePrimitiveType(Expr e){
 	try
 		{
-		if(e instanceof MaybePrimitiveExpr && e.hasJavaClass())
+		if(e instanceof MaybePrimitiveExpr && e.hasJavaClass() && ((MaybePrimitiveExpr)e).canEmitPrimitive())
 			{
 			Class c = e.getJavaClass();
 			if(Util.isPrimitive(c))
@@ -2135,8 +2135,7 @@ public void emit(C context, ObjExpr objx, GeneratorAdapter gen){
 
 		try
 			{
-			if(testExpr instanceof MaybePrimitiveExpr && testExpr.hasJavaClass() &&
-			   testExpr.getJavaClass() == boolean.class)
+			if(maybePrimitiveType(testExpr) == boolean.class)
 				{
 				((MaybePrimitiveExpr) testExpr).emitUnboxed(C.EXPRESSION, objx, gen);
 				gen.ifZCmp(gen.EQ, falseLabel);

File: src/jvm/clojure/lang/Reflector.java
Patch:
@@ -382,7 +382,8 @@ else if(paramType == short.class)
 		else if(paramType == byte.class)
 			return n.byteValue();
 		}
-	throw new IllegalArgumentException("Unexpected param type");
+	throw new IllegalArgumentException("Unexpected param type, expected: " + paramType +
+	                                   ", given: " + arg.getClass().getName());
 }
 
 static Object[] boxArgs(Class[] params, Object[] args){

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -971,7 +971,7 @@ public Object evalAssign(Expr val) throws Exception{
 	public void emitAssign(C context, FnExpr fn, GeneratorAdapter gen,
 	                       Expr val){
 		gen.visitLineNumber(line, gen.mark());
-		if(targetClass != null)
+		if(targetClass != null && field != null)
 			{
 			target.emit(C.EXPRESSION, fn, gen);
 			gen.checkCast(Type.getType(targetClass));

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -179,6 +179,7 @@ public class RT{
 final static Keyword TAG_KEY = Keyword.intern(null, "tag");
 final static public Var AGENT = Var.intern(CLOJURE_NS, Symbol.create("*agent*"), null);
 final static public Var READEVAL = Var.intern(CLOJURE_NS, Symbol.create("*read-eval*"), T);
+final static public Var ASSERT = Var.intern(CLOJURE_NS, Symbol.create("*assert*"), T);
 final static public Var MACRO_META = Var.intern(CLOJURE_NS, Symbol.create("*macro-meta*"), null);
 final static public Var MATH_CONTEXT = Var.intern(CLOJURE_NS, Symbol.create("*math-context*"), null);
 static Keyword LINE_KEY = Keyword.intern(null, "line");

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -169,13 +169,13 @@ public class RT{
 static public final Namespace CLOJURE_NS = Namespace.findOrCreate(Symbol.create("clojure.core"));
 //static final Namespace USER_NS = Namespace.findOrCreate(Symbol.create("user"));
 final static public Var OUT =
-		Var.intern(CLOJURE_NS, Symbol.create("*out*"), new OutputStreamWriter(System.out, UTF8));
+		Var.intern(CLOJURE_NS, Symbol.create("*out*"), new OutputStreamWriter(System.out));
 final static public Var IN =
 		Var.intern(CLOJURE_NS, Symbol.create("*in*"),
-		           new LineNumberingPushbackReader(new InputStreamReader(System.in, UTF8)));
+		           new LineNumberingPushbackReader(new InputStreamReader(System.in)));
 final static public Var ERR =
 		Var.intern(CLOJURE_NS, Symbol.create("*err*"),
-		           new PrintWriter(new OutputStreamWriter(System.err, UTF8), true));
+		           new PrintWriter(new OutputStreamWriter(System.err), true));
 final static Keyword TAG_KEY = Keyword.intern(null, "tag");
 final static public Var AGENT = Var.intern(CLOJURE_NS, Symbol.create("*agent*"), null);
 final static public Var READEVAL = Var.intern(CLOJURE_NS, Symbol.create("*read-eval*"), T);

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -4594,6 +4594,7 @@ private static Expr analyzeSymbol(Symbol sym) throws Exception{
 				{
 				if(Reflector.getField(c, sym.name, true) != null)
 					return new StaticFieldExpr((Integer) LINE.deref(), c, sym.name);
+				throw new Exception("Unable to find static field: " + sym.name + " in " + c);
 				}
 			}
 		}

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -362,7 +362,9 @@ else if(!(RT.second(form) instanceof Symbol))
 					throw new Exception("Can't create defs outside of current ns");
 				}
 			IPersistentMap mm = sym.meta();
-			mm = (IPersistentMap) RT.assoc(mm, RT.LINE_KEY, LINE.deref()).assoc(RT.FILE_KEY, SOURCE.deref());
+            Object source_path = SOURCE_PATH.get();
+            source_path = source_path == null ? "NO_SOURCE_FILE" : source_path;
+            mm = (IPersistentMap) RT.assoc(mm, RT.LINE_KEY, LINE.get()).assoc(RT.FILE_KEY, source_path);
 			Expr meta = analyze(context == C.EVAL ? context : C.EXPRESSION, mm);
 			return new DefExpr((String) SOURCE.deref(), (Integer) LINE.deref(),
 			                   v, analyze(context == C.EVAL ? context : C.EXPRESSION, RT.third(form), v.sym.name),

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -178,6 +178,7 @@ public class RT{
 		           new PrintWriter(new OutputStreamWriter(System.err, UTF8), true));
 final static Keyword TAG_KEY = Keyword.intern(null, "tag");
 final static public Var AGENT = Var.intern(CLOJURE_NS, Symbol.create("*agent*"), null);
+final static public Var READEVAL = Var.intern(CLOJURE_NS, Symbol.create("*read-eval*"), T);
 final static public Var MACRO_META = Var.intern(CLOJURE_NS, Symbol.create("*macro-meta*"), null);
 final static public Var MATH_CONTEXT = Var.intern(CLOJURE_NS, Symbol.create("*math-context*"), null);
 static Keyword LINE_KEY = Keyword.intern(null, "line");

File: src/jvm/clojure/lang/Numbers.java
Patch:
@@ -1734,7 +1734,7 @@ static public int xor(int x, int y){
 
 static public int minus(int x, int y){
 	int ret = x - y;
-	if (((ret ^ x) < 0 && (ret ^ -y) < 0) || (y == Integer.MIN_VALUE))
+	if (((ret ^ x) < 0 && (ret ^ ~y) < 0))
 		return throwIntOverflow();
 	return ret;
 }
@@ -1841,13 +1841,13 @@ static public long add(long x, long y){
 
 static public long minus(long x, long y){
 	long ret = x - y;
-	if (((ret ^ x) < 0 && (ret ^ -y) < 0) || (y == Long.MIN_VALUE))
+	if (((ret ^ x) < 0 && (ret ^ ~y) < 0))
 		return throwIntOverflow();
 	return ret;
 }
 
 static public long minus(long x){
-	if(x == Integer.MIN_VALUE)
+	if(x == Long.MIN_VALUE)
 		return throwIntOverflow();
 	return -x;
 }

File: src/jvm/clojure/lang/LispReader.java
Patch:
@@ -780,11 +780,11 @@ private static IPersistentVector flattenMap(Object form){
 }
 
 static boolean isUnquoteSplicing(Object form){
-	return form instanceof ISeq && RT.first(form).equals(UNQUOTE_SPLICING);
+	return form instanceof ISeq && Util.equals(RT.first(form),UNQUOTE_SPLICING);
 }
 
 static boolean isUnquote(Object form){
-	return form instanceof ISeq && RT.first(form).equals(UNQUOTE);
+	return form instanceof ISeq && Util.equals(RT.first(form),UNQUOTE);
 }
 
 static class UnquoteReader extends AFn{

File: src/jvm/clojure/lang/LazySeq.java
Patch:
@@ -80,8 +80,6 @@ public int hashCode() {
 
     public boolean equals(Object o) {
         ISeq s = seq();
-        if( s == o )
-            return true;
         if( s != null )
             return s.equiv(o);
         else

File: src/jvm/clojure/lang/PersistentList.java
Patch:
@@ -120,7 +120,7 @@ public int hashCode(){
 	}
 
     public boolean equals(Object o) {
-        return (o instanceof Sequential || o instanceof List) && RT.count(o) == 0;
+        return (o instanceof Sequential || o instanceof List) && RT.seq(o) == null;
     }
 
 	public boolean equiv(Object o){

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -760,7 +760,7 @@ else if(coll.getClass().isArray())
 			return Reflector.prepRet(Array.get(coll, n));
 		return notFound;
 		}
-	else if(coll instanceof List)
+	else if(coll instanceof RandomAccess)
 		{
 		List list = (List) coll;
 		if(n < list.size())

File: src/jvm/clojure/lang/Numbers.java
Patch:
@@ -1740,7 +1740,7 @@ static public int xor(int x, int y){
 
 static public int minus(int x, int y){
 	int ret = x - y;
-	if ((ret ^ x) < 0 && (ret ^ -y) < 0)
+	if (((ret ^ x) < 0 && (ret ^ -y) < 0) || (y == Integer.MIN_VALUE))
 		return throwIntOverflow();
 	return ret;
 }
@@ -1847,7 +1847,7 @@ static public long add(long x, long y){
 
 static public long minus(long x, long y){
 	long ret = x - y;
-	if ((ret ^ x) < 0 && (ret ^ -y) < 0)
+	if (((ret ^ x) < 0 && (ret ^ -y) < 0) || (y == Long.MIN_VALUE))
 		return throwIntOverflow();
 	return ret;
 }

File: src/jvm/clojure/lang/ARef.java
Patch:
@@ -1,8 +1,8 @@
 /**
  *   Copyright (c) Rich Hickey. All rights reserved.
  *   The use and distribution terms for this software are covered by the
- *   Common Public License 1.0 (http://opensource.org/licenses/cpl.php)
- *   which can be found in the file CPL.TXT at the root of this distribution.
+ *   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
+ *   which can be found in the file epl-v10.html at the root of this distribution.
  *   By using this software in any fashion, you are agreeing to be bound by
  * 	 the terms of this license.
  *   You must not remove this notice, or any other, from this software.

File: src/jvm/clojure/lang/AReference.java
Patch:
@@ -1,8 +1,8 @@
 /**
  *   Copyright (c) Rich Hickey. All rights reserved.
  *   The use and distribution terms for this software are covered by the
- *   Common Public License 1.0 (http://opensource.org/licenses/cpl.php)
- *   which can be found in the file CPL.TXT at the root of this distribution.
+ *   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
+ *   which can be found in the file epl-v10.html at the root of this distribution.
  *   By using this software in any fashion, you are agreeing to be bound by
  * 	 the terms of this license.
  *   You must not remove this notice, or any other, from this software.

File: src/jvm/clojure/lang/Atom.java
Patch:
@@ -1,8 +1,8 @@
 /**
  *   Copyright (c) Rich Hickey. All rights reserved.
  *   The use and distribution terms for this software are covered by the
- *   Common Public License 1.0 (http://opensource.org/licenses/cpl.php)
- *   which can be found in the file CPL.TXT at the root of this distribution.
+ *   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
+ *   which can be found in the file epl-v10.html at the root of this distribution.
  *   By using this software in any fashion, you are agreeing to be bound by
  * 	 the terms of this license.
  *   You must not remove this notice, or any other, from this software.

File: src/jvm/clojure/lang/IMeta.java
Patch:
@@ -1,8 +1,8 @@
 /**
  *   Copyright (c) Rich Hickey. All rights reserved.
  *   The use and distribution terms for this software are covered by the
- *   Common Public License 1.0 (http://opensource.org/licenses/cpl.php)
- *   which can be found in the file CPL.TXT at the root of this distribution.
+ *   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
+ *   which can be found in the file epl-v10.html at the root of this distribution.
  *   By using this software in any fashion, you are agreeing to be bound by
  * 	 the terms of this license.
  *   You must not remove this notice, or any other, from this software.

File: src/jvm/clojure/lang/IReference.java
Patch:
@@ -1,8 +1,8 @@
 /**
  *   Copyright (c) Rich Hickey. All rights reserved.
  *   The use and distribution terms for this software are covered by the
- *   Common Public License 1.0 (http://opensource.org/licenses/cpl.php)
- *   which can be found in the file CPL.TXT at the root of this distribution.
+ *   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
+ *   which can be found in the file epl-v10.html at the root of this distribution.
  *   By using this software in any fashion, you are agreeing to be bound by
  * 	 the terms of this license.
  *   You must not remove this notice, or any other, from this software.

File: src/jvm/clojure/lang/Settable.java
Patch:
@@ -1,8 +1,8 @@
 /**
  *   Copyright (c) Rich Hickey. All rights reserved.
  *   The use and distribution terms for this software are covered by the
- *   Common Public License 1.0 (http://opensource.org/licenses/cpl.php)
- *   which can be found in the file CPL.TXT at the root of this distribution.
+ *   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
+ *   which can be found in the file epl-v10.html at the root of this distribution.
  *   By using this software in any fashion, you are agreeing to be bound by
  * 	 the terms of this license.
  *   You must not remove this notice, or any other, from this software.

File: src/jvm/clojure/lang/Box.java
Patch:
@@ -14,7 +14,7 @@
 
 public class Box{
 
-public volatile Object val;
+public Object val;
 
 public Box(Object val){
 	this.val = val;

File: src/jvm/clojure/lang/Namespace.java
Patch:
@@ -15,7 +15,7 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicReference;
 
-public class Namespace{
+public class Namespace extends AReference{
 final public Symbol name;
 final AtomicReference<IPersistentMap> mappings = new AtomicReference<IPersistentMap>();
 final AtomicReference<IPersistentMap> aliases = new AtomicReference<IPersistentMap>();

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -825,7 +825,7 @@ else if(sym.name.equals("floats"))
 				else if(sym.name.equals("doubles"))
 					c = double[].class;
 				else if(sym.name.equals("chars"))
-					c = double[].class;
+					c = char[].class;
 				else if(sym.name.equals("shorts"))
 					c = short[].class;
 				else if(sym.name.equals("bytes"))

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -235,7 +235,7 @@ public static List<String> processCommandLine(String[] args){
 static public final Object[] EMPTY_ARRAY = new Object[]{};
 static public final Comparator DEFAULT_COMPARATOR = new Comparator(){
 	public int compare(Object o1, Object o2){
-		return ((Comparable) o1).compareTo(o2);
+		return Util.compare(o1,o2);
 	}
 };
 

File: src/jvm/clojure/lang/LazilyPersistentVector.java
Patch:
@@ -35,7 +35,7 @@ static public IPersistentVector create(Collection coll){
 }
 
 public Object[] toArray(){
-	return array;
+	return array.clone();
 }
 
 public Object nth(int i){

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -782,7 +782,7 @@ else if(coll instanceof IPersistentVector)
 	else if(coll instanceof String)
 		return Character.valueOf(((String) coll).charAt(n));
 	else if(coll.getClass().isArray())
-		return Array.get(coll, n);
+		return Reflector.prepRet(Array.get(coll, n));
 	else if(coll instanceof List)
 		return ((List) coll).get(n);
 	else if(coll instanceof Matcher)
@@ -834,7 +834,7 @@ else if(coll instanceof String)
 	else if(coll.getClass().isArray())
 		{
 		if(n < Array.getLength(coll))
-			return Array.get(coll, n);
+			return Reflector.prepRet(Array.get(coll, n));
 		return notFound;
 		}
 	else if(coll instanceof List)
@@ -1780,7 +1780,7 @@ static public Object[] aclone(Object[] xs){
 }
 
 static public Object aget(Object xs, int i){
-	return Array.get(xs, i);
+	return Reflector.prepRet(Array.get(xs, i));
 }
 
 static public Object aset(Object xs, int i, Object v){

File: src/jvm/clojure/lang/APersistentVector.java
Patch:
@@ -299,10 +299,10 @@ public boolean removeAll(Collection c){
 public boolean containsAll(Collection c){
 	for(Object o : c)
 		{
-		if(contains(o))
-			return true;
+		if(!contains(o))
+			return false;
 		}
-	return false;
+	return true;
 }
 
 public Object[] toArray(Object[] a){

File: src/jvm/clojure/lang/ASeq.java
Patch:
@@ -131,10 +131,10 @@ public boolean removeAll(Collection c){
 public boolean containsAll(Collection c){
 	for(Object o : c)
 		{
-		if(contains(o))
-			return true;
+		if(!contains(o))
+			return false;
 		}
-	return false;
+	return true;
 }
 
 public Object[] toArray(Object[] a){

File: src/jvm/clojure/lang/Var.java
Patch:
@@ -126,7 +126,7 @@ final public Object get(){
 		return b.val;
 	if(hasRoot())
 		return root;
-	throw new IllegalStateException(String.format("Var %s is unbound.", sym));
+	throw new IllegalStateException(String.format("Var %s/%s is unbound.", ns, sym));
 }
 
 public void setValidator(IFn vf){

File: src/jvm/clojure/lang/Namespace.java
Patch:
@@ -23,7 +23,7 @@ public class Namespace{
 final static ConcurrentHashMap<Symbol, Namespace> namespaces = new ConcurrentHashMap<Symbol, Namespace>();
 
 public String toString(){
-	return "#<Namespace: " + name + ">";
+	return name.toString();
 }
 
 Namespace(Symbol name){

File: src/jvm/clojure/lang/ArraySeq.java
Patch:
@@ -81,7 +81,7 @@ public ISeq rest(){
 
 public int count(){
 	if(oa != null)
-		return oa.length;
+		return oa.length - i;
 	return Array.getLength(array) - i;
 }
 

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -31,6 +31,7 @@
 import java.util.List;
 import java.util.ArrayList;
 import java.util.LinkedList;
+import java.util.Arrays;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Modifier;
 
@@ -2017,7 +2018,8 @@ static int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, I
 					matchIdx = i;
 					tied = false;
 					}
-				else if(!subsumes(paramlists.get(matchIdx), paramlists.get(i)))
+				else if(!(subsumes(paramlists.get(matchIdx), paramlists.get(i))
+				          || Arrays.equals(paramlists.get(matchIdx), paramlists.get(i))))
 					tied = true;
 				}
 			}

File: src/jvm/clojure/lang/APersistentSet.java
Patch:
@@ -59,7 +59,7 @@ public boolean equals(Object obj){
 
 	for(Object aM : m)
 		{
-		if(!m.contains(aM))
+		if(!contains(aM))
 			return false;
 		}
 //	for(ISeq s = seq(); s != null; s = s.rest())

File: src/jvm/clojure/lang/TransactionalHashMap.java
Patch:
@@ -124,7 +124,7 @@ public Set<Entry<K, V>> entrySet(){
 		{
 		IPersistentMap map = mapAt(i);
 		if(map.count() > 0)
-			entries.addAll((Collection) map);
+			entries.addAll((Collection) RT.seq(map));
 		}
 	return new AbstractSet<Entry<K, V>>(){
 		public Iterator iterator(){

File: src/jvm/clojure/lang/Var.java
Patch:
@@ -72,7 +72,7 @@ public static Var intern(Namespace ns, Symbol sym, Object root, boolean replaceR
 
 public String toString(){
 	if(ns != null)
-		return "#'" + ns.name + "/" + sym;
+		return "#=(var " + ns.name + "/" + sym + ")";
 	return "#<Var: " + (sym != null ? sym.toString() : "--unnamed--") + ">";
 }
 

File: src/jvm/clojure/lang/LispReader.java
Patch:
@@ -684,7 +684,7 @@ else if(form instanceof Keyword
 		else
 			ret = RT.list(Compiler.QUOTE, form);
 
-		if(form instanceof IObj && ((IObj) form).meta() != null)
+		if(form instanceof IObj && !(form instanceof Var) && ((IObj) form).meta() != null)
 			{
 			//filter line numbers
 			IPersistentMap newMeta = ((IObj) form).meta().without(RT.LINE_KEY);

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -713,6 +713,8 @@ else if(coll instanceof Sequential)
 static public Object nth(Object coll, int n, Object notFound){
 	if(coll == null)
 		return notFound;
+	else if(n < 0)
+		return notFound;
 	else if(coll instanceof IPersistentVector)
 		{
 		IPersistentVector v = (IPersistentVector) coll;

File: src/jvm/clojure/lang/LazyCons.java
Patch:
@@ -26,8 +26,8 @@ public LazyCons(IFn f){
 
 LazyCons(IPersistentMap meta, Object first, ISeq rest){
 	super(meta);
-	this._first = sentinel;
-	this._rest = sentinel;
+	this._first = first;
+	this._rest = rest;
 }
 
 final

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -4022,9 +4022,9 @@ static Var lookupVar(Symbol sym, boolean internNew) throws Exception{
 			var = ns.findInternedVar(name);
 		}
 	else if(sym.equals(NS))
-		return RT.NS_VAR;
+		var =  RT.NS_VAR;
 	else if(sym.equals(IN_NS))
-		return RT.IN_NS_VAR;
+		var = RT.IN_NS_VAR;
 	else
 		{
 		//is it mapped?

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -4100,7 +4100,7 @@ public static Object loadFile(String file) throws Exception{
 	FileInputStream f = new FileInputStream(file);
 	try
 		{
-		return load(new InputStreamReader(f), new File(file).getAbsolutePath(), (new File(file)).getName());
+		return load(new InputStreamReader(f,RT.UTF8), new File(file).getAbsolutePath(), (new File(file)).getName());
 		}
 	finally
 		{

File: src/jvm/clojure/lang/Repl.java
Patch:
@@ -53,7 +53,7 @@ public static void main(String[] args) throws Exception{
 				}
 
 		//repl IO support
-		LineNumberingPushbackReader rdr = new LineNumberingPushbackReader(new InputStreamReader(System.in));
+		LineNumberingPushbackReader rdr = new LineNumberingPushbackReader(new InputStreamReader(System.in,RT.UTF8));
 		OutputStreamWriter w = (OutputStreamWriter) RT.OUT.get();//new OutputStreamWriter(System.out);
 		Object EOF = new Object();
 

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -3912,6 +3912,8 @@ private static Expr analyzeSymbol(Symbol sym) throws Exception{
 	if(o instanceof Var)
 		{
 		Var v = (Var) o;
+		if(isMacro(v) != null)
+			throw new Exception("Can't take value of a macro: " + v);
 		registerVar(v);
 		return new VarExpr(v, tag);
 		}

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -1732,7 +1732,9 @@ public Expr parse(C context, Object frm) throws Exception{
 						try
 							{
 							Var.pushThreadBindings(dynamicBindings);
-							LocalBinding lb = registerLocal(sym, null, null);
+							LocalBinding lb = registerLocal(sym,
+							                                (Symbol) (RT.second(f) instanceof Symbol ? RT.second(f)
+							                                          : null), null);
 							Expr handler = (new BodyExpr.Parser()).parse(context, RT.rest(RT.rest(RT.rest(f))));
 							catches = catches.cons(new CatchClause(c, lb, handler));
 							}

File: src/jvm/clojure/lang/MultiFn.java
Patch:
@@ -112,8 +112,7 @@ private IFn findAndCacheBestMethod(Object dispatchVal) throws Exception{
 			}
 		}
 	if(bestEntry == null)
-		throw new IllegalArgumentException(String.format("No method for dispatch value: %s", dispatchVal));
-
+		return null;
 	//ensure basis has stayed stable throughout, else redo
 	if(cachedHierarchy == hierarchy.get())
 		{

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -2050,7 +2050,7 @@ public Expr parse(C context, Object frm) throws Exception{
 				throw new IllegalArgumentException("Unable to resolve classname: " + RT.second(form));
 			PersistentVector args = PersistentVector.EMPTY;
 			for(ISeq s = RT.rest(RT.rest(form)); s != null; s = s.rest())
-				args = args.cons(analyze(C.EXPRESSION, s.first()));
+				args = args.cons(analyze(context == C.EVAL ? context : C.EXPRESSION, s.first()));
 			return new NewExpr(c, args, line);
 		}
 	}

File: src/jvm/clojure/lang/APersistentMap.java
Patch:
@@ -205,7 +205,7 @@ public Object[] toArray(Object[] a){
 			{
 			a[i] = s.first();
 			}
-		if(a.length >= count())
+		if(a.length > count())
 			a[count()] = null;
 		return a;
 		}

File: src/jvm/clojure/lang/APersistentSet.java
Patch:
@@ -121,7 +121,7 @@ public Object[] toArray(Object[] a){
 			{
 			a[i] = s.first();
 			}
-		if(a.length >= count())
+		if(a.length > count())
 			a[count()] = null;
 		return a;
 		}

File: src/jvm/clojure/lang/APersistentVector.java
Patch:
@@ -287,7 +287,7 @@ public Object[] toArray(Object[] a){
 			{
 			a[i] = s.first();
 			}
-		if(a.length >= count())
+		if(a.length > count())
 			a[count()] = null;
 		return a;
 		}

File: src/jvm/clojure/lang/Numbers.java
Patch:
@@ -1277,7 +1277,7 @@ static public float[] float_array(Object sizeOrSeq){
 			int size = s.count();
 			float[] ret = new float[size];
 			for(int i = 0; i < size && s != null; i++, s = s.rest())
-				ret[i] = ((Number) s.first()).intValue();
+				ret[i] = ((Number) s.first()).floatValue();
 			return ret;
 			}
 	}
@@ -1308,7 +1308,7 @@ static public double[] double_array(Object sizeOrSeq){
 		int size = s.count();
 		double[] ret = new double[size];
 		for(int i = 0; i < size && s != null; i++, s = s.rest())
-			ret[i] = ((Number) s.first()).intValue();
+			ret[i] = ((Number) s.first()).doubleValue();
 		return ret;
 		}
 }
@@ -1370,7 +1370,7 @@ static public long[] long_array(Object sizeOrSeq){
 		int size = s.count();
 		long[] ret = new long[size];
 		for(int i = 0; i < size && s != null; i++, s = s.rest())
-			ret[i] = ((Number) s.first()).intValue();
+			ret[i] = ((Number) s.first()).longValue();
 		return ret;
 		}
 }

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -1716,7 +1716,7 @@ public Expr parse(C context, Object frm) throws Exception{
 									"Bad binding form, expected symbol, got: " + RT.third(f));
 						Symbol sym = (Symbol) RT.third(f);
 						if(sym.getNamespace() != null)
-							throw new Exception("Can't bind qualified name");
+							throw new Exception("Can't bind qualified name:" + sym);
 
 						IPersistentMap dynamicBindings = RT.map(LOCAL_ENV, LOCAL_ENV.get(),
 						                                        NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.get(),
@@ -3141,7 +3141,7 @@ private static FnMethod parse(FnExpr fn, ISeq form) throws Exception{
 					throw new IllegalArgumentException("fn params must be Symbols");
 				Symbol p = (Symbol) parms.nth(i);
 				if(p.getNamespace() != null)
-					throw new Exception("Can't use qualified name as parameter");
+					throw new Exception("Can't use qualified name as parameter: " + p);
 				if(p.equals(_AMP_))
 					{
 					if(state == PSTATE.REQ)
@@ -3428,7 +3428,7 @@ public Expr parse(C context, Object frm) throws Exception{
 								"Bad binding form, expected symbol, got: " + bindings.nth(i));
 					Symbol sym = (Symbol) bindings.nth(i);
 					if(sym.getNamespace() != null)
-						throw new Exception("Can't let qualified name");
+						throw new Exception("Can't let qualified name: " + sym);
 					Expr init = analyze(C.EXPRESSION, bindings.nth(i + 1), sym.name);
 					//sequential enhancement of env (like Lisp let*)
 					LocalBinding lb = registerLocal(sym, tagOf(sym), init);

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -1631,11 +1631,13 @@ public void emit(C context, FnExpr fn, GeneratorAdapter gen){
 			//put in clause local
 			gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), clause.lb.idx);
 			clause.handler.emit(context, fn, gen);
+			if(context != C.STATEMENT)
+				gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), retLocal);
 			gen.mark(clause.endLabel);
 
 			if(finallyExpr != null)
 				finallyExpr.emit(C.STATEMENT, fn, gen);
-			gen.goTo(end);
+			gen.goTo(ret);
 			}
 		gen.mark(endTryCatch);
 		if(finallyExpr != null)

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -216,6 +216,7 @@ static public void addURL(Object url) throws Exception{
 	Symbol namesym = Symbol.create("name");
 	OUT.setTag(Symbol.create("java.io.Writer"));
 	CURRENT_NS.setTag(Symbol.create("clojure.lang.Namespace"));
+	AGENT.setTag(Symbol.create("clojure.lang.Agent"));
 	MATH_CONTEXT.setTag(Symbol.create("java.math.MathContext"));
 	Var v;
 	v = Var.intern(CLOJURE_NS, IN_NAMESPACE, inNamespace);

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -3168,7 +3168,8 @@ public LocalBinding(int num, Symbol sym, Symbol tag, Expr init) throws Exception
 	}
 
 	public boolean hasJavaClass() throws Exception{
-		if(init != null && init.hasJavaClass() && init.getJavaClass().isPrimitive()
+		if(init != null && init.hasJavaClass()
+		   && Util.isPrimitive(init.getJavaClass())
 		   && !(init instanceof MaybePrimitiveExpr))
 			return false;
 		return tag != null

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -3168,6 +3168,9 @@ public LocalBinding(int num, Symbol sym, Symbol tag, Expr init) throws Exception
 	}
 
 	public boolean hasJavaClass() throws Exception{
+		if(init != null && init.hasJavaClass() && init.getJavaClass().isPrimitive()
+		   && !(init instanceof MaybePrimitiveExpr))
+			return false;
 		return tag != null
 		       || (init != null && init.hasJavaClass());
 	}

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -941,7 +941,7 @@ static public void print(Object x, Writer w) throws Exception{
 		}
 	if(x == null)
 		w.write("nil");
-	else if(x instanceof ISeq)
+	else if(x instanceof ISeq || x instanceof IPersistentList)
 		{
 		w.write('(');
 		printInnerSeq(seq(x), w);

File: src/jvm/clojure/lang/APersistentVector.java
Patch:
@@ -137,7 +137,7 @@ public IPersistentVector assoc(Object key, Object val){
 		int i = ((Number) key).intValue();
 		return assocN(i, val);
 		}
-	throw new IllegalAccessError("Key must be integer");
+	throw new IllegalArgumentException("Key must be integer");
 }
 
 public Object valAt(Object key, Object notFound){

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -3361,7 +3361,7 @@ static public Var isMacro(Object op) throws Exception{
 		if(v != null && v.isMacro())
 			{
 			if(v.ns != currentNS() && !v.isPublic())
-				throw new IllegalAccessError("var: " + v + " is not public");
+				throw new IllegalStateException("var: " + v + " is not public");
 			return v;
 			}
 		}
@@ -3545,7 +3545,7 @@ static public Object resolveIn(Namespace n, Symbol sym) throws Exception{
 		if(v == null)
 			throw new Exception("No such var: " + sym);
 		else if(v.ns != currentNS() && !v.isPublic())
-			throw new IllegalAccessError("var: " + sym + " is not public");
+			throw new IllegalStateException("var: " + sym + " is not public");
 		return v;
 		}
 	else if(sym.name.indexOf('.') > 0 || sym.name.charAt(0) == '[')

File: src/jvm/clojure/lang/Namespace.java
Patch:
@@ -118,7 +118,7 @@ public static Namespace findOrCreate(Symbol name){
 
 public static Namespace remove(Symbol name){
 	if(name.equals(RT.CLOJURE_NS.name))
-		throw new IllegalAccessError("Cannot remove clojure namespace");
+		throw new IllegalArgumentException("Cannot remove clojure namespace");
 	return namespaces.remove(name);
 }
 

File: src/jvm/clojure/lang/PersistentVector.java
Patch:
@@ -172,7 +172,7 @@ private Object[] pushTail(int level, Object[] arr, Object[] tailNode, Box expans
 
 public PersistentVector pop(){
 	if(cnt == 0)
-		throw new IllegalAccessError("Can't pop empty vector");
+		throw new IllegalStateException("Can't pop empty vector");
 	if(cnt == 1)
 		return EMPTY.withMeta(meta());
 	if(tail.length > 1)

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -368,7 +368,7 @@ else if(coll instanceof Iterator)
 	else if(coll instanceof Enumeration)
 		return EnumerationSeq.create(((Enumeration) coll));
 	else
-		throw new IllegalAccessError("Don't know how to create ISeq from: " + coll.getClass().getSimpleName());
+		throw new IllegalArgumentException("Don't know how to create ISeq from: " + coll.getClass().getSimpleName());
 }
 
 static public ISeq keys(Object coll){

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -368,7 +368,7 @@ else if(coll instanceof Iterator)
 	else if(coll instanceof Enumeration)
 		return EnumerationSeq.create(((Enumeration) coll));
 	else
-		throw new IllegalAccessError("Don't know how to create ISeq from arg");
+		throw new IllegalAccessError("Don't know how to create ISeq from: " + coll.getClass().getSimpleName());
 }
 
 static public ISeq keys(Object coll){
@@ -398,7 +398,7 @@ else if(o instanceof Map)
 		return ((Map) o).size();
 	else if(o.getClass().isArray())
 		return Array.getLength(o);
-	throw new UnsupportedOperationException("count not supported on this type");
+	throw new UnsupportedOperationException("count not supported on this type: " + o.getClass().getSimpleName());
 }
 
 static public IPersistentCollection conj(IPersistentCollection coll, Object x){
@@ -586,7 +586,7 @@ else if(coll instanceof Sequential)
 		return null;
 		}
 	else
-		throw new UnsupportedOperationException("nth not supported on this type");
+		throw new UnsupportedOperationException("nth not supported on this type: " + coll.getClass().getSimpleName());
 }
 
 static public Object assocN(int n, Object val, Object coll){

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -799,7 +799,7 @@ public Object eval() throws Exception{
 
 	public void emit(C context, FnExpr fn, GeneratorAdapter gen){
 		gen.visitLineNumber(line, gen.mark());
-		if(targetClass != null)
+		if(targetClass != null && field != null)
 			{
 			if(context != C.STATEMENT)
 				{

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -2951,12 +2951,13 @@ public void emit(FnExpr fn, ClassVisitor cv){
 	}
 
 	void emitClearLocals(GeneratorAdapter gen){
-		for(int i = 0; i < numParams(); i++)
+		for(int i = 1; i < numParams()+1; i++)
 			{
 			if(!localsUsedInCatchFinally.contains(i))
 				{
 				gen.visitInsn(Opcodes.ACONST_NULL);
-				gen.storeArg(i);
+				gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), i);
+//				gen.storeArg(i);
 				}
 			}
 		for(int i = numParams() + 1; i < maxLocal + 1; i++)

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -265,7 +265,7 @@ public static void loadResourceScript(String name) throws Exception{
 	InputStream ins = RT.class.getResourceAsStream("/" + name);
 	if(ins != null)
 		{
-		Compiler.load(new InputStreamReader(ins), name, name);
+		Compiler.load(new InputStreamReader(ins), RT.class.getResource("/"+name).toString(), name);
 		ins.close();
 		}
 }

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -1787,7 +1787,7 @@ static class NewExpr implements Expr{
 	final Class c;
 	final static Method invokeConstructorMethod =
 			Method.getMethod("Object invokeConstructor(Class,Object[])");
-	final static Method forNameMethod = Method.getMethod("Class forName(String)");
+	final static Method forNameMethod = Method.getMethod("Class classForName(String)");
 
 
 	public NewExpr(Class c, IPersistentVector args, int line) throws Exception{

File: src/jvm/clojure/lang/AFn.java
Patch:
@@ -13,8 +13,9 @@
 package clojure.lang;
 
 import java.util.Comparator;
+import java.io.Serializable;
 
-public abstract class AFn extends Obj implements IFn, Comparator{
+public abstract class AFn extends Obj implements IFn, Comparator, Serializable{
 
 public AFn(IPersistentMap meta){
 	super(meta);

File: src/jvm/clojure/lang/PersistentArrayMap.java
Patch:
@@ -28,7 +28,7 @@ public class PersistentArrayMap extends APersistentMap{
 final Object[] array;
 static final int HASHTABLE_THRESHOLD = 8;
 
-public static PersistentArrayMap EMPTY = new PersistentArrayMap();
+public static final PersistentArrayMap EMPTY = new PersistentArrayMap();
 
 protected PersistentArrayMap(){
 	this.array = new Object[]{};

File: src/jvm/clojure/lang/PersistentStructMap.java
Patch:
@@ -14,10 +14,11 @@
 
 import java.util.Iterator;
 import java.util.Map;
+import java.io.Serializable;
 
 public class PersistentStructMap extends APersistentMap{
 
-public static class Def{
+public static class Def implements Serializable{
 	final ISeq keys;
 	final IPersistentMap keyslots;
 

File: src/jvm/clojure/lang/Var.java
Patch:
@@ -72,9 +72,7 @@ public static Var intern(Namespace ns, Symbol sym, Object root, boolean replaceR
 public String toString(){
 	if(ns != null)
 		return "#'" + ns.name + "/" + sym;
-	return "#<Var: " + (ns != null ? (ns.name + "/") : "") +
-	       (sym != null ? sym.toString() : "--unnamed--") +
-	       ">";
+	return "#<Var: " + (sym != null ? sym.toString() : "--unnamed--") + ">";
 }
 
 public static Var find(Symbol nsQualifiedSym){

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -441,7 +441,7 @@ else if(coll instanceof Map)
 	else if(key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
 		{
 		int n = ((Number) key).intValue();
-		if(n < count(coll))
+		if(n >= 0 && n < count(coll))
 			return nth(coll, n);
 		return null;
 		}

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -441,7 +441,9 @@ else if(coll instanceof Map)
 	else if(key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
 		{
 		int n = ((Number) key).intValue();
-		return nth(coll, n);
+		if(n < count(coll))
+			return nth(coll, n);
+		return null;
 		}
 
 	return null;

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -192,7 +192,7 @@ public static List<String> processCommandLine(String[] args){
 	Keyword dockw = Keyword.intern(null, "doc");
 	Keyword arglistskw = Keyword.intern(null, "arglists");
 	Symbol namesym = Symbol.create("name");
-	OUT.setTag(Symbol.create("java.io.OutputStreamWriter"));
+	OUT.setTag(Symbol.create("java.io.Writer"));
 	CURRENT_NS.setTag(Symbol.create("clojure.lang.Namespace"));
 	Var v;
 	v = Var.intern(CLOJURE_NS, IN_NAMESPACE, inNamespace);

File: src/jvm/clojure/lang/APersistentVector.java
Patch:
@@ -272,14 +272,14 @@ public PersistentVector.Seq withMeta(IPersistentMap meta){
 	public Object reduce(IFn f) throws Exception{
 		Object ret = v.nth(i);
 		for(int x = i + 1; x < v.count(); x++)
-			ret = f.invoke(ret, x);
+			ret = f.invoke(ret, v.nth(x));
 		return ret;
 	}
 
 	public Object reduce(IFn f, Object start) throws Exception{
 		Object ret = f.invoke(start, v.nth(i));
 		for(int x = i + 1; x < v.count(); x++)
-			ret = f.invoke(ret, x);
+			ret = f.invoke(ret, v.nth(x));
 		return ret;
 	}
 }

File: src/jvm/clojure/lang/ArraySeq.java
Patch:
@@ -71,14 +71,14 @@ public ArraySeq withMeta(IPersistentMap meta){
 public Object reduce(IFn f) throws Exception{
 	Object ret = array[i];
 	for(int x = i+1;x < array.length;x++)
-		ret = f.invoke(ret, x);
+		ret = f.invoke(ret, array[x]);
 	return ret;
 }
 
 public Object reduce(IFn f, Object start) throws Exception{
 	Object ret = f.invoke(start,array[i]);
 	for(int x = i+1;x < array.length;x++)
-		ret = f.invoke(ret, x);
+		ret = f.invoke(ret, array[x]);
 	return ret;
 }
 }

File: src/jvm/clojure/lang/Numbers.java
Patch:
@@ -190,7 +190,7 @@ public Object add(Object x, Object y){
 	}
 };
 
-/*
+//*
 static Ops ops(Object x, Object y){
    Class xc = x.getClass();
    Class yc = y.getClass();

File: src/jvm/clojure/lang/Numbers.java
Patch:
@@ -69,9 +69,9 @@ else if(c == float[].class)
 }
 
 public static double[] add(double[] x, double y){
-	double[] ret = x.clone();
+	double[] ret = new double[x.length];//x.clone();
 	for(int i = 0; i < ret.length; i++)
-		ret[i] += y;
+		ret[i] = x[i] + y;
 	return ret;
 }
 
@@ -83,7 +83,7 @@ public static float[] add(float[] x, float y){
 }
 
 public static Ratio add(Ratio x, int y){
-	 return null;
+	return null;
 }
 
 public static Double add(double x, double y){

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -176,8 +176,8 @@ public class Compiler implements Opcodes{
 static public Var LINE = Var.create(0);
 
 //Integer
-static public Var LINE_BEFORE = Var.create();
-static public Var LINE_AFTER = Var.create();
+static public Var LINE_BEFORE = Var.create(0);
+static public Var LINE_AFTER = Var.create(0);
 
 //Integer
 static public Var NEXT_LOCAL_NUM = Var.create(0);

File: src/jvm/clojure/lang/IFn.java
Patch:
@@ -14,7 +14,7 @@
 
 import java.util.concurrent.Callable;
 
-public interface IFn extends Callable{
+public interface IFn extends Callable, Runnable{
 
 public Object invoke() throws Exception;
 

File: src/jvm/clojure/lang/ASeq.java
Patch:
@@ -124,7 +124,7 @@ public Object[] toArray(Object[] a){
 			{
 			a[i] = s.first();
 			}
-		if(a.length >= count())
+		if(a.length > count())
 			a[count()] = null;
 		return a;
 		}

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -2406,13 +2406,13 @@ static Expr parse(C context, ISeq form, String name) throws Exception{
 		//fn.thisName = name;
 		String basename = enclosingMethod != null ?
 		                  (enclosingMethod.fn.name + "$")
-		                  : (munge(currentNS().name.name) + ".");
+		                  : "clojure.fns." + (munge(currentNS().name.name) + ".");
 		if(RT.second(form) instanceof Symbol)
 			name = ((Symbol) RT.second(form)).name;
 		fn.simpleName = ((name != null ?
 		                    munge(name) : "fn")
 		                    + "__" + RT.nextID());
-		fn.name = "cljfn." + basename + fn.simpleName;
+		fn.name = basename + fn.simpleName;
 		fn.internalName = fn.name.replace('.', '/');
 		fn.fntype = Type.getObjectType(fn.internalName);
 		try

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -245,6 +245,9 @@ static public void init() throws Exception{
 		ins = RT.class.getResourceAsStream("/xml.clj");
 		Compiler.load(new InputStreamReader(ins));
 		ins.close();
+		ins = RT.class.getResourceAsStream("/set.clj");
+		Compiler.load(new InputStreamReader(ins));
+		ins.close();
 		}
 	finally
 		{

File: src/jvm/clojure/lang/DynamicClassLoader.java
Patch:
@@ -21,7 +21,8 @@ public class DynamicClassLoader extends ClassLoader{
 HashMap<String, byte[]> map = new HashMap<String, byte[]>();
 
 public DynamicClassLoader(){
-	super(Compiler.class.getClassLoader());
+	super(Thread.currentThread().getContextClassLoader());
+	//super(Compiler.class.getClassLoader());
 }
 
 public DynamicClassLoader(ClassLoader parent){

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -465,8 +465,8 @@ else if(key instanceof Number && (coll instanceof String || coll.getClass().isAr
 		int n = ((Number) key).intValue();
 		return n >= 0 && n < count(coll);
 		}
-
-	throw new UnsupportedOperationException("contains not supported on this type");
+	return F;
+	//throw new UnsupportedOperationException("contains not supported on this type");
 }
 
 static public Object find(Object coll, Object key){

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -690,6 +690,8 @@ else if(RT.third(form) instanceof ISeq && RT.first(RT.third(form)) instanceof Sy
 	}
 
 	private static Class maybeClass(Object form, boolean stringOk) throws Exception{
+		if(form instanceof Class)
+			return (Class) form;
 		Class c = null;
 		if(form instanceof Symbol)
 			{

File: src/jvm/clojure/lang/APersistentVector.java
Patch:
@@ -323,8 +323,10 @@ public Object nth(int i){
 	}
 
 	public IPersistentVector assocN(int i, Object val){
-		if(start + i >= end)
+		if(start + i > end)
 			throw new IndexOutOfBoundsException();
+		else if(start + i == end)
+			return cons(val);
 		return new SubVector(_meta, v.assocN(start + i, val), start, end);
 	}
 

File: src/jvm/clojure/lang/Namespace.java
Patch:
@@ -83,7 +83,7 @@ Object reference(Symbol sym, Object val){
 	throw new IllegalStateException(sym + " already refers to: " + o + " in namespace: " + name);
 }
 
-public void unintern(Symbol sym) throws Exception{
+public void unmap(Symbol sym) throws Exception{
 	if(sym.ns != null)
 		{
 		throw new IllegalArgumentException("Can't unintern namespace-qualified symbol");

File: src/jvm/clojure/lang/ProxyHandler.java
Patch:
@@ -48,7 +48,7 @@ else if(rt == Float.TYPE)
 			return ((Number) ret).floatValue();
 		else if(rt == Double.TYPE)
 			return ((Number) ret).doubleValue();
-		else if(rt == Boolean.TYPE)
+		else if(rt == Boolean.TYPE && !(ret instanceof Boolean))
 			return ret == null ? Boolean.FALSE : Boolean.TRUE;
 		else if(rt == Byte.TYPE)
 			return (byte) ((Number) ret).intValue();

File: src/jvm/clojure/lang/BigNum.java
Patch:
@@ -20,7 +20,7 @@ public class BigNum extends IntegerNum{
 public boolean equals(Object arg0){
 	return arg0 != null
 	       && arg0 instanceof BigNum
-	       && ((BigNum) arg0).val == val;
+	       && ((BigNum) arg0).val.equals(val);
 }
 
 public int hashCode(){

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -163,7 +163,7 @@ public Object invoke(Object arg1, Object arg2)
 static AtomicInteger id = new AtomicInteger(1);
 
 static{
-OUT.setTag(Symbol.create("java.io.PrintStream"));
+OUT.setTag(Symbol.create("java.io.OutputStreamWriter"));
 }
 //static
 //	{

File: src/jvm/clojure/lang/Reflector.java
Patch:
@@ -346,7 +346,7 @@ else if(paramType.isPrimitive())
 
 static Object prepRet(Object x){
 	if(x instanceof Boolean)
-		return ((Boolean) x).booleanValue() ? RT.T : null;
+		return ((Boolean) x).booleanValue() ? x : null;
 	return x;
 }
 }

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -91,6 +91,7 @@ public class RT{
 Symbol.create("Appendable"), "java.lang.Appendable",
 Symbol.create("CharSequence"), "java.lang.CharSequence",
 Symbol.create("Cloneable"), "java.lang.Cloneable",
+Symbol.create("Comparable"), "java.lang.Comparable",
 Symbol.create("Iterable"), "java.lang.Iterable",
 Symbol.create("Readable"), "java.lang.Readable",
 Symbol.create("Runnable"), "java.lang.Runnable",

File: src/jvm/clojure/lang/PersistentVector.java
Patch:
@@ -324,7 +324,7 @@ public PersistentVector pop(){
 		{
 		return (PersistentVector) EMPTY.withMeta(meta());
 		}
-	if(newroot.length == 1)
+	if(shift > 0 && newroot.length == 1)
 		{
 		newroot = (Object[]) newroot[0];
 		newshift -= 5;

File: src/jvm/clojure/lang/PersistentVector.java
Patch:
@@ -140,7 +140,7 @@ public boolean equals(Object obj){
 			if(ms == null || !RT.equal(nth(i), ms.first()))
 				return false;
 			}
-		if(ms.rest() != null)
+		if(ms != null)
 			return false;
 		}
 

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -383,7 +383,7 @@ else if(coll instanceof Sequential)
 		return null;
 		}
 	else
-		return null;
+		throw new UnsupportedOperationException("nth not supported on this type");
 }
 
 static public Object assocN(int n, Object val, Object coll){

File: src/jvm/clojure/lang/RT.java
Patch:
@@ -232,8 +232,8 @@ else if(coll instanceof Iterable)
 		return IteratorSeq.create(((Iterable) coll).iterator());
 	else if(coll instanceof Object[])
 		return ArraySeq.create((Object[]) coll);
-	else if(coll instanceof Object[])
-		return ArraySeq.create((Object[]) coll);
+	else if(coll instanceof String)
+		return StringSeq.create((String) coll);
 	else
 		throw new IllegalAccessError("Don't know how to create ISeq from arg");
 }

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -2461,7 +2461,7 @@ public void emit(C context, FnExpr fn, GeneratorAdapter gen){
 		else
 			body.emit(context, fn, gen);
 		Label end = gen.mark();
-		gen.visitLocalVariable("this", "Ljava/lang/Object;", null, loopLabel, end, 0);
+//		gen.visitLocalVariable("this", "Ljava/lang/Object;", null, loopLabel, end, 0);
 		for(ISeq bis = bindingInits.seq(); bis != null; bis = bis.rest())
 			{
 			BindingInit bi = (BindingInit) bis.first();

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -2229,7 +2229,8 @@ public Expr parse(C context, Object frms) throws Exception{
 			PersistentVector exprs = PersistentVector.EMPTY;
 			for(; forms != null; forms = forms.rest())
 				{
-				Expr e = (context == C.STATEMENT || forms.rest() != null) ?
+				Expr e = (context != C.EVAL &&
+				         (context == C.STATEMENT || forms.rest() != null)) ?
 				         analyze(C.STATEMENT, forms.first())
 				         :
 				         analyze(context, forms.first());

File: src/jvm/clojure/lang/Compiler.java
Patch:
@@ -684,6 +684,8 @@ public StaticMethodExpr(int line, String className, String methodName, IPersiste
 		this.line = line;
 
 		List methods = Reflector.getMethods(Class.forName(className), args.count(), methodName, true);
+		if(methods.isEmpty())
+			throw new IllegalArgumentException("No matching method found");
 		method = (java.lang.reflect.Method) ((methods.size() == 1) ? methods.get(0) : null);
 	}
 

File: src/jvm/clojure/lang/Reflector.java
Patch:
@@ -201,6 +201,8 @@ static public List getMethods(Class c, int arity, String name, boolean getStatic
 
 
 static Object boxArg(Class paramType, Object arg){
+	if(arg == null && !paramType.isPrimitive())
+		return arg;
 	Class argType = arg.getClass();
 	if(primBoxTypeMatch(paramType, argType))
 		return arg;

File: src/jvm/clojure/lang/ASeq.java
Patch:
@@ -32,7 +32,7 @@ public boolean equals(Object obj){
 		if(ms == null || !RT.equal(s.first(), ms.first()))
 			return false;
 		}
-	if(ms.rest() != null)
+	if(ms != null)
 		return false;
 
 	return true;

File: src/jvm/clojure/lang/DynamicVar.java
Patch:
@@ -60,7 +60,9 @@ public static DynamicVar intern(Symbol sym, Object root, boolean replaceRoot){
 		{
 		DynamicVar dvin = new DynamicVar(sym, root);
 		dvout = table.putIfAbsent(sym, dvin);
-		present = dvout != dvin;   //might have snuck in
+		present = dvout != null;   //might have snuck in
+		if(!present)
+			dvout = dvin;
 		}
 	if(present && (!dvout.hasRoot() || replaceRoot))
 		dvout.bindRoot(root);

File: src/jvm/clojure/lang/Module.java
Patch:
@@ -47,7 +47,7 @@ public TRef findRef(String name) throws Exception{
 }
 
 public static TRef intern(String moduleName, String name) throws Exception{
-	Module module = findModule(name);
+	Module module = findModule(moduleName);
 	if(module == null)
 		throw new Exception(String.format("Module %s not found", moduleName));
 	return module.intern(name);

File: src/jvm/clojure/lang/Delay.java
Patch:
@@ -13,12 +13,13 @@
 package clojure.lang;
 
 public class Delay{
-volatile Object val;
+public volatile Object val;
 IFn fn;
 
 
 public Delay(IFn fn){
 	this.fn = fn;
+	this.val = this;
 }
 
 public Object force() throws Exception{

File: src/jvm/clojure/lang/APersistentMap.java
Patch:
@@ -37,7 +37,7 @@ public boolean equals(Object obj) {
         return false;
     IPersistentMap m = (IPersistentMap)obj;
 
-    if(m.count() != count())
+    if(m.count() != count() || m.hashCode() != hashCode())
         return false;
 
     for(ISeq s = seq();s!=null;s = s.rest())

File: src/jvm/clojure/lang/AnArray.java
Patch:
@@ -43,11 +43,11 @@ public IMapEntry find(Object key) {
     return null;
 }
 
-public IPersistentMap assoc(Object key, Object val) {
+public Associative assoc(Object key, Object val) {
     if(key instanceof Number)
         {
         int i = ((Number)key).intValue();
-        return (IPersistentMap) assocN(i,val);
+        return (Associative) assocN(i,val);
         }
     throw new IllegalAccessError("Key must be integer");
 }

File: src/jvm/clojure/lang/Associative.java
Patch:
@@ -14,7 +14,7 @@ public interface Associative {
 
 IMapEntry find(Object key);
 
-IPersistentMap assoc(Object key, Object val);
+Associative assoc(Object key, Object val);
 
 Object get(Object key);
 }

File: src/jvm/clojure/lang/IPersistentMap.java
Patch:
@@ -14,6 +14,7 @@
 public interface IPersistentMap extends Iterable, IPersistentCollection, Associative {
 
 
+IPersistentMap assoc(Object key, Object val);
 IPersistentMap assocEx(Object key, Object val) throws Exception;
 
 IPersistentMap without(Object key);

File: src/jvm/clojure/lang/PersistentArray.java
Patch:
@@ -335,7 +335,7 @@ private void trim(){
         {
         Master nextMaster = data.master.next;
         int diff = 0;
-        for(int i=0;diff+i<length();i++)
+        for(int i=0;i<length()/2;i++)
             {
             Entry e = getEntry(i);
             if(e != null && e.rev != nextMaster.basis[i])

File: src/org/clojure/runtime/PersistentHashtableMap.java
Patch:
@@ -141,7 +141,7 @@ IPersistentMap grow(){
     return create(_count,newArray);
 }
 
-public Iterator<IMapEntry> iterator() {
+public Iterator iterator() {
     return new Iter(array);
 }
 

File: src/org/clojure/runtime/PersistentListIdentityMap.java
Patch:
@@ -13,7 +13,7 @@
 import java.util.Iterator;
 
 /**
- * Immplementation of persistent map on a linked list
+ * Implementation of persistent map on a linked list
  * Uses identity (==) comparison, vs equals() of PersistentListMap
 
  * Note that instances of this class are constant values

File: src/org/clojure/runtime/PersistentListMap.java
Patch:
@@ -15,7 +15,7 @@
 import java.util.Iterator;
 
 /**
- * Immplementation of persistent map on a linked list
+ * Implementation of persistent map on a linked list
 
  * Note that instances of this class are constant values
  * i.e. add/remove etc return new values

File: src/org/clojure/runtime/PersistentHybridMap.java
Patch:
@@ -86,15 +86,15 @@ public PersistentArrayMap createArrayMap(Object[] init) {
     return new PersistentArrayMap(init);
 }
 
-private IPersistentMap createArrayMap() {
+IPersistentMap createArrayMap() {
     return new PersistentArrayMap();
 }
 
-private IPersistentMap createHashtableMap(Object[] init) {
+IPersistentMap createHashtableMap(Object[] init) {
     return new PersistentHashtableMap(init);
 }
 
-private IPersistentMap createHashtableMap(int initialCapacity) {
+IPersistentMap createHashtableMap(int initialCapacity) {
     return new PersistentHashtableMap(initialCapacity);
 }
 

File: src/org/clojure/runtime/PersistentListMap.java
Patch:
@@ -21,7 +21,7 @@
  * i.e. add/remove etc return new values
  *
  * Lookups/changes are linear, so only appropriate for _very_small_ maps
- * ArrayMap is generally faster, but this class avoids the double allocation,
+ * PersistentArrayMap is generally faster, but this class avoids the double allocation,
  * and so is better/faster as a bucket for hash tables
  *
  * null keys and values are ok, but you won't be able to distinguish a null value via get - use contains/find

