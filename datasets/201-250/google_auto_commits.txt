File: value/src/main/java/com/google/auto/value/processor/BuilderMethodClassifier.java
Patch:
@@ -402,8 +402,8 @@ private void classifyMethodOneArg(ExecutableElement method) {
                       + " is not appropriate", autoWhat());
         }
         // We allow the return type to be a supertype (other than Object), to support step builders.
-        TypeMirror parameterType =
-            Iterables.getOnlyElement(methodSignature.parameterTypes()).getType();
+        AnnotatedTypeMirror parameterType =
+            Iterables.getOnlyElement(methodSignature.parameterTypes());
         propertyNameToSetters.put(
             propertyName, new PropertySetter(method, parameterType, function.get()));
       } else {

File: value/src/main/java/com/google/auto/value/processor/AutoBuilderProcessor.java
Patch:
@@ -324,7 +324,7 @@ private Property newProperty(
     return new Property(
         name,
         identifier,
-        TypeEncoder.encode(type),
+        TypeEncoder.encodeWithAnnotations(type),
         new AnnotatedTypeMirror(type),
         nullableAnnotation,
         nullables,

File: value/src/main/java/com/google/auto/value/processor/ForwardingClassGenerator.java
Patch:
@@ -51,15 +51,15 @@
  * generate a class file, say {@code Forwarder}, that is basically what you would get if you could
  * compile this:
  *
- * <pre>
+ * <pre>{@code
  * final class Forwarder {
  *   private Forwarder() {}
  *
  *   static ConstructMe of(int a, String b, long c) {
  *     return new ConstructMe(a, b, c);
  *   }
  * }
- * </pre>
+ * }</pre>
  *
  * <p>Because the class file is assembled directly, rather than being produced by the Java compiler,
  * it <i>can</i> call the synthetic constructor. Then regular Java source code can do {@code

File: value/src/main/java/com/google/auto/value/processor/BuilderMethodClassifier.java
Patch:
@@ -493,7 +493,6 @@ && originalPropertyType(propertyElement).getKind().isPrimitive()) {
             "[%sUnnecessaryBoxing] %s is primitive but parameter of setter method is not",
             autoWhat(),
             propertyString(propertyElement));
-        return Optional.empty();
       }
       return Optional.of(Copier.IDENTITY);
     }

File: value/src/test/java/com/google/auto/value/processor/AutoValueCompilationTest.java
Patch:
@@ -4031,6 +4031,7 @@ public void autoValueBuilderNullableSetterPrimitiveGetter() {
         javac()
             .withProcessors(new AutoValueProcessor(), new AutoValueBuilderProcessor())
             .compile(javaFileObject);
+    assertThat(compilation).succeeded();
     assertThat(compilation)
         .hadWarningContaining(
             "property method foo.bar.Baz.blam() is primitive but parameter of setter method is not")

File: common/src/main/java/com/google/auto/common/MoreElements.java
Patch:
@@ -301,7 +301,7 @@ public static Optional<AnnotationMirror> getAnnotationMirror(
    * <p>Here is an example how one could get a List of static methods of a class:
    * <pre>{@code
    * FluentIterable.from(ElementFilter.methodsIn(clazzElement.getEnclosedElements()))
-   *     .filter(MoreElements.hasModifiers(Modifier.STATIC).toList();
+   *     .filter(MoreElements.hasModifiers(Modifier.STATIC)).toList();
    * }</pre>
    */
   public static <T extends Element> Predicate<T> hasModifiers(Modifier... modifiers) {
@@ -317,7 +317,7 @@ public static <T extends Element> Predicate<T> hasModifiers(Modifier... modifier
    * <pre>{@code
    * Set<Modifier> modifiers = ...;
    * FluentIterable.from(ElementFilter.methodsIn(clazzElement.getEnclosedElements()))
-   *     .filter(MoreElements.hasModifiers(modifiers).toList();}
+   *     .filter(MoreElements.hasModifiers(modifiers)).toList();}
    * </pre>
    */
   public static <T extends Element> Predicate<T> hasModifiers(final Set<Modifier> modifiers) {

File: value/src/main/java/com/google/auto/value/extension/toprettystring/processor/ToPrettyStringExtension.java
Patch:
@@ -506,6 +506,7 @@ static class KindVisitor extends SimpleTypeVisitor8<PrettyPrintableKind, Void> {
       private final Types types;
 
       KindVisitor(Types types, Elements elements) {
+        super(REGULAR_OBJECT); // default value, covers generic types
         this.types = types;
         this.elements = elements;
       }

File: value/src/main/java/com/google/auto/value/processor/BuilderRequiredProperties.java
Patch:
@@ -18,13 +18,15 @@
 import static com.google.auto.common.MoreStreams.toImmutableList;
 import static com.google.auto.common.MoreStreams.toImmutableMap;
 import static java.lang.Math.min;
+import static java.math.RoundingMode.CEILING;
 import static java.util.stream.Collectors.joining;
 
 import com.google.auto.value.processor.AutoValueishProcessor.Property;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.math.IntMath;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
 
@@ -142,7 +144,7 @@ private BuilderRequiredProperties(
             .collect(toImmutableMap(trackedProperties::get, i -> i));
 
     this.bitmaskFields =
-        IntStream.range(0, (trackedCount + 31) / 32)
+        IntStream.range(0, IntMath.divide(trackedCount, 32, CEILING))
             .mapToObj(
                 i -> {
                   int bitBase = i * 32;

File: value/src/main/java/com/google/auto/value/processor/Executable.java
Patch:
@@ -91,8 +91,8 @@ boolean isOptional(String parameterName) {
     return optionalParameters.contains(parameterName);
   }
 
-  int optionalParameterCount() {
-    return optionalParameters.size();
+  boolean hasOptionalParameters() {
+    return !optionalParameters.isEmpty();
   }
 
   ImmutableList<TypeParameterElement> typeParameters() {

File: common/src/test/java/com/google/auto/common/MoreTypesTest.java
Patch:
@@ -204,7 +204,7 @@ void a() throws RuntimeException {}
     public static void b() throws RuntimeException {}
   }
 
-  @SuppressWarnings("unused")
+  @SuppressWarnings({"unused", "UnusedTypeParameter"})
   private static final class ExecutableElementsGroupE {
     <T> ExecutableElementsGroupE() {}
 
@@ -213,7 +213,7 @@ <T> void a() {}
     public static <T> void b() {}
   }
 
-  @SuppressWarnings("unused")
+  @SuppressWarnings({"unused", "UnusedTypeParameter"})
   private static final class Container<T> {
     private final class Contained {}
   }

File: common/src/test/java/com/google/auto/common/OverridesTest.java
Patch:
@@ -440,6 +440,7 @@ private ExecutableElement getMethod(TypeElement in, String name, TypeKind... par
   // it also inherits it from Collection<E>.
 
   private interface XCollection<E> {
+    @SuppressWarnings("unused")
     boolean add(E e);
   }
 

File: value/src/main/java/com/google/auto/value/extension/memoized/Memoized.java
Patch:
@@ -47,7 +47,7 @@
  * href="https://errorprone.info/bugpattern/DoubleCheckedLocking">double-checked locking</a> to
  * ensure that the annotated method is called at most once.
  *
- * <h3>Example</h3>
+ * <h2>Example</h2>
  *
  * <pre>
  *   {@code @AutoValue}

File: value/src/main/java/com/google/auto/value/extension/toprettystring/ToPrettyString.java
Patch:
@@ -41,7 +41,7 @@
  *
  * <p>{@code @ToPrettyString} is valid on overridden {@code toString()} and other methods alike.
  *
- * <h3>Example</h3>
+ * <h2>Example</h2>
  *
  * <pre>
  *   {@code @AutoValue}

File: value/src/main/java/com/google/auto/value/processor/AutoBuilderProcessor.java
Patch:
@@ -330,7 +330,7 @@ private Property newProperty(
         name,
         identifier,
         TypeEncoder.encode(type),
-        type,
+        new AnnotatedTypeMirror(type),
         nullableAnnotation,
         nullables,
         getterName,
@@ -788,7 +788,7 @@ private static Property annotationBuilderProperty(
         name,
         name,
         TypeEncoder.encode(type),
-        type,
+        new AnnotatedTypeMirror(type),
         /* nullableAnnotation= */ Optional.empty(),
         nullables,
         /* getter= */ "",

File: value/src/main/java/com/google/auto/value/processor/AutoOneOfProcessor.java
Patch:
@@ -99,7 +99,7 @@ void processType(TypeElement autoOneOfType) {
     Set<ExecutableElement> otherMethods = new LinkedHashSet<>(abstractMethods);
     otherMethods.remove(kindGetter);
 
-    ImmutableMap<ExecutableElement, TypeMirror> propertyMethodsAndTypes =
+    ImmutableMap<ExecutableElement, AnnotatedTypeMirror> propertyMethodsAndTypes =
         propertyMethodsIn(otherMethods, autoOneOfType);
     ImmutableBiMap<String, ExecutableElement> properties =
         propertyNameToMethodMap(propertyMethodsAndTypes.keySet());
@@ -257,7 +257,7 @@ && objectMethodToOverride(method) == ObjectMethod.NONE) {
   private void defineVarsForType(
       TypeElement type,
       AutoOneOfTemplateVars vars,
-      ImmutableMap<ExecutableElement, TypeMirror> propertyMethodsAndTypes,
+      ImmutableMap<ExecutableElement, AnnotatedTypeMirror> propertyMethodsAndTypes,
       ExecutableElement kindGetter,
       Nullables nullables) {
     vars.props =

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -215,7 +215,7 @@ void processType(TypeElement type) {
       builderAbstractMethods = ImmutableSet.of();
     }
 
-    ImmutableMap<ExecutableElement, TypeMirror> propertyMethodsAndTypes =
+    ImmutableMap<ExecutableElement, AnnotatedTypeMirror> propertyMethodsAndTypes =
         propertyMethodsIn(immutableSetDifference(abstractMethods, toBuilderMethods), type);
     ImmutableMap<String, ExecutableElement> properties =
         propertyNameToMethodMap(propertyMethodsAndTypes.keySet());
@@ -486,7 +486,7 @@ private void defineVarsForType(
       TypeElement type,
       AutoValueTemplateVars vars,
       ImmutableSet<ExecutableElement> toBuilderMethods,
-      ImmutableMap<ExecutableElement, TypeMirror> propertyMethodsAndTypes,
+      ImmutableMap<ExecutableElement, AnnotatedTypeMirror> propertyMethodsAndTypes,
       Optional<BuilderSpec.Builder> maybeBuilder,
       Nullables nullables,
       ImmutableSet<ExecutableElement> consumedBuilderAbstractMethods) {

File: value/src/main/java/com/google/auto/value/processor/BuilderMethodClassifierForAutoValue.java
Patch:
@@ -40,7 +40,7 @@ private BuilderMethodClassifierForAutoValue(
       TypeMirror builtType,
       TypeElement builderType,
       ImmutableBiMap<ExecutableElement, String> getterToPropertyName,
-      ImmutableMap<String, TypeMirror> rewrittenPropertyTypes,
+      ImmutableMap<String, AnnotatedTypeMirror> rewrittenPropertyTypes,
       Nullables nullables) {
     super(
         errorReporter,
@@ -81,7 +81,7 @@ static Optional<BuilderMethodClassifier<ExecutableElement>> classify(
       TypeElement autoValueClass,
       TypeElement builderType,
       ImmutableBiMap<ExecutableElement, String> getterToPropertyName,
-      ImmutableMap<String, TypeMirror> rewrittenPropertyTypes,
+      ImmutableMap<String, AnnotatedTypeMirror> rewrittenPropertyTypes,
       Nullables nullables,
       boolean autoValueHasToBuilder) {
     BuilderMethodClassifier<ExecutableElement> classifier =

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -285,13 +285,14 @@ void defineVarsForAutoValue(
       Iterable<ExecutableElement> builderMethods =
           Sets.difference(builderAbstractMethods, consumedBuilderAbstractMethods);
       boolean autoValueHasToBuilder = toBuilderMethods != null && !toBuilderMethods.isEmpty();
-      ImmutableMap<ExecutableElement, TypeMirror> getterToPropertyType =
+      ImmutableMap<ExecutableElement, AnnotatedTypeMirror> getterToPropertyType =
           TypeVariables.rewriteReturnTypes(
               processingEnv.getTypeUtils(),
               getterToPropertyName.keySet(),
               autoValueClass,
               builderTypeElement);
-      ImmutableMap.Builder<String, TypeMirror> rewrittenPropertyTypes = ImmutableMap.builder();
+      ImmutableMap.Builder<String, AnnotatedTypeMirror> rewrittenPropertyTypes =
+          ImmutableMap.builder();
       getterToPropertyType.forEach(
           (getter, type) -> rewrittenPropertyTypes.put(getterToPropertyName.get(getter), type));
       Optional<BuilderMethodClassifier<ExecutableElement>> optionalClassifier =

File: value/src/main/java/com/google/auto/value/processor/ExtensionContext.java
Patch:
@@ -39,7 +39,7 @@ class ExtensionContext implements AutoValueExtension.Context {
   private final ProcessingEnvironment processingEnvironment;
   private final TypeElement autoValueClass;
   private final ImmutableMap<String, ExecutableElement> properties;
-  private final ImmutableMap<String, TypeMirror> propertyTypes;
+  private final ImmutableMap<String, AnnotatedTypeMirror> propertyTypes;
   private final ImmutableSet<ExecutableElement> abstractMethods;
   private final ImmutableSet<ExecutableElement> builderAbstractMethods;
   private Optional<BuilderContext> builderContext = Optional.empty();
@@ -49,7 +49,7 @@ class ExtensionContext implements AutoValueExtension.Context {
       ProcessingEnvironment processingEnvironment,
       TypeElement autoValueClass,
       ImmutableMap<String, ExecutableElement> properties,
-      ImmutableMap<ExecutableElement, TypeMirror> propertyMethodsAndTypes,
+      ImmutableMap<ExecutableElement, AnnotatedTypeMirror> propertyMethodsAndTypes,
       ImmutableSet<ExecutableElement> abstractMethods,
       ImmutableSet<ExecutableElement> builderAbstractMethods) {
     this.autoValueProcessor = autoValueProcessor;
@@ -93,7 +93,7 @@ public Map<String, ExecutableElement> properties() {
 
   @Override
   public Map<String, TypeMirror> propertyTypes() {
-    return propertyTypes;
+    return Maps.transformValues(propertyTypes, AnnotatedTypeMirror::getType);
   }
 
   @Override

File: value/src/test/java/com/google/auto/value/processor/BuilderRequiredPropertiesTest.java
Patch:
@@ -341,7 +341,7 @@ private Property fakeProperty(String name, TypeMirror type, boolean hasDefault)
         /* name= */ name,
         /* identifier= */ name,
         /* type= */ type.toString(),
-        /* typeMirror= */ type,
+        /* annotatedType= */ new AnnotatedTypeMirror(type),
         /* nullableAnnotation= */ Optional.empty(),
         /* nullables= */ Nullables.fromMethods(null, ImmutableList.of()),
         /* getter= */ name,

File: value/src/main/java/com/google/auto/value/processor/AutoValueishProcessor.java
Patch:
@@ -965,7 +965,7 @@ && objectMethodToOverride(method) == ObjectMethod.NONE) {
         properties.add(method);
       }
     }
-    return new EclipseHack(processingEnv).methodReturnTypes(properties.build(), declaredType);
+    return new EclipseHack(typeUtils()).methodReturnTypes(properties.build(), declaredType);
   }
 
   /** True if void properties are allowed. */

File: value/src/main/java/com/google/auto/value/processor/BuilderMethodClassifier.java
Patch:
@@ -113,7 +113,7 @@ abstract class BuilderMethodClassifier<E extends Element> {
     this.builderType = builderType;
     this.rewrittenPropertyTypes = rewrittenPropertyTypes;
     this.propertiesWithDefaults = propertiesWithDefaults;
-    this.eclipseHack = new EclipseHack(processingEnv);
+    this.eclipseHack = new EclipseHack(typeUtils);
     this.nullables = nullables;
   }
 

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -287,7 +287,6 @@ void defineVarsForAutoValue(
       boolean autoValueHasToBuilder = toBuilderMethods != null && !toBuilderMethods.isEmpty();
       ImmutableMap<ExecutableElement, TypeMirror> getterToPropertyType =
           TypeVariables.rewriteReturnTypes(
-              processingEnv.getElementUtils(),
               processingEnv.getTypeUtils(),
               getterToPropertyName.keySet(),
               autoValueClass,

File: value/src/main/java/com/google/auto/value/processor/TypeVariables.java
Patch:
@@ -37,7 +37,6 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
 import javax.lang.model.type.WildcardType;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor8;
 import javax.lang.model.util.Types;
 
@@ -80,7 +79,6 @@ private TypeVariables() {}
    *     example.
    */
   static ImmutableMap<ExecutableElement, TypeMirror> rewriteReturnTypes(
-      Elements elementUtils,
       Types typeUtils,
       Collection<ExecutableElement> methods,
       TypeElement sourceType,
@@ -95,7 +93,7 @@ static ImmutableMap<ExecutableElement, TypeMirror> rewriteReturnTypes(
     // What we're doing is only valid if the type parameters are "the same". The check here even
     // requires the names to be the same. The logic would still work without that, but we impose
     // that requirement elsewhere and it means we can check in this simple way.
-    EclipseHack eclipseHack = new EclipseHack(elementUtils, typeUtils);
+    EclipseHack eclipseHack = new EclipseHack(typeUtils);
     TypeMirror[] targetTypeParameterMirrors = new TypeMirror[targetTypeParameters.size()];
     for (int i = 0; i < targetTypeParameters.size(); i++) {
       targetTypeParameterMirrors[i] = targetTypeParameters.get(i).asType();

File: value/src/it/functional/src/test/java/com/google/auto/value/AutoBuilderTest.java
Patch:
@@ -28,7 +28,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.truth.Truth8;
+import com.google.common.truth.Truth;
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -659,9 +659,9 @@ static <T> PairBuilder<T> pairBuilder() {
   @Test
   public void genericGetters() {
     PairBuilder<Number> builder = pairBuilder();
-    Truth8.assertThat(builder.getSecond()).isEmpty();
+    Truth.assertThat(builder.getSecond()).isEmpty();
     builder.setSecond(2);
-    Truth8.assertThat(builder.getSecond()).hasValue(2);
+    Truth.assertThat(builder.getSecond()).hasValue(2);
     try {
       builder.getFirst();
       fail();

File: value/src/it/functional/src/test/java/com/google/auto/value/AutoBuilderTest.java
Patch:
@@ -28,6 +28,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.truth.Truth8;
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -658,9 +659,9 @@ static <T> PairBuilder<T> pairBuilder() {
   @Test
   public void genericGetters() {
     PairBuilder<Number> builder = pairBuilder();
-    assertThat(builder.getSecond()).isEmpty();
+    Truth8.assertThat(builder.getSecond()).isEmpty();
     builder.setSecond(2);
-    assertThat(builder.getSecond()).hasValue(2);
+    Truth8.assertThat(builder.getSecond()).hasValue(2);
     try {
       builder.getFirst();
       fail();

File: value/src/main/java/com/google/auto/value/processor/ForwardingClassGenerator.java
Patch:
@@ -31,7 +31,7 @@
 import static org.objectweb.asm.Opcodes.INVOKESPECIAL;
 import static org.objectweb.asm.Opcodes.LLOAD;
 import static org.objectweb.asm.Opcodes.NEW;
-import static org.objectweb.asm.Opcodes.V1_7;
+import static org.objectweb.asm.Opcodes.V1_8;
 
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableList;
@@ -90,7 +90,7 @@ static byte[] makeConstructorForwarder(
 
     ClassWriter classWriter = new ClassWriter(COMPUTE_MAXS);
     classWriter.visit(
-        V1_7,
+        V1_8,
         ACC_FINAL | ACC_SUPER,
         internalName(forwardingClassName),
         null,

File: value/src/test/java/com/google/auto/value/processor/AutoAnnotationCompilationTest.java
Patch:
@@ -243,7 +243,7 @@ public void testGwtSimple() {
             "package com.example.factories;",
             "",
             "import com.example.annotations.MyAnnotation;",
-            "import java.io.Serializable",
+            "import java.io.Serializable;",
             "import java.util.Arrays;",
             GeneratedImport.importGeneratedAnnotationType(),
             "",
@@ -376,7 +376,7 @@ public void testCollectionsForArrays() {
             "    if (enums == null) {",
             "      throw new NullPointerException(\"Null enums\");",
             "    }",
-            "    this.enums = enums.toArray(new MyEnum[0];",
+            "    this.enums = enums.toArray(new MyEnum[0]);",
             "  }",
             "",
             "  @Override public Class<? extends MyAnnotation> annotationType() {",
@@ -414,7 +414,7 @@ public void testCollectionsForArrays() {
             "          && Arrays.equals(enums,",
             "          (that instanceof AutoAnnotation_AnnotationFactory_newMyAnnotation)",
             "              ? ((AutoAnnotation_AnnotationFactory_newMyAnnotation) that).enums",
-            "              : that.enums())",
+            "              : that.enums());",
             "    }",
             "    return false;",
             "  }",

File: value/src/main/java/com/google/auto/value/processor/AutoValueishProcessor.java
Patch:
@@ -224,7 +224,7 @@ private static String builderInitializer(
      *
      * <ul>
      *   <li>the property is not primitive;
-     *   <li>the property is not already nullable;
+     *   <li>the property type does not already have a {@code @Nullable} annotation;
      *   <li>there is no explicit initializer (for example {@code Optional} properties start off as
      *       {@code Optional.empty()});
      *   <li>we have found a {@code @Nullable} type annotation that can be applied.

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -287,6 +287,7 @@ void processType(TypeElement type) {
     int subclassDepth = writeExtensions(type, context, applicableExtensions);
     String subclass = generatedSubclassName(type, subclassDepth);
     vars.subclass = TypeSimplifier.simpleNameOf(subclass);
+    vars.finalSubclass = finalSubclass;
     vars.isFinal = (subclassDepth == 0);
     vars.modifiers = vars.isFinal ? "final " : "abstract ";
     vars.builderClassModifiers =

File: value/src/test/java/com/google/auto/value/processor/AutoValueCompilationTest.java
Patch:
@@ -1271,7 +1271,7 @@ public void correctBuilder() {
             "  }",
             "",
             "  @Override public Baz.Builder<T> toBuilder() {",
-            "    return new Builder<T>(this);",
+            "    return new AutoValue_Baz.Builder<T>(this);",
             "  }",
             "",
             "  static final class Builder<T extends Number> extends Baz.Builder<T> {",
@@ -1621,7 +1621,7 @@ public void builderWithNullableTypeAnnotation() {
             "  }",
             "",
             "  @Override public Baz.Builder<T> toBuilder() {",
-            "    return new Builder<T>(this);",
+            "    return new AutoValue_Baz.Builder<T>(this);",
             "  }",
             "",
             "  static final class Builder<T extends Number> extends Baz.Builder<T> {",

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -222,6 +222,7 @@ void processType(TypeElement type) {
 
     ExtensionContext context =
         new ExtensionContext(
+            this,
             processingEnv,
             type,
             properties,
@@ -245,6 +246,7 @@ void processType(TypeElement type) {
       properties = propertyNameToMethodMap(propertyMethodsAndTypes.keySet());
       context =
           new ExtensionContext(
+              this,
               processingEnv,
               type,
               properties,
@@ -494,7 +496,7 @@ private void defineVarsForType(
     ImmutableListMultimap<ExecutableElement, AnnotationMirror> annotatedPropertyFields =
         propertyFieldAnnotationMap(type, propertyMethods);
     ImmutableListMultimap<ExecutableElement, AnnotationMirror> annotatedPropertyMethods =
-        propertyMethodAnnotationMap(type, propertyMethods, typeUtils());
+        propertyMethodAnnotationMap(type, propertyMethods);
     vars.props =
         propertySet(
             propertyMethodsAndTypes,

File: value/src/test/java/com/google/auto/value/processor/AutoValueCompilationTest.java
Patch:
@@ -1163,6 +1163,7 @@ public void correctBuilder() {
             "final class AutoValue_Baz<T extends Number> extends Baz<T> {",
             "  private final int anInt;",
             "  private final byte[] aByteArray;",
+            "  @Nullable",
             "  private final int[] aNullableIntArray;",
             "  private final List<T> aList;",
             "  private final ImmutableMap<T, String> anImmutableMap;",

File: common/src/main/java/com/google/auto/common/AnnotationMirrors.java
Patch:
@@ -159,7 +159,7 @@ public static Map.Entry<ExecutableElement, AnnotationValue> getAnnotationElement
    * Returns all {@linkplain AnnotationMirror annotations} that are present on the given {@link
    * Element} which are themselves annotated with {@code annotationClass}.
    */
-  public static ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(
+  public static ImmutableSet<AnnotationMirror> getAnnotatedAnnotations(
       Element element, Class<? extends Annotation> annotationClass) {
     String name = annotationClass.getCanonicalName();
     if (name == null) {
@@ -172,7 +172,7 @@ public static ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(
    * Returns all {@linkplain AnnotationMirror annotations} that are present on the given {@link
    * Element} which are themselves annotated with {@code annotation}.
    */
-  public static ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(
+  public static ImmutableSet<AnnotationMirror> getAnnotatedAnnotations(
       Element element, TypeElement annotation) {
     return element.getAnnotationMirrors().stream()
         .filter(input -> isAnnotationPresent(input.getAnnotationType().asElement(), annotation))
@@ -184,7 +184,7 @@ public static ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(
    * Element} which are themselves annotated with an annotation whose type's canonical name is
    * {@code annotationName}.
    */
-  public static ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(
+  public static ImmutableSet<AnnotationMirror> getAnnotatedAnnotations(
       Element element, String annotationName) {
     return element.getAnnotationMirrors().stream()
         .filter(input -> isAnnotationPresent(input.getAnnotationType().asElement(), annotationName))

File: value/src/main/java/com/google/auto/value/processor/AutoBuilderProcessor.java
Patch:
@@ -754,7 +754,7 @@ private void buildAnnotation(
     text = TypeEncoder.decode(text, processingEnv, vars.pkg, /* baseType= */ javaLangVoid);
     text = Reformatter.fixup(text);
     writeSourceFile(autoAnnotationClassName, text, autoBuilderType);
-    addDeferredType(autoBuilderType);
+    addDeferredType(autoBuilderType, autoAnnotationClassName);
   }
 
   private ImmutableSet<Property> annotationBuilderPropertySet(TypeElement annotationType) {

File: value/src/main/java/com/google/auto/value/processor/MissingTypes.java
Patch:
@@ -54,7 +54,7 @@ static class MissingTypeException extends RuntimeException {
       // Although it is not specified as such, in practice ErrorType.toString() is the type name
       // that appeared in the source code. Showing it here can help in debugging issues with
       // deferral.
-      super(missingType == null ? null : missingType.toString());
+      super(missingType == null ? "" : missingType.toString());
     }
   }
 

File: value/src/test/java/com/google/auto/value/processor/AutoValueCompilationTest.java
Patch:
@@ -972,6 +972,8 @@ public void missingPropertyType() {
         .hadErrorContaining("MissingType")
         .inFile(javaFileObject)
         .onLineContaining("MissingType");
+    assertThat(compilation)
+        .hadErrorContaining("references undefined types including MissingType");
   }
 
   @Test

File: value/src/it/functional/src/test/java/com/google/auto/value/AutoBuilderTest.java
Patch:
@@ -502,7 +502,7 @@ public void propertyBuilder() {
   }
 
   static <T> String concatList(ImmutableList<T> list) {
-    // We're avoiding streams for now so we compile this in Java 7 mode in CompileWithEclipseTest.
+    // We're avoiding streams for now since we compile this in Java 7 mode in CompileWithEclipseTest
     StringBuilder sb = new StringBuilder();
     for (T element : list) {
       sb.append(element);

File: value/src/main/java/com/google/auto/value/processor/PropertyBuilderClassifier.java
Patch:
@@ -275,9 +275,9 @@ Optional<PropertyBuilder> makePropertyBuilder(ExecutableElement method, String p
 
     // We've determined that `BarBuilder` has a method `build()` or `buildOrThrow(). But it must
     // return `Bar`. And if the type of `bar()` is Bar<String> then `BarBuilder.build()` must return
-    // Bar<String>.
+    // something that can be assigned to Bar<String>.
     TypeMirror buildType = eclipseHack.methodReturnType(build, barBuilderDeclaredType);
-    if (!MoreTypes.equivalence().equivalent(barTypeMirror, buildType)) {
+    if (!typeUtils.isAssignable(buildType, barTypeMirror)) {
       errorReporter.reportError(
           method,
           "[AutoValueBuilderWrongType] Property builder for %s has type %s whose %s() method"

File: value/src/main/java/com/google/auto/value/processor/AutoBuilderProcessor.java
Patch:
@@ -188,6 +188,7 @@ private void processType(TypeElement autoBuilderType, TypeElement ofClass, Strin
     TypeMirror builtType = executable.builtType();
     ImmutableMap<String, String> propertyInitializers =
         propertyInitializers(autoBuilderType, executable);
+    Nullables nullables = Nullables.fromMethods(processingEnv, methods);
     Optional<BuilderMethodClassifier<VariableElement>> maybeClassifier =
         BuilderMethodClassifierForAutoBuilder.classify(
             methods,
@@ -196,7 +197,8 @@ private void processType(TypeElement autoBuilderType, TypeElement ofClass, Strin
             executable,
             builtType,
             autoBuilderType,
-            propertyInitializers.keySet());
+            propertyInitializers.keySet(),
+            nullables);
     if (!maybeClassifier.isPresent() || errorReporter().errorCount() > 0) {
       // We've already output one or more error messages.
       return;
@@ -205,7 +207,6 @@ private void processType(TypeElement autoBuilderType, TypeElement ofClass, Strin
     ImmutableMap<String, String> propertyToGetterName =
         propertyToGetterName(executable, autoBuilderType);
     AutoBuilderTemplateVars vars = new AutoBuilderTemplateVars();
-    Nullables nullables = Nullables.fromMethods(processingEnv, methods);
     vars.props =
         propertySet(
             executable,

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -450,7 +450,7 @@ private void defineVarsForType(
         builder -> {
           ImmutableBiMap<ExecutableElement, String> methodToPropertyName =
               propertyNameToMethodMap(propertyMethods).inverse();
-          builder.defineVarsForAutoValue(vars, methodToPropertyName);
+          builder.defineVarsForAutoValue(vars, methodToPropertyName, nullables);
           vars.builderName = "Builder";
           vars.builderAnnotations = copiedClassAnnotations(builder.builderType());
         });

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -270,7 +270,8 @@ ImmutableSet<ExecutableElement> toBuilderMethods(
 
     void defineVarsForAutoValue(
         AutoValueOrBuilderTemplateVars vars,
-        ImmutableBiMap<ExecutableElement, String> getterToPropertyName) {
+        ImmutableBiMap<ExecutableElement, String> getterToPropertyName,
+        Nullables nullables) {
       Iterable<ExecutableElement> builderMethods =
           abstractMethods(builderTypeElement, processingEnv);
       boolean autoValueHasToBuilder = toBuilderMethods != null && !toBuilderMethods.isEmpty();
@@ -293,6 +294,7 @@ void defineVarsForAutoValue(
               builderTypeElement,
               getterToPropertyName,
               rewrittenPropertyTypes.build(),
+              nullables,
               autoValueHasToBuilder);
       if (!optionalClassifier.isPresent()) {
         return;

File: value/src/test/java/com/google/auto/value/processor/BuilderRequiredPropertiesTest.java
Patch:
@@ -343,6 +343,7 @@ private Property fakeProperty(String name, TypeMirror type, boolean hasDefault)
         /* type= */ type.toString(),
         /* typeMirror= */ type,
         /* nullableAnnotation= */ Optional.empty(),
+        /* nullables= */ Nullables.fromMethods(null, ImmutableList.of()),
         /* getter= */ name,
         /* maybeBuilderInitializer= */ Optional.empty(),
         /* hasDefault= */ hasDefault);

File: value/src/test/java/com/google/auto/value/processor/NullablesTest.java
Patch:
@@ -148,7 +148,7 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
 
         expect
             .about(optionals())
-            .that(Nullables.nullableMentionedInMethods(notNullableMethods))
+            .that(Nullables.fromMethods(null, notNullableMethods).nullableTypeAnnotation())
             .isEmpty();
 
         TypeElement nullableElement =
@@ -167,7 +167,8 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
               .withMessage("method %s should have @Nullable", nullableMethod)
               .about(optionals())
               .that(
-                  Nullables.nullableMentionedInMethods(notNullablePlusNullable)
+                  Nullables.fromMethods(null, notNullablePlusNullable)
+                      .nullableTypeAnnotation()
                       .map(AnnotationMirror::getAnnotationType))
               .hasValue(nullableType);
         }

File: value/src/main/java/com/google/auto/value/extension/memoized/Memoized.java
Patch:
@@ -37,7 +37,7 @@
  * </ul>
  *
  * <p>If you want to memoize {@link #hashCode()} or {@link #toString()}, you can redeclare them,
- * keeping them {@code abstract}, and annotate them with {@code @Memoize}.
+ * keeping them {@code abstract}, and annotate them with {@code @Memoized}.
  *
  * <p>If a {@code @Memoized} method is annotated with an annotation whose simple name is {@code
  * Nullable}, then {@code null} values will also be memoized. Otherwise, if the method returns

File: value/src/it/functional/src/main/java/PackagelessNestedValueType.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.Map;
 
 /** @author emcmanus@google.com (Éamonn McManus) */
+@SuppressWarnings("DefaultPackage")
 public class PackagelessNestedValueType {
   @AutoValue
   public abstract static class Nested {

File: value/src/it/functional/src/main/java/PackagelessValueType.java
Patch:
@@ -23,6 +23,7 @@
  *
  * @author emcmanus@google.com (Éamonn McManus)
  */
+@SuppressWarnings("DefaultPackage")
 @AutoValue
 public abstract class PackagelessValueType {
   // The getters here are formatted as an illustration of what getters typically look in real

File: value/src/main/java/com/google/auto/value/processor/BuilderRequiredProperties.java
Patch:
@@ -198,7 +198,7 @@ public String markAsSet(Property p) {
     }
     BitmaskField field = bitmaskFields.get(index / 32);
     // This use-case is why Java reduces int shift amounts mod 32. :-)
-    return field.name + " |= " + hex(1 << index) + ";";
+    return field.name + " |= " + cast(field.type, hex(1 << index)) + ";";
   }
 
   /**

File: value/src/test/java/com/google/auto/value/processor/AutoBuilderCompilationTest.java
Patch:
@@ -52,7 +52,7 @@ public final class AutoBuilderCompilationTest {
           "",
           "  @Override public Baz.Builder setAnInt(int anInt) {",
           "    this.anInt = anInt;",
-          "    set$0 |= 0x1;",
+          "    set$0 |= (byte) 0x1;",
           "    return this;",
           "  }",
           "",

File: value/src/test/java/com/google/auto/value/processor/AutoValueCompilationTest.java
Patch:
@@ -1292,7 +1292,7 @@ public void correctBuilder() {
             "    @Override",
             "    public Baz.Builder<T> anInt(int anInt) {",
             "      this.anInt = anInt;",
-            "      set$0 |= 0x1",
+            "      set$0 |= (byte) 0x1",
             "      return this;",
             "    }",
             "",

File: common/src/main/java/com/google/auto/common/Overrides.java
Patch:
@@ -25,6 +25,7 @@
 import java.util.List;
 import java.util.Map;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
@@ -295,8 +296,8 @@ protected TypeMirror defaultAction(TypeMirror e, Void p) {
 
       @Override
       public TypeMirror visitTypeVariable(TypeVariable t, Void p) {
-        Element element = typeUtils.asElement(t);
-        if (element instanceof TypeParameterElement) {
+        Element element = t.asElement();
+        if (element.getKind() == ElementKind.TYPE_PARAMETER) {
           TypeParameterElement e = (TypeParameterElement) element;
           if (typeBindings.containsKey(e)) {
             return visit(typeBindings.get(e));

File: value/src/test/java/com/google/auto/value/processor/BuilderRequiredPropertiesTest.java
Patch:
@@ -84,9 +84,9 @@ private ImmutableList<String> fieldDeclarations(int size) {
   public void initToAllSet() {
     assertThat(initToAllSet(0)).isEmpty();
     assertThat(initToAllSet(1)).containsExactly("set$0 = (byte) 1;");
-    assertThat(initToAllSet(8)).containsExactly("set$0 = (byte) -1;");
+    assertThat(initToAllSet(8)).containsExactly("set$0 = (byte) 0xff;");
     assertThat(initToAllSet(9)).containsExactly("set$0 = (short) 0x1ff;");
-    assertThat(initToAllSet(16)).containsExactly("set$0 = (short) -1;");
+    assertThat(initToAllSet(16)).containsExactly("set$0 = (short) 0xffff;");
     assertThat(initToAllSet(17)).containsExactly("set$0 = 0x1_ffff;");
     assertThat(initToAllSet(31)).containsExactly("set$0 = 0x7fff_ffff;");
     assertThat(initToAllSet(32)).containsExactly("set$0 = -1;");
@@ -95,7 +95,7 @@ public void initToAllSet() {
     assertThat(initToAllSet(64)).containsExactly("set$0 = -1;", "set$1 = -1;");
     assertThat(initToAllSet(144))
         .containsExactly(
-            "set$0 = -1;", "set$1 = -1;", "set$2 = -1;", "set$3 = -1;", "set$4 = (short) -1;");
+            "set$0 = -1;", "set$1 = -1;", "set$2 = -1;", "set$3 = -1;", "set$4 = (short) 0xffff;");
   }
 
   private ImmutableList<String> initToAllSet(int size) {

File: value/src/main/java/com/google/auto/value/processor/AutoValueOrBuilderTemplateVars.java
Patch:
@@ -124,15 +124,14 @@ abstract class AutoValueOrBuilderTemplateVars extends AutoValueishTemplateVars {
 
   /**
    * True if the generated builder should have a second constructor with a parameter of the built
-   * class. The constructor produces a new builder that starts off with the values from the
+   * type. The constructor produces a new builder that starts off with the values from the
    * parameter.
    */
   Boolean toBuilderConstructor;
 
   /**
    * Any {@code toBuilder()} methods, that is methods that return the builder type. AutoBuilder does
-   * not currently support this, but it's included in these shared variables to simplify the
-   * template.
+   * not support this, but it's included in these shared variables to simplify the template.
    */
   ImmutableList<SimpleMethod> toBuilderMethods;
 

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -492,7 +492,7 @@ private static <E> ImmutableSet<E> immutableSetDifference(ImmutableSet<E> a, Imm
     if (Collections.disjoint(a, b)) {
       return a;
     } else {
-      return ImmutableSet.copyOf(difference(a, b));
+      return difference(a, b).immutableCopy();
     }
   }
 }

File: value/src/main/java/com/google/auto/value/processor/AutoValueishProcessor.java
Patch:
@@ -280,8 +280,8 @@ public boolean isNullable() {
     /**
      * Returns the name of the getter method for this property as defined by the {@code @AutoValue}
      * or {@code @AutoBuilder} class. For property {@code foo}, this will be {@code foo} or {@code
-     * getFoo} or {@code isFoo}. For AutoValue, this will also be the name of a getter method in a
-     * builder; in the case of AutoBuilder it will only be that and may be null.
+     * getFoo} or {@code isFoo}. For AutoBuilder, the getter in question is the one that will be
+     * called on the built type to derive the value of the property, in the copy constructor.
      */
     public String getGetter() {
       return getter;

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -390,8 +390,7 @@ public static class PropertyGetter {
       this.optional = optional;
     }
 
-    // Not accessed from templates so doesn't have to be public.
-    String getName() {
+    public String getName() {
       return name;
     }
 

File: value/src/it/functional/src/test/java/com/google/auto/value/AutoBuilderTest.java
Patch:
@@ -484,7 +484,7 @@ public void propertyBuilder() {
     assertThat(builder3.build()).isEqualTo(expected);
 
     ListContainer.Builder builder4 = ListContainer.builder();
-    builder4.listBuilder();
+    ImmutableList.Builder<String> unused = builder4.listBuilder();
     try {
       builder4.setList(ImmutableList.of("one", "two", "three"));
       fail();

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -346,9 +346,11 @@ void defineVars(AutoValueOrBuilderTemplateVars vars, BuilderMethodClassifier<?>
           vars.props.stream()
               .filter(p -> !p.isNullable())
               .filter(p -> p.getBuilderInitializer().isEmpty())
+              .filter(p -> !p.hasDefault())
               .filter(p -> !vars.builderPropertyBuilders.containsKey(p.getName()))
               .collect(toImmutableSet());
-      vars.builderRequiredProperties = new BuilderRequiredProperties(requiredProperties);
+      vars.builderRequiredProperties =
+          BuilderRequiredProperties.of(vars.props, requiredProperties);
     }
   }
 

File: value/src/main/java/com/google/auto/value/processor/ClassNames.java
Patch:
@@ -30,5 +30,5 @@ private ClassNames() {}
   static final String AUTO_VALUE_BUILDER_NAME = AUTO_VALUE_NAME + ".Builder";
   static final String AUTO_BUILDER_NAME = AUTO_VALUE_PACKAGE_NAME + "AutoBuilder";
   static final String COPY_ANNOTATIONS_NAME = AUTO_VALUE_NAME + ".CopyAnnotations";
-  static final String KOTLIN_METADATA_NAME = "kotlin.Metadata";
+  static final String KOTLIN_METADATA_NAME = "kot".concat("lin.Metadata"); // defeat shading
 }

File: value/src/main/java/com/google/auto/value/extension/serializable/processor/SerializableAutoValueExtension.java
Patch:
@@ -114,7 +114,9 @@ private static final class Generator {
               .collect(toImmutableList());
 
       TypeName classTypeName =
-          getClassTypeName(ClassName.get(context.packageName(), className), typeVariableNames);
+          getClassTypeName(
+              ClassName.get(context.packageName(), context.finalAutoValueClassName()),
+              typeVariableNames);
       this.proxyGenerator =
           new ProxyGenerator(
               classTypeName, typeVariableNames, propertyMirrors, buildSerializersMap());

File: value/src/main/java/com/google/auto/value/AutoAnnotation.java
Patch:
@@ -106,6 +106,6 @@
  *
  * @author emcmanus@google.com (Éamonn McManus)
  */
+@Retention(RetentionPolicy.CLASS)
 @Target(ElementType.METHOD)
-@Retention(RetentionPolicy.SOURCE)
 public @interface AutoAnnotation {}

File: value/src/main/java/com/google/auto/value/processor/AutoBuilderProcessor.java
Patch:
@@ -132,7 +132,6 @@ void processType(TypeElement autoBuilderType) {
     vars.builderName = TypeSimplifier.simpleNameOf(generatedClassName);
     vars.builtType = TypeEncoder.encode(builtType);
     vars.build = build(executable);
-    vars.types = typeUtils();
     vars.toBuilderConstructor = false;
     vars.toBuilderMethods = ImmutableList.of();
     defineSharedVarsForType(autoBuilderType, ImmutableSet.of(), vars);

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -243,7 +243,6 @@ void processType(TypeElement type) {
 
     String finalSubclass = TypeSimplifier.simpleNameOf(generatedSubclassName(type, 0));
     AutoValueTemplateVars vars = new AutoValueTemplateVars();
-    vars.types = processingEnv.getTypeUtils();
     vars.identifiers = !processingEnv.getOptions().containsKey(OMIT_IDENTIFIERS_OPTION);
     defineSharedVarsForType(type, methods, vars);
     defineVarsForType(type, vars, toBuilderMethods, propertyMethodsAndTypes, builder);

File: value/src/main/java/com/google/auto/value/processor/AutoValueishProcessor.java
Patch:
@@ -154,7 +154,7 @@ public final SourceVersion getSupportedSourceVersion() {
   }
 
   /**
-   * A property of an {@code @AutoValue} or {@code @AutoOneOf} class, defined by one of its abstract
+   * A property of an {@code @AutoValue} (etc) class, defined by one of its abstract
    * methods. An instance of this class is made available to the Velocity template engine for each
    * property. The public methods of this class define JavaBeans-style properties that are
    * accessible from templates. For example {@link #getType()} means we can write {@code $p.type}
@@ -231,7 +231,7 @@ public String getName() {
       return name;
     }
 
-    public TypeMirror getTypeMirror() {
+    TypeMirror getTypeMirror() {
       return typeMirror;
     }
 

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -342,12 +342,13 @@ void defineVars(AutoValueOrBuilderTemplateVars vars, BuilderMethodClassifier<?>
       vars.builderPropertyBuilders =
           ImmutableMap.copyOf(classifier.propertyNameToPropertyBuilder());
 
-      vars.builderRequiredProperties =
+      ImmutableSet<Property> requiredProperties =
           vars.props.stream()
               .filter(p -> !p.isNullable())
               .filter(p -> p.getBuilderInitializer().isEmpty())
               .filter(p -> !vars.builderPropertyBuilders.containsKey(p.getName()))
               .collect(toImmutableSet());
+      vars.builderRequiredProperties = new BuilderRequiredProperties(requiredProperties);
     }
   }
 

File: value/src/test/java/com/google/auto/value/processor/AutoBuilderCompilationTest.java
Patch:
@@ -724,7 +724,7 @@ public void setterReturnType() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "[AutoBuilderBuilderRet] Setter methods must return foo.bar.Baz.Builder")
+            "[AutoBuilderBuilderRet] Setter methods must return foo.bar.Baz.Builder or a supertype")
         .inFile(javaFileObject)
         .onLineContaining("two(int x)");
   }

File: value/src/main/java/com/google/auto/value/processor/AutoValueOrBuilderTemplateVars.java
Patch:
@@ -109,7 +109,8 @@ abstract class AutoValueOrBuilderTemplateVars extends AutoValueishTemplateVars {
    *
    * <ul>
    *   <li>it is {@code @Nullable} (in which case it defaults to null);
-   *   <li>it is {@code Optional} (in which case it defaults to empty);
+   *   <li>it has a builder initializer (for example it is {@code Optional}, which will have an
+   *       initializer of {@code Optional.empty()});
    *   <li>it has a property-builder method (in which case it defaults to empty).
    * </ul>
    */

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -333,7 +333,7 @@ void defineVars(AutoValueOrBuilderTemplateVars vars, BuilderMethodClassifier<?>
       vars.builderRequiredProperties =
           vars.props.stream()
               .filter(p -> !p.isNullable())
-              .filter(p -> p.getOptional() == null)
+              .filter(p -> p.getBuilderInitializer().isEmpty())
               .filter(p -> !vars.builderPropertyBuilders.containsKey(p.getName()))
               .collect(toImmutableSet());
     }

File: common/src/main/java/com/google/auto/common/Overrides.java
Patch:
@@ -117,7 +117,7 @@ public boolean overrides(
         // can't be overridden.
         return false;
       }
-      if (!(overridden.getEnclosingElement() instanceof TypeElement)) {
+      if (!MoreElements.isType(overridden.getEnclosingElement())) {
         return false;
         // We don't know how this could happen but we avoid blowing up if it does.
       }

File: value/src/main/java/com/google/auto/value/processor/AutoAnnotationProcessor.java
Patch:
@@ -287,7 +287,7 @@ private boolean methodsAreOverloaded(List<ExecutableElement> methods) {
   private String generatedClassName(ExecutableElement method) {
     TypeElement type = MoreElements.asType(method.getEnclosingElement());
     String name = type.getSimpleName().toString();
-    while (type.getEnclosingElement() instanceof TypeElement) {
+    while (MoreElements.isType(type.getEnclosingElement())) {
       type = MoreElements.asType(type.getEnclosingElement());
       name = type.getSimpleName() + "_" + name;
     }

File: value/src/main/java/com/google/auto/value/processor/AutoValueishProcessor.java
Patch:
@@ -484,7 +484,7 @@ static ImmutableList<String> annotationStrings(List<? extends AnnotationMirror>
    */
   static String generatedClassName(TypeElement type, String prefix) {
     String name = type.getSimpleName().toString();
-    while (type.getEnclosingElement() instanceof TypeElement) {
+    while (MoreElements.isType(type.getEnclosingElement())) {
       type = MoreElements.asType(type.getEnclosingElement());
       name = type.getSimpleName() + "_" + name;
     }

File: value/src/main/java/com/google/auto/value/processor/AutoBuilderProcessor.java
Patch:
@@ -143,6 +143,7 @@ void processType(TypeElement autoBuilderType) {
     vars.build = build(executable);
     vars.types = typeUtils();
     vars.toBuilderConstructor = false;
+    vars.toBuilderMethods = ImmutableList.of();
     defineSharedVarsForType(autoBuilderType, ImmutableSet.of(), vars);
     String text = vars.toText();
     text = TypeEncoder.decode(text, processingEnv, vars.pkg, autoBuilderType.asType());

File: factory/src/main/java/com/google/auto/factory/processor/Parameter.java
Patch:
@@ -107,7 +107,7 @@ static ImmutableSet<Parameter> forParameterList(
     Set<String> names = Sets.newHashSetWithExpectedSize(variables.size());
     for (int i = 0; i < variables.size(); i++) {
       Parameter parameter = forVariableElement(variables.get(i), variableTypes.get(i), types);
-      checkArgument(names.add(parameter.name()));
+      checkArgument(names.add(parameter.name()), "Duplicate parameter name: %s", parameter.name());
       builder.add(parameter);
     }
     ImmutableSet<Parameter> parameters = builder.build();

File: service/processor/src/main/java/com/google/auto/service/processor/AutoServiceProcessor.java
Patch:
@@ -17,8 +17,8 @@
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreStreams.toImmutableSet;
 import static com.google.common.base.Throwables.getStackTraceAsString;
-import static com.google.common.collect.ImmutableSet.toImmutableSet;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;

File: value/src/main/java/com/google/auto/value/extension/memoized/processor/MemoizeExtension.java
Patch:
@@ -19,12 +19,12 @@
 import static com.google.auto.common.GeneratedAnnotationSpecs.generatedAnnotationSpec;
 import static com.google.auto.common.MoreElements.getPackage;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreStreams.toImmutableList;
+import static com.google.auto.common.MoreStreams.toImmutableSet;
 import static com.google.auto.value.extension.memoized.processor.ClassNames.MEMOIZED_NAME;
 import static com.google.auto.value.extension.memoized.processor.MemoizedValidator.getAnnotationMirror;
 import static com.google.common.base.Predicates.equalTo;
 import static com.google.common.base.Predicates.not;
-import static com.google.common.collect.ImmutableList.toImmutableList;
-import static com.google.common.collect.ImmutableSet.toImmutableSet;
 import static com.google.common.collect.Iterables.filter;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Sets.union;

File: value/src/main/java/com/google/auto/value/extension/serializable/processor/SerializableAutoValueExtension.java
Patch:
@@ -15,9 +15,9 @@
  */
 package com.google.auto.value.extension.serializable.processor;
 
+import static com.google.auto.common.MoreStreams.toImmutableList;
+import static com.google.auto.common.MoreStreams.toImmutableMap;
 import static com.google.auto.value.extension.serializable.processor.ClassNames.SERIALIZABLE_AUTO_VALUE_NAME;
-import static com.google.common.collect.ImmutableList.toImmutableList;
-import static com.google.common.collect.ImmutableMap.toImmutableMap;
 import static java.util.stream.Collectors.joining;
 
 import com.google.auto.common.GeneratedAnnotationSpecs;

File: value/src/main/java/com/google/auto/value/extension/toprettystring/processor/ExtensionClassTypeSpecBuilder.java
Patch:
@@ -20,9 +20,9 @@
 import static com.google.auto.common.GeneratedAnnotationSpecs.generatedAnnotationSpec;
 import static com.google.auto.common.MoreElements.getPackage;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreStreams.toImmutableList;
+import static com.google.auto.common.MoreStreams.toImmutableSet;
 import static com.google.auto.value.extension.toprettystring.processor.Annotations.getAnnotationMirror;
-import static com.google.common.collect.ImmutableList.toImmutableList;
-import static com.google.common.collect.ImmutableSet.toImmutableSet;
 import static com.google.common.collect.Sets.union;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;

File: value/src/main/java/com/google/auto/value/extension/toprettystring/processor/ToPrettyStringExtension.java
Patch:
@@ -17,9 +17,9 @@
 package com.google.auto.value.extension.toprettystring.processor;
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreStreams.toImmutableList;
 import static com.google.auto.common.MoreTypes.asTypeElement;
 import static com.google.auto.value.extension.toprettystring.processor.ExtensionClassTypeSpecBuilder.extensionClassTypeSpecBuilder;
-import static com.google.auto.value.extension.toprettystring.processor.ToPrettyStringCollectors.toImmutableList;
 import static com.google.auto.value.extension.toprettystring.processor.ToPrettyStringMethods.toPrettyStringMethod;
 import static com.google.auto.value.extension.toprettystring.processor.ToPrettyStringMethods.toPrettyStringMethods;
 import static com.google.common.collect.Iterables.getLast;

File: value/src/main/java/com/google/auto/value/extension/toprettystring/processor/ToPrettyStringMethods.java
Patch:
@@ -17,9 +17,9 @@
 package com.google.auto.value.extension.toprettystring.processor;
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreStreams.toImmutableList;
+import static com.google.auto.common.MoreStreams.toImmutableSet;
 import static com.google.auto.value.extension.toprettystring.processor.Annotations.toPrettyStringAnnotation;
-import static com.google.auto.value.extension.toprettystring.processor.ToPrettyStringCollectors.toImmutableList;
-import static com.google.auto.value.extension.toprettystring.processor.ToPrettyStringCollectors.toImmutableSet;
 import static com.google.common.collect.MoreCollectors.toOptional;
 
 import com.google.auto.value.extension.AutoValueExtension.Context;

File: value/src/main/java/com/google/auto/value/processor/AutoBuilderProcessor.java
Patch:
@@ -17,10 +17,10 @@
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.getPackage;
+import static com.google.auto.common.MoreStreams.toImmutableList;
+import static com.google.auto.common.MoreStreams.toImmutableSet;
 import static com.google.auto.value.processor.AutoValueProcessor.OMIT_IDENTIFIERS_OPTION;
 import static com.google.auto.value.processor.ClassNames.AUTO_BUILDER_NAME;
-import static com.google.common.collect.ImmutableList.toImmutableList;
-import static com.google.common.collect.ImmutableSet.toImmutableSet;
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toCollection;
 import static java.util.stream.Collectors.toMap;

File: value/src/main/java/com/google/auto/value/processor/AutoValueishProcessor.java
Patch:
@@ -19,9 +19,9 @@
 import static com.google.auto.common.GeneratedAnnotations.generatedAnnotation;
 import static com.google.auto.common.MoreElements.getPackage;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreStreams.toImmutableSet;
 import static com.google.auto.value.processor.ClassNames.AUTO_VALUE_PACKAGE_NAME;
 import static com.google.auto.value.processor.ClassNames.COPY_ANNOTATIONS_NAME;
-import static com.google.common.collect.ImmutableSet.toImmutableSet;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Sets.union;
 import static java.util.stream.Collectors.joining;

File: value/src/main/java/com/google/auto/value/processor/BuilderMethodClassifierForAutoBuilder.java
Patch:
@@ -15,8 +15,8 @@
  */
 package com.google.auto.value.processor;
 
-import static com.google.common.collect.ImmutableBiMap.toImmutableBiMap;
-import static com.google.common.collect.ImmutableMap.toImmutableMap;
+import static com.google.auto.common.MoreStreams.toImmutableBiMap;
+import static com.google.auto.common.MoreStreams.toImmutableMap;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;

File: value/src/main/java/com/google/auto/value/processor/TypeVariables.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.google.auto.value.processor;
 
-import static com.google.common.collect.ImmutableMap.toImmutableMap;
+import static com.google.auto.common.MoreStreams.toImmutableMap;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;

File: common/src/main/java/com/google/auto/common/AnnotationValues.java
Patch:
@@ -15,8 +15,8 @@
  */
 package com.google.auto.common;
 
+import static com.google.auto.common.MoreStreams.toImmutableList;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.ImmutableList.toImmutableList;
 
 import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableList;

File: common/src/main/java/com/google/auto/common/SimpleAnnotationMirror.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.auto.common;
 
+import static com.google.auto.common.MoreStreams.toImmutableMap;
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.collect.ImmutableMap.toImmutableMap;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.common.base.Joiner;

File: value/src/main/java/com/google/auto/value/processor/ClassNames.java
Patch:
@@ -30,4 +30,5 @@ private ClassNames() {}
   static final String AUTO_VALUE_BUILDER_NAME = AUTO_VALUE_NAME + ".Builder";
   static final String AUTO_BUILDER_NAME = AUTO_VALUE_PACKAGE_NAME + "AutoBuilder";
   static final String COPY_ANNOTATIONS_NAME = AUTO_VALUE_NAME + ".CopyAnnotations";
+  static final String KOTLIN_METADATA_NAME = "kotlin.Metadata";
 }

File: value/src/main/java/com/google/auto/value/processor/AutoValueishProcessor.java
Patch:
@@ -109,11 +109,13 @@ abstract class AutoValueishProcessor extends AbstractProcessor {
   private String simpleAnnotationName;
 
   private ErrorReporter errorReporter;
+  private Nullables nullables;
 
   @Override
   public synchronized void init(ProcessingEnvironment processingEnv) {
     super.init(processingEnv);
     errorReporter = new ErrorReporter(processingEnv);
+    nullables = new Nullables(processingEnv);
   }
 
   final ErrorReporter errorReporter() {
@@ -461,7 +463,7 @@ final void defineSharedVarsForType(
     vars.toString = methodsToGenerate.containsKey(ObjectMethod.TO_STRING);
     vars.equals = methodsToGenerate.containsKey(ObjectMethod.EQUALS);
     vars.hashCode = methodsToGenerate.containsKey(ObjectMethod.HASH_CODE);
-    Optional<AnnotationMirror> nullable = Nullables.nullableMentionedInMethods(methods);
+    Optional<AnnotationMirror> nullable = nullables.appropriateNullableGivenMethods(methods);
     vars.equalsParameterType = equalsParameterType(methodsToGenerate, nullable);
     vars.serialVersionUID = getSerialVersionUID(type);
   }

File: value/src/test/java/com/google/auto/value/processor/ExtensionTest.java
Patch:
@@ -172,6 +172,7 @@ public void testExtensionConsumesProperties() {
     Compilation compilation =
         javac()
             .withProcessors(new AutoValueProcessor(ImmutableList.of(new FooExtension())))
+            .withOptions("-A" + Nullables.NULLABLE_OPTION + "=")
             .compile(javaFileObject);
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)

File: value/src/test/java/com/google/auto/value/processor/PropertyAnnotationsTest.java
Patch:
@@ -274,6 +274,7 @@ private void assertGeneratedMatches(
 
     assertAbout(javaSource())
         .that(javaFileObject)
+        .withCompilerOptions("-A" + Nullables.NULLABLE_OPTION + "=")
         .processedWith(new AutoValueProcessor())
         .compilesWithoutError()
         .and()
@@ -514,6 +515,7 @@ public void testCopyingMethodAnnotations() {
 
     assertAbout(javaSource())
         .that(inputFile)
+        .withCompilerOptions("-A" + Nullables.NULLABLE_OPTION + "=")
         .processedWith(new AutoValueProcessor())
         .compilesWithoutError()
         .and()
@@ -552,6 +554,7 @@ public void testCopyingMethodAnnotationsToGeneratedFields() {
 
     assertAbout(javaSource())
         .that(inputFile)
+        .withCompilerOptions("-A" + Nullables.NULLABLE_OPTION + "=")
         .processedWith(new AutoValueProcessor())
         .compilesWithoutError()
         .and()

File: service/processor/src/main/java/com/google/auto/service/processor/AutoServiceProcessor.java
Patch:
@@ -188,7 +188,7 @@ private void generateConfigFiles() {
         Set<String> newServices = new HashSet<>(providers.get(providerInterface));
         if (allServices.containsAll(newServices)) {
           log("No new service entries being added.");
-          return;
+          continue;
         }
 
         allServices.addAll(newServices);

File: value/src/main/java/com/google/auto/value/processor/BuilderMethodClassifier.java
Patch:
@@ -374,8 +374,9 @@ private void classifyMethodOneArg(ExecutableElement method) {
       // propertyNameToSetters can't be null when we call put on it below.
       errorReporter.reportError(
           method,
-          "[%sBuilderWhatProp] Method does not correspond to %s",
+          "[%sBuilderWhatProp] Method %s does not correspond to %s",
           autoWhat(),
+          methodName,
           getterMustMatch());
       checkForFailedJavaBean(method);
       return;

File: value/src/test/java/com/google/auto/value/processor/AutoBuilderCompilationTest.java
Patch:
@@ -647,8 +647,8 @@ public void alienOneArgMethod() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "[AutoBuilderBuilderWhatProp] Method does not correspond to a parameter of Baz(int one,"
-                + " int two)")
+            "[AutoBuilderBuilderWhatProp] Method three does not correspond to "
+                + "a parameter of Baz(int one, int two)")
         .inFile(javaFileObject)
         .onLineContaining("three(int x)");
   }

File: value/src/it/functional/src/test/java/com/google/auto/value/CompileWithEclipseTest.java
Patch:
@@ -66,7 +66,8 @@ public static void setSourceRoot() {
   public @Rule TemporaryFolder tmp = new TemporaryFolder();
 
   private static final ImmutableSet<String> IGNORED_TEST_FILES =
-      ImmutableSet.of("AutoValueNotEclipseTest.java", "CompileWithEclipseTest.java");
+      ImmutableSet.of(
+          "AutoValueNotEclipseTest.java", "CompileWithEclipseTest.java", "GradleTest.java");
 
   private static final Predicate<File> JAVA_FILE =
       f -> f.getName().endsWith(".java") && !IGNORED_TEST_FILES.contains(f.getName());

File: value/src/main/java/com/google/auto/value/processor/BuilderMethodClassifierForAutoValue.java
Patch:
@@ -111,7 +111,8 @@ ImmutableBiMap<String, ExecutableElement> propertyElements() {
   }
 
   @Override
-  Optional<String> propertyForBuilderGetter(String methodName) {
+  Optional<String> propertyForBuilderGetter(ExecutableElement method) {
+    String methodName = method.getSimpleName().toString();
     return Optional.ofNullable(getterNameToGetter.get(methodName)).map(getterToPropertyName::get);
   }
 

File: value/src/main/java/com/google/auto/value/processor/AutoBuilderProcessor.java
Patch:
@@ -110,8 +110,8 @@ void processType(TypeElement autoBuilderType) {
     AnnotationMirror autoBuilderAnnotation =
         getAnnotationMirror(autoBuilderType, AUTO_BUILDER_NAME).get();
     TypeElement ofClass = getOfClass(autoBuilderType, autoBuilderAnnotation);
+    checkModifiersIfNested(ofClass, autoBuilderType, "AutoBuilder ofClass");
     String callMethod = findCallMethodValue(autoBuilderAnnotation);
-    checkModifiersIfNested(ofClass); // TODO: error message is wrong
     ImmutableSet<ExecutableElement> methods =
         abstractMethodsIn(
             getLocalAndInheritedMethods(autoBuilderType, typeUtils(), elementUtils()));
@@ -160,7 +160,8 @@ private ExecutableElement findExecutable(
       ImmutableSet<ExecutableElement> methods) {
     List<ExecutableElement> executables =
         findRelevantExecutables(ofClass, callMethod, autoBuilderType);
-    String description = callMethod.isEmpty() ? "constructor" : "static method named " + callMethod;
+    String description =
+        callMethod.isEmpty() ? "constructor" : "static method named \"" + callMethod + "\"";
     switch (executables.size()) {
       case 0:
         throw errorReporter()

File: value/src/main/java/com/google/auto/value/processor/AutoValueishProcessor.java
Patch:
@@ -433,7 +433,7 @@ final ImmutableSet<Property> propertySet(
     return props.build();
   }
 
-  /** Defines the template variables that are shared by AutoValue and AutoOneOf. */
+  /** Defines the template variables that are shared by AutoValue, AutoOneOf, and AutoBuilder. */
   final void defineSharedVarsForType(
       TypeElement type,
       ImmutableSet<ExecutableElement> methods,

File: value/src/main/java/com/google/auto/value/processor/BuilderMethodClassifierForAutoValue.java
Patch:
@@ -35,14 +35,14 @@ class BuilderMethodClassifierForAutoValue extends BuilderMethodClassifier<Execut
   private BuilderMethodClassifierForAutoValue(
       ErrorReporter errorReporter,
       ProcessingEnvironment processingEnv,
-      TypeElement autoValueClass,
+      TypeMirror builtType,
       TypeElement builderType,
       ImmutableBiMap<ExecutableElement, String> getterToPropertyName,
       ImmutableMap<String, TypeMirror> rewrittenPropertyTypes) {
     super(
         errorReporter,
         processingEnv,
-        autoValueClass,
+        builtType,
         builderType,
         rewrittenPropertyTypes);
     this.errorReporter = errorReporter;
@@ -81,7 +81,7 @@ static Optional<BuilderMethodClassifier<ExecutableElement>> classify(
         new BuilderMethodClassifierForAutoValue(
             errorReporter,
             processingEnv,
-            autoValueClass,
+            autoValueClass.asType(),
             builderType,
             getterToPropertyName,
             rewrittenPropertyTypes);

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -437,7 +437,7 @@ private void defineVarsForType(
         builder -> {
           ImmutableBiMap<ExecutableElement, String> methodToPropertyName =
               propertyNameToMethodMap(propertyMethods).inverse();
-          builder.defineVars(vars, methodToPropertyName);
+          builder.defineVarsForAutoValue(vars, methodToPropertyName);
           vars.builderName = "Builder";
           vars.builderAnnotations = copiedClassAnnotations(builder.builderType());
         });

File: value/src/it/functional/src/test/java/com/google/auto/value/AutoValueJava8Test.java
Patch:
@@ -586,7 +586,7 @@ public void testBuilderWithUnprefixedGetter() {
   public abstract static class BuilderWithPrefixedGetters<T extends Comparable<T>> {
     public abstract ImmutableList<T> getList();
 
-    public abstract T getT();
+    public abstract @Nullable T getT();
 
     @SuppressWarnings("mutable")
     public abstract int @Nullable [] getInts();
@@ -601,7 +601,7 @@ public static <T extends Comparable<T>> Builder<T> builder() {
     public abstract static class Builder<T extends Comparable<T>> {
       public abstract Builder<T> setList(ImmutableList<T> list);
 
-      public abstract Builder<T> setT(T t);
+      public abstract Builder<T> setT(@Nullable T t);
 
       public abstract Builder<T> setInts(int[] ints);
 

File: value/src/main/java/com/google/auto/value/processor/PropertyBuilderClassifier.java
Patch:
@@ -53,7 +53,7 @@ class PropertyBuilderClassifier {
   private final ErrorReporter errorReporter;
   private final Types typeUtils;
   private final Elements elementUtils;
-  private final BuilderMethodClassifier builderMethodClassifier;
+  private final BuilderMethodClassifier<?> builderMethodClassifier;
   private final Predicate<String> propertyIsNullable;
   private final ImmutableMap<String, TypeMirror> propertyTypes;
   private final EclipseHack eclipseHack;
@@ -62,7 +62,7 @@ class PropertyBuilderClassifier {
       ErrorReporter errorReporter,
       Types typeUtils,
       Elements elementUtils,
-      BuilderMethodClassifier builderMethodClassifier,
+      BuilderMethodClassifier<?> builderMethodClassifier,
       Predicate<String> propertyIsNullable,
       ImmutableMap<String, TypeMirror> propertyTypes,
       EclipseHack eclipseHack) {

File: value/src/test/java/com/google/auto/value/processor/AutoBuilderCompilationTest.java
Patch:
@@ -124,8 +124,7 @@ public void simpleSuccess() {
   @Test
   public void simpleRecord() {
     double version = Double.parseDouble(JAVA_SPECIFICATION_VERSION.value());
-    assume().that(version).isAtLeast(15.0);
-    String release = Integer.toString((int) version);
+    assume().that(version).isAtLeast(16.0);
     JavaFileObject javaFileObject =
         JavaFileObjects.forSourceLines(
             "foo.bar.Baz",
@@ -147,8 +146,8 @@ public void simpleRecord() {
             "}");
     Compilation compilation =
         javac()
-            .withOptions("--release", release, "--enable-preview")
             .withProcessors(new AutoBuilderProcessor())
+            .withOptions("-Acom.google.auto.value.AutoBuilderIsUnstable")
             .compile(javaFileObject);
     assertThat(compilation)
         .generatedSourceFile("foo.bar.AutoBuilder_Baz_Builder")

File: value/src/main/java/com/google/auto/value/processor/AutoOneOfProcessor.java
Patch:
@@ -58,7 +58,7 @@
 @AutoService(Processor.class)
 @SupportedAnnotationTypes(AUTO_ONE_OF_NAME)
 @IncrementalAnnotationProcessor(IncrementalAnnotationProcessorType.ISOLATING)
-public class AutoOneOfProcessor extends AutoValueOrOneOfProcessor {
+public class AutoOneOfProcessor extends AutoValueishProcessor {
   public AutoOneOfProcessor() {
     super(AUTO_ONE_OF_NAME);
   }

File: value/src/main/java/com/google/auto/value/processor/AutoOneOfTemplateVars.java
Patch:
@@ -25,7 +25,7 @@
  * @author emcmanus@google.com (Éamonn McManus)
  */
 @SuppressWarnings("unused") // the fields in this class are only read via reflection
-class AutoOneOfTemplateVars extends AutoValueOrOneOfTemplateVars {
+class AutoOneOfTemplateVars extends AutoValueishTemplateVars {
   /**
    * The properties defined by the parent class's abstract methods. The elements of this set are in
    * the same order as the original abstract method declarations in the AutoOneOf class.

File: value/src/main/java/com/google/auto/value/processor/AutoValueBuilderProcessor.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.google.auto.value.processor;
 
-import static com.google.auto.value.processor.AutoValueOrOneOfProcessor.hasAnnotationMirror;
+import static com.google.auto.value.processor.AutoValueishProcessor.hasAnnotationMirror;
 import static com.google.auto.value.processor.ClassNames.AUTO_VALUE_BUILDER_NAME;
 import static com.google.auto.value.processor.ClassNames.AUTO_VALUE_NAME;
 

File: value/src/main/java/com/google/auto/value/processor/AutoValueishTemplateVars.java
Patch:
@@ -18,12 +18,12 @@
 import com.google.common.collect.ImmutableList;
 
 /**
- * The variables to substitute into the autovalue.vm or autooneof.vm template.
+ * The variables to substitute into the autovalue.vm, autooneof.vm, or builder.vm templates.
  *
  * @author emcmanus@google.com (Éamonn McManus)
  */
 @SuppressWarnings("unused") // the fields in this class are only read via reflection
-abstract class AutoValueOrOneOfTemplateVars extends TemplateVars {
+abstract class AutoValueishTemplateVars extends TemplateVars {
   /** Whether to generate an equals(Object) method. */
   Boolean equals;
 

File: value/src/main/java/com/google/auto/value/processor/BuilderMethodClassifier.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.google.auto.value.processor;
 
-import static com.google.auto.value.processor.AutoValueOrOneOfProcessor.nullableAnnotationFor;
+import static com.google.auto.value.processor.AutoValueishProcessor.nullableAnnotationFor;
 import static com.google.common.collect.Sets.difference;
 
 import com.google.auto.common.MoreElements;

File: value/src/main/java/com/google/auto/value/processor/ClassNames.java
Patch:
@@ -28,5 +28,6 @@ private ClassNames() {}
   static final String AUTO_ONE_OF_NAME = AUTO_VALUE_PACKAGE_NAME + "AutoOneOf";
   static final String AUTO_VALUE_NAME = AUTO_VALUE_PACKAGE_NAME + "AutoValue";
   static final String AUTO_VALUE_BUILDER_NAME = AUTO_VALUE_NAME + ".Builder";
+  static final String AUTO_BUILDER_NAME = AUTO_VALUE_PACKAGE_NAME + "AutoBuilder";
   static final String COPY_ANNOTATIONS_NAME = AUTO_VALUE_NAME + ".CopyAnnotations";
 }

File: value/src/main/java/com/google/auto/value/processor/GwtSerialization.java
Patch:
@@ -85,7 +85,7 @@ void maybeWriteGwtSerializer(AutoValueTemplateVars autoVars) {
     if (shouldWriteGwtSerializer()) {
       GwtTemplateVars vars = new GwtTemplateVars();
       vars.pkg = autoVars.pkg;
-      vars.subclass = autoVars.finalSubclass;
+      vars.subclass = autoVars.builtClass;
       vars.formalTypes = autoVars.formalTypes;
       vars.actualTypes = autoVars.actualTypes;
       vars.useBuilder = !autoVars.builderTypeName.isEmpty();
@@ -242,7 +242,7 @@ private void writeSourceFile(String className, String text, TypeElement originat
           .printMessage(
               Diagnostic.Kind.WARNING, "Could not write generated class " + className + ": " + e);
       // A warning rather than an error for the reason explained in
-      // AutoValueOrOneOfProcessor.writeSourceFile.
+      // AutoValueishProcessor.writeSourceFile.
     }
   }
 

File: value/src/test/java/com/google/auto/value/processor/AutoValueCompilationTest.java
Patch:
@@ -57,8 +57,8 @@ public class AutoValueCompilationTest {
   public void simpleSuccess() {
     // Positive test case that ensures we generate the expected code for at least one case.
     // Most AutoValue code-generation tests are functional, meaning that we check that the generated
-    // code does the right thing rather than checking what it looks like, but this test is a sanity
-    // check that we are not generating correct but weird code.
+    // code does the right thing rather than checking what it looks like, but this test checks that
+    // we are not generating correct but weird code.
     JavaFileObject javaFileObject =
         JavaFileObjects.forSourceLines(
             "foo.bar.Baz",

File: value/src/it/functional/src/test/java/com/google/auto/value/AutoAnnotationTest.java
Patch:
@@ -438,6 +438,8 @@ public void testSerialVersionUid() {
   }
 
   public static class IntList extends ArrayList<Integer> {
+    private static final long serialVersionUID = 1L;
+
     IntList(Collection<Integer> c) {
       super(c);
     }

File: value/src/it/functional/src/test/java/com/google/auto/value/AutoOneOfTest.java
Patch:
@@ -560,6 +560,8 @@ public void classAnnotationsCopiedIfCopyAnnotations() {
 
   @AutoOneOf(MaybeEmpty.Kind.class)
   public abstract static class MaybeEmpty implements Serializable {
+    private static final long serialVersionUID = 1L;
+
     public enum Kind {
       EMPTY, STRING,
     }

File: value/src/test/java/com/google/auto/value/processor/AutoValueCompilationTest.java
Patch:
@@ -1129,10 +1129,10 @@ public void correctBuilder() {
             "      return this.anInt == that.anInt()",
             "          && Arrays.equals(this.aByteArray, "
                 + "(that instanceof AutoValue_Baz) "
-                + "? ((AutoValue_Baz) that).aByteArray : that.aByteArray())",
+                + "? ((AutoValue_Baz<?>) that).aByteArray : that.aByteArray())",
             "          && Arrays.equals(this.aNullableIntArray, "
                 + "(that instanceof AutoValue_Baz) "
-                + "? ((AutoValue_Baz) that).aNullableIntArray : that.aNullableIntArray())",
+                + "? ((AutoValue_Baz<?>) that).aNullableIntArray : that.aNullableIntArray())",
             "          && this.aList.equals(that.aList())",
             "          && this.anImmutableList.equals(that.anImmutableList())",
             "          && this.anOptionalString.equals(that.anOptionalString())",

File: value/src/it/functional/src/test/java/com/google/auto/value/AutoValueTest.java
Patch:
@@ -73,6 +73,7 @@
 
 /** @author emcmanus@google.com (Éamonn McManus) */
 @RunWith(JUnit4.class)
+@SuppressWarnings({"AutoValueImmutableFields", "AutoValueFinalMethods", "TypeNameShadowing"})
 public class AutoValueTest {
   private static boolean omitIdentifiers;
 
@@ -3481,6 +3482,7 @@ public void builderAnnotationsCopiedIfRequested() {
   }
 
   @AutoValue
+  @AutoValue.CopyAnnotations
   @SuppressWarnings({"rawtypes", "unchecked"}) // deliberately checking handling of raw types
   abstract static class DataWithSortedCollectionBuilders<K, V> {
     abstract ImmutableSortedMap<K, V> anImmutableSortedMap();

File: value/src/main/java/com/google/auto/value/extension/memoized/processor/MemoizedValidator.java
Patch:
@@ -37,8 +37,8 @@
 import net.ltgt.gradle.incap.IncrementalAnnotationProcessorType;
 
 /**
- * An annotation {@link Processor} that reports errors for {@link Memoized @Memoized} methods that
- * are not inside {@code AutoValue}-annotated classes.
+ * An annotation {@link Processor} that reports errors for {@code @Memoized} methods that are not
+ * inside {@code AutoValue}-annotated classes.
  */
 @AutoService(Processor.class)
 @IncrementalAnnotationProcessor(IncrementalAnnotationProcessorType.ISOLATING)

File: value/src/main/java/com/google/auto/value/extension/serializable/processor/SerializableAutoValueExtension.java
Patch:
@@ -59,6 +59,7 @@
  *   <li>The AutoValue class must implement {@link Serializable}.
  *   <li>Unserializable fields in the AutoValue class must be supported by a {@link
  *       com.google.auto.value.extension.serializable.serializer.interfaces.SerializerExtension}.
+ * </ul>
  */
 @AutoService(AutoValueExtension.class)
 public final class SerializableAutoValueExtension extends AutoValueExtension {

File: value/src/main/java/com/google/auto/value/extension/toprettystring/processor/ToPrettyStringExtension.java
Patch:
@@ -102,7 +102,7 @@ private ImmutableList<MethodSpec> toPrettyStringMethodSpecs(Context context) {
             .addModifiers(
                 intersection(toPrettyStringMethod.getModifiers(), INHERITED_VISIBILITY_MODIFIERS));
 
-    method.addCode("return $S", context.autoValueClass().getSimpleName() + "{");
+    method.addCode("return $S", context.autoValueClass().getSimpleName() + " {");
     ToPrettyStringImplementation implementation = ToPrettyStringImplementation.create(context);
     method.addCode(implementation.toStringCodeBlock.build());
 

File: value/src/main/java/com/google/auto/value/extension/memoized/processor/MemoizeExtension.java
Patch:
@@ -176,6 +176,7 @@ String generate() {
       return JavaFile.builder(context.packageName(), generated.build()).build().toString();
     }
 
+    // LINT.IfChange
     private TypeName superType() {
       ClassName superType = ClassName.get(context.packageName(), classToExtend);
       ImmutableList<TypeVariableName> typeVariableNames = typeVariableNames();
@@ -251,6 +252,7 @@ private MethodSpec equalsWithHashCodeCheck() {
           .build();
     }
 
+    // LINT.IfChange
     /**
      * True if the given class name is in the com.google.auto.value package or a subpackage. False
      * if the class name contains {@code Test}, since many AutoValue tests under

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -302,8 +302,8 @@ void defineVars(
         for (Element buildMethod : errorElements) {
           errorReporter.reportError(
               buildMethod,
-              "[AutoValueBuilderBuild] Builder must have a single no-argument method returning"
-                  + " %s%s",
+              "[AutoValueBuilderBuild] Builder must have a single no-argument method, typically"
+                  + " called build(), that returns %s%s",
               autoValueClass,
               typeParamsString());
         }

File: factory/src/main/java/com/google/auto/factory/processor/AutoFactoryProcessor.java
Patch:
@@ -192,6 +192,7 @@ private ImmutableSet<ImplementationMethodDescriptor> implementationMethods(
                 .publicMethod()
                 .passedParameters(passedParameters)
                 .isVarArgs(implementationMethod.isVarArgs())
+                .exceptions(implementationMethod.getThrownTypes())
                 .build());
       }
     }

File: factory/src/main/java/com/google/auto/factory/processor/FactoryDescriptor.java
Patch:
@@ -194,12 +194,12 @@ private static ImmutableSet<FactoryMethodDescriptor> getDeduplicatedMethodDescri
           duplicateMethodDescriptors.get(methodDescriptor);
 
       FactoryMethodDescriptor newMethodDescriptor =
-         (duplicateMethodDescriptor != null)
-              ? methodDescriptor
-                  .toBuilder()
+          (duplicateMethodDescriptor != null)
+              ? methodDescriptor.toBuilder()
                   .overridingMethod(true)
                   .publicMethod(duplicateMethodDescriptor.publicMethod())
                   .returnType(duplicateMethodDescriptor.returnType())
+                  .exceptions(duplicateMethodDescriptor.exceptions())
                   .build()
               : methodDescriptor;
       deduplicatedMethodDescriptors.add(newMethodDescriptor);

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.auto.value.processor.ClassNames.AUTO_VALUE_NAME;
 import static com.google.common.collect.Sets.difference;
 import static com.google.common.collect.Sets.intersection;
+import static java.util.Comparator.naturalOrder;
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toList;
 
@@ -36,7 +37,6 @@
 import java.lang.annotation.Annotation;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Optional;
@@ -136,7 +136,7 @@ public Set<String> getSupportedOptions() {
     AutoValueExtension.IncrementalExtensionType incrementalType =
         extensions.stream()
             .map(e -> e.incrementalType(processingEnv))
-            .min(Comparator.naturalOrder())
+            .min(naturalOrder())
             .orElse(AutoValueExtension.IncrementalExtensionType.ISOLATING);
     builder.add(OMIT_IDENTIFIERS_OPTION).addAll(optionsFor(incrementalType));
     for (AutoValueExtension extension : extensions) {
@@ -207,7 +207,7 @@ void processType(TypeElement type) {
     Optional<BuilderSpec.Builder> builder = builderSpec.getBuilder();
     ImmutableSet<ExecutableElement> toBuilderMethods;
     if (builder.isPresent()) {
-      toBuilderMethods = builder.get().toBuilderMethods(typeUtils(), abstractMethods);
+      toBuilderMethods = builder.get().toBuilderMethods(typeUtils(), type, abstractMethods);
     } else {
       toBuilderMethods = ImmutableSet.of();
     }

File: factory/src/main/java/com/google/auto/factory/processor/AutoFactoryProcessor.java
Patch:
@@ -19,7 +19,6 @@
 import com.google.auto.factory.AutoFactory;
 import com.google.auto.factory.Provided;
 import com.google.auto.service.AutoService;
-import com.google.common.base.Optional;
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
@@ -31,6 +30,7 @@
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.Messager;

File: factory/src/main/java/com/google/auto/factory/processor/ImplementationMethodDescriptor.java
Patch:
@@ -34,9 +34,9 @@ static Builder builder() {
   }
 
   @AutoValue.Builder
-  static abstract class Builder {
+  abstract static class Builder {
     abstract Builder name(String name);
-    
+
     abstract Builder returnType(TypeMirror returnTypeElement);
 
     abstract Builder publicMethod(boolean publicMethod);

File: factory/src/main/java/com/google/auto/factory/processor/ProviderField.java
Patch:
@@ -21,7 +21,7 @@
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Optional;
+import java.util.Optional;
 import javax.lang.model.element.AnnotationMirror;
 
 @AutoValue

File: common/src/main/java/com/google/auto/common/SuperficialValidation.java
Patch:
@@ -163,7 +163,7 @@ && validateTypes(t.getThrownTypes())
         }
       };
 
-  private static boolean validateType(TypeMirror type) {
+  public static boolean validateType(TypeMirror type) {
     return type.accept(TYPE_VALIDATING_VISITOR, null);
   }
 

File: factory/src/main/java/com/google/auto/factory/processor/FactoryDescriptor.java
Patch:
@@ -46,7 +46,7 @@ public boolean matches(char c) {
         }
       };
 
-  abstract String name();
+  abstract PackageAndClass name();
   abstract TypeMirror extendingType();
   abstract ImmutableSet<TypeMirror> implementingTypes();
   abstract boolean publicType();
@@ -76,7 +76,7 @@ String getUniqueName(CharSequence base) {
   }
 
   static FactoryDescriptor create(
-      String name,
+      PackageAndClass name,
       TypeMirror extendingType,
       ImmutableSet<TypeMirror> implementingTypes,
       boolean publicType,

File: factory/src/main/java/com/google/auto/factory/processor/FactoryMethodDescriptor.java
Patch:
@@ -41,7 +41,7 @@ abstract class FactoryMethodDescriptor {
   abstract Builder toBuilder();
   abstract boolean isVarArgs();
 
-  final String factoryName() {
+  final PackageAndClass factoryName() {
     return declaration().getFactoryName();
   }
 
@@ -54,7 +54,7 @@ static Builder builder(AutoFactoryDeclaration declaration) {
   }
 
   @AutoValue.Builder
-  static abstract class Builder {
+  abstract static class Builder {
     abstract Builder declaration(AutoFactoryDeclaration declaration);
     abstract Builder name(String name);
     abstract Builder returnType(TypeMirror returnType);

File: value/src/main/java/com/google/auto/value/processor/TypeEncoder.java
Patch:
@@ -21,6 +21,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.auto.value.processor.MissingTypes.MissingTypeException;
 import com.google.common.collect.ImmutableSet;
 import java.util.List;
 import java.util.OptionalInt;
@@ -290,7 +291,7 @@ public StringBuilder visitWildcard(WildcardType type, StringBuilder sb) {
 
     @Override
     public StringBuilder visitError(ErrorType t, StringBuilder p) {
-      throw new MissingTypeException();
+      throw new MissingTypeException(t);
     }
   }
 

File: value/src/main/java/com/google/auto/value/processor/TypeSimplifier.java
Patch:
@@ -20,6 +20,8 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.processor.MissingTypes.MissingTypeException;
 import com.google.common.collect.ImmutableSortedSet;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -298,7 +300,7 @@ private static Set<String> ambiguousNames(Types typeUtils, Set<TypeMirror> types
     Map<String, Name> simpleNamesToQualifiedNames = new HashMap<>();
     for (TypeMirror type : types) {
       if (type.getKind() == TypeKind.ERROR) {
-        throw new MissingTypeException();
+        throw new MissingTypeException(MoreTypes.asError(type));
       }
       String simpleName = typeUtils.asElement(type).getSimpleName().toString();
       /*

File: value/src/test/java/com/google/auto/value/processor/TypeEncoderTest.java
Patch:
@@ -21,6 +21,7 @@
 import static java.util.stream.Collectors.joining;
 
 import com.google.auto.common.MoreTypes;
+import com.google.auto.value.processor.MissingTypes.MissingTypeException;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.testing.compile.Compilation;

File: value/src/it/functional/src/main/java/com/google/auto/value/SimpleValueType.java
Patch:
@@ -28,14 +28,14 @@ public abstract class SimpleValueType {
   // The getters here are formatted as an illustration of what getters typically look in real
   // classes. In particular they have doc comments.
 
-  /** @return A string that is a nullable string. */
+  /** Returns a string that is a nullable string. */
   @Nullable
   public abstract String string();
 
-  /** @return An integer that is an integer. */
+  /** Returns an integer that is an integer. */
   public abstract int integer();
 
-  /** @return A non-null map where the keys are strings and the values are longs. */
+  /** Returns a non-null map where the keys are strings and the values are longs. */
   public abstract Map<String, Long> map();
 
   public static SimpleValueType create(

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -17,6 +17,7 @@
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.value.processor.AutoValueOrOneOfProcessor.hasAnnotationMirror;
+import static com.google.auto.value.processor.AutoValueOrOneOfProcessor.nullableAnnotationFor;
 import static com.google.auto.value.processor.ClassNames.AUTO_VALUE_BUILDER_NAME;
 import static com.google.common.collect.Sets.immutableEnumSet;
 import static java.util.stream.Collectors.toList;
@@ -367,8 +368,7 @@ public static class PropertySetter {
       primitiveParameter = parameterType.getKind().isPrimitive();
       this.parameterTypeString = parameterTypeString(setter, parameterType);
       VariableElement parameterElement = Iterables.getOnlyElement(setter.getParameters());
-      Optional<String> maybeNullable =
-          AutoValueOrOneOfProcessor.nullableAnnotationFor(parameterElement, parameterType);
+      Optional<String> maybeNullable = nullableAnnotationFor(parameterElement, parameterType);
       this.nullableAnnotation = maybeNullable.orElse("");
     }
 

File: value/src/test/java/com/google/auto/value/processor/AutoValueCompilationTest.java
Patch:
@@ -1599,7 +1599,7 @@ public void autoValueBuilderWrongTypeSetterWithCopyOf() {
             .compile(javaFileObject);
     assertThat(compilation)
         .hadErrorContaining(
-            "Parameter type of setter method should be "
+            "Parameter type java.lang.String of setter method should be "
                 + "com.google.common.collect.ImmutableList<java.lang.String> to match getter "
                 + "foo.bar.Baz.blam, or it should be a type that can be passed to "
                 + "ImmutableList.copyOf")
@@ -1636,7 +1636,7 @@ public void autoValueBuilderWrongTypeSetterWithCopyOfGenericallyWrong() {
             .compile(javaFileObject);
     assertThat(compilation)
         .hadErrorContaining(
-            "Parameter type of setter method should be "
+            "Parameter type java.util.Collection<java.lang.Integer> of setter method should be "
                 + "com.google.common.collect.ImmutableList<java.lang.String> to match getter "
                 + "foo.bar.Baz.blam, or it should be a type that can be passed to "
                 + "ImmutableList.copyOf to produce "

File: service/annotations/src/main/java/com/google/auto/service/AutoService.java
Patch:
@@ -16,7 +16,7 @@
 package com.google.auto.service;
 
 import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.SOURCE;
+import static java.lang.annotation.RetentionPolicy.CLASS;
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -36,7 +36,7 @@
  * </ul>
  */
 @Documented
-@Retention(SOURCE)
+@Retention(CLASS)
 @Target(TYPE)
 public @interface AutoService {
   /** Returns the interfaces implemented by this service provider. */

File: service/annotations/src/main/java/com/google/auto/service/AutoService.java
Patch:
@@ -16,7 +16,7 @@
 package com.google.auto.service;
 
 import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.CLASS;
+import static java.lang.annotation.RetentionPolicy.SOURCE;
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -36,7 +36,7 @@
  * </ul>
  */
 @Documented
-@Retention(CLASS)
+@Retention(SOURCE)
 @Target(TYPE)
 public @interface AutoService {
   /** Returns the interfaces implemented by this service provider. */

File: service/annotations/src/main/java/com/google/auto/service/AutoService.java
Patch:
@@ -16,7 +16,7 @@
 package com.google.auto.service;
 
 import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.SOURCE;
+import static java.lang.annotation.RetentionPolicy.CLASS;
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -36,7 +36,7 @@
  * </ul>
  */
 @Documented
-@Retention(SOURCE)
+@Retention(CLASS)
 @Target(TYPE)
 public @interface AutoService {
   /** Returns the interfaces implemented by this service provider. */

File: common/src/main/java/com/google/auto/common/MoreTypes.java
Patch:
@@ -869,8 +869,9 @@ public Boolean visitDeclared(DeclaredType type, Void ignored) {
   }
 
   /**
-   * Returns the non-object superclass of the type with the proper type parameters.
-   * An absent Optional is returned if there is no non-Object superclass.
+   * Returns the superclass of {@code type}, with any type parameters bound by {@code type}, or
+   * {@link Optional#absent()} if {@code type} is an interface or {@link Object} or its superclass
+   * is {@link Object}.
    */
   // TODO(user): Remove unused parameter Elements?
   public static Optional<DeclaredType> nonObjectSuperclass(Types types, Elements elements,

File: value/src/main/java/com/google/auto/value/processor/BuilderMethodClassifier.java
Patch:
@@ -321,7 +321,7 @@ private void classifyGetter(ExecutableElement builderGetter, ExecutableElement o
       // boxedOriginalType is Integer, and containedType is also Integer.
       // We don't need any special code for OptionalInt because containedType will be int then.
       TypeMirror boxedOriginalType =
-          (originalGetterType.getKind().isPrimitive())
+          originalGetterType.getKind().isPrimitive()
               ? typeUtils.boxedClass(MoreTypes.asPrimitiveType(originalGetterType)).asType()
               : null;
       if (TYPE_EQUIVALENCE.equivalent(containedType, originalGetterType)

File: factory/src/main/java/com/google/auto/factory/processor/AutoFactoryProcessor.java
Patch:
@@ -175,7 +175,7 @@ public int compare(TypeMirror first, TypeMirror second) {
                   implementationMethodDescriptors.get(entry.getKey()),
                   allowSubclasses));
         } catch (IOException e) {
-          messager.printMessage(Kind.ERROR, "failed");
+          messager.printMessage(Kind.ERROR, "failed: " + e);
         }
       }
     }

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -250,6 +250,7 @@ void processType(TypeElement type) {
     GwtCompatibility gwtCompatibility = new GwtCompatibility(type);
     vars.gwtCompatibleAnnotation = gwtCompatibility.gwtCompatibleAnnotationString();
 
+    builder.ifPresent(context::setBuilderContext);
     int subclassDepth = writeExtensions(type, context, applicableExtensions);
     String subclass = generatedSubclassName(type, subclassDepth);
     vars.subclass = TypeSimplifier.simpleNameOf(subclass);

File: value/src/main/java/com/google/auto/value/processor/TypeSimplifier.java
Patch:
@@ -379,5 +379,5 @@ private static boolean isJavaLangObject(TypeMirror type) {
       TypeElement typeElement = (TypeElement) declaredType.asElement();
       return typeElement.getQualifiedName().contentEquals("java.lang.Object");
     }
-  };
+  }
 }

File: factory/src/it/functional/src/main/java/com/google/auto/factory/FactoryComponent.java
Patch:
@@ -20,5 +20,7 @@
 /** A component to materialize the factory using Dagger 2 */
 @Component(modules = DaggerModule.class)
 interface FactoryComponent {
-  FactoryGeneratedFactory factory();
+  FooFactory factory();
+
+  GenericFooFactory<Number> generatedFactory();
 }

File: factory/src/it/functional/src/main/java/com/google/auto/factory/FactoryInterface.java
Patch:
@@ -16,5 +16,5 @@
 package com.google.auto.factory;
 
 public interface FactoryInterface {
-  FactoryGenerated generate(String name);
+  Foo generate(String name);
 }

File: factory/src/it/functional/src/main/java/com/google/auto/factory/Foo.java
Patch:
@@ -18,14 +18,14 @@
 import javax.inject.Provider;
 
 @AutoFactory(implementing = FactoryInterface.class)
-public final class FactoryGenerated {
+public final class Foo {
   private final String name;
   private final Dependency dependency;
   private final Provider<Dependency> dependencyProvider;
   private final int primitive;
   private final int qualifiedPrimitive;
 
-  FactoryGenerated(
+  Foo(
       String name,
       @Provided Dependency dependency,
       @Provided @Qualifier Provider<Dependency> dependencyProvider,
@@ -40,7 +40,7 @@ public final class FactoryGenerated {
 
   // Generates second factory method with a different name for the Dependency dependency.
   // Tests http://b/21632171.
-  FactoryGenerated(
+  Foo(
       Object name,
       @Provided Dependency dependency2,
       @Provided @Qualifier Provider<Dependency> dependencyProvider,

File: factory/src/it/functional/src/main/java/com/google/auto/factory/GuiceModule.java
Patch:
@@ -23,5 +23,6 @@ public class GuiceModule extends AbstractModule {
     bind(Dependency.class).annotatedWith(Qualifier.class).to(QualifiedDependencyImpl.class);
     bind(Integer.class).toInstance(1);
     bind(Integer.class).annotatedWith(Qualifier.class).toInstance(2);
+    bind(Number.class).toInstance(3);
   }
 }

File: factory/src/main/java/com/google/auto/factory/processor/FactoryDescriptorGenerator.java
Patch:
@@ -120,9 +120,6 @@ FactoryMethodDescriptor generateDescriptorForConstructor(final AutoFactoryDeclar
     checkNotNull(constructor);
     checkArgument(constructor.getKind() == ElementKind.CONSTRUCTOR);
     TypeElement classElement = MoreElements.asType(constructor.getEnclosingElement());
-    if (!classElement.getTypeParameters().isEmpty()) {
-      messager.printMessage(ERROR, "AutoFactory does not support generic types", classElement);
-    }
     ImmutableListMultimap<Boolean, ? extends VariableElement> parameterMap =
         Multimaps.index(constructor.getParameters(), Functions.forPredicate(
             new Predicate<VariableElement>() {

File: factory/src/main/java/com/google/auto/factory/processor/FactoryWriter.java
Patch:
@@ -257,7 +257,7 @@ private static CharSequence getSimpleName(CharSequence fullyQualifiedName) {
 
   private static String getPackage(CharSequence fullyQualifiedName) {
     int lastDot = lastIndexOf(fullyQualifiedName, '.');
-    return fullyQualifiedName.subSequence(0, lastDot).toString();
+    return lastDot == -1 ? "" : fullyQualifiedName.subSequence(0, lastDot).toString();
   }
 
   private static int lastIndexOf(CharSequence charSequence, char c) {

File: common/src/main/java/com/google/auto/common/MoreTypes.java
Patch:
@@ -208,6 +208,7 @@ && equal(enclosingType(a), enclosingType(b), newVisiting)
     }
 
     @Override
+    @SuppressWarnings("TypeEquals")
     public Boolean visitError(ErrorType a, EqualVisitorParam p) {
       return a.equals(p.type);
     }
@@ -295,6 +296,7 @@ private Set<ComparedElements> visitingSetPlus(
     }
   }
 
+  @SuppressWarnings("TypeEquals")
   private static boolean equal(TypeMirror a, TypeMirror b, Set<ComparedElements> visiting) {
     // TypeMirror.equals is not guaranteed to return true for types that are equal, but we can
     // assume that if it does return true then the types are equal. This check also avoids getting

File: value/src/test/java/com/google/auto/value/processor/TypeSimplifierTest.java
Patch:
@@ -106,6 +106,7 @@ public void testQuirkyTypeMirrors() {
   }
 
   @Test
+  @SuppressWarnings("TypeEquals") // We want to test the equals method invocation on TypeMirror.
   public void testTypeMirrorSet() {
     // Test the TypeMirrorSet methods. Resist the temptation to rewrite these in terms of
     // Truth operations! For example, don't change assertThat(set.size()).isEqualTo(0) into

File: value/src/test/java/com/google/auto/value/extension/memoized/MemoizedMethodSubject.java
Patch:
@@ -27,7 +27,7 @@
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 
-final class MemoizedMethodSubject extends Subject<MemoizedMethodSubject, String> {
+final class MemoizedMethodSubject extends Subject {
   private final String actual;
 
   MemoizedMethodSubject(FailureMetadata failureMetadata, String actual) {

File: value/src/test/java/com/google/auto/value/processor/AutoValueCompilationTest.java
Patch:
@@ -2154,8 +2154,9 @@ public void autoValueBuilderAlienMethod0() {
             .compile(javaFileObject);
     assertThat(compilation)
         .hadErrorContaining(
-            "Method without arguments should be a build method returning foo.bar.Baz"
-                + " or a getter method with the same name and type as a getter method of foo.bar.Baz")
+            "Method without arguments should be a build method returning foo.bar.Baz, or a getter"
+                + " method with the same name and type as a getter method of foo.bar.Baz, or"
+                + " fooBuilder() where foo() or getFoo() is a getter method of foo.bar.Baz")
         .inFile(javaFileObject)
         .onLine(12);
   }

File: factory/src/main/java/com/google/auto/factory/processor/FactoryWriter.java
Patch:
@@ -67,7 +67,9 @@ final class FactoryWriter {
   void writeFactory(final FactoryDescriptor descriptor)
       throws IOException {
     String factoryName = getSimpleName(descriptor.name()).toString();
-    TypeSpec.Builder factory = classBuilder(factoryName);
+    TypeSpec.Builder factory =
+        classBuilder(factoryName)
+            .addOriginatingElement(descriptor.declaration().targetType());
     generatedAnnotationSpec(
             elements,
             sourceVersion,

File: factory/src/main/java/com/google/auto/factory/processor/FactoryWriter.java
Patch:
@@ -106,7 +106,7 @@ private void addConstructorAndProviderFields(
     Iterator<ProviderField> providerFields = descriptor.providers().values().iterator();
     for (int argumentIndex = 1; providerFields.hasNext(); argumentIndex++) {
       ProviderField provider = providerFields.next();
-      TypeName typeName = TypeName.get(provider.key().type()).box();
+      TypeName typeName = TypeName.get(provider.key().type().get()).box();
       TypeName providerType = ParameterizedTypeName.get(ClassName.get(Provider.class), typeName);
       factory.addField(providerType, provider.name(), PRIVATE, FINAL);
       if (provider.key().qualifier().isPresent()) {

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -26,6 +26,7 @@
 import com.google.auto.value.extension.AutoValueExtension;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Strings;
+import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
@@ -118,7 +119,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
         if (t instanceof ServiceConfigurationError) {
           warning.append(" This may be due to a corrupt jar file in the compiler's classpath.");
         }
-        warning.append(" Exception: ").append(t);
+        warning.append("\n").append(Throwables.getStackTraceAsString(t));
         errorReporter().reportWarning(warning.toString(), null);
         extensions = ImmutableList.of();
       }

File: value/src/test/java/com/google/auto/value/processor/ExtensionTest.java
Patch:
@@ -616,7 +616,7 @@ private void doTestBadJarDoesntBlowUp(File badJar) throws IOException {
             .processedWith(new AutoValueProcessor(badJarLoader))
             .compilesWithoutError();
     success.withWarningContaining(
-        "This may be due to a corrupt jar file in the compiler's classpath. Exception: "
+        "This may be due to a corrupt jar file in the compiler's classpath.\n  "
             + ServiceConfigurationError.class.getName());
     success
         .and()

File: value/src/main/java/com/google/auto/value/processor/TemplateVars.java
Patch:
@@ -119,8 +119,9 @@ static Template parsedTemplateForResource(String resourceName) {
       return Template.parseFrom(resourceName, TemplateVars::readerFromResource);
     } catch (UnsupportedEncodingException e) {
       throw new AssertionError(e);
-    } catch (IOException | NullPointerException e) {
-      // https://github.com/google/auto/pull/439 says that we can also get NullPointerException.
+    } catch (IOException | NullPointerException | IllegalStateException e) {
+      // https://github.com/google/auto/pull/439 says that we can get NullPointerException.
+      // https://github.com/google/auto/issues/715 says that we can get IllegalStateException
       return retryParseAfterException(resourceName, e);
     }
   }

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -415,8 +415,6 @@ private void defineVarsForType(
     // We can't use ImmutableList.toImmutableList() for obscure Google-internal reasons.
     vars.toBuilderMethods =
         ImmutableList.copyOf(toBuilderMethods.stream().map(SimpleMethod::new).collect(toList()));
-    ImmutableBiMap<ExecutableElement, String> methodToPropertyName =
-        propertyNameToMethodMap(propertyMethods).inverse();
     ImmutableListMultimap<ExecutableElement, AnnotationMirror> annotatedPropertyFields =
         propertyFieldAnnotationMap(type, propertyMethods);
     ImmutableListMultimap<ExecutableElement, AnnotationMirror> annotatedPropertyMethods =
@@ -426,6 +424,8 @@ private void defineVarsForType(
     vars.serialVersionUID = getSerialVersionUID(type);
     // Check for @AutoValue.Builder and add appropriate variables if it is present.
     if (builder.isPresent()) {
+      ImmutableBiMap<ExecutableElement, String> methodToPropertyName =
+          propertyNameToMethodMap(propertyMethods).inverse();
       builder.get().defineVars(vars, methodToPropertyName);
     }
   }

File: value/src/main/java/com/google/auto/value/processor/AutoValueOrOneOfProcessor.java
Patch:
@@ -771,7 +771,7 @@ private void warnAboutPrimitiveArrays(TypeElement autoValueClass, ExecutableElem
           "An @"
               + simpleAnnotationName
               + " property that is a primitive array returns the original array, which can"
-              + " therefore be modified by the caller. If this OK, you can suppress this warning"
+              + " therefore be modified by the caller. If this is OK, you can suppress this warning"
               + " with @SuppressWarnings(\"mutable\"). Otherwise, you should replace the property"
               + " with an immutable type, perhaps a simple wrapper around the original array.";
       boolean sameClass = getter.getEnclosingElement().equals(autoValueClass);

File: common/src/main/java/com/google/auto/common/MoreTypes.java
Patch:
@@ -88,7 +88,7 @@ protected int doHash(TypeMirror t) {
    * <ul>
    * <li>If you don't have an instance of {@code Types}.
    * <li>If you want a reliable {@code hashCode()} for the types, for example to construct a set
-   *     of types using {@link java.util.HashSet} with {@link Equivalence#wrap()}.
+   *     of types using {@link java.util.HashSet} with {@link Equivalence#wrap(Object)}.
    * <li>If you want distinct type variables to be considered equal if they have the same names
    *     and bounds.
    * <li>If you want wildcard types to compare equal if they have the same bounds. {@code

File: value/src/main/java/com/google/auto/value/processor/AutoOneOfProcessor.java
Patch:
@@ -259,6 +259,9 @@ private void defineVarsForType(
 
   @Override
   Optional<String> nullableAnnotationForMethod(ExecutableElement propertyMethod) {
+    if (nullableAnnotationFor(propertyMethod, propertyMethod.getReturnType()).isPresent()) {
+      errorReporter().reportError("@AutoOneOf properties cannot be @Nullable", propertyMethod);
+    }
     return Optional.empty();
   }
 

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -305,7 +305,7 @@ public static class PropertySetter {
       primitiveParameter = parameterType.getKind().isPrimitive();
       this.parameterTypeString = parameterTypeString(setter, parameterType);
       Optional<String> maybeNullable =
-          AutoValueProcessor.nullableAnnotationFor(parameterElement, parameterType);
+          AutoValueOrOneOfProcessor.nullableAnnotationFor(parameterElement, parameterType);
       this.nullableAnnotation = maybeNullable.orElse("");
       boolean nullable = maybeNullable.isPresent();
       this.copyOf = copyOfString(propertyType, parameterType, typeUtils, nullable);

File: value/src/main/java/com/google/auto/value/processor/TypeMirrorSet.java
Patch:
@@ -17,7 +17,6 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.collect.ImmutableList;
 import java.util.AbstractSet;
 import java.util.Collection;
@@ -32,8 +31,7 @@
  * @author emcmanus@google.com (Éamonn McManus)
  */
 class TypeMirrorSet extends AbstractSet<TypeMirror> {
-  private final Set<Equivalence.Wrapper<TypeMirror>> wrappers =
-      new LinkedHashSet<Wrapper<TypeMirror>>();
+  private final Set<Equivalence.Wrapper<TypeMirror>> wrappers = new LinkedHashSet<>();
 
   TypeMirrorSet() {}
 

File: common/src/test/java/com/google/auto/common/SuperficialValidationTest.java
Patch:
@@ -246,8 +246,6 @@ public void missingIntersection() {
         .failsToCompile();
   }
 
-  // TODO(gak): Enable when b/17584340 is resolved.
-  /*
   @Test
   public void invalidAnnotationValue() {
     JavaFileObject javaFileObject = JavaFileObjects.forSourceLines("test.Outer",
@@ -272,7 +270,6 @@ public void invalidAnnotationValue() {
           }
         }).failsToCompile();
   }
-  */
 
   private abstract static class AssertingProcessor extends AbstractProcessor {
     @Override

File: value/src/test/java/com/google/auto/value/processor/ExtensionTest.java
Patch:
@@ -146,7 +146,7 @@ public void testExtensionConsumesProperties() throws Exception {
             "    }",
             "    if (o instanceof Baz) {",
             "      Baz that = (Baz) o;",
-            "      return (this.foo.equals(that.foo()));",
+            "      return this.foo.equals(that.foo());",
             "    }",
             "    return false;",
             "  }",

File: value/src/main/java/com/google/auto/value/processor/AutoAnnotationProcessor.java
Patch:
@@ -182,7 +182,7 @@ private void processMethod(ExecutableElement method) {
   private String getGeneratedTypeName() {
     return generatedAnnotation(elementUtils, processingEnv.getSourceVersion())
         .map(generatedAnnotation -> TypeEncoder.encode(generatedAnnotation.asType()))
-        .orElse(null);
+        .orElse("");
   }
 
   /**

File: value/src/main/java/com/google/auto/value/extension/memoized/Memoized.java
Patch:
@@ -43,7 +43,7 @@
  * returns {@code null}, the overriding method will throw a {@link NullPointerException}.
  *
  * <p>The overriding method uses
- * <a href="http://errorprone.info/bugpattern/DoubleCheckedLocking">double-checked locking</a> to
+ * <a href="https://errorprone.info/bugpattern/DoubleCheckedLocking">double-checked locking</a> to
  * ensure that the annotated method is called at most once.
  *
  * <h3>Example</h3>

File: value/src/main/java/com/google/auto/value/processor/AutoOneOfProcessor.java
Patch:
@@ -25,7 +25,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableBiMap;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -246,8 +245,7 @@ private void defineVarsForType(
   }
 
   @Override
-  Optional<String> nullableAnnotationForMethod(
-      ExecutableElement propertyMethod, ImmutableList<AnnotationMirror> methodAnnotations) {
+  Optional<String> nullableAnnotationForMethod(ExecutableElement propertyMethod) {
     return Optional.empty();
   }
 

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -204,6 +204,7 @@ void processType(TypeElement type) {
     String subclass = generatedSubclassName(type, subclassDepth);
     vars.subclass = TypeSimplifier.simpleNameOf(subclass);
     vars.isFinal = (subclassDepth == 0);
+    vars.modifiers = vars.isFinal ? "final " : "abstract ";
 
     String text = vars.toText();
     text = TypeEncoder.decode(text, processingEnv, vars.pkg, type.asType());

File: value/src/it/functional/src/main/java/PackagelessValueType.java
Patch:
@@ -21,7 +21,6 @@
 /**
  * Simple package-less value type for tests.
  *
- * @see PackagelessValueTypeTest
  * @author emcmanus@google.com (Éamonn McManus)
  */
 @AutoValue

File: value/src/it/functional/src/main/java/com/google/auto/value/SimpleValueType.java
Patch:
@@ -21,7 +21,6 @@
 /**
  * Simple value type for tests.
  *
- * @see SimpleValueTypeTest
  * @author emcmanus@google.com (Éamonn McManus)
  */
 @AutoValue
@@ -53,4 +52,4 @@ public static SimpleValueType create(
     // corresponding field.
     return new AutoValue_SimpleValueType(string, integer, map);
   }
-}
\ No newline at end of file
+}

File: factory/src/test/java/com/google/auto/factory/processor/AutoFactoryProcessorTest.java
Patch:
@@ -29,6 +29,7 @@
 import java.io.UncheckedIOException;
 import java.util.Collections;
 import java.util.List;
+import javax.lang.model.SourceVersion;
 import javax.tools.JavaFileObject;
 import org.junit.Rule;
 import org.junit.Test;
@@ -446,8 +447,7 @@ private JavaFileObject loadExpectedFile(String resourceName) {
   }
 
   private boolean isJavaxAnnotationProcessingGeneratedAvailable() {
-    return compilationRule.getElements().getTypeElement("javax.annotation.processing.Generated")
-        != null;
+    return SourceVersion.latestSupported().compareTo(SourceVersion.RELEASE_8) > 0;
   }
 
   private static void replaceGeneratedImport(List<String> sourceLines) {

File: value/src/main/java/com/google/auto/value/processor/AutoOneOfProcessor.java
Patch:
@@ -250,7 +250,7 @@ private void defineVarsForType(
       ImmutableSet<ExecutableElement> propertyMethods,
       ExecutableElement kindGetter) {
     vars.generated =
-        generatedAnnotation(elementUtils())
+        generatedAnnotation(elementUtils(), processingEnv.getSourceVersion())
             .map(annotation -> TypeEncoder.encode(annotation.asType()))
             .orElse("");
     Map<ExecutableElement, ImmutableList<AnnotationMirror>> annotatedPropertyMethods =

File: value/src/test/java/com/google/auto/value/processor/AutoOneOfCompilationTest.java
Patch:
@@ -34,8 +34,6 @@
 public class AutoOneOfCompilationTest {
   @Rule
   public final Expect expect = Expect.create();
-  @Rule
-  public final GeneratedImportRule generatedImportRule = new GeneratedImportRule();
 
   @Test
   public void success() {
@@ -67,7 +65,7 @@ public void success() {
             "foo.bar.AutoOneOf_TaskResult",
             "package foo.bar;",
             "",
-            generatedImportRule.importGeneratedAnnotationType(),
+            GeneratedImport.importGeneratedAnnotationType(),
             "",
             "@Generated(\"com.google.auto.value.processor.AutoOneOfProcessor\")",
             "final class AutoOneOf_TaskResult {",

File: value/src/main/java/com/google/auto/value/processor/TypeEncoder.java
Patch:
@@ -325,7 +325,7 @@ String rewrite() {
       Set<TypeMirror> referencedClasses = findReferencedClasses();
       // Make a type simplifier based on these referenced types.
       TypeSimplifier typeSimplifier =
-          new TypeSimplifier(typeUtils, packageName, referencedClasses, baseType);
+          new TypeSimplifier(elementUtils, typeUtils, packageName, referencedClasses, baseType);
 
       StringBuilder output = new StringBuilder();
       int copyStart;

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -21,7 +21,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.auto.value.processor.AutoValueProcessor.Property;
+import com.google.auto.value.processor.AutoValueOrOneOfProcessor.Property;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMultimap;

File: common/src/main/java/com/google/auto/common/GeneratedAnnotationSpecs.java
Patch:
@@ -31,7 +31,7 @@ private GeneratedAnnotationSpecs() {}
    * javax.annotation.processing.Generated} or {@code javax.annotation.Generated} is {@linkplain
    * GeneratedAnnotations#generatedAnnotation(Elements) available at compile time}.
    *
-   * @deprecated prefer {@link #generatedAnnotationSpec(Elements, SourceVersion, Class<?>)}
+   * @deprecated prefer {@link #generatedAnnotationSpec(Elements, SourceVersion, Class)}
    */
   @Deprecated
   public static Optional<AnnotationSpec> generatedAnnotationSpec(
@@ -45,7 +45,7 @@ public static Optional<AnnotationSpec> generatedAnnotationSpec(
    * javax.annotation.processing.Generated} or {@code javax.annotation.Generated} is {@linkplain
    * GeneratedAnnotations#generatedAnnotation(Elements) available at compile time}.
    *
-   * @deprecated prefer {@link #generatedAnnotationSpec(Elements, SourceVersion, Class<?>, String)}
+   * @deprecated prefer {@link #generatedAnnotationSpec(Elements, SourceVersion, Class, String)}
    */
   @Deprecated
   public static Optional<AnnotationSpec> generatedAnnotationSpec(

File: service/src/main/java/com/google/auto/service/AutoService.java
Patch:
@@ -40,6 +40,6 @@
 @Retention(SOURCE)
 @Target(TYPE)
 public @interface AutoService {
-  /** Returns the interface implemented by this service provider. */
-  Class<?> value();
+  /** Returns the interfaces implemented by this service provider. */
+  Class<?>[] value();
 }

File: value/src/it/gwtserializer/src/test/java/com/google/auto/value/client/GwtSerializerTest.java
Patch:
@@ -24,8 +24,6 @@
 import com.google.gwt.user.client.rpc.RemoteService;
 import com.google.gwt.user.client.rpc.RemoteServiceRelativePath;
 import com.google.gwt.user.server.rpc.RemoteServiceServlet;
-import java.lang.Override;
-import java.lang.SuppressWarnings;
 
 public class GwtSerializerTest extends GWTTestCase {
 

File: value/src/main/java/com/google/auto/value/processor/TypeMirrorSet.java
Patch:
@@ -17,11 +17,12 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
+import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.collect.ImmutableList;
 import java.util.AbstractSet;
 import java.util.Collection;
-import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedHashSet;
 import java.util.Set;
 import javax.lang.model.type.TypeMirror;
 
@@ -32,7 +33,7 @@
  */
 class TypeMirrorSet extends AbstractSet<TypeMirror> {
   private final Set<Equivalence.Wrapper<TypeMirror>> wrappers =
-      new HashSet<Equivalence.Wrapper<TypeMirror>>();
+      new LinkedHashSet<Wrapper<TypeMirror>>();
 
   TypeMirrorSet() {
   }

File: value/src/test/java/com/google/auto/value/extension/memoized/MemoizedMethodSubject.java
Patch:
@@ -21,15 +21,15 @@
 
 import com.google.auto.value.processor.AutoValueProcessor;
 import com.google.common.collect.ImmutableList;
-import com.google.common.truth.FailureStrategy;
+import com.google.common.truth.FailureMetadata;
 import com.google.common.truth.Subject;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 
 final class MemoizedMethodSubject extends Subject<MemoizedMethodSubject, String> {
 
-  MemoizedMethodSubject(FailureStrategy failureStrategy, String subject) {
-    super(failureStrategy, subject);
+  MemoizedMethodSubject(FailureMetadata failureMetadata, String subject) {
+    super(failureMetadata, subject);
   }
 
   void hasError(String error) {

File: value/src/test/java/com/google/auto/value/processor/GeneratedDoesNotExistTest.java
Patch:
@@ -24,7 +24,6 @@
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.util.concurrent.atomic.AtomicBoolean;
-import javax.annotation.Generated;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.Processor;
 import javax.lang.model.element.TypeElement;
@@ -94,7 +93,7 @@ private static class ElementsHandler extends OverridableInvocationHandler<Elemen
     }
 
     public TypeElement getTypeElement(CharSequence name) {
-      if (name.toString().equals(Generated.class.getName())) {
+      if (name.toString().equals("javax.annotation.Generated")) {
         ignoredGenerated.set(true);
         return null;
       } else {

File: value/src/main/java/com/google/auto/value/processor/AutoAnnotationProcessor.java
Patch:
@@ -130,10 +130,9 @@ private void process(RoundEnvironment roundEnv) {
       } catch (AbortProcessingException e) {
         // We abandoned this type, but continue with the next.
       } catch (RuntimeException e) {
-        // Don't propagate this exception, which will confusingly crash the compiler.
-        // Instead, report a compiler error with the stack trace.
         String trace = Throwables.getStackTraceAsString(e);
         reportError(method, "@AutoAnnotation processor threw an exception: %s", trace);
+        throw e;
       }
     }
   }

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -206,10 +206,9 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         // the same TypeElement on the next round.
         deferredTypeNames.add(type.getQualifiedName().toString());
       } catch (RuntimeException e) {
-        // Don't propagate this exception, which will confusingly crash the compiler.
-        // Instead, report a compiler error with the stack trace.
         String trace = Throwables.getStackTraceAsString(e);
         errorReporter.reportError("@AutoValue processor threw an exception: " + trace, type);
+        throw e;
       }
     }
     return false;  // never claim annotation, because who knows what other processors want?

File: value/src/main/java/com/google/auto/value/processor/BuilderMethodClassifier.java
Patch:
@@ -305,7 +305,7 @@ private boolean classifyGetter(
       ExecutableElement builderGetter, ExecutableElement originalGetter) {
     String propertyName = getterToPropertyName.get(originalGetter);
     TypeMirror builderGetterType = builderMethodReturnType(builderGetter);
-    String builderGetterTypeString = typeSimplifier.simplify(builderGetterType);
+    String builderGetterTypeString = typeSimplifier.simplifyWithAnnotations(builderGetterType);
     TypeMirror originalGetterType = originalGetter.getReturnType();
     if (TYPE_EQUIVALENCE.equivalent(builderGetterType, originalGetterType)) {
       builderGetters.put(

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -315,7 +315,7 @@ public PropertySetter(
       this.name = setter.getSimpleName().toString();
       TypeMirror parameterType = Iterables.getOnlyElement(setter.getParameters()).asType();
       primitiveParameter = parameterType.getKind().isPrimitive();
-      String simplifiedParameterType = typeSimplifier.simplify(parameterType);
+      String simplifiedParameterType = typeSimplifier.simplifyWithAnnotations(parameterType);
       if (setter.isVarArgs()) {
         simplifiedParameterType = simplifiedParameterType.replaceAll("\\[\\]$", "...");
       }

File: value/src/main/java/com/google/auto/value/processor/PropertyBuilderClassifier.java
Patch:
@@ -243,7 +243,7 @@ Optional<PropertyBuilder> makePropertyBuilder(ExecutableElement method, String p
     }
     ExecutableElement builderMaker = maybeBuilderMaker.get();
 
-    String barBuilderType = typeSimplifier.simplify(barBuilderTypeMirror);
+    String barBuilderType = typeSimplifier.simplifyWithAnnotations(barBuilderTypeMirror);
     String rawBarType = typeSimplifier.simplifyRaw(barTypeMirror);
     String initializer = (builderMaker.getKind() == ElementKind.CONSTRUCTOR)
         ? "new " + barBuilderType + "()"

File: value/src/it/functional/src/test/java/com/google/auto/value/AutoValueTest.java
Patch:
@@ -1032,7 +1032,7 @@ public void testComparisonChain() {
       for (int j = 0; j < versions.length; j++) {
         int actual = Integer.signum(versions[i].compareTo(versions[j]));
         int expected = Integer.signum(i - j);
-        assertEquals(actual, expected);
+        assertEquals(expected, actual);
       }
     }
   }

File: value/src/main/java/com/google/auto/value/AutoValue.java
Patch:
@@ -40,7 +40,7 @@
  * @author Éamonn McManus
  * @author Kevin Bourrillion
  */
-@Retention(RetentionPolicy.SOURCE)
+@Retention(RetentionPolicy.CLASS)
 @Target(ElementType.TYPE)
 public @interface AutoValue {
 

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -855,8 +855,6 @@ private TypeSimplifier defineVarsForType(
         errorReporter.reportError("Primitive types cannot be @Nullable", method);
       }
     }
-    // If we are running from Eclipse, undo the work of its compiler which sorts methods.
-    eclipseHack.reorderProperties(props);
     vars.props = ImmutableSet.copyOf(props);
     vars.serialVersionUID = getSerialVersionUID(type);
     vars.formalTypes = typeSimplifier.formalTypeParametersString(type);

File: value/src/test/java/com/google/auto/value/processor/CompilationTest.java
Patch:
@@ -959,7 +959,7 @@ public void correctBuilder() throws Exception {
         "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(javaFileObject, nestedJavaFileObject))
-        .withCompilerOptions("-Xlint:-processing")
+        .withCompilerOptions("-Xlint:-processing", "-implicit:none")
         .processedWith(new AutoValueProcessor())
         .compilesWithoutWarnings()
         .and()

File: common/src/main/java/com/google/auto/common/MoreTypes.java
Patch:
@@ -738,7 +738,7 @@ public TypeVariable visitTypeVariable(TypeVariable type, Void ignore) {
    * Returns a {@link WildcardType} if the {@link TypeMirror} represents a wildcard type or throws
    * an {@link IllegalArgumentException}.
    */
-  public static WildcardType asWildcard(WildcardType maybeWildcardType) {
+  public static WildcardType asWildcard(TypeMirror maybeWildcardType) {
     return maybeWildcardType.accept(WildcardTypeVisitor.INSTANCE, null);
   }
 

File: value/src/main/java/com/google/auto/value/processor/escapevelocity/ExpressionNode.java
Patch:
@@ -129,6 +129,7 @@ static class BinaryExpressionNode extends ExpressionNode {
           return equal(context);
         case NOT_EQUAL:
           return !equal(context);
+        default: // fall out
       }
       int lhsInt = lhs.intValue(context);
       int rhsInt = rhs.intValue(context);

File: factory/src/test/java/com/google/auto/factory/processor/AutoFactoryProcessorTest.java
Patch:
@@ -177,10 +177,10 @@ public void simpleClassProvidedProviderDeps() {
         .failsToCompile()
         .withErrorContaining(
             "Cannot mix allowSubclasses=true and allowSubclasses=false in one factory.")
-            .in(file).onLine(22).atColumn(3)
+            .in(file).onLine(24)
          .and().withErrorContaining(
             "Cannot mix allowSubclasses=true and allowSubclasses=false in one factory.")
-            .in(file).onLine(23).atColumn(3);
+            .in(file).onLine(27);
   }
 
   @Test public void failsOnGenericClass() {

File: value/src/main/java/com/google/auto/value/processor/escapevelocity/ReferenceNode.java
Patch:
@@ -413,7 +413,7 @@ private static boolean classIsExported(Class<?> c) {
       String pkg = packageNameOf(c);
       Object module = CLASS_GET_MODULE_METHOD.invoke(c);
       return (Boolean) MODULE_IS_EXPORTED_METHOD.invoke(module, pkg);
-    } catch (ReflectiveOperationException e) {
+    } catch (Exception e) {
       return false;
     }
   }
@@ -428,7 +428,7 @@ private static boolean classIsExported(Class<?> c) {
       classGetModuleMethod = Class.class.getMethod("getModule");
       Class<?> moduleClass = classGetModuleMethod.getReturnType();
       moduleIsExportedMethod = moduleClass.getMethod("isExported", String.class);
-    } catch (ReflectiveOperationException e) {
+    } catch (Exception e) {
       classGetModuleMethod = null;
       moduleIsExportedMethod = null;
     }

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -55,7 +55,6 @@
 import java.util.ServiceLoader;
 import java.util.Set;
 import java.util.regex.Pattern;
-import javax.annotation.Generated;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.Processor;
@@ -747,7 +746,7 @@ private TypeSimplifier defineVarsForType(
       types.addAll(builder.get().referencedTypes());
     }
     TypeElement generatedTypeElement =
-        processingEnv.getElementUtils().getTypeElement(Generated.class.getName());
+        processingEnv.getElementUtils().getTypeElement("javax.annotation.Generated");
     if (generatedTypeElement != null) {
       types.add(generatedTypeElement.asType());
     }

File: value/src/main/java/com/google/auto/value/processor/BuilderMethodClassifier.java
Patch:
@@ -416,8 +416,8 @@ private boolean checkSetterParameter(ExecutableElement valueGetter, ExecutableEl
       return canMakeCopyUsing(copyOfMethods, valueGetter, setter);
     }
     String error = String.format(
-        "Parameter type of setter method should be %s to match getter %s.%s",
-        targetType, autoValueClass, valueGetter.getSimpleName());
+        "Parameter type %s of setter method should be %s to match getter %s.%s",
+        parameterType, targetType, autoValueClass, valueGetter.getSimpleName());
     errorReporter.reportError(error, setter);
     return false;
   }

File: value/src/test/java/com/google/auto/value/processor/CompilationTest.java
Patch:
@@ -1068,7 +1068,7 @@ public void autoValueBuilderWrongTypeSetter() {
         .processedWith(new AutoValueProcessor(), new AutoValueBuilderProcessor())
         .failsToCompile()
         .withErrorContaining(
-            "Parameter type of setter method should be int to match getter foo.bar.Baz.blim")
+            "Parameter type java.lang.String of setter method should be int to match getter foo.bar.Baz.blim")
         .in(javaFileObject).onLine(12);
   }
 
@@ -1165,7 +1165,7 @@ public void autoValueBuilderWrongTypeSetterWithGetPrefix() {
         .processedWith(new AutoValueProcessor(), new AutoValueBuilderProcessor())
         .failsToCompile()
         .withErrorContaining(
-            "Parameter type of setter method should be int to match getter foo.bar.Baz.getBlim")
+            "Parameter type java.lang.String of setter method should be int to match getter foo.bar.Baz.getBlim")
         .in(javaFileObject).onLine(12);
   }
 

File: common/src/main/java/com/google/auto/common/MoreElements.java
Patch:
@@ -310,7 +310,7 @@ public static ImmutableSet<ExecutableElement> getLocalAndInheritedMethods(
     // TODO(emcmanus): detect if the Types and Elements are the javac ones, and use
     //   NativeOverrides if so. We may need to adjust the logic further to avoid the bug
     //   tested for by MoreElementsTest.getLocalAndInheritedMethods_DaggerBug.
-    Overrides overrides = new Overrides.ExplicitOverrides(typeUtils, elementUtils);
+    Overrides overrides = new Overrides.ExplicitOverrides(typeUtils);
     return getLocalAndInheritedMethods(type, overrides);
   }
 

File: value/src/main/java/com/google/auto/value/processor/AbstractMethodLister.java
Patch:
@@ -55,7 +55,7 @@ private static class RecordingClassVisitor extends ClassVisitor {
     private final ImmutableList.Builder<String> abstractNoArgMethods = ImmutableList.builder();
 
     RecordingClassVisitor() {
-      super(Opcodes.ASM4);
+      super(Opcodes.ASM5);
     }
 
     @Override

File: common/src/main/java/com/google/auto/common/AnnotationMirrors.java
Patch:
@@ -74,7 +74,7 @@ public static Equivalence<AnnotationMirror> equivalence() {
    * {@link ExecutableElement}, supplying default values from the annotation if the
    * annotation property has not been set.  This is equivalent to
    * {@link Elements#getElementValuesWithDefaults(AnnotationMirror)} but can be called
-   * statically without an {@Elements} instance.
+   * statically without an {@link Elements} instance.
    */
   public static Map<ExecutableElement, AnnotationValue> getAnnotationValuesWithDefaults(
       AnnotationMirror annotation) {

File: common/src/main/java/com/google/auto/common/MoreElements.java
Patch:
@@ -270,7 +270,7 @@ public boolean apply(Element input) {
    * @param type the type whose own and inherited methods are to be returned
    * @param elementUtils an {@link Elements} object, typically returned by
    *     {@link javax.annotation.processing.AbstractProcessor#processingEnv processingEnv}<!--
-   *     -->.{@link javax.annotation.processing.ProcessingEnvironment.getElementUtils()
+   *     -->.{@link javax.annotation.processing.ProcessingEnvironment#getElementUtils
    *     getElementUtils()}
    *
    * @deprecated The method {@link #getLocalAndInheritedMethods(TypeElement, Types, Elements)}
@@ -298,11 +298,11 @@ public static ImmutableSet<ExecutableElement> getLocalAndInheritedMethods(
    * @param type the type whose own and inherited methods are to be returned
    * @param typeUtils a {@link Types} object, typically returned by
    *     {@link javax.annotation.processing.AbstractProcessor#processingEnv processingEnv}<!--
-   *     -->.{@link javax.annotation.processing.ProcessingEnvironment.getTypeUtils()
+   *     -->.{@link javax.annotation.processing.ProcessingEnvironment#getTypeUtils
    *     getTypeUtils()}
    * @param elementUtils an {@link Elements} object, typically returned by
    *     {@link javax.annotation.processing.AbstractProcessor#processingEnv processingEnv}<!--
-   *     -->.{@link javax.annotation.processing.ProcessingEnvironment.getElementUtils()
+   *     -->.{@link javax.annotation.processing.ProcessingEnvironment#getElementUtils
    *     getElementUtils()}
    */
   public static ImmutableSet<ExecutableElement> getLocalAndInheritedMethods(

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -437,8 +437,8 @@ private void processType(TypeElement type) {
     // If there are abstract methods that don't fit any of the categories above, that is an error
     // which we signal explicitly to avoid confusion.
 
-    ImmutableSet<ExecutableElement> methods =
-        getLocalAndInheritedMethods(type, processingEnv.getElementUtils());
+    ImmutableSet<ExecutableElement> methods = getLocalAndInheritedMethods(
+        type, processingEnv.getTypeUtils(), processingEnv.getElementUtils());
     ImmutableSet<ExecutableElement> abstractMethods = abstractMethodsIn(methods);
 
     BuilderSpec builderSpec = new BuilderSpec(type, processingEnv, errorReporter);

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -486,7 +486,7 @@ private Optional<Builder> builderFrom(TypeElement builderTypeElement) {
   // Return a set of all abstract methods in the given TypeElement or inherited from ancestors.
   private Set<ExecutableElement> abstractMethods(TypeElement typeElement) {
     Set<ExecutableElement> methods = getLocalAndInheritedMethods(
-        typeElement, processingEnv.getElementUtils());
+        typeElement, processingEnv.getTypeUtils(), processingEnv.getElementUtils());
     ImmutableSet.Builder<ExecutableElement> abstractMethods = ImmutableSet.builder();
     for (ExecutableElement method : methods) {
       if (method.getModifiers().contains(Modifier.ABSTRACT)) {

File: factory/src/main/java/com/google/auto/factory/processor/FactoryDescriptorGenerator.java
Patch:
@@ -142,6 +142,7 @@ public boolean apply(VariableElement parameter) {
         .providedParameters(providedParameters)
         .passedParameters(passedParameters)
         .creationParameters(Parameter.forParameterList(constructor.getParameters(), types))
+        .isVarArgs(constructor.isVarArgs())
         .build();
   }
 

File: common/src/main/java/com/google/auto/common/AnnotationMirrors.java
Patch:
@@ -23,12 +23,10 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
-
 import java.lang.annotation.Annotation;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
-
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;

File: common/src/main/java/com/google/auto/common/AnnotationValues.java
Patch:
@@ -16,9 +16,7 @@
 package com.google.auto.common;
 
 import com.google.common.base.Equivalence;
-
 import java.util.List;
-
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.type.TypeMirror;

File: common/src/main/java/com/google/auto/common/BasicAnnotationProcessor.java
Patch:
@@ -35,15 +35,13 @@
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
-
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Objects;
 import java.util.Set;
-
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.ProcessingEnvironment;

File: common/src/main/java/com/google/auto/common/MoreTypes.java
Patch:
@@ -32,13 +32,11 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-
 import java.lang.reflect.Method;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
-
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;

File: common/src/main/java/com/google/auto/common/Visibility.java
Patch:
@@ -15,15 +15,15 @@
  */
 package com.google.auto.common;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.lang.model.element.ElementKind.PACKAGE;
+
 import com.google.common.collect.Ordering;
 import java.util.Set;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.PackageElement;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import static javax.lang.model.element.ElementKind.PACKAGE;
-
 /**
  * Represents the visibility of a given {@link Element}: {@code public}, {@code protected},
  * {@code private} or default/package-private.

File: factory/src/main/java/com/google/auto/factory/AutoFactory.java
Patch:
@@ -15,11 +15,11 @@
  */
 package com.google.auto.factory;
 
-import java.lang.annotation.Target;
-
 import static java.lang.annotation.ElementType.CONSTRUCTOR;
 import static java.lang.annotation.ElementType.TYPE;
 
+import java.lang.annotation.Target;
+
 /**
  * An annotation to be applied to elements for which a factory should be automatically generated.
  *

File: factory/src/main/java/com/google/auto/factory/processor/AutoFactoryProcessor.java
Patch:
@@ -19,7 +19,6 @@
 import com.google.auto.factory.AutoFactory;
 import com.google.auto.factory.Provided;
 import com.google.auto.service.AutoService;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
@@ -28,7 +27,6 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Multimaps;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collection;

File: factory/src/main/java/com/google/auto/factory/processor/Elements2.java
Patch:
@@ -22,6 +22,7 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.STATIC;
 
+import com.google.common.collect.ImmutableSet;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
@@ -31,8 +32,6 @@
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Types;
 
-import com.google.common.collect.ImmutableSet;
-
 final class Elements2 {
   private Elements2() { }
 

File: factory/src/main/java/com/google/auto/factory/processor/FactoryMethodDescriptor.java
Patch:
@@ -21,7 +21,6 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
-
 import javax.lang.model.type.TypeMirror;
 
 /**

File: factory/src/main/java/com/google/auto/factory/processor/FactoryWriter.java
Patch:
@@ -29,7 +29,6 @@
 import com.google.common.base.Throwables;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
-
 import com.google.common.collect.Iterables;
 import com.google.common.io.CharSink;
 import com.google.common.io.CharSource;
@@ -44,9 +43,7 @@
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
-
 import java.io.IOException;
-
 import java.io.Writer;
 import java.util.Iterator;
 import javax.annotation.Generated;

File: factory/src/main/java/com/google/auto/factory/processor/Parameter.java
Patch:
@@ -21,16 +21,14 @@
 
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
 import com.google.common.base.Equivalence;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
-
 import java.util.List;
 import java.util.Set;
-
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.VariableElement;

File: factory/src/main/java/com/google/auto/factory/processor/ProvidedChecker.java
Patch:
@@ -21,7 +21,6 @@
 
 import com.google.auto.factory.AutoFactory;
 import com.google.auto.factory.Provided;
-
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;

File: factory/src/main/java/com/google/auto/factory/processor/ProviderField.java
Patch:
@@ -15,15 +15,15 @@
  */
 package com.google.auto.factory.processor;
 
+import static com.google.auto.factory.processor.Mirrors.unwrapOptionalEquivalence;
+import static com.google.auto.factory.processor.Mirrors.wrapOptionalInEquivalence;
+
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import javax.lang.model.element.AnnotationMirror;
 
-import static com.google.auto.factory.processor.Mirrors.unwrapOptionalEquivalence;
-import static com.google.auto.factory.processor.Mirrors.wrapOptionalInEquivalence;
-
 @AutoValue
 abstract class ProviderField {
   abstract String name();

File: factory/src/test/resources/bad/EnumSupertype.java
Patch:
@@ -15,9 +15,8 @@
  */
 package tests;
 
-import java.util.concurrent.TimeUnit;
-
 import com.google.auto.factory.AutoFactory;
+import java.util.concurrent.TimeUnit;
 
 @AutoFactory(extending = TimeUnit.class)
 final class InterfaceSupertype {}

File: factory/src/test/resources/bad/MixedFinals.java
Patch:
@@ -15,10 +15,7 @@
  */
 package tests;
 
-import javax.annotation.Generated;
-
 import com.google.auto.factory.AutoFactory;
-import com.google.auto.factory.Provided;
 
 final class MixedFinals {
   @AutoFactory(allowSubclasses = false) MixedFinals() {}

File: factory/src/test/resources/expected/ClassUsingQualifierWithArgsFactory.java
Patch:
@@ -16,7 +16,6 @@
 package tests;
 
 import com.google.auto.factory.internal.Preconditions;
-
 import javax.annotation.Generated;
 import javax.inject.Inject;
 import javax.inject.Provider;

File: factory/src/test/resources/expected/ConstructorAnnotatedFactory.java
Patch:
@@ -16,7 +16,6 @@
 package tests;
 
 import com.google.auto.factory.internal.Preconditions;
-
 import javax.annotation.Generated;
 import javax.inject.Inject;
 import javax.inject.Provider;

File: factory/src/test/resources/expected/ConstructorAnnotatedNonFinalFactory.java
Patch:
@@ -16,7 +16,6 @@
 package tests;
 
 import com.google.auto.factory.internal.Preconditions;
-
 import javax.annotation.Generated;
 import javax.inject.Inject;
 import javax.inject.Provider;

File: factory/src/test/resources/expected/FactoryImplementingGenericInterfaceExtension.java
Patch:
@@ -16,7 +16,6 @@
 package tests;
 
 import com.google.auto.factory.internal.Preconditions;
-
 import javax.annotation.Generated;
 import javax.inject.Inject;
 import javax.inject.Provider;

File: factory/src/test/resources/expected/MixedDepsImplementingInterfacesFactory.java
Patch:
@@ -16,7 +16,6 @@
 package tests;
 
 import com.google.auto.factory.internal.Preconditions;
-
 import javax.annotation.Generated;
 import javax.inject.Inject;
 import javax.inject.Provider;

File: factory/src/test/resources/expected/MultipleProvidedParamsSameKeyFactory.java
Patch:
@@ -16,7 +16,6 @@
 package tests;
 
 import com.google.auto.factory.internal.Preconditions;
-
 import javax.annotation.Generated;
 import javax.inject.Inject;
 import javax.inject.Provider;

File: factory/src/test/resources/expected/SimpleClassMixedDepsFactory.java
Patch:
@@ -16,7 +16,6 @@
 package tests;
 
 import com.google.auto.factory.internal.Preconditions;
-
 import javax.annotation.Generated;
 import javax.inject.Inject;
 import javax.inject.Provider;

File: factory/src/test/resources/expected/SimpleClassPassedDepsFactory.java
Patch:
@@ -16,7 +16,6 @@
 package tests;
 
 import com.google.auto.factory.internal.Preconditions;
-
 import javax.annotation.Generated;
 import javax.inject.Inject;
 

File: factory/src/test/resources/expected/SimpleClassProvidedDepsFactory.java
Patch:
@@ -16,7 +16,6 @@
 package tests;
 
 import com.google.auto.factory.internal.Preconditions;
-
 import javax.annotation.Generated;
 import javax.inject.Inject;
 import javax.inject.Provider;

File: factory/src/test/resources/expected/SimpleClassProvidedProviderDepsFactory.java
Patch:
@@ -16,7 +16,6 @@
 package tests;
 
 import com.google.auto.factory.internal.Preconditions;
-
 import javax.annotation.Generated;
 import javax.inject.Inject;
 import javax.inject.Provider;

File: factory/src/test/resources/good/ConstructorAnnotatedNonFinal.java
Patch:
@@ -15,8 +15,6 @@
  */
 package tests;
 
-import javax.annotation.Generated;
-
 import com.google.auto.factory.AutoFactory;
 import com.google.auto.factory.Provided;
 

File: factory/src/test/resources/good/FactoryImplementingCreateMethod.java
Patch:
@@ -16,7 +16,6 @@
 package tests;
 
 import com.google.auto.factory.AutoFactory;
-
 import java.util.List;
 
 final class FactoryImplementingCreateMethod {

File: factory/src/test/resources/good/SimpleClassImplementingMarker.java
Patch:
@@ -13,9 +13,8 @@
  */
 package tests;
 
-import java.util.RandomAccess;
-
 import com.google.auto.factory.AutoFactory;
+import java.util.RandomAccess;
 
 @AutoFactory(implementing = RandomAccess.class)
 class SimpleClassImplementingMarker {

File: factory/src/test/resources/support/AQualifier.java
Patch:
@@ -19,7 +19,6 @@
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
-
 import javax.inject.Qualifier;
 
 /**

File: factory/src/test/resources/support/BQualifier.java
Patch:
@@ -19,7 +19,6 @@
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
-
 import javax.inject.Qualifier;
 
 /**

File: factory/src/test/resources/support/QualifierWithArgs.java
Patch:
@@ -19,7 +19,6 @@
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
-
 import javax.inject.Qualifier;
 
 /**

File: service/src/main/java/com/google/auto/service/processor/ServicesFiles.java
Patch:
@@ -17,6 +17,7 @@
 
 import static com.google.common.base.Charsets.UTF_8;
 
+import com.google.common.io.Closer;
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.IOException;
@@ -28,8 +29,6 @@
 import java.util.HashSet;
 import java.util.Set;
 
-import com.google.common.io.Closer;
-
 /**
  * A helper class for reading and writing Services files.
  */

File: service/src/test/java/com/google/auto/service/processor/AutoServiceProcessorTest.java
Patch:
@@ -20,13 +20,11 @@
 
 import com.google.auto.service.processor.AutoServiceProcessor;
 import com.google.testing.compile.JavaFileObjects;
-
+import java.util.Arrays;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.util.Arrays;
-
 /**
  * Tests the {@link AutoServiceProcessor}.
  */

File: value/src/it/functional-java8/src/main/java/PackagelessNestedValueType.java
Patch:
@@ -15,7 +15,6 @@
  */
 
 import com.google.auto.value.AutoValue;
-
 import java.util.Map;
 
 /**

File: value/src/it/functional-java8/src/main/java/PackagelessValueType.java
Patch:
@@ -15,10 +15,8 @@
  */
 
 import com.google.auto.value.AutoValue;
-
-import java.util.Map;
-
 import com.google.auto.value.annotation.Nullable;
+import java.util.Map;
 
 /**
  * Simple package-less value type for tests.

File: value/src/it/functional-java8/src/main/java/com/google/auto/value/SimpleValueType.java
Patch:
@@ -15,9 +15,8 @@
  */
 package com.google.auto.value;
 
-import java.util.Map;
-
 import com.google.auto.value.annotation.Nullable;
+import java.util.Map;
 
 /**
  * Simple value type for tests.

File: value/src/it/functional/src/main/java/PackagelessNestedValueType.java
Patch:
@@ -15,7 +15,6 @@
  */
 
 import com.google.auto.value.AutoValue;
-
 import java.util.Map;
 
 /**

File: value/src/it/functional/src/main/java/PackagelessValueType.java
Patch:
@@ -15,9 +15,7 @@
  */
 
 import com.google.auto.value.AutoValue;
-
 import java.util.Map;
-
 import javax.annotation.Nullable;
 
 /**

File: value/src/it/functional/src/main/java/com/google/auto/value/SimpleValueType.java
Patch:
@@ -16,7 +16,6 @@
 package com.google.auto.value;
 
 import java.util.Map;
-
 import javax.annotation.Nullable;
 
 /**

File: value/src/it/functional/src/test/java/PackagelessValueTypeTest.java
Patch:
@@ -16,10 +16,8 @@
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.testing.NullPointerTester;
-
-import junit.framework.TestCase;
-
 import java.util.Map;
+import junit.framework.TestCase;
 
 /**
  * @author emcmanus@google.com (Éamonn McManus)

File: value/src/it/functional/src/test/java/com/google/auto/value/SimpleValueTypeTest.java
Patch:
@@ -17,10 +17,8 @@
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.testing.NullPointerTester;
-
-import junit.framework.TestCase;
-
 import java.util.Map;
+import junit.framework.TestCase;
 
 /**
  * @author emcmanus@google.com (Éamonn McManus)

File: value/src/it/gwtserializer/src/test/java/com/google/auto/value/GwtSerializerSuite.java
Patch:
@@ -15,9 +15,9 @@
  */
 package com.google.auto.value;
 
-import junit.framework.Test;
 import com.google.auto.value.client.GwtSerializerTest;
 import com.google.gwt.junit.tools.GWTTestSuite;
+import junit.framework.Test;
 
 public class GwtSerializerSuite {
   public static Test suite() {

File: value/src/it/gwtserializer/src/test/java/com/google/auto/value/client/GwtSerializerTest.java
Patch:
@@ -15,9 +15,6 @@
  */
 package com.google.auto.value.client;
 
-import java.lang.Override;
-import java.lang.SuppressWarnings;
-
 import com.google.auto.value.AutoValue;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -27,6 +24,8 @@
 import com.google.gwt.user.client.rpc.RemoteService;
 import com.google.gwt.user.client.rpc.RemoteServiceRelativePath;
 import com.google.gwt.user.server.rpc.RemoteServiceServlet;
+import java.lang.Override;
+import java.lang.SuppressWarnings;
 
 public class GwtSerializerTest extends GWTTestCase {
 

File: value/src/main/java/com/google/auto/value/extension/AutoValueExtension.java
Patch:
@@ -18,7 +18,6 @@
 import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
-
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;

File: value/src/main/java/com/google/auto/value/processor/AbstractMethodExtractor.java
Patch:
@@ -16,7 +16,6 @@
 package com.google.auto.value.processor;
 
 import com.google.common.collect.ImmutableListMultimap;
-
 import java.util.ArrayDeque;
 import java.util.Deque;
 

File: value/src/main/java/com/google/auto/value/processor/AnnotationOutput.java
Patch:
@@ -16,10 +16,8 @@
 package com.google.auto.value.processor;
 
 import com.google.common.collect.ImmutableMap;
-
 import java.util.List;
 import java.util.Map;
-
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;

File: value/src/main/java/com/google/auto/value/processor/AutoAnnotationProcessor.java
Patch:
@@ -24,7 +24,6 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.primitives.Primitives;
-
 import java.io.IOException;
 import java.io.Writer;
 import java.util.Arrays;
@@ -33,7 +32,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-
 import javax.annotation.Generated;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.ProcessingEnvironment;

File: value/src/main/java/com/google/auto/value/processor/AutoAnnotationTemplateVars.java
Patch:
@@ -16,7 +16,6 @@
 package com.google.auto.value.processor;
 
 import com.google.auto.value.processor.escapevelocity.Template;
-
 import java.util.Map;
 import java.util.Set;
 import java.util.SortedSet;

File: value/src/main/java/com/google/auto/value/processor/AutoValueBuilderProcessor.java
Patch:
@@ -22,9 +22,7 @@
 import com.google.auto.service.AutoService;
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableSet;
-
 import java.util.Set;
-
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.Processor;
 import javax.annotation.processing.RoundEnvironment;

File: value/src/main/java/com/google/auto/value/processor/AutoValueTemplateVars.java
Patch:
@@ -21,7 +21,6 @@
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
-
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.util.Types;
 

File: value/src/main/java/com/google/auto/value/processor/BuilderMethodClassifier.java
Patch:
@@ -29,11 +29,9 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Sets;
-
 import java.beans.Introspector;
 import java.util.Map;
 import java.util.Set;
-
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -31,10 +31,8 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
-
 import java.util.Map;
 import java.util.Set;
-
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;

File: value/src/main/java/com/google/auto/value/processor/EclipseHack.java
Patch:
@@ -20,7 +20,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
-
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStream;
@@ -36,7 +35,6 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Callable;
-
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;

File: value/src/main/java/com/google/auto/value/processor/ErrorReporter.java
Patch:
@@ -15,8 +15,6 @@
  */
 package com.google.auto.value.processor;
 
-import com.google.auto.value.AutoValue;
-
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Element;

File: value/src/main/java/com/google/auto/value/processor/ExtensionContext.java
Patch:
@@ -18,10 +18,8 @@
 import com.google.auto.value.extension.AutoValueExtension;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-
 import java.util.Map;
 import java.util.Set;
-
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;

File: value/src/main/java/com/google/auto/value/processor/GwtCompatibility.java
Patch:
@@ -18,11 +18,9 @@
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.collect.Lists;
-
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.ExecutableElement;

File: value/src/main/java/com/google/auto/value/processor/GwtSerialization.java
Patch:
@@ -18,7 +18,6 @@
 import com.google.auto.value.processor.escapevelocity.Template;
 import com.google.common.base.Optional;
 import com.google.common.collect.Multimap;
-
 import java.io.IOException;
 import java.io.Writer;
 import java.nio.charset.Charset;
@@ -27,7 +26,6 @@
 import java.util.Map;
 import java.util.SortedSet;
 import java.util.zip.CRC32;
-
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;

File: value/src/main/java/com/google/auto/value/processor/Java8Support.java
Patch:
@@ -18,7 +18,6 @@
 import java.lang.reflect.Method;
 import java.util.Collections;
 import java.util.List;
-
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.type.TypeMirror;
 

File: value/src/main/java/com/google/auto/value/processor/Optionalish.java
Patch:
@@ -21,9 +21,7 @@
 import com.google.common.base.Verify;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-
 import java.util.List;
-
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;

File: value/src/main/java/com/google/auto/value/processor/SimpleNameFunction.java
Patch:
@@ -16,7 +16,6 @@
 package com.google.auto.value.processor;
 
 import com.google.common.base.Function;
-
 import javax.lang.model.element.Element;
 
 enum SimpleNameFunction implements Function<Element, String> {

File: value/src/main/java/com/google/auto/value/processor/TemplateVars.java
Patch:
@@ -19,7 +19,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
-
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;

File: value/src/main/java/com/google/auto/value/processor/TypeMirrorSet.java
Patch:
@@ -17,13 +17,11 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
-
 import java.util.AbstractSet;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
-
 import javax.lang.model.type.TypeMirror;
 
 /**

File: value/src/main/java/com/google/auto/value/processor/TypeSimplifier.java
Patch:
@@ -21,13 +21,11 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSortedSet;
-
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.PackageElement;

File: value/src/main/java/com/google/auto/value/processor/escapevelocity/DirectiveNode.java
Patch:
@@ -34,7 +34,6 @@
 
 import com.google.common.base.Verify;
 import com.google.common.collect.ImmutableList;
-
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.Map;

File: value/src/main/java/com/google/auto/value/processor/escapevelocity/Macro.java
Patch:
@@ -35,7 +35,6 @@
 import com.google.common.base.Verify;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Maps;
-
 import java.util.List;
 import java.util.Map;
 

File: value/src/main/java/com/google/auto/value/processor/escapevelocity/Parser.java
Patch:
@@ -54,7 +54,6 @@
 import com.google.common.collect.Iterables;
 import com.google.common.primitives.Chars;
 import com.google.common.primitives.Ints;
-
 import java.io.IOException;
 import java.io.LineNumberReader;
 import java.io.Reader;

File: value/src/main/java/com/google/auto/value/processor/escapevelocity/ReferenceNode.java
Patch:
@@ -37,7 +37,6 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.primitives.Primitives;
-
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;

File: value/src/main/java/com/google/auto/value/processor/escapevelocity/Reparser.java
Patch:
@@ -52,7 +52,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-
 import java.util.Map;
 import java.util.Set;
 

File: value/src/main/java/com/google/auto/value/processor/escapevelocity/Template.java
Patch:
@@ -33,7 +33,6 @@
 package com.google.auto.value.processor.escapevelocity;
 
 import com.google.auto.value.processor.escapevelocity.EvaluationContext.PlainEvaluationContext;
-
 import java.io.IOException;
 import java.io.Reader;
 import java.util.Map;

File: value/src/main/java/com/google/auto/value/processor/escapevelocity/TokenNode.java
Patch:
@@ -33,7 +33,6 @@
 package com.google.auto.value.processor.escapevelocity;
 
 import com.google.common.collect.ImmutableList;
-
 import java.util.List;
 
 /**

File: value/src/test/java/com/google/auto/value/processor/AbstractMethodExtractorTest.java
Patch:
@@ -16,10 +16,8 @@
 package com.google.auto.value.processor;
 
 import com.google.common.collect.ImmutableMultimap;
-
-import junit.framework.TestCase;
-
 import java.io.StringReader;
+import junit.framework.TestCase;
 
 /**
  * Tests for {@link AbstractMethodExtractor}.

File: value/src/test/java/com/google/auto/value/processor/AbstractMethodListerTest.java
Patch:
@@ -15,11 +15,10 @@
  */
 package com.google.auto.value.processor;
 
-import junit.framework.TestCase;
-
 import java.io.InputStream;
 import java.util.Arrays;
 import java.util.List;
+import junit.framework.TestCase;
 
 /**
  * Tests for {@link AbstractMethodLister}.

File: value/src/test/java/com/google/auto/value/processor/AutoAnnotationErrorsTest.java
Patch:
@@ -21,10 +21,8 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
-
-import junit.framework.TestCase;
-
 import javax.tools.JavaFileObject;
+import junit.framework.TestCase;
 
 /**
  * Tests for compilation errors with the AutoAnnotation processor.

File: value/src/test/java/com/google/auto/value/processor/EclipseHackTokenizerTest.java
Patch:
@@ -15,9 +15,8 @@
  */
 package com.google.auto.value.processor;
 
-import junit.framework.TestCase;
-
 import java.io.StringReader;
+import junit.framework.TestCase;
 
 /**
  * Unit tests for {@link EclipseHackTokenizer}.

File: value/src/test/java/com/google/auto/value/processor/JavaScannerTest.java
Patch:
@@ -19,7 +19,6 @@
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
-
 import junit.framework.TestCase;
 
 /**

File: value/src/test/java/com/google/auto/value/processor/TemplateVarsTest.java
Patch:
@@ -17,13 +17,11 @@
 
 import com.google.auto.value.processor.escapevelocity.Template;
 import com.google.common.collect.ImmutableList;
-
-import junit.framework.TestCase;
-
 import java.io.IOException;
 import java.io.Reader;
 import java.io.StringReader;
 import java.util.List;
+import junit.framework.TestCase;
 
 /**
  * Tests for FieldReader.

File: common/src/main/java/com/google/auto/common/MoreTypes.java
Patch:
@@ -520,7 +520,7 @@ public static Element asElement(TypeMirror typeMirror) {
   private static final TypeVisitor<Element, Void> AS_ELEMENT_VISITOR =
       new SimpleTypeVisitor6<Element, Void>() {
         @Override protected Element defaultAction(TypeMirror e, Void p) {
-          throw new IllegalArgumentException(e + "cannot be converted to an Element");
+          throw new IllegalArgumentException(e + " cannot be converted to an Element");
         }
 
         @Override public Element visitDeclared(DeclaredType t, Void p) {

File: value/src/it/functional/src/test/java/com/google/auto/value/AutoValueTest.java
Patch:
@@ -809,6 +809,7 @@ public boolean equals(Object o) {
     }
   }
 
+  @SuppressWarnings("SelfEquals")
   public void testExplicitEquals() throws Exception {
     ExplicitEquals instance = ExplicitEquals.create();
     assertEquals(0, instance.equalsCount);

File: factory/src/test/resources/expected/ClassUsingQualifierWithArgsFactory.java
Patch:
@@ -30,7 +30,7 @@ final class ClassUsingQualifierWithArgsFactory {
 
   @Inject ClassUsingQualifierWithArgsFactory(
       @QualifierWithArgs(name="Fred", count=3) Provider<String> providedDepAProvider) {
-    this.providedDepAProvider = providedDepAProvider;
+    this.providedDepAProvider = Preconditions.checkNotNull(providedDepAProvider, 1);
   }
 
   ClassUsingQualifierWithArgs create() {

File: factory/src/test/resources/expected/ConstructorAnnotatedFactory.java
Patch:
@@ -29,7 +29,7 @@ final class ConstructorAnnotatedFactory {
   private final Provider<Object> objProvider;
 
   @Inject ConstructorAnnotatedFactory(Provider<Object> objProvider) {
-    this.objProvider = objProvider;
+    this.objProvider = Preconditions.checkNotNull(objProvider, 1);
   }
 
   ConstructorAnnotated create() {

File: factory/src/test/resources/expected/ConstructorAnnotatedNonFinalFactory.java
Patch:
@@ -29,7 +29,7 @@ class ConstructorAnnotatedNonFinalFactory {
   private final Provider<Object> objProvider;
 
   @Inject ConstructorAnnotatedNonFinalFactory(Provider<Object> objProvider) {
-    this.objProvider = objProvider;
+    this.objProvider = Preconditions.checkNotNull(objProvider, 1);
   }
 
   ConstructorAnnotatedNonFinal create() {

File: factory/src/test/resources/expected/CustomNullableFactory.java
Patch:
@@ -15,6 +15,7 @@
  */
 package tests;
 
+import com.google.auto.factory.internal.Preconditions;
 import javax.annotation.Generated;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -29,7 +30,7 @@ final class CustomNullableFactory {
 
   @Inject
   CustomNullableFactory(Provider<Object> objectProvider) {
-    this.objectProvider = objectProvider;
+    this.objectProvider = Preconditions.checkNotNull(objectProvider, 1);
   }
 
   CustomNullable create(@CustomNullable.Nullable String string) {

File: factory/src/test/resources/expected/FactoryImplementingGenericInterfaceExtension.java
Patch:
@@ -30,7 +30,7 @@ final class FactoryImplementingGenericInterfaceExtensionFactory
   private final Provider<String> sProvider;
   @Inject
   FactoryImplementingGenericInterfaceExtensionFactory(Provider<String> sProvider) {
-    this.sProvider = sProvider;
+    this.sProvider = Preconditions.checkNotNull(sProvider, 1);
   }
   FactoryImplementingGenericInterfaceExtension create(Integer i) {
     return new FactoryImplementingGenericInterfaceExtension(

File: factory/src/test/resources/expected/MixedDepsImplementingInterfacesFactory.java
Patch:
@@ -34,7 +34,7 @@ final class MixedDepsImplementingInterfacesFactory
   private final Provider<String> sProvider;
 
   @Inject MixedDepsImplementingInterfacesFactory(Provider<String> sProvider) {
-    this.sProvider = sProvider;
+    this.sProvider = Preconditions.checkNotNull(sProvider, 1);
   }
 
   MixedDepsImplementingInterfaces create(int i) {

File: factory/src/test/resources/expected/SimpleClassMixedDepsFactory.java
Patch:
@@ -30,7 +30,7 @@ final class SimpleClassMixedDepsFactory {
 
   @Inject SimpleClassMixedDepsFactory(
       @AQualifier Provider<String> providedDepAProvider) {
-    this.providedDepAProvider = providedDepAProvider;
+    this.providedDepAProvider = Preconditions.checkNotNull(providedDepAProvider, 1);
   }
 
   SimpleClassMixedDeps create(String depB) {

File: factory/src/test/resources/expected/CustomNamedFactory.java
Patch:
@@ -25,7 +25,7 @@
 final class CustomNamedFactory {
   @Inject CustomNamedFactory() {}
 
-  SimpleClass create() {
-    return new SimpleClass();
+  SimpleClassCustomName create() {
+    return new SimpleClassCustomName();
   }
 }

File: factory/src/test/resources/good/SimpleClassCustomName.java
Patch:
@@ -18,4 +18,4 @@
 import com.google.auto.factory.AutoFactory;
 
 @AutoFactory(className = "CustomNamedFactory")
-final class SimpleClass {}
+final class SimpleClassCustomName {}

File: value/src/test/java/com/google/auto/value/processor/AutoAnnotationCompilationTest.java
Patch:
@@ -285,7 +285,7 @@ public void testCollectionsForArrays() {
         "    if (enums == null) {",
         "      throw new NullPointerException(\"Null enums\");",
         "    }",
-        "    this.enums = enums.toArray(new MyEnum[enums.size()];",
+        "    this.enums = enums.toArray(new MyEnum[0];",
         "  }",
         "",
         "  @Override public Class<? extends MyAnnotation> annotationType() {",

File: factory/src/test/resources/expected/CustomNamedFactory.java
Patch:
@@ -19,8 +19,8 @@
 import javax.inject.Inject;
 
 @Generated(
-  value = "com.google.auto.factory.processor.AutoFactoryProcessor",
-  comments = "https://github.com/google/auto/tree/master/factory"
+    value = "com.google.auto.factory.processor.AutoFactoryProcessor",
+    comments = "https://github.com/google/auto/tree/master/factory"
 )
 final class CustomNamedFactory {
   @Inject CustomNamedFactory() {}

File: factory/src/test/resources/expected/MultipleFactoriesImplementingInterface_ClassAFactory.java
Patch:
@@ -19,8 +19,8 @@
 import javax.inject.Inject;
 
 @Generated(
-  value = "com.google.auto.factory.processor.AutoFactoryProcessor",
-  comments = "https://github.com/google/auto/tree/master/factory"
+    value = "com.google.auto.factory.processor.AutoFactoryProcessor",
+    comments = "https://github.com/google/auto/tree/master/factory"
 )
 final class MultipleFactoriesImplementingInterface_ClassAFactory
     implements MultipleFactoriesImplementingInterface.Base.Factory {

File: factory/src/test/resources/expected/MultipleFactoriesImplementingInterface_ClassBFactory.java
Patch:
@@ -19,8 +19,8 @@
 import javax.inject.Inject;
 
 @Generated(
-  value = "com.google.auto.factory.processor.AutoFactoryProcessor",
-  comments = "https://github.com/google/auto/tree/master/factory"
+    value = "com.google.auto.factory.processor.AutoFactoryProcessor",
+    comments = "https://github.com/google/auto/tree/master/factory"
 )
 final class MultipleFactoriesImplementingInterface_ClassBFactory
     implements MultipleFactoriesImplementingInterface.Base.Factory {

File: factory/src/test/resources/expected/NestedClasses_CustomNamedFactory.java
Patch:
@@ -19,8 +19,8 @@
 import javax.inject.Inject;
 
 @Generated(
-  value = "com.google.auto.factory.processor.AutoFactoryProcessor",
-  comments = "https://github.com/google/auto/tree/master/factory"
+    value = "com.google.auto.factory.processor.AutoFactoryProcessor",
+    comments = "https://github.com/google/auto/tree/master/factory"
 )
 final class NestedClasses_CustomNamedFactory {
   @Inject NestedClasses_CustomNamedFactory() {}

File: factory/src/test/resources/expected/NestedClasses_SimpleNestedClassFactory.java
Patch:
@@ -19,8 +19,8 @@
 import javax.inject.Inject;
 
 @Generated(
-  value = "com.google.auto.factory.processor.AutoFactoryProcessor",
-  comments = "https://github.com/google/auto/tree/master/factory"
+    value = "com.google.auto.factory.processor.AutoFactoryProcessor",
+    comments = "https://github.com/google/auto/tree/master/factory"
 )
 final class NestedClasses_SimpleNestedClassFactory {
   @Inject NestedClasses_SimpleNestedClassFactory() {}

File: factory/src/test/resources/expected/PublicClassFactory.java
Patch:
@@ -19,8 +19,8 @@
 import javax.inject.Inject;
 
 @Generated(
-  value = "com.google.auto.factory.processor.AutoFactoryProcessor",
-  comments = "https://github.com/google/auto/tree/master/factory"
+    value = "com.google.auto.factory.processor.AutoFactoryProcessor",
+    comments = "https://github.com/google/auto/tree/master/factory"
 )
 public final class PublicClassFactory {
   @Inject public PublicClassFactory() {}

File: factory/src/test/resources/expected/SimpleClassFactory.java
Patch:
@@ -19,8 +19,8 @@
 import javax.inject.Inject;
 
 @Generated(
-  value = "com.google.auto.factory.processor.AutoFactoryProcessor",
-  comments = "https://github.com/google/auto/tree/master/factory"
+    value = "com.google.auto.factory.processor.AutoFactoryProcessor",
+    comments = "https://github.com/google/auto/tree/master/factory"
 )
 final class SimpleClassFactory {
   @Inject SimpleClassFactory() {}

File: factory/src/test/resources/expected/SimpleClassImplementingMarkerFactory.java
Patch:
@@ -20,8 +20,8 @@
 import javax.inject.Inject;
 
 @Generated(
-  value = "com.google.auto.factory.processor.AutoFactoryProcessor",
-  comments = "https://github.com/google/auto/tree/master/factory"
+    value = "com.google.auto.factory.processor.AutoFactoryProcessor",
+    comments = "https://github.com/google/auto/tree/master/factory"
 )
 final class SimpleClassImplementingMarkerFactory implements RandomAccess {
   @Inject SimpleClassImplementingMarkerFactory() {}

File: factory/src/test/resources/expected/SimpleClassImplementingSimpleInterfaceFactory.java
Patch:
@@ -19,8 +19,8 @@
 import javax.inject.Inject;
 
 @Generated(
-  value = "com.google.auto.factory.processor.AutoFactoryProcessor",
-  comments = "https://github.com/google/auto/tree/master/factory"
+    value = "com.google.auto.factory.processor.AutoFactoryProcessor",
+    comments = "https://github.com/google/auto/tree/master/factory"
 )
 final class SimpleClassImplementingSimpleInterfaceFactory
     implements SimpleClassImplementingSimpleInterface.SimpleInterface {

File: factory/src/test/resources/expected/SimpleClassNonFinalFactory.java
Patch:
@@ -19,8 +19,8 @@
 import javax.inject.Inject;
 
 @Generated(
-  value = "com.google.auto.factory.processor.AutoFactoryProcessor",
-  comments = "https://github.com/google/auto/tree/master/factory"
+    value = "com.google.auto.factory.processor.AutoFactoryProcessor",
+    comments = "https://github.com/google/auto/tree/master/factory"
 )
 class SimpleClassNonFinalFactory {
   @Inject SimpleClassNonFinalFactory() {}

File: factory/src/test/resources/good/ConstructorAnnotated.java
Patch:
@@ -15,6 +15,8 @@
  */
 package tests;
 
+import javax.annotation.Generated;
+
 import com.google.auto.factory.AutoFactory;
 import com.google.auto.factory.Provided;
 

File: value/src/it/functional-java8/src/test/java/com/google/auto/value/SimpleValueTypeTest.java
Patch:
@@ -20,10 +20,10 @@
 
 import junit.framework.TestCase;
 
-import java.util.Map;
-
 import org.junit.Ignore;
 
+import java.util.Map;
+
 /**
  * @author emcmanus@google.com (Éamonn McManus)
  */

File: value/src/main/java/com/google/auto/value/processor/BuilderMethodClassifier.java
Patch:
@@ -368,7 +368,7 @@ private void checkForFailedJavaBean(ExecutableElement rejectedSetter) {
   /**
    * Checks that the given setter method has a parameter type that is compatible with the return
    * type of the given getter. Compatible means either that it is the same, or that it is a type
-   * that can be copied using a method like {@code ImmutableList.copyOf}.
+   * that can be copied using a method like {@code ImmutableList.copyOf} or {@code Optional.of}.
    *
    * @return true if the types correspond, false if an error has been reported.
    */
@@ -459,11 +459,12 @@ private ImmutableList<ExecutableElement> copyOfMethods(TypeMirror targetType) {
     if (!targetType.getKind().equals(TypeKind.DECLARED)) {
       return ImmutableList.of();
     }
+    String copyOf = Optionalish.isOptional(targetType) ? "of" : "copyOf";
     TypeElement immutableTargetType = MoreElements.asType(typeUtils.asElement(targetType));
     ImmutableList.Builder<ExecutableElement> copyOfMethods = ImmutableList.builder();
     for (ExecutableElement method :
         ElementFilter.methodsIn(immutableTargetType.getEnclosedElements())) {
-      if (method.getSimpleName().contentEquals("copyOf")
+      if (method.getSimpleName().contentEquals(copyOf)
           && method.getParameters().size() == 1
           && method.getModifiers().contains(Modifier.STATIC)) {
         copyOfMethods.add(method);

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -227,7 +227,9 @@ void defineVars(
 
       Set<Property> required = Sets.newLinkedHashSet(vars.props);
       for (Property property : vars.props) {
-        if (property.isNullable() || vars.builderPropertyBuilders.containsKey(property.getName())) {
+        if (property.isNullable()
+            || property.getOptional() != null
+            || vars.builderPropertyBuilders.containsKey(property.getName())) {
           required.remove(property);
         }
       }

File: value/src/test/java/com/google/auto/value/processor/CompilationErrorsTest.java
Patch:
@@ -127,7 +127,7 @@ public void testNoWarningsFromGenerics() throws Exception {
   }
 
   private static final Pattern CANNOT_HAVE_NON_PROPERTIES = Pattern.compile(
-      "@AutoValue classes cannot have abstract methods other than property getters");
+      "Abstract method is neither a property getter nor a Builder converter");
 
   public void testAbstractVoid() throws Exception {
     String testSourceCode = Joiner.on('\n').join(

File: value/src/main/java/com/google/auto/value/processor/EclipseHack.java
Patch:
@@ -168,7 +168,7 @@ private void reorderProperties(TypeElement type, List<Property> properties) {
     final ImmutableList<String> order;
     try {
       order = propertyOrderer.determinePropertyOrder();
-    } catch (IOException e) {
+    } catch (Exception e) {
       processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, e.toString());
       return;
     }

File: service/src/main/java/com/google/auto/service/AutoService.java
Patch:
@@ -16,8 +16,10 @@
 package com.google.auto.service;
 
 import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.SOURCE;
 
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 /**
@@ -34,6 +36,7 @@
  * </ul>
  */
 @Documented
+@Retention(SOURCE)
 @Target(TYPE)
 public @interface AutoService {
   /** Returns the interface implemented by this service provider. */

File: value/src/test/java/com/google/auto/value/processor/PropertyAnnotationsTest.java
Patch:
@@ -184,9 +184,9 @@ private void assertGeneratedMatches(
 
   public void testSimpleAnnotation() {
     assertGeneratedMatches(
-        ImmutableList.of("import javax.annotation.Nullable;"),
-        ImmutableList.of("@Nullable"),
-        ImmutableList.of("@Nullable"));
+        ImmutableList.of("import javax.annotation.Resource;"),
+        ImmutableList.of("@Resource"),
+        ImmutableList.of("@Resource"));
   }
 
   public void testSingleStringValueAnnotation() {

File: value/src/test/java/com/google/auto/value/processor/CompilationTest.java
Patch:
@@ -719,7 +719,7 @@ public void correctBuilder() throws Exception {
         "",
         "    @Override",
         "    public Baz.Builder<T> aNullableIntArray(@Nullable int[] aNullableIntArray) {",
-        "      this.aNullableIntArray = aNullableIntArray == null ? null : aNullableIntArray;",
+        "      this.aNullableIntArray = aNullableIntArray;",
         "      return this;",
         "    }",
         "",

File: value/src/test/java/com/google/auto/value/processor/CompilationTest.java
Patch:
@@ -719,7 +719,7 @@ public void correctBuilder() throws Exception {
         "",
         "    @Override",
         "    public Baz.Builder<T> aNullableIntArray(@Nullable int[] aNullableIntArray) {",
-        "      this.aNullableIntArray = aNullableIntArray;",
+        "      this.aNullableIntArray = aNullableIntArray == null ? null : aNullableIntArray;",
         "      return this;",
         "    }",
         "",

File: value/src/test/java/com/google/auto/value/processor/TypeSimplifierTest.java
Patch:
@@ -316,9 +316,9 @@ public void testTypeMirrorSet() {
       assertTrue(set.contains(otherObjectMirror));
 
       assertFalse(set.contains(null));
-      assertFalse(set.contains("foo"));
+      assertFalse(set.contains((Object) "foo"));
       assertFalse(set.remove(null));
-      assertFalse(set.remove("foo"));
+      assertFalse(set.remove((Object) "foo"));
 
       TypeElement list = typeElementOf("java.util.List");
       TypeMirror listOfObjectMirror = typeUtil.getDeclaredType(list, objectMirror);

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -380,8 +380,9 @@ private void processType(TypeElement type) {
           + " interface; try using @AutoAnnotation instead", type);
     }
 
-    ImmutableSet<ExecutableElement> methods = getLocalAndInheritedMethods(type, processingEnv.getElementUtils());
-    ImmutableSet<ExecutableElement> methodsToImplement = methodsToImplement(methods);
+    ImmutableSet<ExecutableElement> methods =
+        getLocalAndInheritedMethods(type, processingEnv.getElementUtils());
+    ImmutableSet<ExecutableElement> methodsToImplement = methodsToImplement(type, methods);
 
     String fqExtClass = TypeSimplifier.classNameOf(type);
     List<AutoValueExtension> appliedExtensions = new ArrayList<AutoValueExtension>();

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -380,8 +380,9 @@ private void processType(TypeElement type) {
           + " interface; try using @AutoAnnotation instead", type);
     }
 
-    ImmutableSet<ExecutableElement> methods = getLocalAndInheritedMethods(type, processingEnv.getElementUtils());
-    ImmutableSet<ExecutableElement> methodsToImplement = methodsToImplement(methods);
+    ImmutableSet<ExecutableElement> methods =
+        getLocalAndInheritedMethods(type, processingEnv.getElementUtils());
+    ImmutableSet<ExecutableElement> methodsToImplement = methodsToImplement(type, methods);
 
     String fqExtClass = TypeSimplifier.classNameOf(type);
     List<AutoValueExtension> appliedExtensions = new ArrayList<AutoValueExtension>();

File: common/src/main/java/com/google/auto/common/BasicAnnotationProcessor.java
Patch:
@@ -18,6 +18,7 @@
 import com.google.common.base.Ascii;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -307,7 +308,7 @@ private void process(ImmutableSetMultimap<Class<? extends Annotation>, Element>
       ImmutableSetMultimap<Class<? extends Annotation>, Element> stepElements =
           new ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element>()
               .putAll(indexByAnnotation(elementsDeferredBySteps.get(step)))
-              .putAll(filterKeys(validElements, in(step.annotations())))
+              .putAll(filterKeys(validElements, Predicates.<Object>in(step.annotations())))
               .build();
       if (stepElements.isEmpty()) {
         elementsDeferredBySteps.removeAll(step);

File: value/src/main/java/com/google/auto/value/processor/AnnotationOutput.java
Patch:
@@ -159,7 +159,8 @@ private class AnnotationSourceFormVisitor extends SourceFormVisitor {
     @Override
     public Void visitAnnotation(AnnotationMirror a, StringBuilder sb) {
       sb.append('@').append(typeSimplifier.simplify(a.getAnnotationType()));
-      Map<ExecutableElement, AnnotationValue> map = ImmutableMap.copyOf(a.getElementValues());
+      Map<ExecutableElement, AnnotationValue> map =
+          ImmutableMap.<ExecutableElement, AnnotationValue>copyOf(a.getElementValues());
       if (!map.isEmpty()) {
         sb.append('(');
         String sep = "";

File: value/src/main/java/com/google/auto/value/processor/GwtCompatibility.java
Patch:
@@ -51,7 +51,8 @@ Optional<AnnotationMirror> gwtCompatibleAnnotation() {
   // Get rid of the misconceived <? extends ExecutableElement, ? extends AnnotationValue>
   // in the return type of getElementValues().
   static Map<ExecutableElement, AnnotationValue> getElementValues(AnnotationMirror annotation) {
-    return Collections.unmodifiableMap(annotation.getElementValues());
+    return Collections.<ExecutableElement, AnnotationValue>unmodifiableMap(
+        annotation.getElementValues());
   }
 
   String gwtCompatibleAnnotationString() {

File: factory/src/test/resources/good/MultipleFactoriesImplementingInterface.java
Patch:
@@ -25,8 +25,8 @@ static interface Factory {
   }
 
   @AutoFactory(implementing = Base.Factory.class)
-  static class MultipleFactoriesImplementingInterfaceA implements Base { }
+  static class ClassA implements Base { }
 
   @AutoFactory(implementing = Base.Factory.class)
-  static class MultipleFactoriesImplementingInterfaceB implements Base {}
+  static class ClassB implements Base {}
 }  

File: factory/src/it/functional/src/main/java/com/google/auto/factory/GuiceModule.java
Patch:
@@ -21,5 +21,7 @@ public class GuiceModule extends AbstractModule {
   @Override protected void configure() {
     bind(Dependency.class).to(DependencyImpl.class);
     bind(Dependency.class).annotatedWith(Qualifier.class).to(QualifiedDependencyImpl.class);
+    bind(Integer.class).toInstance(1);
+    bind(Integer.class).annotatedWith(Qualifier.class).toInstance(2);
   }
 }

File: factory/src/main/java/com/google/auto/factory/processor/FactoryWriter.java
Patch:
@@ -132,9 +132,9 @@ public String apply(Parameter parameter) {
                       if (methodDescriptor.passedParameters().contains(parameter)) {
                         return parameter.name();
                       } else if (parameter.providerOfType()) {
-                        return descriptor.providerNames().get(parameter.asKey());
+                        return descriptor.providerNames().get(parameter.key());
                       } else {
-                        return descriptor.providerNames().get(parameter.asKey()) + ".get()";
+                        return descriptor.providerNames().get(parameter.key()) + ".get()";
                       }
                     }
                   });

File: value/src/main/java/com/google/auto/value/processor/escapevelocity/Template.java
Patch:
@@ -37,7 +37,6 @@
 import java.io.IOException;
 import java.io.Reader;
 import java.util.Map;
-import java.util.TreeMap;
 
 /**
  * A template expressed in EscapeVelocity, a subset of the Velocity Template Language (VTL) from
@@ -72,8 +71,7 @@ public static Template parseFrom(Reader reader) throws IOException {
    * @return the string result of evaluating the template.
    */
   public String evaluate(Map<String, Object> vars) {
-    Map<String, Object> varsCopy = new TreeMap<String, Object>(vars);
-    EvaluationContext evaluationContext = new EvaluationContext(varsCopy);
+    EvaluationContext evaluationContext = new EvaluationContext(vars);
     return String.valueOf(root.evaluate(evaluationContext));
   }
 }

File: factory/src/main/java/com/google/auto/factory/processor/FactoryDescriptorGenerator.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.google.auto.factory.processor;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -138,7 +139,7 @@ public Name visitTypeAsClass(TypeElement e, Void p) {
             new Predicate<VariableElement>() {
               @Override
               public boolean apply(VariableElement parameter) {
-                return parameter.getAnnotation(Provided.class) != null;
+                return isAnnotationPresent(parameter, Provided.class);
               }
             }));
     ImmutableSet<Parameter> providedParameters = Parameter.forParameterList(parameterMap.get(true));

File: factory/src/main/java/com/google/auto/factory/processor/FactoryWriter.java
Patch:
@@ -38,7 +38,7 @@
 
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
-import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Modifier;
 import javax.tools.JavaFileObject;
 
@@ -101,8 +101,8 @@ void writeFactory(final FactoryDescriptor descriptor)
       Key key = entry.getKey();
       String providerName = entry.getValue();
       writer.emitField("Provider<" + key.getType() + ">", providerName, EnumSet.of(PRIVATE, FINAL));
-      Optional<String> qualifier = key.getQualifier();
-      String qualifierPrefix = qualifier.isPresent() ? "@" + qualifier.get() + " " : "";
+      Optional<AnnotationMirror> qualifier = key.getQualifier();
+      String qualifierPrefix = qualifier.isPresent() ? qualifier.get() + " " : "";
       constructorTokens.add(qualifierPrefix + "Provider<" + key.getType() + ">").add(providerName);
     }
 

File: factory/src/main/java/com/google/auto/factory/processor/ProvidedChecker.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.google.auto.factory.processor;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
@@ -35,7 +36,7 @@ final class ProvidedChecker {
   }
 
   void checkProvidedParameter(Element element) {
-    checkArgument(element.getAnnotation(Provided.class) != null, "%s not annoated with @Provided",
+    checkArgument(isAnnotationPresent(element, Provided.class), "%s not annoated with @Provided",
         element);
     element.accept(new ElementKindVisitor6<Void, Void>() {
       @Override
@@ -73,6 +74,6 @@ private void raiseError(VariableElement providedParameter, String messageFormat)
   }
 
   private static boolean annotatedWithAutoFactory(Element e) {
-    return e.getAnnotation(AutoFactory.class) != null;
+    return isAnnotationPresent(e, AutoFactory.class);
   }
 }

File: factory/src/main/java/com/google/auto/factory/processor/FactoryDescriptorGenerator.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.google.auto.factory.processor;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -139,7 +138,7 @@ public Name visitTypeAsClass(TypeElement e, Void p) {
             new Predicate<VariableElement>() {
               @Override
               public boolean apply(VariableElement parameter) {
-                return isAnnotationPresent(parameter, Provided.class);
+                return parameter.getAnnotation(Provided.class) != null;
               }
             }));
     ImmutableSet<Parameter> providedParameters = Parameter.forParameterList(parameterMap.get(true));

File: factory/src/main/java/com/google/auto/factory/processor/FactoryWriter.java
Patch:
@@ -38,7 +38,7 @@
 
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
-import javax.lang.model.element.AnnotationMirror;
+import javax.inject.Inject;
 import javax.lang.model.element.Modifier;
 import javax.tools.JavaFileObject;
 
@@ -101,8 +101,8 @@ void writeFactory(final FactoryDescriptor descriptor)
       Key key = entry.getKey();
       String providerName = entry.getValue();
       writer.emitField("Provider<" + key.getType() + ">", providerName, EnumSet.of(PRIVATE, FINAL));
-      Optional<AnnotationMirror> qualifier = key.getQualifier();
-      String qualifierPrefix = qualifier.isPresent() ? qualifier.get() + " " : "";
+      Optional<String> qualifier = key.getQualifier();
+      String qualifierPrefix = qualifier.isPresent() ? "@" + qualifier.get() + " " : "";
       constructorTokens.add(qualifierPrefix + "Provider<" + key.getType() + ">").add(providerName);
     }
 

File: factory/src/main/java/com/google/auto/factory/processor/ProvidedChecker.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.google.auto.factory.processor;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
@@ -36,7 +35,7 @@ final class ProvidedChecker {
   }
 
   void checkProvidedParameter(Element element) {
-    checkArgument(isAnnotationPresent(element, Provided.class), "%s not annoated with @Provided",
+    checkArgument(element.getAnnotation(Provided.class) != null, "%s not annoated with @Provided",
         element);
     element.accept(new ElementKindVisitor6<Void, Void>() {
       @Override
@@ -74,6 +73,6 @@ private void raiseError(VariableElement providedParameter, String messageFormat)
   }
 
   private static boolean annotatedWithAutoFactory(Element e) {
-    return isAnnotationPresent(e, AutoFactory.class);
+    return e.getAnnotation(AutoFactory.class) != null;
   }
 }

File: factory/src/main/java/com/google/auto/factory/processor/FactoryDescriptorGenerator.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.google.auto.factory.processor;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -138,7 +139,7 @@ public Name visitTypeAsClass(TypeElement e, Void p) {
             new Predicate<VariableElement>() {
               @Override
               public boolean apply(VariableElement parameter) {
-                return parameter.getAnnotation(Provided.class) != null;
+                return isAnnotationPresent(parameter, Provided.class);
               }
             }));
     ImmutableSet<Parameter> providedParameters = Parameter.forParameterList(parameterMap.get(true));

File: factory/src/main/java/com/google/auto/factory/processor/FactoryWriter.java
Patch:
@@ -38,7 +38,7 @@
 
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
-import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Modifier;
 import javax.tools.JavaFileObject;
 
@@ -101,8 +101,8 @@ void writeFactory(final FactoryDescriptor descriptor)
       Key key = entry.getKey();
       String providerName = entry.getValue();
       writer.emitField("Provider<" + key.getType() + ">", providerName, EnumSet.of(PRIVATE, FINAL));
-      Optional<String> qualifier = key.getQualifier();
-      String qualifierPrefix = qualifier.isPresent() ? "@" + qualifier.get() + " " : "";
+      Optional<AnnotationMirror> qualifier = key.getQualifier();
+      String qualifierPrefix = qualifier.isPresent() ? qualifier.get() + " " : "";
       constructorTokens.add(qualifierPrefix + "Provider<" + key.getType() + ">").add(providerName);
     }
 

File: factory/src/main/java/com/google/auto/factory/processor/ProvidedChecker.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.google.auto.factory.processor;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
@@ -35,7 +36,7 @@ final class ProvidedChecker {
   }
 
   void checkProvidedParameter(Element element) {
-    checkArgument(element.getAnnotation(Provided.class) != null, "%s not annoated with @Provided",
+    checkArgument(isAnnotationPresent(element, Provided.class), "%s not annoated with @Provided",
         element);
     element.accept(new ElementKindVisitor6<Void, Void>() {
       @Override
@@ -73,6 +74,6 @@ private void raiseError(VariableElement providedParameter, String messageFormat)
   }
 
   private static boolean annotatedWithAutoFactory(Element e) {
-    return e.getAnnotation(AutoFactory.class) != null;
+    return isAnnotationPresent(e, AutoFactory.class);
   }
 }

File: value/src/test/java/com/google/auto/value/processor/escapevelocity/TemplateTest.java
Patch:
@@ -193,17 +193,17 @@ public void substituteIndexThenProperty() {
 
   @Test
   public void variableNameCantStartWithNonAscii() {
-    compare("<$Éamonn>", ImmutableMap.of());
+    compare("<$Éamonn>", ImmutableMap.<String, Object>of());
   }
 
   @Test
   public void variableNamesAreAscii() {
-    compare("<$Pádraig>", ImmutableMap.of("P", "(P)"));
+    compare("<$Pádraig>", ImmutableMap.of("P", (Object) "(P)"));
   }
 
   @Test
   public void variableNameCharacters() {
-    compare("<AZaz-foo_bar23>", ImmutableMap.of("AZaz-foo_bar23", "(P)"));
+    compare("<AZaz-foo_bar23>", ImmutableMap.of("AZaz-foo_bar23", (Object) "(P)"));
   }
 
   public static class Indexable {

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -410,12 +410,14 @@ private void processType(TypeElement type) {
       }
     }
 
+    String finalSubclass = generatedSubclassName(type, 0);
     String subclass = generatedSubclassName(type, appliedExtensions.size());
     AutoValueTemplateVars vars = new AutoValueTemplateVars();
     vars.pkg = TypeSimplifier.packageNameOf(type);
     vars.origClass = fqExtClass;
     vars.simpleClassName = TypeSimplifier.simpleNameOf(vars.origClass);
     vars.subclass = TypeSimplifier.simpleNameOf(subclass);
+    vars.finalSubclass = TypeSimplifier.simpleNameOf(finalSubclass);
     vars.isFinal = appliedExtensions.isEmpty();
     vars.types = processingEnv.getTypeUtils();
     defineVarsForType(type, vars, methods);

File: value/src/test/java/com/google/auto/value/processor/CompilationErrorsTest.java
Patch:
@@ -141,7 +141,7 @@ public void testAbstractVoid() throws Exception {
         "  public abstract void foo();\n" +
         "}\n";
     ImmutableMultimap<Diagnostic.Kind, Pattern> expectedDiagnostics = ImmutableMultimap.of(
-//        Diagnostic.Kind.WARNING, CANNOT_HAVE_NON_PROPERTIES,
+        Diagnostic.Kind.WARNING, CANNOT_HAVE_NON_PROPERTIES,
         Diagnostic.Kind.ERROR, Pattern.compile("AutoValue_Baz")
     );
     assertCompilationResultIs(expectedDiagnostics, ImmutableList.of(testSourceCode));
@@ -156,7 +156,7 @@ public void testAbstractWithParams() throws Exception {
         "  public abstract int foo(int bar);\n" +
         "}\n";
     ImmutableMultimap<Diagnostic.Kind, Pattern> expectedDiagnostics = ImmutableMultimap.of(
-//        Diagnostic.Kind.WARNING, CANNOT_HAVE_NON_PROPERTIES,
+        Diagnostic.Kind.WARNING, CANNOT_HAVE_NON_PROPERTIES,
         Diagnostic.Kind.ERROR, Pattern.compile("AutoValue_Baz")
     );
     assertCompilationResultIs(expectedDiagnostics, ImmutableList.of(testSourceCode));

File: value/src/test/java/com/google/auto/value/processor/ExtensionTest.java
Patch:
@@ -76,7 +76,7 @@ public void testExtensionCompilation() throws Exception {
         "  public int hashCode() {",
         "    int h = 1;",
         "    h *= 1000003;",
-        "    h ^= foo.hashCode();",
+        "    h ^= this.foo.hashCode();",
         "    return h;",
         "  }",
         "",
@@ -176,9 +176,9 @@ public void testExtensionWithBuilderCompilation() throws Exception {
         "  public int hashCode() {",
         "    int h = 1;",
         "    h *= 1000003;",
-        "    h ^= foo.hashCode();",
+        "    h ^= this.foo.hashCode();",
         "    h *= 1000003;",
-        "    h ^= bar.hashCode();",
+        "    h ^= this.bar.hashCode();",
         "    return h;",
         "  }",
         "",

File: value/src/test/java/com/google/auto/value/processor/ExtensionTest.java
Patch:
@@ -212,7 +212,7 @@ public boolean applicable(Context context) {
     }
 
     @Override
-    public boolean mustBeAtEnd() {
+    public boolean mustBeAtEnd(Context context) {
       return true;
     }
 

File: value/src/main/java/com/google/auto/value/AutoValueExtension.java
Patch:
@@ -21,7 +21,10 @@ public interface Context {
   public interface GeneratedClass {
     String className();
     String source();
+    Collection<String> additionalImports();
     Collection<ExecutableElement> consumedProperties();
+    Collection<String> additionalInterfaces();
+    Collection<String> additionalCode();
   }
 
   boolean applicable(Context context);

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -419,6 +419,7 @@ private void defineVarsForType(TypeElement type, AutoValueTemplateVars vars) {
     ImmutableSet<ExecutableElement> toBuilderMethods;
     if (builder.isPresent()) {
       toBuilderMethods = builder.get().toBuilderMethods(typeUtils, methodsToImplement);
+      types.addAll(builder.get().referencedTypes());
     } else {
       toBuilderMethods = ImmutableSet.of();
     }

File: value/src/main/java/com/google/auto/value/processor/GwtSerialization.java
Patch:
@@ -244,7 +244,7 @@ private void writeSourceFile(String className, String text, TypeElement originat
 
   private static final Charset UTF8 = Charset.forName("UTF-8");
 
-  private String computeClassHash(List<AutoValueProcessor.Property> props) {
+  private String computeClassHash(Iterable<AutoValueProcessor.Property> props) {
     TypeSimplifier typeSimplifier = new TypeSimplifier(
         processingEnv.getTypeUtils(), "", new TypeMirrorSet(), null);
     CRC32 crc = new CRC32();

File: value/src/main/java/com/google/auto/value/processor/Reformatter.java
Patch:
@@ -78,7 +78,7 @@ private static String compressBlankLines(String s) {
   private static String compressSpace(String s) {
     // Remove extra spaces. An "extra" space is one that is not part of the indentation at the start
     // of a line, and where the next character is also a space or a right paren or a semicolon
-    // or a comma, or the preceding character is a left paren.
+    // or a dot or a comma, or the preceding character is a left paren.
     // TODO(emcmanus): consider merging all three passes using this tokenization approach.
     StringBuilder sb = new StringBuilder(s.length());
     Tokenizer tokenizer = new Tokenizer(s);
@@ -95,7 +95,7 @@ private static String compressSpace(String s) {
         // Since we ensure that the tokenized string ends with \n, and a whitespace token stops
         // at \n, it is safe to look at end.
         char nextC = s.charAt(end);
-        if (",;)".indexOf(nextC) >= 0) {
+        if (".,;)".indexOf(nextC) >= 0) {
           continue;
         }
         sb.append(' ');

File: factory/src/main/java/com/google/auto/factory/processor/AutoFactoryProcessor.java
Patch:
@@ -70,7 +70,7 @@ public final class AutoFactoryProcessor extends AbstractProcessor {
   @Override
   public synchronized void init(ProcessingEnvironment processingEnv) {
     super.init(processingEnv);
-    Dagger_AutoFactoryProcessorComponent.builder()
+    DaggerAutoFactoryProcessorComponent.builder()
         .processorModule(new ProcessorModule(processingEnv))
         .build()
         .injectProcessor(this);

File: value/src/test/java/com/google/auto/value/processor/CompilationTest.java
Patch:
@@ -545,7 +545,7 @@ public void testCorrectBuilder() throws Exception {
         "  private final List<T> aList;",
         "",
         "  private AutoValue_Baz("
-            + "int anInt, byte[] aByteArray, int[] aNullableIntArray, List<T> aList) {",
+            + "int anInt, byte[] aByteArray, @javax.annotation.Nullable int[] aNullableIntArray, List<T> aList) {",
         "    this.anInt = anInt;",
         "    if (aByteArray == null) {",
         "      throw new NullPointerException(\"Null aByteArray\");",

File: value/src/test/java/com/google/auto/value/processor/CompilationTest.java
Patch:
@@ -545,7 +545,7 @@ public void testCorrectBuilder() throws Exception {
         "  private final List<T> aList;",
         "",
         "  private AutoValue_Baz("
-            + "int anInt, byte[] aByteArray, int[] aNullableIntArray, List<T> aList) {",
+            + "int anInt, byte[] aByteArray, @javax.annotation.Nullable int[] aNullableIntArray, List<T> aList) {",
         "    this.anInt = anInt;",
         "    if (aByteArray == null) {",
         "      throw new NullPointerException(\"Null aByteArray\");",

File: common/src/main/java/com/google/auto/common/MoreTypes.java
Patch:
@@ -16,8 +16,8 @@
 package com.google.auto.common;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.EXECUTABLE;

File: common/src/main/java/com/google/auto/common/MoreTypes.java
Patch:
@@ -16,8 +16,8 @@
 package com.google.auto.common;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.EXECUTABLE;

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -159,8 +159,9 @@ ExecutableElement buildMethod() {
      * (for example not every getter has a setter, or some setters don't correspond to getters)
      * then emits an error message and returns null.
      *
-     * @param getterToPropertyName a list of getter methods, such as {@code abstract String foo();}
-     * or {@code abstract String getFoo();}.
+     * @param getterToPropertyName a map where the keys are getter methods, such as
+     *     {@code abstract String foo();} or {@code abstract String getFoo();}, and the values are
+     *     the corresponding properties, such as {@code foo}.
      */
     private Map<String, ExecutableElement> makeSetterMap(
         Map<ExecutableElement, String> getterToPropertyName) {

File: value/src/main/java/com/google/auto/value/processor/BuilderSpec.java
Patch:
@@ -59,7 +59,6 @@ class BuilderSpec {
   private static final Equivalence<TypeMirror> TYPE_EQUIVALENCE = MoreTypes.equivalence();
 
   private final TypeElement autoValueClass;
-  private final Types typeUtils;
   private final Elements elementUtils;
   private final ErrorReporter errorReporter;
 
@@ -68,7 +67,6 @@ class BuilderSpec {
       ProcessingEnvironment processingEnv,
       ErrorReporter errorReporter) {
     this.autoValueClass = autoValueClass;
-    this.typeUtils = processingEnv.getTypeUtils();
     this.elementUtils = processingEnv.getElementUtils();
     this.errorReporter = errorReporter;
   }
@@ -431,7 +429,7 @@ private void addAbstractMethods(
       return;
     }
 
-    TypeElement typeElement = MoreTypes.asTypeElement(typeUtils, typeMirror);
+    TypeElement typeElement = MoreTypes.asTypeElement(typeMirror);
     addAbstractMethods(typeElement.getSuperclass(), abstractMethods);
     for (TypeMirror interfaceMirror : typeElement.getInterfaces()) {
       addAbstractMethods(interfaceMirror, abstractMethods);

File: factory/src/main/java/com/google/auto/factory/processor/FactoryDescriptor.java
Patch:
@@ -45,12 +45,12 @@ public boolean matches(char c) {
   private final ImmutableSortedSet<String> implementingTypes;
   private final boolean publicType;
   private final ImmutableSet<FactoryMethodDescriptor> methodDescriptors;
-  private final ImmutableSet<ImplemetationMethodDescriptor> implementationMethodDescriptors;
+  private final ImmutableSet<ImplementationMethodDescriptor> implementationMethodDescriptors;
   private final ImmutableMap<Key, String> providerNames;
 
   FactoryDescriptor(String name, String extendingType, ImmutableSortedSet<String> implementingTypes,
       boolean publicType, ImmutableSet<FactoryMethodDescriptor> methodDescriptors,
-      ImmutableSet<ImplemetationMethodDescriptor> implementationMethodDescriptors) {
+      ImmutableSet<ImplementationMethodDescriptor> implementationMethodDescriptors) {
     this.name = checkNotNull(name);
     this.extendingType = checkNotNull(extendingType);
     this.implementingTypes = checkNotNull(implementingTypes);
@@ -101,7 +101,7 @@ ImmutableSet<FactoryMethodDescriptor> methodDescriptors() {
     return methodDescriptors;
   }
 
-  ImmutableSet<ImplemetationMethodDescriptor> implementationMethodDescriptors() {
+  ImmutableSet<ImplementationMethodDescriptor> implementationMethodDescriptors() {
     return implementationMethodDescriptors;
   }
 

File: factory/src/main/java/com/google/auto/factory/processor/FactoryWriter.java
Patch:
@@ -131,7 +131,7 @@ void writeFactory(final FactoryDescriptor descriptor)
       writer.endMethod();
     }
 
-    for (ImplemetationMethodDescriptor methodDescriptor
+    for (ImplementationMethodDescriptor methodDescriptor
         : descriptor.implementationMethodDescriptors()) {
       writer.emitAnnotation(Override.class);
       writer.beginMethod(methodDescriptor.returnType(), methodDescriptor.name(),

File: factory/src/main/java/com/google/auto/factory/processor/FactoryDescriptor.java
Patch:
@@ -45,12 +45,12 @@ public boolean matches(char c) {
   private final ImmutableSortedSet<String> implementingTypes;
   private final boolean publicType;
   private final ImmutableSet<FactoryMethodDescriptor> methodDescriptors;
-  private final ImmutableSet<ImplemetationMethodDescriptor> implementationMethodDescriptors;
+  private final ImmutableSet<ImplementationMethodDescriptor> implementationMethodDescriptors;
   private final ImmutableMap<Key, String> providerNames;
 
   FactoryDescriptor(String name, String extendingType, ImmutableSortedSet<String> implementingTypes,
       boolean publicType, ImmutableSet<FactoryMethodDescriptor> methodDescriptors,
-      ImmutableSet<ImplemetationMethodDescriptor> implementationMethodDescriptors) {
+      ImmutableSet<ImplementationMethodDescriptor> implementationMethodDescriptors) {
     this.name = checkNotNull(name);
     this.extendingType = checkNotNull(extendingType);
     this.implementingTypes = checkNotNull(implementingTypes);
@@ -101,7 +101,7 @@ ImmutableSet<FactoryMethodDescriptor> methodDescriptors() {
     return methodDescriptors;
   }
 
-  ImmutableSet<ImplemetationMethodDescriptor> implementationMethodDescriptors() {
+  ImmutableSet<ImplementationMethodDescriptor> implementationMethodDescriptors() {
     return implementationMethodDescriptors;
   }
 

File: factory/src/main/java/com/google/auto/factory/processor/FactoryWriter.java
Patch:
@@ -131,7 +131,7 @@ void writeFactory(final FactoryDescriptor descriptor)
       writer.endMethod();
     }
 
-    for (ImplemetationMethodDescriptor methodDescriptor
+    for (ImplementationMethodDescriptor methodDescriptor
         : descriptor.implementationMethodDescriptors()) {
       writer.emitAnnotation(Override.class);
       writer.beginMethod(methodDescriptor.returnType(), methodDescriptor.name(),

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -429,8 +429,8 @@ private void defineVarsForType(TypeElement type, AutoValueTemplateVars vars) {
     vars.actualTypes = typeSimplifier.actualTypeParametersString(type);
     vars.wildcardTypes = wildcardTypeParametersString(type);
     // Check for @AutoValue.Builder and add appropriate variables if it is present.
-    if (builder.isPresent() && builder.get().validSetters(methodToPropertyName)) {
-      builder.get().defineVars(vars, typeSimplifier);
+    if (builder.isPresent()) {
+      builder.get().defineVars(vars, typeSimplifier, methodToPropertyName);
     }
   }
 

File: value/src/test/java/com/google/auto/value/processor/TypeSimplifierTest.java
Patch:
@@ -378,7 +378,7 @@ public void testTypeMirrorSetWildcardCapture() {
       }
       TypeVariable superU = (TypeVariable) captureOne.getTypeArguments().get(1);
       assertTrue(typeMirrorSet.add(superU));
-      assertFalse(typeMirrorSet.add(superU.getLowerBound()));  // We already added U
+      assertTrue(typeMirrorSet.add(superU.getLowerBound()));
     }
 
     public void testPackageNameOfString() {

File: common/src/main/java/com/google/auto/common/SuperficialValidation.java
Patch:
@@ -95,7 +95,7 @@ && validateElements(e.getTypeParameters())
       };
 
   public static boolean validateElement(Element element) {
-     return element.accept(ELEMENT_VALIDATING_VISITOR, null);
+    return element.accept(ELEMENT_VALIDATING_VISITOR, null);
   }
 
   private static boolean isValidBaseElement(Element e) {

File: value/src/main/java/com/google/auto/value/processor/TypeSimplifier.java
Patch:
@@ -80,7 +80,7 @@ private static class Spelling {
    *     because nested classes in that class or one of its ancestors are in scope in the generated
    *     subclass, so a reference to another class with the same name as one of them is ambiguous.
    *
-   * @throws AbortProcessingException if one of the input types contains an error (typically,
+   * @throws MissingTypeException if one of the input types contains an error (typically,
    *     is undefined). This may be something like {@code UndefinedClass}, or something more subtle
    *     like {@code Set<UndefinedClass<?>>}.
    */
@@ -357,7 +357,7 @@ private static class ReferencedClassTypeVisitor extends SimpleTypeVisitor6<Void,
     }
 
     @Override public Void visitError(ErrorType t, Void p) {
-      throw new AbortProcessingException();
+      throw new MissingTypeException();
     }
   }
 
@@ -390,7 +390,7 @@ private static Set<String> ambiguousNames(Types typeUtils, Set<TypeMirror> types
     Set<String> simpleNames = new HashSet<String>();
     for (TypeMirror type : types) {
       if (type.getKind() == TypeKind.ERROR) {
-        throw new AbortProcessingException();
+        throw new MissingTypeException();
       }
       String simpleName = typeUtils.asElement(type).getSimpleName().toString();
       if (!simpleNames.add(simpleName)) {

File: value/src/test/java/com/google/auto/value/processor/TypeSimplifierTest.java
Patch:
@@ -659,7 +659,7 @@ public void testErrorTypes() {
         try {
           new TypeSimplifier(typeUtil, "foo.bar", ImmutableSet.of(typeWithError), javaLangObject);
           fail("Expected exception for type: " + typeWithError);
-        } catch (AbortProcessingException expected) {
+        } catch (MissingTypeException expected) {
         }
       }
     }

File: value/src/main/java/com/google/auto/value/processor/TypeSimplifier.java
Patch:
@@ -80,7 +80,7 @@ private static class Spelling {
    *     because nested classes in that class or one of its ancestors are in scope in the generated
    *     subclass, so a reference to another class with the same name as one of them is ambiguous.
    *
-   * @throws AbortProcessingException if one of the input types contains an error (typically,
+   * @throws MissingTypeException if one of the input types contains an error (typically,
    *     is undefined). This may be something like {@code UndefinedClass}, or something more subtle
    *     like {@code Set<UndefinedClass<?>>}.
    */
@@ -357,7 +357,7 @@ private static class ReferencedClassTypeVisitor extends SimpleTypeVisitor6<Void,
     }
 
     @Override public Void visitError(ErrorType t, Void p) {
-      throw new AbortProcessingException();
+      throw new MissingTypeException();
     }
   }
 
@@ -390,7 +390,7 @@ private static Set<String> ambiguousNames(Types typeUtils, Set<TypeMirror> types
     Set<String> simpleNames = new HashSet<String>();
     for (TypeMirror type : types) {
       if (type.getKind() == TypeKind.ERROR) {
-        throw new AbortProcessingException();
+        throw new MissingTypeException();
       }
       String simpleName = typeUtils.asElement(type).getSimpleName().toString();
       if (!simpleNames.add(simpleName)) {

File: value/src/test/java/com/google/auto/value/processor/TypeSimplifierTest.java
Patch:
@@ -659,7 +659,7 @@ public void testErrorTypes() {
         try {
           new TypeSimplifier(typeUtil, "foo.bar", ImmutableSet.of(typeWithError), javaLangObject);
           fail("Expected exception for type: " + typeWithError);
-        } catch (AbortProcessingException expected) {
+        } catch (MissingTypeException expected) {
         }
       }
     }

File: value/src/main/java/com/google/auto/value/processor/TemplateVars.java
Patch:
@@ -52,6 +52,7 @@ abstract class TemplateVars {
   static {
     // Ensure that $undefinedvar will produce an exception rather than outputting $undefinedvar.
     velocityRuntimeInstance.setProperty(RuntimeConstants.RUNTIME_REFERENCES_STRICT, "true");
+    velocityRuntimeInstance.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM_CLASS, "org.apache.velocity.runtime.log.NullLogChute" );
 
     // Velocity likes its "managers", LogManager and ResourceManager, which it loads through the
     // context class loader. If that loader can see another copy of Velocity then that will lead

File: common/src/main/java/com/google/auto/common/SuperficialValidation.java
Patch:
@@ -181,15 +181,18 @@ private static boolean validateAnnotation(AnnotationMirror annotationMirror) {
         && validateAnnotationValues(annotationMirror.getElementValues());
   }
 
+  @SuppressWarnings("unused")
   private static boolean validateAnnotationValues(
       Map<? extends ExecutableElement, ? extends AnnotationValue> valueMap) {
+    /* TODO(gak): Enable when b/17584340 is resolved.
     for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> valueEntry :
         valueMap.entrySet()) {
       TypeMirror expectedType = valueEntry.getKey().getReturnType();
       if (!validateAnnotationValue(valueEntry.getValue(), expectedType)) {
         return false;
       }
     }
+    */
     return true;
   }
 

File: common/src/test/java/com/google/auto/common/SuperficialValidationTest.java
Patch:
@@ -203,6 +203,8 @@ public void missingIntersection() {
         .failsToCompile();
   }
 
+  // TODO(gak): Enable when b/17584340 is resolved.
+  /*
   @Test
   public void invalidAnnotationValue() {
     JavaFileObject javaFileObject = JavaFileObjects.forSourceLines("test.Outer",
@@ -227,6 +229,7 @@ public void invalidAnnotationValue() {
           }
         }).failsToCompile();
   }
+  */
 
   private static abstract class AssertingProcessor extends AbstractProcessor {
     @Override

File: common/src/test/java/com/google/auto/common/MoreTypesTest.java
Patch:
@@ -238,7 +238,6 @@ private static final class ReferencedTypesTestData {
     Set<? super String> f12;
   }
 
-
   private static final ErrorType FAKE_ERROR_TYPE = new ErrorType() {
     @Override
     public TypeKind getKind() {

File: common/src/test/java/com/google/auto/common/SuperficialValidationTest.java
Patch:
@@ -228,7 +228,6 @@ public void invalidAnnotationValue() {
         }).failsToCompile();
   }
 
-
   private static abstract class AssertingProcessor extends AbstractProcessor {
     @Override
     public Set<String> getSupportedAnnotationTypes() {

File: factory/src/main/java/com/google/auto/factory/processor/AutoFactoryDeclaration.java
Patch:
@@ -62,7 +62,6 @@ private AutoFactoryDeclaration(Element target, Optional<String> className,
     this.implementingTypes = implementingTypes;
   }
 
-
   String getFactoryName(Name packageName, Name targetType) {
     StringBuilder builder = new StringBuilder(packageName);
     if (packageName.length() > 0) {
@@ -92,7 +91,6 @@ ImmutableSet<TypeElement> implementingTypes() {
     return implementingTypes;
   }
 
-
   static final class Factory {
     private final Elements elements;
     private final Messager messager;

File: factory/src/main/java/com/google/auto/factory/processor/AutoFactoryProcessor.java
Patch:
@@ -134,7 +134,6 @@ private void doProcess(Set<? extends TypeElement> annotations, RoundEnvironment
         }
       }
 
-
       ImmutableSet<FactoryMethodDescriptor> descriptors =
           factoryDescriptorGenerator.generateDescriptor(element);
       indexedMethods.putAll(

File: factory/src/main/java/com/google/auto/factory/processor/FactoryWriter.java
Patch:
@@ -102,7 +102,6 @@ void writeFactory(final FactoryDescriptor descriptor)
       constructorTokens.add(qualifierPrefix + "Provider<" + key.getType() + ">").add(providerName);
     }
 
-
     writer.emitAnnotation("Inject");
     writer.beginMethod(null, factoryName,
         descriptor.publicType() ? EnumSet.of(PUBLIC) : EnumSet.noneOf(Modifier.class),

File: factory/src/main/java/com/google/auto/factory/processor/Mirrors.java
Patch:
@@ -31,7 +31,6 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
 
-
 final class Mirrors {
   private Mirrors() { }
 

File: factory/src/main/java/com/google/auto/factory/processor/Parameter.java
Patch:
@@ -39,7 +39,6 @@ final class Parameter {
   private final String type;
   private final String name;
 
-
   private Parameter(Optional<String> qualifier, String type, String name) {
     this.qualifier = checkNotNull(qualifier);
     this.type = checkNotNull(type);

File: common/src/test/java/com/google/auto/common/MoreElementsTest.java
Patch:
@@ -25,6 +25,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+
 import javax.lang.model.element.Element;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;

File: value/src/main/java/com/google/auto/value/processor/GwtSerialization.java
Patch:
@@ -21,7 +21,6 @@
 import java.io.Writer;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.SortedSet;
@@ -32,7 +31,6 @@
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
@@ -195,7 +193,7 @@ private void writeSourceFile(String className, String text, TypeElement originat
 
   private String computeClassHash(List<AutoValueProcessor.Property> props) {
     TypeSimplifier typeSimplifier = new TypeSimplifier(
-        processingEnv.getTypeUtils(), "", Collections.<TypeMirror>emptySet(), null);
+        processingEnv.getTypeUtils(), "", new TypeMirrorSet(), null);
     CRC32 crc = new CRC32();
     update(crc, typeSimplifier.simplify(type.asType()) + ":");
     for (AutoValueProcessor.Property prop : props) {

File: common/src/test/java/com/google/auto/common/MoreElementsTest.java
Patch:
@@ -25,6 +25,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+
 import javax.lang.model.element.Element;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;

File: value/src/main/java/com/google/auto/value/processor/GwtSerialization.java
Patch:
@@ -21,7 +21,6 @@
 import java.io.Writer;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.SortedSet;
@@ -32,7 +31,6 @@
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
@@ -195,7 +193,7 @@ private void writeSourceFile(String className, String text, TypeElement originat
 
   private String computeClassHash(List<AutoValueProcessor.Property> props) {
     TypeSimplifier typeSimplifier = new TypeSimplifier(
-        processingEnv.getTypeUtils(), "", Collections.<TypeMirror>emptySet(), null);
+        processingEnv.getTypeUtils(), "", new TypeMirrorSet(), null);
     CRC32 crc = new CRC32();
     update(crc, typeSimplifier.simplify(type.asType()) + ":");
     for (AutoValueProcessor.Property prop : props) {

File: value/src/test/java/com/google/auto/value/processor/CompilationTest.java
Patch:
@@ -63,7 +63,7 @@ public void testCompilation() {
         "final class AutoValue_Baz extends Baz {",
         "  private final int buh;",
         "",
-        "  Auto_Baz(int buh) {",
+        "  AutoValue_Baz(int buh) {",
         "    this.buh = buh;",
         "  }",
         "",

File: value/src/test/java/com/google/auto/value/processor/CompilationTest.java
Patch:
@@ -63,7 +63,7 @@ public void testCompilation() {
         "final class AutoValue_Baz extends Baz {",
         "  private final int buh;",
         "",
-        "  Auto_Baz(int buh) {",
+        "  AutoValue_Baz(int buh) {",
         "    this.buh = buh;",
         "  }",
         "",

File: common/src/test/java/com/google/auto/common/MoreElementsTest.java
Patch:
@@ -23,13 +23,15 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
-
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 
+@RunWith(JUnit4.class)
 public class MoreElementsTest {
   @Rule public CompilationRule compilation = new CompilationRule();
 

File: value/src/main/java/com/google/auto/value/processor/AutoValueTemplateVars.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.SortedSet;
 
 /**
- * The template for AutoValue_Foo classes, and the variables to substitute into that template.
+ * The variables to substitute into the autovalue.vm template.
  *
  * @author emcmanus@google.com (Éamonn McManus)
  */
@@ -78,7 +78,7 @@ class AutoValueTemplateVars extends TemplateVars {
    */
   String wildcardTypes;
 
-  private static final SimpleNode TEMPLATE = parsedTemplateForResource("template.vm");
+  private static final SimpleNode TEMPLATE = parsedTemplateForResource("autovalue.vm");
 
   @Override
   SimpleNode parsedTemplate() {

File: value/src/main/java/com/google/auto/value/processor/GwtSerialization.java
Patch:
@@ -201,7 +201,7 @@ private String computeClassHash(List<AutoValueProcessor.Property> props) {
     for (AutoValueProcessor.Property prop : props) {
       update(crc, prop.toString() + ":" + prop.getType() + ";");
     }
-    return String.format("%8x", crc.getValue());
+    return String.format("%08x", crc.getValue());
   }
 
   private static void update(CRC32 crc, String s) {

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -134,12 +134,12 @@ private void process(RoundEnvironment roundEnv) {
         // We abandoned this type, but continue with the next.
       } catch (RuntimeException e) {
         // Don't propagate this exception, which will confusingly crash the compiler.
-        reportError("@AutoValue processor threw an exception: " + e, type);
+        // Instead, report a compiler error with the stack trace.
         StringWriter writer = new StringWriter();
         PrintWriter printWriter = new PrintWriter(writer);
         e.printStackTrace(printWriter);
         printWriter.flush();
-        note(writer.toString());
+        reportError("@AutoValue processor threw an exception: " + writer, type);
       }
     }
   }

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -420,7 +420,8 @@ private void defineVarsForType(TypeElement type, AutoValueTemplateVars vars)
       types.add(javaUtilArrays);
     }
     String pkg = TypeSimplifier.packageNameOf(type);
-    TypeSimplifier typeSimplifier = new TypeSimplifier(processingEnv.getTypeUtils(), pkg, types);
+    TypeSimplifier typeSimplifier =
+        new TypeSimplifier(processingEnv.getTypeUtils(), pkg, types, type.asType());
     vars.imports = typeSimplifier.typesToImport();
     vars.javaUtilArraysSpelling = typeSimplifier.simplify(javaUtilArrays);
     List<Property> props = new ArrayList<Property>();

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -63,7 +63,7 @@
  * @author Éamonn McManus
  */
 @AutoService(Processor.class)
-@SupportedOptions(EclipseHack.ENABLING_OPTION)
+@SupportedOptions({EclipseHack.ENABLING_OPTION, EclipseHack.ENABLING_OPTION_BATCH })
 public class AutoValueProcessor extends AbstractProcessor {
   private static final boolean SILENT = true;
 

File: value/src/main/java/com/google/auto/value/AutoValue.java
Patch:
@@ -35,9 +35,6 @@
  *
  * @see <a href="http://goo.gl/Ter394">AutoValue User's Guide</a>
  *
- * <!-- MOE:begin_intracomment_strip -->
- * @see <a href="http://go/autovalue">Additional Google-internal information<a/>
- * <!-- MOE:end_intracomment_strip -->
  *
  * @author Éamonn McManus
  * @author Kevin Bourrillion

File: factory/src/main/java/com/google/auto/factory/processor/AutoFactoryProcessor.java
Patch:
@@ -81,8 +81,8 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
     try {
       doProcess(annotations, roundEnv);
     } catch (Throwable e) {
-      messager.printMessage(Kind.ERROR, "Failed to process @AutoFactory annotations:\n" +
-          Throwables.getStackTraceAsString(e));
+      messager.printMessage(Kind.ERROR, "Failed to process @AutoFactory annotations:\n"
+          + Throwables.getStackTraceAsString(e));
     }
     return false;
   }

File: factory/src/main/java/com/google/auto/factory/processor/AutoFactoryProcessor.java
Patch:
@@ -81,8 +81,8 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
     try {
       doProcess(annotations, roundEnv);
     } catch (Throwable e) {
-      messager.printMessage(Kind.ERROR, "Failed to process @AutoFactory annotations:\n" +
-          Throwables.getStackTraceAsString(e));
+      messager.printMessage(Kind.ERROR, "Failed to process @AutoFactory annotations:\n"
+          + Throwables.getStackTraceAsString(e));
     }
     return false;
   }

File: factory/src/test/java/com/google/auto/factory/processor/AutoFactoryProcessorTest.java
Patch:
@@ -61,7 +61,7 @@ public class AutoFactoryProcessorTest {
     ASSERT.about(javaSources())
         .that(ImmutableSet.of(
             JavaFileObjects.forResource("good/SimpleClassMixedDeps.java"),
-            JavaFileObjects.forResource("aux/AQualifier.java")))
+            JavaFileObjects.forResource("support/AQualifier.java")))
         .processedWith(new AutoFactoryProcessor())
         .compilesWithoutError()
         .and().generatesSources(
@@ -80,8 +80,8 @@ public class AutoFactoryProcessorTest {
   @Test public void simpleClassProvidedDeps() {
     ASSERT.about(javaSources())
         .that(ImmutableSet.of(
-            JavaFileObjects.forResource("aux/AQualifier.java"),
-            JavaFileObjects.forResource("aux/BQualifier.java"),
+            JavaFileObjects.forResource("support/AQualifier.java"),
+            JavaFileObjects.forResource("support/BQualifier.java"),
             JavaFileObjects.forResource("good/SimpleClassProvidedDeps.java")))
         .processedWith(new AutoFactoryProcessor())
         .compilesWithoutError()

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -128,6 +128,9 @@ private void process(RoundEnvironment roundEnv) {
         processType(type);
       } catch (CompileException e) {
         // We abandoned this type, but continue with the next.
+      } catch (RuntimeException e) {
+        // Don't propagate this exception, which will confusingly crash the compiler.
+        reportError("@AutoValue processor threw an exception: " + e, type);
       }
     }
   }

File: value/src/it/functional/src/test/java/com/google/auto/value/AutoValueTest.java
Patch:
@@ -650,14 +650,13 @@ public void testCacheHashCode() {
     assertEquals(cachedHash1, uncachedHash1);
   }
 
-  public void testHashCodeCachedByDefault() {
-    // TODO(emcmanus): make it uncached by default and invert this test's name and behaviour.
+  public void testHashCodeNotCachedByDefault() {
     HashCodeObserver observer = new HashCodeObserver();
     MaybeCachedHashCode maybeCached = MaybeCachedHashCode.create(observer, 17);
     int hash1 = maybeCached.hashCode();
     int hash2 = maybeCached.hashCode();
     assertEquals(hash1, hash2);
-    assertEquals(1, observer.hashCodeCount);
+    assertEquals(2, observer.hashCodeCount);
   }
 
   @AutoValue

File: value/src/main/java/com/google/auto/value/processor/AbstractMethodExtractor.java
Patch:
@@ -96,7 +96,8 @@ Map<String, List<String>> abstractMethods(JavaTokenizer tokenizer, String packag
           if (Character.isJavaIdentifierStart(className.charAt(0))
               && !className.equals("instanceof")) {
             String container = classStack.getLast();
-            classStack.addLast(container + "." + className);
+            // container might be empty in the case of a packageless class
+            classStack.add(container.isEmpty() ? className : container + "." + className);
           }
           className = null;
         }

File: value/src/main/java/com/google/auto/value/processor/AbstractMethodExtractor.java
Patch:
@@ -96,7 +96,8 @@ Map<String, List<String>> abstractMethods(JavaTokenizer tokenizer, String packag
           if (Character.isJavaIdentifierStart(className.charAt(0))
               && !className.equals("instanceof")) {
             String container = classStack.getLast();
-            classStack.addLast(container + "." + className);
+            // container might be empty in the case of a packageless class
+            classStack.add(container.isEmpty() ? className : container + "." + className);
           }
           className = null;
         }

File: value/src/test/java/com/google/auto/value/processor/CompilationErrorsTest.java
Patch:
@@ -357,4 +357,4 @@ String sourceDirectoryName() {
       return packageName.replace('.', '/');
     }
   }
-}
\ No newline at end of file
+}

File: value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
Patch:
@@ -204,7 +204,7 @@ private static String concatLines(String... lines) {
     "$[genToString?\n  @Override",
     "  public String toString() {",
     "    return \"$[simpleclassname]{\"$[props?\n      + \"]" +
-    "$[props:p|\n      + \", |$[p]=\" + $[p]]",
+    "$[props:p|\n        + \", |$[p]=\" + $[p]]",
     "      + \"}\";",
     "  }]",
     // CHECKSTYLE:ON

File: value/src/test/java/com/google/auto/value/processor/CompilationErrorsTest.java
Patch:
@@ -316,9 +316,7 @@ private void assertCompilationResultIs(
           || (diagnostic.getKind() == Diagnostic.Kind.WARNING
               && diagnostic.getMessage(null).contains(
                   "No processor claimed any of these annotations")));
-      if (ignore) {
-        System.out.println(diagnostic);
-      } else {
+      if (!ignore) {
         diagnosticKinds.add(diagnostic.getKind());
       }
     }

File: value/src/test/java/com/google/auto/value/processor/CompilationErrorsTest.java
Patch:
@@ -316,9 +316,7 @@ private void assertCompilationResultIs(
           || (diagnostic.getKind() == Diagnostic.Kind.WARNING
               && diagnostic.getMessage(null).contains(
                   "No processor claimed any of these annotations")));
-      if (ignore) {
-        System.out.println(diagnostic);
-      } else {
+      if (!ignore) {
         diagnosticKinds.add(diagnostic.getKind());
       }
     }

File: factory/src/test/java/com/google/auto/factory/processor/AutoFactoryProcessorTest.java
Patch:
@@ -129,7 +129,7 @@ public class AutoFactoryProcessorTest {
             .processedWith(new AutoFactoryProcessor())
             .failsToCompile()
             .withErrorContaining("AutoFactory does not support generic types")
-                .in(file).onLine(6).atColumn(14);
+                .in(file).onLine(21).atColumn(14);
   }
 
   @Test public void providedButNoAutoFactory() {

File: factory/src/main/java/com/google/auto/factory/Parameter.java
Patch:
@@ -97,6 +97,7 @@ static Parameter forVariableElement(VariableElement variable) {
         qualifiers.add(Mirrors.getQualifiedName(annotationType).toString());
       }
     }
+    // TODO(gak): check for only one qualifier rather than using the first
     return new Parameter(FluentIterable.from(qualifiers.build()).first(),
         variable.asType().toString(),
         variable.getSimpleName().toString());

File: factory/src/test/java/com/google/auto/factory/AutoFactoryDeclarationTest.java
Patch:
@@ -15,12 +15,12 @@
  */
 package com.google.auto.factory;
 
-import static com.google.auto.factory.AutoFactoryChecker.isValidIdentifier;
+import static com.google.auto.factory.AutoFactoryDeclaration.Factory.isValidIdentifier;
 import static org.truth0.Truth.ASSERT;
 
 import org.junit.Test;
 
-public class AutoFactoryCheckerTest {
+public class AutoFactoryDeclarationTest {
   @Test public void identifiers() {
     ASSERT.that(isValidIdentifier("String")).isTrue();
     ASSERT.that(isValidIdentifier("9CantStartWithNumber")).isFalse();

File: factory/src/main/java/com/google/auto/factory/AutoFactoryProcessor.java
Patch:
@@ -55,6 +55,7 @@
 @AutoService(Processor.class)
 public final class AutoFactoryProcessor extends AbstractProcessor {
   @Inject FactoryDescriptorGenerator factoryDescriptorGenerator;
+  @Inject AutoFactoryChecker autoFactoryChecker;
   @Inject ProvidedChecker providedChecker;
   @Inject Messager messager;
   @Inject Elements elements;
@@ -78,6 +79,7 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
     ImmutableSet.Builder<ImplemetationMethodDescriptor> implemetationMethodDescriptors =
         ImmutableSet.builder();
     for (Element element : roundEnv.getElementsAnnotatedWith(AutoFactory.class)) {
+      autoFactoryChecker.checkAutoFactoryElement(element);
       AutoFactoryDeclaration declaration = AutoFactoryDeclaration.fromAnnotationMirror(
           elements, Mirrors.getAnnotationMirror(element, AutoFactory.class).get());
       for (String implementing : declaration.implementingQualifiedNames()) {

File: factory/src/main/java/com/google/auto/factory/ProvidedChecker.java
Patch:
@@ -55,7 +55,7 @@ public Void visitExecutableAsConstructor(ExecutableElement constructor, Void p)
             if (!(annotatedWithAutoFactory(constructor)
                 || annotatedWithAutoFactory(constructor.getEnclosingElement()))) {
               raiseError(providedParameter,
-                  "@%s may only be applied to classes requesting an auto-factory");
+                  "@%s may only be applied to constructors requesting an auto-factory");
             }
             return null;
           }
@@ -67,7 +67,7 @@ public Void visitExecutableAsConstructor(ExecutableElement constructor, Void p)
 
   private void raiseError(VariableElement providedParameter, String messageFormat) {
     messager.printMessage(ERROR, String.format(messageFormat, Provided.class.getSimpleName()),
-        providedParameter);
+        providedParameter, Mirrors.getAnnotationMirror(providedParameter, Provided.class).get());
   }
 
   private static boolean annotatedWithAutoFactory(Element e) {

File: compile-testing/src/main/java/com/google/testing/compile/JavaSourcesSubject.java
Patch:
@@ -310,8 +310,7 @@ public static final class SingleSourceAdapter
       extends Subject<SingleSourceAdapter, JavaFileObject> {
     private final JavaSourcesSubject delegate;
 
-    SingleSourceAdapter(FailureStrategy failureStrategy,
-        JavaFileObject subject) {
+    SingleSourceAdapter(FailureStrategy failureStrategy, JavaFileObject subject) {
       super(failureStrategy, subject);
       this.delegate =
           new JavaSourcesSubject(failureStrategy, ImmutableList.of(subject));

File: compile-testing/src/main/java/com/google/testing/compile/JavaSourcesSubject.java
Patch:
@@ -170,7 +170,7 @@ public boolean apply(Diagnostic<? extends FileObject> input) {
               });
           if (diagnosticsInFile.isEmpty()) {
             failureStrategy.fail(String.format(
-                "Expeceted an error in %s, but only found errors in ", file.getName(),
+                "Expected an error in %s, but only found errors in ", file.getName(),
                 diagnosticsWithMessage.transform(
                     new Function<Diagnostic<? extends FileObject>, String>() {
                       @Override public String apply(Diagnostic<? extends FileObject> input) {

File: generator/src/main/java/com/google/autofactory/FactoryDescriptorGenerator.java
Patch:
@@ -97,8 +97,7 @@ public ImmutableSet<FactoryMethodDescriptor> visitTypeAsInterface(TypeElement e,
       @Override
       public ImmutableSet<FactoryMethodDescriptor> visitExecutableAsConstructor(ExecutableElement e,
           Void p) {
-        // applied to a constructor
-        return super.visitExecutableAsConstructor(e, p);
+        return ImmutableSet.of(generateDescriptorForConstructor(declaration, e));
       }
     }, null);
   }

File: generator/src/main/java/com/google/autofactory/FactoryWriter.java
Patch:
@@ -24,7 +24,6 @@
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
-import javax.lang.model.element.Element;
 import javax.tools.JavaFileObject;
 
 import com.google.common.base.Function;
@@ -46,9 +45,9 @@ final class FactoryWriter {
 
   private static final Joiner argumentJoiner = Joiner.on(", ");
 
-  void writeFactory(final FactoryDescriptor descriptor, Element originatingElement)
+  void writeFactory(final FactoryDescriptor descriptor)
       throws IOException {
-    JavaFileObject sourceFile = filer.createSourceFile(descriptor.name(), originatingElement);
+    JavaFileObject sourceFile = filer.createSourceFile(descriptor.name());
     JavaWriter writer = new JavaWriter(sourceFile.openWriter());
     String packageName = getPackage(descriptor.name()).toString();
     writer.emitPackage(packageName)

File: generator/src/main/java/com/google/autofactory/Elements2.java
Patch:
@@ -16,15 +16,15 @@
 import com.google.common.collect.ImmutableSet;
 
 final class Elements2 {
-  private Elements2() {}
+  private Elements2() { }
 
   static ImmutableSet<ExecutableElement> getConstructors(TypeElement type) {
     checkNotNull(type);
     checkArgument(type.getKind() == CLASS);
     ImmutableSet.Builder<ExecutableElement> constructors = ImmutableSet.builder();
     for (Element element : type.getEnclosedElements()) {
       constructors.addAll(element.accept(
-          new ElementKindVisitor6<Optional<ExecutableElement>, Void> () {
+          new ElementKindVisitor6<Optional<ExecutableElement>, Void>() {
             @Override
             protected Optional<ExecutableElement> defaultAction(Element e, Void p) {
               return Optional.absent();

File: generator/src/main/java/com/google/autofactory/Names.java
Patch:
@@ -2,7 +2,7 @@
 
 
 final class Names {
-  private Names() {}
+  private Names() { }
 
   static CharSequence getSimpleName(CharSequence fullyQualifiedName) {
     int lastDot = lastIndexOf(fullyQualifiedName, '.');

File: src-subject/src/main/java/com/google/auto/factory/gentest/EqualityScanner.java
Patch:
@@ -86,7 +86,7 @@
  * versions of Java.
  */
 final class EqualityScanner extends SimpleTreeVisitor<Void, Tree> {
-    private final TestVerb testVerb;
+  private final TestVerb testVerb;
 
   EqualityScanner(FailureStrategy failureStrategy) {
     this.testVerb = new TestVerb(failureStrategy);

File: src-subject/src/main/java/com/google/auto/factory/gentest/JavaSourceSubject.java
Patch:
@@ -38,7 +38,7 @@
 /**
  * A <a href="https://github.com/truth0/truth">Truth</a> {@link Subject} that evaluates Java source
  * {@linkplain File files} and compares them for equality based on the AST.
- * 
+ *
  * @author Gregory Kick
  */
 public final class JavaSourceSubject extends Subject<JavaSourceSubject, File> {

File: src-subject/src/main/java/com/google/auto/factory/gentest/JavaSourceSubjectFactory.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * A <a href="https://github.com/truth0/truth">Truth</a> {@link SubjectFactory} for creating
  * {@link JavaSourceSubject} instances.
- * 
+ *
  * @author Gregory Kick
  */
 public class JavaSourceSubjectFactory extends SubjectFactory<JavaSourceSubject, File> {

