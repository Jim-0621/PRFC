File: src/main/javassist/convert/TransformCallToStatic.java
Patch:
@@ -23,6 +23,9 @@ protected int match(int c, int pos, CodeIterator iterator, int typedesc, ConstPo
         }
         iterator.writeByte(Opcode.INVOKESTATIC, pos);
         iterator.write16bit(newIndex, pos + 1);
+        if (c == Opcode.INVOKEINTERFACE || c == Opcode.INVOKEDYNAMIC) {
+            iterator.writeByte(0, pos + 3);
+        }
         return pos;
     }
 }

File: src/main/javassist/convert/TransformCallToStatic.java
Patch:
@@ -23,6 +23,9 @@ protected int match(int c, int pos, CodeIterator iterator, int typedesc, ConstPo
         }
         iterator.writeByte(Opcode.INVOKESTATIC, pos);
         iterator.write16bit(newIndex, pos + 1);
+        if (c == Opcode.INVOKEINTERFACE || c == Opcode.INVOKEDYNAMIC) {
+            iterator.writeByte(0, pos + 3);
+        }
         return pos;
     }
 }

File: src/main/javassist/convert/TransformCallToStatic.java
Patch:
@@ -23,6 +23,9 @@ protected int match(int c, int pos, CodeIterator iterator, int typedesc, ConstPo
         }
         iterator.writeByte(Opcode.INVOKESTATIC, pos);
         iterator.write16bit(newIndex, pos + 1);
+        if (c == Opcode.INVOKEINTERFACE || c == Opcode.INVOKEDYNAMIC) {
+            iterator.writeByte(0, pos + 3);
+        }
         return pos;
     }
 }

File: src/main/javassist/CtClass.java
Patch:
@@ -69,7 +69,7 @@ public abstract class CtClass {
     /**
      * The version number of this release.
      */
-    public static final String version = "3.30.0-GA";
+    public static final String version = "3.30.1-GA";
 
     /**
      * Prints the version number and the copyright notice.

File: src/main/javassist/CtClassType.java
Patch:
@@ -1763,8 +1763,7 @@ private static void insertAuxInitializer(CodeAttribute codeAttr,
         int pos = it.insertEx(initializer.get());
         it.insert(initializer.getExceptionTable(), pos);
         int maxstack = codeAttr.getMaxStack();
-        if (maxstack < stacksize)
-            codeAttr.setMaxStack(stacksize);
+        codeAttr.setMaxStack(maxstack + stacksize);
     }
 
     private int makeFieldInitializer(Bytecode code, CtClass[] parameters)

File: src/test/javassist/Bench.java
Patch:
@@ -5,9 +5,6 @@
 import javassist.compiler.*;
 
 public class Bench extends JvstTestRoot {
-    public Bench(String name) {
-        super(name);
-    }
 
     public void testProceed() throws Exception {
         CtClass cc = sloader.get("test.BenchProceed");

File: src/test/javassist/JvstTest.java
Patch:
@@ -20,9 +20,6 @@ public class JvstTest extends JvstTestRoot {
         java9 = javassist.bytecode.ClassFile.MAJOR_VERSION
                     >= javassist.bytecode.ClassFile.JAVA_9;
     }
-    public JvstTest(String name) {
-         super(name);
-    }
 
     public void testConfig() {
         // is the value of PATH correct?

File: src/test/javassist/JvstTest2.java
Patch:
@@ -14,9 +14,6 @@
 @SuppressWarnings({"rawtypes","unused"})
 @FixMethodOrder(MethodSorters.NAME_ASCENDING)
 public class JvstTest2 extends JvstTestRoot {
-    public JvstTest2(String name) {
-         super(name);
-    }
 
     public void testInsertAt() throws Exception {
         CtClass cc = sloader.get("test2.InsertAt");

File: src/test/javassist/JvstTest3.java
Patch:
@@ -7,9 +7,6 @@
 
 @SuppressWarnings({"rawtypes","unchecked","unused"})
 public class JvstTest3 extends JvstTestRoot {
-    public JvstTest3(String name) {
-         super(name);
-    }
 
     public void testAnnotation() throws Exception {
         CtClass cc = sloader.get("test3.AnnoTest");

File: src/test/javassist/JvstTest4.java
Patch:
@@ -16,9 +16,6 @@
 @SuppressWarnings({"rawtypes","unchecked","unused"})
 @FixMethodOrder(MethodSorters.NAME_ASCENDING)
 public class JvstTest4 extends JvstTestRoot {
-    public JvstTest4(String name) {
-        super(name);
-    }
 
     public void testInsertLocalVars() throws Exception {
         CtClass cc = sloader.get("test4.LocalVars");

File: src/test/javassist/JvstTest5.java
Patch:
@@ -25,9 +25,6 @@
 
 @SuppressWarnings({"rawtypes","unchecked","unused"})
 public class JvstTest5 extends JvstTestRoot {
-    public JvstTest5(String name) {
-        super(name);
-    }
 
     public void testDollarClassInStaticMethod() throws Exception {
         CtClass cc = sloader.makeClass("test5.DollarClass");

File: src/test/javassist/bytecode/InsertGap0.java
Patch:
@@ -159,9 +159,6 @@ public int run2(int x) {
 
 @SuppressWarnings({"rawtypes","unchecked","unused"})
 public final class InsertGap0 extends JvstTestRoot {
-    public InsertGap0(String name) {
-        super(name);
-    }
 
     public void testExample() throws Throwable {
         ClassPool pool = ClassPool.getDefault();

File: src/main/javassist/CtClassType.java
Patch:
@@ -1763,8 +1763,7 @@ private static void insertAuxInitializer(CodeAttribute codeAttr,
         int pos = it.insertEx(initializer.get());
         it.insert(initializer.getExceptionTable(), pos);
         int maxstack = codeAttr.getMaxStack();
-        if (maxstack < stacksize)
-            codeAttr.setMaxStack(stacksize);
+        codeAttr.setMaxStack(maxstack + stacksize);
     }
 
     private int makeFieldInitializer(Bytecode code, CtClass[] parameters)

File: src/main/javassist/CtClass.java
Patch:
@@ -69,7 +69,7 @@ public abstract class CtClass {
     /**
      * The version number of this release.
      */
-    public static final String version = "3.29.1-GA";
+    public static final String version = "3.29.2-GA";
 
     /**
      * Prints the version number and the copyright notice.

File: src/main/javassist/CtClass.java
Patch:
@@ -69,7 +69,7 @@ public abstract class CtClass {
     /**
      * The version number of this release.
      */
-    public static final String version = "3.29.1-GA";
+    public static final String version = "3.29.2-GA";
 
     /**
      * Prints the version number and the copyright notice.

File: src/main/javassist/compiler/MemberCodeGen.java
Patch:
@@ -669,7 +669,7 @@ else if (AccessFlag.isPrivate(acc))
                 acc = AccessFlag.setPackage(acc) | AccessFlag.STATIC;
                 if (!isFromSameDeclaringClass(declClass, thisClass))
                     mname = getAccessiblePrivate(mname, origDesc, desc,
-                        minfo, declClass);
+                                                 minfo, declClass);
             }
 
         boolean popTarget = false;

File: src/main/javassist/compiler/MemberCodeGen.java
Patch:
@@ -667,8 +667,9 @@ else if (AccessFlag.isPrivate(acc))
                                                       origDesc);
 
                 acc = AccessFlag.setPackage(acc) | AccessFlag.STATIC;
-                mname = getAccessiblePrivate(mname, origDesc, desc,
-                                             minfo, declClass);
+                if (!isFromSameDeclaringClass(declClass, thisClass))
+                    mname = getAccessiblePrivate(mname, origDesc, desc,
+                        minfo, declClass);
             }
 
         boolean popTarget = false;

File: src/test/javassist/JvstTest.java
Patch:
@@ -1181,6 +1181,7 @@ public static Test suite() {
         suite.addTestSuite(test.javassist.convert.ArrayAccessReplaceTest.class);
         suite.addTestSuite(test.javassist.convert.ArrayAccessReplaceTest2.class);
         suite.addTestSuite(test.javassist.bytecode.analysis.DomTreeTest.class);
+        suite.addTestSuite(javassist.bytecode.SignatureAttributeTest.class);
         return suite;
     }
 }

File: src/main/javassist/bytecode/AttributeInfo.java
Patch:
@@ -254,7 +254,7 @@ static List<AttributeInfo> copyAll(List<AttributeInfo> attributes, ConstPool cp)
     /* The following two methods are used to implement
      * ClassFile.renameClass().
      * Only CodeAttribute, LocalVariableAttribute,
-     * AnnotationsAttribute, and SignatureAttribute
+     * AnnotationDefaultAttribute, AnnotationsAttribute, and SignatureAttribute
      * override these methods.
      */
     void renameClass(String oldname, String newname) {}

File: src/main/javassist/compiler/MemberCodeGen.java
Patch:
@@ -648,7 +648,7 @@ private void atMethodCallCore2(CtClass targetClass, String mname,
                 throw new CompileError("no such constructor: " + targetClass.getName());
 
             if (declClass != thisClass && AccessFlag.isPrivate(acc)) {
-                if (declClass.getClassFile().getMajorVersion() < ClassFile.JAVA_11
+                if (declClass.getClassFile().getMajorVersion() < ClassFile.JAVA_8
                         || !isFromSameDeclaringClass(declClass, thisClass)) {
                     desc = getAccessibleConstructor(desc, declClass, minfo);
                     bytecode.addOpcode(Opcode.ACONST_NULL); // the last parameter

File: src/main/javassist/util/proxy/SecurityActions.java
Patch:
@@ -213,7 +213,6 @@ static TheUnsafe getSunMiscUnsafeAnonymously() throws ClassNotFoundException
             if (e.getCause() instanceof NoSuchFieldException)
                 throw new ClassNotFoundException("No such instance.", e.getCause());
             if (e.getCause() instanceof IllegalAccessException
-                    || e.getCause() instanceof IllegalAccessException
                     || e.getCause() instanceof SecurityException)
                 throw new ClassNotFoundException("Security denied access.", e.getCause());
             throw new RuntimeException(e.getCause());

File: src/main/javassist/util/proxy/SecurityActions.java
Patch:
@@ -213,7 +213,6 @@ static TheUnsafe getSunMiscUnsafeAnonymously() throws ClassNotFoundException
             if (e.getCause() instanceof NoSuchFieldException)
                 throw new ClassNotFoundException("No such instance.", e.getCause());
             if (e.getCause() instanceof IllegalAccessException
-                    || e.getCause() instanceof IllegalAccessException
                     || e.getCause() instanceof SecurityException)
                 throw new ClassNotFoundException("Security denied access.", e.getCause());
             throw new RuntimeException(e.getCause());

File: src/main/javassist/CtClass.java
Patch:
@@ -1423,7 +1423,7 @@ public final Class<?> toClass(ClassLoader loader)
     public void detach() {
         ClassPool cp = getClassPool();
         CtClass obj = cp.removeCached(getName());
-        if (obj != this)
+        if (obj != null && obj != this)
             cp.cacheCtClass(getName(), obj, false);
     }
 

File: src/main/javassist/CtClass.java
Patch:
@@ -1423,7 +1423,7 @@ public final Class<?> toClass(ClassLoader loader)
     public void detach() {
         ClassPool cp = getClassPool();
         CtClass obj = cp.removeCached(getName());
-        if (obj != this)
+        if (obj != null && obj != this)
             cp.cacheCtClass(getName(), obj, false);
     }
 

File: src/main/javassist/compiler/MemberCodeGen.java
Patch:
@@ -648,7 +648,7 @@ private void atMethodCallCore2(CtClass targetClass, String mname,
                 throw new CompileError("no such constructor: " + targetClass.getName());
 
             if (declClass != thisClass && AccessFlag.isPrivate(acc)) {
-                if (declClass.getClassFile().getMajorVersion() < ClassFile.JAVA_11
+                if (declClass.getClassFile().getMajorVersion() < ClassFile.JAVA_8
                         || !isFromSameDeclaringClass(declClass, thisClass)) {
                     desc = getAccessibleConstructor(desc, declClass, minfo);
                     bytecode.addOpcode(Opcode.ACONST_NULL); // the last parameter

File: src/test/javassist/JvstTest.java
Patch:
@@ -1179,6 +1179,7 @@ public static Test suite() {
         suite.addTestSuite(test.javassist.proxy.ProxySimpleTest.class);
         suite.addTestSuite(test.javassist.bytecode.analysis.AnalyzerTest.class);
         suite.addTestSuite(test.javassist.convert.ArrayAccessReplaceTest.class);
+        suite.addTestSuite(test.javassist.convert.ArrayAccessReplaceTest2.class);
         suite.addTestSuite(test.javassist.bytecode.analysis.DomTreeTest.class);
         return suite;
     }

File: src/main/javassist/bytecode/LocalVariableAttribute.java
Patch:
@@ -219,8 +219,8 @@ public String variableName(int i) {
 
     /**
      * Returns the name of the local variable with given index.
-     * If you want get the parameter name of method with correct order,
-     * should using this method.
+     * If you want to get the parameter name of method with correct order,
+     * you should using this method.
      *
      * @param index         the index of the local variable.
      */

File: src/main/javassist/compiler/TypeChecker.java
Patch:
@@ -933,7 +933,7 @@ else if (op == '.') {
             }
         }
 
-        throw new CompileError("bad filed access");
+        throw new CompileError("bad field access");
     }
 
     private CtField fieldAccess2(Expr e, String jvmClassName) throws CompileError {

File: src/main/javassist/compiler/TypeChecker.java
Patch:
@@ -933,7 +933,7 @@ else if (op == '.') {
             }
         }
 
-        throw new CompileError("bad filed access");
+        throw new CompileError("bad field access");
     }
 
     private CtField fieldAccess2(Expr e, String jvmClassName) throws CompileError {

File: src/test/javassist/JvstTest.java
Patch:
@@ -1179,6 +1179,7 @@ public static Test suite() {
         suite.addTestSuite(test.javassist.proxy.ProxySimpleTest.class);
         suite.addTestSuite(test.javassist.bytecode.analysis.AnalyzerTest.class);
         suite.addTestSuite(test.javassist.convert.ArrayAccessReplaceTest.class);
+        suite.addTestSuite(test.javassist.convert.ArrayAccessReplaceTest2.class);
         suite.addTestSuite(test.javassist.bytecode.analysis.DomTreeTest.class);
         return suite;
     }

File: src/main/javassist/compiler/MemberCodeGen.java
Patch:
@@ -365,7 +365,7 @@ private void atNewArrayExpr2(int type, ASTree sizeExpr,
                 sizeExpr.accept(this);
         else
             if (sizeExpr == null) {
-                int s = init.length();
+                int s = init.size();
                 bytecode.addIconst(s);
             }
             else
@@ -414,7 +414,7 @@ private void atNewArrayExpr2(int type, ASTree sizeExpr,
         }
 
         if (init != null) {
-            int s = init.length();
+            int s = init.size();
             ASTList list = init;
             for (int i = 0; i < s; i++) {
                 bytecode.addOpcode(DUP);

File: src/main/javassist/compiler/Parser.java
Patch:
@@ -683,7 +683,7 @@ private ArrayInit parseArrayInitializer(SymbolTable tbl)
         lex.get();      // '{'
         if(lex.lookAhead() == '}'){
             lex.get();
-            return new ArrayInit(new IntConst(0,TokenId.IntConstant));
+            return new ArrayInit(null);
         }
         ASTree expr = parseExpression(tbl);
         ArrayInit init = new ArrayInit(expr);

File: src/main/javassist/bytecode/ConstPool.java
Patch:
@@ -110,8 +110,10 @@ public final class ConstPool
     public static final int CONST_Dynamic = DynamicInfo.tag;
 
     /**
-     * <code>CONSTANT_InvokeDynamic</code>
+     * <code>CONSTANT_DynamicCallSite</code>,
+     * also known as <code>CONSTANT_InvokeDynamic</code>
      */
+    public static final int CONST_DynamicCallSite = InvokeDynamicInfo.tag;
     public static final int CONST_InvokeDynamic = InvokeDynamicInfo.tag;
 
     /**

File: src/main/javassist/bytecode/InstructionPrinter.java
Patch:
@@ -285,7 +285,7 @@ private static String ldc(ConstPool pool, int index) {
             case ConstPool.CONST_Long:
                 return "#" + index + " = long " + pool.getLongInfo(index);
             case ConstPool.CONST_Double:
-                return "#" + index + " = int " + pool.getDoubleInfo(index);
+                return "#" + index + " = double " + pool.getDoubleInfo(index);
             case ConstPool.CONST_Class:
                 return classInfo(pool, index);
             default:

File: src/main/javassist/bytecode/InstructionPrinter.java
Patch:
@@ -285,7 +285,7 @@ private static String ldc(ConstPool pool, int index) {
             case ConstPool.CONST_Long:
                 return "#" + index + " = long " + pool.getLongInfo(index);
             case ConstPool.CONST_Double:
-                return "#" + index + " = int " + pool.getDoubleInfo(index);
+                return "#" + index + " = double " + pool.getDoubleInfo(index);
             case ConstPool.CONST_Class:
                 return classInfo(pool, index);
             default:

File: src/main/javassist/bytecode/AttributeInfo.java
Patch:
@@ -254,7 +254,7 @@ static List<AttributeInfo> copyAll(List<AttributeInfo> attributes, ConstPool cp)
     /* The following two methods are used to implement
      * ClassFile.renameClass().
      * Only CodeAttribute, LocalVariableAttribute,
-     * AnnotationsAttribute, and SignatureAttribute
+     * AnnotationDefaultAttribute, AnnotationsAttribute, and SignatureAttribute
      * override these methods.
      */
     void renameClass(String oldname, String newname) {}

File: src/test/javassist/JvstTest5.java
Patch:
@@ -556,6 +556,6 @@ public void testRedundantInsertAfter() throws Exception {
         m2.insertAfter("{ $_ += 1; }", true, true);
         cc.writeFile();
         Object obj = make(cc.getName());
-        assertEquals(1, invoke(obj, "run"));
+        assertEquals(71 + 22, invoke(obj, "run"));
     }
 }

File: src/main/javassist/CtClass.java
Patch:
@@ -69,7 +69,7 @@ public abstract class CtClass {
     /**
      * The version number of this release.
      */
-    public static final String version = "3.25.0-GA";
+    public static final String version = "3.26.0-GA";
 
     /**
      * Prints the version number and the copyright notice.

File: src/main/javassist/compiler/MemberResolver.java
Patch:
@@ -539,7 +539,7 @@ public static CtClass getSuperInterface(CtClass c, String interfaceName)
                 if (intfs[i].getName().equals(interfaceName))
                     return intfs[i];
         } catch (NotFoundException e) {}
-        throw new CompileError("cannot find the super inetrface " + interfaceName
+        throw new CompileError("cannot find the super interface " + interfaceName
                                + " of " + c.getName());
     }
 

File: src/main/javassist/compiler/MemberResolver.java
Patch:
@@ -539,7 +539,7 @@ public static CtClass getSuperInterface(CtClass c, String interfaceName)
                 if (intfs[i].getName().equals(interfaceName))
                     return intfs[i];
         } catch (NotFoundException e) {}
-        throw new CompileError("cannot find the super inetrface " + interfaceName
+        throw new CompileError("cannot find the super interface " + interfaceName
                                + " of " + c.getName());
     }
 

File: src/main/javassist/CtBehavior.java
Patch:
@@ -782,7 +782,7 @@ private void insertBefore(String src, boolean rebuild)
                                         Modifier.isStatic(getModifiers()));
             jv.recordParamNames(ca, nvars);
             jv.recordLocalVariables(ca, 0);
-            jv.recordType(getReturnType0());
+            jv.recordReturnType(getReturnType0(), false);
             jv.compileStmnt(src);
             Bytecode b = jv.getBytecode();
             int stack = b.getMaxStack();

File: src/main/javassist/util/proxy/DefineClassHelper.java
Patch:
@@ -219,9 +219,6 @@ Class<?> defineClass(String name, byte[] b, int off, int len, Class<?> neighbor,
                 if (e instanceof RuntimeException) throw (RuntimeException) e;
                 throw new CannotCompileException(e);
             }
-            finally {
-                SecurityActions.setAccessible(defineClass, false);
-            }
         }
     }
 

File: src/main/javassist/util/proxy/DefinePackageHelper.java
Patch:
@@ -128,9 +128,6 @@ Package definePackage(ClassLoader loader, String name, String specTitle,
                 }
                 if (e instanceof RuntimeException) throw (RuntimeException) e;
             }
-            finally {
-                definePackage.setAccessible(false);
-            }
             return null;
         }
     };

File: src/main/javassist/util/proxy/DefineClassHelper.java
Patch:
@@ -219,9 +219,6 @@ Class<?> defineClass(String name, byte[] b, int off, int len, Class<?> neighbor,
                 if (e instanceof RuntimeException) throw (RuntimeException) e;
                 throw new CannotCompileException(e);
             }
-            finally {
-                SecurityActions.setAccessible(defineClass, false);
-            }
         }
     }
 

File: src/main/javassist/util/proxy/DefinePackageHelper.java
Patch:
@@ -128,9 +128,6 @@ Package definePackage(ClassLoader loader, String name, String specTitle,
                 }
                 if (e instanceof RuntimeException) throw (RuntimeException) e;
             }
-            finally {
-                definePackage.setAccessible(false);
-            }
             return null;
         }
     };

File: src/main/javassist/util/proxy/ProxyFactory.java
Patch:
@@ -622,7 +622,9 @@ private void createClass3(ClassLoader cl, Lookup lookup) {
      * {@code java.lang.invoke.MethodHandles.Lookup}.
      */
     private Class<?> getClassInTheSamePackage() {
-        if (superClass != null && superClass != OBJECT_TYPE)
+        if (basename.startsWith("javassist.util.proxy."))       // maybe the super class is java.*
+            return this.getClass();
+        else if (superClass != null && superClass != OBJECT_TYPE)
             return superClass;
         else if (interfaces != null && interfaces.length > 0)
             return interfaces[0];

File: src/main/javassist/scopedpool/SoftValueHashMap.java
Patch:
@@ -31,7 +31,7 @@
  * This Map will remove entries when the value in the map has been cleaned from
  * garbage collection
  * 
- * @version <tt>$Revision: 1.4 $</tt>
+ * @version <code>$Revision: 1.4 $</code>
  * @author <a href="mailto:bill@jboss.org">Bill Burke</a>
  */
 public class SoftValueHashMap<K,V> implements Map<K,V> {
@@ -133,10 +133,10 @@ public SoftValueHashMap() {
 
     /**
      * Constructs a new <code>WeakHashMap</code> with the same mappings as the
-     * specified <tt>Map</tt>. The <code>WeakHashMap</code> is created with
+     * specified <code>Map</code>. The <code>WeakHashMap</code> is created with
      * an initial capacity of twice the number of mappings in the specified map
      * or 11 (whichever is greater), and a default load factor, which is
-     * <tt>0.75</tt>.
+     * <code>0.75</code>.
      * 
      * @param t     the map whose mappings are to be placed in this map.
      */

File: src/main/javassist/ClassPool.java
Patch:
@@ -1038,7 +1038,7 @@ public void appendPathList(String pathlist) throws NotFoundException {
      * work with a security manager or a signed jar file because a
      * protection domain is not specified.</p>
      *
-     * @see #toCalss(CtClass,Class)
+     * @see #toClass(CtClass,Class)
      * @see #toClass(CtClass,Class,java.lang.ClassLoader,ProtectionDomain)
      * @see #getClassLoader()
      */
@@ -1206,7 +1206,7 @@ public Class<?> toClass(CtClass ct,
      *
      * <p>If your program is for only Java 9 or later, don't use this method.
      * Use {@link #toClass(CtClass,Class)} or
-     * {@link #toClass(CtClass)CtClass,java.lang.invoke.MethodHandles.Lookup)}.
+     * {@link #toClass(CtClass,java.lang.invoke.MethodHandles.Lookup)}.
      * </p>
      *
      * @param ct            the class converted into {@code java.lang.Class}.

File: src/main/javassist/expr/NewArray.java
Patch:
@@ -92,9 +92,9 @@ public CtClass[] mayThrow() {
 
     /**
      * Returns the type of array components.  If the created array is
-     * a two-dimensional array of <tt>int</tt>,
+     * a two-dimensional array of <code>int</code>,
      * the type returned by this method is
-     * not <tt>int[]</tt> but <tt>int</tt>.
+     * not <code>int[]</code> but <code>int</code>.
      */
     public CtClass getComponentType() throws NotFoundException {
         if (opcode == Opcode.NEWARRAY) {

File: src/main/javassist/util/proxy/DefineClassHelper.java
Patch:
@@ -252,7 +252,7 @@ Class<?> defineClass(String name, byte[] b, int off, int len, Class<?> neighbor,
      * @param loader        the class loader.  It can be null if {@code neighbor} is not null
      *                      and the JVM is Java 11 or later.
      * @param domain        if it is null, a default domain is used.
-     * @parma bcode         the bytecode for the loaded class.
+     * @param bcode         the bytecode for the loaded class.
      * @since 3.22
      */
     public static Class<?> toClass(String className, Class<?> neighbor, ClassLoader loader,

File: src/main/javassist/util/proxy/ProxyFactory.java
Patch:
@@ -214,7 +214,7 @@ public class ProxyFactory {
      *
      * <p>The default value is {@code false}.</p>
      *
-     * @see DefineClassHelper#toClass(String, Class<?>, ClassLoader, ProtectionDomain, byte[])
+     * @see DefineClassHelper#toClass(String, Class, ClassLoader, ProtectionDomain, byte[])
      * @since 3.22
      */
     public static boolean onlyPublicMethods = false;

File: src/main/javassist/CtClassType.java
Patch:
@@ -1526,7 +1526,7 @@ public void instrument(CodeConverter converter)
         ClassFile cf = getClassFile2();
         ConstPool cp = cf.getConstPool();
         List<MethodInfo> methods = cf.getMethods();
-        for (MethodInfo minfo:methods)
+        for (MethodInfo minfo: methods.toArray(new MethodInfo[methods.size()]))
             converter.doit(this, minfo, cp);
     }
 
@@ -1537,7 +1537,7 @@ public void instrument(ExprEditor editor)
         checkModify();
         ClassFile cf = getClassFile2();
         List<MethodInfo> methods = cf.getMethods();
-        for (MethodInfo minfo:methods)
+        for (MethodInfo minfo: methods.toArray(new MethodInfo[methods.size()]))
             editor.doit(this, minfo);
     }
 

File: src/main/javassist/ClassPoolTail.java
Patch:
@@ -159,7 +159,9 @@ public InputStream openClassfile(String classname)
         URL jarURL = find(classname);
         if (null != jarURL)
             try {
-                return jarURL.openConnection().getInputStream();
+                java.net.URLConnection con = jarURL.openConnection();
+                con.setUseCaches(false);
+                return con.getInputStream();
             }
             catch (IOException e) {
                 throw new NotFoundException("broken jar file?: "

File: src/main/javassist/util/proxy/ProxyFactory.java
Patch:
@@ -1186,8 +1186,8 @@ private void getMethods(Map<String,Method> hash, Class<?> clazz, Set<Class<?>> v
                 // put the method to the cache, retrieve previous definition (if any)
                 Method oldMethod = hash.put(key, m);
 
-                // JIRA JASSIST-244
-                // ignore a bridge method with the same signature that the overridden one has.
+                // JIRA JASSIST-244, 267
+                // ignore a bridge method to a method declared in a non-public class.
                 if (null != oldMethod && isBridge(m)
                     && !Modifier.isPublic(oldMethod.getDeclaringClass().getModifiers())
                     && !Modifier.isAbstract(oldMethod.getModifiers()) && !isDuplicated(i, methods))

File: src/main/javassist/util/proxy/DefineClassHelper.java
Patch:
@@ -246,7 +246,8 @@ public static Class<?> toClass(String className, ClassLoader loader,
             throw e;
         }
         catch (ClassFormatError e) {
-            throw new CannotCompileException(e.getCause());
+            Throwable t = e.getCause();
+            throw new CannotCompileException(t == null ? e : t);
         }
         catch (Exception e) {
             throw new CannotCompileException(e);

File: src/test/javassist/JvstTest.java
Patch:
@@ -79,7 +79,7 @@ public void testReleaseJarClassPathFileHandle() throws Exception {
 
         // Assert that it is possible to delete the jar file.
         // On Windows deleting an open file will fail, while on on Mac/Linux this is always possible.
-        // This check will thus only fail on Windos if the file is still open.
+        // This check will thus only fail on Windows if the file is still open.
         assertTrue(jarFile.delete());
     }
 

File: src/main/javassist/scopedpool/ScopedClassPool.java
Patch:
@@ -119,7 +119,6 @@ protected ClassLoader getClassLoader0() {
      */
     public void close() {
         this.removeClassPath(classPath);
-        classPath.close();
         classes.clear();
         softcache.clear();
     }

File: src/main/javassist/bytecode/stackmap/MapMaker.java
Patch:
@@ -430,7 +430,6 @@ else if (bb.incoming == 0) {
                 // dead code.
                 writer.sameFrame(offsetDelta);
                 offsetDelta = bb.length - 1;
-                prev = bb;
             }
             else
                 offsetDelta += bb.length;

File: src/main/javassist/scopedpool/ScopedClassPoolRepository.java
Patch:
@@ -81,7 +81,7 @@ public interface ScopedClassPoolRepository {
      * 
      * @return the registered classloaders.
      */
-    Map getRegisteredCLs();
+    Map<ClassLoader,ScopedClassPool> getRegisteredCLs();
 
     /**
      * This method will check to see if a register classloader has been

File: src/main/javassist/ClassPoolTail.java
Patch:
@@ -179,7 +179,6 @@ public URL find(String classname) {
         return null;            // not found
     }
 
-    @Override
     @Override
     public String toString() {
         return jarfileURL == null ? "<null>" : jarfileURL.toString();

File: src/main/javassist/scopedpool/ScopedClassPool.java
Patch:
@@ -118,7 +118,6 @@ protected ClassLoader getClassLoader0() {
      */
     public void close() {
         this.removeClassPath(classPath);
-        classPath.close();
         classes.clear();
         softcache.clear();
     }

File: src/main/javassist/scopedpool/ScopedClassPoolRepository.java
Patch:
@@ -81,7 +81,7 @@ public interface ScopedClassPoolRepository {
      * 
      * @return the registered classloaders.
      */
-    Map getRegisteredCLs();
+    Map<ClassLoader,ScopedClassPool> getRegisteredCLs();
 
     /**
      * This method will check to see if a register classloader has been

File: src/main/javassist/ClassPath.java
Patch:
@@ -39,7 +39,7 @@ public interface ClassPath {
      *
      * <p>This method can return null if the specified class file is not
      * found.  If null is returned, the next search path is examined.
-     * However, if an error happens, this method must throw an exception 
+     * However, if an error happens, this method must throw an exception
      * so that the search will be terminated.
      *
      * <p>This method should not modify the contents of the class file.

File: src/main/javassist/CtNewWrappedConstructor.java
Patch:
@@ -16,8 +16,10 @@
 
 package javassist;
 
-import javassist.bytecode.*;
 import javassist.CtMethod.ConstParameter;
+import javassist.bytecode.Bytecode;
+import javassist.bytecode.ClassFile;
+import javassist.bytecode.Descriptor;
 
 class CtNewWrappedConstructor extends CtNewWrappedMethod {
     private static final int PASS_NONE = CtNewConstructor.PASS_NONE;

File: src/main/javassist/CtPrimitiveType.java
Patch:
@@ -47,6 +47,7 @@ public final class CtPrimitiveType extends CtClass {
      * Java type: boolean, byte, char, short, int, long, float, double,
      * or void.
      */
+    @Override
     public boolean isPrimitive() { return true; }
 
     /**
@@ -55,6 +56,7 @@ public final class CtPrimitiveType extends CtClass {
      *
      * @see Modifier
      */
+    @Override
     public int getModifiers() {
         return Modifier.PUBLIC | Modifier.FINAL;
     }

File: src/main/javassist/NotFoundException.java
Patch:
@@ -20,6 +20,9 @@
  * Signals that something could not be found.
  */
 public class NotFoundException extends Exception {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public NotFoundException(String msg) {
         super(msg);
     }

File: src/main/javassist/bytecode/BadBytecode.java
Patch:
@@ -20,6 +20,9 @@
  * Signals that a bad bytecode sequence has been found.
  */
 public class BadBytecode extends Exception {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public BadBytecode(int opcode) {
         super("bytecode " + opcode);
     }

File: src/main/javassist/bytecode/BootstrapMethodsAttribute.java
Patch:
@@ -108,7 +108,8 @@ public BootstrapMethod[] getMethods() {
      * @param classnames        pairs of replaced and substituted
      *                          class names.
      */
-    public AttributeInfo copy(ConstPool newCp, Map classnames) {
+    @Override
+    public AttributeInfo copy(ConstPool newCp, Map<String,String> classnames) {
         BootstrapMethod[] methods = getMethods();
         ConstPool thisCp = getConstPool();
         for (int i = 0; i < methods.length; i++) {

File: src/main/javassist/bytecode/ClassFileWriter.java
Patch:
@@ -16,10 +16,9 @@
 
 package javassist.bytecode;
 
-import java.io.OutputStream;
 import java.io.DataOutputStream;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.io.OutputStream;
 
 /**
  * A quick class-file writer.  This is useful when a generated

File: src/main/javassist/bytecode/ConstantAttribute.java
Patch:
@@ -17,8 +17,8 @@
 package javassist.bytecode;
 
 import java.io.DataInputStream;
-import java.util.Map;
 import java.io.IOException;
+import java.util.Map;
 
 /**
  * <code>ConstantValue_attribute</code>.
@@ -65,7 +65,8 @@ public int getConstantValue() {
      * @param classnames        pairs of replaced and substituted
      *                          class names.
      */
-    public AttributeInfo copy(ConstPool newCp, Map classnames) {
+    @Override
+    public AttributeInfo copy(ConstPool newCp, Map<String,String> classnames) {
         int index = getConstPool().copy(getConstantValue(), newCp,
                                         classnames);
         return new ConstantAttribute(newCp, index);

File: src/main/javassist/bytecode/DeprecatedAttribute.java
Patch:
@@ -50,7 +50,8 @@ public DeprecatedAttribute(ConstPool cp) {
      * @param newCp     the constant pool table used by the new copy.
      * @param classnames        should be null.
      */
-    public AttributeInfo copy(ConstPool newCp, Map classnames) {
+    @Override
+    public AttributeInfo copy(ConstPool newCp, Map<String,String> classnames) {
         return new DeprecatedAttribute(newCp);
     }
 }

File: src/main/javassist/bytecode/DuplicateMemberException.java
Patch:
@@ -25,6 +25,9 @@
  * @see ClassFile#addField(FieldInfo)
  */
 public class DuplicateMemberException extends CannotCompileException {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public DuplicateMemberException(String msg) {
         super(msg);
     }

File: src/main/javassist/bytecode/LineNumberAttribute.java
Patch:
@@ -156,7 +156,8 @@ public Pc toNearPc(int line) {
      * @param newCp     the constant pool table used by the new copy.
      * @param classnames        should be null.
      */
-    public AttributeInfo copy(ConstPool newCp, Map classnames) {
+    @Override
+    public AttributeInfo copy(ConstPool newCp, Map<String,String> classnames) {
         byte[] src = info;
         int num = src.length;
         byte[] dest = new byte[num];

File: src/main/javassist/bytecode/MethodParametersAttribute.java
Patch:
@@ -72,7 +72,8 @@ public int accessFlags(int i) {
      * @param newCp     the constant pool table used by the new copy.
      * @param classnames        ignored.
      */
-    public AttributeInfo copy(ConstPool newCp, Map classnames) {
+    @Override
+    public AttributeInfo copy(ConstPool newCp, Map<String,String> classnames) {
         int s = size();
         ConstPool cp = getConstPool();
         String[] names = new String[s];

File: src/main/javassist/bytecode/SourceFileAttribute.java
Patch:
@@ -65,7 +65,8 @@ public String getFileName() {
      * @param classnames        pairs of replaced and substituted
      *                          class names.
      */
-    public AttributeInfo copy(ConstPool newCp, Map classnames) {
+    @Override
+    public AttributeInfo copy(ConstPool newCp, Map<String,String> classnames) {
         return new SourceFileAttribute(newCp, getFileName());
     }
 }

File: src/main/javassist/bytecode/SyntheticAttribute.java
Patch:
@@ -50,7 +50,8 @@ public SyntheticAttribute(ConstPool cp) {
      * @param newCp     the constant pool table used by the new copy.
      * @param classnames        should be null.
      */
-    public AttributeInfo copy(ConstPool newCp, Map classnames) {
+    @Override
+    public AttributeInfo copy(ConstPool newCp, Map<String,String> classnames) {
         return new SyntheticAttribute(newCp);
     }
 }

File: src/main/javassist/bytecode/analysis/Frame.java
Patch:
@@ -229,6 +229,7 @@ public boolean merge(Frame frame) {
         return changed;
     }
 
+    @Override
     public String toString() {
         StringBuffer buffer = new StringBuffer();
 

File: src/main/javassist/bytecode/annotation/AnnotationsWriter.java
Patch:
@@ -16,7 +16,8 @@
 
 package javassist.bytecode.annotation;
 
-import java.io.*;
+import java.io.IOException;
+import java.io.OutputStream;
 
 import javassist.bytecode.ByteArray;
 import javassist.bytecode.ConstPool;

File: src/main/javassist/bytecode/annotation/NoSuchClassError.java
Patch:
@@ -21,6 +21,8 @@
  * It keeps the name of the class that caused this error. 
  */
 public class NoSuchClassError extends Error {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private String className;
 
     /**

File: src/main/javassist/bytecode/annotation/TypeAnnotationsWriter.java
Patch:
@@ -28,6 +28,7 @@ public TypeAnnotationsWriter(OutputStream os, ConstPool cp) {
      * {@code Runtime(In)VisibleTypeAnnotations_attribute}.
      * It must be followed by {@code num} instances of {@code type_annotation}.
      */
+    @Override
     public void numAnnotations(int num) throws IOException {
         super.numAnnotations(num);
     }

File: src/main/javassist/compiler/NoFieldException.java
Patch:
@@ -19,6 +19,8 @@
 import javassist.compiler.ast.ASTree;
 
 public class NoFieldException extends CompileError {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private String fieldName;
     private ASTree expr;
 

File: src/main/javassist/compiler/SyntaxError.java
Patch:
@@ -17,6 +17,9 @@
 package javassist.compiler;
 
 public class SyntaxError extends CompileError {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public SyntaxError(Lex lexer) {
         super("syntax error near \"" + lexer.getTextAround() + "\"", lexer);
     }

File: src/main/javassist/compiler/ast/MethodDecl.java
Patch:
@@ -19,6 +19,8 @@
 import javassist.compiler.CompileError;
 
 public class MethodDecl extends ASTList {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     public static final String initName = "<init>";
 
     public MethodDecl(ASTree _head, ASTList _tail) {
@@ -40,6 +42,7 @@ public boolean isConstructor() {
 
     public Stmnt getBody() { return (Stmnt)sublist(4).head(); }
 
+    @Override
     public void accept(Visitor v) throws CompileError {
         v.atMethodDecl(this);
     }

File: src/main/javassist/convert/TransformAfter.java
Patch:
@@ -18,7 +18,8 @@
 
 import javassist.CtMethod;
 import javassist.NotFoundException;
-import javassist.bytecode.*;
+import javassist.bytecode.BadBytecode;
+import javassist.bytecode.CodeIterator;
 
 public class TransformAfter extends TransformBefore {
     public TransformAfter(Transformer next,
@@ -28,6 +29,7 @@ public TransformAfter(Transformer next,
         super(next, origMethod, afterMethod);
     }
 
+    @Override
     protected int match2(int pos, CodeIterator iterator) throws BadBytecode {
         iterator.move(pos);
         iterator.insert(saveCode);

File: src/main/javassist/expr/ConstructorCall.java
Patch:
@@ -40,6 +40,7 @@ protected ConstructorCall(int pos, CodeIterator i, CtClass decl, MethodInfo m) {
     /**
      * Returns <code>"super"</code> or "<code>"this"</code>.
      */
+    @Override
     public String getMethodName() {
         return isSuper() ? "super" : "this";
     }
@@ -49,6 +50,7 @@ public String getMethodName() {
      *
      * @see #getConstructor()
      */
+    @Override
     public CtMethod getMethod() throws NotFoundException {
         throw new NotFoundException("this is a constructor call.  Call getConstructor().");
     }
@@ -64,6 +66,7 @@ public CtConstructor getConstructor() throws NotFoundException {
      * Returns true if the called constructor is not <code>this()</code>
      * but <code>super()</code> (a constructor declared in the super class).
      */
+    @Override
     public boolean isSuper() {
         return super.isSuper();
     }

File: src/main/javassist/tools/reflect/CannotCreateException.java
Patch:
@@ -20,6 +20,9 @@
  * Signals that <code>ClassMetaobject.newInstance()</code> fails.
  */
 public class CannotCreateException extends Exception {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public CannotCreateException(String s) {
         super(s);
     }

File: src/main/javassist/tools/reflect/CannotInvokeException.java
Patch:
@@ -17,7 +17,6 @@
 package javassist.tools.reflect;
 
 import java.lang.reflect.InvocationTargetException;
-import java.lang.IllegalAccessException;
 
 /**
  * Thrown when method invocation using the reflection API has thrown
@@ -29,6 +28,8 @@
  */
 public class CannotInvokeException extends RuntimeException {
 
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private Throwable err = null;
 
     /**

File: src/main/javassist/tools/reflect/Compiler.java
Patch:
@@ -16,10 +16,11 @@
 
 package javassist.tools.reflect;
 
-import javassist.CtClass;
-import javassist.ClassPool;
 import java.io.PrintStream;
 
+import javassist.ClassPool;
+import javassist.CtClass;
+
 class CompiledClass {
     public String classname;
     public String metaobject;

File: src/main/javassist/tools/reflect/Loader.java
Patch:
@@ -17,8 +17,8 @@
 package javassist.tools.reflect;
 
 import javassist.CannotCompileException;
-import javassist.NotFoundException;
 import javassist.ClassPool;
+import javassist.NotFoundException;
 
 /**
  * A class loader for reflection.

File: src/main/javassist/tools/rmi/ObjectNotFoundException.java
Patch:
@@ -17,6 +17,9 @@
 package javassist.tools.rmi;
 
 public class ObjectNotFoundException extends Exception {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public ObjectNotFoundException(String name) {
         super(name + " is not exported");
     }

File: src/main/javassist/tools/rmi/RemoteException.java
Patch:
@@ -21,6 +21,9 @@
  * during remote method invocation.
  */
 public class RemoteException extends RuntimeException {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public RemoteException(String msg) {
         super(msg);
     }

File: src/main/javassist/tools/rmi/RemoteRef.java
Patch:
@@ -21,6 +21,8 @@
  * reference through a network stream.
  */
 public class RemoteRef implements java.io.Serializable {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     public int oid;
     public String classname;
 

File: src/main/javassist/util/proxy/ProxyObject.java
Patch:
@@ -31,6 +31,7 @@ public interface ProxyObject extends Proxy {
      * Sets a handler.  It can be used for changing handlers
      * during runtime.
      */
+    @Override
     void setHandler(MethodHandler mi);
 
     /**

File: src/test/Jassist150.java
Patch:
@@ -6,6 +6,7 @@
 import javassist.expr.ExprEditor;
 import javassist.expr.MethodCall;
 
+@SuppressWarnings("unused")
 public class Jassist150 {
     public static final String BASE_PATH = "./";
     public static final String JAVASSIST_JAR = BASE_PATH + "javassist.jar";

File: src/test/Test.java
Patch:
@@ -2,6 +2,7 @@
 import java.util.List;
 import javassist.*;
 
+@SuppressWarnings("unused")
 class InvalidStackMapFrame {
 
 	public void bytecodeVerifyError1() {

File: src/test/VisibleTop.java
Patch:
@@ -1,3 +1,4 @@
+@SuppressWarnings("unused")
 public class VisibleTop {
     public int pub;
     protected int pro;

File: src/test/VisibleTop2.java
Patch:
@@ -1,3 +1,4 @@
+@SuppressWarnings("unused")
 public class VisibleTop2 {
     public int pub;
     protected int pro;

File: src/test/javassist/ClassPoolBench.java
Patch:
@@ -24,6 +24,7 @@ public static void accessClass(String name) throws Exception {
            cc.detach();
     }
 
+    @SuppressWarnings("rawtypes")
     public static void accessAll(String filename) throws Exception {
         ZipFile zip = new ZipFile(filename);
         Enumeration files = zip.entries();

File: src/test/javassist/JvstTest.java
Patch:
@@ -8,6 +8,7 @@
 import javassist.expr.*;
 import javassist.runtime.*;
 
+@SuppressWarnings({"rawtypes","unused", "resource"})
 public class JvstTest extends JvstTestRoot {
     public static boolean java9;
 

File: src/test/javassist/JvstTest3.java
Patch:
@@ -5,6 +5,7 @@
 import javassist.expr.*;
 import test3.*;
 
+@SuppressWarnings({"rawtypes","unchecked","unused"})
 public class JvstTest3 extends JvstTestRoot {
     public JvstTest3(String name) {
          super(name);

File: src/test/javassist/JvstTest5.java
Patch:
@@ -12,6 +12,7 @@
 import javassist.expr.ExprEditor;
 import javassist.expr.MethodCall;
 
+@SuppressWarnings({"rawtypes","unchecked","unused"})
 public class JvstTest5 extends JvstTestRoot {
     public JvstTest5(String name) {
         super(name);

File: src/test/javassist/JvstTestRoot.java
Patch:
@@ -5,10 +5,10 @@
 
 public class JvstTestRoot extends TestCase {
     // the directory where all compiled class files are found.
-    public static final String PATH = "../target/test-classes/";
+    public static final String PATH = "../../target/test-classes/";
 
     // the directory where javassist.jar is found.
-    public static final String JAR_PATH = "../";
+    public static final String JAR_PATH = "../../";
 
     ClassPool sloader, dloader;
     Loader cloader;

File: src/test/javassist/LoaderTestByRandall.java
Patch:
@@ -11,6 +11,7 @@
 /**
  * @author brandall
  */
+@SuppressWarnings({"rawtypes","unused"})
 public class LoaderTestByRandall extends TestCase {
 
     ClassPool cp;

File: src/test/javassist/SetterTest.java
Patch:
@@ -3,6 +3,7 @@
 
 import junit.framework.TestCase;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class SetterTest extends TestCase {
 
     ClassPool pool;

File: src/test/javassist/bytecode/CodeAnalyzerTest.java
Patch:
@@ -5,6 +5,7 @@
 import java.util.List;
 import java.io.*;
 
+@SuppressWarnings({"rawtypes","resource"})
 public class CodeAnalyzerTest {
     public static void main(String[] args) throws Exception {
         ZipFile zfile = new ZipFile(args[0]);

File: src/test/javassist/bytecode/InsertGap0.java
Patch:
@@ -2,6 +2,7 @@
 
 import javassist.*;
 
+@SuppressWarnings("unused")
 final class Gap0Example {
     public static int counter = 1;
 
@@ -70,6 +71,7 @@ public void doit() {
     }
 }
 
+@SuppressWarnings("unused")
 final class Gap0Example2 {
     public static int counter = 1;
 
@@ -155,6 +157,7 @@ public int run2(int x) {
     }
 }
 
+@SuppressWarnings({"rawtypes","unchecked","unused"})
 public final class InsertGap0 extends JvstTestRoot {
     public InsertGap0(String name) {
         super(name);

File: src/test/javassist/bytecode/StackMapTest.java
Patch:
@@ -21,6 +21,7 @@
 import javassist.bytecode.stackmap.TypeData;
 import junit.framework.TestCase;
 
+@SuppressWarnings({"rawtypes","unused"})
 public class StackMapTest extends TestCase {
     public static final String PATH = JvstTest.PATH;
     private ClassPool loader, dloader;

File: src/test/javassist/proxyfactory/MyCls.java
Patch:
@@ -7,6 +7,8 @@
  */
 public class MyCls implements Serializable {
 
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private int i,j;
 
     public int getI() {

File: src/test/javassist/proxyfactory/ProxyFactoryTest.java
Patch:
@@ -11,6 +11,7 @@
 /**
  * <a href="mailto:struberg@yahoo.de">Mark Struberg</a>
  */
+@SuppressWarnings({"rawtypes","unchecked","unused"})
 public class ProxyFactoryTest extends TestCase {
     public void testMethodHandlers() throws Exception {
         ProxyFactory fact = new ProxyFactory();
@@ -59,6 +60,8 @@ public void testSerialize() throws Exception {
     
     public static class MyMethodHandler implements MethodHandler, Serializable {
 
+        /** default serialVersionUID */
+        private static final long serialVersionUID = 1L;
         private int x;
 
         public int getX() {

File: src/test/javassist/tools/reflect/Person.java
Patch:
@@ -3,7 +3,7 @@
 import java.lang.reflect.Method;
 import java.util.Arrays;
 
-import junit.framework.Assert;
+import org.junit.Assert;
 
 /**
  * Work with ClassMetaobjectTest.java

File: src/test/javassist/tools/reflect/SubClass.java
Patch:
@@ -1,6 +1,6 @@
 package javassist.tools.reflect;
 
-import junit.framework.*;
+import org.junit.Assert;
 
 public class SubClass extends SuperClass {
     public String f() { return "f2"; }	// override

File: src/test/test/javassist/convert/ArrayAccessReplaceTest.java
Patch:
@@ -147,6 +147,7 @@ public void testMulti() throws Exception {
         }
     }
 
+    @SuppressWarnings({"rawtypes","unchecked"})
     public static class Echo {
         public static Map byteMap = new HashMap();
         public static Map charMap = new HashMap();

File: src/test/test/javassist/proxy/JBPAPP9257Test.java
Patch:
@@ -8,6 +8,7 @@
 import javassist.util.proxy.Proxy;
 import junit.framework.TestCase;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class JBPAPP9257Test extends TestCase {
     public void testGetHandler() throws Exception {
         ProxyFactory f = new ProxyFactory();

File: src/test/test/javassist/proxy/ProxyCacheGCTest.java
Patch:
@@ -11,6 +11,7 @@
  * test which checks that proxy classes are not retained after their classloader is released.
  * this is a before and after test which validates JASSIST-104
  */
+@SuppressWarnings({"rawtypes","unchecked"})
 public class ProxyCacheGCTest extends TestCase
 {
     /**

File: src/test/test/javassist/proxy/ProxyFactoryCompatibilityTest.java
Patch:
@@ -16,6 +16,7 @@
  * automatically disabled if this legacy api is used. it also exercises the new style
  * api, ensuring that caching works correctly with this model.
  */
+@SuppressWarnings({"rawtypes","unchecked","unused"})
 public class ProxyFactoryCompatibilityTest extends TestCase
 {
     private ClassPool basePool;

File: src/test/test/javassist/tools/DummyClass.java
Patch:
@@ -2,6 +2,7 @@
 
 public class DummyClass {
 
+    @SuppressWarnings("unused")
     private String dummyString = "dummyStringValue";
 
     public void dummyMethod(){}

File: src/test/test1/FieldMod.java
Patch:
@@ -1,6 +1,7 @@
 package test1;
 
 public class FieldMod {
+    @SuppressWarnings("unused")
     private String text;
     public int i;
 }

File: src/test/test1/Howard.java
Patch:
@@ -21,6 +21,7 @@ class Howard2 {
 }
 
 public class Howard extends Howard2 {
+    @SuppressWarnings("unused")
     private Object _remote;
 
     public int run() {

File: src/test/test1/MySerializableClass.java
Patch:
@@ -7,6 +7,8 @@
  * @author Bob Lee
  */
 public class MySerializableClass implements Serializable, Cloneable {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     String fieldA;
     String fieldB;
 

File: src/test/test1/Proceed.java
Patch:
@@ -1,5 +1,6 @@
 package test1;
 
+@SuppressWarnings("unused")
 public class Proceed {
     public int p(int i, int j) { return i + j; }
 

File: src/test/test1/RenameClass.java
Patch:
@@ -6,6 +6,7 @@ class RenameClass2 {
     String name;
 }
 
+@SuppressWarnings({"rawtypes","unchecked", "unused"})
 public class RenameClass {
     private Hashtable table;
     public RenameClass() {

File: src/test/test2/AddMethod.java
Patch:
@@ -1,6 +1,7 @@
 package test2;
 
 public class AddMethod {
+    @SuppressWarnings("unused")
     private int f;
 
     public int f() { return 0; }

File: src/test/test2/Anon.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class Anon {
     public Object make() {
         return new Object() { int k; };

File: src/test/test2/Brennan.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class Brennan {
     private Object format = null;
 }

File: src/test/test2/Inner.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class Inner {
     public void sample() throws Exception {
         java.util.Properties props = new java.util.Properties();

File: src/test/test2/InsertLocal.java
Patch:
@@ -22,6 +22,7 @@ public int run2() {
         return k + s.length();
     }
 
+    @SuppressWarnings("unused")
     public int run3() {
         int i = 0;
         int j = field;

File: src/test/test2/Nested.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class Nested {
     private int i = 3;
     private int geti() { return i; }

File: src/test/test2/Nested2.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class Nested2 {
     private int i = 3;
     private double d = 3.0;

File: src/test/test2/Nested3.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class Nested3 {
     private int i = 0;
     private int geti() { return i; }

File: src/test/test2/Nested4.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class Nested4 {
     private static int value = 6;
 }

File: src/test/test2/NewArray.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class NewArray {
     public int run() {
         return foo(1);

File: src/test/test2/NewExprTry.java
Patch:
@@ -15,6 +15,7 @@ public Object foo(int i) {
     }
 
     public static void main(String[] args) {
+        @SuppressWarnings("unused")
         NewExprTry obj = new NewExprTry(3);
     }
 }

File: src/test/test2/NewOp.java
Patch:
@@ -5,6 +5,7 @@ class NewOp2 {
 }
 
 public class NewOp {
+    @SuppressWarnings("rawtypes")
     java.util.Vector listenerList;
     static int i = 0;
     static String s;

File: src/test/test2/Prune.java
Patch:
@@ -1,6 +1,8 @@
 package test2;
 
 public class Prune extends java.awt.Point implements Cloneable, Runnable {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     public int value;
 
     public Prune(int i) {

File: src/test/test3/Enhancer.java
Patch:
@@ -11,6 +11,7 @@ class EnhanceTest {
     public void foo(String s) { System.out.println(s); }
 }
 
+@SuppressWarnings({"rawtypes","unchecked","unused"})
 public class Enhancer {
     private ClassPool pool;
     private CtClass superClass;

File: src/test/test3/Erasure.java
Patch:
@@ -9,6 +9,7 @@ public class Erasure<T> {
     public Erasure(T t) { value = t; }
     public Erasure() { value = null; }
     public int run() {
+        @SuppressWarnings("unchecked")
         ErasureGet<String> obj = (ErasureGet<String>)new Erasure<String>("1234");
         return obj.get().length();
     }

File: src/test/test3/FieldAccessType.java
Patch:
@@ -4,6 +4,7 @@ public class FieldAccessType {
     private int[] k;
     public void access() {
         k = new int[1];
+        @SuppressWarnings("unused")
         int i = 3;
         i += k[0];
     }

File: src/test/test3/GetMethods.java
Patch:
@@ -1,5 +1,6 @@
 package test3;
 
+@SuppressWarnings("unused")
 class SuperGetMethods {
     public int f0;
     protected double d0;
@@ -12,6 +13,7 @@ void mpack0() {}
     private void mpri0() {}
 }
 
+@SuppressWarnings("unused")
 public class GetMethods extends SuperGetMethods {
     public GetMethods(int i) {}
     protected GetMethods(String i, int j) {}

File: src/test/test3/MethodRedirect.java
Patch:
@@ -5,6 +5,7 @@ interface MethodRedirectIntf {
 }
 
 public class MethodRedirect implements MethodRedirectIntf {
+    @SuppressWarnings("unused")
     private int foo() { return 0; }
     public static int poi() { return 1; } 
     public int bar() { return 2; }

File: src/test/test3/NestedClass.java
Patch:
@@ -17,6 +17,7 @@ public Object foo() {
 
     public Object bar() {
         class Local {
+            @SuppressWarnings("unused")
             int j;
         }
         return new Local();

File: src/test/test3/NewExprTryCatch.java
Patch:
@@ -18,6 +18,7 @@ public void me2() throws Exception {
         // the error is somehow related to the string concatenation and local variables,
         // when the code below is replaced with something else, the error does not occur.
         String s1 = "a";
+        @SuppressWarnings("unused")
         String s2 = s1 + "b";
     }
 

File: src/test/test3/ReplaceNew.java
Patch:
@@ -6,6 +6,7 @@ public ReplaceNew(String s) {}
     int i = 0;
     public int run() {
         i = 3;
+        @SuppressWarnings("unused")
         ReplaceNew s = new ReplaceNew();
         new ReplaceNew();
         return i;

File: src/test/test3/Visible.java
Patch:
@@ -1,12 +1,14 @@
 package test3;
 
+@SuppressWarnings("unused")
 class Visible2 {
     public int pub;
     protected int pro;
     private int pri;
     int pack;
 }
 
+@SuppressWarnings("unused")
 public class Visible {
     public int pub;
     protected int pro;

File: src/test/test4/GetAllRefInnerTest.java
Patch:
@@ -20,6 +20,9 @@ public T bar(T b) {
     }
     public Object foo() {
         return new java.util.HashSet<String>() {
+            /** default serialVersionUID */
+            private static final long serialVersionUID = 1L;
+
             public String toString() { return this.getClass().toString(); } 
         };
     }

File: src/test/test4/JIRA181.java
Patch:
@@ -3,6 +3,9 @@
 import java.util.ArrayList;
 
 public class JIRA181<T extends Number> extends ArrayList<T> {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public @interface Condition {
     	Class<? extends ICondition> condition();
     }

File: src/test/testproxy/Target2.java
Patch:
@@ -2,6 +2,7 @@
 
 import java.io.IOException;
 
+@SuppressWarnings("unused")
 public class Target2 {
     private int value;
     public Target2(int i) { value = 1; }

File: src/test/testproxy/sub/TargetSuper.java
Patch:
@@ -1,5 +1,6 @@
 package testproxy.sub;
 
+@SuppressWarnings("unused")
 public class TargetSuper {
     private int poi() { return 1; }
     int poi2() { return 2; }

File: src/test/Jassist150.java
Patch:
@@ -6,6 +6,7 @@
 import javassist.expr.ExprEditor;
 import javassist.expr.MethodCall;
 
+@SuppressWarnings("unused")
 public class Jassist150 {
     public static final String BASE_PATH = "./";
     public static final String JAVASSIST_JAR = BASE_PATH + "javassist.jar";

File: src/test/Test.java
Patch:
@@ -2,6 +2,7 @@
 import java.util.List;
 import javassist.*;
 
+@SuppressWarnings("unused")
 class InvalidStackMapFrame {
 
 	public void bytecodeVerifyError1() {

File: src/test/VisibleTop.java
Patch:
@@ -1,3 +1,4 @@
+@SuppressWarnings("unused")
 public class VisibleTop {
     public int pub;
     protected int pro;

File: src/test/VisibleTop2.java
Patch:
@@ -1,3 +1,4 @@
+@SuppressWarnings("unused")
 public class VisibleTop2 {
     public int pub;
     protected int pro;

File: src/test/javassist/ClassPoolBench.java
Patch:
@@ -24,6 +24,7 @@ public static void accessClass(String name) throws Exception {
            cc.detach();
     }
 
+    @SuppressWarnings("rawtypes")
     public static void accessAll(String filename) throws Exception {
         ZipFile zip = new ZipFile(filename);
         Enumeration files = zip.entries();

File: src/test/javassist/JvstTest.java
Patch:
@@ -7,6 +7,7 @@
 import javassist.expr.*;
 import javassist.runtime.*;
 
+@SuppressWarnings({"rawtypes","unused", "resource"})
 public class JvstTest extends JvstTestRoot {
     public static boolean java9;
 

File: src/test/javassist/JvstTest2.java
Patch:
@@ -10,6 +10,7 @@
 
 import javassist.expr.*;
 
+@SuppressWarnings({"rawtypes","unused"})
 @FixMethodOrder(MethodSorters.NAME_ASCENDING)
 public class JvstTest2 extends JvstTestRoot {
     public JvstTest2(String name) {

File: src/test/javassist/JvstTest3.java
Patch:
@@ -5,6 +5,7 @@
 import javassist.expr.*;
 import test3.*;
 
+@SuppressWarnings({"rawtypes","unchecked","unused"})
 public class JvstTest3 extends JvstTestRoot {
     public JvstTest3(String name) {
          super(name);

File: src/test/javassist/JvstTest4.java
Patch:
@@ -13,6 +13,7 @@
 import javassist.bytecode.annotation.Annotation;
 import javassist.expr.*;
 
+@SuppressWarnings({"rawtypes","unchecked","unused"})
 @FixMethodOrder(MethodSorters.NAME_ASCENDING)
 public class JvstTest4 extends JvstTestRoot {
     public JvstTest4(String name) {

File: src/test/javassist/JvstTest5.java
Patch:
@@ -12,6 +12,7 @@
 import javassist.expr.ExprEditor;
 import javassist.expr.MethodCall;
 
+@SuppressWarnings({"rawtypes","unchecked","unused"})
 public class JvstTest5 extends JvstTestRoot {
     public JvstTest5(String name) {
         super(name);

File: src/test/javassist/LoaderTestByRandall.java
Patch:
@@ -11,6 +11,7 @@
 /**
  * @author brandall
  */
+@SuppressWarnings({"rawtypes","unused"})
 public class LoaderTestByRandall extends TestCase {
 
     ClassPool cp;

File: src/test/javassist/SetterTest.java
Patch:
@@ -3,6 +3,7 @@
 
 import junit.framework.TestCase;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class SetterTest extends TestCase {
 
     ClassPool pool;

File: src/test/javassist/bytecode/BytecodeTest.java
Patch:
@@ -7,6 +7,7 @@
 import javassist.bytecode.annotation.*;
 import javassist.bytecode.SignatureAttribute.*;
 
+@SuppressWarnings("unused")
 public class BytecodeTest extends TestCase {
     public static final String PATH = JvstTest.PATH;
     private ClassPool loader, dloader;

File: src/test/javassist/bytecode/CodeAnalyzerTest.java
Patch:
@@ -5,6 +5,7 @@
 import java.util.List;
 import java.io.*;
 
+@SuppressWarnings({"rawtypes","resource"})
 public class CodeAnalyzerTest {
     public static void main(String[] args) throws Exception {
         ZipFile zfile = new ZipFile(args[0]);

File: src/test/javassist/bytecode/InsertGap0.java
Patch:
@@ -2,6 +2,7 @@
 
 import javassist.*;
 
+@SuppressWarnings("unused")
 final class Gap0Example {
     public static int counter = 1;
 
@@ -70,6 +71,7 @@ public void doit() {
     }
 }
 
+@SuppressWarnings("unused")
 final class Gap0Example2 {
     public static int counter = 1;
 
@@ -155,6 +157,7 @@ public int run2(int x) {
     }
 }
 
+@SuppressWarnings({"rawtypes","unchecked","unused"})
 public final class InsertGap0 extends JvstTestRoot {
     public InsertGap0(String name) {
         super(name);

File: src/test/javassist/bytecode/StackMapTest.java
Patch:
@@ -21,6 +21,7 @@
 import javassist.bytecode.stackmap.TypeData;
 import junit.framework.TestCase;
 
+@SuppressWarnings({"rawtypes","unused"})
 public class StackMapTest extends TestCase {
     public static final String PATH = JvstTest.PATH;
     private ClassPool loader, dloader;

File: src/test/javassist/compiler/CompTest.java
Patch:
@@ -125,6 +125,7 @@ class Print{
     public static int k;
 }
 
+@SuppressWarnings({"rawtypes","unchecked"})
 class HelloAspect{
   List list;
   

File: src/test/javassist/proxyfactory/ProxyFactoryTest.java
Patch:
@@ -11,6 +11,7 @@
 /**
  * <a href="mailto:struberg@yahoo.de">Mark Struberg</a>
  */
+@SuppressWarnings({"rawtypes","unchecked","unused"})
 public class ProxyFactoryTest extends TestCase {
     public void testMethodHandlers() throws Exception {
         ProxyFactory fact = new ProxyFactory();

File: src/test/javassist/proxyfactory/Tester.java
Patch:
@@ -14,6 +14,7 @@ class Hand implements java.io.Serializable {
     int getHandler() { return 3; }
 }
 
+@SuppressWarnings({"rawtypes","unchecked","resource"})
 public class Tester extends TestCase {
     static class MHandler implements MethodHandler, java.io.Serializable {
         /** default serialVersionUID */

File: src/test/test/javassist/bytecode/analysis/AnalyzerTest.java
Patch:
@@ -363,6 +363,7 @@ public A sharedSuperWithSharedInterface(int x) {
         }
 
 
+        @SuppressWarnings("rawtypes")
         public void reusedLocalMerge() {
              ArrayList list = new ArrayList();
              try {

File: src/test/test/javassist/convert/ArrayAccessReplaceTest.java
Patch:
@@ -147,6 +147,7 @@ public void testMulti() throws Exception {
         }
     }
 
+    @SuppressWarnings({"rawtypes","unchecked"})
     public static class Echo {
         public static Map byteMap = new HashMap();
         public static Map charMap = new HashMap();

File: src/test/test/javassist/proxy/JBPAPP9257Test.java
Patch:
@@ -8,6 +8,7 @@
 import javassist.util.proxy.Proxy;
 import junit.framework.TestCase;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class JBPAPP9257Test extends TestCase {
     public void testGetHandler() throws Exception {
         ProxyFactory f = new ProxyFactory();

File: src/test/test/javassist/proxy/ProxyCacheGCTest.java
Patch:
@@ -11,6 +11,7 @@
  * test which checks that proxy classes are not retained after their classloader is released.
  * this is a before and after test which validates JASSIST-104
  */
+@SuppressWarnings({"rawtypes","unchecked"})
 public class ProxyCacheGCTest extends TestCase
 {
     /**

File: src/test/test/javassist/proxy/ProxyFactoryCompatibilityTest.java
Patch:
@@ -16,6 +16,7 @@
  * automatically disabled if this legacy api is used. it also exercises the new style
  * api, ensuring that caching works correctly with this model.
  */
+@SuppressWarnings({"rawtypes","unchecked","unused"})
 public class ProxyFactoryCompatibilityTest extends TestCase
 {
     private ClassPool basePool;

File: src/test/test/javassist/proxy/ProxySerializationTest.java
Patch:
@@ -13,6 +13,7 @@
  * {@link javassist.util.proxy.ProxyObjectOutputStream} and  @link javassist.util.proxy.ProxyObjectInputStream}
  * reuses classes located in the proxy cache. This tests the fixes provided for JASSIST-42 and JASSIST-97.
  */
+@SuppressWarnings({"rawtypes","unchecked","unused","resource"})
 public class ProxySerializationTest extends TestCase
 {
     public void testSerialization()

File: src/test/test/javassist/proxy/ProxySimpleTest.java
Patch:
@@ -14,6 +14,7 @@
 import javassist.util.proxy.Proxy;
 import javassist.util.proxy.ProxyFactory;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class ProxySimpleTest extends TestCase {
 
     String testResult;

File: src/test/test/javassist/tools/DummyClass.java
Patch:
@@ -2,6 +2,7 @@
 
 public class DummyClass {
 
+    @SuppressWarnings("unused")
     private String dummyString = "dummyStringValue";
 
     public void dummyMethod(){}

File: src/test/test1/FieldMod.java
Patch:
@@ -1,6 +1,7 @@
 package test1;
 
 public class FieldMod {
+    @SuppressWarnings("unused")
     private String text;
     public int i;
 }

File: src/test/test1/Howard.java
Patch:
@@ -21,6 +21,7 @@ class Howard2 {
 }
 
 public class Howard extends Howard2 {
+    @SuppressWarnings("unused")
     private Object _remote;
 
     public int run() {

File: src/test/test1/Proceed.java
Patch:
@@ -1,5 +1,6 @@
 package test1;
 
+@SuppressWarnings("unused")
 public class Proceed {
     public int p(int i, int j) { return i + j; }
 

File: src/test/test1/RenameClass.java
Patch:
@@ -6,6 +6,7 @@ class RenameClass2 {
     String name;
 }
 
+@SuppressWarnings({"rawtypes","unchecked", "unused"})
 public class RenameClass {
     private Hashtable table;
     public RenameClass() {

File: src/test/test2/AddMethod.java
Patch:
@@ -1,6 +1,7 @@
 package test2;
 
 public class AddMethod {
+    @SuppressWarnings("unused")
     private int f;
 
     public int f() { return 0; }

File: src/test/test2/Anon.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class Anon {
     public Object make() {
         return new Object() { int k; };

File: src/test/test2/Brennan.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class Brennan {
     private Object format = null;
 }

File: src/test/test2/Inner.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class Inner {
     public void sample() throws Exception {
         java.util.Properties props = new java.util.Properties();

File: src/test/test2/InsertLocal.java
Patch:
@@ -22,6 +22,7 @@ public int run2() {
         return k + s.length();
     }
 
+    @SuppressWarnings("unused")
     public int run3() {
         int i = 0;
         int j = field;

File: src/test/test2/Nested.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class Nested {
     private int i = 3;
     private int geti() { return i; }

File: src/test/test2/Nested2.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class Nested2 {
     private int i = 3;
     private double d = 3.0;

File: src/test/test2/Nested3.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class Nested3 {
     private int i = 0;
     private int geti() { return i; }

File: src/test/test2/Nested4.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class Nested4 {
     private static int value = 6;
 }

File: src/test/test2/NewArray.java
Patch:
@@ -1,5 +1,6 @@
 package test2;
 
+@SuppressWarnings("unused")
 public class NewArray {
     public int run() {
         return foo(1);

File: src/test/test2/NewExprInTry.java
Patch:
@@ -2,6 +2,7 @@
 
 import java.util.HashMap;
 
+@SuppressWarnings("rawtypes")
 class HashMapWrapper extends HashMap {
     /** default serialVersionUID */
     private static final long serialVersionUID = 1L;
@@ -11,6 +12,7 @@ class HashMapWrapper extends HashMap {
     }
 }
 
+@SuppressWarnings({"rawtypes","unused"})
 public class NewExprInTry {
     public int run() {
         return foo(6);

File: src/test/test2/NewExprTry.java
Patch:
@@ -15,6 +15,7 @@ public Object foo(int i) {
     }
 
     public static void main(String[] args) {
+        @SuppressWarnings("unused")
         NewExprTry obj = new NewExprTry(3);
     }
 }

File: src/test/test2/NewOp.java
Patch:
@@ -5,6 +5,7 @@ class NewOp2 {
 }
 
 public class NewOp {
+    @SuppressWarnings("rawtypes")
     java.util.Vector listenerList;
     static int i = 0;
     static String s;

File: src/test/test3/Enhancer.java
Patch:
@@ -11,6 +11,7 @@ class EnhanceTest {
     public void foo(String s) { System.out.println(s); }
 }
 
+@SuppressWarnings({"rawtypes","unchecked","unused"})
 public class Enhancer {
     private ClassPool pool;
     private CtClass superClass;

File: src/test/test3/Erasure.java
Patch:
@@ -9,6 +9,7 @@ public class Erasure<T> {
     public Erasure(T t) { value = t; }
     public Erasure() { value = null; }
     public int run() {
+        @SuppressWarnings("unchecked")
         ErasureGet<String> obj = (ErasureGet<String>)new Erasure<String>("1234");
         return obj.get().length();
     }

File: src/test/test3/FieldAccessType.java
Patch:
@@ -4,6 +4,7 @@ public class FieldAccessType {
     private int[] k;
     public void access() {
         k = new int[1];
+        @SuppressWarnings("unused")
         int i = 3;
         i += k[0];
     }

File: src/test/test3/GetMethods.java
Patch:
@@ -1,5 +1,6 @@
 package test3;
 
+@SuppressWarnings("unused")
 class SuperGetMethods {
     public int f0;
     protected double d0;
@@ -12,6 +13,7 @@ void mpack0() {}
     private void mpri0() {}
 }
 
+@SuppressWarnings("unused")
 public class GetMethods extends SuperGetMethods {
     public GetMethods(int i) {}
     protected GetMethods(String i, int j) {}

File: src/test/test3/MethodRedirect.java
Patch:
@@ -5,6 +5,7 @@ interface MethodRedirectIntf {
 }
 
 public class MethodRedirect implements MethodRedirectIntf {
+    @SuppressWarnings("unused")
     private int foo() { return 0; }
     public static int poi() { return 1; } 
     public int bar() { return 2; }

File: src/test/test3/NestedClass.java
Patch:
@@ -17,6 +17,7 @@ public Object foo() {
 
     public Object bar() {
         class Local {
+            @SuppressWarnings("unused")
             int j;
         }
         return new Local();

File: src/test/test3/NewExprTryCatch.java
Patch:
@@ -18,6 +18,7 @@ public void me2() throws Exception {
         // the error is somehow related to the string concatenation and local variables,
         // when the code below is replaced with something else, the error does not occur.
         String s1 = "a";
+        @SuppressWarnings("unused")
         String s2 = s1 + "b";
     }
 

File: src/test/test3/ReplaceNew.java
Patch:
@@ -6,6 +6,7 @@ public ReplaceNew(String s) {}
     int i = 0;
     public int run() {
         i = 3;
+        @SuppressWarnings("unused")
         ReplaceNew s = new ReplaceNew();
         new ReplaceNew();
         return i;

File: src/test/test3/Visible.java
Patch:
@@ -1,12 +1,14 @@
 package test3;
 
+@SuppressWarnings("unused")
 class Visible2 {
     public int pub;
     protected int pro;
     private int pri;
     int pack;
 }
 
+@SuppressWarnings("unused")
 public class Visible {
     public int pub;
     protected int pro;

File: src/test/testproxy/ProxyFactoryPerformanceTest.java
Patch:
@@ -17,6 +17,7 @@
 import junit.framework.TestSuite;
 import junit.textui.TestRunner;
 
+@SuppressWarnings({"rawtypes","unchecked", "unused"})
 public class ProxyFactoryPerformanceTest extends TestCase {
 
 	public static final int COUNT = 100; 
@@ -84,6 +85,7 @@ public static void main(String[] args) {
 	}
 }
 
+@SuppressWarnings({"rawtypes","unused"})
 class ProxyMaker extends Thread implements MethodHandler {
 	private static final MethodFilter FINALIZE_FILTER = new MethodFilter() {
 		public boolean isHandled(Method m) {

File: src/test/testproxy/ProxyTester.java
Patch:
@@ -15,6 +15,7 @@
 import junit.framework.TestCase;
 import java.io.*;
 
+@SuppressWarnings({"unchecked", "rawtypes","unused"})
 public class ProxyTester extends TestCase {
     public ProxyTester(String s) {
         super(s);

File: src/test/testproxy/Target2.java
Patch:
@@ -2,6 +2,7 @@
 
 import java.io.IOException;
 
+@SuppressWarnings("unused")
 public class Target2 {
     private int value;
     public Target2(int i) { value = 1; }

File: src/test/testproxy/sub/TargetSuper.java
Patch:
@@ -1,5 +1,6 @@
 package testproxy.sub;
 
+@SuppressWarnings("unused")
 public class TargetSuper {
     private int poi() { return 1; }
     int poi2() { return 2; }

File: src/main/javassist/ClassPath.java
Patch:
@@ -39,7 +39,7 @@ public interface ClassPath {
      *
      * <p>This method can return null if the specified class file is not
      * found.  If null is returned, the next search path is examined.
-     * However, if an error happens, this method must throw an exception 
+     * However, if an error happens, this method must throw an exception
      * so that the search will be terminated.
      *
      * <p>This method should not modify the contents of the class file.

File: src/main/javassist/CtPrimitiveType.java
Patch:
@@ -47,6 +47,7 @@ public final class CtPrimitiveType extends CtClass {
      * Java type: boolean, byte, char, short, int, long, float, double,
      * or void.
      */
+    @Override
     public boolean isPrimitive() { return true; }
 
     /**
@@ -55,6 +56,7 @@ public final class CtPrimitiveType extends CtClass {
      *
      * @see Modifier
      */
+    @Override
     public int getModifiers() {
         return Modifier.PUBLIC | Modifier.FINAL;
     }

File: src/main/javassist/bytecode/AnnotationDefaultAttribute.java
Patch:
@@ -104,7 +104,8 @@ public AnnotationDefaultAttribute(ConstPool cp) {
     /**
      * Copies this attribute and returns a new copy.
      */
-    public AttributeInfo copy(ConstPool newCp, Map classnames) {
+    @Override
+    public AttributeInfo copy(ConstPool newCp, Map<String,String> classnames) {
         AnnotationsAttribute.Copier copier
             = new AnnotationsAttribute.Copier(info, constPool, newCp, classnames);
         try {
@@ -154,6 +155,7 @@ public void setDefaultValue(MemberValue value) {
     /**
      * Returns a string representation of this object.
      */
+    @Override
     public String toString() {
         return getDefaultValue().toString();
     }

File: src/main/javassist/bytecode/BootstrapMethodsAttribute.java
Patch:
@@ -108,7 +108,8 @@ public BootstrapMethod[] getMethods() {
      * @param classnames        pairs of replaced and substituted
      *                          class names.
      */
-    public AttributeInfo copy(ConstPool newCp, Map classnames) {
+    @Override
+    public AttributeInfo copy(ConstPool newCp, Map<String,String> classnames) {
         BootstrapMethod[] methods = getMethods();
         ConstPool thisCp = getConstPool();
         for (int i = 0; i < methods.length; i++) {

File: src/main/javassist/bytecode/ByteStream.java
Patch:
@@ -38,16 +38,19 @@ public void writeBlank(int len) {
         count += len;
     }
 
+    @Override
     public void write(byte[] data) {
         write(data, 0, data.length);
     }
 
+    @Override
     public void write(byte[] data, int off, int len) {
         enlarge(len);
         System.arraycopy(data, off, buf, count, len);
         count += len;
     }
 
+    @Override
     public void write(int b) {
         enlarge(1);
         int oldCount = count;

File: src/main/javassist/bytecode/ConstantAttribute.java
Patch:
@@ -65,7 +65,8 @@ public int getConstantValue() {
      * @param classnames        pairs of replaced and substituted
      *                          class names.
      */
-    public AttributeInfo copy(ConstPool newCp, Map classnames) {
+    @Override
+    public AttributeInfo copy(ConstPool newCp, Map<String,String> classnames) {
         int index = getConstPool().copy(getConstantValue(), newCp,
                                         classnames);
         return new ConstantAttribute(newCp, index);

File: src/main/javassist/bytecode/DeprecatedAttribute.java
Patch:
@@ -50,7 +50,8 @@ public DeprecatedAttribute(ConstPool cp) {
      * @param newCp     the constant pool table used by the new copy.
      * @param classnames        should be null.
      */
-    public AttributeInfo copy(ConstPool newCp, Map classnames) {
+    @Override
+    public AttributeInfo copy(ConstPool newCp, Map<String,String> classnames) {
         return new DeprecatedAttribute(newCp);
     }
 }

File: src/main/javassist/bytecode/LineNumberAttribute.java
Patch:
@@ -156,7 +156,8 @@ public Pc toNearPc(int line) {
      * @param newCp     the constant pool table used by the new copy.
      * @param classnames        should be null.
      */
-    public AttributeInfo copy(ConstPool newCp, Map classnames) {
+    @Override
+    public AttributeInfo copy(ConstPool newCp, Map<String,String> classnames) {
         byte[] src = info;
         int num = src.length;
         byte[] dest = new byte[num];

File: src/main/javassist/bytecode/MethodParametersAttribute.java
Patch:
@@ -72,7 +72,8 @@ public int accessFlags(int i) {
      * @param newCp     the constant pool table used by the new copy.
      * @param classnames        ignored.
      */
-    public AttributeInfo copy(ConstPool newCp, Map classnames) {
+    @Override
+    public AttributeInfo copy(ConstPool newCp, Map<String,String> classnames) {
         int s = size();
         ConstPool cp = getConstPool();
         String[] names = new String[s];

File: src/main/javassist/bytecode/SourceFileAttribute.java
Patch:
@@ -65,7 +65,8 @@ public String getFileName() {
      * @param classnames        pairs of replaced and substituted
      *                          class names.
      */
-    public AttributeInfo copy(ConstPool newCp, Map classnames) {
+    @Override
+    public AttributeInfo copy(ConstPool newCp, Map<String,String> classnames) {
         return new SourceFileAttribute(newCp, getFileName());
     }
 }

File: src/main/javassist/bytecode/SyntheticAttribute.java
Patch:
@@ -50,7 +50,8 @@ public SyntheticAttribute(ConstPool cp) {
      * @param newCp     the constant pool table used by the new copy.
      * @param classnames        should be null.
      */
-    public AttributeInfo copy(ConstPool newCp, Map classnames) {
+    @Override
+    public AttributeInfo copy(ConstPool newCp, Map<String,String> classnames) {
         return new SyntheticAttribute(newCp);
     }
 }

File: src/main/javassist/bytecode/analysis/Frame.java
Patch:
@@ -229,6 +229,7 @@ public boolean merge(Frame frame) {
         return changed;
     }
 
+    @Override
     public String toString() {
         StringBuffer buffer = new StringBuffer();
 

File: src/main/javassist/bytecode/annotation/TypeAnnotationsWriter.java
Patch:
@@ -28,6 +28,7 @@ public TypeAnnotationsWriter(OutputStream os, ConstPool cp) {
      * {@code Runtime(In)VisibleTypeAnnotations_attribute}.
      * It must be followed by {@code num} instances of {@code type_annotation}.
      */
+    @Override
     public void numAnnotations(int num) throws IOException {
         super.numAnnotations(num);
     }

File: src/main/javassist/bytecode/stackmap/TypedBlock.java
Patch:
@@ -54,6 +54,7 @@ protected TypedBlock(int pos) {
         localsTypes = null;
     }
 
+    @Override
     protected void toString2(StringBuffer sbuf) {
         super.toString2(sbuf);
         sbuf.append(",\n stack={");
@@ -110,10 +111,12 @@ public void resetNumLocals() {
     }
 
     public static class Maker extends BasicBlock.Maker {
+        @Override
         protected BasicBlock makeBlock(int pos) {
             return new TypedBlock(pos);
         }
 
+        @Override
         protected BasicBlock[] makeArray(int size) {
             return new TypedBlock[size];
         }

File: src/main/javassist/compiler/AccessorMaker.java
Patch:
@@ -19,6 +19,7 @@
 import javassist.*;
 import javassist.bytecode.*;
 import java.util.HashMap;
+import java.util.Map;
 
 /**
  * AccessorMaker maintains accessors to private members of an enclosing
@@ -27,14 +28,14 @@
 public class AccessorMaker {
     private CtClass clazz;
     private int uniqueNumber;
-    private HashMap accessors;
+    private Map<String,Object> accessors;
 
     static final String lastParamType = "javassist.runtime.Inner";
 
     public AccessorMaker(CtClass c) {
         clazz = c;
         uniqueNumber = 1;
-        accessors = new HashMap();
+        accessors = new HashMap<String,Object>();
     }
 
     public String getConstructor(CtClass c, String desc, MethodInfo orig)

File: src/main/javassist/compiler/CompileError.java
Patch:
@@ -45,10 +45,12 @@ public CompileError(NotFoundException e) {
 
     public Lex getLex() { return lex; }
 
+    @Override
     public String getMessage() {
         return reason;
     }
 
+    @Override
     public String toString() {
         return "compile error: " + reason;
     }

File: src/main/javassist/compiler/ast/ASTree.java
Patch:
@@ -43,6 +43,7 @@ public void setRight(ASTree _right) {}
      */
     public abstract void accept(Visitor v) throws CompileError;
 
+    @Override
     public String toString() {
         StringBuffer sbuf = new StringBuffer();
         sbuf.append('<');

File: src/main/javassist/compiler/ast/ArrayInit.java
Patch:
@@ -29,7 +29,9 @@ public ArrayInit(ASTree firstElement) {
         super(firstElement);
     }
 
+    @Override
     public void accept(Visitor v) throws CompileError { v.atArrayInit(this); }
 
+    @Override
     public String getTag() { return "array"; }
 }

File: src/main/javassist/compiler/ast/AssignExpr.java
Patch:
@@ -38,6 +38,7 @@ public static AssignExpr makeAssign(int op, ASTree oprand1,
         return new AssignExpr(op, oprand1, new ASTList(oprand2));
     }
 
+    @Override
     public void accept(Visitor v) throws CompileError {
         v.atAssignExpr(this);
     }

File: src/main/javassist/compiler/ast/BinExpr.java
Patch:
@@ -41,5 +41,6 @@ public static BinExpr makeBin(int op, ASTree oprand1, ASTree oprand2) {
         return new BinExpr(op, oprand1, new ASTList(oprand2));
     }
 
+    @Override
     public void accept(Visitor v) throws CompileError { v.atBinExpr(this); }
 }

File: src/main/javassist/compiler/ast/CallExpr.java
Patch:
@@ -45,5 +45,6 @@ public static CallExpr makeCall(ASTree target, ASTree args) {
         return new CallExpr(target, new ASTList(args));
     }
 
+    @Override
     public void accept(Visitor v) throws CompileError { v.atCallExpr(this); }
 }

File: src/main/javassist/compiler/ast/CastExpr.java
Patch:
@@ -52,7 +52,9 @@ public CastExpr(int type, int dim, ASTree expr) {
 
     public void setOprand(ASTree t) { getRight().setLeft(t); }
 
+    @Override
     public String getTag() { return "cast:" + castType + ":" + arrayDim; }
 
+    @Override
     public void accept(Visitor v) throws CompileError { v.atCastExpr(this); }
 }

File: src/main/javassist/compiler/ast/CondExpr.java
Patch:
@@ -41,7 +41,9 @@ public CondExpr(ASTree cond, ASTree thenp, ASTree elsep) {
 
     public void setElse(ASTree t) { tail().tail().setHead(t); } 
 
+    @Override
     public String getTag() { return "?:"; }
 
+    @Override
     public void accept(Visitor v) throws CompileError { v.atCondExpr(this); }
 }

File: src/main/javassist/compiler/ast/Declarator.java
Patch:
@@ -88,16 +88,17 @@ public ASTree getInitializer() {
         ASTList t = tail();
         if (t != null)
             return t.head();
-        else
-            return null;
+        return null;
     }
 
     public void setLocalVar(int n) { localVar = n; }
 
     public int getLocalVar() { return localVar; }
 
+    @Override
     public String getTag() { return "decl"; }
 
+    @Override
     public void accept(Visitor v) throws CompileError {
         v.atDeclarator(this);
     }

File: src/main/javassist/compiler/ast/DoubleConst.java
Patch:
@@ -38,8 +38,10 @@ public class DoubleConst extends ASTree {
      */
     public int getType() { return type; }
 
+    @Override
     public String toString() { return Double.toString(value); }
 
+    @Override
     public void accept(Visitor v) throws CompileError {
         v.atDoubleConst(this);
     }
@@ -65,7 +67,7 @@ private DoubleConst compute0(int op, DoubleConst right) {
     }
 
     private DoubleConst compute0(int op, IntConst right) {
-        return compute(op, this.value, (double)right.value, this.type);
+        return compute(op, this.value, right.value, this.type);
     }
 
     private static DoubleConst compute(int op, double value1, double value2,

File: src/main/javassist/compiler/ast/Expr.java
Patch:
@@ -67,6 +67,7 @@ public void setOprand2(ASTree expr) {
         getRight().setLeft(expr);
     }
 
+    @Override
     public void accept(Visitor v) throws CompileError { v.atExpr(this); }
 
     public String getName() {
@@ -81,6 +82,7 @@ else if (id == INSTANCEOF)
             return String.valueOf(id);
     }
 
+    @Override
     protected String getTag() {
         return "op:" + getName();
     }

File: src/main/javassist/compiler/ast/FieldDecl.java
Patch:
@@ -30,8 +30,9 @@ public FieldDecl(ASTree _head, ASTList _tail) {
 
     public Declarator getDeclarator() { return (Declarator)tail().head(); }
 
-    public ASTree getInit() { return (ASTree)sublist(2).head(); }
+    public ASTree getInit() { return sublist(2).head(); }
 
+    @Override
     public void accept(Visitor v) throws CompileError {
         v.atFieldDecl(this);
     }

File: src/main/javassist/compiler/ast/InstanceOfExpr.java
Patch:
@@ -33,10 +33,12 @@ public InstanceOfExpr(int type, int dim, ASTree expr) {
         super(type, dim, expr);
     }
 
+    @Override
     public String getTag() {
         return "instanceof:" + castType + ":" + arrayDim;
     }
 
+    @Override
     public void accept(Visitor v) throws CompileError {
         v.atInstanceOfExpr(this);
     }

File: src/main/javassist/compiler/ast/IntConst.java
Patch:
@@ -38,8 +38,10 @@ public class IntConst extends ASTree {
      */
     public int getType() { return type; }
 
+    @Override
     public String toString() { return Long.toString(value); }
 
+    @Override
     public void accept(Visitor v) throws CompileError {
         v.atIntConst(this);
     }
@@ -113,7 +115,7 @@ else if (type1 == TokenId.CharConstant
     }
 
     private DoubleConst compute0(int op, DoubleConst right) {
-        double value1 = (double)this.value;
+        double value1 = this.value;
         double value2 = right.value;
         double newValue;
         switch (op) {

File: src/main/javassist/compiler/ast/Keyword.java
Patch:
@@ -32,7 +32,9 @@ public Keyword(int token) {
 
     public int get() { return tokenId; }
 
+    @Override
     public String toString() { return "id:" + tokenId; }
 
+    @Override
     public void accept(Visitor v) throws CompileError { v.atKeyword(this); }
 }

File: src/main/javassist/compiler/ast/Member.java
Patch:
@@ -38,5 +38,6 @@ public Member(String name) {
 
     public CtField getField() { return field; }
 
+    @Override
     public void accept(Visitor v) throws CompileError { v.atMember(this); }
 }

File: src/main/javassist/compiler/ast/MethodDecl.java
Patch:
@@ -42,6 +42,7 @@ public boolean isConstructor() {
 
     public Stmnt getBody() { return (Stmnt)sublist(4).head(); }
 
+    @Override
     public void accept(Visitor v) throws CompileError {
         v.atMethodDecl(this);
     }

File: src/main/javassist/compiler/ast/NewExpr.java
Patch:
@@ -68,12 +68,13 @@ public ArrayInit getInitializer() {
         ASTree t = getRight().getRight();
         if (t == null)
             return null;
-        else
-            return (ArrayInit)t.getLeft();
+        return (ArrayInit)t.getLeft();
     }
 
+    @Override
     public void accept(Visitor v) throws CompileError { v.atNewExpr(this); }
 
+    @Override
     protected String getTag() {
         return newArray ? "new[]" : "new";
     }

File: src/main/javassist/compiler/ast/Stmnt.java
Patch:
@@ -49,14 +49,15 @@ public static Stmnt make(int op, ASTree op1, ASTree op2, ASTree op3) {
         return new Stmnt(op, op1, new ASTList(op2, new ASTList(op3)));
     }
 
+    @Override
     public void accept(Visitor v) throws CompileError { v.atStmnt(this); }
 
     public int getOperator() { return operatorId; }
 
+    @Override
     protected String getTag() {
         if (operatorId < 128)
             return "stmnt:" + (char)operatorId;
-        else
-            return "stmnt:" + operatorId;
+        return "stmnt:" + operatorId;
     }
 }

File: src/main/javassist/compiler/ast/StringL.java
Patch:
@@ -32,7 +32,9 @@ public StringL(String t) {
 
     public String get() { return text; }
 
+    @Override
     public String toString() { return "\"" + text + "\""; }
 
+    @Override
     public void accept(Visitor v) throws CompileError { v.atStringL(this); }
 }

File: src/main/javassist/compiler/ast/Symbol.java
Patch:
@@ -32,7 +32,9 @@ public Symbol(String sym) {
 
     public String get() { return identifier; }
 
+    @Override
     public String toString() { return identifier; }
 
+    @Override
     public void accept(Visitor v) throws CompileError { v.atSymbol(this); }
 }

File: src/main/javassist/compiler/ast/Variable.java
Patch:
@@ -33,9 +33,11 @@ public Variable(String sym, Declarator d) {
 
     public Declarator getDeclarator() { return declarator; }
 
+    @Override
     public String toString() {
         return identifier + ":" + declarator.getType();
     }
 
+    @Override
     public void accept(Visitor v) throws CompileError { v.atVariable(this); }
 }

File: src/main/javassist/convert/TransformAccessArrayField.java
Patch:
@@ -16,7 +16,6 @@
 package javassist.convert;
 
 import javassist.CannotCompileException;
-import javassist.ClassPool;
 import javassist.CtClass;
 import javassist.NotFoundException;
 import javassist.CodeConverter.ArrayAccessReplacementMethodNames;
@@ -49,6 +48,7 @@ public TransformAccessArrayField(Transformer next, String methodClassname,
 
     }
 
+    @Override
     public void initialize(ConstPool cp, CtClass clazz, MethodInfo minfo) throws CannotCompileException {
         /*
          * This transformer must be isolated from other transformers, since some
@@ -85,11 +85,13 @@ public void initialize(ConstPool cp, CtClass clazz, MethodInfo minfo) throws Can
         }
     }
 
+    @Override
     public void clean() {
         frames = null;
         offset = -1;
     }
 
+    @Override
     public int transform(CtClass tclazz, int pos, CodeIterator iterator,
             ConstPool cp) throws BadBytecode {
         // Do nothing, see above comment

File: src/main/javassist/convert/TransformAfter.java
Patch:
@@ -28,6 +28,7 @@ public TransformAfter(Transformer next,
         super(next, origMethod, afterMethod);
     }
 
+    @Override
     protected int match2(int pos, CodeIterator iterator) throws BadBytecode {
         iterator.move(pos);
         iterator.insert(saveCode);

File: src/main/javassist/convert/TransformBefore.java
Patch:
@@ -42,13 +42,15 @@ public TransformBefore(Transformer next,
         saveCode = loadCode = null;
     }
 
+    @Override
     public void initialize(ConstPool cp, CodeAttribute attr) {
         super.initialize(cp, attr);
         locals = 0;
         maxLocals = attr.getMaxLocals();
         saveCode = loadCode = null;
     }
 
+    @Override
     protected int match(int c, int pos, CodeIterator iterator,
                         int typedesc, ConstPool cp) throws BadBytecode
     {
@@ -78,6 +80,7 @@ protected int match2(int pos, CodeIterator iterator) throws BadBytecode {
         return iterator.next();
     }
 
+    @Override
     public int extraLocals() { return locals; }
 
     protected void makeCode(CtClass[] paramTypes, ConstPool cp) {

File: src/main/javassist/convert/TransformCall.java
Patch:
@@ -51,6 +51,7 @@ public TransformCall(Transformer next, String oldMethodName,
         newMethodIsPrivate = Modifier.isPrivate(substMethod.getModifiers());
     }
 
+    @Override
     public void initialize(ConstPool cp, CodeAttribute attr) {
         if (constPool != cp)
             newIndex = 0;
@@ -63,6 +64,7 @@ public void initialize(ConstPool cp, CodeAttribute attr) {
      * by <code>classname</code>.   This method transforms the instruction
      * in that case unless the subclass overrides the target method.
      */
+    @Override
     public int transform(CtClass clazz, int pos, CodeIterator iterator,
                          ConstPool cp) throws BadBytecode
     {

File: src/main/javassist/convert/TransformFieldAccess.java
Patch:
@@ -43,6 +43,7 @@ public TransformFieldAccess(Transformer next, CtField field,
         this.constPool = null;
     }
 
+    @Override
     public void initialize(ConstPool cp, CodeAttribute attr) {
         if (constPool != cp)
             newIndex = 0;
@@ -54,6 +55,7 @@ public void initialize(ConstPool cp, CodeAttribute attr) {
      * in a superclass of the class in which the original field is
      * declared.
      */
+    @Override
     public int transform(CtClass clazz, int pos,
                          CodeIterator iterator, ConstPool cp)
     {

File: src/main/javassist/convert/TransformNew.java
Patch:
@@ -32,6 +32,7 @@ public TransformNew(Transformer next,
         this.trapMethod = trapMethod;
     }
 
+    @Override
     public void initialize(ConstPool cp, CodeAttribute attr) {
         nested = 0;
     }
@@ -48,6 +49,7 @@ public void initialize(ConstPool cp, CodeAttribute attr) {
      *    ...
      *    INVOKESTATIC trapMethod in trapClass
      */
+    @Override
     public int transform(CtClass clazz, int pos, CodeIterator iterator,
                          ConstPool cp) throws CannotCompileException
     {

File: src/main/javassist/convert/TransformNewClass.java
Patch:
@@ -32,6 +32,7 @@ public TransformNewClass(Transformer next,
         this.newClassName = newClassName;
     }
 
+    @Override
     public void initialize(ConstPool cp, CodeAttribute attr) {
         nested = 0;
         newClassIndex = newMethodNTIndex = newMethodIndex = 0;
@@ -44,6 +45,7 @@ public void initialize(ConstPool cp, CodeAttribute attr) {
      *    ...
      *    INVOKESPECIAL classname:method
      */
+    @Override
     public int transform(CtClass clazz, int pos, CodeIterator iterator,
                          ConstPool cp) throws CannotCompileException
     {

File: src/main/javassist/convert/TransformReadField.java
Patch:
@@ -66,6 +66,7 @@ static boolean isFieldInSuper(CtClass clazz, CtClass fclass, String fname) {
         return false;
     }
 
+    @Override
     public int transform(CtClass tclazz, int pos, CodeIterator iterator,
                          ConstPool cp) throws BadBytecode
     {

File: src/main/javassist/convert/TransformWriteField.java
Patch:
@@ -27,6 +27,7 @@ public TransformWriteField(Transformer next, CtField field,
         super(next, field, methodClassname, methodName);
     }
 
+    @Override
     public int transform(CtClass tclazz, int pos, CodeIterator iterator,
                          ConstPool cp) throws BadBytecode
     {

File: src/main/javassist/expr/ConstructorCall.java
Patch:
@@ -40,6 +40,7 @@ protected ConstructorCall(int pos, CodeIterator i, CtClass decl, MethodInfo m) {
     /**
      * Returns <code>"super"</code> or "<code>"this"</code>.
      */
+    @Override
     public String getMethodName() {
         return isSuper() ? "super" : "this";
     }
@@ -49,6 +50,7 @@ public String getMethodName() {
      *
      * @see #getConstructor()
      */
+    @Override
     public CtMethod getMethod() throws NotFoundException {
         throw new NotFoundException("this is a constructor call.  Call getConstructor().");
     }
@@ -64,6 +66,7 @@ public CtConstructor getConstructor() throws NotFoundException {
      * Returns true if the called constructor is not <code>this()</code>
      * but <code>super()</code> (a constructor declared in the super class).
      */
+    @Override
     public boolean isSuper() {
         return super.isSuper();
     }

File: src/main/javassist/expr/ExprEditor.java
Patch:
@@ -246,8 +246,7 @@ else if (c == Opcode.CHECKCAST) {
                 context.updateMax(expr.locals(), expr.stack());
                 return true;
             }
-            else
-                return false;
+            return false;
         }
         catch (BadBytecode e) {
             throw new CannotCompileException(e);

File: src/main/javassist/tools/Callback.java
Patch:
@@ -20,6 +20,7 @@
 import javassist.CtBehavior;
 
 import java.util.HashMap;
+import java.util.Map;
 import java.util.UUID;
 
 /**
@@ -49,7 +50,7 @@
  */
 public abstract class Callback {
 
-    public static HashMap callbacks = new HashMap();
+    public static Map<String,Callback> callbacks = new HashMap<String,Callback>();
 
     private final String sourceCode;
 
@@ -73,6 +74,7 @@ public Callback(String src){
      */
     public abstract void result(Object[] objects);
 
+    @Override
     public String toString(){
         return sourceCode();
     }

File: src/main/javassist/tools/web/BadHttpRequest.java
Patch:
@@ -28,10 +28,10 @@ public class BadHttpRequest extends Exception {
 
     public BadHttpRequest(Exception _e) { e = _e; }
 
+    @Override
     public String toString() {
         if (e == null)
             return super.toString();
-        else
-            return e.toString();
+        return e.toString();
     }
 }

File: src/main/javassist/util/HotSwapAgent.java
Patch:
@@ -106,18 +106,18 @@ public static void agentmain(String agentArgs, Instrumentation inst) throws Thro
     /**
      * Redefines a class.
      */
-    public static void redefine(Class oldClass, CtClass newClass)
+    public static void redefine(Class<?> oldClass, CtClass newClass)
         throws NotFoundException, IOException, CannotCompileException
     {
-        Class[] old = { oldClass };
+        Class<?>[] old = { oldClass };
         CtClass[] newClasses = { newClass };
         redefine(old, newClasses);
     }
 
     /**
      * Redefines classes.
      */
-    public static void redefine(Class[] oldClasses, CtClass[] newClasses)
+    public static void redefine(Class<?>[] oldClasses, CtClass[] newClasses)
         throws NotFoundException, IOException, CannotCompileException
     {
         startAgent();

File: src/main/javassist/util/proxy/ProxyObject.java
Patch:
@@ -31,6 +31,7 @@ public interface ProxyObject extends Proxy {
      * Sets a handler.  It can be used for changing handlers
      * during runtime.
      */
+    @Override
     void setHandler(MethodHandler mi);
 
     /**

File: src/test/testproxy/ProxyTester.java
Patch:
@@ -3,13 +3,15 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Modifier;
+
+import org.junit.Assert;
+
 import java.lang.reflect.InvocationTargetException;
 import javassist.util.proxy.ProxyFactory;
 import javassist.util.proxy.MethodFilter;
 import javassist.util.proxy.MethodHandler;
 import javassist.util.proxy.ProxyObject;
 import javassist.util.proxy.Proxy;
-import junit.framework.Assert;
 import junit.framework.TestCase;
 import java.io.*;
 

File: src/test/javassist/tools/reflect/Person.java
Patch:
@@ -3,7 +3,7 @@
 import java.lang.reflect.Method;
 import java.util.Arrays;
 
-import junit.framework.Assert;
+import org.junit.Assert;
 
 /**
  * Work with ClassMetaobjectTest.java

File: src/test/javassist/tools/reflect/SubClass.java
Patch:
@@ -1,6 +1,6 @@
 package javassist.tools.reflect;
 
-import junit.framework.*;
+import org.junit.Assert;
 
 public class SubClass extends SuperClass {
     public String f() { return "f2"; }	// override

File: src/main/javassist/Loader.java
Patch:
@@ -362,7 +362,7 @@ protected Class findClass(String name) throws ClassNotFoundException {
         int i = name.lastIndexOf('.');
         if (i != -1) {
             String pname = name.substring(0, i);
-            if (getPackage(pname) == null)
+            if (getDefinedPackage(pname) == null)
                 try {
                     definePackage(
                         pname, null, null, null, null, null, null, null);

File: src/main/javassist/CannotCompileException.java
Patch:
@@ -22,6 +22,8 @@
  * Thrown when bytecode transformation has failed.
  */
 public class CannotCompileException extends Exception {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private Throwable myCause;
 
     /**

File: src/main/javassist/ClassMap.java
Patch:
@@ -48,6 +48,8 @@
  * @see CtNewMethod#copy(CtMethod,String,CtClass,ClassMap)
  */
 public class ClassMap extends java.util.HashMap {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private ClassMap parent;
 
     /**

File: src/main/javassist/CtClass.java
Patch:
@@ -521,6 +521,9 @@ public synchronized Collection getRefClasses() {
         ClassFile cf = getClassFile2();
         if (cf != null) {
             ClassMap cm = new ClassMap() {
+                /** default serialVersionUID */
+                private static final long serialVersionUID = 1L;
+
                 public void put(String oldname, String newname) {
                     put0(oldname, newname);
                 }

File: src/main/javassist/NotFoundException.java
Patch:
@@ -20,6 +20,9 @@
  * Signals that something could not be found.
  */
 public class NotFoundException extends Exception {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public NotFoundException(String msg) {
         super(msg);
     }

File: src/main/javassist/bytecode/BadBytecode.java
Patch:
@@ -20,6 +20,9 @@
  * Signals that a bad bytecode sequence has been found.
  */
 public class BadBytecode extends Exception {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public BadBytecode(int opcode) {
         super("bytecode " + opcode);
     }

File: src/main/javassist/bytecode/CodeAttribute.java
Patch:
@@ -146,6 +146,9 @@ public AttributeInfo copy(ConstPool newCp, Map classnames)
      * in <code>CodeAttribute</code>.
      */
     public static class RuntimeCopyException extends RuntimeException {
+        /** default serialVersionUID */
+        private static final long serialVersionUID = 1L;
+
         /**
          * Constructs an exception.
          */

File: src/main/javassist/bytecode/DuplicateMemberException.java
Patch:
@@ -25,6 +25,9 @@
  * @see ClassFile#addField(FieldInfo)
  */
 public class DuplicateMemberException extends CannotCompileException {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public DuplicateMemberException(String msg) {
         super(msg);
     }

File: src/main/javassist/bytecode/StackMapTable.java
Patch:
@@ -79,6 +79,9 @@ public AttributeInfo copy(ConstPool newCp, Map classnames)
      * in <code>StackMapTable</code>.
      */
     public static class RuntimeCopyException extends RuntimeException {
+        /** default serialVersionUID */
+        private static final long serialVersionUID = 1L;
+
         /**
          * Constructs an exception.
          */

File: src/main/javassist/bytecode/annotation/NoSuchClassError.java
Patch:
@@ -21,6 +21,8 @@
  * It keeps the name of the class that caused this error. 
  */
 public class NoSuchClassError extends Error {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private String className;
 
     /**

File: src/main/javassist/bytecode/stackmap/BasicBlock.java
Patch:
@@ -28,6 +28,9 @@
  */
 public class BasicBlock {
     static class JsrBytecode extends BadBytecode {
+        /** default serialVersionUID */
+        private static final long serialVersionUID = 1L;
+
         JsrBytecode() { super("JSR"); }
     }
 

File: src/main/javassist/compiler/CompileError.java
Patch:
@@ -20,6 +20,8 @@
 import javassist.NotFoundException;
 
 public class CompileError extends Exception {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private Lex lex;
     private String reason;
 

File: src/main/javassist/compiler/KeywordTable.java
Patch:
@@ -17,6 +17,9 @@
 package javassist.compiler;
 
 public final class KeywordTable extends java.util.HashMap {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public KeywordTable() { super(); }
 
     public int lookup(String name) {

File: src/main/javassist/compiler/NoFieldException.java
Patch:
@@ -19,6 +19,8 @@
 import javassist.compiler.ast.ASTree;
 
 public class NoFieldException extends CompileError {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private String fieldName;
     private ASTree expr;
 

File: src/main/javassist/compiler/SymbolTable.java
Patch:
@@ -20,6 +20,8 @@
 import javassist.compiler.ast.Declarator;
 
 public final class SymbolTable extends HashMap {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private SymbolTable parent;
 
     public SymbolTable() { this(null); }

File: src/main/javassist/compiler/SyntaxError.java
Patch:
@@ -17,6 +17,9 @@
 package javassist.compiler;
 
 public class SyntaxError extends CompileError {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public SyntaxError(Lex lexer) {
         super("syntax error near \"" + lexer.getTextAround() + "\"", lexer);
     }

File: src/main/javassist/compiler/ast/ASTList.java
Patch:
@@ -23,6 +23,8 @@
  * The right subtree must be an ASTList object or null.
  */
 public class ASTList extends ASTree {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private ASTree left;
     private ASTList right;
 

File: src/main/javassist/compiler/ast/ASTree.java
Patch:
@@ -25,6 +25,9 @@
  * and <code>getRight()</code> returns null.
  */
 public abstract class ASTree implements Serializable {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public ASTree getLeft() { return null; }
 
     public ASTree getRight() { return null; }

File: src/main/javassist/compiler/ast/ArrayInit.java
Patch:
@@ -22,6 +22,9 @@
  * Array initializer such as <code>{ 1, 2, 3 }</code>.
  */
 public class ArrayInit extends ASTList {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public ArrayInit(ASTree firstElement) {
         super(firstElement);
     }

File: src/main/javassist/compiler/ast/AssignExpr.java
Patch:
@@ -26,6 +26,9 @@ public class AssignExpr extends Expr {
      * =, %=, &=, *=, +=, -=, /=, ^=, |=, <<=, >>=, >>>=
      */
 
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     private AssignExpr(int op, ASTree _head, ASTList _tail) {
         super(op, _head, _tail);
     }

File: src/main/javassist/compiler/ast/BinExpr.java
Patch:
@@ -30,6 +30,9 @@ public class BinExpr extends Expr {
      * <<, >>, >>>, +, -, *, /, %
      */
 
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     private BinExpr(int op, ASTree _head, ASTList _tail) {
         super(op, _head, _tail);
     }

File: src/main/javassist/compiler/ast/CallExpr.java
Patch:
@@ -24,6 +24,8 @@
  * Method call expression.
  */
 public class CallExpr extends Expr {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private MemberResolver.Method method;  // cached result of lookupMethod()
 
     private CallExpr(ASTree _head, ASTList _tail) {

File: src/main/javassist/compiler/ast/CastExpr.java
Patch:
@@ -23,6 +23,8 @@
  * Cast expression.
  */
 public class CastExpr extends ASTList implements TokenId {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     protected int castType;
     protected int arrayDim;
 

File: src/main/javassist/compiler/ast/CondExpr.java
Patch:
@@ -22,6 +22,9 @@
  * Conditional expression.
  */
 public class CondExpr extends ASTList {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public CondExpr(ASTree cond, ASTree thenp, ASTree elsep) {
         super(cond, new ASTList(thenp, new ASTList(elsep)));
     }

File: src/main/javassist/compiler/ast/Declarator.java
Patch:
@@ -23,6 +23,8 @@
  * Variable declarator.
  */
 public class Declarator extends ASTList implements TokenId {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     protected int varType;
     protected int arrayDim;
     protected int localVar;

File: src/main/javassist/compiler/ast/DoubleConst.java
Patch:
@@ -23,6 +23,8 @@
  * Double constant.
  */
 public class DoubleConst extends ASTree {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     protected double value;
     protected int type;
 

File: src/main/javassist/compiler/ast/Expr.java
Patch:
@@ -29,6 +29,8 @@ public class Expr extends ASTList implements TokenId {
      * Otherwise, the object should be an instance of a subclass.
      */
 
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     protected int operatorId;
 
     Expr(int op, ASTree _head, ASTList _tail) {

File: src/main/javassist/compiler/ast/FieldDecl.java
Patch:
@@ -19,6 +19,9 @@
 import javassist.compiler.CompileError;
 
 public class FieldDecl extends ASTList {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public FieldDecl(ASTree _head, ASTList _tail) {
         super(_head, _tail);
     }

File: src/main/javassist/compiler/ast/InstanceOfExpr.java
Patch:
@@ -22,6 +22,9 @@
  * Instanceof expression.
  */
 public class InstanceOfExpr extends CastExpr {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public InstanceOfExpr(ASTList className, int dim, ASTree expr) {
         super(className, dim, expr);
     }

File: src/main/javassist/compiler/ast/IntConst.java
Patch:
@@ -23,6 +23,8 @@
  * Integer constant.
  */
 public class IntConst extends ASTree {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     protected long value;
     protected int type;
 

File: src/main/javassist/compiler/ast/Keyword.java
Patch:
@@ -22,6 +22,8 @@
  * Keyword.
  */
 public class Keyword extends ASTree {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     protected int tokenId;
 
     public Keyword(int token) {

File: src/main/javassist/compiler/ast/Member.java
Patch:
@@ -23,6 +23,8 @@
  * Member name.
  */
 public class Member extends Symbol {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     // cache maintained by fieldAccess() in TypeChecker.
     // this is used to obtain the value of a static final field.
     private CtField field;

File: src/main/javassist/compiler/ast/MethodDecl.java
Patch:
@@ -19,6 +19,8 @@
 import javassist.compiler.CompileError;
 
 public class MethodDecl extends ASTList {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     public static final String initName = "<init>";
 
     public MethodDecl(ASTree _head, ASTList _tail) {

File: src/main/javassist/compiler/ast/NewExpr.java
Patch:
@@ -23,6 +23,8 @@
  * New Expression.
  */
 public class NewExpr extends ASTList implements TokenId {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     protected boolean newArray;
     protected int arrayType;
 

File: src/main/javassist/compiler/ast/Pair.java
Patch:
@@ -23,6 +23,8 @@
  * overriding abstract methods in ASTree.
  */
 public class Pair extends ASTree {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     protected ASTree left, right;
 
     public Pair(ASTree _left, ASTree _right) {

File: src/main/javassist/compiler/ast/Stmnt.java
Patch:
@@ -23,6 +23,8 @@
  * Statement.
  */
 public class Stmnt extends ASTList implements TokenId {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     protected int operatorId;
 
     public Stmnt(int op, ASTree _head, ASTList _tail) {

File: src/main/javassist/compiler/ast/StringL.java
Patch:
@@ -22,6 +22,8 @@
  * String literal.
  */
 public class StringL extends ASTree {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     protected String text;
 
     public StringL(String t) {

File: src/main/javassist/compiler/ast/Symbol.java
Patch:
@@ -22,6 +22,8 @@
  * Identifier.
  */
 public class Symbol extends ASTree {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     protected String identifier;
 
     public Symbol(String sym) {

File: src/main/javassist/compiler/ast/Variable.java
Patch:
@@ -22,6 +22,8 @@
  * Variable.
  */
 public class Variable extends Symbol {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     protected Declarator declarator;
 
     public Variable(String sym, Declarator d) {

File: src/main/javassist/tools/reflect/CannotCreateException.java
Patch:
@@ -20,6 +20,9 @@
  * Signals that <code>ClassMetaobject.newInstance()</code> fails.
  */
 public class CannotCreateException extends Exception {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public CannotCreateException(String s) {
         super(s);
     }

File: src/main/javassist/tools/reflect/CannotInvokeException.java
Patch:
@@ -29,6 +29,8 @@
  */
 public class CannotInvokeException extends RuntimeException {
 
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private Throwable err = null;
 
     /**

File: src/main/javassist/tools/reflect/CannotReflectException.java
Patch:
@@ -29,6 +29,9 @@
  * @see javassist.CannotCompileException
  */
 public class CannotReflectException extends CannotCompileException {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public CannotReflectException(String msg) {
         super(msg);
     }

File: src/main/javassist/tools/reflect/ClassMetaobject.java
Patch:
@@ -40,6 +40,8 @@
  * @see javassist.tools.reflect.Metalevel
  */
 public class ClassMetaobject implements Serializable {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     /**
      * The base-level methods controlled by a metaobject
      * are renamed so that they begin with

File: src/main/javassist/tools/reflect/Metaobject.java
Patch:
@@ -45,6 +45,8 @@
  * @see javassist.tools.reflect.Metalevel
  */
 public class Metaobject implements Serializable {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     protected ClassMetaobject classmetaobject;
     protected Metalevel baseobject;
     protected Method[] methods;

File: src/main/javassist/tools/rmi/ObjectImporter.java
Patch:
@@ -73,6 +73,8 @@
  * @see javassist.tools.web.Viewer
  */
 public class ObjectImporter implements java.io.Serializable {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private final byte[] endofline = { 0x0d, 0x0a };
     private String servername, orgServername;
     private int port, orgPort;

File: src/main/javassist/tools/rmi/ObjectNotFoundException.java
Patch:
@@ -17,6 +17,9 @@
 package javassist.tools.rmi;
 
 public class ObjectNotFoundException extends Exception {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public ObjectNotFoundException(String name) {
         super(name + " is not exported");
     }

File: src/main/javassist/tools/rmi/RemoteException.java
Patch:
@@ -21,6 +21,9 @@
  * during remote method invocation.
  */
 public class RemoteException extends RuntimeException {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public RemoteException(String msg) {
         super(msg);
     }

File: src/main/javassist/tools/rmi/RemoteRef.java
Patch:
@@ -21,6 +21,8 @@
  * reference through a network stream.
  */
 public class RemoteRef implements java.io.Serializable {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     public int oid;
     public String classname;
 

File: src/main/javassist/tools/web/BadHttpRequest.java
Patch:
@@ -20,6 +20,8 @@
  * Thrown when receiving an invalid HTTP request.
  */
 public class BadHttpRequest extends Exception {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private Exception e;
 
     public BadHttpRequest() { e = null; }

File: src/main/javassist/util/proxy/RuntimeSupport.java
Patch:
@@ -31,6 +31,9 @@ public class RuntimeSupport {
     public static MethodHandler default_interceptor = new DefaultMethodHandler();
 
     static class DefaultMethodHandler implements MethodHandler, Serializable {
+        /** default serialVersionUID */
+        private static final long serialVersionUID = 1L;
+
         public Object invoke(Object self, Method m,
                              Method proceed, Object[] args)
             throws Exception

File: src/main/javassist/util/proxy/SerializedProxy.java
Patch:
@@ -31,6 +31,8 @@
  * @see RuntimeSupport#makeSerializedProxy(Object)
  */
 class SerializedProxy implements Serializable {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private String superClass;
     private String[] interfaces;
     private byte[] filterSignature;

File: src/test/javassist/proxyfactory/MyCls.java
Patch:
@@ -7,6 +7,8 @@
  */
 public class MyCls implements Serializable {
 
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     private int i,j;
 
     public int getI() {

File: src/test/javassist/proxyfactory/ProxyFactoryTest.java
Patch:
@@ -59,6 +59,8 @@ public void testSerialize() throws Exception {
     
     public static class MyMethodHandler implements MethodHandler, Serializable {
 
+        /** default serialVersionUID */
+        private static final long serialVersionUID = 1L;
         private int x;
 
         public int getX() {

File: src/test/test1/MySerializableClass.java
Patch:
@@ -7,6 +7,8 @@
  * @author Bob Lee
  */
 public class MySerializableClass implements Serializable, Cloneable {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     String fieldA;
     String fieldB;
 

File: src/test/test2/NewExprInTry.java
Patch:
@@ -3,6 +3,9 @@
 import java.util.HashMap;
 
 class HashMapWrapper extends HashMap {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     HashMapWrapper(int size, int args) {
         super(size);
     }

File: src/test/test2/Prune.java
Patch:
@@ -1,6 +1,8 @@
 package test2;
 
 public class Prune extends java.awt.Point implements Cloneable, Runnable {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
     public int value;
 
     public Prune(int i) {

File: src/test/test4/GetAllRefInnerTest.java
Patch:
@@ -20,6 +20,9 @@ public T bar(T b) {
     }
     public Object foo() {
         return new java.util.HashSet<String>() {
+            /** default serialVersionUID */
+            private static final long serialVersionUID = 1L;
+
             public String toString() { return this.getClass().toString(); } 
         };
     }

File: src/test/test4/JIRA181.java
Patch:
@@ -3,6 +3,9 @@
 import java.util.ArrayList;
 
 public class JIRA181<T extends Number> extends ArrayList<T> {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     public @interface Condition {
     	Class<? extends ICondition> condition();
     }

File: src/test/testproxy/ProxyFactoryPerformanceTest.java
Patch:
@@ -163,6 +163,9 @@ public Object invoke(Object arg0, Method arg1, Object[] arg2) throws Throwable {
 */
 
 class SampleBean implements Serializable {
+    /** default serialVersionUID */
+    private static final long serialVersionUID = 1L;
+
     long oid;
     
     int version;

File: src/main/javassist/bytecode/ClassFile.java
Patch:
@@ -146,7 +146,7 @@ public final class ClassFile {
             ver = JAVA_5;
             Class.forName("java.util.zip.DeflaterInputStream");
             ver = JAVA_6;
-            Class.forName("java.lang.invoke.CallSite");
+            Class.forName("java.lang.invoke.CallSite", false, ClassLoader.getSystemClassLoader());
             ver = JAVA_7;
             Class.forName("java.util.function.Function");
             ver = JAVA_8;

File: src/main/javassist/bytecode/ClassFile.java
Patch:
@@ -146,7 +146,7 @@ public final class ClassFile {
             ver = JAVA_5;
             Class.forName("java.util.zip.DeflaterInputStream");
             ver = JAVA_6;
-            Class.forName("java.lang.invoke.CallSite");
+            Class.forName("java.lang.invoke.CallSite", false, ClassLoader.getSystemClassLoader());
             ver = JAVA_7;
             Class.forName("java.util.function.Function");
             ver = JAVA_8;

File: src/main/javassist/ClassPool.java
Patch:
@@ -225,7 +225,6 @@ public ClassPool(ClassPool parent) {
      *
      * @see ClassClassPath
      * @see LoaderClassPath
-     * @see ModuleClassPath
      */
     public static synchronized ClassPool getDefault() {
         if (defaultPool == null) {

File: src/main/javassist/CtField.java
Patch:
@@ -379,8 +379,8 @@ public CtClass getType() throws NotFoundException {
      * this field.  They have to be explicitly updated.  For example,
      * if some method contains an expression {@code t.value} and the type
      * of the variable {@code t} is changed by {@link #setType(CtClass)}
-     * from {@code int} to {@code double}, then {@ t.value} has to be modified
-     * since the bytecode of {@code t.value} contains the type information.
+     * from {@code int} to {@code double}, then {@code t.value} has to be modified
+     * as well since the bytecode of {@code t.value} contains the type information.
      * </p>
      *
      * @see CodeConverter

File: src/main/javassist/bytecode/ClassFile.java
Patch:
@@ -763,8 +763,8 @@ public List getAttributes() {
      * returns null if the specified attributed is not found.
      *
      * <p>An attribute name can be obtained by, for example,
-     * {@link AnnotationsAttribute#visibleTab} or
-     * {@link AnnotationsAttribute#invisibleTab}. 
+     * {@link AnnotationsAttribute#visibleTag} or
+     * {@link AnnotationsAttribute#invisibleTag}. 
      * </p>
      * 
      * @param name          attribute name

File: src/main/javassist/bytecode/FieldInfo.java
Patch:
@@ -232,8 +232,8 @@ public List getAttributes() {
      * It returns null if the specified attribute is not found.
      *
      * <p>An attribute name can be obtained by, for example,
-     * {@link AnnotationsAttribute#visibleTab} or
-     * {@link AnnotationsAttribute#invisibleTab}. 
+     * {@link AnnotationsAttribute#visibleTag} or
+     * {@link AnnotationsAttribute#invisibleTag}. 
      * </p>
      * 
      * @param name      attribute name

File: src/main/javassist/bytecode/MethodInfo.java
Patch:
@@ -316,8 +316,8 @@ public List getAttributes() {
      * method returns null.
      * 
      * <p>An attribute name can be obtained by, for example,
-     * {@link AnnotationsAttribute#visibleTab} or
-     * {@link AnnotationsAttribute#invisibleTab}.
+     * {@link AnnotationsAttribute#visibleTag} or
+     * {@link AnnotationsAttribute#invisibleTag}.
      * </p>
      * 
      * @param name attribute name

File: src/test/javassist/JvstTest3.java
Patch:
@@ -1086,7 +1086,8 @@ public void testAddInterfaceMethod() throws Exception {
         CtMethod m3 = CtMethod.make("public void foo3() {}", cc);
         try {
             cc.addMethod(m3);
-            fail();
+            if (ClassFile.MAJOR_VERSION < ClassFile.JAVA_8)
+                fail();
         }
         catch (CannotCompileException e) {
             // System.out.println(e);

File: src/main/javassist/ClassClassPath.java
Patch:
@@ -82,7 +82,7 @@ public ClassClassPath(Class c) {
      */
     public InputStream openClassfile(String classname) throws NotFoundException {
         String filename = '/' + classname.replace('.', '/') + ".class";
-        return thisClass.getResourceAsStream('/' + filename);
+        return thisClass.getResourceAsStream(filename);
     }
 
     /**

File: src/main/javassist/CtClass.java
Patch:
@@ -69,7 +69,7 @@ public abstract class CtClass {
     /**
      * The version number of this release.
      */
-    public static final String version = "3.20.0-GA";
+    public static final String version = "3.21.0-GA";
 
     /**
      * Prints the version number and the copyright notice.
@@ -80,7 +80,7 @@ public abstract class CtClass {
      */
     public static void main(String[] args) {
         System.out.println("Javassist version " + CtClass.version);
-        System.out.println("Copyright (C) 1999-2015 Shigeru Chiba."
+        System.out.println("Copyright (C) 1999-2016 Shigeru Chiba."
                            + " All Rights Reserved.");
     }
 

File: src/main/javassist/bytecode/annotation/AnnotationImpl.java
Patch:
@@ -131,12 +131,12 @@ public Object invoke(Object proxy, Method method, Object[] args)
         if (Object.class == method.getDeclaringClass()) {
             if ("equals".equals(name)) {
                 Object obj = args[0];
-                return new Boolean(checkEquals(obj));
+                return Boolean.valueOf(checkEquals(obj));
             }
             else if ("toString".equals(name))
                 return annotation.toString();
             else if ("hashCode".equals(name))
-                return new Integer(hashCode());
+                return Integer.valueOf(hashCode());
         }
         else if ("annotationType".equals(name)
                  && method.getParameterTypes().length == 0)

File: src/main/javassist/bytecode/annotation/BooleanMemberValue.java
Patch:
@@ -59,7 +59,7 @@ public BooleanMemberValue(ConstPool cp) {
     }
 
     Object getValue(ClassLoader cl, ClassPool cp, Method m) {
-        return new Boolean(getValue());
+        return Boolean.valueOf(getValue());
     }
 
     Class getType(ClassLoader cl) {

File: src/main/javassist/bytecode/annotation/ByteMemberValue.java
Patch:
@@ -59,7 +59,7 @@ public ByteMemberValue(ConstPool cp) {
     }
 
     Object getValue(ClassLoader cl, ClassPool cp, Method m) {
-        return new Byte(getValue());
+        return Byte.valueOf(getValue());
     }
 
     Class getType(ClassLoader cl) {

File: src/main/javassist/bytecode/annotation/CharMemberValue.java
Patch:
@@ -60,7 +60,7 @@ public CharMemberValue(ConstPool cp) {
     }
 
     Object getValue(ClassLoader cl, ClassPool cp, Method m) {
-        return new Character(getValue());
+        return Character.valueOf(getValue());
     }
 
     Class getType(ClassLoader cl) {

File: src/main/javassist/bytecode/annotation/DoubleMemberValue.java
Patch:
@@ -61,7 +61,7 @@ public DoubleMemberValue(ConstPool cp) {
     }
 
     Object getValue(ClassLoader cl, ClassPool cp, Method m) {
-        return new Double(getValue());
+        return Double.valueOf(getValue());
     }
 
     Class getType(ClassLoader cl) {

File: src/main/javassist/bytecode/annotation/FloatMemberValue.java
Patch:
@@ -61,7 +61,7 @@ public FloatMemberValue(ConstPool cp) {
     }
 
     Object getValue(ClassLoader cl, ClassPool cp, Method m) {
-        return new Float(getValue());
+        return Float.valueOf(getValue());
     }
 
     Class getType(ClassLoader cl) {

File: src/main/javassist/bytecode/annotation/IntegerMemberValue.java
Patch:
@@ -66,7 +66,7 @@ public IntegerMemberValue(ConstPool cp) {
     }
 
     Object getValue(ClassLoader cl, ClassPool cp, Method m) {
-        return new Integer(getValue());
+        return Integer.valueOf(getValue());
     }
 
     Class getType(ClassLoader cl) {

File: src/main/javassist/bytecode/annotation/LongMemberValue.java
Patch:
@@ -60,7 +60,7 @@ public LongMemberValue(ConstPool cp) {
     }
 
     Object getValue(ClassLoader cl, ClassPool cp, Method m) {
-        return new Long(getValue());
+        return Long.valueOf(getValue());
     }
 
     Class getType(ClassLoader cl) {

File: src/main/javassist/bytecode/annotation/ShortMemberValue.java
Patch:
@@ -60,7 +60,7 @@ public ShortMemberValue(ConstPool cp) {
     }
 
     Object getValue(ClassLoader cl, ClassPool cp, Method m) {
-        return new Short(getValue());
+        return Short.valueOf(getValue());
     }
 
     Class getType(ClassLoader cl) {

File: src/main/javassist/bytecode/stackmap/BasicBlock.java
Patch:
@@ -196,7 +196,7 @@ private Mark makeMark(HashMap table, int pos, BasicBlock[] jump,
 
         private Mark makeMark0(HashMap table, int pos,
                                boolean isBlockBegin, boolean isTarget) {
-            Integer p = new Integer(pos);
+            Integer p = Integer.valueOf(pos);
             Mark m = (Mark)table.get(p);
             if (m == null) {
                 m = new Mark(pos);

File: src/main/javassist/compiler/CodeGen.java
Patch:
@@ -595,7 +595,7 @@ private void atBreakStmnt(Stmnt st, boolean notCont)
                         "sorry, not support labeled break or continue");
 
         bytecode.addOpcode(Opcode.GOTO);
-        Integer pc = new Integer(bytecode.currentPc());
+        Integer pc = Integer.valueOf(bytecode.currentPc());
         bytecode.addIndex(0);
         if (notCont)
             breakList.add(pc);

File: src/main/javassist/compiler/KeywordTable.java
Patch:
@@ -28,6 +28,6 @@ public int lookup(String name) {
     }
 
     public void append(String name, int t) {
-        put(name, new Integer(t));
+        put(name, Integer.valueOf(t));
     }
 }

File: src/main/javassist/compiler/MemberCodeGen.java
Patch:
@@ -209,7 +209,7 @@ protected void atTryStmnt(Stmnt st) throws CompileError {
         boolean tryNotReturn = !hasReturned;
         if (tryNotReturn) {
             bc.addOpcode(Opcode.GOTO);
-            gotoList.add(new Integer(bc.currentPc()));
+            gotoList.add(Integer.valueOf(bc.currentPc()));
             bc.addIndex(0);   // correct later
         }
 
@@ -235,7 +235,7 @@ protected void atTryStmnt(Stmnt st) throws CompileError {
 
             if (!hasReturned) {
                 bc.addOpcode(Opcode.GOTO);
-                gotoList.add(new Integer(bc.currentPc()));
+                gotoList.add(Integer.valueOf(bc.currentPc()));
                 bc.addIndex(0);   // correct later
                 tryNotReturn = true;
             }

File: src/main/javassist/tools/rmi/ObjectImporter.java
Patch:
@@ -189,7 +189,7 @@ public Object lookupObject(String name) throws ObjectNotFoundException
     private Object createProxy(int oid, String classname) throws Exception {
         Class c = Class.forName(classname);
         Constructor cons = c.getConstructor(proxyConstructorParamTypes);
-        return cons.newInstance(new Object[] { this, new Integer(oid) });
+        return cons.newInstance(new Object[] { this, Integer.valueOf(oid) });
     }
 
     /**

File: src/test/Test.java
Patch:
@@ -48,7 +48,7 @@ public static void main(String[] args) throws Exception {
         ctClass.debugWriteFile();
         Class<?> cc = ctClass.toClass();
         System.out.println(cc.getName());
-        InvalidStackMapFrame obj = (InvalidStackMapFrame)cc.newInstance();
+        InvalidStackMapFrame obj = (InvalidStackMapFrame)cc.getDeclaredConstructor().newInstance();
         obj.bytecodeVerifyError();
     }
 }

File: src/test/javassist/JvstTest.java
Patch:
@@ -1041,7 +1041,7 @@ public void testToString() throws Exception {
     }
 
     public void testPackage() throws Exception {
-        Object obj = new Loader().loadClass("test1.Pac").newInstance();
+        Object obj = new Loader().loadClass("test1.Pac").getConstructor().newInstance();
         assertEquals(1, invoke(obj, "run"));
     }
 

File: src/test/javassist/JvstTest4.java
Patch:
@@ -606,7 +606,7 @@ public void testPackage() throws Throwable {    // JASSIST-147
         pool.makePackage(pool.getClassLoader(), packageName);
         CtClass ctcl = pool.makeClass("test4.pack.Clazz");
         Class cl = ctcl.toClass();
-        Object obj = cl.newInstance();
+        Object obj = cl.getConstructor().newInstance();
         assertEquals(packageName, obj.getClass().getPackage().getName());
     }
 
@@ -1029,7 +1029,7 @@ public void testDeadcode() throws Exception {
 
         newClass.debugWriteFile();
         Class<?> cClass = newClass.toClass();
-        Object o = cClass.newInstance();
+        Object o = cClass.getConstructor().newInstance();
         java.lang.reflect.Method m = cClass.getMethod("evaluate");
         m.invoke(o);
         m = cClass.getMethod("evaluate2");

File: src/test/javassist/JvstTest5.java
Patch:
@@ -76,7 +76,7 @@ public void testJIRA246b() throws Exception {
     }
 
     public void testJIRA242() throws Exception {
-        Boolean ss = new Boolean(2 > 3);
+        Boolean ss = Boolean.valueOf(2 > 3);
         ClassPool cp = ClassPool.getDefault();
         CtClass cc = cp.get("test5.JIRA242$Hello");
         CtMethod m = cc.getDeclaredMethod("say");
@@ -218,7 +218,7 @@ public void testBadClass() throws Exception {
         System.out.println(src);
         badClass.addMethod(CtMethod.make(src, badClass));
         Class clazzz = badClass.toClass();
-        Object obj = clazzz.newInstance(); // <-- falls here
+        Object obj = clazzz.getConstructor().newInstance(); // <-- falls here
     }
 
     public void test83StackmapWithArrayType() throws Exception {

File: src/test/javassist/JvstTestRoot.java
Patch:
@@ -34,7 +34,7 @@ protected void setUp() throws Exception {
     }
 
     protected Object make(String name) throws Exception {
-        return cloader.loadClass(name).newInstance();
+        return cloader.loadClass(name).getConstructor().newInstance();
     }
 
     protected int invoke(Object target, String method) throws Exception {
@@ -47,7 +47,7 @@ protected int invoke(Object target, String method, int arg)
         throws Exception {
         Method m =
             target.getClass().getMethod(method, new Class[] { int.class });
-        Object res = m.invoke(target, new Object[] { new Integer(arg)});
+        Object res = m.invoke(target, new Object[] { Integer.valueOf(arg)});
         return ((Integer) res).intValue();
     }
 }

File: src/test/javassist/bytecode/BytecodeTest.java
Patch:
@@ -29,7 +29,7 @@ protected void setUp() throws Exception {
     }
 
     protected Object make(String name) throws Exception {
-        return cloader.loadClass(name).newInstance();
+        return cloader.loadClass(name).getConstructor().newInstance();
     }
 
     protected int invoke(Object target, String method) throws Exception {

File: src/test/javassist/bytecode/InsertGap0.java
Patch:
@@ -175,7 +175,7 @@ public void testExample() throws Throwable {
         Class c = cc.toClass();
         cc.stopPruning(p);
 
-        Object obj = c.newInstance();
+        Object obj = c.getConstructor().newInstance();
         assertEquals(2, invoke(obj, "run", 0));
     }
 
@@ -194,7 +194,7 @@ public void testExample2() throws Throwable {
         Class c = cc.toClass();
         cc.stopPruning(p);
 
-        Object obj = c.newInstance();
+        Object obj = c.getConstructor().newInstance();
         assertEquals(0, invoke(obj, "run2", 0));
     }
 

File: src/test/javassist/proxyfactory/Tester.java
Patch:
@@ -27,7 +27,7 @@ public void test() throws Exception {
         ProxyFactory f = new ProxyFactory();
         f.setSuperclass(Hand.class);
         Class c = f.createClass();
-        Hand foo = (Hand)c.newInstance();
+        Hand foo = (Hand)c.getConstructor().newInstance();
         ((Proxy)foo).setHandler(mi);
         assertTrue(ProxyFactory.isProxyClass(c));
         assertEquals(3, foo.getHandler());

File: src/test/test/javassist/bytecode/analysis/ScannerTest.java
Patch:
@@ -72,7 +72,7 @@ private static void verifySubroutine(Subroutine[] subs, int pos, int start,
         assertNotNull(sub);
         assertEquals(sub.start(), start);
         for (int i = 0; i < callers.length; i++)
-            assertTrue(sub.callers().contains(new Integer(callers[i])));
+            assertTrue(sub.callers().contains(Integer.valueOf(callers[i])));
     }
 
     private static void generate(ClassPool pool) throws CannotCompileException, IOException, NotFoundException {

File: src/test/test/javassist/proxy/JBPAPP9257Test.java
Patch:
@@ -27,7 +27,7 @@ public Object invoke(Object self, Method m, Method proceed,
                 // method.
             }
         };
-        Foo foo = (Foo)c.newInstance();
+        Foo foo = (Foo)c.getConstructor().newInstance();
         try {
             ((ProxyObject)foo).setHandler(mi);
             fail("foo is a ProxyObject!");
@@ -55,7 +55,7 @@ public Object invoke(Object self, Method m, Method proceed,
                 // method.
             }
         };
-        Foo2 foo = (Foo2)c.newInstance();
+        Foo2 foo = (Foo2)c.getConstructor().newInstance();
         try {
             ((ProxyObject)foo).setHandler(mi);
             fail("foo is a ProxyObject!");

File: src/test/test/javassist/proxy/ProxyCacheGCTest.java
Patch:
@@ -93,16 +93,16 @@ public void createProxy(int counter)
             Class javaHandlerClass = classPool.toClass(ctHandlerClass);
             Class javaFilterClass = classPool.toClass(ctFilterClass);
 
-            MethodHandler handler= (MethodHandler)javaHandlerClass.newInstance();
-            MethodFilter filter = (MethodFilter)javaFilterClass.newInstance();
+            MethodHandler handler= (MethodHandler)javaHandlerClass.getConstructor().newInstance();
+            MethodFilter filter = (MethodFilter)javaFilterClass.getConstructor().newInstance();
 
             // ok, now create a factory and a proxy class and proxy from that factory
             factory.setFilter(filter);
             factory.setSuperclass(javaTargetClass);
             // factory.setSuperclass(Object.class);
 
             Class proxyClass = factory.createClass();
-            Object target = proxyClass.newInstance();
+            Object target = proxyClass.getConstructor().newInstance();
             ((ProxyObject)target).setHandler(handler);
         } catch (Exception e) {
             e.printStackTrace();

File: src/test/test2/ConstField.java
Patch:
@@ -8,6 +8,6 @@ public class ConstField {
     public static final double d = 9.0;
     public static final String s = "const";
     public static final Object obj = null;
-    public static final Integer integer = new Integer(4);
+    public static final Integer integer = Integer.valueOf(4);
     public static int k = 2;
 }

File: src/test/test3/Enhancer.java
Patch:
@@ -35,7 +35,7 @@ public Object invoke(Object self, Method m, Object[] args)
                 }
             });
         Class c = e.createClass();
-        EnhanceTest obj = (EnhanceTest)c.newInstance();
+        EnhanceTest obj = (EnhanceTest)c.getConstructor().newInstance();
         obj.foo("test");
     }
 

File: src/test/test4/Signature.java
Patch:
@@ -7,7 +7,7 @@ public static class Foo {
 
     public int run() {
         Signature<String> s = new Signature<String>();
-        return s.foo(new Integer(3), "foo", s, null).length();
+        return s.foo(Integer.valueOf(3), "foo", s, null).length();
     }
 
     <S> T foo(S s, T t, Signature<T> signature, Signature<Signature<String>> v) {

File: src/test/testproxy/ProxyFactoryPerformanceTest.java
Patch:
@@ -45,7 +45,7 @@ public void callCreateClass(String translator, Class cl) throws Throwable {
         error = null;
 		Thread[] threads = new Thread[MAX_THREADS];
 		for (int i = 0; i < threads.length; ++i) {
-			threads[i] = (Thread)cl.newInstance();
+			threads[i] = (Thread)cl.getDeclaredConstructor().newInstance();
 		}
 		long time = System.currentTimeMillis();
 		for (int i = 0; i < threads.length; ++i) {

File: src/test/javassist/JvstTest.java
Patch:
@@ -842,7 +842,7 @@ public void testMakeInterface() throws Exception {
         // cloader.loadClass(cc.getName());
         java.io.File genDir = new java.io.File(".");
         java.net.URLClassLoader ucl = new java.net.URLClassLoader(
-                        new java.net.URL[] { genDir.toURL() }, null);
+                        new java.net.URL[] { genDir.toURI().toURL() }, null);
         Class intf = ucl.loadClass("test1.MkInterface");
     }
 

File: src/test/testproxy/ProxyFactoryPerformanceTest.java
Patch:
@@ -104,7 +104,7 @@ public void callCreateClass() {
 			factory.setSuperclass(SampleBean.class);
 			factory.setInterfaces(SampleBean.class.getInterfaces());
 			factory.setFilter(FINALIZE_FILTER);
-			factory.setHandler(this);
+			// factory.setHandler(this);
 
 			Class proxyClass = factory.createClass();
 			//System.out.println("proxy name: " + proxyClass.getName());

File: src/test/javassist/JvstTest.java
Patch:
@@ -842,7 +842,7 @@ public void testMakeInterface() throws Exception {
         // cloader.loadClass(cc.getName());
         java.io.File genDir = new java.io.File(".");
         java.net.URLClassLoader ucl = new java.net.URLClassLoader(
-                        new java.net.URL[] { genDir.toURL() }, null);
+                        new java.net.URL[] { genDir.toURI().toURL() }, null);
         Class intf = ucl.loadClass("test1.MkInterface");
     }
 

File: src/test/testproxy/ProxyFactoryPerformanceTest.java
Patch:
@@ -104,7 +104,7 @@ public void callCreateClass() {
 			factory.setSuperclass(SampleBean.class);
 			factory.setInterfaces(SampleBean.class.getInterfaces());
 			factory.setFilter(FINALIZE_FILTER);
-			factory.setHandler(this);
+			// factory.setHandler(this);
 
 			Class proxyClass = factory.createClass();
 			//System.out.println("proxy name: " + proxyClass.getName());

File: src/main/javassist/bytecode/stackmap/TypeData.java
Patch:
@@ -319,11 +319,12 @@ private void fixTypes(ArrayList scc, ClassPool cp) throws NotFoundException {
             }
 
             if (isBasicType) {
+                is2WordType = kind.is2WordType();
                 for (int i = 0; i < size; i++) {
                     TypeVar cv = (TypeVar)scc.get(i);
                     cv.lowers.clear();
                     cv.lowers.add(kind);
-                    is2WordType = kind.is2WordType();
+                    cv.is2WordType = kind.is2WordType();
                 }
             }
             else {

File: src/main/javassist/expr/MethodCall.java
Patch:
@@ -215,7 +215,7 @@ else if (c == INVOKESTATIC
                 jc.recordStaticProceed(classname, methodname);
             else if (c == INVOKESPECIAL)
                 jc.recordSpecialProceed(Javac.param0Name, classname,
-                                        methodname, signature);
+                                        methodname, signature, index);
             else
                 jc.recordProceed(Javac.param0Name, methodname);
 

File: src/test/javassist/JvstTest5.java
Patch:
@@ -139,7 +139,7 @@ public void testJIRA248() throws Exception {
     }
 
     public void testInvalidCastWithDollar() throws Exception {
-        String code = "{ new JavassistInvalidCastTest().inspectReturn((Object) ($w) $_); } ";
+        String code = "{ new test5.JavassistInvalidCastTest().inspectReturn((Object) ($w) $_); } ";
         CtClass c = sloader.get("test5.InvalidCastDollar");
         for (CtMethod method : c.getDeclaredMethods())
             method.insertAfter(code);

File: src/main/javassist/util/proxy/ProxyFactory.java
Patch:
@@ -1243,7 +1243,8 @@ private static MethodInfo makeDelegator(Method meth, String desc,
         Bytecode code = new Bytecode(cp, 0, 0);
         code.addAload(0);
         int s = addLoadParameters(code, meth.getParameterTypes(), 1);
-        code.addInvokespecial(declClass.getName(), meth.getName(), desc);
+        code.addInvokespecial(declClass.isInterface(), cp.addClassInfo(declClass.getName()),
+                              meth.getName(), desc);
         addReturn(code, meth.getReturnType());
         code.setMaxLocals(++s);
         delegator.setCodeAttribute(code.toCodeAttribute());

File: src/main/javassist/bytecode/annotation/Annotation.java
Patch:
@@ -78,7 +78,7 @@ public Annotation(int type, ConstPool cp) {
      * Constructs an annotation including no members.  A member can be
      * later added to the created annotation by <code>addMemberValue()</code>. 
      *
-     * @param typeName  the name of the annotation interface type.
+     * @param typeName  the fully-qualified name of the annotation interface type.
      * @param cp        the constant pool table.
      *
      * @see #addMemberValue(String, MemberValue)

File: src/main/javassist/bytecode/annotation/ArrayMemberValue.java
Patch:
@@ -130,7 +130,7 @@ public String toString() {
      * Writes the value.
      */
     public void write(AnnotationsWriter writer) throws IOException {
-        int num = values.length;
+        int num = values == null ? 0 : values.length;
         writer.arrayValue(num);
         for (int i = 0; i < num; ++i)
             values[i].write(writer);

File: src/main/javassist/compiler/CodeGen.java
Patch:
@@ -1420,12 +1420,13 @@ private String checkCastExpr(CastExpr expr, String name)
         int type = expr.getType();
         oprand.accept(this);
         int srcType = exprType;
+        int srcDim = arrayDim;
         if (invalidDim(srcType, arrayDim, className, type, dim, name, true)
             || srcType == VOID || type == VOID)
             throw new CompileError(msg);
 
         if (type == CLASS) {
-            if (!isRefType(srcType))
+            if (!isRefType(srcType) && srcDim == 0)
                 throw new CompileError(msg);
 
             return toJvmArrayName(name, dim);

File: src/main/javassist/compiler/MemberCodeGen.java
Patch:
@@ -642,7 +642,7 @@ else if (AccessFlag.isPrivate(acc))
             bytecode.addInvokestatic(declClass, mname, desc);
         }
         else if (isSpecial)    // if (isSpecial && notStatic(acc))
-            bytecode.addInvokespecial(declClass, mname, desc);
+            bytecode.addInvokespecial(targetClass, mname, desc);
         else {
             if (!Modifier.isPublic(declClass.getModifiers())
                 || declClass.isInterface() != targetClass.isInterface())

File: src/test/javassist/JvstTest5.java
Patch:
@@ -128,11 +128,11 @@ public void testInnerClassAttributeRemove() throws Exception {
 
     public void testJIRA248() throws Exception {
         CtClass cc = sloader.get("test5.JIRA248");
-        String methodBody = "public int run() { return foo() + super.foo(); }";
+        String methodBody = "public int run() { return foo() + super.foo() + super.bar(); }";
         CtMethod ctMethod = CtMethod.make(methodBody, cc);
         cc.addMethod(ctMethod);
         cc.writeFile();
         Object obj = make(cc.getName());
-        assertEquals(71, invoke(obj, "run"));
+        assertEquals(271, invoke(obj, "run"));
     }
 }

File: src/test/testproxy/ProxyTester.java
Patch:
@@ -399,7 +399,7 @@ public static class WriteReplace2 implements Serializable {
     public static void testJIRA189() throws Exception {
     	Class persistentClass = Target189.PublishedArticle.class;
         ProxyFactory factory = new ProxyFactory();
-        factory.writeDirectory = ".";
+        // factory.writeDirectory = ".";
         factory.setUseCache(false);
         factory.setSuperclass(persistentClass);
         factory.setInterfaces(new Class[] { Target189.TestProxy.class });
@@ -417,7 +417,7 @@ public static void testJIRA189() throws Exception {
 
     public void testJIRA127() throws Exception {
         ProxyFactory proxyFactory = new ProxyFactory();
-        proxyFactory.writeDirectory = ".";
+        // proxyFactory.writeDirectory = ".";
         proxyFactory.setInterfaces(new Class[]{ Target127.Sub.class });
         Target127.Sub proxy = (Target127.Sub)proxyFactory.create(new Class[0], new Object[0], new MethodHandler() {
             public Object invoke(Object self, Method thisMethod, Method proceed, Object[] args) throws Throwable {

File: src/main/javassist/compiler/TypeChecker.java
Patch:
@@ -502,7 +502,7 @@ private void computeBinExprType(BinExpr expr, int token, int type1)
         else
             insertCast(expr, type1, type2);
 
-        if (CodeGen.isP_INT(exprType))
+        if (CodeGen.isP_INT(exprType) && exprType != BOOLEAN)
             exprType = INT;         // type1 may be BYTE, ...
     }
 

File: src/main/javassist/SerialVersionUID.java
Patch:
@@ -70,8 +70,10 @@ private static boolean isSerializable(CtClass clazz)
     /**
      * Calculate default value. See Java Serialization Specification, Stream
      * Unique Identifiers.
+     *
+     * @since 3.20
      */
-    static long calculateDefault(CtClass clazz)
+    public static long calculateDefault(CtClass clazz)
         throws CannotCompileException
     {
         try {

File: src/main/javassist/bytecode/stackmap/BasicBlock.java
Patch:
@@ -360,6 +360,7 @@ private BasicBlock[] makeBlocks(HashMap markTable) {
                             prev.length = m.position - prev.position;
                             // the incoming flow from dead code is not counted
                             // bb.incoming++;
+                            prev.stop = true;   // because the incoming flow is not counted.
                             prev.exit = makeArray(bb);
                         }
                     }

File: src/test/javassist/JvstTest4.java
Patch:
@@ -661,9 +661,9 @@ public void testJIRA150() throws Exception {
         long t2 = endTime2 - endTime;
         long t3 = endTime3 - endTime2;
         System.out.println("JIRA150: " + t1 + ", " + t2 + ", " + t3);
-        assertTrue("performance test (the next try may succeed): " + t1 + "/ 6 < " + t2,
+        assertTrue("performance test (the next try may succeed): " + t2 + " < 6 * " + t1,
                    t2 < t1 * 6);
-        assertTrue("", t3 < t1 * 3);
+        assertTrue(t3 + " < 3 * " + t1, t3 < t1 * 3);
     }
 
     public void testJIRA150b() throws Exception {

File: src/main/javassist/ClassPool.java
Patch:
@@ -250,7 +250,7 @@ protected CtClass getCached(String classname) {
      * caching of classes.
      *
      * @see #getCached(String)
-     * @see #removeCached(String,CtClass)
+     * @see #removeCached(String)
      */
     protected void cacheCtClass(String classname, CtClass c, boolean dynamic) {
         classes.put(classname, c);
@@ -517,7 +517,6 @@ public CtClass getCtClass(String classname) throws NotFoundException {
 
     /**
      * @param useCache      false if the cached CtClass must be ignored.
-     * @param searchParent  false if the parent class pool is not searched.
      * @return null     if the class could not be found.
      */
     protected synchronized CtClass get0(String classname, boolean useCache)

File: src/main/javassist/bytecode/stackmap/Tracer.java
Patch:
@@ -104,7 +104,7 @@ protected void visitTableSwitch(int pos, byte[] code, int n,
      * @param pos           the position of LOOKUPSWITCH
      * @param code          bytecode
      * @param n             the number of case labels
-     * @param offsetPos     the position of the table of pairs of a value and a branch target.
+     * @param pairsPos      the position of the table of pairs of a value and a branch target.
      * @param defaultOffset     the offset to the default branch target.
      */
     protected void visitLookupSwitch(int pos, byte[] code, int n,

File: src/main/javassist/bytecode/stackmap/TypedBlock.java
Patch:
@@ -29,7 +29,7 @@ public class TypedBlock extends BasicBlock {
      * Divides the method body into basic blocks.
      * The type information of the first block is initialized.
      *
-     * @param optmize       if it is true and the method does not include
+     * @param optimize       if it is true and the method does not include
      *                      branches, this method returns null.
      */
     public static TypedBlock[] makeBlocks(MethodInfo minfo, CodeAttribute ca,

File: src/main/javassist/compiler/AccessorMaker.java
Patch:
@@ -90,7 +90,7 @@ public String getConstructor(CtClass c, String desc, MethodInfo orig)
      * @param accDesc   the descriptor of the accessor method.  The first
      *                  parameter type is <code>clazz</code>.
      *                  If the private method is static,
-     *              <code>accDesc<code> must be identical to <code>desc</code>. 
+     *              <code>accDesc</code> must be identical to <code>desc</code>. 
      *                  
      * @param orig      the method info of the private method.
      * @return

File: src/main/javassist/compiler/Javac.java
Patch:
@@ -185,8 +185,8 @@ private CtBehavior compileMethod(Parser p, MethodDecl md)
     /**
      * Compiles a method (or constructor) body.
      *
-     * @src	a single statement or a block.
-     *          If null, this method produces a body returning zero or null.
+     * @param src	a single statement or a block.
+     *              If null, this method produces a body returning zero or null.
      */
     public Bytecode compileBody(CtBehavior method, String src)
         throws CompileError
@@ -346,7 +346,7 @@ public int recordParams(CtClass[] params, boolean isStatic)
      * <code>isStatic</code> must be recorded before compilation.
      * <code>maxLocals</code> is updated to include $0,...
      *
-     * @paaram use0     true if $0 is used.
+     * @param use0     true if $0 is used.
      * @param varNo     the register number of $0 (use0 is true)
      *                          or $1 (otherwise).
      * @param target    the type of $0 (it can be null if use0 is false).

File: src/main/javassist/compiler/MemberResolver.java
Patch:
@@ -299,7 +299,7 @@ public CtField lookupFieldByJvmName(String jvmClassName, Symbol fieldName)
     }
 
     /**
-     * @param name      a qualified class name. e.g. java.lang.String
+     * @param className      a qualified class name. e.g. java.lang.String
      */
     public CtField lookupField(String className, Symbol fieldName)
         throws CompileError
@@ -326,7 +326,7 @@ public CtClass lookupClass(Declarator decl) throws CompileError {
     }
 
     /**
-     * @parma classname         jvm class name.
+     * @param classname         jvm class name.
      */
     public CtClass lookupClass(int type, int dim, String classname)
         throws CompileError

File: src/main/javassist/compiler/ProceedHandler.java
Patch:
@@ -23,7 +23,6 @@
  * An interface to an object for implementing $proceed().
  *
  * @see javassist.compiler.JvstCodeGen#setProceedHandler(ProceedHandler, String)
- * @see javassist.compiler.JvstCodeGen#atMethodCall(Expr)
  */
 public interface ProceedHandler {
     void doit(JvstCodeGen gen, Bytecode b, ASTList args) throws CompileError;

File: src/main/javassist/compiler/ast/Visitor.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * The visitor pattern.
  *
- * @see ast.ASTree#accept(Visitor)
+ * @see ASTree#accept(Visitor)
  */
 public class Visitor {
     public void atASTList(ASTList n) throws CompileError {}

File: src/main/javassist/bytecode/analysis/Analyzer.java
Patch:
@@ -59,13 +59,13 @@
  * // 5:   new #18; //class java/lang/Double
  * // 8:   dup
  * // 9:   dconst_0
- * // 10:  invokespecial   #44; //Method java/lang/Double."<init>":(D)V
+ * // 10:  invokespecial   #44; //Method java/lang/Double."&lt;init&gt;":(D)V
  * // 13:  astore_2
  * // 14:  goto    26
  * // 17:  new #16; //class java/lang/Long
  * // 20:  dup
  * // 21:  lconst_1
- * // 22:  invokespecial   #47; //Method java/lang/Long."<init>":(J)V
+ * // 22:  invokespecial   #47; //Method java/lang/Long."&lt;init&gt;":(J)V
  * // 25:  astore_2
  * // 26:  aload_2
  * // 27:  areturn

File: src/main/javassist/tools/reflect/ClassMetaobject.java
Patch:
@@ -337,7 +337,7 @@ public final Class getReturnType(int identifier) {
      * original name.
      *
      * <p>This method is useful, in conjuction with
-     * {@link ClassMetaobject#getMethod()}, to obtain a quick reference
+     * {@link ClassMetaobject#getMethod(int)}, to obtain a quick reference
      * to the original method in the reflected class (i.e. not the proxy
      * method), using the original name of the method.
      *

File: src/main/javassist/ByteArrayClassPath.java
Patch:
@@ -29,11 +29,11 @@
  * into a <code>CtClass</code> object representing the class with a name
  * <code>classname</code>, then do as following:
  *
- * <ul><pre>
+ * <pre>
  * ClassPool cp = ClassPool.getDefault();
  * cp.insertClassPath(new ByteArrayClassPath(classname, b));
  * CtClass cc = cp.get(classname);
- * </pre></ul>
+ * </pre>
  *
  * <p>The <code>ClassPool</code> object <code>cp</code> uses the created
  * <code>ByteArrayClassPath</code> object as the source of the class file.

File: src/main/javassist/ClassClassPath.java
Patch:
@@ -27,10 +27,10 @@
  * with a user-defined class loader and any class files are not found with
  * the default <code>ClassPool</code>.  For example,
  *
- * <ul><pre>
+ * <pre>
  * ClassPool cp = ClassPool.getDefault();
  * cp.insertClassPath(new ClassClassPath(this.getClass()));
- * </pre></ul>
+ * </pre>
  *
  * This code snippet permanently adds a <code>ClassClassPath</code>
  * to the default <code>ClassPool</code>.  Note that the default

File: src/main/javassist/ClassMap.java
Patch:
@@ -25,15 +25,15 @@
  * definition or a method body.  Define a subclass of this class
  * if a more complex mapping algorithm is needed.  For example,
  *
- * <ul><pre>class MyClassMap extends ClassMap {
+ * <pre>class MyClassMap extends ClassMap {
  *   public Object get(Object jvmClassName) {
  *     String name = toJavaName((String)jvmClassName);
  *     if (name.startsWith("java."))
  *         return toJvmName("java2." + name.substring(5));
  *     else
  *         return super.get(jvmClassName);
  *   }
- * }</pre></ul>
+ * }</pre>
  *
  * <p>This subclass maps <code>java.lang.String</code> to
  * <code>java2.lang.String</code>.  Note that <code>get()</code>

File: src/main/javassist/Translator.java
Patch:
@@ -47,8 +47,8 @@ void start(ClassPool pool)
      * Is invoked by a <code>Loader</code> for notifying that
      * a class is loaded.  The <code>Loader</code> calls
      *
-     * <ul><pre>
-     * pool.get(classname).toBytecode()</pre></ul>
+     * <pre>
+     * pool.get(classname).toBytecode()</pre>
      *
      * to read the class file after <code>onLoad()</code> returns.
      *

File: src/main/javassist/URLClassPath.java
Patch:
@@ -41,8 +41,8 @@ public class URLClassPath implements ClassPath {
      * "org.javassist.test.Main", then the given URL is used for loading that class.
      * The <code>URLClassPath</code> obtains a class file from:
      *
-     * <ul><pre>http://www.javassist.org:80/java/classes/org/javassist/test/Main.class
-     * </pre></ul>
+     * <pre>http://www.javassist.org:80/java/classes/org/javassist/test/Main.class
+     * </pre>
      *
      * <p>Here, we assume that <code>host</code> is "www.javassist.org",
      * <code>port</code> is 80, and <code>directory</code> is "/java/classes/".

File: src/main/javassist/bytecode/ClassFile.java
Patch:
@@ -319,7 +319,7 @@ public void setAccessFlags(int acc) {
      *
      * <p>The returned value is obtained from <code>inner_class_access_flags</code>
      * of the entry representing this nested class itself
-     * in <code>InnerClasses_attribute</code>>. 
+     * in <code>InnerClasses_attribute</code>. 
      */
     public int getInnerAccessFlags() {
         InnerClassesAttribute ica

File: src/main/javassist/bytecode/MethodInfo.java
Patch:
@@ -52,13 +52,13 @@ public class MethodInfo {
     public static boolean doPreverify = false;
 
     /**
-     * The name of constructors: <code>&lt;init&gt</code>.
+     * The name of constructors: <code>&lt;init&gt;</code>.
      */
     public static final String nameInit = "<init>";
 
     /**
      * The name of class initializer (static initializer):
-     * <code>&lt;clinit&gt</code>.
+     * <code>&lt;clinit&gt;</code>.
      */
     public static final String nameClinit = "<clinit>";
 

File: src/main/javassist/bytecode/SignatureAttribute.java
Patch:
@@ -377,7 +377,7 @@ public static class TypeParameter {
 
         /**
          * Constructs a <code>TypeParameter</code> representing a type parametre
-         * like <code>&lt;T extends ... &gt;<code>.
+         * like <code>&lt;T extends ... &gt;</code>.
          *
          * @param name      parameter name.
          * @param superClass    an upper bound class-type (or null).
@@ -394,7 +394,7 @@ public TypeParameter(String name, ObjectType superClass, ObjectType[] superInter
 
         /**
          * Constructs a <code>TypeParameter</code> representing a type parameter
-         * like <code>&lt;T&gt;<code>.
+         * like <code>&lt;T&gt;</code>.
          *
          * @param name          parameter name.
          */

File: src/main/javassist/bytecode/TypeAnnotationsAttribute.java
Patch:
@@ -10,6 +10,8 @@
  * A class representing
  * {@code RuntimeVisibleTypeAnnotations} attribute and
  * {@code RuntimeInvisibleTypeAnnotations} attribute.
+ *
+ * @since 3.19
  */
 public class TypeAnnotationsAttribute extends AttributeInfo {
     /**

File: src/main/javassist/bytecode/analysis/Analyzer.java
Patch:
@@ -43,7 +43,7 @@
  * // Method to analyze
  * public Object doSomething(int x) {
  *     Number n;
- *     if (x < 5) {
+ *     if (x &lt; 5) {
  *        n = new Double(0);
  *     } else {
  *        n = new Long(0);

File: src/main/javassist/bytecode/annotation/TypeAnnotationsWriter.java
Patch:
@@ -9,6 +9,8 @@
  * A convenience class for constructing a
  * {@code ..TypeAnnotations_attribute}.
  * See the source code of the {@link javassist.bytecode.TypeAnnotationsAttribute} class.
+ *
+ * @since 3.19
  */
 public class TypeAnnotationsWriter extends AnnotationsWriter {
     /**

File: src/main/javassist/expr/ExprEditor.java
Patch:
@@ -40,7 +40,7 @@
  *
  * <p>The following code is an example:
  *
- * <ul><pre>
+ * <pre>
  * CtMethod cm = ...;
  * cm.instrument(new ExprEditor() {
  *     public void edit(MethodCall m) throws CannotCompileException {
@@ -49,7 +49,7 @@
  *                                + m.getLineNumber());
  *     }
  * });
- * </pre></ul>
+ * </pre>
  *
  * <p>This code inspects all method calls appearing in the method represented
  * by <code>cm</code> and it prints the names and the line numbers of the

File: src/main/javassist/runtime/Desc.java
Patch:
@@ -28,7 +28,7 @@ public class Desc {
      * Specifies how a <code>java.lang.Class</code> object is loaded.
      *
      * <p>If true, it is loaded by:
-     * <ul><pre>Thread.currentThread().getContextClassLoader().loadClass()</pre></ul>
+     * <pre>Thread.currentThread().getContextClassLoader().loadClass()</pre>
      * <p>If false, it is loaded by <code>Class.forName()</code>.
      * The default value is false.
      */

File: src/main/javassist/tools/Dump.java
Patch:
@@ -26,7 +26,7 @@
  * the class file is broken.
  *
  * <p>For example,
- * <ul><pre>% java javassist.tools.Dump foo.class</pre></ul>
+ * <pre>% java javassist.tools.Dump foo.class</pre>
  *
  * <p>prints the contents of the constant pool and the list of methods
  * and fields.

File: src/main/javassist/tools/framedump.java
Patch:
@@ -24,7 +24,7 @@
  *  of all methods in a class.
  *
  * <p>For example,
- * <ul><pre>% java javassist.tools.framedump foo.class</pre></ul>
+ * <pre>% java javassist.tools.framedump foo.class</pre>
  */
 public class framedump {
     private framedump() {}

File: src/main/javassist/tools/reflect/Compiler.java
Patch:
@@ -50,8 +50,8 @@ class CompiledClass {
  * by that class name is not reflective.
  * 
  * <p>For example,
- * <ul><pre>% java Compiler Dog -m MetaDog -c CMetaDog Cat -m MetaCat Cow
- * </pre></ul>
+ * <pre>% java Compiler Dog -m MetaDog -c CMetaDog Cat -m MetaCat Cow
+ * </pre>
  *
  * <p>modifies class files <code>Dog.class</code>, <code>Cat.class</code>,
  * and <code>Cow.class</code>.

File: src/main/javassist/tools/rmi/ObjectImporter.java
Patch:
@@ -100,10 +100,10 @@ public ObjectImporter(Applet applet) {
      * <p>If you run a program with <code>javassist.tools.web.Viewer</code>,
      * you can construct an object importer as follows:
      *
-     * <ul><pre>
+     * <pre>
      * Viewer v = (Viewer)this.getClass().getClassLoader();
      * ObjectImporter oi = new ObjectImporter(v.getServer(), v.getPort());
-     * </pre></ul>
+     * </pre>
      *
      * @see javassist.tools.web.Viewer
      */

File: src/main/javassist/tools/rmi/StubGenerator.java
Patch:
@@ -26,7 +26,7 @@
  *
  * <p>The proxy class for class A is as follows:
  *
- * <ul><pre>public class A implements Proxy, Serializable {
+ * <pre>public class A implements Proxy, Serializable {
  *   private ObjectImporter importer;
  *   private int objectId;
  *   public int _getObjectId() { return objectId; }
@@ -35,7 +35,7 @@
  *   }
  *
  *   ... the same methods that the original class A declares ...
- * }</pre></ul>
+ * }</pre>
  *
  * <p>Instances of the proxy class is created by an
  * <code>ObjectImporter</code> object.

File: src/main/javassist/tools/web/Viewer.java
Patch:
@@ -28,7 +28,7 @@
  *
  * <p>To run, you should type:
  *
- * <ul><code>% java javassist.tools.web.Viewer <i>host port</i> Main arg1, ...</code></ul>
+ * <pre>% java javassist.tools.web.Viewer <i>host port</i> Main arg1, ...</pre>
  *
  * <p>This command calls <code>Main.main()</code> with <code>arg1,...</code>
  * All classes including <code>Main</code> are fetched from
@@ -42,10 +42,10 @@
  * a program loaded by this object can call a method in <code>Viewer</code>.
  * For example, you can write something like this:
  *
- * <ul><pre>
+ * <pre>
  * Viewer v = (Viewer)this.getClass().getClassLoader();
  * String port = v.getPort();
- * </pre></ul>
+ * </pre>
  *
  */
 public class Viewer extends ClassLoader {

File: src/main/javassist/bytecode/ClassFileWriter.java
Patch:
@@ -507,6 +507,7 @@ public void end(StackMapTable.Writer smap, AttributeWriter aw) {
          * Returns the length of the bytecode that has been added so far.
          *
          * @return      the length in bytes.
+         * @since 3.19
          */
         public int size() { return output.getPos() - startPos - 14; } 
 

File: src/main/javassist/bytecode/annotation/ClassMemberValue.java
Patch:
@@ -101,7 +101,7 @@ Class getType(ClassLoader cl) throws ClassNotFoundException {
     public String getValue() {
         String v = cp.getUtf8Info(valueIndex);
         try {
-			return SignatureAttribute.toTypeSignature(v).toString();
+			return SignatureAttribute.toTypeSignature(v).jvmTypeName();
 		} catch (BadBytecode e) {
 			throw new RuntimeException(e);
 		}
@@ -121,7 +121,7 @@ public void setValue(String newClassName) {
      * Obtains the string representation of this object.
      */
     public String toString() {
-    	return getValue() + ".class";
+        return getValue().replace('$', '.') + ".class";
     }
 
     /**

File: src/main/javassist/bytecode/InstructionPrinter.java
Patch:
@@ -116,7 +116,7 @@ public static String instructionString(CodeIterator iter, int pos, ConstPool poo
             case IF_ICMPNE:
                 return opstring + " " + (iter.s16bitAt(pos + 1) + pos);
             case IINC:
-                return opstring + " " + iter.byteAt(pos + 1);
+                return opstring + " " + iter.byteAt(pos + 1) + ", " + iter.signedByteAt(pos + 2);
             case GOTO:
             case JSR:
                 return opstring + " " + (iter.s16bitAt(pos + 1) + pos);

File: src/main/javassist/tools/framedump.java
Patch:
@@ -36,7 +36,7 @@ private framedump() {}
      */
     public static void main(String[] args) throws Exception {
         if (args.length != 1) {
-            System.err.println("Usage: java javassist.tools.framedump <class file name>");
+            System.err.println("Usage: java javassist.tools.framedump <fully-qualified class name>");
             return;
         }
         

File: src/test/javassist/JvstTest4.java
Patch:
@@ -657,8 +657,8 @@ public void testJIRA150() throws Exception {
         long t2 = endTime2 - endTime;
         long t3 = endTime3 - endTime2;
         System.out.println("JIRA150: " + t1 + ", " + t2 + ", " + t3);
-        assertTrue(t2 < t1 * 3);
-        assertTrue(t3 < t1 * 2);
+        assertTrue(t2 < t1 * 4);
+        assertTrue(t3 < t1 * 3);
     }
 
     public void testJIRA150b() throws Exception {

File: src/main/javassist/compiler/CodeGen.java
Patch:
@@ -434,7 +434,7 @@ private void atWhileStmnt(Stmnt st, boolean notDo) throws CompileError {
         if (notDo)
             bytecode.write16bit(pc, pc3 - pc + 1);
 
-        boolean alwaysBranch = compileBooleanExpr(true, expr);
+        boolean alwaysBranch = compileBooleanExpr(true, expr) && breakList.size() == 0;
         bytecode.addIndex(pc2 - bytecode.currentPc() + 1);
 
         patchGoto(breakList, bytecode.currentPc());

File: src/main/javassist/bytecode/stackmap/MapMaker.java
Patch:
@@ -183,10 +183,10 @@ private void make(byte[] code, TypedBlock tb)
 
         int pos = tb.position;
         int end = pos + tb.length;
-        while (pos < end)
+        while (pos < end) {
             pos += doOpcode(pos, code);
-
-        traceException(code, tb.toCatch);
+            traceException(code, tb.toCatch);
+        }
 
         if (tb.exit != null) {
             for (int i = 0; i < tb.exit.length; i++) {

File: src/main/javassist/bytecode/stackmap/MapMaker.java
Patch:
@@ -291,7 +291,6 @@ private void recordStackMap0(TypedBlock target, int st, TypeData[] tStackTypes)
     protected static int recordTypeData(int n, TypeData[] srcTypes, TypeData[] destTypes) {
         int k = -1;
         for (int i = 0; i < n; i++) {
-            // TypeData t = srcTypes[i];
             TypeData t = validateTypeData(srcTypes, n, i);
             destTypes[i] = t.join();
             if (t != TOP)

File: src/main/javassist/bytecode/stackmap/Tracer.java
Patch:
@@ -81,7 +81,7 @@ protected int doOpcode(int pos, byte[] code) throws BadBytecode {
                     return doOpcode148_201(pos, code, op);
         }
         catch (ArrayIndexOutOfBoundsException e) {
-            throw new BadBytecode("inconsistent stack height " + e.getMessage());
+            throw new BadBytecode("inconsistent stack height " + e.getMessage(), e);
         }
     }
 

File: src/main/javassist/compiler/MemberCodeGen.java
Patch:
@@ -957,7 +957,7 @@ private boolean setFieldType(FieldInfo finfo) throws CompileError {
         else
             className = null;
 
-        boolean is2byte = (c == 'J' || c == 'D');
+        boolean is2byte = dim == 0 && (c == 'J' || c == 'D');
         return is2byte;
     }
 

File: src/main/javassist/ClassPool.java
Patch:
@@ -936,7 +936,7 @@ public ClassPath appendClassPath(String pathname)
     /**
      * Detatches the <code>ClassPath</code> object from the search path.
      * The detached <code>ClassPath</code> object cannot be added
-     * to the pathagain.
+     * to the path again.
      */
     public void removeClassPath(ClassPath cp) {
         source.removeClassPath(cp);

File: src/main/javassist/bytecode/CodeAttribute.java
Patch:
@@ -465,13 +465,15 @@ static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable,
      * Changes the index numbers of the local variables
      * to append a new parameter.
      * This method does not update <code>LocalVariableAttribute</code>,
+     * <code>LocalVariableTypeAttribute</code>,
      * <code>StackMapTable</code>, or <code>StackMap</code>.
      * These attributes must be explicitly updated.
      *
      * @param where         the index of the new parameter.
      * @param size         the type size of the new parameter (1 or 2).
      *
      * @see LocalVariableAttribute#shiftIndex(int, int)
+     * @see LocalVariableTypeAttribute#shiftIndex(int, int)
      * @see StackMapTable#insertLocal(int, int, int)
      * @see StackMap#insertLocal(int, int, int)
      */

File: src/main/javassist/CtClass.java
Patch:
@@ -69,7 +69,7 @@ public abstract class CtClass {
     /**
      * The version number of this release.
      */
-    public static final String version = "3.17.1-GA";
+    public static final String version = "3.18.0-GA";
 
     /**
      * Prints the version number and the copyright notice.
@@ -80,7 +80,7 @@ public abstract class CtClass {
      */
     public static void main(String[] args) {
         System.out.println("Javassist version " + CtClass.version);
-        System.out.println("Copyright (C) 1999-2012 Shigeru Chiba."
+        System.out.println("Copyright (C) 1999-2013 Shigeru Chiba."
                            + " All Rights Reserved.");
     }
 

File: src/main/javassist/bytecode/Bytecode.java
Patch:
@@ -1083,7 +1083,7 @@ public void addInvokevirtual(String classname, String name, String desc) {
     public void addInvokevirtual(int clazz, String name, String desc) {
         add(INVOKEVIRTUAL);
         addIndex(constPool.addMethodrefInfo(clazz, name, desc));
-        growStack(Descriptor.dataSize(desc));   // assume CosntPool#REF_invokeStatic
+        growStack(Descriptor.dataSize(desc) - 1);
     }
 
     /**
@@ -1170,7 +1170,7 @@ public void addInvokedynamic(int bootstrap, String name, String desc) {
         add(INVOKEDYNAMIC);
         addIndex(dyn);
         add(0, 0);
-        growStack(Descriptor.dataSize(desc) - 1);
+        growStack(Descriptor.dataSize(desc));   // assume ConstPool#REF_invokeStatic
     }
 
     /**

File: src/test/javassist/JvstTest2.java
Patch:
@@ -436,14 +436,14 @@ public void testNullArg() throws Exception {
 
     public void testAddMethod() throws Exception {
         CtClass cc = sloader.get("test2.AddMethod");
-	CtMethod m = CtNewMethod.make(
-                         "public void f() { return 1; }", cc);
+        CtMethod m = CtNewMethod.make(
+                         "public int f() { return 1; }", cc);
         try {
             cc.addMethod(m);
             fail();
         }
         catch (CannotCompileException e) {}
-	CtMethod m2 = CtNewMethod.make(
+        CtMethod m2 = CtNewMethod.make(
                          "public void f(int i, int j) { return 1; }", cc);
         cc.addMethod(m2);
         try {

File: src/test/test/javassist/proxy/JBPAPP9257Test.java
Patch:
@@ -27,13 +27,14 @@ public Object invoke(Object self, Method m, Method proceed,
                 // method.
             }
         };
-        Foo foo = (Foo) c.newInstance();
+        Foo foo = (Foo)c.newInstance();
         try {
             ((ProxyObject)foo).setHandler(mi);
             fail("foo is a ProxyObject!");
         } catch (ClassCastException e) {}
         ((Proxy)foo).setHandler(mi);
         assertEquals("I'm doing something!", foo.doSomething());
+        assertEquals("This is a secret handler!", foo.getHandler());
     }
 
     public void testGetHandler2() throws Exception {
@@ -61,5 +62,6 @@ public Object invoke(Object self, Method m, Method proceed,
         } catch (ClassCastException e) {}
         ((Proxy)foo).setHandler(mi);
         assertEquals("do something!", foo.doSomething());
+        assertEquals("return a string!", foo.getHandler());
     }
 }

File: src/test/test1/Delegator.java
Patch:
@@ -1,7 +1,7 @@
 package test1;
 
 class SuperDelegator {
-    public int f(int p) { return p + 1; }
+	public int f(int p) { return p + 1; }
     public static int g(int p) { return p + 1; }
 }
 

File: src/test/javassist/bytecode/StackMapTest.java
Patch:
@@ -790,6 +790,9 @@ public void testJsr() throws Exception {
         Bytecode code = new Bytecode(cp, 1, 3);
         code.addIconst(3);
         code.addIstore(1);
+        code.addIload(1);
+        code.add(Opcode.IFEQ);
+        code.addIndex(6);
         code.add(Opcode.JSR);
         code.addIndex(5);
         code.addIload(1);

File: src/test/javassist/bytecode/StackMapTest.java
Patch:
@@ -783,7 +783,7 @@ public void testCommonSuperclass() throws Exception {
     public void testJsr() throws Exception {
         CtClass cc = loader.makeClass("javassist.bytecode.StackMapTestJsrTest");
         ClassFile cf = cc.getClassFile();
-        cf.setMajorVersion(ClassFile.JAVA_6);
+        cf.setMajorVersion(ClassFile.JAVA_5);
         ConstPool cp = cf.getConstPool();
         MethodInfo mi = new MethodInfo(cp, "test", "()I");
         mi.setAccessFlags(AccessFlag.PUBLIC);
@@ -806,8 +806,8 @@ public void testJsr() throws Exception {
                                  + "}",
                                    cc));
         cc.writeFile();
-        // Object t1 = make(cc.getName());
-        // assertEquals(3, invoke(t1, "test"));
+        Object t1 = make(cc.getName());
+        assertEquals(3, invoke(t1, "test"));
     }
 
     public void tstCtClassType() throws Exception {

File: src/main/javassist/CtClass.java
Patch:
@@ -69,7 +69,7 @@ public abstract class CtClass {
     /**
      * The version number of this release.
      */
-    public static final String version = "3.17.0-GA";
+    public static final String version = "3.17.1-snapshot";
 
     /**
      * Prints the version number and the copyright notice.

File: src/main/javassist/compiler/MemberCodeGen.java
Patch:
@@ -590,7 +590,7 @@ private void atMethodCallCore2(CtClass targetClass, String mname,
         if (mname.equals(MethodInfo.nameInit)) {
             isSpecial = true;
             if (declClass != targetClass)
-                throw new CompileError("no such constructor");
+                throw new CompileError("no such constructor: " + targetClass.getName());
 
             if (declClass != thisClass && AccessFlag.isPrivate(acc)) {
                 desc = getAccessibleConstructor(desc, declClass, minfo);

File: src/main/javassist/util/proxy/MethodHandler.java
Patch:
@@ -22,7 +22,7 @@
  * The interface implemented by the invocation handler of a proxy
  * instance.
  *
- * @see ProxyFactory#setHandler(MethodHandler)
+ * @see Proxy#setHandler(MethodHandler)
  */
 public interface MethodHandler {
     /**
@@ -33,7 +33,7 @@ public interface MethodHandler {
      * @param thisMethod    the overridden method declared in the super
      *                      class or interface.
      * @param proceed       the forwarder method for invoking the overridden 
-     *                      method.  It is null if the overridden mehtod is
+     *                      method.  It is null if the overridden method is
      *                      abstract or declared in the interface.
      * @param args          an array of objects containing the values of
      *                      the arguments passed in the method invocation

File: src/test/javassist/JvstTest.java
Patch:
@@ -1116,14 +1116,14 @@ public static Test suite() {
         suite.addTestSuite(javassist.bytecode.InsertGap0.class);
         suite.addTestSuite(javassist.tools.reflect.LoaderTest.class);
         suite.addTestSuite(testproxy.ProxyTester.class);
-        // suite.addTestSuite(testproxy.ProxyFactoryPerformanceTest.class);
+        suite.addTestSuite(testproxy.ProxyFactoryPerformanceTest.class); // remove?
         suite.addTestSuite(javassist.proxyfactory.ProxyFactoryTest.class);
         suite.addTestSuite(javassist.proxyfactory.Tester.class);
         suite.addTestSuite(test.javassist.proxy.ProxySerializationTest.class);
         suite.addTestSuite(test.javassist.convert.ArrayAccessReplaceTest.class);
         suite.addTestSuite(test.javassist.proxy.JASSIST113RegressionTest.class);
         suite.addTestSuite(test.javassist.proxy.JBPAPP9257Test.class);
-        //suite.addTestSuite(test.javassist.proxy.ProxyCacheGCTest.class);
+        suite.addTestSuite(test.javassist.proxy.ProxyCacheGCTest.class);  // remvoe?
         suite.addTestSuite(test.javassist.proxy.ProxyFactoryCompatibilityTest.class);
         suite.addTestSuite(test.javassist.proxy.ProxySerializationTest.class);
         suite.addTestSuite(test.javassist.proxy.ProxySimpleTest.class);

File: src/test/javassist/proxyfactory/ProxyFactoryTest.java
Patch:
@@ -12,8 +12,6 @@
  * <a href="mailto:struberg@yahoo.de">Mark Struberg</a>
  */
 public class ProxyFactoryTest extends TestCase {
-
-
     public void testMethodHandlers() throws Exception {
         ProxyFactory fact = new ProxyFactory();
         fact.setSuperclass(MyCls.class);

File: src/main/javassist/bytecode/MethodInfo.java
Patch:
@@ -431,7 +431,7 @@ public void rebuildStackMap(ClassPool pool) throws BadBytecode {
      * include a code attribute, nothing happens.
      *
      * @param pool          used for making type hierarchy.
-     * @see StackMapTable
+     * @see StackMap
      * @since 3.12
      */
     public void rebuildStackMapForME(ClassPool pool) throws BadBytecode {

File: src/main/javassist/bytecode/stackmap/TypeData.java
Patch:
@@ -745,11 +745,13 @@ public boolean eq(TypeData d) {
 
         public void setType(String typeName, ClassPool cp) throws BadBytecode {
             super.setType(typeName, cp);
-            initialized = true;
+            // initialized = true;
         }
 
         public String toString() { return "uninit:" + getName() + "@" + offset; }
 
+        public int offset() { return offset; }
+
         public void constructorCalled(int offset) {
             if (offset == this.offset)
                 initialized = true;

File: src/main/javassist/bytecode/AttributeInfo.java
Patch:
@@ -77,6 +77,8 @@ static AttributeInfo read(ConstPool cp, DataInputStream in)
         if (nameStr.charAt(0) < 'L') {
             if (nameStr.equals(AnnotationDefaultAttribute.tag))
                 return new AnnotationDefaultAttribute(cp, name, in);
+            else if (nameStr.equals(BootstrapMethodsAttribute.tag))
+                return new BootstrapMethodsAttribute(cp, name, in);
             else if (nameStr.equals(CodeAttribute.tag))
                 return new CodeAttribute(cp, name, in);
             else if (nameStr.equals(ConstantAttribute.tag))

File: src/main/javassist/bytecode/InstructionPrinter.java
Patch:
@@ -137,8 +137,8 @@ public static String instructionString(CodeIterator iter, int pos, ConstPool poo
                 return opstring + " " + methodInfo(pool, iter.u16bitAt(pos + 1));
             case INVOKEINTERFACE:
                 return opstring + " " + interfaceMethodInfo(pool, iter.u16bitAt(pos + 1));
-            case 186:
-                throw new RuntimeException("Bad opcode 186");
+            case INVOKEDYNAMIC:
+                return opstring + " " + iter.u16bitAt(pos + 1);
             case NEW:
                 return opstring + " " + classInfo(pool, iter.u16bitAt(pos + 1));
             case NEWARRAY:

File: src/main/javassist/bytecode/Opcode.java
Patch:
@@ -156,6 +156,7 @@ public interface Opcode {
     int IMUL = 104;
     int INEG = 116;
     int INSTANCEOF = 193;
+    int INVOKEDYNAMIC = 186;
     int INVOKEINTERFACE = 185;
     int INVOKESPECIAL = 183;
     int INVOKESTATIC = 184;
@@ -428,7 +429,7 @@ public interface Opcode {
         0, // invokespecial, 183        depends on the type
         0, // invokestatic, 184         depends on the type
         0, // invokeinterface, 185      depends on the type
-        0, // undefined, 186
+        0, // invokedynaimc, 186        depends on the type
         1, // new, 187
         0, // newarray, 188
         0, // anewarray, 189

File: src/main/javassist/bytecode/CodeIterator.java
Patch:
@@ -725,10 +725,11 @@ public void append(ExceptionTable et, int offset) {
         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1,
         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3,
         3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 1, 1, 1, 1, 1, 1, 3, 3,
-        3, 3, 3, 3, 3, 5, 5, 3, 2, 3, 1, 1, 3, 3, 1, 1, 0, 4, 3, 3,
+     // 3, 3, 3, 3, 3, 5, 5, 3, 2, 3, 1, 1, 3, 3, 1, 1, 0, 4, 3, 3,
+        3, 3, 3, 3, 3, 5, 0, 3, 2, 3, 1, 1, 3, 3, 1, 1, 0, 4, 3, 3,
         5, 5
     };
-    // 0 .. LOOKUPSWITCH, TABLESWITCH, WIDE
+    // 0 .. UNUSED (186), LOOKUPSWITCH, TABLESWITCH, WIDE
 
     /**
      * Calculates the index of the next opcode.

File: src/main/javassist/CtNewWrappedConstructor.java
Patch:
@@ -39,6 +39,7 @@ public static CtConstructor wrapped(CtClass[] parameterTypes,
                                      howToCallSuper, body,
                                      parameterTypes, constParam);
             cons.getMethodInfo2().setCodeAttribute(code.toCodeAttribute());
+            // a stack map table is not needed.
             return cons;
         }
         catch (NotFoundException e) {

File: src/main/javassist/CtNewWrappedMethod.java
Patch:
@@ -44,7 +44,9 @@ public static CtMethod wrapped(CtClass returnType, String mname,
 
         Bytecode code = makeBody(declaring, declaring.getClassFile2(), body,
                                  parameterTypes, returnType, constParam);
-        mt.getMethodInfo2().setCodeAttribute(code.toCodeAttribute());
+        MethodInfo minfo = mt.getMethodInfo2();
+        minfo.setCodeAttribute(code.toCodeAttribute());
+        // a stack map has been already created. 
         return mt;
     }
 

File: src/main/javassist/bytecode/ConstPool.java
Patch:
@@ -174,7 +174,7 @@ public int getTag(int index) {
      * @return  a fully-qualified class or interface name specified
      *          by <code>name_index</code>.  If the type is an array
      *          type, this method returns an encoded name like
-     *          <code>[java.lang.Object;</code> (note that the separators
+     *          <code>[Ljava.lang.Object;</code> (note that the separators
      *          are not slashes but dots).
      * @see javassist.ClassPool#getCtClass(String)
      */

File: src/main/javassist/bytecode/stackmap/BasicBlock.java
Patch:
@@ -274,7 +274,7 @@ else if (op == Opcode.GOTO_W)
                 else if (op == Opcode.JSR_W)
                     makeJsr(marks, index, index + ci.s32bitAt(index + 1), 5);
                 else if (op == Opcode.WIDE && ci.byteAt(index + 1) == Opcode.RET)
-                    makeMark(marks, index, null, 1, true);
+                    makeMark(marks, index, null, 4, true);
             }
 
             if (et != null) {

File: src/main/javassist/bytecode/stackmap/TypeTag.java
Patch:
@@ -19,7 +19,8 @@
 import javassist.bytecode.StackMapTable;
 
 public interface TypeTag {
-    TypeData TOP = null;
+    String TOP_TYPE = "*top*";
+    TypeData TOP = new TypeData.BasicType(TOP_TYPE, StackMapTable.TOP);
     TypeData INTEGER = new TypeData.BasicType("int", StackMapTable.INTEGER);
     TypeData FLOAT = new TypeData.BasicType("float", StackMapTable.FLOAT);
     TypeData DOUBLE = new TypeData.BasicType("double", StackMapTable.DOUBLE);

File: src/test/javassist/JvstTest.java
Patch:
@@ -1110,7 +1110,7 @@ public static Test suite() {
         suite.addTestSuite(JvstTest4.class);
         suite.addTestSuite(LoaderTestByRandall.class);
         suite.addTestSuite(javassist.bytecode.BytecodeTest.class);
-        // suite.addTestSuite(javassist.bytecode.StackMapTest.class);
+        suite.addTestSuite(javassist.bytecode.StackMapTest.class);
         suite.addTestSuite(javassist.compiler.CompTest.class);
         suite.addTestSuite(javassist.SetterTest.class);
         suite.addTestSuite(javassist.bytecode.InsertGap0.class);

File: src/test/javassist/JvstTest4.java
Patch:
@@ -683,9 +683,10 @@ public void testJIRA150b() throws Exception {
             }
         }
         System.gc();
+        System.gc();
         int size = javassist.compiler.MemberResolver.getInvalidMapSize();
         System.out.println("JIRA150b " + size);
-        assertTrue(size < N - 10);
+        assertTrue("JIRA150b size: " + size, size < N - 10);
     }
 
     public void testJIRA152() throws Exception {

File: src/main/javassist/bytecode/SignatureAttribute.java
Patch:
@@ -1066,7 +1066,7 @@ private static ClassType parseClassType2(String sig, Cursor c, ClassType parent)
             targs = null;
 
         ClassType thisClass = ClassType.make(sig, start, end, targs, parent);
-        if (t == '$') {
+        if (t == '$' || t == '.') {
             c.position--;
             return parseClassType2(sig, c, thisClass);
         }

File: src/main/javassist/compiler/TypeChecker.java
Patch:
@@ -899,6 +899,9 @@ public void atClassObject(Expr expr) throws CompileError {
 
     public void atArrayLength(Expr expr) throws CompileError {
         expr.oprand1().accept(this);
+        if (arrayDim == 0)
+            throw new NoFieldException("length", expr);
+
         exprType = INT;
         arrayDim = 0;
     }

File: src/test/javassist/JvstTest.java
Patch:
@@ -1126,6 +1126,9 @@ public static Test suite() {
         suite.addTestSuite(test.javassist.proxy.ProxyFactoryCompatibilityTest.class);
         suite.addTestSuite(test.javassist.proxy.ProxySerializationTest.class);
         suite.addTestSuite(test.javassist.proxy.ProxySimpleTest.class);
+        suite.addTestSuite(test.javassist.bytecode.analysis.AnalyzerTest.class);
+        suite.addTestSuite(test.javassist.convert.ArrayAccessReplaceTest.class);
+        suite.addTestSuite(test.javassist.bytecode.analysis.DomTreeTest.class);
         return suite;
     }
 }

File: src/test/test/javassist/bytecode/analysis/DomTreePrinter.java
Patch:
@@ -20,7 +20,6 @@ public static void main(String[] args) throws Exception {
         Node[] pdom = cf.postDominatorTree();
         for (int i = 0; i < pdom.length; i++)
             System.out.println(i + ": " + pdom[i]);
-
     }
 
     public int dummy(int n, int[] array) {

File: src/main/javassist/CtClass.java
Patch:
@@ -68,7 +68,7 @@ public abstract class CtClass {
     /**
      * The version number of this release.
      */
-    public static final String version = "3.16.1-GA";
+    public static final String version = "3.17.0-GA";
 
     /**
      * Prints the version number and the copyright notice.

File: src/main/javassist/bytecode/analysis/ControlFlow.java
Patch:
@@ -344,7 +344,7 @@ public String toString() {
             StringBuffer sbuf = new StringBuffer();
             sbuf.append("Node[pos=").append(block().position());
             sbuf.append(", parent=");
-            sbuf.append(parent == null ? "*" : parent.block().position());
+            sbuf.append(parent == null ? "*" : Integer.toString(parent.block().position()));
             sbuf.append(", children{");
             for (int i = 0; i < children.length; i++)
                 sbuf.append(children[i].block().position()).append(", ");

File: src/main/javassist/runtime/Desc.java
Patch:
@@ -38,8 +38,7 @@ private static Class getClassObject(String name)
         throws ClassNotFoundException
     {
         if (useContextClassLoader)
-            return Thread.currentThread().getContextClassLoader()
-                   .loadClass(name);
+            return Class.forName(name, true, Thread.currentThread().getContextClassLoader());
         else
             return Class.forName(name);
     }

File: src/main/javassist/CtNewWrappedMethod.java
Patch:
@@ -151,7 +151,7 @@ private static String addBodyMethod(CtClassType clazz,
             int acc = body.getAccessFlags();
             body.setAccessFlags(AccessFlag.setPrivate(acc));
             body.addAttribute(new SyntheticAttribute(classfile.getConstPool()));
-            // a stack map is copied.  rebuilding it is not needed. 
+            // a stack map is copied.  rebuilding it is not needed.
             classfile.addMethod(body);
             bodies.put(src, bodyname);
             CtMember.Cache cache = clazz.hasMemberCache();

File: src/test/javassist/JvstTest4.java
Patch:
@@ -20,8 +20,10 @@ public void testInsertLocalVars() throws Exception {
         
         CtMethod m1 = cc.getDeclaredMethod("run");
         m1.getMethodInfo().getCodeAttribute().insertLocalVar(2, 20);
+        m1.getMethodInfo().rebuildStackMapIf6(cc.getClassPool(), cc.getClassFile());
         CtMethod m2 = cc.getDeclaredMethod("run2");
         m2.getMethodInfo().getCodeAttribute().insertLocalVar(2, 0x101);
+        m2.getMethodInfo().rebuildStackMapIf6(cc.getClassPool(), cc.getClassFile());
 
         cc.writeFile();
         Object obj = make(cc.getName());
@@ -83,6 +85,7 @@ public void edit(MethodCall c) throws CannotCompileException {
                 }
             }
         });
+        // m3.getMethodInfo2().rebuildStackMapIf6(cc.getClassPool(), cc.getClassFile2());
 
         cc.writeFile();
         Object obj = make(cc.getName());

File: src/main/javassist/compiler/MemberCodeGen.java
Patch:
@@ -504,7 +504,6 @@ else if (op == '.') {
                     exprType = CLASS;
                     arrayDim = 0;
                     className = nfe.getField(); // JVM-internal
-                    resolver.recordPackage(className);
                     isStatic = true;
                 }
 
@@ -1078,7 +1077,6 @@ else if (acceptLength && arrayDim > 0
                     Symbol fname = (Symbol)e.oprand2();
                     String cname = nfe.getField();
                     f = resolver.lookupFieldByJvmName2(cname, fname, expr);
-                    resolver.recordPackage(cname);
                     resultStatic = true;
                     return f;
                 }

File: src/main/javassist/bytecode/analysis/ControlFlow.java
Patch:
@@ -271,7 +271,6 @@ protected void toString2(StringBuffer sbuf) {
 
         /**
          * Returns the length of this block.
-         * @return
          */
         public int length() { return length; }
 

File: src/main/javassist/util/proxy/Proxy.java
Patch:
@@ -22,7 +22,7 @@
  * To obtain a handler, call {@link ProxyFactory#getHandler(Proxy)}.
  *
  * @see ProxyFactory
- * @see 3.16
+ * @since 3.16
  */
 public interface Proxy {
     /**

File: src/main/javassist/bytecode/ConstPool.java
Patch:
@@ -1024,7 +1024,6 @@ private int readOne(DataInputStream in) throws IOException {
             break;
         case ClassInfo.tag :                    // 7
             info = new ClassInfo(in, numOfItems);
-            // classes.put(<classname>, info);
             break;
         case StringInfo.tag :                   // 8
             info = new StringInfo(in, numOfItems);

File: src/test/javassist/JvstTest2.java
Patch:
@@ -3,6 +3,8 @@
 import java.io.*;
 import java.net.URL;
 import java.lang.reflect.Method;
+
+import javassist.bytecode.ClassFile;
 import javassist.expr.*;
 
 public class JvstTest2 extends JvstTestRoot {

File: src/test/javassist/JvstTest4.java
Patch:
@@ -122,7 +122,8 @@ public void testRename() throws Exception {
         cc2.rebuildClassFile();
         cc2.writeFile();
         Object obj = make(cc.getName());
-        assertEquals(4, invoke(obj, "run"));
+        assertEquals("test4.Rename2", obj.getClass().getName());
+        assertEquals(14, invoke(obj, "run"));
     }
 
     public void testRename2() throws Exception {

File: src/main/javassist/util/proxy/ProxyObjectOutputStream.java
Patch:
@@ -57,7 +57,7 @@ protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException {
             writeInt(interfaces.length - 1);
             for (int i = 0; i < interfaces.length; i++) {
                 Class interfaze = interfaces[i];
-                if (interfaze != ProxyObject.class) {
+                if (interfaze != ProxyObject.class && interfaze != Proxy.class) {
                     name = interfaces[i].getName();
                     writeObject(name);
                 }

File: src/main/javassist/util/proxy/RuntimeSupport.java
Patch:
@@ -220,6 +220,8 @@ public static SerializedProxy makeSerializedProxy(Object proxy)
         MethodHandler methodHandler = null;
         if (proxy instanceof ProxyObject)
             methodHandler = ((ProxyObject)proxy).getHandler();
+        else if (proxy instanceof Proxy)
+            methodHandler = ProxyFactory.getHandler((Proxy)proxy);
 
         return new SerializedProxy(clazz, ProxyFactory.getFilterSignature(clazz), methodHandler);
     }

File: src/main/javassist/util/proxy/SerializedProxy.java
Patch:
@@ -43,9 +43,10 @@ class SerializedProxy implements Serializable {
         int n = infs.length;
         interfaces = new String[n - 1];
         String setterInf = ProxyObject.class.getName();
+        String setterInf2 = Proxy.class.getName();
         for (int i = 0; i < n; i++) {
             String name = infs[i].getName();
-            if (!name.equals(setterInf))
+            if (!name.equals(setterInf) && !name.equals(setterInf2))
                 interfaces[i] = name;
         }
     }
@@ -81,7 +82,7 @@ Object readResolve() throws ObjectStreamException {
             ProxyFactory f = new ProxyFactory();
             f.setSuperclass(loadClass(superClass));
             f.setInterfaces(infs);
-            ProxyObject proxy = (ProxyObject)f.createClass(filterSignature).newInstance();
+            Proxy proxy = (Proxy)f.createClass(filterSignature).newInstance();
             proxy.setHandler(handler);
             return proxy;
         }

File: src/main/javassist/bytecode/analysis/Executor.java
Patch:
@@ -596,7 +596,7 @@ public void execute(MethodInfo method, int pos, CodeIterator iter, Frame frame,
                 break;
             case CHECKCAST:
                 verifyAssignable(Type.OBJECT, simplePop(frame));
-                frame.push(typeFromDesc(constPool.getClassInfo(iter.u16bitAt(pos + 1))));
+                frame.push(typeFromDesc(constPool.getClassInfoByDescriptor(iter.u16bitAt(pos + 1))));
                 break;
             case INSTANCEOF:
                 verifyAssignable(Type.OBJECT, simplePop(frame));

File: src/main/javassist/compiler/Parser.java
Patch:
@@ -891,7 +891,7 @@ private ASTree parseUnaryExpr(SymbolTable tbl) throws CompileError {
     /* cast.expr : "(" builtin.type ("[" "]")* ")" unary.expr
                  | "(" class.type ("[" "]")* ")" unary.expr2
 
-       unary.expr2 is a unary.expr begining with "(", NULL, StringL,
+       unary.expr2 is a unary.expr beginning with "(", NULL, StringL,
        Identifier, THIS, SUPER, or NEW.
 
        Either "(int.class)" or "(String[].class)" is a not cast expression.

File: src/main/javassist/CtClass.java
Patch:
@@ -428,7 +428,7 @@ public Object get(Object jvmClassName) {
 
                 public void fix(String name) {}
             };
-            cf.renameClass(cm);
+            cf.getRefClasses(cm);
             return cm.values();
         }
         else

File: src/main/javassist/bytecode/AnnotationsAttribute.java
Patch:
@@ -285,6 +285,8 @@ void renameClass(Map classnames) {
         }
     }
 
+    void getRefClasses(Map classnames) { renameClass(classnames); }
+
     /**
      * Returns a string representation of this object.
      */

File: src/main/javassist/bytecode/ParameterAnnotationsAttribute.java
Patch:
@@ -186,6 +186,8 @@ void renameClass(Map classnames) {
         }
     }
 
+    void getRefClasses(Map classnames) { renameClass(classnames); }
+
     /**
      * Returns a string representation of this object.
      */

File: src/main/javassist/CtClass.java
Patch:
@@ -409,6 +409,8 @@ public void replaceClassName(ClassMap map) {
      * That collection includes the name of this class.
      *
      * <p>This method may return <code>null</code>.
+     *
+     * @return a <code>Collection&lt;String&gt;</code> object.
      */
     public synchronized Collection getRefClasses() {
         ClassFile cf = getClassFile2();

File: src/main/javassist/bytecode/AttributeInfo.java
Patch:
@@ -251,8 +251,8 @@ static ArrayList copyAll(ArrayList list, ConstPool cp) {
 
     /* The following two methods are used to implement
      * ClassFile.renameClass().
-     * Only CodeAttribute and LocalVariableAttribute override
-     * this method.
+     * Only CodeAttribute, LocalVariableAttribute, and
+     * AnnotationsAttribute override these methods.
      */
     void renameClass(String oldname, String newname) {}
     void renameClass(Map classnames) {}

File: src/main/javassist/bytecode/ClassFilePrinter.java
Patch:
@@ -111,6 +111,9 @@ static void printAttributes(List list, PrintWriter out, char kind) {
             else if (ai instanceof AnnotationsAttribute) {
                 out.println("annnotation: " + ai.toString());
             }
+            else if (ai instanceof ParameterAnnotationsAttribute) {
+                out.println("parameter annnotations: " + ai.toString());
+            }
             else if (ai instanceof StackMapTable) {
                 out.println("<stack map table begin>");
                 StackMapTable.Printer.print((StackMapTable)ai, out);

File: src/main/javassist/expr/Cast.java
Patch:
@@ -84,7 +84,7 @@ public CtClass[] mayThrow() {
      *
      * <p>$0 is available but the value is <code>null</code>.
      *
-     * @param statement         a Java statement.
+     * @param statement         a Java statement except try-catch.
      */
     public void replace(String statement) throws CannotCompileException {
         thisClass.getClassFile();   // to call checkModify().

File: src/main/javassist/expr/Expr.java
Patch:
@@ -264,15 +264,15 @@ private static void storeStack0(int i, int n, CtClass[] params, int regno,
      * Replaces this expression with the bytecode derived from
      * the given source text.
      *
-     * @param statement         a Java statement.
+     * @param statement         a Java statement except try-catch.
      */
     public abstract void replace(String statement) throws CannotCompileException;
 
     /**
      * Replaces this expression with the bytecode derived from
      * the given source text and <code>ExprEditor</code>.
      *
-     * @param statement         a Java statement.
+     * @param statement         a Java statement except try-catch.
      * @param recursive         if not null, the substituted bytecode
      *                          is recursively processed by the given
      *                          <code>ExprEditor</code>.

File: src/main/javassist/expr/FieldAccess.java
Patch:
@@ -144,7 +144,7 @@ public String getSignature() {
      * If the field access is writing, $_ is available but the value
      * of $_ is ignored.
      *
-     * @param statement         a Java statement.
+     * @param statement         a Java statement except try-catch.
      */
     public void replace(String statement) throws CannotCompileException {
         thisClass.getClassFile();   // to call checkModify().

File: src/main/javassist/expr/Handler.java
Patch:
@@ -92,7 +92,7 @@ public boolean isFinally() {
     /**
      * This method has not been implemented yet.
      *
-     * @param statement         a Java statement.
+     * @param statement         a Java statement except try-catch.
      */
     public void replace(String statement) throws CannotCompileException {
         throw new RuntimeException("not implemented yet");

File: src/main/javassist/expr/Instanceof.java
Patch:
@@ -87,7 +87,7 @@ public CtClass[] mayThrow() {
      *
      * <p>$0 is available but the value is <code>null</code>.
      *
-     * @param statement         a Java statement.
+     * @param statement         a Java statement except try-catch.
      */
     public void replace(String statement) throws CannotCompileException {
         thisClass.getClassFile();   // to call checkModify().

File: src/main/javassist/expr/MethodCall.java
Patch:
@@ -173,7 +173,7 @@ public CtClass getReturnType() throws NotFoundException {
      *
      * <p>$0 is available even if the called method is static.
      *
-     * @param statement         a Java statement.
+     * @param statement         a Java statement except try-catch.
      */
     public void replace(String statement) throws CannotCompileException {
         thisClass.getClassFile();   // to call checkModify().

File: src/main/javassist/expr/NewArray.java
Patch:
@@ -153,7 +153,7 @@ public int getCreatedDimensions() {
      * If the field access is writing, $_ is available but the value
      * of $_ is ignored.
      *
-     * @param statement         a Java statement.
+     * @param statement         a Java statement except try-catch.
      */
     public void replace(String statement) throws CannotCompileException {
         try {

File: src/main/javassist/expr/NewExpr.java
Patch:
@@ -156,7 +156,7 @@ else if (op == Opcode.DUP_X1
      *
      * <p>$0 is available but the value is null.
      *
-     * @param statement         a Java statement.
+     * @param statement         a Java statement except try-catch.
      */
     public void replace(String statement) throws CannotCompileException {
         thisClass.getClassFile();   // to call checkModify().

File: src/main/javassist/bytecode/ClassFileWriter.java
Patch:
@@ -651,8 +651,9 @@ public int addInterfaceMethodrefInfo(int classInfo,
          * @return          the index of the added entry.
          */
         public int addStringInfo(String str) {
+            int utf8 = addUtf8Info(str);
             output.write(StringInfo.tag);
-            output.writeShort(addUtf8Info(str));
+            output.writeShort(utf8);
             return num++;
         }
 

File: src/main/javassist/CtClass.java
Patch:
@@ -766,7 +766,7 @@ public CtConstructor[] getConstructors() {
     public CtConstructor getConstructor(String desc)
         throws NotFoundException
     {
-        throw new NotFoundException("no such a constructor");
+        throw new NotFoundException("no such constructor");
     }
 
     /**

File: src/main/javassist/bytecode/ClassFile.java
Patch:
@@ -580,7 +580,7 @@ public List getMethods() {
      * Returns the method with the specified name. If there are multiple methods
      * with that name, this method returns one of them.
      * 
-     * @return null if no such a method is found.
+     * @return null if no such method is found.
      */
     public MethodInfo getMethod(String name) {
         ArrayList list = methods;

File: src/main/javassist/compiler/JvstCodeGen.java
Patch:
@@ -254,7 +254,7 @@ protected void atCflow(ASTList cname) throws CompileError {
         String name = sbuf.toString();
         Object[] names = resolver.getClassPool().lookupCflow(name);
         if (names == null)
-            throw new CompileError("no such a " + cflowName + ": " + name);
+            throw new CompileError("no such " + cflowName + ": " + name);
 
         bytecode.addGetstatic((String)names[0], (String)names[1],
                               "Ljavassist/runtime/Cflow;");

File: src/main/javassist/compiler/MemberCodeGen.java
Patch:
@@ -590,7 +590,7 @@ private void atMethodCallCore2(CtClass targetClass, String mname,
         if (mname.equals(MethodInfo.nameInit)) {
             isSpecial = true;
             if (declClass != targetClass)
-                throw new CompileError("no such a constructor");
+                throw new CompileError("no such constructor");
 
             if (declClass != thisClass && AccessFlag.isPrivate(acc)) {
                 desc = getAccessibleConstructor(desc, declClass, minfo);

File: src/main/javassist/util/HotSwapper.java
Patch:
@@ -185,7 +185,7 @@ public void reload(Map classFiles) {
     private ReferenceType toRefType(String className) {
         List list = jvm.classesByName(className);
         if (list == null || list.isEmpty())
-            throw new RuntimeException("no such a class: " + className);
+            throw new RuntimeException("no such class: " + className);
         else
             return (ReferenceType)list.get(0);
     }

File: src/main/javassist/Modifier.java
Patch:
@@ -35,6 +35,7 @@ public class Modifier {
     public static final int FINAL     = AccessFlag.FINAL;
     public static final int SYNCHRONIZED = AccessFlag.SYNCHRONIZED;
     public static final int VOLATILE  = AccessFlag.VOLATILE;
+    public static final int VARARGS = AccessFlag.VARARGS;
     public static final int TRANSIENT = AccessFlag.TRANSIENT;
     public static final int NATIVE    = AccessFlag.NATIVE;
     public static final int INTERFACE = AccessFlag.INTERFACE;

File: src/main/javassist/CtField.java
Patch:
@@ -319,6 +319,8 @@ private Object[] getAnnotations(boolean ignoreNotFound) throws ClassNotFoundExce
 
     /**
      * Returns the character string representing the type of the field.
+     * The field signature is represented by a character string
+     * called a field descriptor, which is defined in the JVM specification.
      * If two fields have the same type,
      * <code>getSignature()</code> returns the same string.
      *

File: src/main/javassist/bytecode/analysis/Type.java
Patch:
@@ -206,9 +206,9 @@ public int getDimensions() {
         if (!isArray()) return 0;
 
         String name = clazz.getName();
-        int pos = name.length() - 2;
+        int pos = name.length() - 1;
         int count = 0;
-        while (name.charAt(pos) == '[' ) {
+        while (name.charAt(pos) == ']' ) {
             pos -= 2;
             count++;
         }

File: src/test/test/javassist/proxy/ProxyFactoryCompatibilityTest.java
Patch:
@@ -41,6 +41,7 @@ public Object invoke(Object self, Method m, Method proceed,
 
     public void testFactoryCompatibility() throws Exception
     {
+        System.out.println("ProxyFactory.useCache = " + ProxyFactory.useCache);
         // create a factory which, by default, uses caching
         ProxyFactory factory = new ProxyFactory();
         factory.setSuperclass(TestClass.class);

File: src/main/javassist/ClassPoolTail.java
Patch:
@@ -57,7 +57,7 @@ public URL find(String classname) {
         File f = new File(filename);
         if (f.exists())
             try {
-                return f.getCanonicalFile().toURL();
+                return f.getCanonicalFile().toURI().toURL();
             }
             catch (MalformedURLException e) {}
             catch (IOException e) {}
@@ -127,7 +127,7 @@ final class JarClassPath implements ClassPath {
         try {
             jarfile = new JarFile(pathname);
             jarfileURL = new File(pathname).getCanonicalFile()
-                                           .toURL().toString();
+                                           .toURI().toURL().toString();
             return;
         }
         catch (IOException e) {}

File: src/test/test/javassist/proxy/ProxyCacheGCTest.java
Patch:
@@ -4,6 +4,7 @@
 import javassist.util.proxy.MethodFilter;
 import javassist.util.proxy.MethodHandler;
 import javassist.util.proxy.ProxyFactory;
+import javassist.util.proxy.ProxyObject;
 import junit.framework.TestCase;
 
 /**
@@ -92,13 +93,13 @@ public void createProxy(int counter)
             MethodFilter filter = (MethodFilter)javaFilterClass.newInstance();
 
             // ok, now create a factory and a proxy class and proxy from that factory
-            factory.setHandler(handler);
             factory.setFilter(filter);
             factory.setSuperclass(javaTargetClass);
             // factory.setSuperclass(Object.class);
 
             Class proxyClass = factory.createClass();
             Object target = proxyClass.newInstance();
+            ((ProxyObject)target).setHandler(handler);
         } catch (Exception e) {
             e.printStackTrace();
             fail("cannot create proxy " + e);

File: src/main/javassist/bytecode/AnnotationsAttribute.java
Patch:
@@ -111,7 +111,7 @@ public class AnnotationsAttribute extends AttributeInfo {
     public static final String invisibleTag = "RuntimeInvisibleAnnotations";
 
     /**
-     * Constructs a <code>Runtime(In)VisisbleAnnotations_attribute</code>.
+     * Constructs a <code>Runtime(In)VisibleAnnotations_attribute</code>.
      *
      * @param cp            constant pool
      * @param attrname      attribute name (<code>visibleTag</code> or
@@ -126,7 +126,7 @@ public AnnotationsAttribute(ConstPool cp, String attrname, byte[] info) {
 
     /**
      * Constructs an empty
-     * <code>Runtime(In)VisisbleAnnotations_attribute</code>.
+     * <code>Runtime(In)VisibleAnnotations_attribute</code>.
      * A new annotation can be later added to the created attribute
      * by <code>setAnnotations()</code>.
      *

File: src/main/javassist/bytecode/ParameterAnnotationsAttribute.java
Patch:
@@ -53,7 +53,7 @@ public class ParameterAnnotationsAttribute extends AttributeInfo {
         = "RuntimeInvisibleParameterAnnotations";
     /**
      * Constructs
-     * a <code>Runtime(In)VisisbleParameterAnnotations_attribute</code>.
+     * a <code>Runtime(In)VisibleParameterAnnotations_attribute</code>.
      *
      * @param cp            constant pool
      * @param attrname      attribute name (<code>visibleTag</code> or
@@ -69,7 +69,7 @@ public ParameterAnnotationsAttribute(ConstPool cp, String attrname,
 
     /**
      * Constructs an empty
-     * <code>Runtime(In)VisisbleParameterAnnotations_attribute</code>.
+     * <code>Runtime(In)VisibleParameterAnnotations_attribute</code>.
      * A new annotation can be later added to the created attribute
      * by <code>setAnnotations()</code>.
      *

File: src/main/javassist/CtNewClass.java
Patch:
@@ -103,7 +103,7 @@ public void inheritAllConstructors()
 
         if (n < 1)
             throw new CannotCompileException(
-                        "no public constructor in " + superclazz.getName());
+                        "no inheritable constructor in " + superclazz.getName());
 
     }
 
@@ -117,7 +117,7 @@ private boolean isInheritable(int mod, CtClass superclazz) {
             if (pname == null)
                 return pname2 == null;
             else
-                pname.equals(pname2);
+                return pname.equals(pname2);
         }
 
         return true;

File: src/main/javassist/bytecode/ClassFile.java
Patch:
@@ -240,7 +240,6 @@ public void prune() {
         }
 
         attributes = newAttributes;
-        cp.prune();
         constPool = cp;
     }
 

File: src/main/javassist/CtClass.java
Patch:
@@ -410,7 +410,7 @@ public void replaceClassName(ClassMap map) {
      *
      * <p>This method may return <code>null</code>.
      */
-    public Collection getRefClasses() {
+    public synchronized Collection getRefClasses() {
         ClassFile cf = getClassFile2();
         if (cf != null) {
             ClassMap cm = new ClassMap() {

File: src/main/javassist/bytecode/ExceptionTable.java
Patch:
@@ -153,6 +153,8 @@ public void setHandlerPc(int nth, int value) {
      * Returns <code>catchType</code> of the <i>n</i>-th entry.
      *
      * @param nth               the <i>n</i>-th (&gt;= 0).
+     * @return an index into the <code>constant_pool</code> table,
+     *          or zero if this exception handler is for all exceptions.
      */
     public int catchType(int nth) {
         ExceptionTableEntry e = (ExceptionTableEntry)entries.get(nth);

File: src/main/javassist/bytecode/MethodInfo.java
Patch:
@@ -434,7 +434,7 @@ public int getLineNumber(int pos) {
      * <p>
      * This method modifies a call to <code>super()</code>, which should be
      * at the head of a constructor body, so that a constructor in a different
-     * super class is called. This method does not change actural parameters.
+     * super class is called. This method does not change actual parameters.
      * Hence the new super class must have a constructor with the same signature
      * as the original one.
      * 

File: src/main/javassist/bytecode/InstructionPrinter.java
Patch:
@@ -130,6 +130,7 @@ public static String instructionString(CodeIterator iter, int pos, ConstPool poo
             case NEWARRAY:
                 return opstring + " " + arrayInfo(iter.byteAt(pos + 1));
             case ANEWARRAY:
+            case CHECKCAST:
                 return opstring + " " + classInfo(pool, iter.u16bitAt(pos + 1));
             case WIDE:
                 return wide(iter, pos);

File: src/main/javassist/convert/TransformAccessArrayField.java
Patch:
@@ -32,7 +32,7 @@
  *
  * @author <a href="kabir.khan@jboss.com">Kabir Khan</a>
  * @author Jason T. Greene
- * @version $Revision: 1.6 $
+ * @version $Revision: 1.7 $
  */
 public final class TransformAccessArrayField extends Transformer {
     private final String methodClassname;
@@ -140,6 +140,8 @@ private int replace(ConstPool cp, CodeIterator iterator, int pos,
             }
 
             // The gap may include extra padding
+            // Write a nop in case the padding pushes the instruction forward
+            iterator.writeByte(NOP, pos);
             int gapLength = iterator.insertGap(pos, castType != null ? 5 : 2);
 
             int mi = cp.addClassInfo(methodClassname);

File: src/main/javassist/CtBehavior.java
Patch:
@@ -746,7 +746,7 @@ public void insertAfter(String src, boolean asFinally)
             iterator.append(b.getExceptionTable(), gapPos);
 
             if (asFinally)
-                ca.getExceptionTable().add(0, gapPos, gapPos, 0);
+                ca.getExceptionTable().add(getStartPosOfBody(ca), gapPos, gapPos, 0); 
 
             int gapLen = iterator.getCodeLength() - gapPos - handlerLen;
             int subr = iterator.getCodeLength() - gapLen;

File: src/main/javassist/CtClass.java
Patch:
@@ -52,7 +52,7 @@ public abstract class CtClass {
     /**
      * The version number of this release.
      */
-    public static final String version = "3.8.0.GA";
+    public static final String version = "3.8.1.GA";
 
     /**
      * Prints the version number and the copyright notice.

File: src/main/javassist/expr/Cast.java
Patch:
@@ -65,7 +65,7 @@ public CtClass getType() throws NotFoundException {
         int pos = currentPos;
         int index = iterator.u16bitAt(pos + 1);
         String name = cp.getClassInfo(index);
-        return Descriptor.toCtClass(name, thisClass.getClassPool());
+        return thisClass.getClassPool().getCtClass(name);
     }
 
     /**

File: src/main/javassist/expr/Handler.java
Patch:
@@ -73,7 +73,7 @@ public CtClass[] mayThrow() {
     public CtClass getType() throws NotFoundException {
         ConstPool cp = getConstPool();
         String name = cp.getClassInfo(etable.catchType(index));
-        return Descriptor.toCtClass(name, thisClass.getClassPool());
+        return thisClass.getClassPool().getCtClass(name);
     }
 
     /**

File: src/main/javassist/expr/Instanceof.java
Patch:
@@ -68,7 +68,7 @@ public CtClass getType() throws NotFoundException {
         int pos = currentPos;
         int index = iterator.u16bitAt(pos + 1);
         String name = cp.getClassInfo(index);
-        return Descriptor.toCtClass(name, thisClass.getClassPool());
+        return thisClass.getClassPool().getCtClass(name);
     }
 
     /**

File: src/main/javassist/CtBehavior.java
Patch:
@@ -362,6 +362,7 @@ public void setBody(String src,
             methodInfo.setAccessFlags(methodInfo.getAccessFlags()
                                       & ~AccessFlag.ABSTRACT);
             methodInfo.rebuildStackMapIf6(cc.getClassPool(), cc.getClassFile2());
+            declaringClass.rebuildClassFile();
         }
         catch (CompileError e) {
             throw new CannotCompileException(e);
@@ -396,6 +397,7 @@ static void setBody0(CtClass srcClass, MethodInfo srcInfo,
 
         destInfo.setAccessFlags(destInfo.getAccessFlags()
                                 & ~AccessFlag.ABSTRACT);
+        destClass.rebuildClassFile();
     }
 
     /**

File: src/main/javassist/CtBehavior.java
Patch:
@@ -654,6 +654,7 @@ private void insertBefore(String src, boolean rebuild)
                                         Modifier.isStatic(getModifiers()));
             jv.recordParamNames(ca, nvars);
             jv.recordLocalVariables(ca, 0);
+            jv.recordType(getReturnType0());
             jv.compileStmnt(src);
             Bytecode b = jv.getBytecode();
             int stack = b.getMaxStack();

File: src/main/javassist/compiler/JvstCodeGen.java
Patch:
@@ -95,7 +95,7 @@ else if (name.equals(sigName)) {
         }
         else if (name.equals(dollarTypeName)) {
             if (dollarType == null)
-                throw new CompileError(dollarType + " is not available");
+                throw new CompileError(dollarTypeName + " is not available");
 
             bytecode.addLdc(Descriptor.of(dollarType));
             callGetType("getType");

File: src/main/javassist/bytecode/analysis/Executor.java
Patch:
@@ -282,8 +282,8 @@ public void execute(MethodInfo method, int pos, CodeIterator iter, Frame frame,
                 int insert = end - (opcode - DUP2_X1) - 1;
                 Type type1 = frame.getStack(frame.getTopIndex() - 1);
                 Type type2 = frame.peek();
-                 frame.push(type1);
-                 frame.push(type2);
+                frame.push(type1);
+                frame.push(type2);
                 while (end > insert) {
                     frame.setStack(end, frame.getStack(end - 2));
                     end--;

File: src/main/javassist/bytecode/analysis/MultiType.java
Patch:
@@ -201,11 +201,9 @@ private Map mergeMultiAndSingle(MultiType multi, Type single) {
 
     private boolean inMergeSource(MultiType source) {
         while (source != null) {
-            if (source == this) {
-                System.out.println("INMERGESOURCE!");
+            if (source == this)
                 return true;
 
-            }
             source = source.mergeSource;
         }
 

File: src/main/javassist/CtArray.java
Patch:
@@ -41,7 +41,8 @@ public boolean subtypeOf(CtClass clazz) throws NotFoundException {
 
         String cname = clazz.getName();
         if (cname.equals(javaLangObject)
-            || cname.equals("java.lang.Cloneable"))
+            || cname.equals("java.lang.Cloneable")
+            || cname.equals("java.io.Serializable"))
             return true;
 
         return clazz.isArray()

File: src/main/javassist/bytecode/StackMapTable.java
Patch:
@@ -743,7 +743,7 @@ private void update(int pos, int offsetDelta, int base, int entry) {
                 else if (offsetDelta < 64) {
                     byte[] newinfo = insertGap(info, pos, 2);
                     newinfo[pos] = (byte)entry;
-                    ByteArray.write16bit(newDelta, info, pos + 1);
+                    ByteArray.write16bit(newDelta, newinfo, pos + 1);
                     updatedInfo = newinfo;
                 }
                 else

File: src/main/javassist/ClassMap.java
Patch:
@@ -76,7 +76,7 @@ public void put(CtClass oldname, CtClass newname) {
      * internal form used in the JVM before putting it in
      * the hashtable.
      *
-     * <p>If <code>oldname</code> is equivalent to
+     * <p>If <code>oldname</code> is identical to
      * <code>newname</code>, then this method does not
      * perform anything; it does not record the mapping from
      * <code>oldname</code> to <code>newname</code>.  See

File: src/main/javassist/compiler/AccessorMaker.java
Patch:
@@ -89,7 +89,7 @@ public String getConstructor(CtClass c, String desc, MethodInfo orig)
      * @param accDesc   the descriptor of the accessor method.  The first
      *                  parameter type is <code>clazz</code>.
      *                  If the private method is static,
-     *              <code>accDesc<code> must be equal to <code>desc</code>. 
+     *              <code>accDesc<code> must be identical to <code>desc</code>. 
      *                  
      * @param orig      the method info of the private method.
      * @return

File: src/main/javassist/bytecode/StackMapTable.java
Patch:
@@ -675,6 +675,7 @@ private void printTypeInfo(int tag, int data) {
                 break;
             case THIS :
                 msg = "this";
+                break;
             case OBJECT :
                 msg = "object (cpool_index " + data + ")";
                 break;

File: src/main/javassist/tools/reflect/ClassMetaobject.java
Patch:
@@ -73,7 +73,9 @@ public ClassMetaobject(String[] params)
             javaClass = getClassObject(params[0]);
         }
         catch (ClassNotFoundException e) {
-            javaClass = null;
+            throw new RuntimeException("not found: " + params[0]
+                                       + ", useContextClassLoader: "
+                                       + Boolean.toString(useContextClassLoader), e);
         }
 
         constructors = javaClass.getConstructors();

File: src/main/javassist/bytecode/StackMapTable.java
Patch:
@@ -229,6 +229,7 @@ else if (type < 255)
         public void sameFrame(int pos, int offsetDelta) throws BadBytecode {}
 
         private int sameLocals(int pos, int type) throws BadBytecode {
+            int top = pos;
             int offset;
             if (type < 128)
                 offset = type - 64;
@@ -244,7 +245,7 @@ private int sameLocals(int pos, int type) throws BadBytecode {
                 pos += 2;
             }
 
-            sameLocals(pos, offset, tag, data);
+            sameLocals(top, offset, tag, data);
             return pos + 2;
         }
 

File: src/main/javassist/bytecode/CodeAttribute.java
Patch:
@@ -356,6 +356,8 @@ private static LdcEntry copyCode(byte[] code, int beginPos, int endPos,
                 if (index < 0x100)
                     newcode[i + 1] = (byte)index;
                 else {
+                    newcode[i] = NOP;
+                    newcode[i + 1] = NOP;
                     LdcEntry ldc = new LdcEntry();
                     ldc.where = i;
                     ldc.index = index;

File: src/main/javassist/util/proxy/ProxyFactory.java
Patch:
@@ -586,6 +586,7 @@ private static void addMethodsHolder(ClassFile cf, ConstPool cp,
         finfo.setAccessFlags(AccessFlag.PRIVATE | AccessFlag.STATIC);
         cf.addField(finfo);
         MethodInfo minfo = new MethodInfo(cp, "<clinit>", "()V");
+        minfo.setAccessFlags(AccessFlag.STATIC);
         Bytecode code = new Bytecode(cp, 0, 0);
         code.addIconst(size * 2);
         code.addAnewarray("java.lang.reflect.Method");

File: src/main/javassist/CtNewClass.java
Patch:
@@ -29,12 +29,14 @@ class CtNewClass extends CtClassType {
         super(name, cp);
         wasChanged = true;
         String superName;
-        if (superclass == null)
+        if (isInterface || superclass == null)
             superName = null;
         else
             superName = superclass.getName();
 
         classfile = new ClassFile(isInterface, name, superName);
+        if (isInterface && superclass != null)
+            classfile.setInterfaces(new String[] { superclass.getName() });
 
         setModifiers(Modifier.setPublic(getModifiers()));
         hasConstructor = isInterface;

File: src/main/javassist/CtClassType.java
Patch:
@@ -240,7 +240,7 @@ public synchronized void saveClassFile() {
     }
 
     public synchronized void releaseClassFile() {
-        if (!isModified())
+        if (classfile != null && !isModified() && hasMemberCache() == null)
             classfile = null;
     }
 
@@ -256,7 +256,7 @@ public synchronized void releaseClassFile() {
      * of the CtClasses that have not been recently used
      * if they are unmodified. 
      */
-    private void releaseClassFiles() {
+    public void releaseClassFiles() {
         Enumeration e = classPool.classes.elements();
         while (e.hasMoreElements()) {
             Object obj = e.nextElement();

File: src/main/javassist/expr/Cast.java
Patch:
@@ -87,6 +87,7 @@ public CtClass[] mayThrow() {
      * @param statement         a Java statement.
      */
     public void replace(String statement) throws CannotCompileException {
+        thisClass.getClassFile();   // to call checkModify().
         ConstPool constPool = getConstPool();
         int pos = currentPos;
         int index = iterator.u16bitAt(pos + 1);

File: src/main/javassist/expr/FieldAccess.java
Patch:
@@ -147,6 +147,7 @@ public String getSignature() {
      * @param statement         a Java statement.
      */
     public void replace(String statement) throws CannotCompileException {
+        thisClass.getClassFile();   // to call checkModify().
         ConstPool constPool = getConstPool();
         int pos = currentPos;
         int index = iterator.u16bitAt(pos + 1);

File: src/main/javassist/expr/Instanceof.java
Patch:
@@ -90,6 +90,7 @@ public CtClass[] mayThrow() {
      * @param statement         a Java statement.
      */
     public void replace(String statement) throws CannotCompileException {
+        thisClass.getClassFile();   // to call checkModify().
         ConstPool constPool = getConstPool();
         int pos = currentPos;
         int index = iterator.u16bitAt(pos + 1);

File: src/main/javassist/expr/MethodCall.java
Patch:
@@ -176,6 +176,7 @@ public CtClass getReturnType() throws NotFoundException {
      * @param statement         a Java statement.
      */
     public void replace(String statement) throws CannotCompileException {
+        thisClass.getClassFile();   // to call checkModify().
         ConstPool constPool = getConstPool();
         int pos = currentPos;
         int index = iterator.u16bitAt(pos + 1);

File: src/main/javassist/expr/NewArray.java
Patch:
@@ -170,6 +170,7 @@ private void replace2(String statement)
         throws CompileError, NotFoundException, BadBytecode,
                CannotCompileException
     {
+        thisClass.getClassFile();   // to call checkModify().
         ConstPool constPool = getConstPool();
         int pos = currentPos;
         CtClass retType;

File: src/main/javassist/expr/NewExpr.java
Patch:
@@ -160,6 +160,8 @@ else if (op == Opcode.INVOKESPECIAL)
      * @param statement         a Java statement.
      */
     public void replace(String statement) throws CannotCompileException {
+        thisClass.getClassFile();   // to call checkModify().
+
         final int bytecodeSize = 3;
         int pos = newPos;
 

File: src/main/javassist/CtClass.java
Patch:
@@ -560,6 +560,9 @@ public CtClass getSuperclass() throws NotFoundException {
      * to <code>addInterface()</code>; it appends <code>clazz</code> to
      * the list of the super interfaces extended by that interface.
      * Note that an interface can extend multiple super interfaces.
+     *
+     * @see #replaceClassName(String, String)
+     * @see #replaceClassName(ClassMap)
      */
     public void setSuperclass(CtClass clazz) throws CannotCompileException {
         checkModify();

File: src/main/javassist/bytecode/MethodInfo.java
Patch:
@@ -194,7 +194,7 @@ public String getName() {
      */
     public void setName(String newName) {
         name = constPool.addUtf8Info(newName);
-       cachedName = newName;
+        cachedName = newName;
     }
 
     /**

File: src/main/javassist/CtClassType.java
Patch:
@@ -170,7 +170,6 @@ public ClassFile getClassFile2() {
             return cfile;
 
         if (readCounter++ > READ_THRESHOLD) {
-            getCounter += 2;
             releaseClassFiles();
             readCounter = 0;
         }

File: src/main/javassist/ClassPool.java
Patch:
@@ -111,12 +111,13 @@ public Object run() throws Exception{
      * are called.  The automatic pruning can be turned on/off individually
      * for each <code>CtClass</code> object.
      *
-     * <p>The initial value is true.
+     * <p>The initial value is false.
      *
      * @see CtClass#prune()
      * @see CtClass#stopPruning(boolean)
+     * @see CtClass#detach()
      */
-    public static boolean doPruning = true;
+    public static boolean doPruning = false;
 
     /* releaseUnmodifiedClassFile was introduced for avoiding a bug
        of JBoss AOP.  So the value should be true except for JBoss AOP.

File: src/main/javassist/CtConstructor.java
Patch:
@@ -35,7 +35,6 @@
 public final class CtConstructor extends CtBehavior {
     protected CtConstructor(MethodInfo minfo, CtClass declaring) {
         super(declaring, minfo);
-        next = null;
     }
 
     /**

File: src/main/javassist/CtField.java
Patch:
@@ -97,7 +97,6 @@ private CtField(String typeDesc, String name, CtClass clazz)
         throws CannotCompileException
     {
         super(clazz);
-        next = null;
         ClassFile cf = clazz.getClassFile2();
         if (cf == null)
             throw new CannotCompileException("bad declaring class: "
@@ -109,7 +108,6 @@ private CtField(String typeDesc, String name, CtClass clazz)
     CtField(FieldInfo fi, CtClass clazz) {
         super(clazz);
         fieldInfo = fi;
-        next = null;
     }
 
     /**

File: src/main/javassist/CtNewClass.java
Patch:
@@ -28,7 +28,6 @@ class CtNewClass extends CtClassType {
                boolean isInterface, CtClass superclass) {
         super(name, cp);
         wasChanged = true;
-        eraseCache();
         String superName;
         if (superclass == null)
             superName = null;

File: src/main/javassist/CtNewWrappedMethod.java
Patch:
@@ -152,6 +152,9 @@ private static String addBodyMethod(CtClassType clazz,
             // a stack map is copied.  rebuilding it is not needed. 
             classfile.addMethod(body);
             bodies.put(src, bodyname);
+            CtMember.Cache cache = clazz.hasMemberCache();
+            if (cache != null)
+                cache.addMethod(new CtMethod(body, clazz));
         }
 
         return bodyname;

File: src/main/javassist/CtMethod.java
Patch:
@@ -262,6 +262,7 @@ public void setWrappedBody(CtMethod mbody, ConstParameter constParam)
         methodInfo.setCodeAttribute(cattr);
         methodInfo.setAccessFlags(methodInfo.getAccessFlags()
                                   & ~AccessFlag.ABSTRACT);
+        // rebuilding a stack map table is not needed.
     }
 
     // inner classes

File: src/main/javassist/bytecode/stackmap/TypedBlock.java
Patch:
@@ -7,7 +7,10 @@ public class TypedBlock extends BasicBlock {
     public TypeData[] stackTypes, localsTypes;
 
     // set by a Liveness object.
+    // inputs[i] is true if the i-th variable is used within this block.  
     public boolean[] inputs;
+
+    // working area for Liveness class. 
     public boolean updating;
     public int status;
     public byte[] localsUsage;

File: src/main/javassist/ClassPool.java
Patch:
@@ -584,7 +584,8 @@ public CtMethod getMethod(String classname, String methodname)
      * @see javassist.ByteArrayClassPath
      */
     public CtClass makeClass(InputStream classfile)
-        throws IOException, RuntimeException {
+        throws IOException, RuntimeException
+    {
         classfile = new BufferedInputStream(classfile);
         CtClass clazz = new CtClassType(classfile, this);
         clazz.checkModify();

File: src/main/javassist/bytecode/ClassFileWriter.java
Patch:
@@ -46,7 +46,7 @@ public static void print(ClassFile cf, PrintWriter out) {
             = AccessFlag.toModifier(cf.getAccessFlags()
                                     & ~AccessFlag.SYNCHRONIZED);
         out.println("major: " + cf.major + ", minor: " + cf.minor
-                    + "modifiers: " + Integer.toHexString(cf.getAccessFlags()));
+                    + " modifiers: " + Integer.toHexString(cf.getAccessFlags()));
         out.println(Modifier.toString(mod) + " class "
                     + cf.getName() + " extends " + cf.getSuperclass());
 

File: src/main/javassist/bytecode/stackmap/TypeData.java
Patch:
@@ -263,7 +263,7 @@ else if (oldName.equals(typeName))
                     cache = cp.get(oldName);
     
                 CtClass cache2 = cp.get(typeName);
-                if (cache2.subclassOf(cache)) {
+                if (cache2.subtypeOf(cache)) {
                     cache = cache2;
                     return true;
                 }

File: src/main/javassist/CtClass.java
Patch:
@@ -738,7 +738,7 @@ public CtConstructor getClassInitializer() {
     /**
      * Returns an array containing <code>CtMethod</code> objects
      * representing all the non-private methods of the class.
-     * That array includes pon-private methods inherited from the
+     * That array includes non-private methods inherited from the
      * superclasses.
      */
     public CtMethod[] getMethods() {

File: src/main/javassist/CtClass.java
Patch:
@@ -52,7 +52,7 @@ public abstract class CtClass {
     /**
      * The version number of this release.
      */
-    public static final String version = "3.5GA";
+    public static final String version = "3.6.0BETA";
 
     /**
      * Prints the version number and the copyright notice.
@@ -63,7 +63,7 @@ public abstract class CtClass {
      */
     public static void main(String[] args) {
         System.out.println("Javassist version " + CtClass.version);
-        System.out.println("Copyright (C) 1999-2006 Shigeru Chiba."
+        System.out.println("Copyright (C) 1999-2007 Shigeru Chiba."
                            + " All Rights Reserved.");
     }
 

File: src/main/javassist/CtClassType.java
Patch:
@@ -414,8 +414,7 @@ public void setModifiers(int mod) {
         }
 
         checkModify();
-        int acc = AccessFlag.of(mod) | AccessFlag.SUPER;
-        cf.setAccessFlags(acc);
+        cf.setAccessFlags(AccessFlag.of(mod));
     }
 
     public Object[] getAnnotations() throws ClassNotFoundException {

File: src/main/javassist/bytecode/ClassFileWriter.java
Patch:
@@ -45,7 +45,8 @@ public static void print(ClassFile cf, PrintWriter out) {
         int mod
             = AccessFlag.toModifier(cf.getAccessFlags()
                                     & ~AccessFlag.SYNCHRONIZED);
-        out.println("major: " + cf.major + ", minor: " + cf.minor);
+        out.println("major: " + cf.major + ", minor: " + cf.minor
+                    + "modifiers: " + Integer.toHexString(cf.getAccessFlags()));
         out.println(Modifier.toString(mod) + " class "
                     + cf.getName() + " extends " + cf.getSuperclass());
 

File: src/main/javassist/bytecode/SignatureAttribute.java
Patch:
@@ -442,7 +442,7 @@ public String toString() {
         }
     }
 
-    static class NestedClassType extends ClassType {
+    public static class NestedClassType extends ClassType {
         ClassType parent;
         NestedClassType(String s, int b, int e,
                         TypeArgument[] targs, ClassType p) {

File: src/main/javassist/bytecode/Descriptor.java
Patch:
@@ -550,7 +550,7 @@ private static int toCtClass(ClassPool cp, String desc, int i,
         return i2;
     }
 
-    private static CtClass toPrimitiveClass(char c) {
+    static CtClass toPrimitiveClass(char c) {
         CtClass type = null;
         switch (c) {
         case 'Z' :

File: src/main/javassist/tools/web/Webserver.java
Patch:
@@ -39,7 +39,6 @@ public class Webserver {
     protected Translator translator;
 
     private final static byte[] endofline = { 0x0d, 0x0a };
-    private byte[] filebuffer = new byte[4096];
 
     private final static int typeHtml = 1;
     private final static int typeClass = 2;
@@ -273,6 +272,7 @@ && letUsersSendClassfile(out, filename, len))
         if (file.canRead()) {
             sendHeader(out, file.length(), fileType);
             FileInputStream fin = new FileInputStream(file);
+            byte[] filebuffer = new byte[4096];
             for (;;) {
                 len = fin.read(filebuffer);
                 if (len <= 0)
@@ -293,6 +293,7 @@ && letUsersSendClassfile(out, filename, len))
                 = getClass().getResourceAsStream("/" + urlName);
             if (fin != null) {
                 ByteArrayOutputStream barray = new ByteArrayOutputStream();
+                byte[] filebuffer = new byte[4096];
                 for (;;) {
                     len = fin.read(filebuffer);
                     if (len <= 0)

File: src/main/javassist/bytecode/AttributeInfo.java
Patch:
@@ -96,8 +96,10 @@ else if (nameStr.equals(LocalVariableAttribute.tag)
                      || nameStr.equals(LocalVariableAttribute.typeTag))
                 return new LocalVariableAttribute(cp, name, in);
             else if (nameStr.equals(AnnotationsAttribute.visibleTag)
-                     || nameStr.equals(AnnotationsAttribute.invisibleTag))
+                     || nameStr.equals(AnnotationsAttribute.invisibleTag)) {
+                // RuntimeVisibleAnnotations or RuntimeInvisibleAnnotations
                 return new AnnotationsAttribute(cp, name, in);
+            }
             else if (nameStr.equals(ParameterAnnotationsAttribute.visibleTag)
                 || nameStr.equals(ParameterAnnotationsAttribute.invisibleTag))
                 return new ParameterAnnotationsAttribute(cp, name, in);

File: src/main/javassist/compiler/CodeGen.java
Patch:
@@ -1652,6 +1652,8 @@ protected static int getArrayWriteOp(int type, int dim) {
             return LASTORE;
         case INT :
             return IASTORE;
+        case SHORT :
+            return SASTORE;
         case CHAR :
             return CASTORE;
         case BYTE :

File: src/main/javassist/bytecode/annotation/Annotation.java
Patch:
@@ -289,12 +289,13 @@ public Object toAnnotationType(ClassLoader cl, ClassPool cp)
      * @param writer            the output.
      */
     public void write(AnnotationsWriter writer) throws IOException {
+        String typeName = pool.getUtf8Info(typeIndex);
         if (members == null) {
-            writer.annotation(typeIndex, 0);
+            writer.annotation(typeName, 0);
             return;
         }
 
-        writer.annotation(typeIndex, members.size());
+        writer.annotation(typeName, members.size());
         Iterator it = members.values().iterator();
         while (it.hasNext()) {
             Pair pair = (Pair)it.next();

File: src/main/javassist/bytecode/annotation/ClassMemberValue.java
Patch:
@@ -120,7 +120,7 @@ public String toString() {
      * Writes the value.
      */
     public void write(AnnotationsWriter writer) throws IOException {
-        writer.classInfoIndex(valueIndex);
+        writer.classInfoIndex(cp.getUtf8Info(valueIndex));
     }
 
     /**

File: src/main/javassist/util/proxy/ProxyFactory.java
Patch:
@@ -363,6 +363,8 @@ private void override(String thisClassname, Method meth, String prefix,
         else {
             MethodInfo delegator
                 = makeDelegator(meth, desc, cp, declClass, delegatorName);
+            // delegator is not a bridge method.  See Sec. 15.12.4.5 of JLS 3rd Ed.
+            delegator.setAccessFlags(delegator.getAccessFlags() & ~AccessFlag.BRIDGE);
             cf.addMethod(delegator);
         }
 
@@ -417,8 +419,6 @@ private static boolean makeUniqueName0(String name, Iterator it) {
      * @param mod       the modifiers of the method. 
      */
     private static boolean isVisible(int mod, String from, Member meth) {
-        if ((mod & Modifier.VOLATILE) != 0)
-         return false;
         if ((mod & Modifier.PRIVATE) != 0)
             return false;
         else if ((mod & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0)

File: src/main/javassist/CtBehavior.java
Patch:
@@ -166,7 +166,7 @@ public Object[][] getParameterAnnotations() throws ClassNotFoundException {
         ParameterAnnotationsAttribute ainfo2 = (ParameterAnnotationsAttribute)
                     mi.getAttribute(ParameterAnnotationsAttribute.visibleTag);  
         return CtClassType.toAnnotationType(getDeclaringClass().getClassPool(),
-                                            ainfo, ainfo2);
+                                            ainfo, ainfo2, mi);
     }
 
     /**
@@ -324,7 +324,7 @@ static void setBody0(CtClass srcClass, MethodInfo srcInfo,
      * method returns null.
      *
      * <p>Note that an attribute is a data block specified by
-     * the class file format.
+     * the class file format.  It is not an annotation.
      * See {@link javassist.bytecode.AttributeInfo}.
      *
      * @param name              attribute name
@@ -341,7 +341,7 @@ public byte[] getAttribute(String name) {
      * Adds an attribute. The attribute is saved in the class file.
      *
      * <p>Note that an attribute is a data block specified by
-     * the class file format.
+     * the class file format.  It is not an annotation.
      * See {@link javassist.bytecode.AttributeInfo}.
      *
      * @param name      attribute name

File: src/main/javassist/CtClassType.java
Patch:
@@ -447,7 +447,7 @@ static Object[] toAnnotationType(ClassPool cp, AnnotationsAttribute a1,
     }
 
     static Object[][] toAnnotationType(ClassPool cp, ParameterAnnotationsAttribute a1,
-                                       ParameterAnnotationsAttribute a2)
+                                       ParameterAnnotationsAttribute a2, MethodInfo minfo)
         throws ClassNotFoundException
     {
         int numParameters = 0;
@@ -456,7 +456,7 @@ static Object[][] toAnnotationType(ClassPool cp, ParameterAnnotationsAttribute a
         else if (a2 != null)
             numParameters = a2.numParameters();
         else
-           return new Object[0][];
+            numParameters = Descriptor.numOfParameters(minfo.getDescriptor());
 
         Object[][] result = new Object[numParameters][];
         for (int i = 0; i < numParameters; i++) {

File: src/main/javassist/util/proxy/MethodHandler.java
Patch:
@@ -41,8 +41,8 @@ public interface MethodHandler {
      *                      is a wrapper class.
      * @return              the resulting value of the method invocation.
      *
-     * @throws Exception    if the method invocation fails.
+     * @throws Throwable    if the method invocation fails.
      */
     Object invoke(Object self, Method thisMethod, Method proceed,
-                  Object[] args) throws Exception;
+                  Object[] args) throws Throwable;
 }

File: src/main/javassist/util/proxy/ProxyFactory.java
Patch:
@@ -45,7 +45,7 @@
  * f.setSuperclass(Foo.class);
  * MethodHandler mi = new MethodHandler() {
  *     public Object invoke(Object self, Method m, Method proceed,
- *                          Object[] args) throws Exception {
+ *                          Object[] args) throws Throwable {
  *         System.out.println("Name: " + m.getName());
  *         proceed.invoke(self, args);  // execute the original method.
  *     }

File: src/main/javassist/CtClassType.java
Patch:
@@ -496,7 +496,7 @@ private static Object toAnnoType(Annotation anno, ClassPool cp)
         throws ClassNotFoundException
     {
         try {
-            ClassLoader cl = ClassPool.getContextClassLoader();
+            ClassLoader cl = cp.getClassLoader();
             return anno.toAnnotationType(cl, cp);
         }
         catch (ClassNotFoundException e) {

File: src/main/javassist/CtClass.java
Patch:
@@ -1137,7 +1137,7 @@ public void writeFile()
      * @param directoryName     it must end without a directory separator.
      */
     public void writeFile(String directoryName)
-        throws NotFoundException, CannotCompileException, IOException
+        throws CannotCompileException, IOException
     {
         String classname = getName();
         String filename = directoryName + File.separatorChar

File: src/main/javassist/CtClassType.java
Patch:
@@ -426,8 +426,10 @@ static Object[][] toAnnotationType(ClassPool cp, ParameterAnnotationsAttribute a
         int numParameters = 0;
         if (a1 != null) 
             numParameters = a1.numParameters();
-        else
+        else if (a2 != null)
             numParameters = a2.numParameters();
+        else
+           return new Object[0][];
 
         Object[][] result = new Object[numParameters][];
         ClassLoader cl = Thread.currentThread().getContextClassLoader();

File: src/main/javassist/CtClass.java
Patch:
@@ -437,6 +437,9 @@ public boolean isInterface() {
      * Returns the modifiers for this class, encoded in an integer.
      * For decoding, use <code>javassist.Modifier</code>.
      *
+     * <p>If the class is a static nested class (a.k.a. static inner class),
+     * the returned modifiers include <code>Modifier.STATIC</code>. 
+     *
      * @see Modifier
      */
     public int getModifiers() {

File: src/main/javassist/Modifier.java
Patch:
@@ -40,6 +40,8 @@ public class Modifier {
     public static final int INTERFACE = AccessFlag.INTERFACE;
     public static final int ABSTRACT  = AccessFlag.ABSTRACT;
     public static final int STRICT    = AccessFlag.STRICT;
+    public static final int ANNOTATION = AccessFlag.ANNOTATION;
+    public static final int ENUM      = AccessFlag.ENUM;
 
     /**
      * Returns true if the modifiers include the <tt>public</tt>

File: src/main/javassist/ClassPool.java
Patch:
@@ -582,7 +582,7 @@ public synchronized CtClass makeClass(String classname, CtClass superclass)
     }
 
     /**
-     * Creates a new nested class.
+     * Creates a new public nested class.
      * This method is called by CtClassType.makeNestedClass().
      *
      * @param classname     a fully-qualified class name.

File: src/main/javassist/CtBehavior.java
Patch:
@@ -408,8 +408,9 @@ public void instrument(ExprEditor editor)
      * a constructor in the super class or this class is called.
      * Therefore, the inserted bytecode is subject to constraints described
      * in Section 4.8.2 of The Java Virtual Machine Specification (2nd ed).
-     * For example, it cannot access instance fields or methods
-     * although it can access static fields and methods.
+     * For example, it cannot access instance fields or methods although
+     * it may assign a value to an instance field directly declared in this
+     * class.  Accessing static fields and methods is allowed.
      * Use <code>insertBeforeBody()</code> in <code>CtConstructor</code>.
      *
      * @param src       the source code representing the inserted bytecode.

File: src/main/javassist/bytecode/annotation/AnnotationMemberValue.java
Patch:
@@ -17,6 +17,7 @@
 import javassist.ClassPool;
 import javassist.bytecode.ConstPool;
 import java.io.IOException;
+import java.lang.reflect.Method;
 
 /**
  * Nested annotation.
@@ -43,7 +44,7 @@ public AnnotationMemberValue(Annotation a, ConstPool cp) {
         value = a;
     }
 
-    Object getValue(ClassLoader cl, ClassPool cp)
+    Object getValue(ClassLoader cl, ClassPool cp, Method m)
         throws ClassNotFoundException
     {
         return AnnotationImpl.make(cl, getType(cl), cp, value);

File: src/main/javassist/bytecode/annotation/BooleanMemberValue.java
Patch:
@@ -17,6 +17,7 @@
 import javassist.ClassPool;
 import javassist.bytecode.ConstPool;
 import java.io.IOException;
+import java.lang.reflect.Method;
 
 /**
  * Boolean constant value.
@@ -56,7 +57,7 @@ public BooleanMemberValue(ConstPool cp) {
         setValue(false);
     }
 
-    Object getValue(ClassLoader cl, ClassPool cp) {
+    Object getValue(ClassLoader cl, ClassPool cp, Method m) {
         return new Boolean(getValue());
     }
 

File: src/main/javassist/bytecode/annotation/ByteMemberValue.java
Patch:
@@ -17,6 +17,7 @@
 import javassist.ClassPool;
 import javassist.bytecode.ConstPool;
 import java.io.IOException;
+import java.lang.reflect.Method;
 
 /**
  * Byte constant value.
@@ -56,7 +57,7 @@ public ByteMemberValue(ConstPool cp) {
         setValue((byte)0);
     }
 
-    Object getValue(ClassLoader cl, ClassPool cp) {
+    Object getValue(ClassLoader cl, ClassPool cp, Method m) {
         return new Byte(getValue());
     }
 

File: src/main/javassist/bytecode/annotation/CharMemberValue.java
Patch:
@@ -18,6 +18,7 @@
 import javassist.ClassPool;
 import javassist.bytecode.ConstPool;
 import java.io.IOException;
+import java.lang.reflect.Method;
 
 /**
  * Char constant value.
@@ -57,7 +58,7 @@ public CharMemberValue(ConstPool cp) {
         setValue('\0');
     }
 
-    Object getValue(ClassLoader cl, ClassPool cp) {
+    Object getValue(ClassLoader cl, ClassPool cp, Method m) {
         return new Character(getValue());
     }
 

File: src/main/javassist/bytecode/annotation/ClassMemberValue.java
Patch:
@@ -19,6 +19,7 @@
 import javassist.bytecode.ConstPool;
 import javassist.bytecode.Descriptor;
 import java.io.IOException;
+import java.lang.reflect.Method;
 
 /**
  * Class value.
@@ -59,7 +60,7 @@ public ClassMemberValue(ConstPool cp) {
         setValue("java.lang.Class");
     }
 
-    Object getValue(ClassLoader cl, ClassPool cp)
+    Object getValue(ClassLoader cl, ClassPool cp, Method m)
         throws ClassNotFoundException
     {
         return loadClass(cl, getValue());

File: src/main/javassist/bytecode/annotation/DoubleMemberValue.java
Patch:
@@ -18,13 +18,14 @@
 import javassist.ClassPool;
 import javassist.bytecode.ConstPool;
 import java.io.IOException;
+import java.lang.reflect.Method;
 
 /**
  * Double floating-point number constant value.
  *
  * @author <a href="mailto:bill@jboss.org">Bill Burke</a>
  * @author Shigeru Chiba
- * @version $Revision: 1.6 $
+ * @version $Revision: 1.7 $
  */
 public class DoubleMemberValue extends MemberValue {
     int valueIndex;
@@ -58,7 +59,7 @@ public DoubleMemberValue(ConstPool cp) {
         setValue(0.0);
     }
 
-    Object getValue(ClassLoader cl, ClassPool cp) {
+    Object getValue(ClassLoader cl, ClassPool cp, Method m) {
         return new Double(getValue());
     }
 

File: src/main/javassist/bytecode/annotation/EnumMemberValue.java
Patch:
@@ -16,6 +16,7 @@
 package javassist.bytecode.annotation;
 
 import java.io.IOException;
+import java.lang.reflect.Method;
 
 import javassist.ClassPool;
 import javassist.bytecode.ConstPool;
@@ -54,7 +55,7 @@ public EnumMemberValue(ConstPool cp) {
         typeIndex = valueIndex = 0;
     }
 
-    Object getValue(ClassLoader cl, ClassPool cp)
+    Object getValue(ClassLoader cl, ClassPool cp, Method m)
         throws ClassNotFoundException
     {
         try {

File: src/main/javassist/bytecode/annotation/FloatMemberValue.java
Patch:
@@ -18,13 +18,14 @@
 import javassist.ClassPool;
 import javassist.bytecode.ConstPool;
 import java.io.IOException;
+import java.lang.reflect.Method;
 
 /**
  * Floating-point number constant value.
  *
  * @author <a href="mailto:bill@jboss.org">Bill Burke</a>
  * @author Shigeru Chiba
- * @version $Revision: 1.6 $
+ * @version $Revision: 1.7 $
  */
 public class FloatMemberValue extends MemberValue {
     int valueIndex;
@@ -58,7 +59,7 @@ public FloatMemberValue(ConstPool cp) {
         setValue(0.0F);
     }
 
-    Object getValue(ClassLoader cl, ClassPool cp) {
+    Object getValue(ClassLoader cl, ClassPool cp, Method m) {
         return new Float(getValue());
     }
 

File: src/main/javassist/bytecode/annotation/IntegerMemberValue.java
Patch:
@@ -18,6 +18,7 @@
 import javassist.ClassPool;
 import javassist.bytecode.ConstPool;
 import java.io.IOException;
+import java.lang.reflect.Method;
 
 /**
  * Integer constant value.
@@ -63,7 +64,7 @@ public IntegerMemberValue(ConstPool cp) {
         setValue(0);
     }
 
-    Object getValue(ClassLoader cl, ClassPool cp) {
+    Object getValue(ClassLoader cl, ClassPool cp, Method m) {
         return new Integer(getValue());
     }
 

File: src/main/javassist/bytecode/annotation/LongMemberValue.java
Patch:
@@ -18,6 +18,7 @@
 import javassist.ClassPool;
 import javassist.bytecode.ConstPool;
 import java.io.IOException;
+import java.lang.reflect.Method;
 
 /**
  * Long integer constant value.
@@ -57,7 +58,7 @@ public LongMemberValue(ConstPool cp) {
         setValue(0L);
     }
 
-    Object getValue(ClassLoader cl, ClassPool cp) {
+    Object getValue(ClassLoader cl, ClassPool cp, Method m) {
         return new Long(getValue());
     }
 

File: src/main/javassist/bytecode/annotation/MemberValue.java
Patch:
@@ -18,6 +18,7 @@
 import javassist.ClassPool;
 import javassist.bytecode.ConstPool;
 import java.io.IOException;
+import java.lang.reflect.Method;
 
 /**
  * The value of a member declared in an annotation.
@@ -39,7 +40,7 @@ public abstract class MemberValue {
      * Returns the value.  If the value type is a primitive type, the
      * returned value is boxed.
      */
-    abstract Object getValue(ClassLoader cl, ClassPool cp)
+    abstract Object getValue(ClassLoader cl, ClassPool cp, Method m)
         throws ClassNotFoundException;
 
     abstract Class getType(ClassLoader cl) throws ClassNotFoundException;

File: src/main/javassist/bytecode/annotation/ShortMemberValue.java
Patch:
@@ -18,6 +18,7 @@
 import javassist.ClassPool;
 import javassist.bytecode.ConstPool;
 import java.io.IOException;
+import java.lang.reflect.Method;
 
 /**
  * Short integer constant value.
@@ -57,7 +58,7 @@ public ShortMemberValue(ConstPool cp) {
         setValue((short)0);
     }
 
-    Object getValue(ClassLoader cl, ClassPool cp) {
+    Object getValue(ClassLoader cl, ClassPool cp, Method m) {
         return new Short(getValue());
     }
 

File: src/main/javassist/bytecode/annotation/StringMemberValue.java
Patch:
@@ -18,6 +18,7 @@
 import javassist.ClassPool;
 import javassist.bytecode.ConstPool;
 import java.io.IOException;
+import java.lang.reflect.Method;
 
 /**
  * String constant value.
@@ -57,7 +58,7 @@ public StringMemberValue(ConstPool cp) {
         setValue("");
     }
 
-    Object getValue(ClassLoader cl, ClassPool cp) {
+    Object getValue(ClassLoader cl, ClassPool cp, Method m) {
         return getValue();
     }
 

File: src/main/javassist/expr/NewExpr.java
Patch:
@@ -125,6 +125,8 @@ private int canReplace() throws CannotCompileException {
         else if (op == Opcode.DUP_X1
                  && iterator.byteAt(newPos + 4) == Opcode.SWAP)
             return 5;
+        else if (op == Opcode.INVOKESPECIAL)
+            return 3;   // for Eclipse's compiler
         else
             throw new CannotCompileException(
                         "sorry, cannot edit NEW followed by no DUP");

File: src/main/javassist/compiler/MemberCodeGen.java
Patch:
@@ -489,8 +489,8 @@ public void atMethodCallCore(CtClass targetClass, String mname,
         int count = bytecode.getStackDepth() - stack + 1;
 
         if (found == null)
-            found = resolver.lookupMethod(targetClass, thisMethod, mname,
-                                          types, dims, cnames, false);
+            found = resolver.lookupMethod(targetClass, thisClass, thisMethod,
+                                          mname, types, dims, cnames);
 
         if (found == null) {
             String msg;

File: src/main/javassist/compiler/TypeChecker.java
Patch:
@@ -652,8 +652,8 @@ public MemberResolver.Method atMethodCallCore(CtClass targetClass,
         atMethodArgs(args, types, dims, cnames);
 
         MemberResolver.Method found
-            = resolver.lookupMethod(targetClass, thisMethod, mname,
-                                    types, dims, cnames, false);
+            = resolver.lookupMethod(targetClass, thisClass, thisMethod,
+                                    mname, types, dims, cnames);
         if (found == null) {
             String msg;
             if (mname.equals(MethodInfo.nameInit))

File: src/main/javassist/CtNewConstructor.java
Patch:
@@ -30,6 +30,7 @@
  * initializer obtained by <code>makeClassInitializer()</code>.
  *
  * @see CtClass#addConstructor(CtConstructor)
+ * @see CtClass#makeClassInitializer()
  */
 public class CtNewConstructor {
     /**

File: src/main/javassist/bytecode/annotation/MemberValue.java
Patch:
@@ -21,6 +21,7 @@
 /**
  * The value of a member declared in an annotation.
  *
+ * @see Annotation#getMemberValue(String)
  * @author <a href="mailto:bill@jboss.org">Bill Burke</a>
  * @author Shigeru Chiba
  */

File: src/main/javassist/bytecode/annotation/MemberValueVisitor.java
Patch:
@@ -18,6 +18,7 @@
 /**
  * Visitor for traversing member values included in an annotation.
  *
+ * @see MemberValue#accept(MemberValueVisitor)
  * @author <a href="mailto:bill@jboss.org">Bill Burke</a>
  */
 public interface MemberValueVisitor {

File: src/main/javassist/bytecode/annotation/Annotation.java
Patch:
@@ -34,6 +34,9 @@
  *
  * @see javassist.bytecode.AnnotationsAttribute#getAnnotations()
  * @see javassist.bytecode.ParameterAnnotationsAttribute#getAnnotations()
+ * @see MemberValue
+ * @see MemberValueVisitor
+ * @see AnnotationsWriter
  *
  * @author <a href="mailto:bill@jboss.org">Bill Burke</a>
  * @author Shigeru Chiba

File: src/main/javassist/bytecode/ClassFile.java
Patch:
@@ -373,6 +373,7 @@ public final void renameClass(Map classnames) {
 
     /**
      * Returns the names of the interfaces implemented by the class.
+     * The returned array is read only.
      */
     public String[] getInterfaces() {
         if (cachedInterfaces != null)

File: src/main/javassist/bytecode/FieldInfo.java
Patch:
@@ -100,13 +100,13 @@ void prune(ConstPool cp) {
             newAttributes.add(visibleAnnotations);
         }
 
-        attribute = newAttributes;
         int index = getConstantValue();
         if (index != 0) {
             index = constPool.copy(index, cp, null);
-            attribute.add(new ConstantAttribute(cp, index));
+            newAttributes.add(new ConstantAttribute(cp, index));
         }
 
+        attribute = newAttributes;
         name = cp.addUtf8Info(getName());
         descriptor = cp.addUtf8Info(getDescriptor());
         constPool = cp;

File: src/main/javassist/bytecode/annotation/EnumMemberValue.java
Patch:
@@ -15,9 +15,9 @@
 
 package javassist.bytecode.annotation;
 
+import java.io.IOException;
 import javassist.bytecode.ConstPool;
 import javassist.bytecode.Descriptor;
-import java.io.IOException;
 
 /**
  * Enum constant value.
@@ -92,7 +92,7 @@ public String toString() {
      * Writes the value.
      */
     public void write(AnnotationsWriter writer) throws IOException {
-        writer.enumConstValue(getType(), getValue());
+        writer.enumConstValue(cp.getUtf8Info(typeIndex), getValue());
     }
 
     /**

File: src/main/javassist/bytecode/AttributeInfo.java
Patch:
@@ -72,7 +72,9 @@ static AttributeInfo read(ConstPool cp, DataInputStream in)
         int name = in.readUnsignedShort();
         String nameStr = cp.getUtf8Info(name);
         if (nameStr.charAt(0) < 'L') {
-            if (nameStr.equals(CodeAttribute.tag))
+            if (nameStr.equals(AnnotationDefaultAttribute.tag))
+                return new AnnotationDefaultAttribute(cp, name, in);
+            else if (nameStr.equals(CodeAttribute.tag))
                 return new CodeAttribute(cp, name, in);
             else if (nameStr.equals(ConstantAttribute.tag))
                 return new ConstantAttribute(cp, name, in);

File: src/main/javassist/CtClass.java
Patch:
@@ -44,7 +44,7 @@ public abstract class CtClass {
     /**
      * The version number of this release.
      */
-    public static final String version = "3.0";
+    public static final String version = "3.1";
 
     /**
      * Prints the version number and the copyright notice.

File: src/main/javassist/CtClass.java
Patch:
@@ -956,7 +956,7 @@ public void instrument(ExprEditor editor)
      * in <code>ClassPool</code>.
      *
      * @see #toClass(java.lang.ClassLoader)
-     * @see ClassPool#toClass(java.lang.ClassLoader)
+     * @see ClassPool#toClass(CtClass)
      */
     public Class toClass() throws CannotCompileException {
         return getClassPool().toClass(this);

File: src/main/javassist/ClassPool.java
Patch:
@@ -248,6 +248,9 @@ public CtClass getAndRename(String orgName, String newName)
         throws NotFoundException
     {
         CtClass clazz = get0(orgName, false);
+        if (clazz == null)
+            throw new NotFoundException(orgName);
+
         if (clazz instanceof CtClassType)
             ((CtClassType)clazz).setClassPool(this);
 

File: src/main/javassist/CtConstructor.java
Patch:
@@ -180,7 +180,7 @@ public String getName() {
         if (methodInfo.isStaticInitializer())
             return MethodInfo.nameClinit;
         else
-            return declaringClass.getName();
+            return declaringClass.getSimpleName();
     }
 
     /**

File: src/main/javassist/CtClassType.java
Patch:
@@ -666,7 +666,7 @@ private static void getMethods0(HashMap h, CtClass cc) {
             CtMethod cm = ((CtClassType)cc).getMethodsCache();
             while (cm != null) {
                 if (Modifier.isPublic(cm.getModifiers()))
-                    h.put(cm, cm);
+                    h.put(cm.getStringRep(), cm);
 
                 cm = cm.next;
             }

File: src/main/javassist/bytecode/ClassFile.java
Patch:
@@ -452,7 +452,7 @@ private void testExistingMethod(String name, String descriptor)
         while (it.hasNext()) {
             MethodInfo minfo = (MethodInfo)it.next();
             if (minfo.getName().equals(name)
-                && Descriptor.eqSignature(minfo.getDescriptor(), descriptor))
+                && Descriptor.eqParamTypes(minfo.getDescriptor(), descriptor))
                 throw new CannotCompileException("duplicate method: " + name);
         }
     }

File: src/main/javassist/CannotCompileException.java
Patch:
@@ -41,7 +41,7 @@ public CannotCompileException(String msg) {
     /**
      * Constructs a CannotCompileException with an <code>Exception</code>.
      */
-    public CannotCompileException(Exception e) {
+    public CannotCompileException(Throwable e) {
         super("by " + e.toString());
         message = null;
     }

File: src/main/javassist/bytecode/FieldInfo.java
Patch:
@@ -120,6 +120,8 @@ public void setDescriptor(String desc) {
 
     /**
      * Returns all the attributes.
+     * A new element can be added to the returned list
+     * and an existing element can be removed from the list.
      *
      * @return a list of <code>AttributeInfo</code> objects.
      * @see AttributeInfo

File: src/main/javassist/bytecode/MethodInfo.java
Patch:
@@ -178,6 +178,8 @@ public void setDescriptor(String desc) {
 
     /**
      * Returns all the attributes.
+     * A new element can be added to the returned list
+     * and an existing element can be removed from the list.
      *
      * @return a list of <code>AttributeInfo</code> objects.
      * @see AttributeInfo

File: src/main/javassist/ClassPath.java
Patch:
@@ -23,7 +23,7 @@
  * representing a class search path.
  * <code>ClassPool</code> uses those objects for reading class files.
  *
- * <code>The users can define a class implementing this interface so that
+ * <p>The users can define a class implementing this interface so that
  * a class file is obtained from a non-standard source.
  *
  * @see ClassPool#insertClassPath(ClassPath)
@@ -42,7 +42,6 @@ public interface ClassPath {
      * so that the search will be terminated.
      *
      * <p>This method should not modify the contents of the class file.
-     * Use <code>javassist.Translator</code> for modification.
      *
      * @param classname         a fully-qualified class name
      * @return          the input stream for reading a class file

File: src/main/javassist/CtClass.java
Patch:
@@ -843,7 +843,7 @@ public void instrument(ExprEditor editor)
      *
      * @return the <code>Class</code> object representing the loaded class.  
      * @see CtClass#forName(String)
-     * @see ClassPool.SimpleClassLoader
+     * @see ClassPool.SimpleLoader
      * @see Loader
      */
     public Class toClass()
@@ -859,7 +859,7 @@ public Class toClass()
      * been loaded by an internal class loader of Javassist.
      *
      * @see CtClass#toClass()
-     * @see ClassPool.SimpleClassLoader
+     * @see ClassPool.SimpleLoader
      */
     public static Class forName(String name) throws ClassNotFoundException {
         return ClassPool.forName(name);

File: src/main/javassist/reflect/Compiler.java
Patch:
@@ -122,9 +122,8 @@ private static void processClasses(CompiledClass[] entries, int n)
         }
 
         for (int i = 0; i < n; ++i) {
-            CtClass c = pool.get(entries[i].classname);
-            implementor.onWrite(pool, c);
-            c.writeFile();
+            implementor.onLoad(pool, entries[i].classname);
+            pool.get(entries[i].classname).writeFile();
         }
     }
 

File: src/main/javassist/reflect/Reflection.java
Patch:
@@ -91,7 +91,7 @@ public Reflection() {
     }
 
     /**
-     * Initializes.
+     * Initializes the object.
      */
     public void start(ClassPool pool) throws NotFoundException {
         classPool = pool;
@@ -115,9 +115,10 @@ public void start(ClassPool pool) throws NotFoundException {
      * Inserts hooks for intercepting accesses to the fields declared
      * in reflective classes.
      */
-    public void onWrite(ClassPool pool, CtClass clazz)
+    public void onLoad(ClassPool pool, String classname)
         throws CannotCompileException, NotFoundException
     {
+        CtClass clazz = pool.get(classname);
         clazz.instrument(converter);
     }
 

File: src/main/javassist/web/Webserver.java
Patch:
@@ -337,10 +337,10 @@ private boolean letUsersSendClassfile(OutputStream out,
         String classname
             = filename.substring(0, length - 6).replace('/', '.');
         try {
-            CtClass c = classPool.get(classname);
             if (translator != null)
-                translator.onWrite(classPool, c);
+                translator.onLoad(classPool, classname);
 
+            CtClass c = classPool.get(classname);
             classfile = c.toBytecode();
             if (debugDir != null)
                 c.writeFile(debugDir);

File: src/main/javassist/ClassPool.java
Patch:
@@ -680,7 +680,7 @@ private synchronized CtClass get0(String classname)
         return clazz;
     }
 
-    private CtClass get1(String classname) throws NotFoundException {
+    protected CtClass get1(String classname) throws NotFoundException {
         if (classname.endsWith("[]")) {
             String base = classname.substring(0, classname.indexOf('['));
             if (getCached(base) == null && find(base) == null)

File: src/main/javassist/CtNewWrappedMethod.java
Patch:
@@ -139,7 +139,6 @@ private static String addBodyMethod(CtClassType clazz,
             do {
                 bodyname = addedWrappedMethod + clazz.getUniqueNumber();
             } while (classfile.getMethod(bodyname) != null);
-
             ClassMap map = new ClassMap();
             map.put(src.getDeclaringClass().getName(), clazz.getName());
             MethodInfo body = new MethodInfo(classfile.getConstPool(),

File: src/main/javassist/bytecode/ClassFile.java
Patch:
@@ -350,7 +350,7 @@ private void testExistingField(String name, String descriptor)
         while (it.hasNext()) {
             FieldInfo minfo = (FieldInfo)it.next();
             if (minfo.getName().equals(name))
-                throw new CannotCompileException("duplicated field: " + name);
+                throw new CannotCompileException("duplicate field: " + name);
         }
     }
 
@@ -408,7 +408,7 @@ private void testExistingMethod(String name, String descriptor)
             MethodInfo minfo = (MethodInfo)it.next();
             if (minfo.getName().equals(name)
                 && Descriptor.eqSignature(minfo.getDescriptor(), descriptor))
-                throw new CannotCompileException("duplicated method: " + name);
+                throw new CannotCompileException("duplicate method: " + name);
         }
     }
 

File: src/main/javassist/compiler/MemberResolver.java
Patch:
@@ -176,6 +176,9 @@ else if (n >= nArgs)
             if (argTypes[n] == NULL) {
                 if (dim == 0 && c != 'L')
                     return NO;
+
+                if (c == 'L')
+                    i = desc.indexOf(';', i) + 1;
             }
             else if (argDims[n] != dim) {
                 if (!(dim == 0 && c == 'L'

File: src/main/javassist/ByteArrayClassPath.java
Patch:
@@ -43,6 +43,7 @@
  * @see javassist.ClassPath
  * @see ClassPool#insertClassPath(ClassPath)
  * @see ClassPool#appendClassPath(ClassPath)
+ * @see ClassPool#makeClass(InputStream)
  */
 public class ByteArrayClassPath implements ClassPath {
     protected String classname;

File: src/main/javassist/ClassPool.java
Patch:
@@ -662,6 +662,7 @@ public CtMethod getMethod(String classname, String methodname)
      * @param classfile         class file.
      * @exception RuntimeException      if there is a frozen class with the
      *                                  the same name.
+     * @see javassist.ByteArrayClassPath
      */
     public CtClass makeClass(InputStream classfile)
         throws IOException, RuntimeException

File: src/main/javassist/CtBehavior.java
Patch:
@@ -109,6 +109,8 @@ public String getSignature() {
 
     /**
      * Obtains exceptions that this method/constructor may throw.
+     *
+     * @return a zero-length array if there is no throws clause.
      */
     public CtClass[] getExceptionTypes() throws NotFoundException {
         String[] exceptions;
@@ -126,7 +128,7 @@ public CtClass[] getExceptionTypes() throws NotFoundException {
      */
     public void setExceptionTypes(CtClass[] types) throws NotFoundException {
         declaringClass.checkModify();
-        if (types == null) {
+        if (types == null || types.length == 0) {
             methodInfo.removeExceptionsAttribute();
             return;
         }

File: src/main/javassist/CtClass.java
Patch:
@@ -321,7 +321,7 @@ public void setName(String name) {
      * @param oldName           replaced class name
      * @param newName           substituted class name
      */
-    public void replaceClassName(String oldname, String newname) {
+    public void replaceClassName(String oldName, String newName) {
         checkModify();
     }
 
@@ -538,7 +538,6 @@ public CtConstructor[] getConstructors() {
      * For details of the method descriptor, see the JVM specification
      * or <code>javassist.bytecode.Descriptor</code>.
      *
-     * @param name      method name
      * @param desc      method descriptor
      * @see javassist.bytecode.Descriptor
      */

File: src/main/javassist/CtNewConstructor.java
Patch:
@@ -79,8 +79,6 @@ public static CtConstructor make(String src, CtClass declaring)
     /**
      * Creates a public constructor.
      *
-     * @param returnType        the type of the returned value.
-     * @param mname             the method name.
      * @param parameters        a list of the parameter types.
      * @param exceptions        a list of the exception types.
      * @param body              the source text of the constructor body.

File: src/main/javassist/CtNewMethod.java
Patch:
@@ -409,8 +409,8 @@ private static CtMethod delegator0(CtMethod delegate, CtClass declaring)
      *
      * @param returnType        the type of the returned value.
      * @param mname             the method name.
-     * @param parameters        a list of the parameter types.
-     * @param exceptions        a list of the exception types.
+     * @param parameterTypes    a list of the parameter types.
+     * @param exceptionTypes    a list of the exception types.
      * @param body              the method body
      *                          (must not be a static method).
      * @param constParam        the constant parameter

File: src/main/javassist/Dump.java
Patch:
@@ -36,7 +36,7 @@ private Dump() {}
     /**
      * Main method.
      *
-     * @param args[0]           class file name.
+     * @param args           <code>args[0]</code> is the class file name.
      */
     public static void main(String[] args) throws Exception {
         if (args.length != 1) {

File: src/main/javassist/bytecode/CodeIterator.java
Patch:
@@ -496,7 +496,7 @@ public int append(byte[] code) {
     /**
      * Appends a gap at the end of the bytecode sequence.
      *
-     * @param length            gap length
+     * @param gapLength            gap length
      */
     public void appendGap(int gapLength) {
         byte[] code = bytecode;

File: src/main/javassist/bytecode/ConstPool.java
Patch:
@@ -684,7 +684,7 @@ public int addFieldrefInfo(int classInfo, String name, String type) {
      * Adds a new <code>CONSTANT_Fieldref_info</code> structure.
      *
      * @param classInfo         <code>class_index</code>
-     * @param nameandtypeinfo   <code>name_and_type_index</code>.
+     * @param nameAndTypeInfo   <code>name_and_type_index</code>.
      * @return          the index of the added entry.
      */
     public int addFieldrefInfo(int classInfo, int nameAndTypeInfo) {
@@ -713,7 +713,7 @@ public int addMethodrefInfo(int classInfo, String name, String type) {
      * Adds a new <code>CONSTANT_Methodref_info</code> structure.
      *
      * @param classInfo         <code>class_index</code>
-     * @param nameandtypeinfo   <code>name_and_type_index</code>.
+     * @param nameAndTypeInfo   <code>name_and_type_index</code>.
      * @return          the index of the added entry.
      */
     public int addMethodrefInfo(int classInfo, int nameAndTypeInfo) {
@@ -745,7 +745,7 @@ public int addInterfaceMethodrefInfo(int classInfo, String name,
      * structure.
      *
      * @param classInfo         <code>class_index</code>
-     * @param nameandtypeinfo   <code>name_and_type_index</code>.
+     * @param nameAndTypeInfo   <code>name_and_type_index</code>.
      * @return          the index of the added entry.
      */
     public int addInterfaceMethodrefInfo(int classInfo,

File: src/main/javassist/bytecode/DeprecatedAttribute.java
Patch:
@@ -38,7 +38,6 @@ public class DeprecatedAttribute extends AttributeInfo {
      * Constructs a Deprecated attribute.
      *
      * @param cp                a constant pool table.
-     * @param filename          the name of the source file.
      */
     public DeprecatedAttribute(ConstPool cp) {
         super(cp, tag, new byte[0]);

File: src/main/javassist/bytecode/SyntheticAttribute.java
Patch:
@@ -38,7 +38,6 @@ public class SyntheticAttribute extends AttributeInfo {
      * Constructs a Synthetic attribute.
      *
      * @param cp                a constant pool table.
-     * @param filename          the name of the source file.
      */
     public SyntheticAttribute(ConstPool cp) {
         super(cp, tag, new byte[0]);

File: src/main/javassist/rmi/AppletServer.java
Patch:
@@ -99,7 +99,7 @@ public void run() {
      * the proxy class and call a method on the exported object.
      *
      * @param name      the name used for looking the object up.
-     * @param object    the exported object.
+     * @param obj       the exported object.
      * @return          the object identifier
      *
      * @see javassist.rmi.ObjectImporter#lookupObject(String)

File: src/main/javassist/compiler/TypeChecker.java
Patch:
@@ -669,7 +669,7 @@ private void atPlusPlus(int token, ASTree oprand, Expr expr)
             if (oprand instanceof Expr) {
                 Expr e = (Expr)oprand;
                 if (e.getOperator() == ARRAY) {
-                    atArrayRead(expr.oprand1(), expr.oprand2());
+                    atArrayRead(e.oprand1(), e.oprand2());
                     // arrayDim should be 0.
                     int t = exprType;
                     if (t == INT || t == BYTE || t == CHAR || t == SHORT)

File: src/main/javassist/ClassPool.java
Patch:
@@ -571,6 +571,9 @@ public CtClass getAndRename(String orgName, String newName)
      * <p>If <code>classname</code> ends with "[]", then this method
      * returns a <code>CtClass</code> object for that array type.
      *
+     * <p>To obtain an inner class, use "$" instead of "." for separating
+     * the enclosing class name and the inner class name.
+     *
      * @param classname         a fully-qualified class name.
      */
     public synchronized CtClass get(String classname)

File: src/main/javassist/CtClass.java
Patch:
@@ -35,7 +35,7 @@ public abstract class CtClass {
     /**
      * The version number of this release.
      */
-    public static final String version = "2.7 beta 4";
+    public static final String version = "2.7 alpha 5";
 
     /**
      * Prints the version number and the copyright notice.

File: src/main/javassist/ClassPool.java
Patch:
@@ -537,7 +537,7 @@ synchronized void classNameChanged(String oldname, CtClass clazz) {
     void checkNotFrozen(String classname, String errmsg)
         throws RuntimeException
     {
-        CtClass c = (CtClass)classes.get(classname);
+        CtClass c = getCached(classname);
         if (c != null && c.isFrozen())
             throw new RuntimeException(errmsg);
     }
@@ -576,7 +576,7 @@ public CtClass getAndRename(String orgName, String newName)
     public synchronized CtClass get(String classname)
         throws NotFoundException
     {
-        CtClass clazz = (CtClass)classes.get(classname);
+        CtClass clazz = getCached(classname);
         if (clazz == null) {
             clazz = get0(classname);
             classes.put(classname, clazz);

File: src/main/javassist/ClassPoolTail.java
Patch:
@@ -171,9 +171,7 @@ public CtClass makeClass(String classname) {
         throw new RuntimeException("fatal error");
     }
 
-    void checkClassName(String classname)
-        throws NotFoundException
-    {
+    void checkClassName(String classname) throws NotFoundException {
         InputStream fin = openClassfile(classname);
         try {
             fin.close();

File: src/main/javassist/URLClassPath.java
Patch:
@@ -61,6 +61,8 @@ public String toString() {
 
     /**
      * Opens a class file with http.
+     *
+     * @return null if the class file is not found. 
      */
     public InputStream openClassfile(String classname) {
         try {

File: src/main/javassist/compiler/Parser.java
Patch:
@@ -852,7 +852,7 @@ private ASTree parseUnaryExpr(SymbolTable tbl) throws CompileError {
         case '!' :
         case '~' :
             t = lex.get();
-            return new Expr(t, parseUnaryExpr(tbl));
+            return Expr.make(t, parseUnaryExpr(tbl));
         case '(' :
             return parseCast(tbl);
         default :
@@ -1051,7 +1051,7 @@ else if (expr instanceof Expr) {
                 throw new SyntaxError(lex);
         }
 
-        return Expr.make(CALL, expr, parseArgumentList(tbl));
+        return CallExpr.makeCall(expr, parseArgumentList(tbl));
     }
 
     private String toClassName(ASTree name)

File: src/main/javassist/compiler/ProceedHandler.java
Patch:
@@ -25,6 +25,6 @@
  * @see javassist.compiler.JvstCodeGen#atMethodCall(Expr)
  */
 public interface ProceedHandler {
-    void doit(JvstCodeGen gen, Bytecode b, ASTList args)
-        throws CompileError;
+    void doit(JvstCodeGen gen, Bytecode b, ASTList args) throws CompileError;
+    void setReturnType(JvstTypeChecker c, ASTList args) throws CompileError;
 }

File: src/main/javassist/compiler/ast/AssignExpr.java
Patch:
@@ -25,7 +25,7 @@ public class AssignExpr extends Expr {
      * =, %=, &=, *=, +=, -=, /=, ^=, |=, <<=, >>=, >>>=
      */
 
-    public AssignExpr(int op, ASTree _head, ASTList _tail) {
+    private AssignExpr(int op, ASTree _head, ASTList _tail) {
         super(op, _head, _tail);
     }
 

File: src/main/javassist/compiler/ast/Visitor.java
Patch:
@@ -35,6 +35,7 @@ public void atAssignExpr(AssignExpr n) throws CompileError {}
     public void atCondExpr(CondExpr n) throws CompileError {}
     public void atBinExpr(BinExpr n) throws CompileError {}
     public void atExpr(Expr n) throws CompileError {}
+    public void atCallExpr(CallExpr n) throws CompileError {}
     public void atCastExpr(CastExpr n) throws CompileError {}
     public void atInstanceOfExpr(InstanceOfExpr n) throws CompileError {}
     public void atNewExpr(NewExpr n) throws CompileError {}

File: src/main/javassist/CtClassType.java
Patch:
@@ -20,7 +20,6 @@
 import javassist.compiler.CompileError;
 import javassist.expr.ExprEditor;
 import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
 import java.io.InputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;

File: src/main/javassist/bytecode/AttributeInfo.java
Patch:
@@ -81,6 +81,8 @@ else if (nameStr.equals(SourceFileAttribute.tag))
             return new SourceFileAttribute(cp, name, in);
         else if (nameStr.equals(LineNumberAttribute.tag))
             return new LineNumberAttribute(cp, name, in);
+        else if (nameStr.equals(LocalVariableAttribute.tag))
+            return new LocalVariableAttribute(cp, name, in);
         else if (nameStr.equals(SyntheticAttribute.tag))
             return new SyntheticAttribute(cp, name, in);
         else if (nameStr.equals(DeprecatedAttribute.tag))

File: src/main/javassist/bytecode/Bytecode.java
Patch:
@@ -15,9 +15,6 @@
 
 package javassist.bytecode;
 
-import java.io.DataOutputStream;
-import java.io.IOException;
-import javassist.CannotCompileException;
 import javassist.CtClass;
 import javassist.CtPrimitiveType;
 

File: src/main/javassist/bytecode/CodeAttribute.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.List;
 import java.util.LinkedList;
 import java.util.Map;
-import javassist.CtClass;
 
 /**
  * <code>Code_attribute</code>.

File: src/main/javassist/bytecode/ExceptionsAttribute.java
Patch:
@@ -161,7 +161,7 @@ public void setExceptions(String[] elist) {
     /**
      * Returns <code>number_of_exceptions</code>.
      */
-    public int length() { return info.length / 2 - 1; }
+    public int tableLength() { return info.length / 2 - 1; }
 
     /**
      * Returns the value of <code>exception_index_table[nth]</code>.

File: src/main/javassist/bytecode/FieldInfo.java
Patch:
@@ -18,7 +18,6 @@
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
-import java.util.Hashtable;
 import java.util.List;
 import java.util.LinkedList;
 

File: src/main/javassist/bytecode/InnerClassesAttribute.java
Patch:
@@ -41,7 +41,7 @@ private InnerClassesAttribute(ConstPool cp, byte[] info) {
     /**
      * Returns <code>number_of_classes</code>.
      */
-    public int length() { return ByteArray.readU16bit(get(), 0); }
+    public int tableLength() { return ByteArray.readU16bit(get(), 0); }
 
     /**
      * Returns <code>classes[nth].inner_class_info_index</code>.

File: src/main/javassist/bytecode/LineNumberAttribute.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Map;
 
 /**
- * <code>LineNumberTablec_attribute</code>.
+ * <code>LineNumberTable_attribute</code>.
  */
 public class LineNumberAttribute extends AttributeInfo {
     /**

File: src/main/javassist/bytecode/MethodInfo.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.Map;
 import java.util.List;
 import java.util.LinkedList;
-import javassist.CannotCompileException;
 
 /**
  * <code>method_info</code> structure.

File: src/main/javassist/compiler/Javac.java
Patch:
@@ -23,7 +23,6 @@
 import javassist.CtMethod;
 import javassist.CtConstructor;
 import javassist.CannotCompileException;
-import javassist.ClassPool;
 import javassist.Modifier;
 import javassist.bytecode.Bytecode;
 import javassist.bytecode.Opcode;
@@ -120,7 +119,7 @@ private CtField compileField(FieldDecl fd)
         Declarator d = fd.getDeclarator();
         f = new CtFieldWithInit(gen.lookupClass(d), d.getVariable().get(),
                                 gen.getThisClass());
-        f.setModifiers(gen.getModifiers(fd.getModifiers()));
+        f.setModifiers(MemberCodeGen.getModifiers(fd.getModifiers()));
         if (fd.getInit() != null)
             f.setInit(fd.getInit());
 
@@ -130,7 +129,7 @@ private CtField compileField(FieldDecl fd)
     private CtMember compileMethod(Parser p, MethodDecl md)
         throws CompileError
     {
-        int mod = gen.getModifiers(md.getModifiers());
+        int mod = MemberCodeGen.getModifiers(md.getModifiers());
         CtClass[] plist = gen.makeParamList(md);
         CtClass[] tlist = gen.makeThrowsList(md);
         recordParams(plist, Modifier.isStatic(mod));

File: src/main/javassist/compiler/ast/Declarator.java
Patch:
@@ -60,7 +60,7 @@ public Declarator make(Symbol sym, int dim, ASTree init) {
         Declarator d = new Declarator(this.varType, this.arrayDim + dim);
         d.qualifiedClass = this.qualifiedClass;
         d.setLeft(sym);
-        d.append(d, init);
+        append(d, init);
         return d;
     }
 

File: src/main/javassist/convert/TransformAfter.java
Patch:
@@ -15,11 +15,9 @@
 
 package javassist.convert;
 
-import javassist.CtClass;
 import javassist.CtMethod;
 import javassist.NotFoundException;
 import javassist.bytecode.*;
-import javassist.CannotCompileException;
 
 public class TransformAfter extends TransformBefore {
     public TransformAfter(Transformer next,

File: src/main/javassist/convert/TransformBefore.java
Patch:
@@ -19,7 +19,6 @@
 import javassist.CtMethod;
 import javassist.NotFoundException;
 import javassist.bytecode.*;
-import javassist.CannotCompileException;
 
 public class TransformBefore extends TransformCall {
     protected CtClass[] parameterTypes;

File: src/main/javassist/convert/TransformCall.java
Patch:
@@ -18,7 +18,6 @@
 import javassist.CtClass;
 import javassist.CtMethod;
 import javassist.bytecode.*;
-import javassist.CannotCompileException;
 
 public class TransformCall extends Transformer {
     protected String classname, methodname, methodDescriptor;

File: src/main/javassist/convert/TransformFieldAccess.java
Patch:
@@ -19,7 +19,6 @@
 import javassist.CtClass;
 import javassist.CtField;
 import javassist.Modifier;
-import javassist.CannotCompileException;
 
 final public class TransformFieldAccess extends Transformer {
     private String newClassname, newFieldname;

File: src/main/javassist/convert/TransformReadField.java
Patch:
@@ -19,7 +19,6 @@
 import javassist.ClassPool;
 import javassist.CtClass;
 import javassist.CtField;
-import javassist.CannotCompileException;
 import javassist.NotFoundException;
 import javassist.Modifier;
 

File: src/main/javassist/convert/TransformWriteField.java
Patch:
@@ -18,7 +18,6 @@
 import javassist.CtClass;
 import javassist.CtField;
 import javassist.bytecode.*;
-import javassist.CannotCompileException;
 
 final public class TransformWriteField extends TransformReadField {
     public TransformWriteField(Transformer next, CtField field,

File: src/main/javassist/expr/Handler.java
Patch:
@@ -18,7 +18,6 @@
 import javassist.*;
 import javassist.bytecode.*;
 import javassist.compiler.*;
-import javassist.compiler.ast.ASTList;
 
 /**
  * Catch clause.

File: src/main/javassist/expr/NewExpr.java
Patch:
@@ -18,7 +18,6 @@
 import javassist.*;
 import javassist.bytecode.*;
 import javassist.compiler.*;
-import javassist.compiler.ast.ASTree;
 import javassist.compiler.ast.ASTList;
 
 /**

File: src/main/javassist/reflect/ClassMetaobject.java
Patch:
@@ -20,7 +20,6 @@
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
-import javassist.CtClass;
 
 /**
  * A runtime class metaobject.

File: src/main/javassist/reflect/Reflection.java
Patch:
@@ -16,7 +16,6 @@
 package javassist.reflect;
 
 import javassist.*;
-import java.io.IOException;
 import javassist.CtMethod.ConstParameter;
 
 /**

File: src/main/javassist/rmi/ObjectImporter.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.io.*;
 import java.net.*;
-import java.awt.*;
 import java.applet.Applet;
 import java.lang.reflect.*;
 

File: src/main/javassist/rmi/StubGenerator.java
Patch:
@@ -15,7 +15,6 @@
 
 package javassist.rmi;
 
-import java.io.*;
 import javassist.*;
 import java.lang.reflect.Method;
 import java.util.Hashtable;

File: src/main/javassist/web/Webserver.java
Patch:
@@ -17,10 +17,8 @@
 
 import java.net.*;
 import java.io.*;
-import java.util.Hashtable;
 import java.util.Date;
 import javassist.ClassPool;
-import javassist.Translator;
 
 /**
  * A web server for Javassist.

File: src/main/javassist/CtClass.java
Patch:
@@ -420,8 +420,8 @@ public void setSuperclass(CtClass clazz) throws CannotCompileException {
     }
 
     /**
-     * Obtains the class objects representing the interfaces of the
-     * class.
+     * Obtains the class objects representing the interfaces implemented
+     * by the class.
      */
     public CtClass[] getInterfaces() throws NotFoundException {
         return new CtClass[0];

File: src/main/javassist/CtField.java
Patch:
@@ -198,6 +198,7 @@ public String getName() {
      * Changes the name of the field.
      */
     public void setName(String newName) {
+        declaringClass.checkModify();
         fieldInfo.setName(newName);
     }
 
@@ -216,6 +217,7 @@ public int getModifiers() {
      * @see Modifier
      */
     public void setModifiers(int mod) {
+        declaringClass.checkModify();
         fieldInfo.setAccessFlags(AccessFlag.of(mod));
     }
 

File: src/main/javassist/bytecode/CodeIterator.java
Patch:
@@ -123,6 +123,8 @@ public void write32bit(int value, int index) {
 
     /**
      * Writes a byte array at the index.
+     *
+     * @param code	may be a zero-length array.
      */
     public void write(byte[] code, int index) {
         int len = code.length;

File: src/main/javassist/ClassPool.java
Patch:
@@ -372,9 +372,9 @@ public Class loadClass(String name, byte[] classfile)
 
     /**
      * Returns a <code>java.lang.Class</code> object that has been loaded
-     * by <code>writeAsClass()</code>.  Note that such an object cannot be
+     * by <code>writeAsClass()</code>.  That object cannot be
      * obtained by <code>java.lang.Class.forName()</code> because it has
-     * been loaded by an internal class loader.
+     * been loaded by an internal class loader of Javassist.
      *
      * @see #writeAsClass(String)
      * @see javassist.CtClass#toClass()

File: src/main/javassist/Loader.java
Patch:
@@ -80,7 +80,7 @@
  * Loader cl = new Loader(cp);
  *
  * CtClass ct = cp.get("test.Rectangle");
- * ct.setSuperclass(loader.get("test.Point"));
+ * ct.setSuperclass(cp.get("test.Point"));
  *
  * Class c = cl.loadClass("test.Rectangle");
  * Object rect = c.newInstance();</pre></ul>

File: src/main/javassist/ClassPool.java
Patch:
@@ -91,6 +91,7 @@ protected CtClass getCached(String classname)
     {
         return (CtClass)classes.get(classname); 
     }
+
     /**
      * Creates a class pool.
      *

File: src/main/javassist/CtNewMethod.java
Patch:
@@ -307,12 +307,12 @@ private static CtMethod delegator0(CtMethod delegate, CtClass declaring)
         CtClass[] params = delegate.getParameterTypes();
         int s;
         if (isStatic) {
-            s = code.addLoadParameters(params);
+            s = code.addLoadParameters(params, 0);
             code.addInvokestatic(deleClass, methodName, desc);
         }
         else {
             code.addLoad(0, deleClass);
-            s = code.addLoadParameters(params);
+            s = code.addLoadParameters(params, 1);
             code.addInvokespecial(deleClass, methodName, desc);
         }
 

File: src/main/javassist/CtNewWrappedConstructor.java
Patch:
@@ -63,7 +63,7 @@ protected static Bytecode makeBody(CtClass declaring, ClassFile classfile,
             code.addInvokespecial(superclazz, "<init>", "()V");
         }
         else if (howToCallSuper == PASS_PARAMS) {
-            stacksize = code.addLoadParameters(parameters) + 1;
+            stacksize = code.addLoadParameters(parameters, 1) + 1;
             code.addInvokespecial(superclazz, "<init>",
                                   Descriptor.ofConstructor(parameters));
         }

File: src/main/javassist/CtClass.java
Patch:
@@ -35,7 +35,7 @@ public abstract class CtClass {
     /**
      * The version number of this release.
      */
-    public static final String version = "2.5";
+    public static final String version = "2.5.1";
 
     static final String javaLangObject = "java.lang.Object";
 

File: src/main/javassist/compiler/Javac.java
Patch:
@@ -170,6 +170,8 @@ private CtMember compileMethod(Parser p, MethodDecl md)
 
     /**
      * Compiles a method (or constructor) body.
+     *
+     * @src	a single statement or a block.
      */
     public Bytecode compileBody(CtBehavior method, String src)
         throws CompileError

File: src/main/javassist/expr/MethodCall.java
Patch:
@@ -131,7 +131,7 @@ public CtClass[] mayThrow() {
      * Returns true if the called method is of a superclass of the current
      * class.
      */
-    boolean isSuper() {
+    public boolean isSuper() {
         return iterator.byteAt(currentPos) == INVOKESPECIAL
             && !where().getDeclaringClass().getName().equals(getClassName());
     }

File: src/main/javassist/expr/Expr.java
Patch:
@@ -22,9 +22,9 @@
 import java.util.Iterator;
 
 /**
- * Caller-side expression.
+ * Expression.
  */
-abstract class Expr implements Opcode {
+public abstract class Expr implements Opcode {
     int currentPos;
     CodeIterator iterator;
     CtClass thisClass;

File: src/main/javassist/CtClass.java
Patch:
@@ -225,7 +225,7 @@ public CtClass getComponentType() throws NotFoundException {
     /**
      * Returns <code>true</code> if this class extends or implements
      * <code>clazz</code>.  It also returns <code>true</code> if
-     * this class is the same as <code>clazz<code>.
+     * this class is the same as <code>clazz</code>.
      */
     public boolean subtypeOf(CtClass clazz) throws NotFoundException {
         return this == clazz || getName().equals(clazz.getName());

