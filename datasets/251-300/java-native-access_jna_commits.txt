File: contrib/platform/src/com/sun/jna/platform/unix/solaris/Kstat2.java
Patch:
@@ -272,10 +272,10 @@ public Kstat2NV mapGet(String name) {
          *         {@link Kstat2Map} is returned.
          *         <p>
          *         If the value is of type {@link Kstat2#KSTAT2_NVVT_INT}, a
-         *         {@link long} is returned.
+         *         {@code long} is returned.
          *         <p>
          *         If the value is of type {@link Kstat2#KSTAT2_NVVT_INTS}, an array of
-         *         {@link long} is returned.
+         *         {@code long} is returned.
          *         <p>
          *         If the value is of type {@link Kstat2#KSTAT2_NVVT_STR}, a
          *         {@link String} is returned.

File: contrib/platform/src/com/sun/jna/platform/unix/solaris/Kstat2.java
Patch:
@@ -272,10 +272,10 @@ public Kstat2NV mapGet(String name) {
          *         {@link Kstat2Map} is returned.
          *         <p>
          *         If the value is of type {@link Kstat2#KSTAT2_NVVT_INT}, a
-         *         {@link long} is returned.
+         *         {@code long} is returned.
          *         <p>
          *         If the value is of type {@link Kstat2#KSTAT2_NVVT_INTS}, an array of
-         *         {@link long} is returned.
+         *         {@code long} is returned.
          *         <p>
          *         If the value is of type {@link Kstat2#KSTAT2_NVVT_STR}, a
          *         {@link String} is returned.

File: contrib/platform/src/com/sun/jna/platform/win32/GDI32.java
Patch:
@@ -322,7 +322,7 @@ HBITMAP CreateDIBSection(HDC hDC, BITMAPINFO pbmi, int iUsage,
      */
     int GetDeviceCaps(HDC hdc, int nIndex);
 
-    /** The GetDIBits function retrieves the bits fo the specified compatible
+    /** The GetDIBits function retrieves the bits of the specified compatible
      * bitmap and copies them into a buffer as a DIB using the specified
      * format.
      * @param hdc A handle to the device context.

File: contrib/platform/src/com/sun/jna/platform/win32/GDI32.java
Patch:
@@ -322,7 +322,7 @@ HBITMAP CreateDIBSection(HDC hDC, BITMAPINFO pbmi, int iUsage,
      */
     int GetDeviceCaps(HDC hdc, int nIndex);
 
-    /** The GetDIBits function retrieves the bits fo the specified compatible
+    /** The GetDIBits function retrieves the bits of the specified compatible
      * bitmap and copies them into a buffer as a DIB using the specified
      * format.
      * @param hdc A handle to the device context.

File: contrib/platform/test/com/sun/jna/platform/win32/Crypt32Test.java
Patch:
@@ -468,7 +468,6 @@ private void enumerateRootCertificates(HCERTSTORE hCertStore) {
                 assertNotNull(ctx.pCertInfo.Subject);
                 assertFalse(decodeName(ctx.pCertInfo.Issuer).isEmpty());
                 assertFalse(decodeName(ctx.pCertInfo.Subject).isEmpty());
-                assertEquals(decodeName(ctx.pCertInfo.Issuer), decodeName(ctx.pCertInfo.Subject));
                 // System.out.printf("%20s: %s%n", "Issuer", decodeName(ctx.pCertInfo.Issuer));
                 // System.out.printf("%20s: %s%n", "Subject", decodeName(ctx.pCertInfo.Subject));
                 readCertificates++;

File: contrib/platform/test/com/sun/jna/platform/win32/Win32ServiceDemo.java
Patch:
@@ -122,7 +122,7 @@ public static boolean install() {
             }
         }
 
-        String JAVA_HOME = System.getenv("JAVA_HOME");
+        String JAVA_HOME = System.getProperty("java.home", System.getenv("JAVA_HOME"));
         String javaBinary = "java.exe";
         if(JAVA_HOME != null) {
             javaBinary = "\"" + new File(JAVA_HOME, "\\bin\\java.exe").getAbsolutePath() + "\"";

File: contrib/platform/test/com/sun/jna/platform/win32/Win32ServiceDemo.java
Patch:
@@ -122,7 +122,7 @@ public static boolean install() {
             }
         }
 
-        String JAVA_HOME = System.getenv("JAVA_HOME");
+        String JAVA_HOME = System.getProperty("java.home", System.getenv("JAVA_HOME"));
         String javaBinary = "java.exe";
         if(JAVA_HOME != null) {
             javaBinary = "\"" + new File(JAVA_HOME, "\\bin\\java.exe").getAbsolutePath() + "\"";

File: src/com/sun/jna/Function.java
Patch:
@@ -245,7 +245,7 @@ public static Function getFunction(Pointer p, int callFlags, String encoding) {
         this.library = library;
         this.functionName = functionName;
         this.callFlags = callFlags;
-        this.options = library.options;
+        this.options = library.getOptions();
         this.encoding = encoding != null ? encoding : Native.getDefaultStringEncoding();
         try {
             this.peer = library.getSymbolAddress(functionName);

File: src/com/sun/jna/Function.java
Patch:
@@ -561,7 +561,7 @@ private Object convertArgument(Object[] args, int index,
             // than in native code so that the values will be valid until
             // this method returns.
             // Convert String to native pointer (const)
-            return new NativeString((String)arg, false).getPointer();
+            return new NativeString((String)arg, encoding).getPointer();
         } else if (arg instanceof WString) {
             // Convert WString to native pointer (const)
             return new NativeString(arg.toString(), true).getPointer();

File: src/com/sun/jna/Function.java
Patch:
@@ -561,7 +561,7 @@ private Object convertArgument(Object[] args, int index,
             // than in native code so that the values will be valid until
             // this method returns.
             // Convert String to native pointer (const)
-            return new NativeString((String)arg, false).getPointer();
+            return new NativeString((String)arg, encoding).getPointer();
         } else if (arg instanceof WString) {
             // Convert WString to native pointer (const)
             return new NativeString(arg.toString(), true).getPointer();

File: contrib/platform/src/com/sun/jna/platform/win32/OpenGL32Util.java
Patch:
@@ -41,7 +41,7 @@ public abstract class OpenGL32Util {
      * @return the function
      */
     public static Function wglGetProcAddress(String procName) {
-        Pointer funcPointer = OpenGL32.INSTANCE.wglGetProcAddress("wglEnumGpusNV");
+        Pointer funcPointer = OpenGL32.INSTANCE.wglGetProcAddress(procName);
         return (funcPointer == null) ? null : Function.getFunction(funcPointer);
     }
 

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/ProxyObject.java
Patch:
@@ -189,7 +189,7 @@ public boolean equals(Object arg) {
     @Override
     public int hashCode() {
         long id = this.getUnknownId();
-        return (int) ((id >>> 32) & 0xFFFFFFFF) + (int) (id & 0xFFFFFFFF);
+        return (int) ((id >>> 32) + (id & 0xFFFFFFFFL));
     }
 
     @Override

File: src/com/sun/jna/Pointer.java
Patch:
@@ -60,7 +60,7 @@ public static final Pointer createConstant(long peer) {
         systems.
      */
     public static final Pointer createConstant(int peer) {
-        return new Opaque((long)peer & 0xFFFFFFFF);
+        return new Opaque(peer & 0xFFFFFFFFL);
     }
 
     /** Pointer value of the real native pointer. Use long to be 64-bit safe.
@@ -112,7 +112,7 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return (int)((peer >>> 32) + (peer & 0xFFFFFFFF));
+        return (int) ((peer >>> 32) + (peer & 0xFFFFFFFFL));
     }
 
 

File: test/com/sun/jna/DirectStructureByValueTest.java
Patch:
@@ -36,6 +36,7 @@ public static class DirectTestLibrary implements TestLibrary {
         public native int testStructureByValueArgument32(ByValue32 arg);
         public native long testStructureByValueArgument64(ByValue64 arg);
         public native long testStructureByValueArgument128(ByValue128 arg);
+        public native DemoStructureDifferentArrayLengths.ByValue returnLastElementOfComponentsDSDAL(DemoStructureDifferentArrayLengths.ByValue arg, int debug);
         static {
             Native.register("testlib");
         }

File: contrib/platform/test/com/sun/jna/platform/mac/XAttrUtilTest.java
Patch:
@@ -157,7 +157,7 @@ public void testReadAlignedCliTool() throws IOException {
 
     public void testWriteAlignedCliTool() throws IOException, InterruptedException {
         Process p = Runtime.getRuntime().exec(new String[] {"xattr", "-w", "JNA", "Java Native Access", testPath});
-        assertTrue(p.waitFor(30, TimeUnit.SECONDS));
+        assertTrue("Wait for CLI xattr call timed out", p.waitFor(60, TimeUnit.SECONDS));
         String resultString = XAttrUtil.getXAttr(testPath, "JNA");
         assertEquals("Java Native Access", resultString);
     }

File: contrib/platform/test/com/sun/jna/platform/mac/IOKitTest.java
Patch:
@@ -30,6 +30,7 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeTrue;
 
 import java.util.HashSet;
 import java.util.Set;
@@ -166,8 +167,7 @@ public void testIteratorParentChild() {
 
             // Get device name
             String controllerName = controllerDevice.getName();
-            // Root controllers always begin with "AppleUSB"
-            assertEquals("AppleUSB", controllerName.substring(0, 8));
+            assertNotNull(controllerName);
 
             // Get the first child, to test vs. iterator
             boolean testFirstChild = true;
@@ -177,7 +177,6 @@ public void testIteratorParentChild() {
             IOIterator childIter = controllerDevice.getChildIterator(IO_SERVICE);
             IORegistryEntry childDevice = childIter.next();
             while (childDevice != null) {
-                assertTrue(childDevice.conformsTo("IOUSBDevice"));
                 long childId = childDevice.getRegistryEntryID();
                 assertTrue(childId > 19);
                 assertFalse(uniqueEntryIdSet.contains(childId));

File: contrib/platform/test/com/sun/jna/platform/mac/IOKitTest.java
Patch:
@@ -30,6 +30,7 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeTrue;
 
 import java.util.HashSet;
 import java.util.Set;
@@ -166,8 +167,7 @@ public void testIteratorParentChild() {
 
             // Get device name
             String controllerName = controllerDevice.getName();
-            // Root controllers always begin with "AppleUSB"
-            assertEquals("AppleUSB", controllerName.substring(0, 8));
+            assertNotNull(controllerName);
 
             // Get the first child, to test vs. iterator
             boolean testFirstChild = true;
@@ -177,7 +177,6 @@ public void testIteratorParentChild() {
             IOIterator childIter = controllerDevice.getChildIterator(IO_SERVICE);
             IORegistryEntry childDevice = childIter.next();
             while (childDevice != null) {
-                assertTrue(childDevice.conformsTo("IOUSBDevice"));
                 long childId = childDevice.getRegistryEntryID();
                 assertTrue(childId > 19);
                 assertFalse(uniqueEntryIdSet.contains(childId));

File: contrib/platform/test/com/sun/jna/platform/mac/CoreFoundationTest.java
Patch:
@@ -209,6 +209,7 @@ public void testCFDictionary() {
         CFStringRef oneStr = CFStringRef.createCFString("one");
 
         // Key does not exist, returns null
+        assertEquals(0L, dict.getCount());
         assertFalse(dict.getValueIfPresent(oneStr, null));
         Pointer cfNull = dict.getValue(oneStr);
         assertNull(cfNull);
@@ -223,6 +224,7 @@ public void testCFDictionary() {
         IntByReference one = new IntByReference(1);
         CFNumberRef cfOne = CF.CFNumberCreate(null, CFNumberType.kCFNumberIntType.typeIndex(), one);
         dict.setValue(oneStr, cfOne);
+        assertEquals(1L, dict.getCount());
 
         assertTrue(dict.getValueIfPresent(oneStr, null));
         Pointer result = dict.getValue(oneStr);
@@ -240,6 +242,7 @@ public void testCFDictionary() {
         result = dict.getValue(onePtr);
         CFStringRef strRef = new CFStringRef(result);
         assertEquals("one", strRef.stringValue());
+        assertEquals(2L, dict.getCount());
 
         oneStr.release();
         cfOne.release();

File: contrib/platform/src/com/sun/jna/platform/unix/X11.java
Patch:
@@ -606,7 +606,7 @@ class XSetWindowAttributes extends Structure {
     int XK_a = 0x61;
     int XK_z = 0x7a;
     int XK_Shift_L = 0xffe1;
-    int XK_Shift_R = 0xffe1;
+    int XK_Shift_R = 0xffe2;
     int XK_Control_L = 0xffe3;
     int XK_Control_R = 0xffe4;
     int XK_CapsLock = 0xffe5;

File: contrib/platform/src/com/sun/jna/platform/unix/X11.java
Patch:
@@ -606,7 +606,7 @@ class XSetWindowAttributes extends Structure {
     int XK_a = 0x61;
     int XK_z = 0x7a;
     int XK_Shift_L = 0xffe1;
-    int XK_Shift_R = 0xffe1;
+    int XK_Shift_R = 0xffe2;
     int XK_Control_L = 0xffe3;
     int XK_Control_R = 0xffe4;
     int XK_CapsLock = 0xffe5;

File: contrib/platform/src/com/sun/jna/platform/mac/CoreFoundation.java
Patch:
@@ -303,7 +303,7 @@ public boolean booleanValue() {
      * <p>
      * CFArray is “toll-free bridged” with its Cocoa Foundation counterpart,
      * {@code NSArray}. Therefore, in a method where you see an {@code NSArray *}
-     * parameter, you can pass in a {@link #CFArrayRef}.
+     * parameter, you can pass in a {@code CFArrayRef} .
      */
     class CFArrayRef extends CFTypeRef {
         public CFArrayRef() {

File: contrib/platform/src/com/sun/jna/platform/mac/IOKit.java
Patch:
@@ -763,7 +763,7 @@ CFTypeRef IORegistryEntrySearchCFProperty(IORegistryEntry entry, String plane, C
      * @param connect
      *            An {@code io_connect_t} handle is returned on success, to be used
      *            with the IOConnectXXX APIs. It should be destroyed with
-     *            {@link IOServiceClose}.
+     *            {@link #IOServiceClose}.
      * @return A return code generated by {@code IOService::newUserClient}.
      */
     int IOServiceOpen(IOService service, int owningTask, int type, PointerByReference connect);
@@ -828,7 +828,7 @@ CFTypeRef IORegistryEntrySearchCFProperty(IORegistryEntry entry, String plane, C
      *         <p>
      *         Caller should NOT release the returned CFDictionary - it will be
      *         released as part of the {@link CFTypeRef} returned by
-     *         {@link IOPSCopyPowerSourcesInfo}.
+     *         {@link #IOPSCopyPowerSourcesInfo}.
      */
     CFDictionaryRef IOPSGetPowerSourceDescription(CFTypeRef blob, CFTypeRef ps);
 

File: contrib/platform/src/com/sun/jna/platform/win32/Advapi32Util.java
Patch:
@@ -966,7 +966,7 @@ public static String[] registryGetStringArray(HKEY hKey, String value) {
 
     /**
      * Convert the null-delimited buffer of strings returned from registry values of
-     * type {@link WinNT.REG_MULTI_SZ} to an array of strings.
+     * type {@link WinNT#REG_MULTI_SZ} to an array of strings.
      *
      * @param data
      *            A buffer containing strings delimited by a null character, ending

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32.java
Patch:
@@ -2787,7 +2787,7 @@ boolean SystemTimeToTzSpecificLocalTime(TIME_ZONE_INFORMATION lpTimeZone,
 
     /**
      * @deprecated Use
-     *             {@link #CreateRemoteThread(com.sun.jna.platform.win32.WinNT.HANDLE, com.sun.jna.platform.win32.WinBase.SECURITY_ATTRIBUTES, int, com.sun.jna.Pointer, com.sun.jna.Pointer, int, com.sun.jna.platform.win32.WinDef.DWORDByReference)
+     *             {@link #CreateRemoteThread(com.sun.jna.platform.win32.WinNT.HANDLE, com.sun.jna.platform.win32.WinBase.SECURITY_ATTRIBUTES, int, com.sun.jna.Pointer, com.sun.jna.Pointer, int, com.sun.jna.platform.win32.WinDef.DWORDByReference)}
      */
     @Deprecated
     HANDLE CreateRemoteThread(HANDLE hProcess, WinBase.SECURITY_ATTRIBUTES lpThreadAttributes, int dwStackSize, FOREIGN_THREAD_START_ROUTINE lpStartAddress, Pointer lpParameter, DWORD dwCreationFlags, Pointer lpThreadId);

File: contrib/platform/src/com/sun/jna/platform/win32/PsapiUtil.java
Patch:
@@ -71,11 +71,11 @@ public static int[] enumProcesses() {
      * @throws Win32Exception in case an error occurs
      * @see <a href="http://msdn.microsoft.com/en-us/library/ms683217(VS.85).aspx">MSDN</a>
      */
-    public static String GetProcessImageFileName(HANDLE process) {
+    public static String GetProcessImageFileName(HANDLE hProcess) {
         int size = 2048;
         while (true) {
             final char[] filePath = new char[size];
-            int length = Psapi.INSTANCE.GetProcessImageFileName(process,
+            int length = Psapi.INSTANCE.GetProcessImageFileName(hProcess,
                 filePath, filePath.length);
             if(length == 0) {
                 if(Native.getLastError() != WinError.ERROR_INSUFFICIENT_BUFFER) {

File: contrib/platform/src/com/sun/jna/platform/win32/WTypes.java
Patch:
@@ -108,7 +108,7 @@ public BSTR() {
          * Instantiate a BSTR from a pointer. The user is responsible for allocating and
          * releasing memory for the {@link BSTR}, most commonly using
          * {@link OleAuto#SysAllocString(String)} and
-         * {@link OleAuto#SysFreeString(BSTR)}
+         * {@link OleAuto#SysFreeString(com.sun.jna.platform.win32.WTypes.BSTR)}
          *
          * @param pointer
          *            A pointer to the string
@@ -119,7 +119,7 @@ public BSTR(Pointer pointer) {
 
         /**
          * @deprecated Use {@link OleAuto#SysAllocString(String)} and
-         *             {@link OleAuto#SysFreeString(BSTR)}
+         *             {@link OleAuto#SysFreeString(com.sun.jna.platform.win32.WTypes.BSTR)}
          */
         @Deprecated
         public BSTR(String value) {

File: contrib/platform/src/com/sun/jna/platform/win32/WinNT.java
Patch:
@@ -2994,7 +2994,7 @@ protected SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX(Pointer memory) {
          * Create a new instance of the appropriate subclass of
          * {@link SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX} from the provided
          * {@link Pointer} to native memory. Use this method rather than
-         * {@link #SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX(Pointer)} to properly
+         * {@code SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX(Pointer)} to properly
          * cast the Pointer to the appropriate subclass and populate variable
          * length arrays.
          *

File: contrib/platform/src/com/sun/jna/platform/win32/Wtsapi32.java
Patch:
@@ -149,7 +149,7 @@ public interface WTS_CONNECTSTATE_CLASS {
 
     /**
      * Contains values that indicate the type of session information to retrieve in
-     * a call to the {@link #WTSQuerySessionInformation()} function.
+     * a call to the {@link #WTSQuerySessionInformation(com.sun.jna.platform.win32.WinNT.HANDLE, int, int, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference)} function.
      */
     public interface WTS_INFO_CLASS {
         int WTSInitialProgram = 0;

File: contrib/platform/src/com/sun/jna/platform/mac/CoreFoundation.java
Patch:
@@ -303,7 +303,7 @@ public boolean booleanValue() {
      * <p>
      * CFArray is “toll-free bridged” with its Cocoa Foundation counterpart,
      * {@code NSArray}. Therefore, in a method where you see an {@code NSArray *}
-     * parameter, you can pass in a {@link #CFArrayRef}.
+     * parameter, you can pass in a {@code CFArrayRef} .
      */
     class CFArrayRef extends CFTypeRef {
         public CFArrayRef() {

File: contrib/platform/src/com/sun/jna/platform/mac/IOKit.java
Patch:
@@ -763,7 +763,7 @@ CFTypeRef IORegistryEntrySearchCFProperty(IORegistryEntry entry, String plane, C
      * @param connect
      *            An {@code io_connect_t} handle is returned on success, to be used
      *            with the IOConnectXXX APIs. It should be destroyed with
-     *            {@link IOServiceClose}.
+     *            {@link #IOServiceClose}.
      * @return A return code generated by {@code IOService::newUserClient}.
      */
     int IOServiceOpen(IOService service, int owningTask, int type, PointerByReference connect);
@@ -828,7 +828,7 @@ CFTypeRef IORegistryEntrySearchCFProperty(IORegistryEntry entry, String plane, C
      *         <p>
      *         Caller should NOT release the returned CFDictionary - it will be
      *         released as part of the {@link CFTypeRef} returned by
-     *         {@link IOPSCopyPowerSourcesInfo}.
+     *         {@link #IOPSCopyPowerSourcesInfo}.
      */
     CFDictionaryRef IOPSGetPowerSourceDescription(CFTypeRef blob, CFTypeRef ps);
 

File: contrib/platform/src/com/sun/jna/platform/win32/Advapi32Util.java
Patch:
@@ -966,7 +966,7 @@ public static String[] registryGetStringArray(HKEY hKey, String value) {
 
     /**
      * Convert the null-delimited buffer of strings returned from registry values of
-     * type {@link WinNT.REG_MULTI_SZ} to an array of strings.
+     * type {@link WinNT#REG_MULTI_SZ} to an array of strings.
      *
      * @param data
      *            A buffer containing strings delimited by a null character, ending

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32.java
Patch:
@@ -2787,7 +2787,7 @@ boolean SystemTimeToTzSpecificLocalTime(TIME_ZONE_INFORMATION lpTimeZone,
 
     /**
      * @deprecated Use
-     *             {@link #CreateRemoteThread(com.sun.jna.platform.win32.WinNT.HANDLE, com.sun.jna.platform.win32.WinBase.SECURITY_ATTRIBUTES, int, com.sun.jna.Pointer, com.sun.jna.Pointer, int, com.sun.jna.platform.win32.WinDef.DWORDByReference)
+     *             {@link #CreateRemoteThread(com.sun.jna.platform.win32.WinNT.HANDLE, com.sun.jna.platform.win32.WinBase.SECURITY_ATTRIBUTES, int, com.sun.jna.Pointer, com.sun.jna.Pointer, int, com.sun.jna.platform.win32.WinDef.DWORDByReference)}
      */
     @Deprecated
     HANDLE CreateRemoteThread(HANDLE hProcess, WinBase.SECURITY_ATTRIBUTES lpThreadAttributes, int dwStackSize, FOREIGN_THREAD_START_ROUTINE lpStartAddress, Pointer lpParameter, DWORD dwCreationFlags, Pointer lpThreadId);

File: contrib/platform/src/com/sun/jna/platform/win32/PsapiUtil.java
Patch:
@@ -71,11 +71,11 @@ public static int[] enumProcesses() {
      * @throws Win32Exception in case an error occurs
      * @see <a href="http://msdn.microsoft.com/en-us/library/ms683217(VS.85).aspx">MSDN</a>
      */
-    public static String GetProcessImageFileName(HANDLE process) {
+    public static String GetProcessImageFileName(HANDLE hProcess) {
         int size = 2048;
         while (true) {
             final char[] filePath = new char[size];
-            int length = Psapi.INSTANCE.GetProcessImageFileName(process,
+            int length = Psapi.INSTANCE.GetProcessImageFileName(hProcess,
                 filePath, filePath.length);
             if(length == 0) {
                 if(Native.getLastError() != WinError.ERROR_INSUFFICIENT_BUFFER) {

File: contrib/platform/src/com/sun/jna/platform/win32/WTypes.java
Patch:
@@ -108,7 +108,7 @@ public BSTR() {
          * Instantiate a BSTR from a pointer. The user is responsible for allocating and
          * releasing memory for the {@link BSTR}, most commonly using
          * {@link OleAuto#SysAllocString(String)} and
-         * {@link OleAuto#SysFreeString(BSTR)}
+         * {@link OleAuto#SysFreeString(com.sun.jna.platform.win32.WTypes.BSTR)}
          *
          * @param pointer
          *            A pointer to the string
@@ -119,7 +119,7 @@ public BSTR(Pointer pointer) {
 
         /**
          * @deprecated Use {@link OleAuto#SysAllocString(String)} and
-         *             {@link OleAuto#SysFreeString(BSTR)}
+         *             {@link OleAuto#SysFreeString(com.sun.jna.platform.win32.WTypes.BSTR)}
          */
         @Deprecated
         public BSTR(String value) {

File: contrib/platform/src/com/sun/jna/platform/win32/WinNT.java
Patch:
@@ -2994,7 +2994,7 @@ protected SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX(Pointer memory) {
          * Create a new instance of the appropriate subclass of
          * {@link SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX} from the provided
          * {@link Pointer} to native memory. Use this method rather than
-         * {@link #SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX(Pointer)} to properly
+         * {@code SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX(Pointer)} to properly
          * cast the Pointer to the appropriate subclass and populate variable
          * length arrays.
          *

File: contrib/platform/src/com/sun/jna/platform/win32/Wtsapi32.java
Patch:
@@ -149,7 +149,7 @@ public interface WTS_CONNECTSTATE_CLASS {
 
     /**
      * Contains values that indicate the type of session information to retrieve in
-     * a call to the {@link #WTSQuerySessionInformation()} function.
+     * a call to the {@link #WTSQuerySessionInformation(com.sun.jna.platform.win32.WinNT.HANDLE, int, int, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference)} function.
      */
     public interface WTS_INFO_CLASS {
         int WTSInitialProgram = 0;

File: test/com/sun/jna/VMCrashProtectionTest.java
Patch:
@@ -24,7 +24,6 @@
 package com.sun.jna;
 
 import junit.framework.TestCase;
-import org.junit.Assume;
 
 public class VMCrashProtectionTest extends TestCase {
 
@@ -52,12 +51,14 @@ public void testAccessViolation() {
         else
             m.setLong(0, 1);
         Pointer p = m.getPointer(0);
+        Throwable actual = null;
         try {
             p.setInt(0, 0);
-            fail("Exception should be thrown");
         }
         catch(Throwable e) {
+            actual = e;
         }
+        assertNotNull("Exception should be thrown", actual);
     }
 
     public static void main(String[] args) {

File: test/com/sun/jna/VMCrashProtectionTest.java
Patch:
@@ -24,7 +24,6 @@
 package com.sun.jna;
 
 import junit.framework.TestCase;
-import org.junit.Assume;
 
 public class VMCrashProtectionTest extends TestCase {
 
@@ -52,12 +51,14 @@ public void testAccessViolation() {
         else
             m.setLong(0, 1);
         Pointer p = m.getPointer(0);
+        Throwable actual = null;
         try {
             p.setInt(0, 0);
-            fail("Exception should be thrown");
         }
         catch(Throwable e) {
+            actual = e;
         }
+        assertNotNull("Exception should be thrown", actual);
     }
 
     public static void main(String[] args) {

File: contrib/platform/src/com/sun/jna/platform/win32/WinNT.java
Patch:
@@ -1074,10 +1074,11 @@ public FILE_NOTIFY_INFORMATION next() {
     int REG_NOTIFY_CHANGE_ATTRIBUTES = 0x00000002;
     int REG_NOTIFY_CHANGE_LAST_SET = 0x00000004;
     int REG_NOTIFY_CHANGE_SECURITY = 0x00000008;
+    int REG_NOTIFY_THREAD_AGNOSTIC = 0x10000000;
 
     int REG_LEGAL_CHANGE_FILTER = REG_NOTIFY_CHANGE_NAME
             | REG_NOTIFY_CHANGE_ATTRIBUTES | REG_NOTIFY_CHANGE_LAST_SET
-            | REG_NOTIFY_CHANGE_SECURITY;
+            | REG_NOTIFY_CHANGE_SECURITY | REG_NOTIFY_THREAD_AGNOSTIC;
 
     //
     // Predefined Value Types.

File: src/com/sun/jna/Platform.java
Patch:
@@ -313,7 +313,7 @@ static String getNativeLibraryResourcePrefix(int osType, String arch, String nam
                 osPrefix = "w32ce-" + arch;
                 break;
             case Platform.MAC:
-                osPrefix = "darwin";
+                osPrefix = "darwin-" + arch;
                 break;
             case Platform.LINUX:
                 osPrefix = "linux-" + arch;

File: test/com/sun/jna/LibraryLoadTest.java
Patch:
@@ -100,7 +100,8 @@ public void testLoadFromClasspathAbsolute() throws MalformedURLException {
     }
 
     public void testLoadFromJar() throws MalformedURLException {
-        NativeLibrary.getInstance("testlib-jar", new TestLoader(new File(TESTJAR)));
+        NativeLibrary.getInstance("testlib-jar", new TestLoader(new File(TESTJAR2)));
+        NativeLibrary.getInstance("testlib-jar", new TestLoader(new File(TESTJAR3)));
     }
 
     public void testLoadFromJarAbsolute() throws MalformedURLException {

File: test/com/sun/jna/Paths.java
Patch:
@@ -54,4 +54,6 @@ public CloverLoader(ClassLoader parent) throws MalformedURLException {
         : System.getProperty("jna.nativedir",
                              BUILDDIR + "/native-" + Platform.RESOURCE_PREFIX + "/");
     String TESTJAR = BUILDDIR + "/jna-test.jar";
+    String TESTJAR2 = BUILDDIR + "/jna-test2.jar";
+    String TESTJAR3 = BUILDDIR + "/jna-test3.jar";
 }

File: src/com/sun/jna/Platform.java
Patch:
@@ -313,7 +313,7 @@ static String getNativeLibraryResourcePrefix(int osType, String arch, String nam
                 osPrefix = "w32ce-" + arch;
                 break;
             case Platform.MAC:
-                osPrefix = "darwin";
+                osPrefix = "darwin-" + arch;
                 break;
             case Platform.LINUX:
                 osPrefix = "linux-" + arch;

File: test/com/sun/jna/LibraryLoadTest.java
Patch:
@@ -100,7 +100,8 @@ public void testLoadFromClasspathAbsolute() throws MalformedURLException {
     }
 
     public void testLoadFromJar() throws MalformedURLException {
-        NativeLibrary.getInstance("testlib-jar", new TestLoader(new File(TESTJAR)));
+        NativeLibrary.getInstance("testlib-jar", new TestLoader(new File(TESTJAR2)));
+        NativeLibrary.getInstance("testlib-jar", new TestLoader(new File(TESTJAR3)));
     }
 
     public void testLoadFromJarAbsolute() throws MalformedURLException {

File: test/com/sun/jna/Paths.java
Patch:
@@ -54,4 +54,6 @@ public CloverLoader(ClassLoader parent) throws MalformedURLException {
         : System.getProperty("jna.nativedir",
                              BUILDDIR + "/native-" + Platform.RESOURCE_PREFIX + "/");
     String TESTJAR = BUILDDIR + "/jna-test.jar";
+    String TESTJAR2 = BUILDDIR + "/jna-test2.jar";
+    String TESTJAR3 = BUILDDIR + "/jna-test3.jar";
 }

File: contrib/platform/test/com/sun/jna/platform/win32/Kernel32Test.java
Patch:
@@ -1811,7 +1811,8 @@ public void testSetErrorMode() {
         // Set bit flags to 0x0001
         int previousMode = Kernel32.INSTANCE.SetErrorMode(0x0001);
         // Restore to previous state; 0x0001 is now "previous"
-        assertEquals(Kernel32.INSTANCE.SetErrorMode(previousMode), 0x0001);
+        // Since 0x0004 bit is sticky previous may be 0x0005
+        assertEquals(0x0001, Kernel32.INSTANCE.SetErrorMode(previousMode) & ~0x0004);
     }
 
 // Testcase is disabled, as kernel32 ordinal values are not stable.

File: test/com/sun/jna/VarArgsTest.java
Patch:
@@ -42,8 +42,8 @@ protected List<String> getFieldOrder() {
         }
         public int addVarArgs(String fmt, Number... args);
         public String returnStringVarArgs(String fmt, Object... args);
-        public void modifyStructureVarArgs(String fmt, Object arg1, Object... args);
-        public String returnStringVarArgs2(String... args);
+        public void modifyStructureVarArgs(String fmt, Object... args);
+        public String returnStringVarArgs2(String fmt, String... args);
     }
     TestLibrary lib;
     @Override

File: src/com/sun/jna/Native.java
Patch:
@@ -664,6 +664,7 @@ private static void loadLibraryInstance(Class<?> cls) {
                     if (field.getType() == cls
                         && Modifier.isStatic(field.getModifiers())) {
                         // Ensure the field gets initialized by reading it
+                        field.setAccessible(true); // interface might be private
                         libraries.put(cls, new WeakReference<Object>(field.get(null)));
                         break;
                     }

File: contrib/platform/src/com/sun/jna/platform/win32/Psapi.java
Patch:
@@ -226,6 +226,8 @@ public interface Psapi extends StdCallLibrary {
     boolean GetModuleInformation(HANDLE hProcess, HMODULE hModule, MODULEINFO lpmodinfo, int cb);
 
     /**
+     * Retrieves the name of the executable file for the specified process.
+     *
      * @param hProcess
      *            A handle to the process. The handle must have the
      *            PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION

File: contrib/platform/test/com/sun/jna/platform/mac/XAttrUtilTest.java
Patch:
@@ -157,7 +157,7 @@ public void testReadAlignedCliTool() throws IOException {
 
     public void testWriteAlignedCliTool() throws IOException, InterruptedException {
         Process p = Runtime.getRuntime().exec(new String[] {"xattr", "-w", "JNA", "Java Native Access", testPath});
-        assertTrue(p.waitFor(10, TimeUnit.SECONDS));
+        assertTrue(p.waitFor(30, TimeUnit.SECONDS));
         String resultString = XAttrUtil.getXAttr(testPath, "JNA");
         assertEquals("Java Native Access", resultString);
     }

File: contrib/platform/src/com/sun/jna/platform/win32/Psapi.java
Patch:
@@ -226,6 +226,8 @@ public interface Psapi extends StdCallLibrary {
     boolean GetModuleInformation(HANDLE hProcess, HMODULE hModule, MODULEINFO lpmodinfo, int cb);
 
     /**
+     * Retrieves the name of the executable file for the specified process.
+     *
      * @param hProcess
      *            A handle to the process. The handle must have the
      *            PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION

File: src/com/sun/jna/CallbackReference.java
Patch:
@@ -67,9 +67,9 @@ public class CallbackReference extends WeakReference<Callback> {
             throw new Error("Error looking up CallbackProxy.callback() method");
         }
     }
-    
+
     private static final Class<?> DLL_CALLBACK_CLASS;
-    
+
     static {
         if (Platform.isWindows()) {
             try {

File: contrib/platform/src/com/sun/jna/platform/win32/Variant.java
Patch:
@@ -478,9 +478,9 @@ public void setValue(VARTYPE vt, Object value) {
         }
 
         public Object getValue() {
-            this.read();
+            // this.read() is called by this.getVarType()
             int varType = this.getVarType().intValue();
-            switch (this.getVarType().intValue()) {
+            switch (varType) {
                 case VT_UI1:
                     return this._variant.__variant.readField("bVal");
                 case VT_I2:

File: contrib/platform/test/com/sun/jna/platform/win32/User32WindowMessagesTest.java
Patch:
@@ -294,7 +294,7 @@ public LRESULT callback(HWND hwnd, int uMsg, WPARAM wParam, LPARAM lParam) {
 
     public HWND determineHWNDFromWindowClass(String windowClass) {
         CallBackFindWindowHandleByWindowclass cb = new CallBackFindWindowHandleByWindowclass(windowClass);
-        assertCallSucceeded("Find HWND for " + windowClass, User32.INSTANCE.EnumWindows(cb, null));
+        User32.INSTANCE.EnumWindows(cb, null);
         return cb.getFoundHwnd();
 
     }

File: contrib/platform/test/com/sun/jna/platform/win32/User32WindowMessagesTest.java
Patch:
@@ -294,7 +294,7 @@ public LRESULT callback(HWND hwnd, int uMsg, WPARAM wParam, LPARAM lParam) {
 
     public HWND determineHWNDFromWindowClass(String windowClass) {
         CallBackFindWindowHandleByWindowclass cb = new CallBackFindWindowHandleByWindowclass(windowClass);
-        assertCallSucceeded("Find HWND for " + windowClass, User32.INSTANCE.EnumWindows(cb, null));
+        User32.INSTANCE.EnumWindows(cb, null);
         return cb.getFoundHwnd();
 
     }

File: contrib/platform/test/com/sun/jna/platform/win32/User32WindowMessagesTest.java
Patch:
@@ -294,7 +294,7 @@ public LRESULT callback(HWND hwnd, int uMsg, WPARAM wParam, LPARAM lParam) {
 
     public HWND determineHWNDFromWindowClass(String windowClass) {
         CallBackFindWindowHandleByWindowclass cb = new CallBackFindWindowHandleByWindowclass(windowClass);
-        User32.INSTANCE.EnumWindows(cb, null);
+        assertCallSucceeded("Find HWND for " + windowClass, User32.INSTANCE.EnumWindows(cb, null));
         return cb.getFoundHwnd();
 
     }
@@ -313,7 +313,7 @@ public CallBackFindWindowHandleByWindowclass(String windowClass) {
         public boolean callback(HWND hWnd, Pointer data) {
 
             char[] windowText = new char[512];
-            User32.INSTANCE.GetClassName(hWnd, windowText, 512);
+            assertCallSucceeded("GetClassName", User32.INSTANCE.GetClassName(hWnd, windowText, windowText.length) != 0);
             String className = Native.toString(windowText);
 
             if (windowClass.equalsIgnoreCase(className)) {

File: contrib/platform/src/com/sun/jna/platform/win32/PsapiUtil.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * Psapi utility API.
  *
- * @author Torbj&ouml;rn Svensson, azoff[at]svenskalinuxforeninen.se
+ * @author Torbj&ouml;rn Svensson, azoff[at]svenskalinuxforeningen.se
  */
 public abstract class PsapiUtil {
 

File: contrib/platform/test/com/sun/jna/platform/win32/PsapiUtilTest.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * Applies API tests on {@link PsapiUtil}.
  *
- * @author Torbj&ouml;rn Svensson, azoff[at]svenskalinuxforeninen.se
+ * @author Torbj&ouml;rn Svensson, azoff[at]svenskalinuxforeningen.se
  */
 @SuppressWarnings("nls")
 public class PsapiUtilTest {

File: contrib/platform/src/com/sun/jna/platform/win32/PsapiUtil.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * Psapi utility API.
  *
- * @author Torbj&ouml;rn Svensson, azoff[at]svenskalinuxforeninen.se
+ * @author Torbj&ouml;rn Svensson, azoff[at]svenskalinuxforeningen.se
  */
 public abstract class PsapiUtil {
 

File: contrib/platform/test/com/sun/jna/platform/win32/PsapiUtilTest.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * Applies API tests on {@link PsapiUtil}.
  *
- * @author Torbj&ouml;rn Svensson, azoff[at]svenskalinuxforeninen.se
+ * @author Torbj&ouml;rn Svensson, azoff[at]svenskalinuxforeningen.se
  */
 @SuppressWarnings("nls")
 public class PsapiUtilTest {

File: src/com/sun/jna/Platform.java
Patch:
@@ -194,7 +194,8 @@ public static final boolean is64Bit() {
             || "ppc64".equals(ARCH) || "ppc64le".equals(ARCH)
             || "sparcv9".equals(ARCH)
             || "mips64".equals(ARCH) || "mips64el".equals(ARCH)
-            || "amd64".equals(ARCH)) {
+            || "amd64".equals(ARCH)
+            || "aarch64".equals(ARCH)) {
             return true;
         }
         return Native.POINTER_SIZE == 8;
@@ -215,7 +216,7 @@ public static final boolean isPPC() {
     }
 
     public static final boolean isARM() {
-        return ARCH.startsWith("arm");
+        return ARCH.startsWith("arm") || ARCH.startsWith("aarch");
     }
 
     public static final boolean isSPARC() {

File: test/com/sun/jna/StructureTest.java
Patch:
@@ -1388,7 +1388,7 @@ public void testNestedStructureTypeInfo() {
         assertEquals("Wrong type information for 'inner' field",
                      inner, els.getPointer(0));
         assertEquals("Wrong type information for integer field",
-                     Structure.getTypeInfo(Integer.valueOf(0)),
+                     Structure.getTypeInfo(0).getPointer(),
                      els.getPointer(Native.POINTER_SIZE));
         assertNull("Type element list should be null-terminated",
                    els.getPointer(Native.POINTER_SIZE*2));
@@ -2163,7 +2163,7 @@ protected List<String> getFieldOrder() {
         Structure s = new TestStructure();
         assertEquals("Wrong type mapper for structure", mapper, s.getTypeMapper());
 
-        TestFFIType ffi_type = new TestFFIType(Structure.getTypeInfo(s));
+        TestFFIType ffi_type = new TestFFIType(Structure.getTypeInfo(s).getPointer());
         assertEquals("Java Structure size does not match FFIType size",
                      s.size(), ffi_type.size.intValue());
     }

File: contrib/platform/test/com/sun/jna/platform/win32/Ole32Test.java
Patch:
@@ -23,14 +23,14 @@
  */
 package com.sun.jna.platform.win32;
 
-import junit.framework.TestCase;
-
 import com.sun.jna.Native;
 import com.sun.jna.Pointer;
 import com.sun.jna.platform.win32.Guid.GUID;
 import com.sun.jna.platform.win32.WinNT.HRESULT;
 import com.sun.jna.ptr.PointerByReference;
 
+import junit.framework.TestCase;
+
 /**
  * @author dblock[at]dblock[dot]org
  * @author markus[at]headcrashing[dot]eu
@@ -106,7 +106,7 @@ public void testCoCreateInstance() {
                 // aggregation
                 WTypes.CLSCTX_LOCAL_SERVER, riid, pDispatch);
         assertTrue(W32Errors.SUCCEEDED(hr.intValue()));
-        assertTrue(!pDispatch.equals(Pointer.NULL));
+        assertNotNull(pDispatch.getValue());
         // We leak this iUnknown reference because we don't have the JNACOM lib
         // here to wrap the native iUnknown pointer and call iUnknown.release()
         if (W32Errors.SUCCEEDED(hrCI.intValue())) {

File: test/com/sun/jna/StructureTest.java
Patch:
@@ -31,14 +31,14 @@
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
 
-import junit.framework.TestCase;
-
 import com.sun.jna.Structure.FieldOrder;
 import com.sun.jna.Structure.StructureSet;
 import com.sun.jna.ptr.ByteByReference;
 import com.sun.jna.ptr.IntByReference;
 import com.sun.jna.ptr.LongByReference;
 
+import junit.framework.TestCase;
+
 /** TODO: need more alignment tests, especially platform-specific behavior
  * @author twall@users.sf.net
  */
@@ -1785,6 +1785,7 @@ protected List<String> getFieldOrder() {
         assertNotNull("Field should not be null after read", s.field);
     }
 
+    @SuppressWarnings("unlikely-arg-type")
     public void testStructureEquals() {
         class OtherStructure extends Structure {
             public int first;

File: contrib/platform/src/com/sun/jna/platform/win32/WinNT.java
Patch:
@@ -919,9 +919,9 @@ public FILE_NOTIFY_INFORMATION next() {
 
     int KEY_EXECUTE = KEY_READ & (~SYNCHRONIZE);
 
-    int KEY_ALL_ACCESS = STANDARD_RIGHTS_ALL | KEY_QUERY_VALUE | KEY_SET_VALUE
+    int KEY_ALL_ACCESS = ((STANDARD_RIGHTS_ALL | KEY_QUERY_VALUE | KEY_SET_VALUE
             | KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | KEY_NOTIFY
-            | KEY_CREATE_LINK & (~SYNCHRONIZE);
+            | KEY_CREATE_LINK) & (~SYNCHRONIZE));
 
     //
     // Open/Create Options

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32Util.java
Patch:
@@ -636,7 +636,7 @@ public static DomainTrust[] getDomainTrusts(String serverName) {
         }
         try {
             DS_DOMAIN_TRUSTS domainTrustRefs = new DS_DOMAIN_TRUSTS(domainsPointerRef.getValue());
-            DS_DOMAIN_TRUSTS[] domainTrusts = (DS_DOMAIN_TRUSTS[]) domainTrustRefs.toArray(new DS_DOMAIN_TRUSTS[0]);
+            DS_DOMAIN_TRUSTS[] domainTrusts = (DS_DOMAIN_TRUSTS[]) domainTrustRefs.toArray(new DS_DOMAIN_TRUSTS[domainTrustCount.getValue()]);
             ArrayList<DomainTrust> trusts = new ArrayList<DomainTrust>(domainTrustCount.getValue());
             for(DS_DOMAIN_TRUSTS domainTrust : domainTrusts) {
                 DomainTrust t = new DomainTrust();

File: contrib/platform/test/com/sun/jna/platform/win32/Netapi32Test.java
Patch:
@@ -260,7 +260,7 @@ public void testDsEnumerateDomainTrusts() {
         assertTrue(domainTrustCount.getValue() >= 0);
 
         DS_DOMAIN_TRUSTS domainTrustRefs = new DS_DOMAIN_TRUSTS(domainsPointerRef.getValue());
-        DS_DOMAIN_TRUSTS[] domainTrusts = (DS_DOMAIN_TRUSTS[]) domainTrustRefs.toArray(new DS_DOMAIN_TRUSTS[0]);
+        DS_DOMAIN_TRUSTS[] domainTrusts = (DS_DOMAIN_TRUSTS[]) domainTrustRefs.toArray(new DS_DOMAIN_TRUSTS[domainTrustCount.getValue()]);
 
         for (DS_DOMAIN_TRUSTS trust : domainTrusts) {
             assertTrue(trust.DnsDomainName.length() > 0);

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32Util.java
Patch:
@@ -636,7 +636,7 @@ public static DomainTrust[] getDomainTrusts(String serverName) {
         }
         try {
             DS_DOMAIN_TRUSTS domainTrustRefs = new DS_DOMAIN_TRUSTS(domainsPointerRef.getValue());
-            DS_DOMAIN_TRUSTS[] domainTrusts = (DS_DOMAIN_TRUSTS[]) domainTrustRefs.toArray(new DS_DOMAIN_TRUSTS[0]);
+            DS_DOMAIN_TRUSTS[] domainTrusts = (DS_DOMAIN_TRUSTS[]) domainTrustRefs.toArray(new DS_DOMAIN_TRUSTS[domainTrustCount.getValue()]);
             ArrayList<DomainTrust> trusts = new ArrayList<DomainTrust>(domainTrustCount.getValue());
             for(DS_DOMAIN_TRUSTS domainTrust : domainTrusts) {
                 DomainTrust t = new DomainTrust();

File: contrib/platform/test/com/sun/jna/platform/win32/Netapi32Test.java
Patch:
@@ -260,7 +260,7 @@ public void testDsEnumerateDomainTrusts() {
         assertTrue(domainTrustCount.getValue() >= 0);
 
         DS_DOMAIN_TRUSTS domainTrustRefs = new DS_DOMAIN_TRUSTS(domainsPointerRef.getValue());
-        DS_DOMAIN_TRUSTS[] domainTrusts = (DS_DOMAIN_TRUSTS[]) domainTrustRefs.toArray(new DS_DOMAIN_TRUSTS[0]);
+        DS_DOMAIN_TRUSTS[] domainTrusts = (DS_DOMAIN_TRUSTS[]) domainTrustRefs.toArray(new DS_DOMAIN_TRUSTS[domainTrustCount.getValue()]);
 
         for (DS_DOMAIN_TRUSTS trust : domainTrusts) {
             assertTrue(trust.DnsDomainName.length() > 0);

File: src/com/sun/jna/internal/ReflectionUtils.java
Patch:
@@ -23,7 +23,6 @@
  */
 package com.sun.jna.internal;
 
-import java.lang.invoke.MethodType;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -74,7 +73,7 @@ private static Constructor getConstructorLookupClass() {
         METHOD_HANDLES_LOOKUP = lookupMethod(methodHandles, "lookup");
         METHOD_HANDLES_LOOKUP_IN = lookupMethod(lookup, "in", Class.class);
         METHOD_HANDLES_LOOKUP_UNREFLECT_SPECIAL = lookupMethod(lookup, "unreflectSpecial", Method.class, Class.class);
-        METHOD_HANDLES_LOOKUP_FIND_SPECIAL = lookupMethod(lookup, "findSpecial", Class.class, String.class, MethodType.class, Class.class);
+        METHOD_HANDLES_LOOKUP_FIND_SPECIAL = lookupMethod(lookup, "findSpecial", Class.class, String.class, methodType, Class.class);
         METHOD_HANDLES_BIND_TO = lookupMethod(methodHandle, "bindTo", Object.class);
         METHOD_HANDLES_INVOKE_WITH_ARGUMENTS = lookupMethod(methodHandle, "invokeWithArguments", Object[].class);
         METHOD_HANDLES_PRIVATE_LOOKUP_IN = lookupMethod(methodHandles, "privateLookupIn", Class.class, lookup);

File: src/com/sun/jna/internal/ReflectionUtils.java
Patch:
@@ -23,7 +23,6 @@
  */
 package com.sun.jna.internal;
 
-import java.lang.invoke.MethodType;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -74,7 +73,7 @@ private static Constructor getConstructorLookupClass() {
         METHOD_HANDLES_LOOKUP = lookupMethod(methodHandles, "lookup");
         METHOD_HANDLES_LOOKUP_IN = lookupMethod(lookup, "in", Class.class);
         METHOD_HANDLES_LOOKUP_UNREFLECT_SPECIAL = lookupMethod(lookup, "unreflectSpecial", Method.class, Class.class);
-        METHOD_HANDLES_LOOKUP_FIND_SPECIAL = lookupMethod(lookup, "findSpecial", Class.class, String.class, MethodType.class, Class.class);
+        METHOD_HANDLES_LOOKUP_FIND_SPECIAL = lookupMethod(lookup, "findSpecial", Class.class, String.class, methodType, Class.class);
         METHOD_HANDLES_BIND_TO = lookupMethod(methodHandle, "bindTo", Object.class);
         METHOD_HANDLES_INVOKE_WITH_ARGUMENTS = lookupMethod(methodHandle, "invokeWithArguments", Object[].class);
         METHOD_HANDLES_PRIVATE_LOOKUP_IN = lookupMethod(methodHandles, "privateLookupIn", Class.class, lookup);

File: src/com/sun/jna/Native.java
Patch:
@@ -226,7 +226,7 @@ static boolean isCompatibleVersion(String expectedVersion, String nativeVersion)
         MAX_ALIGNMENT = Platform.isSPARC() || Platform.isWindows()
             || (Platform.isLinux() && (Platform.isARM() || Platform.isPPC() || Platform.isMIPS()))
             || Platform.isAIX()
-            || Platform.isAndroid()
+            || (Platform.isAndroid() && !Platform.isIntel())
             ? 8 : LONG_SIZE;
         MAX_PADDING = (Platform.isMac() && Platform.isPPC()) ? 8 : MAX_ALIGNMENT;
         System.setProperty("jna.loaded", "true");

File: src/com/sun/jna/Native.java
Patch:
@@ -226,7 +226,7 @@ static boolean isCompatibleVersion(String expectedVersion, String nativeVersion)
         MAX_ALIGNMENT = Platform.isSPARC() || Platform.isWindows()
             || (Platform.isLinux() && (Platform.isARM() || Platform.isPPC() || Platform.isMIPS()))
             || Platform.isAIX()
-            || Platform.isAndroid()
+            || (Platform.isAndroid() && !Platform.isIntel())
             ? 8 : LONG_SIZE;
         MAX_PADDING = (Platform.isMac() && Platform.isPPC()) ? 8 : MAX_ALIGNMENT;
         System.setProperty("jna.loaded", "true");

File: src/com/sun/jna/Memory.java
Patch:
@@ -87,7 +87,7 @@ public SharedMemory(long offset, long size) {
         }
         /** No need to free memory. */
         @Override
-        protected void dispose() {
+        protected synchronized void dispose() {
             this.peer = 0;
         }
         /** Pass bounds check to parent. */

File: contrib/platform/src/com/sun/jna/platform/WindowUtils.java
Patch:
@@ -1,6 +1,5 @@
-/*
- * Copyright (c) 2007-2008 Timothy Wall, All Rights Reserved
- * Parts Copyright (c) 2007 Olivier Chafik
+/* Copyright (c) 2007-2008 Timothy Wall, All Rights Reserved
+ * Copyright (c) 2007 Olivier Chafik
  *
  * The contents of this file is dual-licensed under 2
  * alternative Open Source/Free licenses: LGPL 2.1 or later and

File: contrib/platform/src/com/sun/jna/platform/win32/GDI32.java
Patch:
@@ -1,4 +1,4 @@
-/* copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
  *
  * The contents of this file is dual-licensed under 2
  * alternative Open Source/Free licenses: LGPL 2.1 or later and

File: contrib/platform/src/com/sun/jna/platform/win32/ObjBase.java
Patch:
@@ -1,7 +1,6 @@
-/*
- * Copyright 2010 Digital Rapids Corp.
- */
 /* Copyright (c) 2010 Timothy Wall, All Rights Reserved
+ * Copyright 2010 Digital Rapids Corp.
+ *
  * The contents of this file is dual-licensed under 2
  * alternative Open Source/Free licenses: LGPL 2.1 or later and
  * Apache License 2.0. (starting with JNA version 4.0.0).

File: contrib/w32printing/src/com/sun/jna/platform/win32/Win32SpoolMonitor.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * The contents of this file is dual-licensed under 2
  * alternative Open Source/Free licenses: LGPL 2.1 or later and
  * Apache License 2.0. (starting with JNA version 4.0.0).

File: src/com/sun/jna/win32/W32APIOptions.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * The contents of this file is dual-licensed under 2
  * alternative Open Source/Free licenses: LGPL 2.1 or later and
  * Apache License 2.0. (starting with JNA version 4.0.0).

File: test/com/sun/jna/IntegerTypeTest.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * The contents of this file is dual-licensed under 2
  * alternative Open Source/Free licenses: LGPL 2.1 or later and
  * Apache License 2.0. (starting with JNA version 4.0.0).

File: test/com/sun/jna/PrematureGCTest.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * The contents of this file is dual-licensed under 2
  * alternative Open Source/Free licenses: LGPL 2.1 or later and
  * Apache License 2.0. (starting with JNA version 4.0.0).

File: test/com/sun/jna/StructureFieldOrderInspector.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * The contents of this file is dual-licensed under 2
  * alternative Open Source/Free licenses: LGPL 2.1 or later and
  * Apache License 2.0. (starting with JNA version 4.0.0).

File: test/com/sun/jna/StructureFieldOrderInspectorTest.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * The contents of this file is dual-licensed under 2
  * alternative Open Source/Free licenses: LGPL 2.1 or later and
  * Apache License 2.0. (starting with JNA version 4.0.0).

File: contrib/platform/src/com/sun/jna/platform/win32/User32Util.java
Patch:
@@ -276,12 +276,12 @@ protected boolean getMessageFailed() {
             return true;
         }
     }
-       
+
     /**
      * Load a string value from the string table of an executable.
-     * 
+     *
      * @param location the location, eg. %SystemRoot%\system32\input.dll,-5011
-     * @return
+     * @return the string located at the designated location
      * @throws UnsupportedEncodingException
      */
     public static String loadString(String location) throws UnsupportedEncodingException {

File: contrib/platform/src/com/sun/jna/platform/win32/WinDef.java
Patch:
@@ -658,8 +658,6 @@ public HKL(int i) {
 
         /**
          * Get the low word (unsigned short).
-         *
-         * @return
          */
         public int getLanguageIdentifier() {
             return (int) (Pointer.nativeValue(getPointer()) & 0xFFFF);

File: contrib/platform/src/com/sun/jna/platform/RasterRangesUtils.java
Patch:
@@ -243,8 +243,8 @@ public static boolean outputOccupiedRanges(int[] pixels, int w, int h, int occup
     private static Set<Rectangle> mergeRects(Set<Rectangle> prev, Set<Rectangle> current) {
         Set<Rectangle> unmerged = new HashSet<Rectangle>(prev);
         if (!prev.isEmpty() && !current.isEmpty()) {
-            Rectangle[] pr = prev.toArray(new Rectangle[prev.size()]);
-            Rectangle[] cr = current.toArray(new Rectangle[current.size()]);
+            Rectangle[] pr = prev.toArray(new Rectangle[0]);
+            Rectangle[] cr = current.toArray(new Rectangle[0]);
             int ipr = 0;
             int icr = 0;
             while (ipr < pr.length && icr < cr.length) {

File: contrib/platform/src/com/sun/jna/platform/win32/Advapi32Util.java
Patch:
@@ -946,7 +946,7 @@ public static String[] registryGetStringArray(HKEY hKey, String value) {
 				result.add(s);
 			}
 		}
-		return result.toArray(new String[result.size()]);
+		return result.toArray(new String[0]);
 	}
 
 	/**
@@ -2632,7 +2632,7 @@ public static ACE_HEADER[] getFileSecurity(String fileName,
                                         result.add(aceStructure);
                                 }
 			}
-			return result.toArray(new ACE_HEADER[result.size()]);
+			return result.toArray(new ACE_HEADER[0]);
 		}
 
                 return aceStructures;

File: contrib/platform/src/com/sun/jna/platform/win32/DdemlUtil.java
Patch:
@@ -1751,7 +1751,7 @@ private Ddeml.HSZPAIR[] onWildconnect(int transactionType, HSZ topic, HSZ servic
             for(WildconnectHandler handler: wildconnectHandler) {
                 hszpairs.addAll(handler.onWildconnect(transactionType, topic, service, convcontext, sameInstance));
             }
-            return hszpairs.toArray(new HSZPAIR[hszpairs.size()]);
+            return hszpairs.toArray(new HSZPAIR[0]);
         }
         
         

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32Util.java
Patch:
@@ -674,7 +674,7 @@ public static final WinNT.SYSTEM_LOGICAL_PROCESSOR_INFORMATION[] getLogicalProce
         int returnedStructCount = bufferSize.getValue().intValue()
                 / sizePerStruct;
         return (WinNT.SYSTEM_LOGICAL_PROCESSOR_INFORMATION[]) firstInformation
-                .toArray(new WinNT.SYSTEM_LOGICAL_PROCESSOR_INFORMATION[returnedStructCount]);
+                .toArray(new WinNT.SYSTEM_LOGICAL_PROCESSOR_INFORMATION[0]);
     }
 
     /**

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32Util.java
Patch:
@@ -636,7 +636,7 @@ public static DomainTrust[] getDomainTrusts(String serverName) {
     	}
     	try {
             DS_DOMAIN_TRUSTS domainTrustRefs = new DS_DOMAIN_TRUSTS(domainsPointerRef.getValue());
-            DS_DOMAIN_TRUSTS[] domainTrusts = (DS_DOMAIN_TRUSTS[]) domainTrustRefs.toArray(new DS_DOMAIN_TRUSTS[domainTrustCount.getValue()]);
+            DS_DOMAIN_TRUSTS[] domainTrusts = (DS_DOMAIN_TRUSTS[]) domainTrustRefs.toArray(new DS_DOMAIN_TRUSTS[0]);
             ArrayList<DomainTrust> trusts = new ArrayList<DomainTrust>(domainTrustCount.getValue());
             for(DS_DOMAIN_TRUSTS domainTrust : domainTrusts) {
                 DomainTrust t = new DomainTrust();

File: contrib/platform/test/com/sun/jna/platform/win32/Netapi32Test.java
Patch:
@@ -247,7 +247,7 @@ public void testDsEnumerateDomainTrusts() {
     	assertTrue(domainTrustCount.getValue() >= 0);
 
         DS_DOMAIN_TRUSTS domainTrustRefs = new DS_DOMAIN_TRUSTS(domainsPointerRef.getValue());
-        DS_DOMAIN_TRUSTS[] domainTrusts = (DS_DOMAIN_TRUSTS[]) domainTrustRefs.toArray(new DS_DOMAIN_TRUSTS[domainTrustCount.getValue()]);
+        DS_DOMAIN_TRUSTS[] domainTrusts = (DS_DOMAIN_TRUSTS[]) domainTrustRefs.toArray(new DS_DOMAIN_TRUSTS[0]);
 
     	for(DS_DOMAIN_TRUSTS trust : domainTrusts) {
 			assertTrue(trust.DnsDomainName.length() > 0);

File: src/com/sun/jna/CallbackReference.java
Patch:
@@ -346,7 +346,7 @@ private static Method getCallbackMethod(Class<?> cls) {
             }
         }
 
-        Method[] methods = pmethods.toArray(new Method[pmethods.size()]);
+        Method[] methods = pmethods.toArray(new Method[0]);
         if (methods.length == 1) {
             return checkMethod(methods[0]);
         }

File: src/com/sun/jna/NativeLibrary.java
Patch:
@@ -941,7 +941,7 @@ static double parseVersion(String ver) {
                     }
                     ldPaths.add(0, paths[i]);
                 }
-                paths = ldPaths.toArray(new String[ldPaths.size()]);
+                paths = ldPaths.toArray(new String[0]);
             }
 
             for (int i=0;i < paths.length;i++) {

File: src/com/sun/jna/Pointer.java
Patch:
@@ -755,7 +755,7 @@ public Pointer[] getPointerArray(long offset) {
             addOffset += Native.POINTER_SIZE;
             p = getPointer(offset + addOffset);
         }
-        return array.toArray(new Pointer[array.size()]);
+        return array.toArray(new Pointer[0]);
     }
 
     /** Returns an array of {@link Pointer} of the requested size. */
@@ -837,7 +837,7 @@ public String[] getStringArray(long offset, int length, String encoding) {
                 addOffset += Native.POINTER_SIZE;
             }
         }
-        return strings.toArray(new String[strings.size()]);
+        return strings.toArray(new String[0]);
     }
 
     //////////////////////////////////////////////////////////////////////////

File: src/com/sun/jna/Native.java
Patch:
@@ -974,7 +974,7 @@ private static void loadNativeDispatchLibrary() {
             }
         }
         String jnaNosys = System.getProperty("jna.nosys", "true");
-        if (!Boolean.parseBoolean(jnaNosys)) {
+        if ((!Boolean.parseBoolean(jnaNosys)) || Platform.isAndroid()) {
             try {
                 LOG.log(DEBUG_JNA_LOAD_LEVEL, "Trying (via loadLibrary) {0}", libName);
                 System.loadLibrary(libName);

File: src/com/sun/jna/Native.java
Patch:
@@ -974,7 +974,7 @@ private static void loadNativeDispatchLibrary() {
             }
         }
         String jnaNosys = System.getProperty("jna.nosys", "true");
-        if (!Boolean.parseBoolean(jnaNosys)) {
+        if ((!Boolean.parseBoolean(jnaNosys)) || Platform.isAndroid()) {
             try {
                 LOG.log(DEBUG_JNA_LOAD_LEVEL, "Trying (via loadLibrary) {0}", libName);
                 System.loadLibrary(libName);

File: contrib/platform/src/com/sun/jna/platform/win32/Variant.java
Patch:
@@ -285,7 +285,7 @@ public VARIANT(boolean value) {
         }
 
         /**
-         * @deprecated Use {@link #VARIANT(com.sun.jna.platform.win32.COM.Dispatch) 
+         * @deprecated Use {@link #VARIANT(com.sun.jna.platform.win32.COM.Dispatch)}
          */
         @Deprecated
         public VARIANT(IDispatch value) {

File: contrib/platform/test/com/sun/jna/platform/win32/COM/WbemcliTest.java
Patch:
@@ -238,7 +238,7 @@ public void testShowProperties() {
                         assertTrue(year > 1970);
                         assertTrue(month >= 1 && month <= 12);
                         assertTrue(day >= 1 && day <= 31);
-                        assertTrue(hour >= 0 && day <= 23);
+                        assertTrue(hour >= 0 && hour <= 23);
                         assertTrue(minute >= 0 && minute <= 59);
                         assertTrue(second >= 0 && second <= 59);
                         OleAuto.INSTANCE.VariantClear(pVal);

File: contrib/platform/src/com/sun/jna/platform/linux/LibC.java
Patch:
@@ -89,8 +89,8 @@ protected List<Field> getFieldList() {
         @Override
         protected List<String> getFieldOrder() {
             List<String> fieldOrder = new ArrayList<String>(super.getFieldOrder());
-            if (PADDING_SIZE > 0) {
-                fieldOrder.add("_f");
+            if (PADDING_SIZE == 0) {
+                fieldOrder.remove("_f");
             }
             return fieldOrder;
         }

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/Convert.java
Patch:
@@ -120,8 +120,9 @@ public static VARIANT toVariant(Object value) {
                         Constructor<VARIANT> constructor = null;
                         if (value != null) {
                                 for (Constructor<VARIANT> m : (Constructor<VARIANT>[]) VARIANT.class.getConstructors()) {
-                                        if (m.getParameterCount() > 0
-                                                && m.getParameterTypes()[0].isAssignableFrom(value.getClass())) {
+                                        Class<?>[] parameters = m.getParameterTypes();
+                                        if (parameters.length == 1
+                                                && parameters[0].isAssignableFrom(value.getClass())) {
                                                 constructor = m;
                                         }
                                 }

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/Convert.java
Patch:
@@ -120,8 +120,9 @@ public static VARIANT toVariant(Object value) {
                         Constructor<VARIANT> constructor = null;
                         if (value != null) {
                                 for (Constructor<VARIANT> m : (Constructor<VARIANT>[]) VARIANT.class.getConstructors()) {
-                                        if (m.getParameterCount() > 0
-                                                && m.getParameterTypes()[0].isAssignableFrom(value.getClass())) {
+                                        Class<?>[] parameters = m.getParameterTypes();
+                                        if (parameters.length == 1
+                                                && parameters[0].isAssignableFrom(value.getClass())) {
                                                 constructor = m;
                                         }
                                 }

File: test/com/sun/jna/JNALoadTest.java
Patch:
@@ -125,7 +125,7 @@ public void testLoadAndUnloadFromJar() throws Exception {
         String path = (String)field.get(null);
         assertNotNull("Native library path unavailable", path);
         assertTrue("Native library not unpacked from jar: " + path,
-                   path.startsWith(System.getProperty("java.io.tmpdir")));
+                path.startsWith(Native.getTempDir().getAbsolutePath()));
 
         Reference<Class<?>> ref = new WeakReference<Class<?>>(cls);
         Reference<ClassLoader> clref = new WeakReference<ClassLoader>(loader);

File: src/com/sun/jna/Native.java
Patch:
@@ -980,7 +980,8 @@ private static void loadNativeDispatchLibrary() {
                 }
             }
         }
-        if (!Boolean.getBoolean("jna.nosys")) {
+        String jnaNosys = System.getProperty("jna.nosys", "true");
+        if (!Boolean.parseBoolean(jnaNosys)) {
             try {
                 if (DEBUG_JNA_LOAD) {
                     System.out.println("Trying (via loadLibrary) " + libName);

File: src/com/sun/jna/Pointer.java
Patch:
@@ -130,9 +130,9 @@ public long indexOf(long offset, byte value) {
      * Indirect the native pointer, copying <em>from</em> memory pointed to by
      * native pointer, into the specified array.
      *
-     * @param offset byte offset from pointer into which data is copied
+     * @param offset byte offset from pointer from which data is copied
      * @param buf    <code>byte</code> array into which data is copied
-     * @param index  array index from which to start copying
+     * @param index  array index to which data is copied
      * @param length number of elements from native pointer that must be copied
      */
     public void read(long offset, byte[] buf, int index, int length) {

File: contrib/platform/src/com/sun/jna/platform/win32/Mpr.java
Patch:
@@ -30,7 +30,6 @@
 import com.sun.jna.platform.win32.WinNT.HANDLEByReference;
 import com.sun.jna.platform.win32.Winnetwk.*;
 import com.sun.jna.ptr.IntByReference;
-import com.sun.jna.ptr.PointerByReference;
 import com.sun.jna.win32.StdCallLibrary;
 import com.sun.jna.win32.W32APIOptions;
 
@@ -308,7 +307,7 @@ public interface Mpr extends StdCallLibrary {
      *         (v=vs.85).aspx
      */
     public int WNetUseConnection(HWND hwndOwner, NETRESOURCE lpNETRESOURCE, String lpPassword, String lpUserID, int dwFlags,
-            PointerByReference lpAccessName, IntByReference lpBufferSize, IntByReference lpResult);
+            Pointer lpAccessName, IntByReference lpBufferSize, IntByReference lpResult);
 
     /**
      * The WNetAddConnection3 function makes a connection to a network resource.

File: contrib/platform/src/com/sun/jna/platform/win32/Mpr.java
Patch:
@@ -30,7 +30,6 @@
 import com.sun.jna.platform.win32.WinNT.HANDLEByReference;
 import com.sun.jna.platform.win32.Winnetwk.*;
 import com.sun.jna.ptr.IntByReference;
-import com.sun.jna.ptr.PointerByReference;
 import com.sun.jna.win32.StdCallLibrary;
 import com.sun.jna.win32.W32APIOptions;
 
@@ -308,7 +307,7 @@ public interface Mpr extends StdCallLibrary {
      *         (v=vs.85).aspx
      */
     public int WNetUseConnection(HWND hwndOwner, NETRESOURCE lpNETRESOURCE, String lpPassword, String lpUserID, int dwFlags,
-            PointerByReference lpAccessName, IntByReference lpBufferSize, IntByReference lpResult);
+            Pointer lpAccessName, IntByReference lpBufferSize, IntByReference lpResult);
 
     /**
      * The WNetAddConnection3 function makes a connection to a network resource.

File: contrib/platform/test/com/sun/jna/platform/win32/IPHlpAPITest.java
Patch:
@@ -116,11 +116,12 @@ public void testGetNetworkParams() {
 
         IntByReference bufferSize = new IntByReference();
         assertEquals(WinError.ERROR_BUFFER_OVERFLOW, IPHlpAPI.INSTANCE.GetNetworkParams(null, bufferSize));
-        FIXED_INFO buffer = new FIXED_INFO(new Memory(bufferSize.getValue()));
+        Memory buffer = new Memory(bufferSize.getValue());
         assertEquals(WinError.ERROR_SUCCESS, IPHlpAPI.INSTANCE.GetNetworkParams(buffer, bufferSize));
+        FIXED_INFO fixedInfo = new FIXED_INFO(buffer);
 
         // Check all DNS servers are valid IPs
-        IPHlpAPI.IP_ADDR_STRING dns = buffer.DnsServerList;
+        IPHlpAPI.IP_ADDR_STRING dns = fixedInfo.DnsServerList;
         while (dns != null) {
             // Start with 16-char byte array
             String addr = new String(dns.IpAddress.String);

File: contrib/platform/test/com/sun/jna/platform/win32/IPHlpAPITest.java
Patch:
@@ -37,7 +37,6 @@
 
 import com.sun.jna.Memory;
 import com.sun.jna.platform.win32.IPHlpAPI.FIXED_INFO;
-import com.sun.jna.platform.win32.IPHlpAPI.IP_ADDR_STRING;
 import com.sun.jna.platform.win32.IPHlpAPI.MIB_IFROW;
 import com.sun.jna.platform.win32.IPHlpAPI.MIB_IF_ROW2;
 import com.sun.jna.ptr.IntByReference;
@@ -121,7 +120,7 @@ public void testGetNetworkParams() {
         assertEquals(WinError.ERROR_SUCCESS, IPHlpAPI.INSTANCE.GetNetworkParams(buffer, bufferSize));
 
         // Check all DNS servers are valid IPs
-        IP_ADDR_STRING dns = buffer.DnsServerList;
+        IPHlpAPI.IP_ADDR_STRING dns = buffer.DnsServerList;
         while (dns != null) {
             // Start with 16-char byte array
             String addr = new String(dns.IpAddress.String);
@@ -132,7 +131,7 @@ public void testGetNetworkParams() {
             }
             // addr is now a dotted-notation IP string. Test valid
             assertTrue(ValidIP.matcher(addr).matches());
-            dns = dns.Next == null ? null : new IP_ADDR_STRING(dns.Next);
+            dns = dns.Next;
         }
     }
 }

File: test/com/sun/jna/DirectCallbacksTest.java
Patch:
@@ -73,7 +73,7 @@ public static class DirectTestLibrary implements TestLibrary {
         @Override
         public native void callVoidCallback(VoidCallback c);
         @Override
-        public native void callVoidCallbackThreaded(VoidCallback c, int count, int ms, String name);
+        public native void callVoidCallbackThreaded(VoidCallback c, int count, int ms, String name, int stacksize);
 
         @Override
         public native int callInt32Callback(CustomCallback cb, int arg1, int arg2);

File: contrib/platform/test/com/sun/jna/platform/win32/IPHlpAPITest.java
Patch:
@@ -37,6 +37,7 @@
 
 import com.sun.jna.Memory;
 import com.sun.jna.platform.win32.IPHlpAPI.FIXED_INFO;
+import com.sun.jna.platform.win32.IPHlpAPI.IP_ADDR_STRING;
 import com.sun.jna.platform.win32.IPHlpAPI.MIB_IFROW;
 import com.sun.jna.platform.win32.IPHlpAPI.MIB_IF_ROW2;
 import com.sun.jna.ptr.IntByReference;
@@ -120,7 +121,7 @@ public void testGetNetworkParams() {
         assertEquals(WinError.ERROR_SUCCESS, IPHlpAPI.INSTANCE.GetNetworkParams(buffer, bufferSize));
 
         // Check all DNS servers are valid IPs
-        IPHlpAPI.IP_ADDR_STRING dns = buffer.DnsServerList;
+        IP_ADDR_STRING dns = buffer.DnsServerList;
         while (dns != null) {
             // Start with 16-char byte array
             String addr = new String(dns.IpAddress.String);
@@ -131,7 +132,7 @@ public void testGetNetworkParams() {
             }
             // addr is now a dotted-notation IP string. Test valid
             assertTrue(ValidIP.matcher(addr).matches());
-            dns = dns.Next;
+            dns = dns.Next == null ? null : new IP_ADDR_STRING(dns.Next);
         }
     }
 }

File: contrib/platform/src/com/sun/jna/platform/win32/WinNT.java
Patch:
@@ -2802,6 +2802,9 @@ public void write() {
 
         @Override
         public void read() {
+            if(SidStart == null) {
+                SidStart = new byte[4];
+            }
             super.read();
             int offsetOfSID = super.fieldOffset("SidStart");
             int sizeOfSID = super.AceSize - super.fieldOffset("SidStart");

File: src/com/sun/jna/win32/DLLCallback.java
Patch:
@@ -33,5 +33,6 @@
  */
 public interface DLLCallback extends Callback {  
     /** Total number of DLL callbacks available for allocation. */
+    @java.lang.annotation.Native
     int DLL_FPTRS = 16;
 }

File: contrib/platform/src/com/sun/jna/platform/win32/COM/IDispatch.java
Patch:
@@ -119,7 +119,7 @@ public HRESULT GetIDsOfNames(REFIID riid, WString[] rgszNames, int cNames,
      * @param pDispParams  Pointer to a DISPPARAMS structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.
      * @param pVarResult   Pointer to the location where the result is to be stored, or NULL if the caller expects no result. This argument is ignored if DISPATCH_PROPERTYPUT or DISPATCH_PROPERTYPUTREF is specified.
      * @param pExcepInfo   Pointer to a structure that contains exception information. This structure should be filled in if DISP_E_EXCEPTION is returned. Can be NULL.
-     * @param puArgErr     The index within rgvarg of the first argument that has an error. Arguments are stored in pDispParams->rgvarg in reverse order,
+     * @param puArgErr     The index within rgvarg of the first argument that has an error. Arguments are stored in pDispParams-&gt;rgvarg in reverse order,
      *                     so the first argument is the one with the highest index in the array. This parameter is returned only when the resulting return
      *                     value is DISP_E_TYPEMISMATCH or DISP_E_PARAMNOTFOUND. This argument can be set to null. For details, see Returning Errors.
      * @return This method can return one of these values.

File: contrib/platform/src/com/sun/jna/platform/win32/COM/IShellFolder.java
Patch:
@@ -295,13 +295,13 @@ HRESULT BindToStorage(
      *            If this method is successful, the CODE field of the HRESULT contains one of the following values. For information regarding the extraction of
      *            the CODE field from the returned HRESULT, see Remarks. If this method is unsuccessful, it returns a COM error code.
      *            Negative
-     *            A negative return value indicates that the first item should precede the second (pidl1 < pidl2).
+     *            A negative return value indicates that the first item should precede the second (pidl1 &lt; pidl2).
      *            Positive
-     *            A positive return value indicates that the first item should follow the second (pidl1 > pidl2).
+     *            A positive return value indicates that the first item should follow the second (pidl1 &gt; pidl2).
      *            Zero
      *            A return value of zero indicates that the two items are the same (pidl1 = pidl2).
      *            Use the HRESULT_CODE macro to extract the CODE field from the HRESULT, then cast the result as a short.
-     *            #define HRESULT_CODE(hr)    ((hr) & 0xFFFF)
+     *            #define HRESULT_CODE(hr)    ((hr) &amp; 0xFFFF)
      *
      */
     HRESULT CompareIDs(

File: contrib/platform/src/com/sun/jna/platform/win32/Ddeml.java
Patch:
@@ -725,7 +725,7 @@ protected List<String> getFieldOrder() {
     public int MSGF_DDEMGR = 0x8001;
 
     /* codepage constants */
-    /** default codepage for windows & old DDE convs. */
+    /** default codepage for windows &amp; old DDE convs. */
     public int CP_WINANSI = 1004;
     /** default codepage for usage from java */
     public int CP_WINUNICODE = 1200;

File: contrib/platform/src/com/sun/jna/platform/win32/GDI32.java
Patch:
@@ -517,7 +517,7 @@ public int GetObject(final HANDLE hgdiobj, final int cbBuffer,
 	 *            OR operator.</td>
 	 *            </tr>
 	 *            <tr>
-	 *            <td><strong>NOMIRRORBITMAP</strong</td>
+	 *            <td><strong>NOMIRRORBITMAP</strong></td>
 	 *            <td>Prevents the bitmap from being mirrored.</td>
 	 *            </tr>
 	 *            <tr>

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32Util.java
Patch:
@@ -924,7 +924,7 @@ public static byte[] getResource(String path, String type, String name) {
      *
      * @param path
      *            The path to the executable file
-     * @return A map of resource type name/ID => resources.<br>
+     * @return A map of resource type name/ID =&gt; resources.<br>
      *         A map key + a single list item + the path to the executable can
      *         be handed off to getResource() to actually get the resource.
      */

File: contrib/platform/src/com/sun/jna/platform/win32/ShTypes.java
Patch:
@@ -57,9 +57,9 @@ public static class ByReference extends UNION implements Structure.ByReference {
          * indicate which union member to use:
          * 
          * <table>
-         * <tr><td>{@link TYPE_WSTR}</td><td>0x0</td><td>Use STRRET.pOleStr</td><td>must be freed by caller of GetDisplayNameOf</td></tr>
-         * <tr><td>{@link TYPE_OFFSET}</td><td>0x1</td><td>Use STRRET.uOffset</td><td>Offset into SHITEMID for ANSI string</td></tr>
-         * <tr><td>{@link TYPE_CSTR}</td><td>0x0</td><td>Use STRRET.cStr</td><td>ANSI Buffer</td></tr>
+         * <tr><td>{@link #TYPE_WSTR}</td><td>0x0</td><td>Use STRRET.pOleStr</td><td>must be freed by caller of GetDisplayNameOf</td></tr>
+         * <tr><td>{@link #TYPE_OFFSET}</td><td>0x1</td><td>Use STRRET.uOffset</td><td>Offset into SHITEMID for ANSI string</td></tr>
+         * <tr><td>{@link #TYPE_CSTR}</td><td>0x0</td><td>Use STRRET.cStr</td><td>ANSI Buffer</td></tr>
          * </table>
          */
         public int uType;

File: contrib/platform/src/com/sun/jna/platform/win32/User32.java
Patch:
@@ -2391,7 +2391,7 @@ HANDLE SetWinEventHook(int eventMin, int eventMax, HMODULE hmodWinEventProc, Win
      *            for example, if you specified 12 or more bytes of extra class
      *            memory, a value of 8 would be an index to the third integer.
      *            To retrieve any other value from the WNDCLASSEX structure,
-     *            specify one of the following values.<br? GCW_ATOM: -32<br>
+     *            specify one of the following values.<br> GCW_ATOM: -32<br>
      *            Retrieves an ATOM value that uniquely identifies the window
      *            class. This is the same atom that the RegisterClassEx function
      *            returns.<br>

File: contrib/platform/src/com/sun/jna/platform/win32/WinNT.java
Patch:
@@ -3496,7 +3496,7 @@ protected List<String> getFieldOrder() {
      *        15                   10 9                       0   bit
      *  </pre>
      * 
-     *  <p>WARNING:  This pattern isn't always follows, Serbina, Bosnian & Croation for example.</p>
+     *  <p>WARNING:  This pattern isn't always follows, Serbina, Bosnian &amp; Croation for example.</p>
      *
      *  <p>It is recommended that applications test for locale names or actual LCIDs.</p>
      *

File: contrib/platform/src/com/sun/jna/platform/win32/Winevt.java
Patch:
@@ -1549,7 +1549,8 @@ public static interface EVT_PUBLISHER_METADATA_PROPERTY_ID {
 
     /**
      * Defines the identifiers that identify the metadata properties of an event definition.
-     * https://msdn.microsoft.com/en-us/library/windows/desktop/aa385517%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
+     * 
+     * @see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa385517%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396">MSDN</a>
      */
     public static interface EVT_EVENT_METADATA_PROPERTY_ID {
 

File: contrib/platform/src/com/sun/jna/platform/win32/WininetUtil.java
Patch:
@@ -43,7 +43,7 @@ public class WininetUtil {
      * Some entries are cookies, some entries are history items, and some are
      * actual files.<br>
      * 
-     * @return A map of cache URL => local file (or URL => empty string for
+     * @return A map of cache URL =&gt; local file (or URL =&gt; empty string for
      *         cookie and history entries)
      */
     public static Map<String, String> getCache() {

File: contrib/platform/src/com/sun/jna/platform/win32/Winsvc.java
Patch:
@@ -765,7 +765,7 @@ interface HandlerEx extends StdCallLibrary.StdCallCallback {
          * request.</li>
          * <li>If your service handles SERVICE_CONTROL_HARDWAREPROFILECHANGE,
          * return NO_ERROR to grant the request and an error code to deny the
-         * request.< </li> <li>If your service handles
+         * request.</li> <li>If your service handles
          * SERVICE_CONTROL_POWEREVENT, return NO_ERROR to grant the request and
          * an error code to deny the request.</li>
          * <li>For all other control codes your service handles, return

File: src/com/sun/jna/Version.java
Patch:
@@ -23,6 +23,6 @@
  */
 package com.sun.jna;
 interface Version {
-    String VERSION = "4.2.0";
-    String VERSION_NATIVE = "5.0.1";
+    String VERSION = "5.0.0-SNAPSHOT";
+    String VERSION_NATIVE = "5.2.1";
 }

File: contrib/platform/src/com/sun/jna/platform/win32/COM/IDispatch.java
Patch:
@@ -119,7 +119,7 @@ public HRESULT GetIDsOfNames(REFIID riid, WString[] rgszNames, int cNames,
      * @param pDispParams  Pointer to a DISPPARAMS structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.
      * @param pVarResult   Pointer to the location where the result is to be stored, or NULL if the caller expects no result. This argument is ignored if DISPATCH_PROPERTYPUT or DISPATCH_PROPERTYPUTREF is specified.
      * @param pExcepInfo   Pointer to a structure that contains exception information. This structure should be filled in if DISP_E_EXCEPTION is returned. Can be NULL.
-     * @param puArgErr     The index within rgvarg of the first argument that has an error. Arguments are stored in pDispParams->rgvarg in reverse order,
+     * @param puArgErr     The index within rgvarg of the first argument that has an error. Arguments are stored in pDispParams-&gt;rgvarg in reverse order,
      *                     so the first argument is the one with the highest index in the array. This parameter is returned only when the resulting return
      *                     value is DISP_E_TYPEMISMATCH or DISP_E_PARAMNOTFOUND. This argument can be set to null. For details, see Returning Errors.
      * @return This method can return one of these values.

File: contrib/platform/src/com/sun/jna/platform/win32/COM/IShellFolder.java
Patch:
@@ -295,13 +295,13 @@ HRESULT BindToStorage(
      *            If this method is successful, the CODE field of the HRESULT contains one of the following values. For information regarding the extraction of
      *            the CODE field from the returned HRESULT, see Remarks. If this method is unsuccessful, it returns a COM error code.
      *            Negative
-     *            A negative return value indicates that the first item should precede the second (pidl1 < pidl2).
+     *            A negative return value indicates that the first item should precede the second (pidl1 &lt; pidl2).
      *            Positive
-     *            A positive return value indicates that the first item should follow the second (pidl1 > pidl2).
+     *            A positive return value indicates that the first item should follow the second (pidl1 &gt; pidl2).
      *            Zero
      *            A return value of zero indicates that the two items are the same (pidl1 = pidl2).
      *            Use the HRESULT_CODE macro to extract the CODE field from the HRESULT, then cast the result as a short.
-     *            #define HRESULT_CODE(hr)    ((hr) & 0xFFFF)
+     *            #define HRESULT_CODE(hr)    ((hr) &amp; 0xFFFF)
      *
      */
     HRESULT CompareIDs(

File: contrib/platform/src/com/sun/jna/platform/win32/Ddeml.java
Patch:
@@ -725,7 +725,7 @@ protected List<String> getFieldOrder() {
     public int MSGF_DDEMGR = 0x8001;
 
     /* codepage constants */
-    /** default codepage for windows & old DDE convs. */
+    /** default codepage for windows &amp; old DDE convs. */
     public int CP_WINANSI = 1004;
     /** default codepage for usage from java */
     public int CP_WINUNICODE = 1200;

File: contrib/platform/src/com/sun/jna/platform/win32/GDI32.java
Patch:
@@ -517,7 +517,7 @@ public int GetObject(final HANDLE hgdiobj, final int cbBuffer,
 	 *            OR operator.</td>
 	 *            </tr>
 	 *            <tr>
-	 *            <td><strong>NOMIRRORBITMAP</strong</td>
+	 *            <td><strong>NOMIRRORBITMAP</strong></td>
 	 *            <td>Prevents the bitmap from being mirrored.</td>
 	 *            </tr>
 	 *            <tr>

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32Util.java
Patch:
@@ -924,7 +924,7 @@ public static byte[] getResource(String path, String type, String name) {
      *
      * @param path
      *            The path to the executable file
-     * @return A map of resource type name/ID => resources.<br>
+     * @return A map of resource type name/ID =&gt; resources.<br>
      *         A map key + a single list item + the path to the executable can
      *         be handed off to getResource() to actually get the resource.
      */

File: contrib/platform/src/com/sun/jna/platform/win32/ShTypes.java
Patch:
@@ -57,9 +57,9 @@ public static class ByReference extends UNION implements Structure.ByReference {
          * indicate which union member to use:
          * 
          * <table>
-         * <tr><td>{@link TYPE_WSTR}</td><td>0x0</td><td>Use STRRET.pOleStr</td><td>must be freed by caller of GetDisplayNameOf</td></tr>
-         * <tr><td>{@link TYPE_OFFSET}</td><td>0x1</td><td>Use STRRET.uOffset</td><td>Offset into SHITEMID for ANSI string</td></tr>
-         * <tr><td>{@link TYPE_CSTR}</td><td>0x0</td><td>Use STRRET.cStr</td><td>ANSI Buffer</td></tr>
+         * <tr><td>{@link #TYPE_WSTR}</td><td>0x0</td><td>Use STRRET.pOleStr</td><td>must be freed by caller of GetDisplayNameOf</td></tr>
+         * <tr><td>{@link #TYPE_OFFSET}</td><td>0x1</td><td>Use STRRET.uOffset</td><td>Offset into SHITEMID for ANSI string</td></tr>
+         * <tr><td>{@link #TYPE_CSTR}</td><td>0x0</td><td>Use STRRET.cStr</td><td>ANSI Buffer</td></tr>
          * </table>
          */
         public int uType;

File: contrib/platform/src/com/sun/jna/platform/win32/User32.java
Patch:
@@ -2391,7 +2391,7 @@ HANDLE SetWinEventHook(int eventMin, int eventMax, HMODULE hmodWinEventProc, Win
      *            for example, if you specified 12 or more bytes of extra class
      *            memory, a value of 8 would be an index to the third integer.
      *            To retrieve any other value from the WNDCLASSEX structure,
-     *            specify one of the following values.<br? GCW_ATOM: -32<br>
+     *            specify one of the following values.<br> GCW_ATOM: -32<br>
      *            Retrieves an ATOM value that uniquely identifies the window
      *            class. This is the same atom that the RegisterClassEx function
      *            returns.<br>

File: contrib/platform/src/com/sun/jna/platform/win32/WinNT.java
Patch:
@@ -3496,7 +3496,7 @@ protected List<String> getFieldOrder() {
      *        15                   10 9                       0   bit
      *  </pre>
      * 
-     *  <p>WARNING:  This pattern isn't always follows, Serbina, Bosnian & Croation for example.</p>
+     *  <p>WARNING:  This pattern isn't always follows, Serbina, Bosnian &amp; Croation for example.</p>
      *
      *  <p>It is recommended that applications test for locale names or actual LCIDs.</p>
      *

File: contrib/platform/src/com/sun/jna/platform/win32/Winevt.java
Patch:
@@ -1549,7 +1549,8 @@ public static interface EVT_PUBLISHER_METADATA_PROPERTY_ID {
 
     /**
      * Defines the identifiers that identify the metadata properties of an event definition.
-     * https://msdn.microsoft.com/en-us/library/windows/desktop/aa385517%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
+     * 
+     * @see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa385517%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396">MSDN</a>
      */
     public static interface EVT_EVENT_METADATA_PROPERTY_ID {
 

File: contrib/platform/src/com/sun/jna/platform/win32/WininetUtil.java
Patch:
@@ -43,7 +43,7 @@ public class WininetUtil {
      * Some entries are cookies, some entries are history items, and some are
      * actual files.<br>
      * 
-     * @return A map of cache URL => local file (or URL => empty string for
+     * @return A map of cache URL =&gt; local file (or URL =&gt; empty string for
      *         cookie and history entries)
      */
     public static Map<String, String> getCache() {

File: contrib/platform/src/com/sun/jna/platform/win32/Winsvc.java
Patch:
@@ -765,7 +765,7 @@ interface HandlerEx extends StdCallLibrary.StdCallCallback {
          * request.</li>
          * <li>If your service handles SERVICE_CONTROL_HARDWAREPROFILECHANGE,
          * return NO_ERROR to grant the request and an error code to deny the
-         * request.< </li> <li>If your service handles
+         * request.</li> <li>If your service handles
          * SERVICE_CONTROL_POWEREVENT, return NO_ERROR to grant the request and
          * an error code to deny the request.</li>
          * <li>For all other control codes your service handles, return

File: src/com/sun/jna/Version.java
Patch:
@@ -12,6 +12,6 @@
  */
 package com.sun.jna;
 interface Version {
-    String VERSION = "4.2.0";
-    String VERSION_NATIVE = "5.0.1";
+    String VERSION = "5.0.0-SNAPSHOT";
+    String VERSION_NATIVE = "5.2.1";
 }

File: contrib/platform/src/com/sun/jna/platform/win32/COM/IShellFolder.java
Patch:
@@ -30,6 +30,7 @@
 import com.sun.jna.Pointer;
 import com.sun.jna.platform.win32.Guid.IID;
 import com.sun.jna.platform.win32.Guid.REFIID;
+import com.sun.jna.platform.win32.ShTypes.STRRET;
 import com.sun.jna.platform.win32.WinDef;
 import com.sun.jna.platform.win32.WinNT;
 import com.sun.jna.platform.win32.WinNT.HRESULT;
@@ -408,7 +409,7 @@ HRESULT GetUIObjectOf(
     HRESULT GetDisplayNameOf(
             Pointer pidl,
             int flags,
-            PointerByReference pName);
+            STRRET pName);
 
     /**
      * Sets the display name of a file object or subfolder, changing the item identifier in the process.
@@ -523,7 +524,7 @@ public HRESULT GetUIObjectOf(WinDef.HWND hwndOwner, int cidl, Pointer apidl, REF
                     return new WinNT.HRESULT( f.invokeInt(new Object[]{interfacePointer, hwndOwner, cidl, apidl, riid, rgfReserved, ppv}));
                 }
 
-                public WinNT.HRESULT GetDisplayNameOf(Pointer pidl, int flags, PointerByReference pName){
+                public WinNT.HRESULT GetDisplayNameOf(Pointer pidl, int flags, STRRET pName){
                     Function f = Function.getFunction(vTable[11], Function.ALT_CONVENTION);
                     return new WinNT.HRESULT( f.invokeInt(new Object[]{interfacePointer, pidl, flags, pName}));
                 }

File: contrib/platform/src/com/sun/jna/platform/win32/Shlwapi.java
Patch:
@@ -28,6 +28,7 @@
 
 import com.sun.jna.Native;
 import com.sun.jna.Pointer;
+import com.sun.jna.platform.win32.ShTypes.STRRET;
 import com.sun.jna.ptr.PointerByReference;
 import com.sun.jna.win32.StdCallLibrary;
 import com.sun.jna.win32.W32APIOptions;
@@ -54,7 +55,7 @@ public interface Shlwapi extends StdCallLibrary {
      * @return If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
      */
 
-    HRESULT StrRetToStr(PointerByReference pstr, Pointer pidl, PointerByReference ppszName);
+    HRESULT StrRetToStr(STRRET pstr, Pointer pidl, PointerByReference ppszName);
 
     /**
      * Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to

File: contrib/platform/src/com/sun/jna/platform/win32/COM/IShellFolder.java
Patch:
@@ -30,6 +30,7 @@
 import com.sun.jna.Pointer;
 import com.sun.jna.platform.win32.Guid.IID;
 import com.sun.jna.platform.win32.Guid.REFIID;
+import com.sun.jna.platform.win32.ShTypes.STRRET;
 import com.sun.jna.platform.win32.WinDef;
 import com.sun.jna.platform.win32.WinNT;
 import com.sun.jna.platform.win32.WinNT.HRESULT;
@@ -408,7 +409,7 @@ HRESULT GetUIObjectOf(
     HRESULT GetDisplayNameOf(
             Pointer pidl,
             int flags,
-            PointerByReference pName);
+            STRRET pName);
 
     /**
      * Sets the display name of a file object or subfolder, changing the item identifier in the process.
@@ -523,7 +524,7 @@ public HRESULT GetUIObjectOf(WinDef.HWND hwndOwner, int cidl, Pointer apidl, REF
                     return new WinNT.HRESULT( f.invokeInt(new Object[]{interfacePointer, hwndOwner, cidl, apidl, riid, rgfReserved, ppv}));
                 }
 
-                public WinNT.HRESULT GetDisplayNameOf(Pointer pidl, int flags, PointerByReference pName){
+                public WinNT.HRESULT GetDisplayNameOf(Pointer pidl, int flags, STRRET pName){
                     Function f = Function.getFunction(vTable[11], Function.ALT_CONVENTION);
                     return new WinNT.HRESULT( f.invokeInt(new Object[]{interfacePointer, pidl, flags, pName}));
                 }

File: contrib/platform/src/com/sun/jna/platform/win32/Shlwapi.java
Patch:
@@ -28,6 +28,7 @@
 
 import com.sun.jna.Native;
 import com.sun.jna.Pointer;
+import com.sun.jna.platform.win32.ShTypes.STRRET;
 import com.sun.jna.ptr.PointerByReference;
 import com.sun.jna.win32.StdCallLibrary;
 import com.sun.jna.win32.W32APIOptions;
@@ -54,7 +55,7 @@ public interface Shlwapi extends StdCallLibrary {
      * @return If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
      */
 
-    HRESULT StrRetToStr(PointerByReference pstr, Pointer pidl, PointerByReference ppszName);
+    HRESULT StrRetToStr(STRRET pstr, Pointer pidl, PointerByReference ppszName);
 
     /**
      * Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to

File: test/com/sun/jna/DirectTest.java
Patch:
@@ -36,7 +36,7 @@
 import java.util.Map;
 
 //@SuppressWarnings("unused")
-public class DirectTest extends TestCase implements Paths, GCWaits {
+public class DirectTest extends TestCase implements Paths {
 
     public static void main(java.lang.String[] argList) {
         junit.textui.TestRunner.run(DirectTest.class);

File: contrib/platform/src/com/sun/jna/platform/win32/COM/COMBindingBaseObject.java
Patch:
@@ -336,6 +336,6 @@ protected HRESULT oleMethod(int nType, VARIANT.ByReference pvResult,
      *            the hr
      */
     protected void checkFailed(HRESULT hr) {
-        COMUtils.checkRC(hr, null, null);
+        COMUtils.checkRC(hr);
     }
 }

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/IConnectionPoint.java
Patch:
@@ -46,5 +46,5 @@ public interface IConnectionPoint {
 	 * @param comEventCallbackInterface - the interface that is being listened to
 	 * @param cookie - the cookie that was returned when advise was called
 	 */
-	void unadvise(Class<?> comEventCallbackInterface, final IComEventCallbackCookie cookie);
+	void unadvise(Class<?> comEventCallbackInterface, final IComEventCallbackCookie cookie) throws COMException;
 }

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/ObjectFactory.java
Patch:
@@ -126,7 +126,7 @@ public <T> T createObject(Class<T> comInterface) {
 	 * Gets and existing COM object (GetActiveObject) for the given progId and
 	 * returns a ProxyObject for the given interface.
 	 */
-	public <T> T fetchObject(Class<T> comInterface) {
+	public <T> T fetchObject(Class<T> comInterface) throws COMException {
                 assert COMUtils.comIsInitialized() : "COM not initialized";
             
                 ComObject comObectAnnotation = comInterface.getAnnotation(ComObject.class);

File: src/com/sun/jna/CallbackReference.java
Patch:
@@ -272,7 +272,7 @@ private CallbackReference(Callback callback, int callingConvention, boolean dire
     private Class<?> getNativeType(Class<?> cls) {
         if (Structure.class.isAssignableFrom(cls)) {
             // Make sure we can instantiate an argument of this type
-            Structure.validate(cls);
+            Structure.validate((Class<? extends Structure>)cls);
             if (!Structure.ByValue.class.isAssignableFrom(cls))
                 return Pointer.class;
         } else if (NativeMapped.class.isAssignableFrom(cls)) {
@@ -580,14 +580,14 @@ else if (Structure.class.isAssignableFrom(dstType)) {
                     // If passed by value, don't hold onto the pointer, which
                     // is only valid for the duration of the callback call
                     if (Structure.ByValue.class.isAssignableFrom(dstType)) {
-                        Structure s = Structure.newInstance(dstType);
+                        Structure s = Structure.newInstance((Class<? extends Structure>) dstType);
                         byte[] buf = new byte[s.size()];
                         ((Pointer)value).read(0, buf, 0, buf.length);
                         s.getPointer().write(0, buf, 0, buf.length);
                         s.read();
                         value = s;
                     } else {
-                        Structure s = Structure.newInstance(dstType, (Pointer)value);
+                        Structure s = Structure.newInstance((Class<? extends Structure>) dstType, (Pointer)value);
                         s.conditionalAutoRead();
                         value = s;
                     }

File: src/com/sun/jna/Native.java
Patch:
@@ -1241,7 +1241,7 @@ public static int getNativeSize(Class<?> type, Object value) {
         }
         if (Structure.class.isAssignableFrom(type)
             && !Structure.ByReference.class.isAssignableFrom(type)) {
-            return Structure.size(type, (Structure)value);
+            return Structure.size((Class<Structure>) type, (Structure)value);
         }
         try {
             return getNativeSize(type);
@@ -1276,7 +1276,7 @@ public static int getNativeSize(Class<?> cls) {
         if (cls == double.class || cls == Double.class) return 8;
         if (Structure.class.isAssignableFrom(cls)) {
             if (Structure.ByValue.class.isAssignableFrom(cls)) {
-                return Structure.size(cls);
+                return Structure.size((Class<? extends Structure>) cls);
             }
             return POINTER_SIZE;
         }

File: test/com/sun/jna/StructureTest.java
Patch:
@@ -281,7 +281,7 @@ public interface SizeTest extends Library {
     private void testStructureSize(int index) {
         try {
             SizeTest lib = Native.loadLibrary("testlib", SizeTest.class);
-            Class<?> cls = Class.forName(getClass().getName() + "$TestStructure" + index);
+            Class<? extends Structure> cls = (Class<? extends Structure>) Class.forName(getClass().getName() + "$TestStructure" + index);
             Structure s = Structure.newInstance(cls);
             assertEquals("Incorrect size for structure " + index + "=>" + s.toString(true), lib.getStructureSize(index), s.size());
         }

File: test/com/sun/jna/NativeTest.java
Patch:
@@ -61,7 +61,7 @@ public void testLoadLibraryMethods() throws Exception {
                 Method m = Native.class.getMethod("loadLibrary", paramTypes);
                 Class<?> returnType = m.getReturnType();
                 signature.append(Native.getSignature(returnType));
-                assertSame("Mismatched return type for signature=" + signature, Object.class, returnType);
+                assertSame("Mismatched return type for signature=" + signature, Library.class, returnType);
 //                System.out.println("===>" + m.getName() + ": " + signature);
             } catch(NoSuchMethodError err) {
                 fail("No method for signature=" + signature);

File: test/com/sun/jna/NativeTest.java
Patch:
@@ -61,7 +61,7 @@ public void testLoadLibraryMethods() throws Exception {
                 Method m = Native.class.getMethod("loadLibrary", paramTypes);
                 Class<?> returnType = m.getReturnType();
                 signature.append(Native.getSignature(returnType));
-                assertSame("Mismatched return type for signature=" + signature, Object.class, returnType);
+                assertSame("Mismatched return type for signature=" + signature, Library.class, returnType);
 //                System.out.println("===>" + m.getName() + ": " + signature);
             } catch(NoSuchMethodError err) {
                 fail("No method for signature=" + signature);

File: contrib/msoffice/src/com/sun/jna/platform/win32/COM/util/office/Excelautomation_KB_219151_Mod.java
Patch:
@@ -142,7 +142,7 @@ private static void displayQuaterlySales(ComIWorksheet sheet) {
             pane.setOptionType(JOptionPane.YES_NO_OPTION);
             JDialog dialog = pane.createDialog("Input...");
             dialog.setAlwaysOnTop(true);
-            dialog.show();
+            dialog.setVisible(true);
             if(((Integer) pane.getValue()) == JOptionPane.YES_OPTION) {
                 break;
             }

File: contrib/platform/src/com/sun/jna/platform/win32/Advapi32.java
Patch:
@@ -2866,7 +2866,8 @@ boolean CreateProcessWithLogonW(String lpUsername, String lpDomain, String lpPas
      *                      service in the process.</p>
      *
      * @param lpHandlerProc A pointer to the handler function to be registered.
-     *                      For more information, see {@link Handler}.
+     *                      For more information, see
+     *                      {@link com.sun.jna.platform.win32.Winsvc.Handler WinSvc.Handler}.
      *
      * @return A service status handle, NULL on error. Call GetLastError to
      * get extended error condition. Possible error codes:

File: contrib/platform/src/com/sun/jna/platform/win32/Ole32.java
Patch:
@@ -447,7 +447,7 @@ HRESULT CoCreateInstance(GUID rclsid, Pointer pUnkOuter, int dwClsContext,
 
     /**
      * Puts an OLE compound document object into the running state.
-     * @param pUnknown [in] Pointer to the {@link IUnknown IUnknown} interface
+     * @param pUnknown [in] Pointer to the {@link com.sun.jna.platform.win32.COM.IUnknown IUnknown} interface
      *                 on the object, with which it will query for a pointer to
      *                 the IRunnableObject interface, and then call its Run method.
      * @return This function returns  on success.

File: contrib/platform/test/com/sun/jna/platform/win32/Kernel32ConsoleTest.java
Patch:
@@ -20,6 +20,7 @@
 import com.sun.jna.platform.win32.WinDef.HWND;
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.ptr.IntByReference;
+import org.junit.Assume;
 
 /**
  * @author lgoldstein
@@ -29,6 +30,8 @@ public class Kernel32ConsoleTest extends AbstractWin32TestSupport {
 
 	@Test
 	public void testGetConsoleDisplayMode() {
+                // If there is no console window, it can't be queried
+                Assume.assumeNotNull(INSTANCE.GetConsoleWindow());
 		IntByReference	curMode=new IntByReference();
 		assertCallSucceeded("Initial display mode value retrieval", INSTANCE.GetConsoleDisplayMode(curMode));
 	}

File: contrib/platform/test/com/sun/jna/platform/win32/Shell32UtilTest.java
Patch:
@@ -70,7 +70,8 @@ public void testGetKnownFolderPath()
         assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_Libraries));
         assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_RoamingAppData));
         assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_UserProfiles));
-        assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_UserProgramFiles));
-        assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_UserProgramFilesCommon));
+        // This is unstable:
+        // assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_UserProgramFiles));
+        // assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_UserProgramFilesCommon));
     }
 }

File: contrib/platform/test/com/sun/jna/platform/win32/User32Test.java
Patch:
@@ -88,6 +88,8 @@ public void testNoDuplicateMethodsNames() {
             for (String name : new String[] {
                     // has 2 overloads since the original API accepts both MONITORINFO and MONITORINFOEX
                     "GetMonitorInfo"
+                    // has 2 overloads since there was a broken binding for MonitorFromPoint
+                    ,"MonitorFromPoint"
                 }) {
                 dupSet.remove(name);
             }
@@ -184,7 +186,7 @@ public final void testRegisterWindowMessage() {
     public final void testMonitorFromPoint() {
         int dwFlags = WinUser.MONITOR_DEFAULTTOPRIMARY;
 
-        POINT pt = new POINT(0, 0);
+        POINT.ByValue pt = new POINT.ByValue(0, 0);
         assertNotNull(User32.INSTANCE.MonitorFromPoint(pt, dwFlags));
     }
 

File: src/com/sun/jna/NativeLibrary.java
Patch:
@@ -947,6 +947,9 @@ else if (Platform.isARM()) {
             cpu = "arm";
             libc = "-gnueabi";
         }
+        else if (Platform.ARCH.equals("mips64el")) {
+            libc = "-gnuabi64";
+        }
 
         return cpu + kernel + libc;
     }

File: test/com/sun/jna/JNALoadTest.java
Patch:
@@ -143,7 +143,8 @@ public void testLoadAndUnloadFromJar() throws Exception {
         // Check for temporary file deletion
         File f = new File(path);
         for (int i=0;i < GC_WAITS && (f.exists() || Boolean.getBoolean("jna.loaded"));i++) {
-            Thread.sleep(GC_WAIT_INTERVAL);
+            System.gc(); // attempt to fix intermittent test failures
+            Thread.sleep(4 * GC_WAIT_INTERVAL);  // '4 *' is attempt to fix intermittent test failures
             System.gc();
         }
 
@@ -186,7 +187,7 @@ public void testLoadAndUnloadFromResourcePath() throws Exception {
         field = null;
         System.gc();
         for (int i=0;i < GC_WAITS && (ref.get() != null || clref.get() != null || Boolean.getBoolean("jna.loaded"));i++) {
-            Thread.sleep(GC_WAIT_INTERVAL);
+            Thread.sleep(2 * GC_WAIT_INTERVAL);  // '2 *' is attempt to fix intermittent test failures 
             System.gc();
         }
         assertNull("Class not GC'd: " + ref.get(), ref.get());

File: contrib/platform/src/com/sun/jna/platform/win32/Ole32.java
Patch:
@@ -447,7 +447,7 @@ HRESULT CoCreateInstance(GUID rclsid, Pointer pUnkOuter, int dwClsContext,
 
     /**
      * Puts an OLE compound document object into the running state.
-     * @param pUnknown [in] Pointer to the {@link IUnknown IUnknown} interface
+     * @param pUnknown [in] Pointer to the {@link com.sun.jna.platform.win32.COM.IUnknown IUnknown} interface
      *                 on the object, with which it will query for a pointer to
      *                 the IRunnableObject interface, and then call its Run method.
      * @return This function returns  on success.

File: contrib/platform/test/com/sun/jna/platform/win32/Kernel32ConsoleTest.java
Patch:
@@ -20,6 +20,7 @@
 import com.sun.jna.platform.win32.WinDef.HWND;
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.ptr.IntByReference;
+import org.junit.Assume;
 
 /**
  * @author lgoldstein
@@ -29,6 +30,8 @@ public class Kernel32ConsoleTest extends AbstractWin32TestSupport {
 
 	@Test
 	public void testGetConsoleDisplayMode() {
+                // If there is no console window, it can't be queried
+                Assume.assumeNotNull(INSTANCE.GetConsoleWindow());
 		IntByReference	curMode=new IntByReference();
 		assertCallSucceeded("Initial display mode value retrieval", INSTANCE.GetConsoleDisplayMode(curMode));
 	}

File: contrib/platform/test/com/sun/jna/platform/win32/Shell32UtilTest.java
Patch:
@@ -70,7 +70,8 @@ public void testGetKnownFolderPath()
         assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_Libraries));
         assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_RoamingAppData));
         assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_UserProfiles));
-        assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_UserProgramFiles));
-        assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_UserProgramFilesCommon));
+        // This is unstable:
+        // assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_UserProgramFiles));
+        // assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_UserProgramFilesCommon));
     }
 }

File: contrib/platform/test/com/sun/jna/platform/win32/User32Test.java
Patch:
@@ -88,6 +88,8 @@ public void testNoDuplicateMethodsNames() {
             for (String name : new String[] {
                     // has 2 overloads since the original API accepts both MONITORINFO and MONITORINFOEX
                     "GetMonitorInfo"
+                    // has 2 overloads since there was a broken binding for MonitorFromPoint
+                    ,"MonitorFromPoint"
                 }) {
                 dupSet.remove(name);
             }
@@ -184,7 +186,7 @@ public final void testRegisterWindowMessage() {
     public final void testMonitorFromPoint() {
         int dwFlags = WinUser.MONITOR_DEFAULTTOPRIMARY;
 
-        POINT pt = new POINT(0, 0);
+        POINT.ByValue pt = new POINT.ByValue(0, 0);
         assertNotNull(User32.INSTANCE.MonitorFromPoint(pt, dwFlags));
     }
 

File: contrib/platform/test/com/sun/jna/platform/win32/Kernel32ConsoleTest.java
Patch:
@@ -20,6 +20,7 @@
 import com.sun.jna.platform.win32.WinDef.HWND;
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.ptr.IntByReference;
+import org.junit.Assume;
 
 /**
  * @author lgoldstein
@@ -29,6 +30,8 @@ public class Kernel32ConsoleTest extends AbstractWin32TestSupport {
 
 	@Test
 	public void testGetConsoleDisplayMode() {
+                // If there is no console window, it can't be queried
+                Assume.assumeNotNull(INSTANCE.GetConsoleWindow());
 		IntByReference	curMode=new IntByReference();
 		assertCallSucceeded("Initial display mode value retrieval", INSTANCE.GetConsoleDisplayMode(curMode));
 	}

File: contrib/platform/test/com/sun/jna/platform/win32/Shell32UtilTest.java
Patch:
@@ -70,7 +70,8 @@ public void testGetKnownFolderPath()
         assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_Libraries));
         assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_RoamingAppData));
         assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_UserProfiles));
-        assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_UserProgramFiles));
-        assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_UserProgramFilesCommon));
+        // This is unstable:
+        // assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_UserProgramFiles));
+        // assertNotNull(Shell32Util.getKnownFolderPath(KnownFolders.FOLDERID_UserProgramFilesCommon));
     }
 }

File: contrib/platform/test/com/sun/jna/platform/win32/User32Test.java
Patch:
@@ -88,6 +88,8 @@ public void testNoDuplicateMethodsNames() {
             for (String name : new String[] {
                     // has 2 overloads since the original API accepts both MONITORINFO and MONITORINFOEX
                     "GetMonitorInfo"
+                    // has 2 overloads since there was a broken binding for MonitorFromPoint
+                    ,"MonitorFromPoint"
                 }) {
                 dupSet.remove(name);
             }
@@ -184,7 +186,7 @@ public final void testRegisterWindowMessage() {
     public final void testMonitorFromPoint() {
         int dwFlags = WinUser.MONITOR_DEFAULTTOPRIMARY;
 
-        POINT pt = new POINT(0, 0);
+        POINT.ByValue pt = new POINT.ByValue(0, 0);
         assertNotNull(User32.INSTANCE.MonitorFromPoint(pt, dwFlags));
     }
 

File: contrib/platform/src/com/sun/jna/platform/win32/Ole32.java
Patch:
@@ -447,7 +447,7 @@ HRESULT CoCreateInstance(GUID rclsid, Pointer pUnkOuter, int dwClsContext,
 
     /**
      * Puts an OLE compound document object into the running state.
-     * @param pUnknown [in] Pointer to the {@link IUnknown IUnknown} interface
+     * @param pUnknown [in] Pointer to the {@link com.sun.jna.platform.win32.COM.IUnknown IUnknown} interface
      *                 on the object, with which it will query for a pointer to
      *                 the IRunnableObject interface, and then call its Run method.
      * @return This function returns  on success.

File: test/com/sun/jna/JNALoadTest.java
Patch:
@@ -143,7 +143,7 @@ public void testLoadAndUnloadFromJar() throws Exception {
         // Check for temporary file deletion
         File f = new File(path);
         for (int i=0;i < GC_WAITS && (f.exists() || Boolean.getBoolean("jna.loaded"));i++) {
-            Thread.sleep(GC_WAIT_INTERVAL);
+            Thread.sleep(2 * GC_WAIT_INTERVAL);  // '2 *' is attempt to fix intermittent test failures
             System.gc();
         }
 
@@ -186,7 +186,7 @@ public void testLoadAndUnloadFromResourcePath() throws Exception {
         field = null;
         System.gc();
         for (int i=0;i < GC_WAITS && (ref.get() != null || clref.get() != null || Boolean.getBoolean("jna.loaded"));i++) {
-            Thread.sleep(GC_WAIT_INTERVAL);
+            Thread.sleep(2 * GC_WAIT_INTERVAL);  // '2 *' is attempt to fix intermittent test failures 
             System.gc();
         }
         assertNull("Class not GC'd: " + ref.get(), ref.get());

File: contrib/platform/src/com/sun/jna/platform/win32/WTypes.java
Patch:
@@ -157,7 +157,7 @@ public String toString() {
 
     public class BSTRByReference extends ByReference {
         public BSTRByReference() {
-            super(Pointer.SIZE);
+            super(Native.POINTER_SIZE);
         }
 
         public BSTRByReference(BSTR value) {

File: contrib/platform/src/com/sun/jna/platform/win32/WinBase.java
Patch:
@@ -50,7 +50,7 @@ public interface WinBase extends WinDef, BaseTSD {
 
     /** Constant value representing an invalid HANDLE. */
     HANDLE INVALID_HANDLE_VALUE =
-        new HANDLE(Pointer.createConstant(Pointer.SIZE == 8
+        new HANDLE(Pointer.createConstant(Native.POINTER_SIZE == 8
                                           ? -1 : 0xFFFFFFFFL));
 
     int WAIT_FAILED = 0xFFFFFFFF;

File: contrib/platform/src/com/sun/jna/platform/win32/WinNT.java
Patch:
@@ -394,7 +394,7 @@ public PSIDByReference() {
         }
 
         public PSIDByReference(PSID h) {
-            super(Pointer.SIZE);
+            super(Native.POINTER_SIZE);
             setValue(h);
         }
 
@@ -1393,7 +1393,7 @@ public HANDLEByReference() {
         }
 
         public HANDLEByReference(HANDLE h) {
-            super(Pointer.SIZE);
+            super(Native.POINTER_SIZE);
             setValue(h);
         }
 
@@ -2605,7 +2605,7 @@ public PACLByReference() {
         }
 
         public PACLByReference(ACL h) {
-            super(Pointer.SIZE);
+            super(Native.POINTER_SIZE);
             setValue(h);
         }
 

File: contrib/platform/src/com/sun/jna/platform/win32/WinReg.java
Patch:
@@ -23,6 +23,7 @@
  */
 package com.sun.jna.platform.win32;
 
+import com.sun.jna.Native;
 import com.sun.jna.Pointer;
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.ptr.ByReference;
@@ -48,7 +49,7 @@ public HKEYByReference() {
         }
         
         public HKEYByReference(HKEY h) {
-            super(Pointer.SIZE);
+            super(Native.POINTER_SIZE);
             setValue(h);
         }
         

File: contrib/platform/src/com/sun/jna/platform/win32/WinUser.java
Patch:
@@ -27,6 +27,7 @@
 import java.util.List;
 
 import com.sun.jna.Callback;
+import com.sun.jna.Native;
 import com.sun.jna.Pointer;
 import com.sun.jna.Structure;
 import com.sun.jna.Union;
@@ -198,9 +199,9 @@ protected List<String> getFieldOrder() {
     int GWL_USERDATA = -21;
     int GWL_HWNDPARENT = -8;
 
-    int DWL_DLGPROC = Pointer.SIZE;
+    int DWL_DLGPROC = Native.POINTER_SIZE;
     int DWL_MSGRESULT = 0;
-    int DWL_USER = 2*Pointer.SIZE;
+    int DWL_USER = 2*Native.POINTER_SIZE;
 
     /* Window Styles */
 

File: src/com/sun/jna/CallbackReference.java
Patch:
@@ -363,7 +363,7 @@ private static Method getCallbackMethod(Class<?> cls) {
 
     /** Set the behavioral options for this callback. */
     private void setCallbackOptions(int options) {
-        cbstruct.setInt(Pointer.SIZE, options);
+        cbstruct.setInt(Native.POINTER_SIZE, options);
     }
 
     /** Obtain a pointer to the native glue code for this callback. */

File: src/com/sun/jna/Memory.java
Patch:
@@ -537,7 +537,7 @@ public double getDouble(long offset) {
      */
     @Override
     public Pointer getPointer(long offset) {
-        boundsCheck(offset, Pointer.SIZE);
+        boundsCheck(offset, Native.POINTER_SIZE);
         return super.getPointer(offset);
     }
 
@@ -689,7 +689,7 @@ public void setDouble(long offset, double value) {
      */
     @Override
     public void setPointer(long offset, Pointer value) {
-        boundsCheck(offset, Pointer.SIZE);
+        boundsCheck(offset, Native.POINTER_SIZE);
         super.setPointer(offset, value);
     }
 

File: src/com/sun/jna/NativeLibrary.java
Patch:
@@ -870,7 +870,7 @@ static double parseVersion(String ver) {
             if (Platform.isLinux() || Platform.isSolaris()
                 || Platform.isFreeBSD() || Platform.iskFreeBSD()) {
                 // Linux & FreeBSD use /usr/lib32, solaris uses /usr/lib/32
-                archPath = (Platform.isSolaris() ? "/" : "") + Pointer.SIZE * 8;
+                archPath = (Platform.isSolaris() ? "/" : "") + Native.POINTER_SIZE * 8;
             }
             String[] paths = {
                 "/usr/lib" + archPath,

File: src/com/sun/jna/Structure.java
Patch:
@@ -1411,11 +1411,11 @@ else if ((Pointer.class.isAssignableFrom(type) && !Function.class.isAssignableFr
                  || Callback.class.isAssignableFrom(type)
                  || WString.class == type
                  || String.class == type) {
-            alignment = Pointer.SIZE;
+            alignment = Native.POINTER_SIZE;
         }
         else if (Structure.class.isAssignableFrom(type)) {
             if (ByReference.class.isAssignableFrom(type)) {
-                alignment = Pointer.SIZE;
+                alignment = Native.POINTER_SIZE;
             }
             else {
                 if (value == null)
@@ -1968,7 +1968,7 @@ protected List<String> getFieldOrder() {
             return Arrays.asList(new String[] { "size", "alignment", "type", "elements" });
         }
         private void init(Pointer[] els) {
-            elements = new Memory(Pointer.SIZE * els.length);
+            elements = new Memory(Native.POINTER_SIZE * els.length);
             elements.write(0, els, 0, els.length);
             write();
         }

File: src/com/sun/jna/ptr/PointerByReference.java
Patch:
@@ -23,6 +23,7 @@
  */
 package com.sun.jna.ptr;
 
+import com.sun.jna.Native;
 import com.sun.jna.Pointer;
 
 /** Represents a reference to a pointer to native data. 
@@ -36,7 +37,7 @@ public PointerByReference() {
     }
     
     public PointerByReference(Pointer value) {
-        super(Pointer.SIZE);
+        super(Native.POINTER_SIZE);
         setValue(value);
     }
     

File: src/com/sun/jna/win32/StdCallFunctionMapper.java
Patch:
@@ -49,7 +49,7 @@ protected int getArgumentNativeStackSize(Class<?> cls) {
             cls = NativeMappedConverter.getInstance(cls).nativeType();
         }
         if (cls.isArray()) {
-            return Pointer.SIZE;
+            return Native.POINTER_SIZE;
         }
         try {
             return Native.getNativeSize(cls);

File: test/com/sun/jna/HeadlessLoadLibraryTest.java
Patch:
@@ -28,7 +28,7 @@ public class HeadlessLoadLibraryTest extends TestCase {
     
     public void testLoadWhenHeadless() {
         System.setProperty("java.awt.headless", "true");
-        assertTrue("Pointer size must not be zero", Pointer.SIZE > 0);
+        assertTrue("Pointer size must not be zero", Native.POINTER_SIZE > 0);
     }
     
     public static void main(String[] args) {

File: test/com/sun/jna/LibraryLoadTest.java
Patch:
@@ -47,7 +47,7 @@ public TestLoader(File path) throws MalformedURLException {
     }
 
     public void testLoadJNALibrary() {
-        assertTrue("Pointer size should never be zero", Pointer.SIZE > 0);
+        assertTrue("Pointer size should never be zero", Native.POINTER_SIZE > 0);
     }
 
     public void testLoadJAWT() {
@@ -65,7 +65,7 @@ public void testLoadAWTAfterJNA() {
 
         if (GraphicsEnvironment.isHeadless()) return;
 
-        if (Pointer.SIZE > 0) {
+        if (Native.POINTER_SIZE > 0) {
             Toolkit.getDefaultToolkit();
         }
     }

File: test/com/sun/jna/StructureBufferFieldTest.java
Patch:
@@ -74,7 +74,7 @@ public void testBufferFieldReadUnchanged() {
     public void testBufferFieldReadChanged() {
         if (!Platform.HAS_BUFFERS) return;
         BufferStructure bs = new BufferStructure();
-        if (Pointer.SIZE == 4) {
+        if (Native.POINTER_SIZE == 4) {
             bs.getPointer().setInt(0, 0x1);
         }
         else {

File: test/com/sun/jna/UnionTest.java
Patch:
@@ -92,7 +92,7 @@ public void testCalculateSize() {
 
     public void testFieldOffsets() {
         StructUnion u = new StructUnion();
-        assertEquals("Wrong union size: " + u, Pointer.SIZE, u.size());
+        assertEquals("Wrong union size: " + u, Native.POINTER_SIZE, u.size());
         u.setType(u.testStruct.getClass());
         u.write();
         assertEquals("Wrong struct member base address",
@@ -132,7 +132,7 @@ public void testWriteTypedUnion() {
         final int VALUE = 0x12345678;
         // write an instance of a direct union class to memory
         StructUnion u = new StructUnion();
-        assertEquals("Wrong union size: " + u, Pointer.SIZE, u.size());
+        assertEquals("Wrong union size: " + u, Native.POINTER_SIZE, u.size());
         IntStructure intStruct = new IntStructure();
         intStruct.value = VALUE;
         u.setTypedValue(intStruct);
@@ -158,7 +158,7 @@ public void callback() {
 
     public void testReadTypedUnion() {
         StructUnion u = new StructUnion();
-        assertEquals("Wrong union size: " + u, Pointer.SIZE, u.size());
+        assertEquals("Wrong union size: " + u, Native.POINTER_SIZE, u.size());
         final int VALUE = 0x12345678;
         u.getPointer().setInt(0, VALUE);
         assertEquals("int structure not read properly", VALUE, ((IntStructure) u.getTypedValue(IntStructure.class)).value);

File: test/com/sun/jna/VMCrashProtectionTest.java
Patch:
@@ -40,8 +40,8 @@ public void testAccessViolation() {
         if (!Native.isProtected())
             return;
         
-        Memory m = new Memory(Pointer.SIZE);
-        if (Pointer.SIZE == 4)
+        Memory m = new Memory(Native.POINTER_SIZE);
+        if (Native.POINTER_SIZE == 4)
             m.setInt(0, 1);
         else
             m.setLong(0, 1);

File: src/com/sun/jna/Native.java
Patch:
@@ -161,7 +161,7 @@ public static float parseVersion(String v) {
      * 
      * @param expectedVersion
      * @param nativeVersion
-     * @return 
+     * @return true if nativeVersion describes a version compatible to expectedVersion
      */
     static boolean isCompatibleVersion(String expectedVersion, String nativeVersion) {
         String[] expectedVersionParts = expectedVersion.split("\\.");

File: test/com/sun/jna/VarArgsTest.java
Patch:
@@ -43,7 +43,7 @@ protected List<String> getFieldOrder() {
         public int addVarArgs(String fmt, Number... args);
         public String returnStringVarArgs(String fmt, Object... args);
         public void modifyStructureVarArgs(String fmt, Object arg1, Object... args);
-        public String returnStringVarArgs(String... args);
+        public String returnStringVarArgs2(String... args);
     }
     TestLibrary lib;
     @Override
@@ -93,7 +93,7 @@ public void testStringVarArgs() {
     public void testStringVarArgsFull() {
         Object[] args = new Object[] { "Test" };
         assertEquals("Did not return correct string", args[0],
-                     lib.returnStringVarArgs("", "Test"));
+                     lib.returnStringVarArgs2("", "Test"));
     }
 
     public void testAppendNullToVarargs() {

File: contrib/platform/src/com/sun/jna/platform/win32/Ddeml.java
Patch:
@@ -2561,6 +2561,7 @@ public HDDEDATA DdeCreateDataHandle(
     public int DdeGetData(HDDEDATA hData, Pointer pDst, int cbMax, int cbOff);
 
     /**
+     * Provides access to the data in the specified Dynamic Data Exchange (DDE) object.
      * An application must call the DdeUnaccessData function when it has
      * finished accessing the data in the object.
      *

File: contrib/platform/src/com/sun/jna/platform/win32/DdemlUtil.java
Patch:
@@ -731,7 +731,7 @@ public Ddeml.HDDEDATA createDataHandle(Pointer pSrc, int cb, int cbOff, Ddeml.HS
         }
 
         public void freeDataHandle(Ddeml.HDDEDATA hData) {
-            boolean result = Ddeml.INSTANCE.DdeUnaccessData(hData);
+            boolean result = Ddeml.INSTANCE.DdeFreeDataHandle(hData);
             if(! result) {
                 throw DdemlException.create(getLastError());
             }

File: src/com/sun/jna/Function.java
Patch:
@@ -327,10 +327,11 @@ Object invoke(Method invokingMethod, Class<?>[] paramTypes, Class<?> returnType,
 
         TypeMapper mapper = (TypeMapper)options.get(Library.OPTION_TYPE_MAPPER);
         boolean allowObjects = Boolean.TRUE.equals(options.get(Library.OPTION_ALLOW_OBJECTS));
+        boolean isVarArgs = args.length > 0 && invokingMethod != null ? isVarArgs(invokingMethod) : false;
         int fixedArgs = args.length > 0 && invokingMethod != null ? fixedArgs(invokingMethod) : 0;
         for (int i=0; i < args.length; i++) {
             Class<?> paramType = invokingMethod != null
-                ? (fixedArgs > 0 && i >= paramTypes.length-1
+                ? (isVarArgs && i >= paramTypes.length-1
                    ? paramTypes[paramTypes.length-1].getComponentType()
                    : paramTypes[i])
                 : null;

File: src/com/sun/jna/Function.java
Patch:
@@ -327,10 +327,11 @@ Object invoke(Method invokingMethod, Class<?>[] paramTypes, Class<?> returnType,
 
         TypeMapper mapper = (TypeMapper)options.get(Library.OPTION_TYPE_MAPPER);
         boolean allowObjects = Boolean.TRUE.equals(options.get(Library.OPTION_ALLOW_OBJECTS));
+        boolean isVarArgs = args.length > 0 && invokingMethod != null ? isVarArgs(invokingMethod) : false;
         int fixedArgs = args.length > 0 && invokingMethod != null ? fixedArgs(invokingMethod) : 0;
         for (int i=0; i < args.length; i++) {
             Class<?> paramType = invokingMethod != null
-                ? (fixedArgs > 0 && i >= paramTypes.length-1
+                ? (isVarArgs && i >= paramTypes.length-1
                    ? paramTypes[paramTypes.length-1].getComponentType()
                    : paramTypes[i])
                 : null;

File: contrib/platform/src/com/sun/jna/platform/win32/WinNT.java
Patch:
@@ -2778,6 +2778,7 @@ public ACCESS_ACEStructure(int Mask, byte AceType, byte AceFlags, PSID psid) {
             this.AceSize = (short) (super.fieldOffset("SidStart") + psid.getBytes().length);
             this.psid = psid;
             this.Mask = Mask;
+            this.SidStart = psid.getPointer().getByteArray(0, SidStart.length);
             this.allocateMemory(AceSize);
             write();
         }
@@ -2792,6 +2793,7 @@ public ACCESS_ACEStructure(Pointer p) {
          */
         @Override
         public void write() {
+            super.write();
             int offsetOfSID = super.fieldOffset("SidStart");
             int sizeOfSID = super.AceSize - super.fieldOffset("SidStart");
             if(psid != null) {

File: contrib/platform/src/com/sun/jna/platform/win32/Advapi32Util.java
Patch:
@@ -391,7 +391,7 @@ public static int alignOnDWORD(int cbAcl) {
 
 	/**
      * Helper function to calculate the size of an ACE for a given PSID size
-     * @param pSid the PSID
+     * @param sidLength length of the sid
      * @return size of the ACE
      */
     public static int getAceSize(int sidLength) {

File: contrib/platform/src/com/sun/jna/platform/win32/User32Util.java
Patch:
@@ -241,7 +241,7 @@ public void exit() {
         
         /**
          * The method is called from the thread, that run the message dispatcher,
-         * when the call to {@see com.sun.jna.platform.win32.User32#GetMessage}
+         * when the call to {@link com.sun.jna.platform.win32.User32#GetMessage}
          * fails (returns {@code -1}).
          * 
          * <p>If the method returns {@code true}, the MainLoop is exitted, if it 

File: contrib/platform/src/com/sun/jna/platform/win32/WinNT.java
Patch:
@@ -3113,9 +3113,9 @@ public class SECURITY_QUALITY_OF_SERVICE extends Structure {
          * Specifies whether the server is to be given a snapshot of the
          * client's security context (called static tracking), or is to be
          * continually updated to track changes to the client's security context
-         * (called dynamic tracking). The {@link WinNT.SECURITY_STATIC_TRACKING}
+         * (called dynamic tracking). The {@link WinNT#SECURITY_STATIC_TRACKING}
          * value specifies static tracking, and the
-         * {@link WinNT.SECURITY_DYNAMIC_TRACKING} value specifies dynamic
+         * {@link WinNT#SECURITY_DYNAMIC_TRACKING} value specifies dynamic
          * tracking. Not all communications mechanisms support dynamic tracking;
          * those that do not will default to static tracking.
          */

File: contrib/platform/src/com/sun/jna/platform/win32/WinUser.java
Patch:
@@ -1843,7 +1843,7 @@ public String toString() {
      */
     public int CF_GDIOBJFIRST = 0x0300;
     /**
-     * @see WinUser.CF_GDIOBJFIRST
+     * @see WinUser#CF_GDIOBJFIRST
      */
     public int CF_GDIOBJLAST = 0x03FF;
     /**
@@ -1920,7 +1920,7 @@ public String toString() {
      */
     public int CF_PRIVATEFIRST = 0x0200;
     /**
-     * @see WinDef.CF_PRIVATEFIRST.
+     * @see WinUser#CF_PRIVATEFIRST
      */
     public int CF_PRIVATELAST = 0x02FF;
     /**

File: src/com/sun/jna/Native.java
Patch:
@@ -1908,8 +1908,6 @@ static synchronized native long createNativeCallback(Callback callback,
      * @param fp        function pointer
      * @param callFlags calling convention to be used
      * @param args      Arguments to pass to the native function
-     *
-     * @return The value returned by the target native function
      */
     static native void invokeVoid(Function function, long fp, int callFlags, Object[] args);
 

File: contrib/platform/src/com/sun/jna/platform/win32/User32Util.java
Patch:
@@ -241,7 +241,7 @@ public void exit() {
         
         /**
          * The method is called from the thread, that run the message dispatcher,
-         * when the call to {@see com.sun.jna.platform.win32.User32#GetMessage}
+         * when the call to {@link com.sun.jna.platform.win32.User32#GetMessage}
          * fails (returns {@code -1}).
          * 
          * <p>If the method returns {@code true}, the MainLoop is exitted, if it 

File: contrib/platform/src/com/sun/jna/platform/win32/WinNT.java
Patch:
@@ -3113,9 +3113,9 @@ public class SECURITY_QUALITY_OF_SERVICE extends Structure {
          * Specifies whether the server is to be given a snapshot of the
          * client's security context (called static tracking), or is to be
          * continually updated to track changes to the client's security context
-         * (called dynamic tracking). The {@link WinNT.SECURITY_STATIC_TRACKING}
+         * (called dynamic tracking). The {@link WinNT#SECURITY_STATIC_TRACKING}
          * value specifies static tracking, and the
-         * {@link WinNT.SECURITY_DYNAMIC_TRACKING} value specifies dynamic
+         * {@link WinNT#SECURITY_DYNAMIC_TRACKING} value specifies dynamic
          * tracking. Not all communications mechanisms support dynamic tracking;
          * those that do not will default to static tracking.
          */

File: contrib/platform/src/com/sun/jna/platform/win32/WinUser.java
Patch:
@@ -1843,7 +1843,7 @@ public String toString() {
      */
     public int CF_GDIOBJFIRST = 0x0300;
     /**
-     * @see WinUser.CF_GDIOBJFIRST
+     * @see WinUser#CF_GDIOBJFIRST
      */
     public int CF_GDIOBJLAST = 0x03FF;
     /**
@@ -1920,7 +1920,7 @@ public String toString() {
      */
     public int CF_PRIVATEFIRST = 0x0200;
     /**
-     * @see WinDef.CF_PRIVATEFIRST.
+     * @see WinUser#CF_PRIVATEFIRST
      */
     public int CF_PRIVATELAST = 0x02FF;
     /**

File: src/com/sun/jna/Native.java
Patch:
@@ -1908,8 +1908,6 @@ static synchronized native long createNativeCallback(Callback callback,
      * @param fp        function pointer
      * @param callFlags calling convention to be used
      * @param args      Arguments to pass to the native function
-     *
-     * @return The value returned by the target native function
      */
     static native void invokeVoid(Function function, long fp, int callFlags, Object[] args);
 

File: contrib/platform/src/com/sun/jna/platform/win32/Variant.java
Patch:
@@ -295,7 +295,7 @@ public void setValue(int vt, Object value) {
         }
         
         public void setValue(SAFEARRAY array) {
-            this.setValue(array.getVarType().intValue() | VT_SAFEARRAY, array);
+            this.setValue(array.getVarType().intValue() | VT_ARRAY, array);
         }
 
         public void setValue(VARTYPE vt, Object value) {
@@ -428,7 +428,7 @@ public void setValue(VARTYPE vt, Object value) {
                 this._variant.__variant.writeField("pvRecord", value);
                 break;
             default:
-                if ((varType & VT_ARRAY) > 0 || (varType & VT_SAFEARRAY) > 0) {
+                if ((varType & VT_ARRAY) > 0) {
                     if ((varType & VT_BYREF) > 0) {
                         this._variant.__variant.writeField("pparray", value);
                     } else {
@@ -530,7 +530,7 @@ public Object getValue() {
             case VT_RECORD:
                 return this._variant.__variant.readField("pvRecord");
             default:
-                if((varType & VT_ARRAY) > 0 || ((varType & VT_SAFEARRAY) > 0)) {
+                if((varType & VT_ARRAY) > 0) {
                     if((varType & VT_BYREF) > 0) {
                         return this._variant.__variant.readField("pparray");
                     } else {

File: contrib/platform/test/com/sun/jna/platform/win32/VariantTest.java
Patch:
@@ -247,7 +247,7 @@ public void testVariantSafearrayWrapping() {
         SAFEARRAY safearray = OaIdl.SAFEARRAY.createSafeArray(new VARTYPE(Variant.VT_I1), 5);
         try {
             VARIANT variant = new VARIANT(safearray);
-            assertThat(variant.getVarType().intValue(), equalTo((int) (Variant.VT_I1 | Variant.VT_SAFEARRAY)));
+            assertThat(variant.getVarType().intValue(), equalTo((int) (Variant.VT_I1 | Variant.VT_ARRAY)));
             Object wrappedValue = variant.getValue();
             assertThat(wrappedValue, instanceOf(SAFEARRAY.class));
             assertThat(safearray.getUBound(0), is(4));

File: test/com/sun/jna/PerformanceTest.java
Patch:
@@ -337,7 +337,7 @@ public String getFunctionName(NativeLibrary library, Method method) {
 
         start = System.currentTimeMillis();
         for (int i=0;i < COUNT;i++) {
-            Native.setMemory(0L, 0L, (byte)0);
+            Native.setMemory(Pointer.NULL, 0L, 0L, 0L, (byte)0);
         }
         delta = System.currentTimeMillis() - start;
         System.out.println("memset (JNI): " + delta + "ms");

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32Util.java
Patch:
@@ -421,7 +421,7 @@ public static Map<String,String> getEnvironmentVariables(Pointer lpszEnvironment
         if (lpszEnvironmentBlock == null) {
             return null;
         }
-
+        
         Map<String,String>  vars=new TreeMap<String,String>();
         boolean             asWideChars=isWideCharEnvironmentStringBlock(lpszEnvironmentBlock, offset);
         long                stepFactor=asWideChars ? 2L : 1L;

File: contrib/platform/src/com/sun/jna/platform/win32/WinCrypt.java
Patch:
@@ -19,6 +19,7 @@
 import com.sun.jna.Pointer;
 import com.sun.jna.Structure;
 import com.sun.jna.platform.win32.WinDef.HWND;
+import com.sun.jna.win32.W32APITypeMapper;
 
 /**
  * Ported from WinCrypt.h.
@@ -101,11 +102,11 @@ public static class CRYPTPROTECT_PROMPTSTRUCT extends Structure {
         public String szPrompt;
 
         public CRYPTPROTECT_PROMPTSTRUCT() {
-            super();
+            super(W32APITypeMapper.DEFAULT);
         }
 
         public CRYPTPROTECT_PROMPTSTRUCT(Pointer memory) {
-            super(memory);
+            super(memory, Structure.ALIGN_DEFAULT, W32APITypeMapper.DEFAULT);
             read();
         }
 

File: contrib/platform/src/com/sun/jna/platform/win32/WinUser.java
Patch:
@@ -22,6 +22,7 @@
 import com.sun.jna.platform.win32.BaseTSD.ULONG_PTR;
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.win32.StdCallLibrary.StdCallCallback;
+import com.sun.jna.win32.W32APITypeMapper;
 
 /**
  * Ported from WinUser.h Microsoft Windows SDK 6.0A.
@@ -1166,6 +1167,7 @@ public static class ByReference extends WNDCLASSEX implements
          * Instantiates a new wndclassex.
          */
         public WNDCLASSEX() {
+            super(W32APITypeMapper.DEFAULT);
         }
 
         /**
@@ -1175,7 +1177,7 @@ public WNDCLASSEX() {
          *            the memory
          */
         public WNDCLASSEX(Pointer memory) {
-            super(memory);
+            super(memory, Structure.ALIGN_DEFAULT, W32APITypeMapper.DEFAULT);
             read();
         }
 

File: contrib/platform/src/com/sun/jna/platform/win32/Winsvc.java
Patch:
@@ -18,7 +18,6 @@
 import com.sun.jna.Memory;
 import com.sun.jna.Pointer;
 import com.sun.jna.Structure;
-import com.sun.jna.TypeMapper;
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.win32.W32APITypeMapper;
 

File: contrib/platform/test/com/sun/jna/platform/win32/Advapi32Test.java
Patch:
@@ -189,7 +189,9 @@ public void testLookupAccountSid() {
     		String nameString = Native.toString(name);
     		String referencedDomainNameString = Native.toString(referencedDomainName);
     		assertTrue(nameString.length() > 0);
-    		assertEquals("Everyone", nameString);
+                if(AbstractWin32TestSupport.isEnglishLocale) {
+                    assertEquals("Everyone", nameString);
+                }
     		assertTrue(referencedDomainNameString.length() == 0);
     	} finally {
     	    Kernel32Util.freeLocalMemory(value.getPointer());

File: contrib/platform/test/com/sun/jna/platform/win32/Kernel32Test.java
Patch:
@@ -380,7 +380,7 @@ public void testGetTickCount() throws InterruptedException {
 
     public void testGetTickCount64() throws InterruptedException {
         long tick1 = Kernel32.INSTANCE.GetTickCount64();
-        Thread.sleep(10);
+        Thread.sleep(100);
         long tick2 = Kernel32.INSTANCE.GetTickCount64();
 
         assertTrue(tick2 > tick1);

File: contrib/platform/test/com/sun/jna/platform/win32/NtDllTest.java
Patch:
@@ -44,7 +44,8 @@ public void testZwQueryKey() {
     			phKey.getValue(), Wdm.KEY_INFORMATION_CLASS.KeyBasicInformation, 
     			keyInformation, resultLength.getValue(), resultLength));    	
     	// show
-    	assertEquals("Software", keyInformation.getName());
+        // Keys are case insensitive (https://msdn.microsoft.com/de-de/library/windows/desktop/ms724946(v=vs.85).aspx)
+    	assertEquals("software", keyInformation.getName().toLowerCase());
     	// close key
     	assertEquals(W32Errors.ERROR_SUCCESS, Advapi32.INSTANCE.RegCloseKey(phKey.getValue()));    	    	    	    	
     }

File: contrib/platform/test/com/sun/jna/platform/win32/NtDllUtilTest.java
Patch:
@@ -29,7 +29,8 @@ public void testGetKeyName() {
     	HKEYByReference phKey = new HKEYByReference();
     	assertEquals(W32Errors.ERROR_SUCCESS, Advapi32.INSTANCE.RegOpenKeyEx(
     			WinReg.HKEY_CURRENT_USER, "Software", 0, WinNT.KEY_WRITE | WinNT.KEY_READ, phKey));
-    	assertEquals("Software", NtDllUtil.getKeyName(phKey.getValue()));
+        // Keys are case insensitive (https://msdn.microsoft.com/de-de/library/windows/desktop/ms724946(v=vs.85).aspx)
+    	assertEquals("software", NtDllUtil.getKeyName(phKey.getValue()).toLowerCase());
     	assertEquals(W32Errors.ERROR_SUCCESS, Advapi32.INSTANCE.RegCloseKey(phKey.getValue()));
     }
 }

File: contrib/platform/test/com/sun/jna/platform/win32/PdhTest.java
Patch:
@@ -48,7 +48,7 @@ public void testQueryOneCounter() {
         HANDLE hQuery = ref.getValue();
         try {
             ref.setValue(null);
-            assertErrorSuccess("PdhAddCounter", pdh.PdhAddCounter(hQuery, counterName, null, ref), true);
+            assertErrorSuccess("PdhAddEnglishCounter", pdh.PdhAddEnglishCounter(hQuery, counterName, null, ref), true);
             
             HANDLE hCounter = ref.getValue();
             try {
@@ -93,7 +93,7 @@ public void testQueryMultipleCounters() {
             try {
                 for (String counterName : names) {
                     ref.setValue(null);
-                    assertErrorSuccess("PdhAddCounter[" + counterName + "]", pdh.PdhAddCounter(hQuery, counterName, null, ref), true);
+                    assertErrorSuccess("PdhAddCounter[" + counterName + "]", pdh.PdhAddEnglishCounter(hQuery, counterName, null, ref), true);
 
                     HANDLE hCounter = ref.getValue();
                     handlesMap.put(counterName, hCounter);

File: contrib/platform/test/com/sun/jna/platform/win32/Secur32Test.java
Patch:
@@ -254,7 +254,8 @@ public void testEnumerateSecurityPackages() {
     		assertTrue(packageInfo.Comment.length() >= 0);
     	}
     	assertEquals(W32Errors.SEC_E_OK, Secur32.INSTANCE.FreeContextBuffer(
-    			pPackageInfo.getPointer()));
+    			pPackageInfo.pPkgInfo.getPointer()));
+        
     }
 
     public void testQuerySecurityContextToken() {

File: contrib/platform/test/com/sun/jna/platform/win32/VersionUtilTest.java
Patch:
@@ -32,11 +32,11 @@ public void testGetFileVersionNumbers() {
         assertTrue("The major file version number should be greater than 0 when pulling version from \"" + file + "\"", version.getFileVersionMajor() > 0);
         assertTrue("The minor file version number should be greater than or equal to 0 when pulling version from \"" + file + "\"", version.getFileVersionMinor() >= 0);
         assertTrue("The revision file version number should be greater than or equal to 0 when pulling version from \"" + file + "\"", version.getFileVersionRevision() >= 0);
-        assertTrue("The build file version number should be greater than or equal to 0  when pulling version from \"" + file + "\"", version.getFileVersionBuild() > 0);
+        assertTrue("The build file version number should be greater than or equal to 0  when pulling version from \"" + file + "\"", version.getFileVersionBuild() >= 0);
 
         assertTrue("The major product version number should be greater than 0 when pulling version from \"" + file + "\"", version.getProductVersionMajor() > 0);
         assertTrue("The minor product version number should be greater than or equal to 0 when pulling version from \"" + file + "\"", version.getProductVersionMinor() >= 0);
         assertTrue("The revision product version number should be greater than or equal to 0 when pulling version from \"" + file + "\"", version.getProductVersionRevision() >= 0);
-        assertTrue("The build product version number should be greater than or equal to 0  when pulling version from \"" + file + "\"", version.getProductVersionBuild() > 0);
+        assertTrue("The build product version number should be greater than or equal to 0  when pulling version from \"" + file + "\"", version.getProductVersionBuild() >= 0);
     }
 }

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32Util.java
Patch:
@@ -421,7 +421,7 @@ public static Map<String,String> getEnvironmentVariables(Pointer lpszEnvironment
         if (lpszEnvironmentBlock == null) {
             return null;
         }
-
+        
         Map<String,String>  vars=new TreeMap<String,String>();
         boolean             asWideChars=isWideCharEnvironmentStringBlock(lpszEnvironmentBlock, offset);
         long                stepFactor=asWideChars ? 2L : 1L;

File: contrib/platform/test/com/sun/jna/platform/win32/Advapi32Test.java
Patch:
@@ -189,7 +189,9 @@ public void testLookupAccountSid() {
     		String nameString = Native.toString(name);
     		String referencedDomainNameString = Native.toString(referencedDomainName);
     		assertTrue(nameString.length() > 0);
-    		assertEquals("Everyone", nameString);
+                if(AbstractWin32TestSupport.isEnglishLocale) {
+                    assertEquals("Everyone", nameString);
+                }
     		assertTrue(referencedDomainNameString.length() == 0);
     	} finally {
     	    Kernel32Util.freeLocalMemory(value.getPointer());

File: contrib/platform/test/com/sun/jna/platform/win32/Kernel32Test.java
Patch:
@@ -380,7 +380,7 @@ public void testGetTickCount() throws InterruptedException {
 
     public void testGetTickCount64() throws InterruptedException {
         long tick1 = Kernel32.INSTANCE.GetTickCount64();
-        Thread.sleep(10);
+        Thread.sleep(100);
         long tick2 = Kernel32.INSTANCE.GetTickCount64();
 
         assertTrue(tick2 > tick1);

File: contrib/platform/test/com/sun/jna/platform/win32/NtDllTest.java
Patch:
@@ -44,7 +44,8 @@ public void testZwQueryKey() {
     			phKey.getValue(), Wdm.KEY_INFORMATION_CLASS.KeyBasicInformation, 
     			keyInformation, resultLength.getValue(), resultLength));    	
     	// show
-    	assertEquals("Software", keyInformation.getName());
+        // Keys are case insensitive (https://msdn.microsoft.com/de-de/library/windows/desktop/ms724946(v=vs.85).aspx)
+    	assertEquals("software", keyInformation.getName().toLowerCase());
     	// close key
     	assertEquals(W32Errors.ERROR_SUCCESS, Advapi32.INSTANCE.RegCloseKey(phKey.getValue()));    	    	    	    	
     }

File: contrib/platform/test/com/sun/jna/platform/win32/NtDllUtilTest.java
Patch:
@@ -29,7 +29,8 @@ public void testGetKeyName() {
     	HKEYByReference phKey = new HKEYByReference();
     	assertEquals(W32Errors.ERROR_SUCCESS, Advapi32.INSTANCE.RegOpenKeyEx(
     			WinReg.HKEY_CURRENT_USER, "Software", 0, WinNT.KEY_WRITE | WinNT.KEY_READ, phKey));
-    	assertEquals("Software", NtDllUtil.getKeyName(phKey.getValue()));
+        // Keys are case insensitive (https://msdn.microsoft.com/de-de/library/windows/desktop/ms724946(v=vs.85).aspx)
+    	assertEquals("software", NtDllUtil.getKeyName(phKey.getValue()).toLowerCase());
     	assertEquals(W32Errors.ERROR_SUCCESS, Advapi32.INSTANCE.RegCloseKey(phKey.getValue()));
     }
 }

File: contrib/platform/test/com/sun/jna/platform/win32/PdhTest.java
Patch:
@@ -48,7 +48,7 @@ public void testQueryOneCounter() {
         HANDLE hQuery = ref.getValue();
         try {
             ref.setValue(null);
-            assertErrorSuccess("PdhAddCounter", pdh.PdhAddCounter(hQuery, counterName, null, ref), true);
+            assertErrorSuccess("PdhAddEnglishCounter", pdh.PdhAddEnglishCounter(hQuery, counterName, null, ref), true);
             
             HANDLE hCounter = ref.getValue();
             try {
@@ -93,7 +93,7 @@ public void testQueryMultipleCounters() {
             try {
                 for (String counterName : names) {
                     ref.setValue(null);
-                    assertErrorSuccess("PdhAddCounter[" + counterName + "]", pdh.PdhAddCounter(hQuery, counterName, null, ref), true);
+                    assertErrorSuccess("PdhAddCounter[" + counterName + "]", pdh.PdhAddEnglishCounter(hQuery, counterName, null, ref), true);
 
                     HANDLE hCounter = ref.getValue();
                     handlesMap.put(counterName, hCounter);

File: contrib/platform/test/com/sun/jna/platform/win32/Secur32Test.java
Patch:
@@ -254,7 +254,8 @@ public void testEnumerateSecurityPackages() {
     		assertTrue(packageInfo.Comment.length() >= 0);
     	}
     	assertEquals(W32Errors.SEC_E_OK, Secur32.INSTANCE.FreeContextBuffer(
-    			pPackageInfo.getPointer()));
+    			pPackageInfo.pPkgInfo.getPointer()));
+        
     }
 
     public void testQuerySecurityContextToken() {

File: contrib/platform/test/com/sun/jna/platform/win32/VersionUtilTest.java
Patch:
@@ -32,11 +32,11 @@ public void testGetFileVersionNumbers() {
         assertTrue("The major file version number should be greater than 0 when pulling version from \"" + file + "\"", version.getFileVersionMajor() > 0);
         assertTrue("The minor file version number should be greater than or equal to 0 when pulling version from \"" + file + "\"", version.getFileVersionMinor() >= 0);
         assertTrue("The revision file version number should be greater than or equal to 0 when pulling version from \"" + file + "\"", version.getFileVersionRevision() >= 0);
-        assertTrue("The build file version number should be greater than or equal to 0  when pulling version from \"" + file + "\"", version.getFileVersionBuild() > 0);
+        assertTrue("The build file version number should be greater than or equal to 0  when pulling version from \"" + file + "\"", version.getFileVersionBuild() >= 0);
 
         assertTrue("The major product version number should be greater than 0 when pulling version from \"" + file + "\"", version.getProductVersionMajor() > 0);
         assertTrue("The minor product version number should be greater than or equal to 0 when pulling version from \"" + file + "\"", version.getProductVersionMinor() >= 0);
         assertTrue("The revision product version number should be greater than or equal to 0 when pulling version from \"" + file + "\"", version.getProductVersionRevision() >= 0);
-        assertTrue("The build product version number should be greater than or equal to 0  when pulling version from \"" + file + "\"", version.getProductVersionBuild() > 0);
+        assertTrue("The build product version number should be greater than or equal to 0  when pulling version from \"" + file + "\"", version.getProductVersionBuild() >= 0);
     }
 }

File: contrib/platform/src/com/sun/jna/platform/win32/WinCrypt.java
Patch:
@@ -19,6 +19,7 @@
 import com.sun.jna.Pointer;
 import com.sun.jna.Structure;
 import com.sun.jna.platform.win32.WinDef.HWND;
+import com.sun.jna.win32.W32APITypeMapper;
 
 /**
  * Ported from WinCrypt.h.
@@ -101,11 +102,11 @@ public static class CRYPTPROTECT_PROMPTSTRUCT extends Structure {
         public String szPrompt;
 
         public CRYPTPROTECT_PROMPTSTRUCT() {
-            super();
+            super(W32APITypeMapper.DEFAULT);
         }
 
         public CRYPTPROTECT_PROMPTSTRUCT(Pointer memory) {
-            super(memory);
+            super(memory, Structure.ALIGN_DEFAULT, W32APITypeMapper.DEFAULT);
             read();
         }
 

File: contrib/platform/src/com/sun/jna/platform/win32/WinUser.java
Patch:
@@ -22,6 +22,7 @@
 import com.sun.jna.platform.win32.BaseTSD.ULONG_PTR;
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.win32.StdCallLibrary.StdCallCallback;
+import com.sun.jna.win32.W32APITypeMapper;
 
 /**
  * Ported from WinUser.h Microsoft Windows SDK 6.0A.
@@ -1166,6 +1167,7 @@ public static class ByReference extends WNDCLASSEX implements
          * Instantiates a new wndclassex.
          */
         public WNDCLASSEX() {
+            super(W32APITypeMapper.DEFAULT);
         }
 
         /**
@@ -1175,7 +1177,7 @@ public WNDCLASSEX() {
          *            the memory
          */
         public WNDCLASSEX(Pointer memory) {
-            super(memory);
+            super(memory, Structure.ALIGN_DEFAULT, W32APITypeMapper.DEFAULT);
             read();
         }
 

File: contrib/platform/src/com/sun/jna/platform/win32/Winsvc.java
Patch:
@@ -18,7 +18,6 @@
 import com.sun.jna.Memory;
 import com.sun.jna.Pointer;
 import com.sun.jna.Structure;
-import com.sun.jna.TypeMapper;
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.win32.W32APITypeMapper;
 

File: contrib/platform/test/com/sun/jna/platform/win32/Kernel32Test.java
Patch:
@@ -346,7 +346,7 @@ public void testOpenProcess() {
 
     public void testQueryFullProcessImageName() {
         int pid = Kernel32.INSTANCE.GetCurrentProcessId();
-        HANDLE h = Kernel32.INSTANCE.OpenProcess(0, false, pid);
+        HANDLE h = Kernel32.INSTANCE.OpenProcess(WinNT.PROCESS_QUERY_INFORMATION, false, pid);
         assertNotNull("Failed (" + Kernel32.INSTANCE.GetLastError() + ") to get process ID=" + pid + " handle", h);
 
         try {

File: src/com/sun/jna/Native.java
Patch:
@@ -36,6 +36,7 @@
 import java.net.URLClassLoader;
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.ArrayList;
@@ -95,7 +96,7 @@
  */
 public final class Native implements Version {
 
-    public static final String DEFAULT_ENCODING = "utf8";
+    public static final String DEFAULT_ENCODING = Charset.defaultCharset().name();
     public static boolean DEBUG_LOAD = Boolean.getBoolean("jna.debug_load");
     public static boolean DEBUG_JNA_LOAD = Boolean.getBoolean("jna.debug_load.jna");
 

File: test/com/sun/jna/ReturnTypesTest.java
Patch:
@@ -12,6 +12,7 @@
  */
 package com.sun.jna;
 
+import java.nio.charset.Charset;
 import java.util.Collections;
 import java.util.List;
 import junit.framework.TestCase;
@@ -314,7 +315,8 @@ public void testReturnPointerArray() {
     }
 
     public void testReturnStringArray() {
-        final String VALUE = getName() + UNICODE;
+        Charset charset = Charset.forName(Native.getDefaultStringEncoding());
+        final String VALUE = getName() + charset.decode(charset.encode(UNICODE));
         String[] input = {
             VALUE, null,
         };

File: test/com/sun/jna/ReturnTypesTest.java
Patch:
@@ -12,6 +12,7 @@
  */
 package com.sun.jna;
 
+import java.nio.charset.Charset;
 import java.util.Collections;
 import java.util.List;
 import junit.framework.TestCase;
@@ -314,7 +315,8 @@ public void testReturnPointerArray() {
     }
 
     public void testReturnStringArray() {
-        final String VALUE = getName() + UNICODE;
+        Charset charset = Charset.forName(Native.getDefaultStringEncoding());
+        final String VALUE = getName() + charset.decode(charset.encode(UNICODE));
         String[] input = {
             VALUE, null,
         };

File: src/com/sun/jna/Native.java
Patch:
@@ -36,6 +36,7 @@
 import java.net.URLClassLoader;
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.ArrayList;
@@ -95,7 +96,7 @@
  */
 public final class Native implements Version {
 
-    public static final String DEFAULT_ENCODING = "utf8";
+    public static final String DEFAULT_ENCODING = Charset.defaultCharset().name();
     public static boolean DEBUG_LOAD = Boolean.getBoolean("jna.debug_load");
     public static boolean DEBUG_JNA_LOAD = Boolean.getBoolean("jna.debug_load.jna");
 

File: contrib/platform/src/com/sun/jna/platform/win32/COM/COMUtils.java
Patch:
@@ -192,11 +192,11 @@ public static ArrayList<COMInfo> getAllCOMInfoOnSystem() {
     }
 
     /**
-     * Check is COM was initialized correctly. The initialization status is not changed!
+     * Check if COM was initialized correctly. The initialization status is not changed!
      *
      * <p>This is a debug function, not for normal usage!</p>
      * 
-     * @return
+     * @return whether COM has been initialized
      */
     public static boolean comIsInitialized() {
         WinNT.HRESULT hr = Ole32.INSTANCE.CoInitializeEx(Pointer.NULL, Ole32.COINIT_MULTITHREADED);

File: contrib/platform/src/com/sun/jna/platform/win32/OaIdlUtil.java
Patch:
@@ -77,7 +77,7 @@ public abstract class OaIdlUtil {
      * @param sa SAFEARRAY to convert
      * @param destruct if true the supplied SAFEARRAY is destroyed, there must
      * not be additional locks on the array!
-     * @return
+     * @return Java array corresponding to the given SAFEARRAY
      */
     public static Object toPrimitiveArray(SAFEARRAY sa, boolean destruct) {
         Pointer dataPointer = sa.accessData();

File: contrib/platform/src/com/sun/jna/platform/win32/Variant.java
Patch:
@@ -248,9 +248,9 @@ public VARIANT(double value) {
          * Create a new VARIANT wrapping the supplied string.
          * 
          * <p><i>Implementation note:</i> the string is wrapped as a BSTR value,
-         * that is allocated using {@see com.sun.jna.platform.win32.OleAuto#SysAllocString}
+         * that is allocated using {@link com.sun.jna.platform.win32.OleAuto#SysAllocString}
          * and needs to be freed using
-         * {@see com.sun.jna.platform.win32.OleAuto#SysFreeString} by the user</p>
+         * {@link com.sun.jna.platform.win32.OleAuto#SysFreeString} by the user</p>
          * 
          * @param value  to be wrapped
          */

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/CallbackProxy.java
Patch:
@@ -133,7 +133,7 @@ void invokeOnThread(final DISPID dispIdMember, final REFIID riid, LCID lcid, WOR
                 for ( int i = 0; i < vargs.variantArg.length; i++) {
                     Class targetClass = params[vargs.variantArg.length - 1 - i];
                     Variant.VARIANT varg = vargs.variantArg[i];
-                    Object jarg = Convert.toJavaObject(varg, targetClass, factory, true);
+                    Object jarg = Convert.toJavaObject(varg, targetClass, factory, true, false);
                     rjargs.add(jarg);
                 }
             }

File: contrib/platform/test/com/sun/jna/platform/win32/COM/ITypeInfoTest.java
Patch:
@@ -25,10 +25,11 @@
 import com.sun.jna.platform.win32.WinNT.HRESULT;
 import com.sun.jna.ptr.IntByReference;
 import com.sun.jna.ptr.PointerByReference;
-import static junit.framework.TestCase.assertEquals;
 import org.junit.Ignore;
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+
 /**
  * @author dblock[at]dblock[dot]org
  */

File: contrib/platform/test/com/sun/jna/platform/win32/COM/ShellApplicationWindowsTest.java
Patch:
@@ -9,11 +9,12 @@
 import com.sun.jna.platform.win32.Variant.VARIANT;
 import com.sun.jna.platform.win32.WinDef.LONG;
 
-import static junit.framework.TestCase.assertTrue;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+
 public class ShellApplicationWindowsTest {
 
     static {

File: contrib/platform/test/com/sun/jna/platform/win32/COM/ITypeInfoTest.java
Patch:
@@ -25,10 +25,11 @@
 import com.sun.jna.platform.win32.WinNT.HRESULT;
 import com.sun.jna.ptr.IntByReference;
 import com.sun.jna.ptr.PointerByReference;
-import static junit.framework.TestCase.assertEquals;
 import org.junit.Ignore;
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+
 /**
  * @author dblock[at]dblock[dot]org
  */

File: contrib/platform/test/com/sun/jna/platform/win32/COM/ShellApplicationWindowsTest.java
Patch:
@@ -9,11 +9,12 @@
 import com.sun.jna.platform.win32.Variant.VARIANT;
 import com.sun.jna.platform.win32.WinDef.LONG;
 
-import static junit.framework.TestCase.assertTrue;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+
 public class ShellApplicationWindowsTest {
 
     static {

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/Convert.java
Patch:
@@ -12,6 +12,7 @@
  */
 package com.sun.jna.platform.win32.COM.util;
 
+import com.sun.jna.platform.win32.OaIdl.VARIANT_BOOL;
 import com.sun.jna.platform.win32.OleAuto;
 import com.sun.jna.platform.win32.Variant;
 import java.lang.reflect.InvocationHandler;
@@ -100,6 +101,8 @@ public static Object toJavaObject(VARIANT value, Class targetClass) {
                 }
                 if (vobj instanceof WinDef.BOOL) {
 			return ((WinDef.BOOL) vobj).booleanValue();
+                } else if (vobj instanceof VARIANT_BOOL) {
+			return ((VARIANT_BOOL) vobj).booleanValue();
 		} else if (vobj instanceof WinDef.LONG) {
 			return ((WinDef.LONG) vobj).longValue();
 		} else if (vobj instanceof WinDef.SHORT) {

File: contrib/platform/src/com/sun/jna/platform/win32/WinDef.java
Patch:
@@ -1404,6 +1404,7 @@ public BOOL(boolean value) {
          */
         public BOOL(long value) {
             super(SIZE, value, false);
+            assert value == 0 || value == 1;
         }
 
         public boolean booleanValue() {
@@ -1597,7 +1598,7 @@ public CHAR() {
          *
          * @param ch The {@code char} value
          */
-        public CHAR(char ch) {
+        public CHAR(byte ch) {
             this(ch & 0xFF);
         }
 

File: contrib/platform/test/com/sun/jna/platform/win32/VariantTest.java
Patch:
@@ -34,7 +34,7 @@ public VariantTest() {
 
     public void testVariantClear() {
         VARIANT variant = new VARIANT(new SHORT(33333));
-        HRESULT hr = OleAuto.INSTANCE.VariantClear(variant.getPointer());
+        HRESULT hr = OleAuto.INSTANCE.VariantClear(variant);
 
         assertTrue("hr: " + hr.intValue(), hr.intValue() == 0);
     }

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/Convert.java
Patch:
@@ -12,6 +12,7 @@
  */
 package com.sun.jna.platform.win32.COM.util;
 
+import com.sun.jna.platform.win32.OaIdl.VARIANT_BOOL;
 import com.sun.jna.platform.win32.OleAuto;
 import com.sun.jna.platform.win32.Variant;
 import java.lang.reflect.InvocationHandler;
@@ -100,6 +101,8 @@ public static Object toJavaObject(VARIANT value, Class targetClass) {
                 }
                 if (vobj instanceof WinDef.BOOL) {
 			return ((WinDef.BOOL) vobj).booleanValue();
+                } else if (vobj instanceof VARIANT_BOOL) {
+			return ((VARIANT_BOOL) vobj).booleanValue();
 		} else if (vobj instanceof WinDef.LONG) {
 			return ((WinDef.LONG) vobj).longValue();
 		} else if (vobj instanceof WinDef.SHORT) {

File: contrib/platform/src/com/sun/jna/platform/win32/WinDef.java
Patch:
@@ -1404,6 +1404,7 @@ public BOOL(boolean value) {
          */
         public BOOL(long value) {
             super(SIZE, value, false);
+            assert value == 0 || value == 1;
         }
 
         public boolean booleanValue() {
@@ -1597,7 +1598,7 @@ public CHAR() {
          *
          * @param ch The {@code char} value
          */
-        public CHAR(char ch) {
+        public CHAR(byte ch) {
             this(ch & 0xFF);
         }
 

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/annotation/ComProperty.java
Patch:
@@ -23,4 +23,5 @@
 @Inherited
 public @interface ComProperty {
 	String name() default "";
+        int dispId() default -1; //default to dispid unknown
 }

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/ProxyObject.java
Patch:
@@ -378,7 +378,7 @@ public <T> T getProperty(Class<T> returnType, String name, Object... args) {
 		Variant.VARIANT.ByReference result = new Variant.VARIANT.ByReference();
 		WinNT.HRESULT hr = this.oleMethod(OleAuto.DISPATCH_PROPERTYGET, result, this.getRawDispatch(), name, vargs);
 		COMUtils.checkRC(hr);
-		Object jobj = Convert.toJavaObject(result);
+		Object jobj = Convert.toJavaObject(result, returnType);
 		if (IComEnum.class.isAssignableFrom(returnType)) {
 			return returnType.cast(Convert.toComEnum((Class<? extends IComEnum>) returnType, jobj));
 		}
@@ -408,7 +408,7 @@ public <T> T invokeMethod(Class<T> returnType, String name, Object... args) {
 		WinNT.HRESULT hr = this.oleMethod(OleAuto.DISPATCH_METHOD, result, this.getRawDispatch(), name, vargs);
 		COMUtils.checkRC(hr);
 
-		Object jobj = Convert.toJavaObject(result);
+		Object jobj = Convert.toJavaObject(result, returnType);
 		if (IComEnum.class.isAssignableFrom(returnType)) {
 			return returnType.cast(Convert.toComEnum((Class<? extends IComEnum>) returnType, jobj));
 		}

File: contrib/platform/test/com/sun/jna/platform/win32/COM/IDispatchTest.java
Patch:
@@ -39,7 +39,7 @@ private Dispatch createIDispatch() {
         try {
             PointerByReference pDispatch = new PointerByReference();
 
-            // Get CLSID for Word.Application...
+            // Get CLSID for Shell.Application...
             CLSID.ByReference clsid = new CLSID.ByReference();
             HRESULT hr = Ole32.INSTANCE.CLSIDFromProgID("Shell.Application",
                     clsid);

File: contrib/platform/test/com/sun/jna/platform/win32/COM/util/RunningObjectTable_Test.java
Patch:
@@ -31,10 +31,10 @@ public class RunningObjectTable_Test {
 	@ComInterface(iid="{00020970-0000-0000-C000-000000000046}")
 	interface Application extends IUnknown {
 		@ComProperty
-		boolean getVisible();
+		Boolean getVisible();
 		
 		@ComProperty
-		void setVisible(boolean value);
+		void setVisible(Boolean value);
 		
 		@ComMethod
 		void Quit(boolean SaveChanges, Object OriginalFormat, Boolean RouteDocument);

File: contrib/platform/src/com/sun/jna/platform/win32/Winsvc.java
Patch:
@@ -241,7 +241,7 @@ public static class ByReference extends SERVICE_FAILURE_ACTIONS implements Struc
          * If this value is NULL, the reboot message is unchanged. If the value is an empty string 
          * (""), the reboot message is deleted and no message is broadcast.
          * This member can specify a localized string using the following format:
-         * @[path\]dllname,-strID
+         * "@[path]dllname,-strID"
          * The string with identifier strID is loaded from dllname; the path is optional. For more 
          * information, see RegLoadMUIString.
          * Windows Server 2003 and Windows XP:  Localized strings are not supported until Windows 

File: contrib/platform/src/com/sun/jna/platform/win32/COM/ITypeLib.java
Patch:
@@ -12,6 +12,7 @@
  */
 package com.sun.jna.platform.win32.COM;
 
+import com.sun.jna.Pointer;
 import com.sun.jna.platform.win32.Guid.GUID;
 import com.sun.jna.platform.win32.OaIdl.MEMBERID;
 import com.sun.jna.platform.win32.OaIdl.TLIBATTR;
@@ -69,9 +70,9 @@ public HRESULT IsName(
 
     public HRESULT FindName(
     /* [annotation][out][in] */
-    BSTRByReference szNameBuf,
+    LPOLESTR szNameBuf,
     /* [in] */ULONG lHashVal,
-    /* [length_is][size_is][out] */PointerByReference ppTInfo,
+    /* [length_is][size_is][out] */Pointer[] ppTInfo,
     /* [length_is][size_is][out] */MEMBERID[] rgMemId,
     /* [out][in] */USHORTByReference pcFound);
 

File: contrib/platform/src/com/sun/jna/platform/win32/WTypes.java
Patch:
@@ -196,7 +196,7 @@ public String toString() {
     }
 
     public static class LPOLESTR extends PointerType {
-        public static class ByReference extends BSTR implements
+        public static class ByReference extends LPOLESTR implements
                 Structure.ByReference {
         }
 

File: contrib/platform/src/com/sun/jna/platform/win32/COM/ITypeLib.java
Patch:
@@ -12,6 +12,7 @@
  */
 package com.sun.jna.platform.win32.COM;
 
+import com.sun.jna.Pointer;
 import com.sun.jna.platform.win32.Guid.GUID;
 import com.sun.jna.platform.win32.OaIdl.MEMBERID;
 import com.sun.jna.platform.win32.OaIdl.TLIBATTR;
@@ -69,9 +70,9 @@ public HRESULT IsName(
 
     public HRESULT FindName(
     /* [annotation][out][in] */
-    BSTRByReference szNameBuf,
+    LPOLESTR szNameBuf,
     /* [in] */ULONG lHashVal,
-    /* [length_is][size_is][out] */PointerByReference ppTInfo,
+    /* [length_is][size_is][out] */Pointer[] ppTInfo,
     /* [length_is][size_is][out] */MEMBERID[] rgMemId,
     /* [out][in] */USHORTByReference pcFound);
 

File: contrib/platform/src/com/sun/jna/platform/win32/WTypes.java
Patch:
@@ -196,7 +196,7 @@ public String toString() {
     }
 
     public static class LPOLESTR extends PointerType {
-        public static class ByReference extends BSTR implements
+        public static class ByReference extends LPOLESTR implements
                 Structure.ByReference {
         }
 

File: contrib/platform/src/com/sun/jna/platform/win32/OaIdl.java
Patch:
@@ -1075,6 +1075,8 @@ public static class ByReference extends INVOKEKIND implements
                 Structure.ByReference {
         };
 
+        public static final List<String> FIELDS = createFieldsOrder("value");
+        
         // / <i>native declaration : line 30</i>
         public static final INVOKEKIND INVOKE_FUNC = new INVOKEKIND(1);
         // / <i>native declaration : line 31</i>
@@ -1084,7 +1086,6 @@ public static class ByReference extends INVOKEKIND implements
         // / <i>native declaration : line 33</i>
         public static final INVOKEKIND INVOKE_PROPERTYPUTREF = new INVOKEKIND(8);
 
-        public static final List<String> FIELDS = createFieldsOrder("value");
         public int value;
 
         public INVOKEKIND() {

File: contrib/platform/src/com/sun/jna/platform/win32/OaIdl.java
Patch:
@@ -1075,6 +1075,8 @@ public static class ByReference extends INVOKEKIND implements
                 Structure.ByReference {
         };
 
+        public static final List<String> FIELDS = createFieldsOrder("value");
+        
         // / <i>native declaration : line 30</i>
         public static final INVOKEKIND INVOKE_FUNC = new INVOKEKIND(1);
         // / <i>native declaration : line 31</i>
@@ -1084,7 +1086,6 @@ public static class ByReference extends INVOKEKIND implements
         // / <i>native declaration : line 33</i>
         public static final INVOKEKIND INVOKE_PROPERTYPUTREF = new INVOKEKIND(8);
 
-        public static final List<String> FIELDS = createFieldsOrder("value");
         public int value;
 
         public INVOKEKIND() {

File: src/com/sun/jna/VarArgsChecker.java
Patch:
@@ -27,7 +27,7 @@ boolean isVarArgs(Method m) {
         
 	int fixedArgs(Method m) {
 	    // In Java, final argument contains all "varargs"
-	    return m.getParameterTypes().length - 1;
+	    return m.isVarArgs() ? m.getParameterTypes().length - 1 : 0;
 	}
     }
     

File: test/com/sun/jna/VarArgsTest.java
Patch:
@@ -70,7 +70,7 @@ public void testDoubleVarArgs() {
         double arg1 = 1;
         double arg2 = 2;
         assertEquals("VarArgs not added correctly", (int)arg1 + (int)arg2,
-                     lib.addInt32VarArgs("ff", Double.valueOf(arg1), Double.valueOf(arg2)));
+                     lib.addInt32VarArgs("FF", Double.valueOf(arg1), Double.valueOf(arg2)));
     }
     public void testStringVarArgs() {
         Object[] args = new Object[] { "Test" };

File: contrib/platform/src/com/sun/jna/platform/win32/Advapi32.java
Patch:
@@ -30,6 +30,7 @@
 import com.sun.jna.platform.win32.Winsvc.SC_HANDLE;
 import com.sun.jna.platform.win32.Winsvc.SERVICE_STATUS;
 import com.sun.jna.platform.win32.Winsvc.SERVICE_STATUS_PROCESS;
+import com.sun.jna.platform.win32.Winsvc.ChangeServiceConfig2Info;
 import com.sun.jna.ptr.IntByReference;
 import com.sun.jna.ptr.LongByReference;
 import com.sun.jna.ptr.PointerByReference;

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32.java
Patch:
@@ -54,7 +54,6 @@ public interface Kernel32 extends StdCallLibrary, WinNT, Wincon {
      */
     int LOAD_LIBRARY_AS_DATAFILE = 0x2;
     
-    
     /**
      * Reads data from the specified file or input/output (I/O) device. Reads
      * occur at the position specified by the file pointer if supported by the

File: contrib/platform/src/com/sun/jna/platform/win32/COM/IDispatch.java
Patch:
@@ -81,7 +81,7 @@ public HRESULT GetTypeInfo(UINT iTInfo, LCID lcid,
      * @param lcid      The locale context in which to interpret the names.
      * @param rgDispId  Caller-allocated array, each element of which contains an identifier (ID) corresponding to one of the names passed in
      *                  the rgszNames array. The first element represents the member name. The subsequent elements represent each of the member's parameters.
-     * @return
+     * @return status of the operation
      */
     public HRESULT GetIDsOfNames(REFIID riid, WString[] rgszNames, int cNames,
             LCID lcid, DISPIDByReference rgDispId);

File: contrib/platform/src/com/sun/jna/platform/win32/Wininet.java
Patch:
@@ -198,8 +198,7 @@ boolean FindNextUrlCacheEntry(HANDLE hEnumHandle, INTERNET_CACHE_ENTRY_INFO lpNe
      *     </code>
      * </pre>
      *
-     * @see https://msdn.microsoft.com/en-us/library/windows/desktop/aa385134(v=
-     *      vs.85).aspx
+     * @see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa385134(v=vs.85).aspx">MSDN</a>
      */
     static class INTERNET_CACHE_ENTRY_INFO extends Structure {
         public static final List<String> FIELDS = createFieldsOrder(

File: contrib/platform/src/com/sun/jna/platform/mac/MacFileUtils.java
Patch:
@@ -32,7 +32,7 @@ public class MacFileUtils extends FileUtils {
 
     public interface FileManager extends Library {
 
-        public FileManager INSTANCE = (FileManager)Native.loadLibrary("CoreServices", FileManager.class);
+        FileManager INSTANCE = Native.loadLibrary("CoreServices", FileManager.class);
 
         int kFSFileOperationDefaultOptions = 0;
         int kFSFileOperationsOverwrite = 0x01;

File: contrib/platform/src/com/sun/jna/platform/win32/Version.java
Patch:
@@ -22,8 +22,7 @@
  */
 public interface Version extends StdCallLibrary {
 
-    Version INSTANCE = (Version)
-        Native.loadLibrary("version", Version.class, W32APIOptions.DEFAULT_OPTIONS);
+    Version INSTANCE = Native.loadLibrary("version", Version.class, W32APIOptions.DEFAULT_OPTIONS);
 
     /**
      * Determines whether the operating system can retrieve version information for a specified file. If version

File: test/com/sun/jna/AnnotatedLibraryTest.java
Patch:
@@ -68,8 +68,7 @@ public Class nativeType() {
         });
         
         options.put(Library.OPTION_TYPE_MAPPER, mapper);
-        AnnotationTestLibrary lib = (AnnotationTestLibrary) 
-            Native.loadLibrary("testlib", AnnotationTestLibrary.class, options);
+        AnnotationTestLibrary lib = Native.loadLibrary("testlib", AnnotationTestLibrary.class, options);
         assertEquals("Failed to convert integer return to boolean TRUE", true,
                      lib.returnInt32Argument(true));
         assertTrue("Failed to get annotation from ParameterContext", hasAnnotation[0]);        

File: test/com/sun/jna/wince/CoreDLLTest.java
Patch:
@@ -25,6 +25,8 @@ public static void main(java.lang.String[] argList) {
     }
 
     public interface CoreDLL extends StdCallLibrary {
+        CoreDLL INSTANCE = Native.loadLibrary("coredll", CoreDLL.class, W32APIOptions.UNICODE_OPTIONS);
+
         public static class SECURITY_ATTRIBUTES extends Structure {
             public int dwLength;
             public Pointer lpSecurityDescriptor;
@@ -88,8 +90,7 @@ protected List getFieldOrder() {
                 return Arrays.asList(new String[] { "hProcess", "hThread", "dwProcessId", "dwThreadId" });
             }
         }
-        CoreDLL INSTANCE = (CoreDLL)Native.loadLibrary("coredll", CoreDLL.class,
-                                                       W32APIOptions.UNICODE_OPTIONS);
+
         boolean CreateProcess(String lpApplicationName, String lpCommandLine,
                               SECURITY_ATTRIBUTES lpProcessAttributes,
                               SECURITY_ATTRIBUTES lpThreadAttributes,

File: contrib/platform/src/com/sun/jna/platform/mac/MacFileUtils.java
Patch:
@@ -32,7 +32,7 @@ public class MacFileUtils extends FileUtils {
 
     public interface FileManager extends Library {
 
-        public FileManager INSTANCE = (FileManager)Native.loadLibrary("CoreServices", FileManager.class);
+        FileManager INSTANCE = Native.loadLibrary("CoreServices", FileManager.class);
 
         int kFSFileOperationDefaultOptions = 0;
         int kFSFileOperationsOverwrite = 0x01;

File: contrib/platform/src/com/sun/jna/platform/win32/Version.java
Patch:
@@ -22,8 +22,7 @@
  */
 public interface Version extends StdCallLibrary {
 
-    Version INSTANCE = (Version)
-        Native.loadLibrary("version", Version.class, W32APIOptions.DEFAULT_OPTIONS);
+    Version INSTANCE = Native.loadLibrary("version", Version.class, W32APIOptions.DEFAULT_OPTIONS);
 
     /**
      * Determines whether the operating system can retrieve version information for a specified file. If version

File: test/com/sun/jna/AnnotatedLibraryTest.java
Patch:
@@ -68,8 +68,7 @@ public Class nativeType() {
         });
         
         options.put(Library.OPTION_TYPE_MAPPER, mapper);
-        AnnotationTestLibrary lib = (AnnotationTestLibrary) 
-            Native.loadLibrary("testlib", AnnotationTestLibrary.class, options);
+        AnnotationTestLibrary lib = Native.loadLibrary("testlib", AnnotationTestLibrary.class, options);
         assertEquals("Failed to convert integer return to boolean TRUE", true,
                      lib.returnInt32Argument(true));
         assertTrue("Failed to get annotation from ParameterContext", hasAnnotation[0]);        

File: test/com/sun/jna/wince/CoreDLLTest.java
Patch:
@@ -25,6 +25,8 @@ public static void main(java.lang.String[] argList) {
     }
 
     public interface CoreDLL extends StdCallLibrary {
+        CoreDLL INSTANCE = Native.loadLibrary("coredll", CoreDLL.class, W32APIOptions.UNICODE_OPTIONS);
+
         public static class SECURITY_ATTRIBUTES extends Structure {
             public int dwLength;
             public Pointer lpSecurityDescriptor;
@@ -88,8 +90,7 @@ protected List getFieldOrder() {
                 return Arrays.asList(new String[] { "hProcess", "hThread", "dwProcessId", "dwThreadId" });
             }
         }
-        CoreDLL INSTANCE = (CoreDLL)Native.loadLibrary("coredll", CoreDLL.class,
-                                                       W32APIOptions.UNICODE_OPTIONS);
+
         boolean CreateProcess(String lpApplicationName, String lpCommandLine,
                               SECURITY_ATTRIBUTES lpProcessAttributes,
                               SECURITY_ATTRIBUTES lpThreadAttributes,

File: contrib/platform/src/com/sun/jna/platform/win32/Shlwapi.java
Patch:
@@ -6,12 +6,12 @@
 
 import com.sun.jna.Native;
 import com.sun.jna.Pointer;
-import com.sun.jna.platform.win32.Shell32;
-import com.sun.jna.platform.win32.WinNT;
 import com.sun.jna.ptr.PointerByReference;
+import com.sun.jna.win32.StdCallLibrary;
 import com.sun.jna.win32.W32APIOptions;
+import com.sun.jna.platform.win32.WinNT.*;
 
-public interface Shlwapi extends WinNT {
+public interface Shlwapi extends StdCallLibrary {
     Shlwapi INSTANCE = (Shlwapi) Native.loadLibrary("Shlwapi", Shlwapi.class, W32APIOptions.UNICODE_OPTIONS);
 
 

File: contrib/platform/test/com/sun/jna/platform/win32/COM/IDispatchTest.java
Patch:
@@ -102,7 +102,7 @@ public void testGetIDsOfNames() {
         WString[] ptName = new WString[] { new WString("Application") };
         DISPIDByReference pdispID = new DISPIDByReference();
 
-        HRESULT hr = dispatch.GetIDsOfNames(new REFIID.ByValue(Guid.IID_NULL), ptName, 1, LOCALE_SYSTEM_DEFAULT, pdispID);
+        HRESULT hr = dispatch.GetIDsOfNames(new REFIID(Guid.IID_NULL), ptName, 1, LOCALE_SYSTEM_DEFAULT, pdispID);
         COMUtils.checkRC(hr);
         assertEquals(0, hr.intValue());
     }

File: contrib/platform/test/com/sun/jna/platform/win32/COM/ITypeLibTest.java
Patch:
@@ -130,8 +130,9 @@ public void testFindName() {
         BSTRByReference szNameBuf = new BSTRByReference(OleAuto.INSTANCE.SysAllocString("Application"));
         ULONG lHashVal = new ULONG(0);
         USHORTByReference pcFound = new USHORTByReference((short)20);
-
-        HRESULT hr = shellTypeLib.FindName(szNameBuf, lHashVal, null, null, pcFound);
+        PointerByReference ppTInfo = new PointerByReference();
+        MEMBERID[] rgMemId = new MEMBERID[20];
+        HRESULT hr = shellTypeLib.FindName(szNameBuf, lHashVal, ppTInfo, rgMemId, pcFound);
 
         COMUtils.checkRC(hr);
         //System.out.println("szNameBuf: " + szNameBuf);

File: contrib/platform/test/com/sun/jna/platform/win32/COM/IUnknownTest.java
Patch:
@@ -66,7 +66,7 @@ protected void setUp() throws Exception {
     public void testQueryInterface() {
         Unknown iUnknown = this.createIUnknown();
         PointerByReference ppvObject = new PointerByReference();
-        iUnknown.QueryInterface(new REFIID.ByValue(IUnknown.IID_IUNKNOWN), ppvObject);
+        iUnknown.QueryInterface(new REFIID(IUnknown.IID_IUNKNOWN), ppvObject);
 
         assertTrue("ppvObject:" + ppvObject.toString(), ppvObject != null);
     }

File: contrib/platform/test/com/sun/jna/platform/win32/COM/RunningObjectTable_Test.java
Patch:
@@ -125,7 +125,7 @@ public void GetObject() {
 			
 			IUnknown unk = new Unknown(ppunkObject.getValue());
 			PointerByReference ppvObject = new PointerByReference();
-			hr = unk.QueryInterface(new REFIID.ByValue(IUnknown.IID_IUNKNOWN), ppvObject);
+			hr = unk.QueryInterface(new REFIID(IUnknown.IID_IUNKNOWN), ppvObject);
 			assertEquals(0, hr.intValue());
 			assertNotNull(ppvObject.getValue());
 			

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32.java
Patch:
@@ -55,7 +55,6 @@ public interface Kernel32 extends StdCallLibrary, WinNT, Wincon {
      */
     int LOAD_LIBRARY_AS_DATAFILE = 0x2;
     
-    
     /**
      * Reads data from the specified file or input/output (I/O) device. Reads
      * occur at the position specified by the file pointer if supported by the

File: contrib/platform/src/com/sun/jna/platform/win32/Advapi32.java
Patch:
@@ -2250,7 +2250,7 @@ BOOL WINAPI CreateProcessWithLogonW(
 	 *         process is terminated.<br>
 	 *         To get the termination status of a process, call
 	 *         GetExitCodeProcess.
-	 * @see MSDN {@link http://msdn.microsoft.com/en-us/library/windows/desktop/ms682431%28v=vs.85%29.aspx }
+	 * @see <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682431%28v=vs.85%29.aspx">MSDN</a>
 	 */
 	boolean CreateProcessWithLogonW(String lpUsername, String lpDomain, String lpPassword, int dwLogonFlags,
 			String lpApplicationName, String lpCommandLine, int dwCreationFlags, Pointer lpEnvironment,

File: contrib/platform/src/com/sun/jna/platform/win32/Crypt32.java
Patch:
@@ -130,7 +130,7 @@ public boolean CryptUnprotectData(DATA_BLOB pDataIn, PointerByReference szDataDe
 	 *         Refer to those function topics for their respective error
 	 *         handling behaviors.<br>
 	 *         For extended error information, call GetLastError.
-	 * @see MSDN {@link http://msdn.microsoft.com/en-us/library/bb736347(v=vs.85).aspx }
+	 * @see <a href="http://msdn.microsoft.com/en-us/library/bb736347(v=vs.85).aspx">MSDN</a>
 	 */
 	boolean CertAddEncodedCertificateToSystemStore(String szCertStoreName, Pointer pbCertEncoded, int cbCertEncoded);
 }

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32.java
Patch:
@@ -2464,7 +2464,7 @@ boolean SystemTimeToTzSpecificLocalTime(TIME_ZONE_INFORMATION lpTimeZone,
      * Reads data from an area of memory in a specified process. The entire area
      * to be read must be accessible or the operation fails.
      * 
-     * @see MSDN {@link https://msdn.microsoft.com/en-us/library/windows/desktop/ms680553(v=vs.85).aspx }
+     * @see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680553(v=vs.85).aspx">MSDN</a>
      * @param hProcess
      *            A handle to the process with memory that is being read. The
      *            handle must have PROCESS_VM_READ access to the process.
@@ -2780,7 +2780,7 @@ boolean GetVolumePathNamesForVolumeName(String lpszVolumeName,
      *            [in] A handle to the communications device.<br>
      *            The
      *            {@link com.sun.jna.platform.win32.Kernel32#CreateFile(String, int, int, com.sun.jna.platform.win32.WinBase.SECURITY_ATTRIBUTES, int, int, com.sun.jna.platform.win32.WinNT.HANDLE)}
-     *            function returns this {@link HANDLE}.
+     *            function returns this {@link WinNT.HANDLE}.
      * @param lpDCB
      *            [in, out] A pointer to a {@link WinBase.DCB} structure that
      *            receives the control settings information.
@@ -2846,7 +2846,7 @@ boolean GetVolumePathNamesForVolumeName(String lpszVolumeName,
      *            [in] A handle to the communications device. The
      *            {@link com.sun.jna.platform.win32.Kernel32#CreateFile(String, int, int, com.sun.jna.platform.win32.WinBase.SECURITY_ATTRIBUTES, int, int, com.sun.jna.platform.win32.WinNT.HANDLE)}
      *            function returns this handle.
-     * @param LPCOMMTIMEOUTS
+     * @param lpCommTimeouts
      *            [in] A pointer to a {@link WinBase.COMMTIMEOUTS} structure
      *            that contains the new time-out values.
      * @return If the function succeeds, the return value is nonzero. <br>

File: contrib/platform/src/com/sun/jna/platform/win32/Tlhelp32.java
Patch:
@@ -51,7 +51,7 @@ public interface Tlhelp32 {
      * To include the 32-bit modules of the process specified in th32ProcessID
      * from a 64-bit process, use the TH32CS_SNAPMODULE32 flag.
      *
-     * @see MSDN {@link https://msdn.microsoft.com/en-us/library/windows/desktop/ms682489(v=vs.85).aspx }
+     * @see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682489(v=vs.85).aspx">MSDN</a>
      */
     WinDef.DWORD TH32CS_SNAPMODULE   = new WinDef.DWORD(0x00000008);
 

File: contrib/platform/src/com/sun/jna/platform/win32/COM/TypeLibUtil.java
Patch:
@@ -520,7 +520,7 @@ public String getDocString() {
      * 
      * @return the help context
      */
-    public long getHelpContext() {
+    public int getHelpContext() {
         return helpContext;
     }
 

File: contrib/platform/src/com/sun/jna/platform/win32/User32.java
Patch:
@@ -1980,7 +1980,7 @@ HDEVNOTIFY RegisterDeviceNotification(HANDLE hRecipient,
 	 *         Windows 2000: If {@link Kernel32#GetLastError()} returns 0, then
 	 *         the function timed out.
 	 */
-	long SendMessageTimeout(HWND hWnd, int msg, long wParam, long lParam,
+        LRESULT SendMessageTimeout(HWND hWnd, int msg, WPARAM wParam, LPARAM lParam,
 			int fuFlags, int uTimeout, DWORDByReference lpdwResult);
 
 	/**
@@ -2006,7 +2006,7 @@ long SendMessageTimeout(HWND hWnd, int msg, long wParam, long lParam,
 	 *         If the function fails, the return value is zero. To get extended
 	 *         error information, call {@link Kernel32#GetLastError()}.</p>
 	 */
-	long GetClassLongPtr(HWND hWnd, int nIndex);
+	ULONG_PTR GetClassLongPtr(HWND hWnd, int nIndex);
 
 	/**
 	 * @param pRawInputDeviceList

File: contrib/platform/src/com/sun/jna/platform/win32/Win32Exception.java
Patch:
@@ -20,9 +20,9 @@
  */
 public class Win32Exception extends RuntimeException {
 	
-	private static final long serialVersionUID = 1L;
-	
-	private HRESULT _hr;
+    private static final long serialVersionUID = 1L;
+    
+    private HRESULT _hr;
     
     /**
      * Returns the error code of the error.

File: contrib/platform/src/com/sun/jna/platform/win32/Crypt32.java
Patch:
@@ -28,7 +28,7 @@
 public interface Crypt32 extends StdCallLibrary {
 	
 	Crypt32 INSTANCE = (Crypt32) Native.loadLibrary("Crypt32",
-			Crypt32.class, W32APIOptions.UNICODE_OPTIONS);
+			Crypt32.class, W32APIOptions.DEFAULT_OPTIONS);
 	
 	/**
 	 * The CryptProtectData function performs encryption on the data in a DATA_BLOB

File: contrib/platform/src/com/sun/jna/platform/win32/DBT.java
Patch:
@@ -22,15 +22,14 @@
 import com.sun.jna.platform.win32.WinDef.LONG;
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.platform.win32.WinUser.HDEVNOTIFY;
-import com.sun.jna.win32.StdCallLibrary;
 
 /**
  * Based on dbt.h (various types)
  * 
  * @author Tobias Wolf, wolf.tobias@gmx.net
  */
 @SuppressWarnings("serial")
-public interface DBT extends StdCallLibrary {
+public interface DBT {
 
     /** The dbt no disk space. */
     int DBT_NO_DISK_SPACE = 0x0047;

File: contrib/platform/src/com/sun/jna/platform/win32/GL.java
Patch:
@@ -12,12 +12,10 @@
  */
 package com.sun.jna.platform.win32;
 
-import com.sun.jna.win32.StdCallLibrary;
-
 /**
  * Definitions for WinOpenGL
  */
-public interface GL extends StdCallLibrary {
+public interface GL {
     public final int GL_VENDOR = 0x1F00;
     public final int GL_RENDERER = 0x1F01;
     public final int GL_VERSION = 0x1F02;

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32.java
Patch:
@@ -18,17 +18,18 @@
 import com.sun.jna.ptr.IntByReference;
 import com.sun.jna.ptr.PointerByReference;
 import com.sun.jna.win32.W32APIOptions;
+import com.sun.jna.win32.StdCallLibrary;
 
 /**
  * Interface definitions for <code>kernel32.dll</code>. Includes additional
  * alternate mappings from {@link WinNT} which make use of NIO buffers,
  * {@link Wincon} for console API.
  */
-public interface Kernel32 extends WinNT, Wincon {
+public interface Kernel32 extends StdCallLibrary, WinNT, Wincon {
 
     /** The instance. */
     Kernel32 INSTANCE = (Kernel32) Native.loadLibrary("kernel32",
-            Kernel32.class, W32APIOptions.UNICODE_OPTIONS);
+            Kernel32.class, W32APIOptions.DEFAULT_OPTIONS);
 
     /**
      * Reads data from the specified file or input/output (I/O) device. Reads

File: contrib/platform/src/com/sun/jna/platform/win32/LMCons.java
Patch:
@@ -12,14 +12,12 @@
  */
 package com.sun.jna.platform.win32;
 
-import com.sun.jna.win32.StdCallLibrary;
-
 /**
  * Ported from LMCons.h.
  * @author dblock[at]dblock.org
  * Windows SDK 6.0A
  */
-public interface LMCons extends StdCallLibrary {
+public interface LMCons {
     int  NETBIOS_NAME_LEN = 16;            // NetBIOS net name (bytes)
 
     /**

File: contrib/platform/src/com/sun/jna/platform/win32/LMErr.java
Patch:
@@ -12,14 +12,12 @@
  */
 package com.sun.jna.platform.win32;
 
-import com.sun.jna.win32.StdCallLibrary;
-
 /**
  * Ported from LMErr.h.
  * @author dblock[at]dblock.org
  * Windows SDK 6.0A
  */
-public interface LMErr extends StdCallLibrary {
+public interface LMErr {
     int NERR_Success =  0;
     int NERR_BASE =  2100;
     

File: contrib/platform/src/com/sun/jna/platform/win32/LMJoin.java
Patch:
@@ -12,14 +12,12 @@
  */
 package com.sun.jna.platform.win32;
 
-import com.sun.jna.win32.StdCallLibrary;
-
 /**
  * Ported from LMJoin.h.
  * Windows SDK 6.0A.
  * @author dblock[at]dblock.org
  */
-public interface LMJoin extends StdCallLibrary {
+public interface LMJoin {
 
     /**
      * Status of a workstation.

File: contrib/platform/src/com/sun/jna/platform/win32/Msi.java
Patch:
@@ -21,7 +21,7 @@
 public interface Msi extends StdCallLibrary {
 
     Msi INSTANCE = (Msi)
-        Native.loadLibrary("msi", Msi.class, W32APIOptions.UNICODE_OPTIONS);
+        Native.loadLibrary("msi", Msi.class, W32APIOptions.DEFAULT_OPTIONS);
 
     /**
      * The component being requested is disabled on the computer.

File: contrib/platform/src/com/sun/jna/platform/win32/NTSecApi.java
Patch:
@@ -21,14 +21,13 @@
 import com.sun.jna.Union;
 import com.sun.jna.platform.win32.WinNT.LARGE_INTEGER;
 import com.sun.jna.platform.win32.WinNT.PSID;
-import com.sun.jna.win32.StdCallLibrary;
 
 /**
  * Ported from NTSecApi.h
  * Windows SDK 6.0A.
  * @author dblock[at]dblock.org
  */
-public interface NTSecApi extends StdCallLibrary {
+public interface NTSecApi {
 	
     /**
      * The LSA_UNICODE_STRING structure is used by various Local Security Authority (LSA) 

File: contrib/platform/src/com/sun/jna/platform/win32/NtDll.java
Patch:
@@ -26,7 +26,7 @@
 public interface NtDll extends StdCallLibrary {
 	
 	NtDll INSTANCE = (NtDll) Native.loadLibrary("NtDll",
-			NtDll.class, W32APIOptions.UNICODE_OPTIONS);
+			NtDll.class, W32APIOptions.DEFAULT_OPTIONS);
 
 	/**
 	 * The ZwQueryKey routine provides information about the class of a registry key, 
@@ -52,4 +52,4 @@ public interface NtDll extends StdCallLibrary {
 	 */
 	public int ZwQueryKey(HANDLE KeyHandle, int KeyInformationClass,
 			Structure KeyInformation, int Length, IntByReference ResultLength);
-}
\ No newline at end of file
+}

File: contrib/platform/src/com/sun/jna/platform/win32/Ole32.java
Patch:
@@ -34,7 +34,7 @@ public interface Ole32 extends StdCallLibrary {
 
     /** The instance. */
     Ole32 INSTANCE = (Ole32) Native.loadLibrary("Ole32", Ole32.class,
-                                                W32APIOptions.UNICODE_OPTIONS);
+                                                W32APIOptions.DEFAULT_OPTIONS);
 
     /**
      * Creates a GUID, a unique 128-bit integer used for CLSIDs and interface
@@ -217,6 +217,8 @@ HRESULT CoCreateInstance(GUID rclsid, Pointer pUnkOuter, int dwClsContext,
      * 
      *         REGDB_E_READREGDB The registry could not be opened for reading.
      */
+    HRESULT CLSIDFromString(String lpsz, CLSID.ByReference pclsid);
+    /** @deprecated use the String version */
     HRESULT CLSIDFromString(WString lpsz, CLSID.ByReference pclsid);
 
 	/**

File: contrib/platform/src/com/sun/jna/platform/win32/OleAuto.java
Patch:
@@ -100,7 +100,7 @@ public interface OleAuto extends StdCallLibrary {
 
 	/** The instance. */
 	OleAuto INSTANCE = (OleAuto) Native.loadLibrary("OleAut32", OleAuto.class,
-			W32APIOptions.UNICODE_OPTIONS);
+			W32APIOptions.DEFAULT_OPTIONS);
 
 	/**
 	 * This function allocates a new string and copies the passed string into
@@ -473,6 +473,8 @@ public HRESULT LoadRegTypeLib(GUID rguid, int wVerMajor, int wVerMinor,
 	 *            loaded.
          * @return status
 	 */
+	public HRESULT LoadTypeLib(String szFile, PointerByReference pptlib);
+        /** @deprecated use the String version */
 	public HRESULT LoadTypeLib(WString szFile, PointerByReference pptlib);
 
 	/**

File: contrib/platform/src/com/sun/jna/platform/win32/Pdh.java
Patch:
@@ -33,7 +33,7 @@
  */
 public interface Pdh extends StdCallLibrary {
     Pdh INSTANCE = (Pdh) Native.loadLibrary("Pdh",
-            Pdh.class, W32APIOptions.UNICODE_OPTIONS);
+            Pdh.class, W32APIOptions.DEFAULT_OPTIONS);
 
 
     /** Maximum counter name length. */

File: contrib/platform/src/com/sun/jna/platform/win32/Rasapi32.java
Patch:
@@ -33,7 +33,7 @@
  * Rasapi32.dll Interface.
  */
 public interface Rasapi32 extends StdCallLibrary {
-	Rasapi32 INSTANCE = (Rasapi32) Native.loadLibrary("Rasapi32", Rasapi32.class, W32APIOptions.UNICODE_OPTIONS);
+	Rasapi32 INSTANCE = (Rasapi32) Native.loadLibrary("Rasapi32", Rasapi32.class, W32APIOptions.DEFAULT_OPTIONS);
 
 	/**
 	 * The RasDial function establishes a RAS connection between a RAS client and a RAS server.

File: contrib/platform/src/com/sun/jna/platform/win32/Secur32.java
Patch:
@@ -30,7 +30,7 @@
  * @author dblock[at]dblock.org
  */
 public interface Secur32 extends StdCallLibrary {
-    Secur32 INSTANCE = (Secur32) Native.loadLibrary("Secur32", Secur32.class, W32APIOptions.UNICODE_OPTIONS);
+    Secur32 INSTANCE = (Secur32) Native.loadLibrary("Secur32", Secur32.class, W32APIOptions.DEFAULT_OPTIONS);
 	
     /**
      * Specifies a format for a directory service object name.

File: contrib/platform/src/com/sun/jna/platform/win32/Shell32.java
Patch:
@@ -30,7 +30,7 @@
 public interface Shell32 extends ShellAPI, StdCallLibrary {
 	
     Shell32 INSTANCE = (Shell32) Native.loadLibrary("shell32", Shell32.class, 
-    		W32APIOptions.UNICODE_OPTIONS);
+    		W32APIOptions.DEFAULT_OPTIONS);
 
 	/**
 	 * No dialog box confirming the deletion of the objects will be displayed.

File: contrib/platform/src/com/sun/jna/platform/win32/Tlhelp32.java
Patch:
@@ -15,12 +15,11 @@
 
 import com.sun.jna.Pointer;
 import com.sun.jna.Structure;
-import com.sun.jna.win32.StdCallLibrary;
 
 /**
  * Interface for the Tlhelp32.h header file.
  */
-public interface Tlhelp32 extends StdCallLibrary {
+public interface Tlhelp32 {
 
     /**
      * Includes all heaps of the process specified in th32ProcessID in the snapshot. To enumerate the heaps, see

File: contrib/platform/src/com/sun/jna/platform/win32/User32Util.java
Patch:
@@ -12,7 +12,6 @@
 import java.util.Arrays;
 import java.util.List;
 
-import com.sun.jna.WString;
 import com.sun.jna.platform.win32.WinDef.HINSTANCE;
 import com.sun.jna.platform.win32.WinDef.HMENU;
 import com.sun.jna.platform.win32.WinDef.HWND;
@@ -43,7 +42,7 @@ public static final HWND createWindow(final String className, final String windo
     public static final HWND createWindowEx(final int exStyle, final String className, final String windowName, final int style, final int x, final int y,
             final int width, final int height, final HWND parent, final HMENU menu, final HINSTANCE instance, final LPVOID param) {
         final HWND hWnd = User32.INSTANCE
-                .CreateWindowEx(exStyle, new WString(className), windowName, style, x, y, width, height, parent, menu, instance, param);
+                .CreateWindowEx(exStyle, className, windowName, style, x, y, width, height, parent, menu, instance, param);
         if (hWnd == null)
             throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
         return hWnd;
@@ -77,4 +76,4 @@ public static final List<RAWINPUTDEVICELIST> GetRawInputDeviceList() {
 
         return Arrays.asList(records);
     }
-}
\ No newline at end of file
+}

File: contrib/platform/src/com/sun/jna/platform/win32/VerRsrc.java
Patch:
@@ -15,12 +15,11 @@
 
 import com.sun.jna.Pointer;
 import com.sun.jna.Structure;
-import com.sun.jna.win32.StdCallLibrary;
 
 /**
  * Interface for the VerRsrc.h header file.
  */
-public interface VerRsrc extends StdCallLibrary {
+public interface VerRsrc {
 
     /**
      * Contains version information for a file. This information is language and code page independent.

File: contrib/platform/src/com/sun/jna/platform/win32/W32FileUtils.java
Patch:
@@ -15,7 +15,6 @@
 import java.io.File;
 import java.io.IOException;
 
-import com.sun.jna.WString;
 import com.sun.jna.platform.FileUtils;
 
 public class W32FileUtils extends FileUtils {
@@ -32,7 +31,7 @@ public void moveToTrash(File[] files) throws IOException {
         for (int i=0;i < paths.length;i++) {
             paths[i] = files[i].getAbsolutePath();
         }
-        fileop.pFrom = new WString(fileop.encodePaths(paths));
+        fileop.pFrom = fileop.encodePaths(paths);
         fileop.fFlags = ShellAPI.FOF_ALLOWUNDO|ShellAPI.FOF_NO_UI;
         int ret = shell.SHFileOperation(fileop);
         if (ret != 0) {

File: contrib/platform/src/com/sun/jna/platform/win32/Wdm.java
Patch:
@@ -18,14 +18,13 @@
 import com.sun.jna.Native;
 import com.sun.jna.Pointer;
 import com.sun.jna.Structure;
-import com.sun.jna.win32.StdCallLibrary;
 
 /**
  * Ported from Wdm.h.
  * Microsoft Windows DDK.
  * @author dblock[at]dblock.org
  */
-public interface Wdm extends StdCallLibrary {
+public interface Wdm {
 	
     /**
      * The KEY_BASIC_INFORMATION structure defines a subset of 

File: contrib/platform/src/com/sun/jna/platform/win32/WinCrypt.java
Patch:
@@ -20,14 +20,13 @@
 import com.sun.jna.Pointer;
 import com.sun.jna.Structure;
 import com.sun.jna.platform.win32.WinDef.HWND;
-import com.sun.jna.win32.StdCallLibrary;
 
 /**
  * Ported from WinCrypt.h.
  * Microsoft Windows SDK 6.0A.
  * @author dblock[at]dblock.org
  */
-public interface WinCrypt extends StdCallLibrary {
+public interface WinCrypt {
 	
     /**
      * The CryptoAPI CRYPTOAPI_BLOB structure is used for an arbitrary array of bytes.

File: contrib/platform/src/com/sun/jna/platform/win32/WinDef.java
Patch:
@@ -25,15 +25,14 @@
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.platform.win32.WinNT.HANDLEByReference;
 import com.sun.jna.ptr.ByReference;
-import com.sun.jna.win32.StdCallLibrary;
 
 /**
  * Ported from Windef.h (various macros and types). Microsoft Windows SDK 6.0A.
  *
  * @author dblock[at]dblock.org
  */
 @SuppressWarnings("serial")
-public interface WinDef extends StdCallLibrary {
+public interface WinDef {
 
     /** The max path. */
     int MAX_PATH = 260;

File: contrib/platform/src/com/sun/jna/platform/win32/WinGDI.java
Patch:
@@ -21,15 +21,14 @@
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.platform.win32.WinDef.HBITMAP;
 import com.sun.jna.platform.win32.WinDef.RECT;
-import com.sun.jna.win32.StdCallLibrary;
 
 /**
  * Ported from WinGDI.h. 
  * Microsoft Windows SDK 6.0A.
  * @author dblock[at]dblock.org
  * @author Andreas "PAX" L&uuml;ck, onkelpax-git[at]yahoo.de
  */
-public interface WinGDI extends StdCallLibrary {
+public interface WinGDI {
     int RDH_RECTANGLES = 1;
 
     class RGNDATAHEADER extends Structure {

File: contrib/platform/src/com/sun/jna/platform/win32/WinNT.java
Patch:
@@ -26,6 +26,7 @@
 import com.sun.jna.Structure;
 import com.sun.jna.Union;
 import com.sun.jna.ptr.ByReference;
+import com.sun.jna.win32.StdCallLibrary.StdCallCallback;
 
 /**
  * This module defines the 32-Bit Windows types and constants that are defined

File: contrib/platform/src/com/sun/jna/platform/win32/WinRas.java
Patch:
@@ -26,12 +26,12 @@
 import com.sun.jna.platform.win32.WinDef.HWND;
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.platform.win32.WinNT.LUID;
-import com.sun.jna.win32.StdCallLibrary;
+import com.sun.jna.win32.StdCallLibrary.StdCallCallback;
 
 /**
  * Definitions for RASAPI32
  */
-public interface WinRas extends StdCallLibrary {
+public interface WinRas {
 	public static final int ERROR_BUFFER_TOO_SMALL = 603;
 	public static final int ERROR_CANNOT_FIND_PHONEBOOK_ENTRY = 623;
 

File: contrib/platform/src/com/sun/jna/platform/win32/WinReg.java
Patch:
@@ -15,7 +15,6 @@
 import com.sun.jna.Pointer;
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.ptr.ByReference;
-import com.sun.jna.win32.StdCallLibrary;
 
 /**
  * This module contains the function prototypes and constant, type and structure 
@@ -24,7 +23,7 @@
  * Microsoft Windows SDK 6.0A.
  * @author dblock[at]dblock.org
  */
-public interface WinReg extends StdCallLibrary {
+public interface WinReg {
 	
     public static class HKEY extends HANDLE {
         public HKEY() { }

File: contrib/platform/src/com/sun/jna/platform/win32/Winioctl.java
Patch:
@@ -15,12 +15,11 @@
 
 import com.sun.jna.Pointer;
 import com.sun.jna.Structure;
-import com.sun.jna.win32.StdCallLibrary;
 
 /**
  * Interface for the Winioctl.h header file.
  */
-public interface Winioctl extends StdCallLibrary {
+public interface Winioctl {
 
     /**
      * Retrieves the device type, device number, and, for a partitionable device, the partition number of a device.

File: contrib/platform/src/com/sun/jna/platform/win32/Winspool.java
Patch:
@@ -93,7 +93,7 @@ public interface Winspool extends StdCallLibrary {
     int PRINTER_ENUM_HIDE = 0x01000000;
 
     Winspool INSTANCE = (Winspool) Native.loadLibrary("Winspool.drv",
-            Winspool.class, W32APIOptions.UNICODE_OPTIONS);
+            Winspool.class, W32APIOptions.DEFAULT_OPTIONS);
 
     /**
      * The EnumPrinters function enumerates available printers, print servers,

File: contrib/platform/src/com/sun/jna/platform/win32/Winsvc.java
Patch:
@@ -19,7 +19,6 @@
 import com.sun.jna.Memory;
 import com.sun.jna.Structure;
 import com.sun.jna.platform.win32.WinNT.HANDLE;
-import com.sun.jna.win32.StdCallLibrary;
 
 /**
  * This module defines the 32-Bit Windows types and constants that are defined
@@ -28,7 +27,7 @@
  * Microsoft Windows SDK 7.0A.
  * @author EugineLev
  */
-public interface Winsvc extends StdCallLibrary {	
+public interface Winsvc {	
 
     /**
      *  Contains status information for a service. The ControlService, EnumDependentServices,

File: src/com/sun/jna/Pointer.java
Patch:
@@ -1437,7 +1437,9 @@ public void setWideString(long offset, String value) {
         public void setMemory(long offset, long size, byte value) {
             throw new UnsupportedOperationException(MSG); 
         }
-        public String dump(long offset, int size) { throw new UnsupportedOperationException(MSG); }
+        public String dump(long offset, int size) {
+            throw new UnsupportedOperationException(MSG);
+        }
         public String toString() {
             return "const@0x" + Long.toHexString(peer);
         }

File: test/com/sun/jna/PlatformTest.java
Patch:
@@ -57,6 +57,9 @@ public void testOSPrefix() {
         assertEquals("Wrong resource path Linux/ppc", "linux-ppc",
                      Platform.getNativeLibraryResourcePrefix(Platform.LINUX,
                                                              "powerpc", "Linux"));
+        assertEquals("Wrong resource path Linux/sparcv9", "linux-sparcv9",
+                     Platform.getNativeLibraryResourcePrefix(Platform.LINUX,
+                                                             "sparcv9", "Linux"));
         assertEquals("Wrong resource path OpenBSD/x86", "openbsd-x86",
                      Platform.getNativeLibraryResourcePrefix(Platform.OPENBSD,
                                                              "x86", "OpenBSD"));

File: src/com/sun/jna/Native.java
Patch:
@@ -96,8 +96,8 @@
 public final class Native implements Version {
 
     public static final String DEFAULT_ENCODING = "utf8";
-    static final boolean DEBUG_LOAD = Boolean.getBoolean("jna.debug_load");
-    static final boolean DEBUG_JNA_LOAD = Boolean.getBoolean("jna.debug_load.jna");
+    public static boolean DEBUG_LOAD = Boolean.getBoolean("jna.debug_load");
+    public static boolean DEBUG_JNA_LOAD = Boolean.getBoolean("jna.debug_load.jna");
 
     // Used by tests, do not remove
     static String jnidispatchPath = null;

File: src/com/sun/jna/Native.java
Patch:
@@ -96,8 +96,8 @@
 public final class Native implements Version {
 
     public static final String DEFAULT_ENCODING = "utf8";
-    static final boolean DEBUG_LOAD = Boolean.getBoolean("jna.debug_load");
-    static final boolean DEBUG_JNA_LOAD = Boolean.getBoolean("jna.debug_load.jna");
+    public static boolean DEBUG_LOAD = Boolean.getBoolean("jna.debug_load");
+    public static boolean DEBUG_JNA_LOAD = Boolean.getBoolean("jna.debug_load.jna");
 
     // Used by tests, do not remove
     static String jnidispatchPath = null;

File: test/com/sun/jna/DirectReturnTypesTest.java
Patch:
@@ -75,6 +75,8 @@ public DirectObjectTestLibrary(Map options) {
 
     public static class DirectNativeMappedLibrary implements NativeMappedLibrary {
         public native Custom returnInt32Argument(int arg);
+        public native size_t returnInt32Magic();
+        public native size_t returnInt64Magic();
         static {
             Native.register("testlib");
         }

File: test/com/sun/jna/DirectArgumentsMarshalTest.java
Patch:
@@ -92,6 +92,8 @@ protected void setUp() {
     
     public static class DirectNativeMappedLibrary implements NativeMappedLibrary {
         public native int returnInt32Argument(Custom arg);
+        public native int returnInt32Argument(size_t arg);
+        public native long returnInt64Argument(size_t arg);
         static {
             Native.register("testlib");
         }

File: src/com/sun/jna/Version.java
Patch:
@@ -12,6 +12,6 @@
  */
 package com.sun.jna;
 interface Version {
-    String VERSION = "4.2.0-SNAPSHOT";
+    String VERSION = "4.2.0";
     String VERSION_NATIVE = "4.0.1";
 }

File: test/com/sun/jna/PlatformTest.java
Patch:
@@ -57,6 +57,9 @@ public void testOSPrefix() {
         assertEquals("Wrong resource path Linux/ppc", "linux-ppc",
                      Platform.getNativeLibraryResourcePrefix(Platform.LINUX,
                                                              "powerpc", "Linux"));
+        assertEquals("Wrong resource path Linux/sparcv9", "linux-sparcv9",
+                     Platform.getNativeLibraryResourcePrefix(Platform.LINUX,
+                                                             "sparcv9", "Linux"));
         assertEquals("Wrong resource path OpenBSD/x86", "openbsd-x86",
                      Platform.getNativeLibraryResourcePrefix(Platform.OPENBSD,
                                                              "x86", "OpenBSD"));

File: test/com/sun/jna/MemoryTest.java
Patch:
@@ -42,7 +42,7 @@ protected void finalize() {
         shared = null;
         System.gc();
         Memory.purge();
-        for (int i=0;i < GC_WAITS && ref.get() != null) {
+        for (int i=0;i < GC_WAITS && ref.get() != null;i++) {
             Thread.sleep(GC_WAIT_INTERVAL);
             System.gc();
             Memory.purge();

File: src/com/sun/jna/Structure.java
Patch:
@@ -1556,7 +1556,7 @@ private Class baseClass() {
 
     /** Return whether the given Structure's backing data is identical to
      * this one.
-     * @param o object to compare
+     * @param s Structure to compare
      * @return equality result
      */
     public boolean dataEquals(Structure s) {

File: src/com/sun/jna/Structure.java
Patch:
@@ -1556,7 +1556,7 @@ private Class baseClass() {
 
     /** Return whether the given Structure's backing data is identical to
      * this one.
-     * @param o object to compare
+     * @param s Structure to compare
      * @return equality result
      */
     public boolean dataEquals(Structure s) {

File: src/com/sun/jna/CallbackReference.java
Patch:
@@ -165,13 +165,14 @@ private CallbackReference(Callback callback, int callingConvention, boolean dire
                     direct = false;
                     break;
                 }
-                // No TypeMapper support in native callback code
+                // Direct mode callbacks do not support TypeMapper
                 if (mapper != null
                     && mapper.getFromNativeConverter(ptypes[i]) != null) {
                     direct = false;
                     break;
                 }
             }
+            // Direct mode callbacks do not support TypeMapper
             if (mapper != null
                 && mapper.getToNativeConverter(m.getReturnType()) != null) {
                 direct = false;

File: src/com/sun/jna/NativeMapped.java
Patch:
@@ -15,7 +15,8 @@
 /** Provide conversion for a Java type to and from a native type.  
  * {@link Function} and {@link Structure} will use this interface to determine
  * how to map a given Java object into a native type.<p>
- * Implementations of this interface must provide a no-args constructor. 
+ * Implementations of this interface must provide a no-args constructor.</p>
+ * <p>See {@link ToNativeConverter} for a list of allowable native types.</p>
  * @author wmeissner 
  */
 public interface NativeMapped {

File: src/com/sun/jna/ToNativeConverter.java
Patch:
@@ -32,8 +32,8 @@ public interface ToNativeConverter {
      * <li>{@link Structure}
      * <li>String
      * <li>{@link WString}
-     * <li>{@link java.nio.Buffer}
-     * <li>primitive array
+     * <li>{@link java.nio.Buffer} (unsupported in direct mode)
+     * <li>primitive array (unsupported in direct mode)
      * </ul>
      */
     Object toNative(Object value, ToNativeContext context);

File: test/com/sun/jna/DirectCallbacksTest.java
Patch:
@@ -33,8 +33,8 @@ public static class DirectTestLibrary implements TestLibrary {
         public native float callFloatCallback(FloatCallback c, float arg, float arg2);
         public native double callDoubleCallback(DoubleCallback c, double arg, double arg2);
         public native SmallTestStructure callStructureCallback(StructureCallback c, SmallTestStructure arg);
-        public native String callStringCallback(StringCallback c, String arg);
-        public native WString callWideStringCallback(WideStringCallback c, WString arg);
+        public native String callStringCallback(StringCallback c, String arg, String arg2);
+        public native WString callWideStringCallback(WideStringCallback c, WString arg, WString arg2);
         public Pointer callStringArrayCallback(StringArrayCallback c, String[] arg) { throw new UnsupportedOperationException(); }
         public native int callCallbackWithByReferenceArgument(CopyArgToByReference cb, int arg, IntByReference result);
         public native TestStructure.ByValue callCallbackWithStructByValue(TestStructure.TestCallback callback, TestStructure.ByValue cbstruct);
@@ -64,6 +64,7 @@ protected Map callbackCache() {
     public static class DirectCallbackTestLibrary implements CallbackTestLibrary {
         public native double callInt32Callback(DoubleCallback c, double arg, double arg2);
         public native float callInt64Callback(FloatCallback c, float arg, float arg2);
+        public native String callWideStringCallback(WStringCallback c, String arg, String arg2);
         static {
             Native.register(NativeLibrary.getInstance("testlib", _OPTIONS));
         }

File: src/com/sun/jna/CallbackReference.java
Patch:
@@ -165,13 +165,14 @@ private CallbackReference(Callback callback, int callingConvention, boolean dire
                     direct = false;
                     break;
                 }
-                // No TypeMapper support in native callback code
+                // Direct mode callbacks do not support TypeMapper
                 if (mapper != null
                     && mapper.getFromNativeConverter(ptypes[i]) != null) {
                     direct = false;
                     break;
                 }
             }
+            // Direct mode callbacks do not support TypeMapper
             if (mapper != null
                 && mapper.getToNativeConverter(m.getReturnType()) != null) {
                 direct = false;

File: src/com/sun/jna/NativeMapped.java
Patch:
@@ -15,7 +15,8 @@
 /** Provide conversion for a Java type to and from a native type.  
  * {@link Function} and {@link Structure} will use this interface to determine
  * how to map a given Java object into a native type.<p>
- * Implementations of this interface must provide a no-args constructor. 
+ * Implementations of this interface must provide a no-args constructor.</p>
+ * <p>See {@link ToNativeConverter} for a list of allowable native types.</p>
  * @author wmeissner 
  */
 public interface NativeMapped {

File: src/com/sun/jna/ToNativeConverter.java
Patch:
@@ -32,8 +32,8 @@ public interface ToNativeConverter {
      * <li>{@link Structure}
      * <li>String
      * <li>{@link WString}
-     * <li>{@link java.nio.Buffer}
-     * <li>primitive array
+     * <li>{@link java.nio.Buffer} (unsupported in direct mode)
+     * <li>primitive array (unsupported in direct mode)
      * </ul>
      */
     Object toNative(Object value, ToNativeContext context);

File: test/com/sun/jna/DirectCallbacksTest.java
Patch:
@@ -33,8 +33,8 @@ public static class DirectTestLibrary implements TestLibrary {
         public native float callFloatCallback(FloatCallback c, float arg, float arg2);
         public native double callDoubleCallback(DoubleCallback c, double arg, double arg2);
         public native SmallTestStructure callStructureCallback(StructureCallback c, SmallTestStructure arg);
-        public native String callStringCallback(StringCallback c, String arg);
-        public native WString callWideStringCallback(WideStringCallback c, WString arg);
+        public native String callStringCallback(StringCallback c, String arg, String arg2);
+        public native WString callWideStringCallback(WideStringCallback c, WString arg, WString arg2);
         public Pointer callStringArrayCallback(StringArrayCallback c, String[] arg) { throw new UnsupportedOperationException(); }
         public native int callCallbackWithByReferenceArgument(CopyArgToByReference cb, int arg, IntByReference result);
         public native TestStructure.ByValue callCallbackWithStructByValue(TestStructure.TestCallback callback, TestStructure.ByValue cbstruct);
@@ -64,6 +64,7 @@ protected Map callbackCache() {
     public static class DirectCallbackTestLibrary implements CallbackTestLibrary {
         public native double callInt32Callback(DoubleCallback c, double arg, double arg2);
         public native float callInt64Callback(FloatCallback c, float arg, float arg2);
+        public native String callWideStringCallback(WStringCallback c, String arg, String arg2);
         static {
             Native.register(NativeLibrary.getInstance("testlib", _OPTIONS));
         }

File: test/com/sun/jna/win32/W32StdCallTest.java
Patch:
@@ -122,7 +122,7 @@ public void testStdCallReturnInt32Argument() {
     
     public void testStdCallReturnStructureByValueArgument() {
         TestLibrary.TestStructure.ByValue s = new TestLibrary.TestStructure.ByValue();
-        assertEquals("Wrong value", s, testlib.returnStructureByValueArgumentStdCall(s));
+        assertTrue("Wrong struct value", s.dataEquals(testlib.returnStructureByValueArgumentStdCall(s)));
     }
     
     public void testStdCallCallback() {

File: test/com/sun/jna/win32/W32StdCallTest.java
Patch:
@@ -122,7 +122,7 @@ public void testStdCallReturnInt32Argument() {
     
     public void testStdCallReturnStructureByValueArgument() {
         TestLibrary.TestStructure.ByValue s = new TestLibrary.TestStructure.ByValue();
-        assertEquals("Wrong value", s, testlib.returnStructureByValueArgumentStdCall(s));
+        assertTrue("Wrong struct value", s.dataEquals(testlib.returnStructureByValueArgumentStdCall(s)));
     }
     
     public void testStdCallCallback() {

File: contrib/platform/src/com/sun/jna/platform/FileUtils.java
Patch:
@@ -28,8 +28,9 @@ public boolean hasTrash() {
     }
 
     /** Move the given file to the system trash, if one is available.
-        Throws an exception on failure.
-    */
+     * @param files files to move
+     * @throws IOException on failure.
+     */
     public abstract void moveToTrash(File[] files) throws IOException;
 
     /** Canonical lazy loading of a singleton. */

File: contrib/platform/src/com/sun/jna/platform/WindowUtils.java
Patch:
@@ -159,11 +159,11 @@ public class WindowUtils {
      * Ideally we'd have more control over {@link PopupFactory} but this
      * is a fairly simple, lightweight workaround.  Note that, at least as of
      * JDK 1.6, the following do not have the desired effect:<br>
-     * <code><pre>
+     * <pre><code>
      * ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
      * JPopupMenu.setDefaultLightWeightPopupEnabled(false);
      * System.setProperty("JPopupMenu.defaultLWPopupEnabledKey", "false");
-     * </pre></code>
+     * </code></pre>
      */
     private static class HeavyweightForcer extends Window {
 		private static final long serialVersionUID = 1L;

File: contrib/platform/src/com/sun/jna/platform/mac/Carbon.java
Patch:
@@ -42,6 +42,7 @@ public interface Carbon extends Library {
 
     /**
      * Obtains the event target reference for the standard toolbox dispatcher
+     * @return event dispatcher reference
      */
     public Pointer GetEventDispatcherTarget();
 

File: contrib/platform/src/com/sun/jna/platform/mac/XAttr.java
Patch:
@@ -17,7 +17,7 @@
 import com.sun.jna.Pointer;
 
 /**
- * JNA wrapper for <sys/xattr.h>
+ * JNA wrapper for &lt;sys/xattr.h&gt;
  * 
  */
 interface XAttr extends Library {

File: contrib/platform/src/com/sun/jna/platform/win32/COM/IConnectionPoint.java
Patch:
@@ -26,7 +26,7 @@ public interface IConnectionPoint extends IUnknown {
 	 * 
 	 * 
 	 * @param iid
-	 * @return
+	 * @return interface pointer
 	 */
 	HRESULT GetConnectionInterface(IID iid);
 	
@@ -53,14 +53,14 @@ public interface IConnectionPoint extends IUnknown {
 	 * 
 	 * @param pUnkSink
 	 * @param pdwCookie
-	 * @return
+	 * @return status
 	 */
 	WinNT.HRESULT Advise(IUnknownCallback pUnkSink, DWORDByReference pdwCookie);
 	
 	/**
 	 * 
 	 * @param dwCookie
-	 * @return
+	 * @return status
 	 */
 	HRESULT Unadvise(DWORD dwCookie);
 }

File: contrib/platform/src/com/sun/jna/platform/win32/COM/IConnectionPointContainer.java
Patch:
@@ -29,7 +29,7 @@ public interface IConnectionPointContainer extends IUnknown {
 	  * }
 	  * @param riid
 	  * @param ppCP
-	  * @return
+	  * @return hresult
 	  */
 	 public HRESULT FindConnectionPoint(  REFIID riid,  PointerByReference ppCP );
 }

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/Factory.java
Patch:
@@ -73,7 +73,7 @@ public ComThread getComThread() {
 	 * CoInitialize must be called be fore this method. Either explicitly or
 	 * implicitly via other methods.
 	 * 
-	 * @return
+	 * @return running object table
 	 */
 	public IRunningObjectTable getRunningObjectTable() {
 		try {
@@ -117,7 +117,7 @@ public <T> T createProxy(Class<T> comInterface, IDispatch dispatch) {
 	 * @param comInterface
 	 * @param unknownId
 	 * @param dispatch
-	 * @return
+	 * @return proxy object
 	 */
 	<T> T createProxy(Class<T> comInterface, long unknownId, IDispatch dispatch) {
 		ProxyObject jop = new ProxyObject(comInterface, unknownId, dispatch, this);

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/IRunningObjectTable.java
Patch:
@@ -35,7 +35,7 @@ public interface IRunningObjectTable {
 	 * those for which queryInterface(iid) gives a valid result.
 	 * 
 	 * @param comInterface
-	 * @return
+	 * @return active objects
 	 */
 	<T> List<T> getActiveObjectsByInterface(Class<T> comInterface);
 }

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32.java
Patch:
@@ -52,7 +52,7 @@ public int NetGetJoinInformation(String lpServer,
 	/**
 	 * Frees the memory that the NetApiBufferAllocate function allocates.
 	 * 
-	 * @param buffer
+	 * @param buffer buffer
 	 * @return If the function succeeds, the return value is NERR_Success. If
 	 *         the function fails, the return value is a system error code.
 	 */

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32Util.java
Patch:
@@ -154,7 +154,7 @@ public static int getJoinStatus(String computerName) {
 	
     /**
      * Get information about a computer.
-     * @param computerName
+     * @param computerName computer name
      * @return Domain or workgroup name.
      */
     public static String getDomainName(String computerName) {

File: contrib/platform/src/com/sun/jna/platform/win32/OaIdl.java
Patch:
@@ -1278,6 +1278,7 @@ protected List getFieldOrder() {
         /**
          * @param tdescElem
          *            C type : TYPEDESC<br>
+         * @param cDims dimensions
          * @param rgbounds
          *            [size_is]<br>
          *            C type : SAFEARRAYBOUND[1]

File: contrib/platform/src/com/sun/jna/platform/win32/OleAuto.java
Patch:
@@ -272,7 +272,7 @@ public SAFEARRAY.ByReference SafeArrayCreate(VARTYPE vt, int cDims,
 	 * @param rgIndices
 	 *            [in] A vector of indexes for each dimension of the array. The
 	 *            right-most (least significant) dimension is rgIndices[0]. The
-	 *            left-most dimension is stored at rgIndices[psa->cDims - 1].
+	 *            left-most dimension is stored at rgIndices[psa-&gt;cDims - 1].
 	 * @param pv
 	 *            [out] The element of the array.
 	 * 
@@ -435,6 +435,7 @@ protected List getFieldOrder() {
 	 * 
 	 *            TYPE_E_CANTLOADLIBRARY The type library or DLL could not be
 	 *            loaded.
+         * @return status
 	 */
 	public HRESULT LoadRegTypeLib(GUID rguid, int wVerMajor, int wVerMinor,
 			LCID lcid, PointerByReference pptlib);
@@ -470,6 +471,7 @@ public HRESULT LoadRegTypeLib(GUID rguid, int wVerMajor, int wVerMinor,
 	 * 
 	 *            TYPE_E_CANTLOADLIBRARY The type library or DLL could not be
 	 *            loaded.
+         * @return status
 	 */
 	public HRESULT LoadTypeLib(WString szFile, PointerByReference pptlib);
 

File: contrib/platform/src/com/sun/jna/platform/win32/Pdh.java
Patch:
@@ -123,7 +123,7 @@ protected List<String> getFieldOrder() {
 
     /**
      * Creates a full counter path using the members specified in the
-     * {@link #PDH_COUNTER_PATH_ELEMENTS} structure.
+     * {@link Pdh.PDH_COUNTER_PATH_ELEMENTS} structure.
      * @param pCounterPathElements Structure that contains the members
      * used to make up the path
      * @param szFullPathBuffer Caller-allocated buffer that receives a null-terminated
@@ -249,7 +249,7 @@ protected List<String> getFieldOrder() {
      * query and updates the status code of each counter.
      * @param hQuery Handle to the query
      * @param pllTimeStamp Time stamp when the first counter value in the query
-     * was retrieved. The time is specified as {@link WinBase#FILETIME}.
+     * was retrieved. The time is specified as {@link WinBase.FILETIME}.
      * @return ERROR_SUCCESS if successful
      * @see <A HREF="https://msdn.microsoft.com/en-us/library/windows/desktop/aa372569(v=vs.85).aspx">PdhCollectQueryDataWithTime</A>
      */

File: contrib/platform/src/com/sun/jna/platform/win32/PdhMsg.java
Patch:
@@ -162,15 +162,15 @@ public interface PdhMsg {
     public static final int PDH_PLA_ERROR_TYPE_MISMATCH = 0xC0000BEF;
     /** The information specified does not resolve to a valid path name. */
     public static final int PDH_PLA_ERROR_FILEPATH = 0xC0000BF0;
-    /** The &quot;Performance Logs & Alerts&quot; service did not respond. */
+    /** The &quot;Performance Logs &amp; Alerts&quot; service did not respond. */
     public static final int PDH_PLA_SERVICE_ERROR = 0xC0000BF1;
     /** The information passed is not valid. */
     public static final int PDH_PLA_VALIDATION_ERROR = 0xC0000BF2;
     /** The information passed is not valid. */
     public static final int PDH_PLA_VALIDATION_WARNING = 0x80000BF3;
     /** The name supplied is too long. */
     public static final int PDH_PLA_ERROR_NAME_TOO_LONG = 0xC0000BF4;
-    /** SQL log format is incorrect. Correct format is &quot;SQL:<DSN-name>!<LogSet-Name>&quot;. */
+    /** SQL log format is incorrect. Correct format is &quot;SQL:&lt;DSN-name&gt;!&lt;LogSet-Name&gt;&quot;. */
     public static final int PDH_INVALID_SQL_LOG_FORMAT = 0xC0000BF5;
     /** Performance counter in PdhAddCounter call has already been added in the performance query. */
     public static final int PDH_COUNTER_ALREADY_IN_QUERY = 0xC0000BF6;

File: contrib/platform/src/com/sun/jna/platform/win32/Rasapi32.java
Patch:
@@ -230,6 +230,7 @@ public interface Rasapi32 extends StdCallLibrary {
 	 *            Pointer to a buffer that receives the error string. This parameter must not be NULL.
 	 * @param cBufSize
 	 *            Specifies the size, in characters, of the buffer pointed to by lpszErrorString.
+         * @return status
 	 */
 	public int RasGetErrorString(int uErrorValue, char[] lpszErrorString, int cBufSize);
 }

File: contrib/platform/src/com/sun/jna/platform/win32/Rasapi32Util.java
Patch:
@@ -240,6 +240,7 @@ public static RASDIALPARAMS getPhoneBookDialingParams(String entryName) throws R
 	/**
 	 * Dial a phone book entry by name (Synchronously)
 	 * @param entryName The phone book entry name
+         * @return result reference
 	 * @throws Ras32Exception errors
 	 */
 	public static HANDLE dialEntry(String entryName) throws Ras32Exception {
@@ -271,6 +272,7 @@ public static HANDLE dialEntry(String entryName) throws Ras32Exception {
 	/**
 	 * Dial a phone book entry by name (Asynchronously - callback type 2)
 	 * @param entryName The phone book entry name
+         * @param func2
 	 * @return the HRASCONN for this connection
 	 * @throws Ras32Exception errors
 	 */

File: contrib/platform/src/com/sun/jna/platform/win32/Shell32.java
Patch:
@@ -88,11 +88,11 @@ HRESULT SHGetFolderPath(HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlag
      *        resource once it is no longer needed by calling {@link Ole32#CoTaskMemFree}. The returned path does not include a trailing
      *        backslash. For example, "C:\Users" is returned rather than "C:\Users\".
      * @return Returns S_OK if successful, or an error value otherwise, including the following: 
-     *        <li>E_FAIL Among other things, this value can indicate that the rfid parameter references a KNOWNFOLDERID which 
+     *        <ul><li>E_FAIL Among other things, this value can indicate that the rfid parameter references a KNOWNFOLDERID which 
      *        does not have a path (such as a folder marked as KF_CATEGORY_VIRTUAL).</li> 
      *        <li>E_INVALIDARG Among other things, this value can indicate that the rfid parameter references a KNOWNFOLDERID 
      *        that is not present on the system. Not all KNOWNFOLDERID values are present on all systems. Use 
-     *        IKnownFolderManager::GetFolderIds to retrieve the set of KNOWNFOLDERID values for the current system.</li>
+     *        IKnownFolderManager::GetFolderIds to retrieve the set of KNOWNFOLDERID values for the current system.</li></ul>
      */
     HRESULT SHGetKnownFolderPath(GUID rfid, int dwFlags, HANDLE hToken, PointerByReference ppszPath);
 
@@ -160,7 +160,7 @@ HRESULT SHGetFolderPath(HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlag
      *   that indicates the cause of the failure. The return value is cast as an HINSTANCE for backward compatibility
      *   with 16-bit Windows applications. It is not a true HINSTANCE, however. It can be cast only to an int and
      *   compared to either 32 or the following error codes below.
-     * <p/>
+     * 
      * NOTE: {@link WinDef.INT_PTR} is used instead of HINSTANCE here, since
      *   the former fits the reutrn type's actual usage more closely.
      *

File: contrib/platform/src/com/sun/jna/platform/win32/ShlObj.java
Patch:
@@ -148,11 +148,13 @@ public enum KNOWN_FOLDER_FLAG
          * predefined for that folder are applied. If the folder does not exist and cannot be created, the function
          * returns a failure code and no path is returned. This value can be used only with the following functions and
          * methods: 
+         * <ul>
          * <li>SHGetKnownFolderPath</li> 
          * <li>SHGetKnownFolderIDList</li> 
          * <li>IKnownFolder::GetIDList</li>
          * <li>IKnownFolder::GetPath</li> 
          * <li>IKnownFolder::GetShellItem</li>
+         * </ul>
          */
         CREATE(0x00008000),
         /**

File: contrib/platform/src/com/sun/jna/platform/win32/Sspi.java
Patch:
@@ -334,8 +334,8 @@ public SecBufferDesc(int type, byte[] token) {
 	    
         /**
          * Create a new SecBufferDesc with one SecBuffer of a given type and size.
-         * @param type
-         * @param tokenSize
+         * @param type type
+         * @param tokenSize token size
          */
         public SecBufferDesc(int type, int tokenSize) {
             pBuffers[0] = new SecBuffer.ByReference(type, tokenSize);

File: contrib/platform/src/com/sun/jna/platform/win32/Variant.java
Patch:
@@ -741,6 +741,7 @@ public VariantArg() {
 
         /**
          * construct VariantArg cast onto pre-allocated memory
+         * @param pointer base address
          */
         public VariantArg(Pointer pointer) {
         	super(pointer);

File: contrib/platform/src/com/sun/jna/platform/win32/W32Errors.java
Patch:
@@ -161,7 +161,7 @@ public static final HRESULT HRESULT_FROM_WIN32(int x) {
 	/**
 	 * FACILITY_USERMODE_FILTER_MANAGER
 	 * 
-	 * Translation macro for converting: NTSTATUS --> HRESULT.
+	 * Translation macro for converting: NTSTATUS --&gt; HRESULT.
 	 *
 	 * @param x the x
 	 * @return the int

File: src/com/sun/jna/PointerType.java
Patch:
@@ -43,7 +43,9 @@ public Object toNative() {
         return getPointer();
     }
 
-    /** Returns the associated native {@link Pointer}. */
+    /** Returns the associated native {@link Pointer}.
+        @return Native pointer representation for this object.
+     */
     public Pointer getPointer() {
         return pointer;
     }

File: src/com/sun/jna/Union.java
Patch:
@@ -67,6 +67,7 @@ protected List getFieldOrder() {
     /** Indicates by type which field will be used to write to native memory.
      * If there are multiple fields of the same type, use {@link
      * #setType(String)} instead with the field name.
+     * @param type desired active type for the union
      * @throws IllegalArgumentException if the type does not correspond to
      * any declared union field.
      */
@@ -84,6 +85,7 @@ public void setType(Class type) {
 
     /**
      * Indicates which field will be used to write to native memory.
+     * @param fieldName desired field to use for the active union type
      * @throws IllegalArgumentException if the name does not correspond to
      * any declared union field.
      */

File: test/com/sun/jna/ArgumentsMarshalTest.java
Patch:
@@ -565,9 +565,9 @@ public void testStructureByReferenceArrayArgument() {
             null,
             new CheckFieldAlignment.ByReference(),
         };
-        assertEquals("Wrong value returned (0)", args[0], lib.returnPointerArrayElement(args, 0));
+        assertTrue("Wrong value returned (0)", args[0].dataEquals(lib.returnPointerArrayElement(args, 0)));
         assertNull("Wrong value returned (1)", lib.returnPointerArrayElement(args, 1));
-        assertEquals("Wrong value returned (2)", args[2], lib.returnPointerArrayElement(args, 2));
+        assertTrue("Wrong value returned (2)", args[2].dataEquals(lib.returnPointerArrayElement(args, 2)));
         assertNull("Native array should be null terminated", lib.returnPointerArrayElement(args, 3));
     }
 

File: test/com/sun/jna/CallbacksTest.java
Patch:
@@ -741,8 +741,8 @@ public TestStructure.ByValue callback(TestStructure.ByValue s) {
                    + arg[0].getPointer(), arg[0].getPointer() instanceof Memory);
         assertTrue("ByValue result should own its own memory, instead was "
                    + result.getPointer(), result.getPointer() instanceof Memory);
-        assertEquals("Wrong value for callback argument", s, arg[0]);
-        assertEquals("Wrong value for callback result", s, result);
+        assertTrue("Wrong value for callback argument", s.dataEquals(arg[0]));
+        assertTrue("Wrong value for callback result", s.dataEquals(result));
     }
     
     public void testUnionByValueCallbackArgument() throws Exception{ 

File: contrib/platform/src/com/sun/jna/platform/win32/W32Service.java
Patch:
@@ -86,8 +86,8 @@ public void setFailureActions(List<SC_ACTION> actions, int resetPeriod, String r
 			String command) {
 		SERVICE_FAILURE_ACTIONS.ByReference actionStruct = new SERVICE_FAILURE_ACTIONS.ByReference();
 		actionStruct.dwResetPeriod = resetPeriod;
-		actionStruct.setRebootMessage(rebootMsg);
-		actionStruct.setCommand(command);
+		actionStruct.lpRebootMsg = rebootMsg;
+		actionStruct.lpCommand = command;
 		actionStruct.cActions = actions.size();
 
 		actionStruct.lpsaActions = new SC_ACTION.ByReference();

File: contrib/platform/test/com/sun/jna/platform/win32/W32ServiceTest.java
Patch:
@@ -108,8 +108,8 @@ public void testSetAndGetFailureActions() {
 		service.setFailureActions(actions, resetPeriod, rebootMsg, command);
 
 		SERVICE_FAILURE_ACTIONS changedActions = service.getFailureActions();
-		assertEquals(changedActions.getRebootMessage(), rebootMsg);
-		assertEquals(changedActions.getCommand(), command);
+		assertEquals(changedActions.lpRebootMsg, rebootMsg);
+		assertEquals(changedActions.lpCommand, command);
 		assertEquals(changedActions.dwResetPeriod, resetPeriod);
 		assertEquals(changedActions.cActions, 4);
 		SC_ACTION[] actionArray = (SC_ACTION[])changedActions.lpsaActions.toArray(changedActions.cActions);

File: contrib/platform/src/com/sun/jna/platform/win32/Advapi32.java
Patch:
@@ -48,7 +48,7 @@
  */
 public interface Advapi32 extends StdCallLibrary {
 	Advapi32 INSTANCE = (Advapi32) Native.loadLibrary("Advapi32",
-			Advapi32.class, W32APIOptions.UNICODE_OPTIONS);
+			Advapi32.class, W32APIOptions.DEFAULT_OPTIONS);
 
 	public static final int MAX_KEY_LENGTH = 255;
 	public static final int MAX_VALUE_NAME = 16383;

File: contrib/platform/src/com/sun/jna/platform/win32/Crypt32.java
Patch:
@@ -27,7 +27,7 @@
 public interface Crypt32 extends StdCallLibrary {
 	
 	Crypt32 INSTANCE = (Crypt32) Native.loadLibrary("Crypt32",
-			Crypt32.class, W32APIOptions.UNICODE_OPTIONS);
+			Crypt32.class, W32APIOptions.DEFAULT_OPTIONS);
 	
 	/**
 	 * The CryptProtectData function performs encryption on the data in a DATA_BLOB

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32.java
Patch:
@@ -27,7 +27,7 @@ public interface Kernel32 extends WinNT, Wincon {
 
     /** The instance. */
     Kernel32 INSTANCE = (Kernel32) Native.loadLibrary("kernel32",
-            Kernel32.class, W32APIOptions.UNICODE_OPTIONS);
+            Kernel32.class, W32APIOptions.DEFAULT_OPTIONS);
 
     /**
      * Reads data from the specified file or input/output (I/O) device. Reads

File: contrib/platform/src/com/sun/jna/platform/win32/Msi.java
Patch:
@@ -21,7 +21,7 @@
 public interface Msi extends StdCallLibrary {
 
     Msi INSTANCE = (Msi)
-        Native.loadLibrary("msi", Msi.class, W32APIOptions.UNICODE_OPTIONS);
+        Native.loadLibrary("msi", Msi.class, W32APIOptions.DEFAULT_OPTIONS);
 
     /**
      * The component being requested is disabled on the computer.

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32.java
Patch:
@@ -30,7 +30,7 @@
 public interface Netapi32 extends StdCallLibrary {
 	
 	Netapi32 INSTANCE = (Netapi32) Native.loadLibrary("Netapi32",
-			Netapi32.class, W32APIOptions.UNICODE_OPTIONS);
+			Netapi32.class, W32APIOptions.DEFAULT_OPTIONS);
 
 	/**
 	 * Retrieves join status information for the specified computer.

File: contrib/platform/src/com/sun/jna/platform/win32/NtDll.java
Patch:
@@ -26,7 +26,7 @@
 public interface NtDll extends StdCallLibrary {
 	
 	NtDll INSTANCE = (NtDll) Native.loadLibrary("NtDll",
-			NtDll.class, W32APIOptions.UNICODE_OPTIONS);
+			NtDll.class, W32APIOptions.DEFAULT_OPTIONS);
 
 	/**
 	 * The ZwQueryKey routine provides information about the class of a registry key, 

File: contrib/platform/src/com/sun/jna/platform/win32/Ole32.java
Patch:
@@ -34,7 +34,7 @@ public interface Ole32 extends StdCallLibrary {
 
     /** The instance. */
     Ole32 INSTANCE = (Ole32) Native.loadLibrary("Ole32", Ole32.class,
-                                                W32APIOptions.UNICODE_OPTIONS);
+                                                W32APIOptions.DEFAULT_OPTIONS);
 
     /**
      * Creates a GUID, a unique 128-bit integer used for CLSIDs and interface

File: contrib/platform/src/com/sun/jna/platform/win32/OleAuto.java
Patch:
@@ -100,7 +100,7 @@ public interface OleAuto extends StdCallLibrary {
 
 	/** The instance. */
 	OleAuto INSTANCE = (OleAuto) Native.loadLibrary("OleAut32", OleAuto.class,
-			W32APIOptions.UNICODE_OPTIONS);
+			W32APIOptions.DEFAULT_OPTIONS);
 
 	/**
 	 * This function allocates a new string and copies the passed string into

File: contrib/platform/src/com/sun/jna/platform/win32/Pdh.java
Patch:
@@ -33,7 +33,7 @@
  */
 public interface Pdh extends StdCallLibrary {
     Pdh INSTANCE = (Pdh) Native.loadLibrary("Pdh",
-            Pdh.class, W32APIOptions.UNICODE_OPTIONS);
+            Pdh.class, W32APIOptions.DEFAULT_OPTIONS);
 
 
     /** Maximum counter name length. */

File: contrib/platform/src/com/sun/jna/platform/win32/Rasapi32.java
Patch:
@@ -33,7 +33,7 @@
  * Rasapi32.dll Interface.
  */
 public interface Rasapi32 extends StdCallLibrary {
-	Rasapi32 INSTANCE = (Rasapi32) Native.loadLibrary("Rasapi32", Rasapi32.class, W32APIOptions.UNICODE_OPTIONS);
+	Rasapi32 INSTANCE = (Rasapi32) Native.loadLibrary("Rasapi32", Rasapi32.class, W32APIOptions.DEFAULT_OPTIONS);
 
 	/**
 	 * The RasDial function establishes a RAS connection between a RAS client and a RAS server.

File: contrib/platform/src/com/sun/jna/platform/win32/Secur32.java
Patch:
@@ -30,7 +30,7 @@
  * @author dblock[at]dblock.org
  */
 public interface Secur32 extends StdCallLibrary {
-    Secur32 INSTANCE = (Secur32) Native.loadLibrary("Secur32", Secur32.class, W32APIOptions.UNICODE_OPTIONS);
+    Secur32 INSTANCE = (Secur32) Native.loadLibrary("Secur32", Secur32.class, W32APIOptions.DEFAULT_OPTIONS);
 	
     /**
      * Specifies a format for a directory service object name.

File: contrib/platform/src/com/sun/jna/platform/win32/Shell32.java
Patch:
@@ -30,7 +30,7 @@
 public interface Shell32 extends ShellAPI, StdCallLibrary {
 	
     Shell32 INSTANCE = (Shell32) Native.loadLibrary("shell32", Shell32.class, 
-    		W32APIOptions.UNICODE_OPTIONS);
+    		W32APIOptions.DEFAULT_OPTIONS);
     
     /**
      * This function can be used to copy, move, rename, or delete a file system object.

File: contrib/platform/src/com/sun/jna/platform/win32/Winspool.java
Patch:
@@ -93,7 +93,7 @@ public interface Winspool extends StdCallLibrary {
     int PRINTER_ENUM_HIDE = 0x01000000;
 
     Winspool INSTANCE = (Winspool) Native.loadLibrary("Winspool.drv",
-            Winspool.class, W32APIOptions.UNICODE_OPTIONS);
+            Winspool.class, W32APIOptions.DEFAULT_OPTIONS);
 
     /**
      * The EnumPrinters function enumerates available printers, print servers,

File: contrib/platform/src/com/sun/jna/platform/FileUtils.java
Patch:
@@ -28,8 +28,9 @@ public boolean hasTrash() {
     }
 
     /** Move the given file to the system trash, if one is available.
-        Throws an exception on failure.
-    */
+     * @param files files to move
+     * @throws IOException on failure.
+     */
     public abstract void moveToTrash(File[] files) throws IOException;
 
     /** Canonical lazy loading of a singleton. */

File: contrib/platform/src/com/sun/jna/platform/WindowUtils.java
Patch:
@@ -159,11 +159,11 @@ public class WindowUtils {
      * Ideally we'd have more control over {@link PopupFactory} but this
      * is a fairly simple, lightweight workaround.  Note that, at least as of
      * JDK 1.6, the following do not have the desired effect:<br>
-     * <code><pre>
+     * <pre><code>
      * ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
      * JPopupMenu.setDefaultLightWeightPopupEnabled(false);
      * System.setProperty("JPopupMenu.defaultLWPopupEnabledKey", "false");
-     * </pre></code>
+     * </code></pre>
      */
     private static class HeavyweightForcer extends Window {
 		private static final long serialVersionUID = 1L;

File: contrib/platform/src/com/sun/jna/platform/mac/Carbon.java
Patch:
@@ -42,6 +42,7 @@ public interface Carbon extends Library {
 
     /**
      * Obtains the event target reference for the standard toolbox dispatcher
+     * @return event dispatcher reference
      */
     public Pointer GetEventDispatcherTarget();
 

File: contrib/platform/src/com/sun/jna/platform/mac/XAttr.java
Patch:
@@ -17,7 +17,7 @@
 import com.sun.jna.Pointer;
 
 /**
- * JNA wrapper for <sys/xattr.h>
+ * JNA wrapper for &lt;sys/xattr.h&gt;
  * 
  */
 interface XAttr extends Library {

File: contrib/platform/src/com/sun/jna/platform/win32/COM/IConnectionPoint.java
Patch:
@@ -26,7 +26,7 @@ public interface IConnectionPoint extends IUnknown {
 	 * 
 	 * 
 	 * @param iid
-	 * @return
+	 * @return interface pointer
 	 */
 	HRESULT GetConnectionInterface(IID iid);
 	
@@ -53,14 +53,14 @@ public interface IConnectionPoint extends IUnknown {
 	 * 
 	 * @param pUnkSink
 	 * @param pdwCookie
-	 * @return
+	 * @return status
 	 */
 	WinNT.HRESULT Advise(IUnknownCallback pUnkSink, DWORDByReference pdwCookie);
 	
 	/**
 	 * 
 	 * @param dwCookie
-	 * @return
+	 * @return status
 	 */
 	HRESULT Unadvise(DWORD dwCookie);
 }

File: contrib/platform/src/com/sun/jna/platform/win32/COM/IConnectionPointContainer.java
Patch:
@@ -29,7 +29,7 @@ public interface IConnectionPointContainer extends IUnknown {
 	  * }
 	  * @param riid
 	  * @param ppCP
-	  * @return
+	  * @return hresult
 	  */
 	 public HRESULT FindConnectionPoint(  REFIID riid,  PointerByReference ppCP );
 }

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/Factory.java
Patch:
@@ -73,7 +73,7 @@ public ComThread getComThread() {
 	 * CoInitialize must be called be fore this method. Either explicitly or
 	 * implicitly via other methods.
 	 * 
-	 * @return
+	 * @return running object table
 	 */
 	public IRunningObjectTable getRunningObjectTable() {
 		try {
@@ -117,7 +117,7 @@ public <T> T createProxy(Class<T> comInterface, IDispatch dispatch) {
 	 * @param comInterface
 	 * @param unknownId
 	 * @param dispatch
-	 * @return
+	 * @return proxy object
 	 */
 	<T> T createProxy(Class<T> comInterface, long unknownId, IDispatch dispatch) {
 		ProxyObject jop = new ProxyObject(comInterface, unknownId, dispatch, this);

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/IRunningObjectTable.java
Patch:
@@ -35,7 +35,7 @@ public interface IRunningObjectTable {
 	 * those for which queryInterface(iid) gives a valid result.
 	 * 
 	 * @param comInterface
-	 * @return
+	 * @return active objects
 	 */
 	<T> List<T> getActiveObjectsByInterface(Class<T> comInterface);
 }

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32.java
Patch:
@@ -52,7 +52,7 @@ public int NetGetJoinInformation(String lpServer,
 	/**
 	 * Frees the memory that the NetApiBufferAllocate function allocates.
 	 * 
-	 * @param buffer
+	 * @param buffer buffer
 	 * @return If the function succeeds, the return value is NERR_Success. If
 	 *         the function fails, the return value is a system error code.
 	 */

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32Util.java
Patch:
@@ -154,7 +154,7 @@ public static int getJoinStatus(String computerName) {
 	
     /**
      * Get information about a computer.
-     * @param computerName
+     * @param computerName computer name
      * @return Domain or workgroup name.
      */
     public static String getDomainName(String computerName) {

File: contrib/platform/src/com/sun/jna/platform/win32/OaIdl.java
Patch:
@@ -1278,6 +1278,7 @@ protected List getFieldOrder() {
         /**
          * @param tdescElem
          *            C type : TYPEDESC<br>
+         * @param cDims dimensions
          * @param rgbounds
          *            [size_is]<br>
          *            C type : SAFEARRAYBOUND[1]

File: contrib/platform/src/com/sun/jna/platform/win32/OleAuto.java
Patch:
@@ -272,7 +272,7 @@ public SAFEARRAY.ByReference SafeArrayCreate(VARTYPE vt, int cDims,
 	 * @param rgIndices
 	 *            [in] A vector of indexes for each dimension of the array. The
 	 *            right-most (least significant) dimension is rgIndices[0]. The
-	 *            left-most dimension is stored at rgIndices[psa->cDims - 1].
+	 *            left-most dimension is stored at rgIndices[psa-&gt;cDims - 1].
 	 * @param pv
 	 *            [out] The element of the array.
 	 * 
@@ -435,6 +435,7 @@ protected List getFieldOrder() {
 	 * 
 	 *            TYPE_E_CANTLOADLIBRARY The type library or DLL could not be
 	 *            loaded.
+         * @return status
 	 */
 	public HRESULT LoadRegTypeLib(GUID rguid, int wVerMajor, int wVerMinor,
 			LCID lcid, PointerByReference pptlib);
@@ -470,6 +471,7 @@ public HRESULT LoadRegTypeLib(GUID rguid, int wVerMajor, int wVerMinor,
 	 * 
 	 *            TYPE_E_CANTLOADLIBRARY The type library or DLL could not be
 	 *            loaded.
+         * @return status
 	 */
 	public HRESULT LoadTypeLib(WString szFile, PointerByReference pptlib);
 

File: contrib/platform/src/com/sun/jna/platform/win32/Pdh.java
Patch:
@@ -123,7 +123,7 @@ protected List<String> getFieldOrder() {
 
     /**
      * Creates a full counter path using the members specified in the
-     * {@link #PDH_COUNTER_PATH_ELEMENTS} structure.
+     * {@link Pdh.PDH_COUNTER_PATH_ELEMENTS} structure.
      * @param pCounterPathElements Structure that contains the members
      * used to make up the path
      * @param szFullPathBuffer Caller-allocated buffer that receives a null-terminated
@@ -249,7 +249,7 @@ protected List<String> getFieldOrder() {
      * query and updates the status code of each counter.
      * @param hQuery Handle to the query
      * @param pllTimeStamp Time stamp when the first counter value in the query
-     * was retrieved. The time is specified as {@link WinBase#FILETIME}.
+     * was retrieved. The time is specified as {@link WinBase.FILETIME}.
      * @return ERROR_SUCCESS if successful
      * @see <A HREF="https://msdn.microsoft.com/en-us/library/windows/desktop/aa372569(v=vs.85).aspx">PdhCollectQueryDataWithTime</A>
      */

File: contrib/platform/src/com/sun/jna/platform/win32/PdhMsg.java
Patch:
@@ -162,15 +162,15 @@ public interface PdhMsg {
     public static final int PDH_PLA_ERROR_TYPE_MISMATCH = 0xC0000BEF;
     /** The information specified does not resolve to a valid path name. */
     public static final int PDH_PLA_ERROR_FILEPATH = 0xC0000BF0;
-    /** The &quot;Performance Logs & Alerts&quot; service did not respond. */
+    /** The &quot;Performance Logs &amp; Alerts&quot; service did not respond. */
     public static final int PDH_PLA_SERVICE_ERROR = 0xC0000BF1;
     /** The information passed is not valid. */
     public static final int PDH_PLA_VALIDATION_ERROR = 0xC0000BF2;
     /** The information passed is not valid. */
     public static final int PDH_PLA_VALIDATION_WARNING = 0x80000BF3;
     /** The name supplied is too long. */
     public static final int PDH_PLA_ERROR_NAME_TOO_LONG = 0xC0000BF4;
-    /** SQL log format is incorrect. Correct format is &quot;SQL:<DSN-name>!<LogSet-Name>&quot;. */
+    /** SQL log format is incorrect. Correct format is &quot;SQL:&lt;DSN-name&gt;!&lt;LogSet-Name&gt;&quot;. */
     public static final int PDH_INVALID_SQL_LOG_FORMAT = 0xC0000BF5;
     /** Performance counter in PdhAddCounter call has already been added in the performance query. */
     public static final int PDH_COUNTER_ALREADY_IN_QUERY = 0xC0000BF6;

File: contrib/platform/src/com/sun/jna/platform/win32/Rasapi32.java
Patch:
@@ -230,6 +230,7 @@ public interface Rasapi32 extends StdCallLibrary {
 	 *            Pointer to a buffer that receives the error string. This parameter must not be NULL.
 	 * @param cBufSize
 	 *            Specifies the size, in characters, of the buffer pointed to by lpszErrorString.
+         * @return status
 	 */
 	public int RasGetErrorString(int uErrorValue, char[] lpszErrorString, int cBufSize);
 }

File: contrib/platform/src/com/sun/jna/platform/win32/Rasapi32Util.java
Patch:
@@ -240,6 +240,7 @@ public static RASDIALPARAMS getPhoneBookDialingParams(String entryName) throws R
 	/**
 	 * Dial a phone book entry by name (Synchronously)
 	 * @param entryName The phone book entry name
+         * @return result reference
 	 * @throws Ras32Exception errors
 	 */
 	public static HANDLE dialEntry(String entryName) throws Ras32Exception {
@@ -271,6 +272,7 @@ public static HANDLE dialEntry(String entryName) throws Ras32Exception {
 	/**
 	 * Dial a phone book entry by name (Asynchronously - callback type 2)
 	 * @param entryName The phone book entry name
+         * @param func2
 	 * @return the HRASCONN for this connection
 	 * @throws Ras32Exception errors
 	 */

File: contrib/platform/src/com/sun/jna/platform/win32/Shell32.java
Patch:
@@ -88,11 +88,11 @@ HRESULT SHGetFolderPath(HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlag
      *        resource once it is no longer needed by calling {@link Ole32#CoTaskMemFree}. The returned path does not include a trailing
      *        backslash. For example, "C:\Users" is returned rather than "C:\Users\".
      * @return Returns S_OK if successful, or an error value otherwise, including the following: 
-     *        <li>E_FAIL Among other things, this value can indicate that the rfid parameter references a KNOWNFOLDERID which 
+     *        <ul><li>E_FAIL Among other things, this value can indicate that the rfid parameter references a KNOWNFOLDERID which 
      *        does not have a path (such as a folder marked as KF_CATEGORY_VIRTUAL).</li> 
      *        <li>E_INVALIDARG Among other things, this value can indicate that the rfid parameter references a KNOWNFOLDERID 
      *        that is not present on the system. Not all KNOWNFOLDERID values are present on all systems. Use 
-     *        IKnownFolderManager::GetFolderIds to retrieve the set of KNOWNFOLDERID values for the current system.</li>
+     *        IKnownFolderManager::GetFolderIds to retrieve the set of KNOWNFOLDERID values for the current system.</li></ul>
      */
     HRESULT SHGetKnownFolderPath(GUID rfid, int dwFlags, HANDLE hToken, PointerByReference ppszPath);
 
@@ -160,7 +160,7 @@ HRESULT SHGetFolderPath(HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlag
      *   that indicates the cause of the failure. The return value is cast as an HINSTANCE for backward compatibility
      *   with 16-bit Windows applications. It is not a true HINSTANCE, however. It can be cast only to an int and
      *   compared to either 32 or the following error codes below.
-     * <p/>
+     * 
      * NOTE: {@link WinDef.INT_PTR} is used instead of HINSTANCE here, since
      *   the former fits the reutrn type's actual usage more closely.
      *

File: contrib/platform/src/com/sun/jna/platform/win32/ShlObj.java
Patch:
@@ -148,11 +148,13 @@ public enum KNOWN_FOLDER_FLAG
          * predefined for that folder are applied. If the folder does not exist and cannot be created, the function
          * returns a failure code and no path is returned. This value can be used only with the following functions and
          * methods: 
+         * <ul>
          * <li>SHGetKnownFolderPath</li> 
          * <li>SHGetKnownFolderIDList</li> 
          * <li>IKnownFolder::GetIDList</li>
          * <li>IKnownFolder::GetPath</li> 
          * <li>IKnownFolder::GetShellItem</li>
+         * </ul>
          */
         CREATE(0x00008000),
         /**

File: contrib/platform/src/com/sun/jna/platform/win32/Sspi.java
Patch:
@@ -334,8 +334,8 @@ public SecBufferDesc(int type, byte[] token) {
 	    
         /**
          * Create a new SecBufferDesc with one SecBuffer of a given type and size.
-         * @param type
-         * @param tokenSize
+         * @param type type
+         * @param tokenSize token size
          */
         public SecBufferDesc(int type, int tokenSize) {
             pBuffers[0] = new SecBuffer.ByReference(type, tokenSize);

File: contrib/platform/src/com/sun/jna/platform/win32/Variant.java
Patch:
@@ -720,6 +720,7 @@ public VariantArg() {
 
         /**
          * construct VariantArg cast onto pre-allocated memory
+         * @param pointer base address
          */
         public VariantArg(Pointer pointer) {
         	super(pointer);

File: contrib/platform/src/com/sun/jna/platform/win32/W32Errors.java
Patch:
@@ -161,7 +161,7 @@ public static final HRESULT HRESULT_FROM_WIN32(int x) {
 	/**
 	 * FACILITY_USERMODE_FILTER_MANAGER
 	 * 
-	 * Translation macro for converting: NTSTATUS --> HRESULT.
+	 * Translation macro for converting: NTSTATUS --&gt; HRESULT.
 	 *
 	 * @param x the x
 	 * @return the int

File: src/com/sun/jna/PointerType.java
Patch:
@@ -43,7 +43,9 @@ public Object toNative() {
         return getPointer();
     }
 
-    /** Returns the associated native {@link Pointer}. */
+    /** Returns the associated native {@link Pointer}.
+        @return Native pointer representation for this object.
+     */
     public Pointer getPointer() {
         return pointer;
     }

File: src/com/sun/jna/Union.java
Patch:
@@ -67,6 +67,7 @@ protected List getFieldOrder() {
     /** Indicates by type which field will be used to write to native memory.
      * If there are multiple fields of the same type, use {@link
      * #setType(String)} instead with the field name.
+     * @param type desired active type for the union
      * @throws IllegalArgumentException if the type does not correspond to
      * any declared union field.
      */
@@ -84,6 +85,7 @@ public void setType(Class type) {
 
     /**
      * Indicates which field will be used to write to native memory.
+     * @param fieldName desired field to use for the active union type
      * @throws IllegalArgumentException if the name does not correspond to
      * any declared union field.
      */

File: test/com/sun/jna/CallbacksTest.java
Patch:
@@ -46,10 +46,10 @@ public class CallbacksTest extends TestCase implements Paths {
 
     private static final int THREAD_TIMEOUT = 5000;
 
-    protected void waitFor(Thread t) {
+    protected void waitFor(Thread thread) {
         long start = System.currentTimeMillis();
-	while (t.isAlive()) {
-	    Thread.sleep(10);
+	while (thread.isAlive()) {
+	    try { Thread.sleep(10); } catch(InterruptedException e) { }
 	    if (System.currentTimeMillis() - start > THREAD_TIMEOUT) {
 		fail("Timed out waiting for native thread " + thread
                      + " to detach and terminate");

File: contrib/platform/test/com/sun/jna/platform/win32/Kernel32DiskManagementFunctionsTest.java
Patch:
@@ -64,11 +64,11 @@ private void testGetDiskFreeSpaceEx(String lpDirectoryName) {
 //        System.out.append('\t').append("TotalNumberOfBytes: ").println(lpTotalNumberOfBytes);
 //        System.out.append('\t').append("TotalNumberOfFreeBytes: ").println(lpTotalNumberOfFreeBytes);
 
-        assertTrue("No free size for " + lpDirectoryName, lpTotalNumberOfFreeBytes.getValue() > 0L);
+        assertTrue("No free size for " + lpDirectoryName, LARGE_INTEGER.compare(lpTotalNumberOfFreeBytes, 0L) > 0);
         assertTrue("Free size (" + lpTotalNumberOfFreeBytes + ")"
                  + " not below total size (" + lpTotalNumberOfBytes + ")"
                  + " for " + lpDirectoryName,
-                   lpTotalNumberOfFreeBytes.getValue() < lpTotalNumberOfBytes.getValue());
+                 LARGE_INTEGER.compare(lpTotalNumberOfFreeBytes, lpTotalNumberOfBytes) < 0);
     }
 
     @Test

File: contrib/platform/test/com/sun/jna/platform/win32/Kernel32DiskManagementFunctionsTest.java
Patch:
@@ -64,11 +64,11 @@ private void testGetDiskFreeSpaceEx(String lpDirectoryName) {
 //        System.out.append('\t').append("TotalNumberOfBytes: ").println(lpTotalNumberOfBytes);
 //        System.out.append('\t').append("TotalNumberOfFreeBytes: ").println(lpTotalNumberOfFreeBytes);
 
-        assertTrue("No free size for " + lpDirectoryName, lpTotalNumberOfFreeBytes.getValue() > 0L);
+        assertTrue("No free size for " + lpDirectoryName, LARGE_INTEGER.compare(lpTotalNumberOfFreeBytes, 0L) > 0);
         assertTrue("Free size (" + lpTotalNumberOfFreeBytes + ")"
                  + " not below total size (" + lpTotalNumberOfBytes + ")"
                  + " for " + lpDirectoryName,
-                   lpTotalNumberOfFreeBytes.getValue() < lpTotalNumberOfBytes.getValue());
+                 LARGE_INTEGER.compare(lpTotalNumberOfFreeBytes, lpTotalNumberOfBytes) < 0);
     }
 
     @Test

File: src/com/sun/jna/Structure.java
Patch:
@@ -1798,6 +1798,7 @@ private void init(Pointer[] els) {
             write();
         }
 
+        /** Obtain a pointer to the native FFI type descriptor for the given object. */
         static Pointer get(Object obj) {
             if (obj == null)
                 return FFITypes.ffi_type_pointer;
@@ -1847,7 +1848,7 @@ private static Pointer get(Object obj, Class cls) {
                     typeInfoMap.put(obj, type);
                     return type.getPointer();
                 }
-                throw new IllegalArgumentException("Unsupported Structure field type " + cls);
+                throw new IllegalArgumentException("Unsupported type " + cls);
             }
         }
     }

File: src/com/sun/jna/Structure.java
Patch:
@@ -1798,6 +1798,7 @@ private void init(Pointer[] els) {
             write();
         }
 
+        /** Obtain a pointer to the native FFI type descriptor for the given object. */
         static Pointer get(Object obj) {
             if (obj == null)
                 return FFITypes.ffi_type_pointer;
@@ -1847,7 +1848,7 @@ private static Pointer get(Object obj, Class cls) {
                     typeInfoMap.put(obj, type);
                     return type.getPointer();
                 }
-                throw new IllegalArgumentException("Unsupported Structure field type " + cls);
+                throw new IllegalArgumentException("Unsupported type " + cls);
             }
         }
     }

File: src/com/sun/jna/Structure.java
Patch:
@@ -1791,6 +1791,7 @@ private void init(Pointer[] els) {
             write();
         }
 
+        /** Obtain a pointer to the native FFI type descriptor for the given object. */
         static Pointer get(Object obj) {
             if (obj == null)
                 return FFITypes.ffi_type_pointer;
@@ -1840,7 +1841,7 @@ private static Pointer get(Object obj, Class cls) {
                     typeInfoMap.put(obj, type);
                     return type.getPointer();
                 }
-                throw new IllegalArgumentException("Unsupported Structure field type " + cls);
+                throw new IllegalArgumentException("Unsupported type " + cls);
             }
         }
     }

File: contrib/platform/src/com/sun/jna/platform/win32/Advapi32Util.java
Patch:
@@ -1896,7 +1896,7 @@ public EventLogRecord(Pointer pevlr) {
 				int count = _record.NumStrings.intValue();
 				long offset = _record.StringOffset.intValue();
 				while (count > 0) {
-					String s = pevlr.getWideString(0);
+					String s = pevlr.getWideString(offset);
 					strings.add(s);
 					offset += s.length() * Native.WCHAR_SIZE;
 					offset += Native.WCHAR_SIZE;

File: contrib/platform/src/com/sun/jna/platform/win32/Advapi32Util.java
Patch:
@@ -1896,7 +1896,7 @@ public EventLogRecord(Pointer pevlr) {
 				int count = _record.NumStrings.intValue();
 				long offset = _record.StringOffset.intValue();
 				while (count > 0) {
-					String s = pevlr.getWideString(0);
+					String s = pevlr.getWideString(offset);
 					strings.add(s);
 					offset += s.length() * Native.WCHAR_SIZE;
 					offset += Native.WCHAR_SIZE;

File: contrib/platform/src/com/sun/jna/platform/win32/COM/IConnectionPointContainer.java
Patch:
@@ -21,7 +21,7 @@ public interface IConnectionPointContainer extends IUnknown {
 	 public final static IID IID_IConnectionPointContainer = new IID("B196B284-BAB4-101A-B69C-00AA00341D07");
 	 
 	 /**
-	  * @code{
+	  * {@code
 	  *   HRESULT FindConnectionPoint(
 	  *     [in]   REFIID riid,
 	  *     [out]  IConnectionPoint **ppCP

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/Factory.java
Patch:
@@ -115,7 +115,7 @@ public <T> T createProxy(Class<T> comInterface, IDispatch dispatch) {
 	/** only for use when creating ProxyObjects from Callbacks
 	 * 
 	 * @param comInterface
-	 * @param unk
+	 * @param unknownId
 	 * @param dispatch
 	 * @return
 	 */

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/IConnectionPoint.java
Patch:
@@ -20,7 +20,7 @@ public interface IConnectionPoint {
 	 * Set up the comEventCallbackListener to receive callback events from the target COM object
 	 * 
 	 * @param comEventCallbackInterface - the COM interface that the listener will receive events from
-	 * @param comEventCallback - and object that will receive the callback events
+	 * @param comEventCallbackListener - and object that will receive the callback events
 	 * @return - a cookie that can be used to detach (unadvise) the event callback listener
 	 * 
 	 * throws COMException if an error occurs trying to set up the listener on the target COM object,

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/IRunningObjectTable.java
Patch:
@@ -34,7 +34,7 @@ public interface IRunningObjectTable {
 	 * Enumerates the running objects (via enumRunning), and returns a list of
 	 * those for which queryInterface(iid) gives a valid result.
 	 * 
-	 * @param iid
+	 * @param comInterface
 	 * @return
 	 */
 	<T> List<T> getActiveObjectsByInterface(Class<T> comInterface);

File: contrib/platform/src/com/sun/jna/platform/win32/COM/util/ProxyObject.java
Patch:
@@ -82,7 +82,7 @@ public ProxyObject(Class<?> theInterface, IDispatch rawDispatch, Factory factory
 	 * however, the unknown pointer value is passed in;
 	 * 
 	 * @param theInterface
-	 * @param rawUnk
+	 * @param unknownId
 	 * @param rawDispatch
 	 * @param factory
 	 */

File: contrib/platform/src/com/sun/jna/platform/win32/GDI32.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* copyright (c) 2007 Timothy Wall, All Rights Reserved
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -387,7 +387,7 @@ HBITMAP CreateDIBSection(HDC hDC, BITMAPINFO pbmi, int iUsage,
 	 *            <tr>
 	 *            <td>
 	 *            {@link HBITMAP} returned from a call to
-	 *            {@link #CreateDIBSection(HDC, BITMAPINFO, int, PointerByReference, Pointer, int)}
+	 *            {@link #CreateDIBSection}
 	 *            </td>
 	 *            <td>{@link DIBSECTION}, if cbBuffer is set to sizeof(
 	 *            {@link DIBSECTION}), or {@link BITMAP}, if cbBuffer is set to

File: contrib/platform/src/com/sun/jna/platform/win32/Ole32.java
Patch:
@@ -274,7 +274,7 @@ HRESULT CoCreateInstance(GUID rclsid, Pointer pUnkOuter, int dwClsContext,
      *   HRESULT CoGetMalloc(
      *     [In]   DWORD dwMemContext,
      *     [Out]  LPMALLOC *ppMalloc
-     *   );
+     *   );}
      * 
      * @see <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms693395%28v=vs.85%29.aspx">MSDN</a>
      * 

File: contrib/platform/test/com/sun/jna/platform/win32/COM/ITypeInfoTest.java
Patch:
@@ -28,6 +28,7 @@
 import com.sun.jna.platform.win32.WinNT.HRESULT;
 import com.sun.jna.ptr.IntByReference;
 import com.sun.jna.ptr.PointerByReference;
+import org.junit.Ignore;
 
 /**
  * @author dblock[at]dblock[dot]org
@@ -160,6 +161,7 @@ public void testGetDocumentation() {
         throw new RuntimeException("Didn't find documentation in any of the type infos");
     }
 
+    @Ignore("Needs a DLL that contains code")
     public void testGetDllEntry() {
         ITypeInfo[] typeInfos = getTypeInfos();
         MEMBERID memid = new MEMBERID(0);
@@ -183,6 +185,7 @@ public void testGetDllEntry() {
     public void testGetRefTypeInfo() {
     }
 
+    @Ignore("Needs a DLL that contains code")
     public void testAddressOfMember() {
         ITypeInfo[] typeInfos = getTypeInfos();
         MEMBERID memid = new MEMBERID();

File: contrib/platform/test/com/sun/jna/platform/WindowUtilsTest.java
Patch:
@@ -610,9 +610,9 @@ public void testGetProcessFilePath() {
 		final JFrame w = new JFrame();
 		try {
 			w.setVisible(true);
-			final String searchSubStr = "\\bin\\javaw.exe";
-			final HWND hwnd = new HWND();
-			hwnd.setPointer(Native.getComponentPointer(w));
+			
+			final String searchSubStr = "\\bin\\java";
+			final HWND hwnd = new HWND(Native.getComponentPointer(w));
 
 			assertTrue("Path didn't contain '" + searchSubStr + "': "
 					+ WindowUtils.getProcessFilePath(hwnd),

File: contrib/platform/test/com/sun/jna/platform/win32/PsapiTest.java
Patch:
@@ -35,9 +35,8 @@ public void testGetModuleFileNameEx() {
 		final JFrame w = new JFrame();
 		try {
 			w.setVisible(true);
-			final String searchSubStr = "\\bin\\javaw.exe";
-			final HWND hwnd = new HWND();
-			hwnd.setPointer(Native.getComponentPointer(w));
+			final String searchSubStr = "\\bin\\java";
+			final HWND hwnd = new HWND(Native.getComponentPointer(w));
 
 			final IntByReference pid = new IntByReference();
 			User32.INSTANCE.GetWindowThreadProcessId(hwnd, pid);

File: src/com/sun/jna/NativeLibrary.java
Patch:
@@ -257,7 +257,7 @@ else if (Platform.isWindows() && !isAbsolutePath) {
             if (handle == 0) {
                 try {
                     File embedded = Native.extractFromResourcePath(libraryName, (ClassLoader)options.get(Library.OPTION_CLASSLOADER));
-                    handle = Native.open(embedded.getAbsolutePath());
+                    handle = Native.open(embedded.getAbsolutePath(), openFlags);
                     libraryPath = embedded.getAbsolutePath();
                     // Don't leave temporary files around
                     if (Native.isUnpacked(embedded)) {

File: contrib/platform/src/com/sun/jna/platform/win32/WTypes.java
Patch:
@@ -135,7 +135,7 @@ public LPSTR(Pointer pointer) {
         }
 
         public LPSTR(String value) {
-            this();
+            this(new Memory((value.length() + 1L) * Native.WCHAR_SIZE));
             this.setValue(value);
         }
 
@@ -172,7 +172,7 @@ public LPWSTR(Pointer pointer) {
         }
 
         public LPWSTR(String value) {
-            this();
+            this(new Memory((value.length() + 1L) * Native.WCHAR_SIZE));
             this.setValue(value);
         }
 

File: src/com/sun/jna/Platform.java
Patch:
@@ -33,6 +33,8 @@ public final class Platform {
      * running headless.
      */
     public static final boolean HAS_AWT;
+    /** Whether this platform supports the JAWT library. */
+    public static final boolean HAS_JAWT;
     /** Canonical name of this platform's math library. */
     public static final String MATH_LIBRARY_NAME;
     /** Canonical name of this platform's C runtime library. */
@@ -104,6 +106,7 @@ else if (osName.equalsIgnoreCase("netbsd")) {
         // has the unintended side effect of actually loading AWT native libs,
         // which can be problematic
         HAS_AWT = osType != WINDOWSCE && osType != ANDROID && osType != AIX;
+        HAS_JAWT = HAS_AWT && osType != MAC;
         HAS_BUFFERS = hasBuffers;
         RO_FIELDS = osType != WINDOWSCE;
         C_LIBRARY_NAME = osType == WINDOWS ? "msvcrt" : osType == WINDOWSCE ? "coredll" : "c";

File: test/com/sun/jna/LibraryLoadTest.java
Patch:
@@ -40,7 +40,7 @@ public void testLoadJNALibrary() {
     }
     
     public void testLoadJAWT() {
-        if (!Platform.HAS_AWT) return;
+        if (!Platform.HAS_AWT || !Platform.HAS_JAWT) return;
 
         if (GraphicsEnvironment.isHeadless()) return;
 

File: contrib/platform/src/com/sun/jna/platform/unix/X11.java
Patch:
@@ -220,7 +220,7 @@ class WindowByReference extends ByReference {
         public WindowByReference() { super(XID.SIZE); }
         public Window getValue() {
             NativeLong value = getPointer().getNativeLong(0);
-            return value.longValue() == 0 ? Window.None : new Window(value.longValue());
+            return value.longValue() == X11.None ? Window.None : new Window(value.longValue());
         }
     }
     class Pixmap extends Drawable {

File: contrib/platform/src/com/sun/jna/platform/unix/X11.java
Patch:
@@ -284,10 +284,9 @@ protected List getFieldOrder() {
                 return Arrays.asList(new String[] { "red", "redMask", "green", "greenMask", "blue", "blueMask", "alpha", "alphaMask" }); 
             }
         }
-        class PictFormat extends IntegerType {
+        class PictFormat extends XID {
             private static final long serialVersionUID = 1L;
-            public static final int SIZE = 4;
-            public PictFormat(long value) { super(SIZE, value, true); }
+            public PictFormat(long value) { super(value); }
             public PictFormat() { this(0); }
         }
         class XRenderPictFormat extends Structure {

File: test/com/sun/jna/WebStartTest.java
Patch:
@@ -68,7 +68,9 @@ public class WebStartTest extends TestCase implements Paths {
         // Explicitly supply javawebstart.version, which is missing in NetX
         // Boo, java-vm-args doesn't work in NetX
         // and neither does javaws -J<arg>
-        + "    <j2se version='1.4+' java-vm-args='-Djavawebstart.version=0.0'/>\n"
+        // java-vm-args also causes javaws to ask for the JNLP to be signed,
+        // so don't bother
+        //+ "    <j2se version='1.4+' java-vm-args='-Djavawebstart.version=0.0'/>\n"
         + "    <jar href='jna-test.jar'/>\n"
         + "    <jar href='jna.jar'/>\n"
         + "    <jar href='junit.jar'/>{CLOVER}\n"

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32.java
Patch:
@@ -1366,7 +1366,7 @@ boolean CreateProcessW(String lpApplicationName, char[] lpCommandLine,
      * 
      * @param buffer
      *            a buffer which receives an array of
-     *            {@link SYSTEM_LOGICAL_PROCESSOR_INFORMATION} structures.
+     *            {@link WinNT.SYSTEM_LOGICAL_PROCESSOR_INFORMATION} structures.
      * @param returnLength
      *            on input, specifies the length of the buffer in bytes. On
      *            output, receives the number of bytes actually returned, or if

File: contrib/platform/src/com/sun/jna/platform/win32/OpenGL32.java
Patch:
@@ -37,7 +37,7 @@ public interface OpenGL32 extends StdCallLibrary {
      * The wglCreateContext function creates a new OpenGL rendering context, which is suitable for drawing on the device
      * referenced by hdc. The rendering context has the same pixel format as the device context.
      *
-     * @param hdc
+     * @param windowDC
      *            Handle to a device context for which the function creates a suitable OpenGL rendering context.
      * @return handle to an OpenGL rendering context
      */
@@ -55,7 +55,7 @@ public interface OpenGL32 extends StdCallLibrary {
      * The wglMakeCurrent function makes a specified OpenGL rendering context the calling thread's current rendering
      * context. All subsequent OpenGL calls made by the thread are drawn on the device identified by hdc.
      *
-     * @param hdc
+     * @param windowDC
      *            Handle to a device context. Subsequent OpenGL calls made by the calling thread are drawn on the
      *            device identified by hdc.
      * @param hglrc

File: contrib/platform/src/com/sun/jna/platform/win32/OpenGL32Util.java
Patch:
@@ -35,9 +35,8 @@ public static Function wglGetProcAddress(String procName) {
     }
 
     /**
-     * Return a RAS connection by name
-     * @param connName the connection name
-     * @return the RAS connection structure
+     * Count GPUs
+     * @return the number of available GPUs
      */
     public static int countGpusNV() {
         // create a dummy window

File: contrib/platform/src/com/sun/jna/platform/win32/User32.java
Patch:
@@ -1798,7 +1798,7 @@ HDEVNOTIFY RegisterDeviceNotification(HANDLE hRecipient,
      * positions of the specified window. 
      * 
      * @param hwnd A handle to the window. 
-     * @param dest A pointer to the WINDOWPLACEMENT structure that receives the
+     * @param lpwndpl A pointer to the WINDOWPLACEMENT structure that receives the
      *        show state and position information. 
      * @return The number of characters copied to the specified buffer indicates
      *        success. Zero indicates failure. To get extended error
@@ -1811,7 +1811,7 @@ HDEVNOTIFY RegisterDeviceNotification(HANDLE hRecipient,
      * of the specified window. 
      * 
      * @param hwnd A handle to the window. 
-     * @param dest A pointer to a WINDOWPLACEMENT structure that specifies the
+     * @param lpwndpl A pointer to a WINDOWPLACEMENT structure that specifies the
      *        new show state and window positions.
      * @return The number of characters copied to the specified buffer indicates
      *        success. Zero indicates failure. To get extended error 
@@ -1917,7 +1917,7 @@ HDEVNOTIFY RegisterDeviceNotification(HANDLE hRecipient,
      * asynchronously; thus, an application cannot assume that the console notification messages
      * have been handled when a call to ExitWindowsEx returns.
      * 
-     * To shut down or restart the system, the calling process must use the {@link com.sun.jna.platform.Advapi32.AdjustTokenPrivileges}
+     * To shut down or restart the system, the calling process must use the {@link com.sun.jna.platform.win32.Advapi32#AdjustTokenPrivileges}
      * function to enable the SE_SHUTDOWN_NAME privilege. For more information, see Running with Special Privileges.
      * 
      * @param uFlags The shutdown type. This parameter must include one of EWX_HYBRID_SHUTDOWN,

File: test/com/sun/jna/NativeTest.java
Patch:
@@ -410,7 +410,7 @@ public static void main(String[] args) {
             for (int i=0;i < args.length;i++) {
                 System.out.println("Running tests on class " + args[i]);
                 try {
-                    junit.textui.TestRunner.run(Class.forName(args[i]));
+                    junit.textui.TestRunner.run((Class<? extends TestCase>) Class.forName(args[i]));
                 }
                 catch(Throwable e) {
                     e.printStackTrace();

File: contrib/platform/src/com/sun/jna/platform/win32/Ole32.java
Patch:
@@ -230,7 +230,7 @@ HRESULT CoCreateInstance(GUID rclsid, Pointer pUnkOuter, int dwClsContext,
 	 * @param cb The size of the memory block to be allocated, in bytes.
 	 * @return If the function succeeds, it returns the allocated memory block. Otherwise, it returns NULL.
 	 */
-    LPVOID CoTaskMemAlloc(SIZE_T cb);
+    Pointer CoTaskMemAlloc(long cb);
 
     /**
 	 * Changes the size of a previously allocated block of task memory. This function changes the size of a previously
@@ -256,7 +256,7 @@ HRESULT CoCreateInstance(GUID rclsid, Pointer pUnkOuter, int dwClsContext,
 	 * @param cb The size of the memory block to be reallocated, in bytes. This parameter can be 0.
 	 * @return If the function succeeds, it returns the reallocated memory block. Otherwise, it returns NULL.
 	 */
-    LPVOID CoTaskMemRealloc(LPVOID pv, SIZE_T cb);
+    Pointer CoTaskMemRealloc(Pointer pv, long cb);
 
     /**
 	 * Frees a block of task memory previously allocated through a call to the {@link #CoTaskMemAlloc} or
@@ -265,6 +265,6 @@ HRESULT CoCreateInstance(GUID rclsid, Pointer pUnkOuter, int dwClsContext,
 	 * pointed to by pv is invalid and can no longer be used.
 	 * @param pv A pointer to the memory block to be freed. If this parameter is NULL, the function has no effect.
 	 */
-    void CoTaskMemFree(LPVOID pv);
+    void CoTaskMemFree(Pointer pv);
 
 }

File: contrib/platform/src/com/sun/jna/platform/win32/Shell32Util.java
Patch:
@@ -84,7 +84,7 @@ public static String getKnownFolderPath(GUID guid) throws Win32Exception
         }
 
         String result = outPath.getValue().getWideString(0);
-        Ole32.INSTANCE.CoTaskMemFree(new LPVOID(outPath.getPointer().getLong(0)));
+        Ole32.INSTANCE.CoTaskMemFree(outPath.getValue());
 
         return result;
     }

File: contrib/platform/test/com/sun/jna/platform/win32/Shell32Test.java
Patch:
@@ -139,7 +139,7 @@ public void testSHGetKnownFolderPath()
         GUID guid = KnownFolders.FOLDERID_Fonts;
         HRESULT hr = Shell32.INSTANCE.SHGetKnownFolderPath(guid, flags, token, outPath);
 
-        Ole32.INSTANCE.CoTaskMemFree(new LPVOID(outPath.getPointer().getLong(0)));
+        Ole32.INSTANCE.CoTaskMemFree(outPath.getValue());
 
         assertTrue(W32Errors.SUCCEEDED(hr.intValue()));
     }

File: src/com/sun/jna/DefaultTypeMapper.java
Patch:
@@ -117,7 +117,7 @@ public void addFromNativeConverter(Class cls, FromNativeConverter converter) {
     /** Add a {@link TypeConverter} to provide bidirectional mapping between
      * a native and Java type.  
      */
-    protected void addTypeConverter(Class cls, TypeConverter converter) {
+    public void addTypeConverter(Class cls, TypeConverter converter) {
         addFromNativeConverter(cls, converter);
         addToNativeConverter(cls, converter);
     }

File: src/com/sun/jna/Structure.java
Patch:
@@ -1030,7 +1030,7 @@ private void validateField(String name, Class type) {
                 getNativeSize(type);
             }
             catch(IllegalArgumentException e) {
-                String msg = "Invalid Structure field in " + getClass() + ", field name '" + name + "' (" + type + ")";
+                String msg = "Invalid Structure field in " + getClass() + ", field name '" + name + "' (" + type + "): " + e.getMessage();
                 throw new IllegalArgumentException(msg, e);
             }
         }
@@ -1150,7 +1150,7 @@ else if (writeConverter != null || readConverter != null) {
                 if (!force && typeMapper == null) {
                     return null;
                 }
-                String msg = "Invalid Structure field in " + getClass() + ", field name '" + structField.name + "' (" + structField.type + ")";
+                String msg = "Invalid Structure field in " + getClass() + ", field name '" + structField.name + "' (" + structField.type + "): " + e.getMessage();
                 throw new IllegalArgumentException(msg, e);
             }
 

File: src/com/sun/jna/DefaultTypeMapper.java
Patch:
@@ -117,7 +117,7 @@ public void addFromNativeConverter(Class cls, FromNativeConverter converter) {
     /** Add a {@link TypeConverter} to provide bidirectional mapping between
      * a native and Java type.  
      */
-    protected void addTypeConverter(Class cls, TypeConverter converter) {
+    public void addTypeConverter(Class cls, TypeConverter converter) {
         addFromNativeConverter(cls, converter);
         addToNativeConverter(cls, converter);
     }

File: src/com/sun/jna/NativeLibrary.java
Patch:
@@ -500,7 +500,7 @@ Function getFunction(String name, Method method) {
     }
 
     /**
-     * Create a new  @{link Function} that is linked with a native
+     * Create a new  {@link Function} that is linked with a native
      * function that follows a given calling flags.
      *
      * @param	functionName
@@ -514,7 +514,7 @@ public Function getFunction(String functionName, int callFlags) {
     }
 
     /**
-     * Create a new  @{link Function} that is linked with a native
+     * Create a new  {@link Function} that is linked with a native
      * function that follows a given calling flags.
      *
      * @param	functionName

File: contrib/platform/src/com/sun/jna/platform/win32/WTypes.java
Patch:
@@ -209,7 +209,7 @@ public LPOLESTR(Pointer pointer) {
         }
 
         public LPOLESTR(String value) {
-            this();
+            super(new Memory((value.length() + 1L) * Native.WCHAR_SIZE));
             this.setValue(value);
         }
 

File: contrib/platform/src/com/sun/jna/platform/win32/WTypes.java
Patch:
@@ -209,7 +209,7 @@ public LPOLESTR(Pointer pointer) {
         }
 
         public LPOLESTR(String value) {
-            this();
+            super(new Memory((value.length() + 1L) * Native.WCHAR_SIZE));
             this.setValue(value);
         }
 

File: contrib/platform/test/com/sun/jna/platform/win32/Ole32Test.java
Patch:
@@ -83,10 +83,9 @@ public void testCoCreateInstance() {
 		HRESULT hrCI = Ole32.INSTANCE.CoInitializeEx(null, 0);
 
 		GUID guid = Ole32Util
-				.getGUIDFromString("{13709620-C279-11CE-A49E-444553540000}"); // Shell
-																				// object
+				.getGUIDFromString("{00021401-0000-0000-C000-000000000046}"); // Shell object
 		GUID riid = Ole32Util
-				.getGUIDFromString("{D8F015C0-C278-11CE-A49E-444553540000}"); // IShellDispatch
+				.getGUIDFromString("{000214EE-0000-0000-C000-000000000046}"); // IShellLinkA
 
 		PointerByReference pDispatch = new PointerByReference();
 

File: contrib/platform/test/com/sun/jna/platform/win32/Ole32Test.java
Patch:
@@ -83,10 +83,9 @@ public void testCoCreateInstance() {
 		HRESULT hrCI = Ole32.INSTANCE.CoInitializeEx(null, 0);
 
 		GUID guid = Ole32Util
-				.getGUIDFromString("{13709620-C279-11CE-A49E-444553540000}"); // Shell
-																				// object
+				.getGUIDFromString("{00021401-0000-0000-C000-000000000046}"); // Shell object
 		GUID riid = Ole32Util
-				.getGUIDFromString("{D8F015C0-C278-11CE-A49E-444553540000}"); // IShellDispatch
+				.getGUIDFromString("{000214EE-0000-0000-C000-000000000046}"); // IShellLinkA
 
 		PointerByReference pDispatch = new PointerByReference();
 

File: contrib/platform/src/com/sun/jna/platform/win32/Advapi32Util.java
Patch:
@@ -1600,7 +1600,7 @@ public static TreeMap<String, Object> registryGetValues(HKEY hKey) {
 				ArrayList<String> result = new ArrayList<String>();
 				int offset = 0;
 				while (offset < stringData.size()) {
-					String s = stringData.getWideString(0);
+					String s = stringData.getWideString(offset);
 					offset += s.length() * Native.WCHAR_SIZE;
 					offset += Native.WCHAR_SIZE;
 					if (s.length() == 0 && offset == stringData.size()) {

File: contrib/alphamaskdemo/com/sun/jna/contrib/demo/AlphaMaskDemo.java
Patch:
@@ -72,7 +72,7 @@
 import com.sun.jna.platform.win32.WinGDI.BITMAPINFO;
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.platform.win32.WinUser.BLENDFUNCTION;
-import com.sun.jna.platform.win32.WinUser.POINT;
+import com.sun.jna.platform.win32.WinDef.POINT;
 import com.sun.jna.platform.win32.WinUser.SIZE;
 import com.sun.jna.ptr.PointerByReference;
 

File: contrib/platform/src/com/sun/jna/platform/WindowUtils.java
Patch:
@@ -80,7 +80,7 @@
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.platform.win32.WinUser;
 import com.sun.jna.platform.win32.WinUser.BLENDFUNCTION;
-import com.sun.jna.platform.win32.WinUser.POINT;
+import com.sun.jna.platform.win32.WinDef.POINT;
 import com.sun.jna.platform.win32.WinUser.SIZE;
 import com.sun.jna.ptr.ByteByReference;
 import com.sun.jna.ptr.IntByReference;

File: contrib/platform/src/com/sun/jna/platform/win32/GDI32.java
Patch:
@@ -123,7 +123,7 @@ HRGN CreateRoundRectRgn(int nLeftRect, int nTopRect, int nRightRect,
      *  If the function fails, the return value is zero. 
      *  To get extended error information, call GetLastError.
      */
-    HRGN CreatePolyPolygonRgn(WinUser.POINT[] lppt, int[] lpPolyCounts,
+    HRGN CreatePolyPolygonRgn(WinDef.POINT[] lppt, int[] lpPolyCounts,
                               int nCount, int fnPolyFillMode);
 
     /**

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/TlbImp.java
Patch:
@@ -18,10 +18,8 @@
 import java.io.FileOutputStream;
 import java.io.IOException;
 
-import com.sun.jna.Native;
 import com.sun.jna.platform.win32.OaIdl.TYPEKIND;
 import com.sun.jna.platform.win32.COM.TypeLibUtil;
-import com.sun.jna.platform.win32.COM.TypeLibUtil.TypeLibDoc;
 import com.sun.jna.platform.win32.COM.tlb.imp.TlbBase;
 import com.sun.jna.platform.win32.COM.tlb.imp.TlbCmdlineArgs;
 import com.sun.jna.platform.win32.COM.tlb.imp.TlbCoClass;
@@ -88,7 +86,7 @@ public void startCOM2Java() {
         try {
             // create output Dir
             this.createDir();
-            
+
             int typeInfoCount = typeLibUtil.getTypeInfoCount();
             for (int i = 0; i < typeInfoCount; ++i) {
                 TYPEKIND typekind = typeLibUtil.getTypeInfoType(i);

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbFunction.java
Patch:
@@ -65,7 +65,7 @@ public TlbFunction(int count, int index, TypeLibUtil typeLibUtil, FUNCDESC funcD
         for (int i = 0; i < paramCount; i++) {
             ELEMDESC elemdesc = funcDesc.lprgelemdescParam.elemDescArg[i];
             String methodName = names[i + 1].toLowerCase();
-            methodparams += this.getType(elemdesc.tdesc) + " " + this.validateMethodName(methodName);
+            methodparams += this.getType(elemdesc.tdesc) + " " + this.replaceJavaKeyword(methodName);
             methodvariables += methodName;
 
             // if there is more than 1 param

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbFunctionStub.java
Patch:
@@ -69,7 +69,7 @@ public TlbFunctionStub(int index, TypeLibUtil typeLibUtil,
         for (int i = 0; i < paramCount; i++) {
             ELEMDESC elemdesc = funcDesc.lprgelemdescParam.elemDescArg[i];
             String methodName = names[i + 1].toLowerCase();
-            methodparams += this.getType(elemdesc.tdesc) + " " + this.validateMethodName(methodName);
+            methodparams += this.getType(elemdesc.tdesc) + " " + this.replaceJavaKeyword(methodName);
             methodvariables += methodName;
 
             // if there is more than 1 param

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbPropertyPut.java
Patch:
@@ -61,8 +61,8 @@ public TlbPropertyPut(int count, int index, TypeLibUtil typeLibUtil,
         for (int i = 0; i < paramCount; i++) {
             ELEMDESC elemdesc = funcDesc.lprgelemdescParam.elemDescArg[i];
             varType = this.getType(elemdesc);
-            methodparams += varType + " " + names[i].toLowerCase();
-            methodvariables += names[i].toLowerCase();
+            methodparams += varType + " " + this.replaceJavaKeyword(names[i].toLowerCase());
+            methodvariables += this.replaceJavaKeyword(names[i].toLowerCase());
 
             // if there is more than 1 param
             if (i < (paramCount - 1)) {

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbPropertyPutStub.java
Patch:
@@ -62,7 +62,7 @@ public TlbPropertyPutStub(int index, TypeLibUtil typeLibUtil,
         for (int i = 0; i < paramCount; i++) {
             ELEMDESC elemdesc = funcDesc.lprgelemdescParam.elemDescArg[i];
             varType =  this.getType(elemdesc);
-            methodparams += varType + " " + names[i].toLowerCase();
+            methodparams += varType + " " + this.replaceJavaKeyword(names[i].toLowerCase());
 
             // if there is more than 1 param
             if (i < (paramCount - 1)) {

File: contrib/platform/src/com/sun/jna/platform/win32/OaIdl.java
Patch:
@@ -1303,7 +1303,9 @@ public static class ByReference extends PARAMDESC implements
                 Structure.ByReference {
         };
 
-        public PARAMDESCEX.ByReference pparamdescex;
+        // replaced PARAMDESCEX.ByReference with Pointer
+        // because of JNA 4 has a problem with ByReference
+        public Pointer pparamdescex;
         public USHORT wParamFlags;
 
         public PARAMDESC() {

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbFunction.java
Patch:
@@ -52,8 +52,8 @@ public TlbFunction(int count, int index, TypeLibUtil typeLibUtil, FUNCDESC funcD
 
         String methodparams = "";
         String methodvariables = "";
-        int vtableId = funcDesc.oVft;
-        int paramCount = funcDesc.cParams;
+        short vtableId = funcDesc.oVft.shortValue();
+        short paramCount = funcDesc.cParams.shortValue();
         ELEMDESC elemDesdRetType = funcDesc.elemdescFunc;
         String returnType = this.getType(elemDesdRetType.tdesc);
         String[] names = typeInfoUtil.getNames(funcDesc.memid, paramCount + 1);

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbFunctionStub.java
Patch:
@@ -56,8 +56,8 @@ public TlbFunctionStub(int index, TypeLibUtil typeLibUtil,
 
         String methodparams = "";
         String methodvariables = "";
-        int vtableId = funcDesc.oVft;
-        int paramCount = funcDesc.cParams;
+        short vtableId = funcDesc.oVft.shortValue();
+        short paramCount = funcDesc.cParams.shortValue();
         ELEMDESC elemDesdRetType = funcDesc.elemdescFunc;
         String returnType = this.getType(elemDesdRetType.tdesc);
         String[] names = typeInfoUtil.getNames(funcDesc.memid, paramCount + 1);

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbPropertyGet.java
Patch:
@@ -47,7 +47,7 @@ public TlbPropertyGet(int count, int index, TypeLibUtil typeLibUtil,
         super(index, typeLibUtil, funcDesc, typeInfoUtil);
 
         this.methodName = "get" + this.getMethodName();
-        int vtableId = funcDesc.oVft;
+        short vtableId = funcDesc.oVft.shortValue();
         String returnType = this.getType(funcDesc);
         
         this.replaceVariable("helpstring", docStr);

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbPropertyGetStub.java
Patch:
@@ -53,7 +53,7 @@ public TlbPropertyGetStub(int index, TypeLibUtil typeLibUtil,
         TypeInfoDoc typeInfoDoc = typeInfoUtil.getDocumentation(funcDesc.memid);
         String docStr = typeInfoDoc.getDocString();
         String methodname = "get" + typeInfoDoc.getName();
-        int vtableId = funcDesc.oVft;
+        short vtableId = funcDesc.oVft.shortValue();
         String returnType = this.getType(funcDesc);        
         
         this.replaceVariable("helpstring", docStr);

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbPropertyPut.java
Patch:
@@ -53,8 +53,8 @@ public TlbPropertyPut(int count, int index, TypeLibUtil typeLibUtil,
         this.methodName = "set" + getMethodName();
         String methodparams = "";
         String methodvariables = ", ";
-        int vtableId = funcDesc.oVft;
-        int paramCount = funcDesc.cParams;
+        short vtableId = funcDesc.oVft.shortValue();
+        short paramCount = funcDesc.cParams.shortValue();
         String varType;
         String[] names = typeInfoUtil.getNames(funcDesc.memid, paramCount + 1);
 

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbPropertyPutStub.java
Patch:
@@ -54,8 +54,8 @@ public TlbPropertyPutStub(int index, TypeLibUtil typeLibUtil,
         String docStr = typeInfoDoc.getDocString();
         String methodname = "set" + typeInfoDoc.getName();
         String methodparams = "";
-        int vtableId = funcDesc.oVft;
-        int paramCount = funcDesc.cParams;
+        short vtableId = funcDesc.oVft.shortValue();
+        short paramCount = funcDesc.cParams.shortValue();
         String varType;
         String[] names = typeInfoUtil.getNames(funcDesc.memid, paramCount + 1);
 

File: src/com/sun/jna/Structure.java
Patch:
@@ -534,8 +534,6 @@ public void read() {
         try {
             for (Iterator i=fields().values().iterator();i.hasNext();) {
                 StructField structField = (StructField)i.next();
-                System.out.println(structField.name);
-                System.out.println(structField.type.toString());
                 readField(structField);
             }
         }

File: contrib/platform/src/com/sun/jna/platform/win32/COM/COMLateBindingBaseObject.java
Patch:
@@ -18,7 +18,7 @@
 import com.sun.jna.platform.win32.Kernel32;
 import com.sun.jna.platform.win32.OaIdl;
 import com.sun.jna.platform.win32.OaIdl.DISPID;
-import com.sun.jna.platform.win32.OaIdl.DISPIDbyReference;
+import com.sun.jna.platform.win32.OaIdl.DISPIDByReference;
 import com.sun.jna.platform.win32.OaIdl.EXCEPINFO;
 import com.sun.jna.platform.win32.Ole32;
 import com.sun.jna.platform.win32.OleAuto;
@@ -214,7 +214,7 @@ protected HRESULT oleMethod(int nType, VARIANT.ByReference pvResult,
         VARIANT[] _args = null;
         WString[] ptName = new WString[] { new WString(name) };
         DISPPARAMS dp = new DISPPARAMS();
-        DISPIDbyReference pdispID = new DISPIDbyReference();
+        DISPIDByReference pdispID = new DISPIDByReference();
         EXCEPINFO.ByReference pExcepInfo = new EXCEPINFO.ByReference();
         IntByReference puArgErr = new IntByReference();
 
@@ -238,7 +238,7 @@ protected HRESULT oleMethod(int nType, VARIANT.ByReference pvResult,
         // Handle special-case for property-puts!
         if (nType == OleAuto.DISPATCH_PROPERTYPUT) {
             dp.cNamedArgs = new UINT(_argsLen);
-            dp.rgdispidNamedArgs = new DISPIDbyReference(
+            dp.rgdispidNamedArgs = new DISPIDByReference(
                     OaIdl.DISPID_PROPERTYPUT);
         }
 

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32.java
Patch:
@@ -1365,7 +1365,7 @@ boolean CreateProcessW(String lpApplicationName, char[] lpCommandLine,
      *         extended error information, call {@link #GetLastError()}.
      */
     boolean GetLogicalProcessorInformation(Pointer buffer,
-            DWORDbyReference returnLength);
+            DWORDByReference returnLength);
 
     /**
      * Retrieves information about the system's current usage of both physical

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32Util.java
Patch:
@@ -341,7 +341,7 @@ public static final void writePrivateProfileString(final String appName,
     public static final WinNT.SYSTEM_LOGICAL_PROCESSOR_INFORMATION[] getLogicalProcessorInformation() {
         int sizePerStruct = new WinNT.SYSTEM_LOGICAL_PROCESSOR_INFORMATION()
                 .size();
-        WinDef.DWORDbyReference bufferSize = new WinDef.DWORDbyReference(
+        WinDef.DWORDByReference bufferSize = new WinDef.DWORDByReference(
                 new WinDef.DWORD(sizePerStruct));
         Memory memory;
         while (true) {

File: contrib/platform/src/com/sun/jna/platform/win32/OleAuto.java
Patch:
@@ -20,7 +20,7 @@
 import com.sun.jna.Structure;
 import com.sun.jna.WString;
 import com.sun.jna.platform.win32.Guid.GUID;
-import com.sun.jna.platform.win32.OaIdl.DISPIDbyReference;
+import com.sun.jna.platform.win32.OaIdl.DISPIDByReference;
 import com.sun.jna.platform.win32.OaIdl.SAFEARRAY;
 import com.sun.jna.platform.win32.OaIdl.SAFEARRAYBOUND;
 import com.sun.jna.platform.win32.Variant.VARIANT;
@@ -364,7 +364,7 @@ public static class ByReference extends DISPPARAMS implements
 		public VariantArg.ByReference rgvarg;
 
 		/** The rgdispid named args. */
-		public DISPIDbyReference rgdispidNamedArgs;
+		public DISPIDByReference rgdispidNamedArgs;
 
 		/** The c args. */
 		public UINT cArgs;

File: contrib/platform/test/com/sun/jna/platform/win32/COM/ITypeLibTest.java
Patch:
@@ -26,7 +26,7 @@
 import com.sun.jna.platform.win32.WinDef.LCID;
 import com.sun.jna.platform.win32.WinDef.UINT;
 import com.sun.jna.platform.win32.WinDef.ULONG;
-import com.sun.jna.platform.win32.WinDef.USHORTbyReference;
+import com.sun.jna.platform.win32.WinDef.USHORTByReference;
 import com.sun.jna.platform.win32.WinNT.HRESULT;
 import com.sun.jna.ptr.PointerByReference;
 
@@ -129,7 +129,7 @@ public void testFindName() {
 		ITypeLib shellTypeLib = loadShellTypeLib();
 		BSTRByReference szNameBuf = new BSTRByReference(OleAuto.INSTANCE.SysAllocString("Application"));
 		ULONG lHashVal = new ULONG(0);
-		USHORTbyReference pcFound = new USHORTbyReference((short)20);
+		USHORTByReference pcFound = new USHORTByReference((short)20);
 
 		HRESULT hr = shellTypeLib.FindName(szNameBuf, lHashVal, null, null, pcFound);
 

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/TlbImp.java
Patch:
@@ -18,6 +18,7 @@
 import java.io.FileOutputStream;
 import java.io.IOException;
 
+import com.sun.jna.Native;
 import com.sun.jna.platform.win32.OaIdl.TYPEKIND;
 import com.sun.jna.platform.win32.COM.TypeLibUtil;
 import com.sun.jna.platform.win32.COM.TypeLibUtil.TypeLibDoc;

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbFunction.java
Patch:
@@ -52,8 +52,8 @@ public TlbFunction(int count, int index, TypeLibUtil typeLibUtil, FUNCDESC funcD
 
         String methodparams = "";
         String methodvariables = "";
-        short vtableId = funcDesc.oVft;
-        short paramCount = funcDesc.cParams;
+        int vtableId = funcDesc.oVft;
+        int paramCount = funcDesc.cParams;
         ELEMDESC elemDesdRetType = funcDesc.elemdescFunc;
         String returnType = this.getType(elemDesdRetType.tdesc);
         String[] names = typeInfoUtil.getNames(funcDesc.memid, paramCount + 1);

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbFunctionStub.java
Patch:
@@ -56,8 +56,8 @@ public TlbFunctionStub(int index, TypeLibUtil typeLibUtil,
 
         String methodparams = "";
         String methodvariables = "";
-        short vtableId = funcDesc.oVft;
-        short paramCount = funcDesc.cParams;
+        int vtableId = funcDesc.oVft;
+        int paramCount = funcDesc.cParams;
         ELEMDESC elemDesdRetType = funcDesc.elemdescFunc;
         String returnType = this.getType(elemDesdRetType.tdesc);
         String[] names = typeInfoUtil.getNames(funcDesc.memid, paramCount + 1);

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbPropertyGet.java
Patch:
@@ -47,7 +47,7 @@ public TlbPropertyGet(int count, int index, TypeLibUtil typeLibUtil,
         super(index, typeLibUtil, funcDesc, typeInfoUtil);
 
         this.methodName = "get" + this.getMethodName();
-        short vtableId = funcDesc.oVft;
+        int vtableId = funcDesc.oVft;
         String returnType = this.getType(funcDesc);
         
         this.replaceVariable("helpstring", docStr);

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbPropertyGetStub.java
Patch:
@@ -53,7 +53,7 @@ public TlbPropertyGetStub(int index, TypeLibUtil typeLibUtil,
         TypeInfoDoc typeInfoDoc = typeInfoUtil.getDocumentation(funcDesc.memid);
         String docStr = typeInfoDoc.getDocString();
         String methodname = "get" + typeInfoDoc.getName();
-        short vtableId = funcDesc.oVft;
+        int vtableId = funcDesc.oVft;
         String returnType = this.getType(funcDesc);        
         
         this.replaceVariable("helpstring", docStr);

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbPropertyPut.java
Patch:
@@ -53,8 +53,8 @@ public TlbPropertyPut(int count, int index, TypeLibUtil typeLibUtil,
         this.methodName = "set" + getMethodName();
         String methodparams = "";
         String methodvariables = ", ";
-        short vtableId = funcDesc.oVft;
-        short paramCount = funcDesc.cParams;
+        int vtableId = funcDesc.oVft;
+        int paramCount = funcDesc.cParams;
         String varType;
         String[] names = typeInfoUtil.getNames(funcDesc.memid, paramCount + 1);
 

File: contrib/platform/src/com/sun/jna/platform/win32/COM/tlb/imp/TlbPropertyPutStub.java
Patch:
@@ -54,8 +54,8 @@ public TlbPropertyPutStub(int index, TypeLibUtil typeLibUtil,
         String docStr = typeInfoDoc.getDocString();
         String methodname = "set" + typeInfoDoc.getName();
         String methodparams = "";
-        short vtableId = funcDesc.oVft;
-        short paramCount = funcDesc.cParams;
+        int vtableId = funcDesc.oVft;
+        int paramCount = funcDesc.cParams;
         String varType;
         String[] names = typeInfoUtil.getNames(funcDesc.memid, paramCount + 1);
 

File: src/com/sun/jna/Structure.java
Patch:
@@ -624,7 +624,7 @@ static Structure updateStructureByReference(Class type, Structure s, Pointer add
      * updated from the contents of native memory.
      */
     // TODO: make overridable method with calculated native type, offset, etc
-    Object readField(StructField structField) {
+    protected Object readField(StructField structField) {
 
         // Get the offset of the field
         int offset = structField.offset;
@@ -734,7 +734,7 @@ public void writeField(String name, Object value) {
         writeField(structField);
     }
 
-    void writeField(StructField structField) {
+    protected void writeField(StructField structField) {
 
         if (structField.isReadOnly)
             return;
@@ -1663,7 +1663,7 @@ StructField typeInfoField() {
         return null;
     }
 
-    static class StructField extends Object {
+    protected static class StructField extends Object {
         public String name;
         public Class type;
         public Field field;

File: src/com/sun/jna/Structure.java
Patch:
@@ -1301,7 +1301,7 @@ else if (actualAlignType == ALIGN_GNUC) {
             // NOTE this is published ABI for 32-bit gcc/linux/x86, osx/x86,
             // and osx/ppc.  osx/ppc special-cases the first element
             if (!isFirstElement || !(Platform.isMac() && Platform.isPPC())) {
-                alignment = Math.min(Native.MAX_PADDING, alignment);
+                alignment = Math.min(Native.MAX_ALIGNMENT, alignment);
             }
             if (!isFirstElement && Platform.isAIX() && (type == double.class || type == Double.class)) {
                 alignment = 4;

File: test/com/sun/jna/StructureTest.java
Patch:
@@ -158,7 +158,7 @@ protected List getFieldOrder() {
         }
         Structure s = new TestStructure();
         s.setAlignType(Structure.ALIGN_GNUC);
-        final int SIZE = Native.MAX_PADDING == 8 ? 32 : 28;
+        final int SIZE = Native.MAX_ALIGNMENT == 8 ? 32 : 28;
         assertEquals("Wrong structure size", SIZE, s.size());
     }
 

File: test/com/sun/jna/JNAUnloadTest.java
Patch:
@@ -105,7 +105,7 @@ public void testLoadAndUnloadFromJar() throws Exception {
         Class cls = Class.forName("com.sun.jna.Native", true, loader);
         assertEquals("Wrong class loader", loader, cls.getClassLoader());
 
-        Field field = cls.getDeclaredField("nativeLibraryPath");
+        Field field = cls.getDeclaredField("jnidispatchPath");
         field.setAccessible(true);
         String path = (String)field.get(null);
         assertNotNull("Native library path unavailable", path);
@@ -159,7 +159,7 @@ public void testLoadAndUnloadFromResourcePath() throws Exception {
         Class cls = Class.forName("com.sun.jna.Native", true, loader);
         assertEquals("Wrong class loader", loader, cls.getClassLoader());
 
-        Field field = cls.getDeclaredField("nativeLibraryPath");
+        Field field = cls.getDeclaredField("jnidispatchPath");
         field.setAccessible(true);
         String path = (String)field.get(null);
         assertNotNull("Native library not found", path);

File: src/com/sun/jna/NativeLibrary.java
Patch:
@@ -256,6 +256,7 @@ else if (Platform.isWindows() && !isAbsolutePath) {
                 try {
                     File embedded = Native.extractFromResourcePath(libraryName, (ClassLoader)options.get(Library.OPTION_CLASSLOADER));
                     handle = Native.open(embedded.getAbsolutePath());
+                    libraryPath = embedded.getAbsolutePath();
                     // Don't leave temporary files around
                     if (Native.isUnpacked(embedded)) {
                         Native.deleteLibrary(embedded);

File: test/com/sun/jna/LibraryLoadTest.java
Patch:
@@ -143,9 +143,6 @@ public void testLoadLibraryWithUnicodeName() throws Exception {
         File tmpdir = Native.getTempDir();
         String libName = NativeLibrary.mapSharedLibraryName("testlib");
         File src = new File(TESTPATH, libName);
-        if (Platform.isWindowsCE()) {
-            src = new File("/Storage Card", libName);
-        }
         assertTrue("Expected JNA native library at " + src + " is missing", src.exists());
 
         final String UNICODE = "\u0444\u043b\u0441\u0432\u0443";

File: test/com/sun/jna/VMCrashProtectionTest.java
Patch:
@@ -14,15 +14,15 @@
 
 import junit.framework.TestCase;
 
-// TODO: add more platforms
 public class VMCrashProtectionTest extends TestCase {
     
+    private boolean savedProtected = Boolean.getBoolean("jna.protected");
     protected void setUp() {
         Native.setProtected(true);
     }
     
     protected void tearDown() {
-        Native.setProtected(false);
+        Native.setProtected(savedProtected);
     }
     
     public void testAccessViolation() {

File: src/com/sun/jna/Native.java
Patch:
@@ -153,7 +153,7 @@ public void uncaughtException(Callback c, Throwable e) {
         }
 	MAX_PADDING = Platform.isSPARC() || Platform.isWindows() || Platform.isARM()
             || Platform.isAIX() || Platform.isAndroid()
-            || (Platform.isPPC() && Platform.isLinux())
+            || Platform.isPPC()
             ? 8 : LONG_SIZE;
     }
 

File: src/com/sun/jna/Native.java
Patch:
@@ -1481,6 +1481,7 @@ else if (cvt[t] == CVT_TYPE_MAPPER) {
         looking them up later.
     */
     private static void cacheOptions(Class cls, Map libOptions, Object proxy) {
+        libOptions = new HashMap(libOptions);
         synchronized(libraries) {
             options.put(cls, libOptions);
             if (proxy != null) {

File: test/com/sun/jna/NativeTest.java
Patch:
@@ -111,7 +111,7 @@ interface VoidCallback extends Callback {
     }
     public void testSynchronizedAccess() throws Exception {
         final boolean[] lockHeld = { false };
-        final NativeLibrary nlib = NativeLibrary.getInstance("testlib");
+        final NativeLibrary nlib = NativeLibrary.getInstance("testlib", TestLib.class.getClassLoader());
         final TestLib lib = (TestLib)Native.loadLibrary("testlib", TestLib.class);
         final TestLib synchlib = (TestLib)Native.synchronizedLibrary(lib); 
         final TestLib.VoidCallback cb = new TestLib.VoidCallback() {
@@ -168,6 +168,7 @@ public interface TestInterfaceWithInstance extends Library {
         TypeMapper TEST_MAPPER = new DefaultTypeMapper();
         String TEST_ENCODING = "test-encoding";
         Map TEST_OPTS = new HashMap() { {
+            put(OPTION_CLASSLOADER, TestInterfaceWithInstance.class.getClassLoader());
             put(OPTION_TYPE_MAPPER, TEST_MAPPER);
             put(OPTION_STRUCTURE_ALIGNMENT, new Integer(TEST_ALIGNMENT));
             put(OPTION_STRING_ENCODING, TEST_ENCODING);

File: test/com/sun/jna/CallbacksTest.java
Patch:
@@ -1203,9 +1203,9 @@ public void callback() {
         assertTrue("GetModuleHandleEx(fptr) failed: " + Native.getLastError(), result != 0);
 
         f = kernel32.getFunction("GetModuleHandleW");
-        Pointer handle = f.invokePointer(new Object[] { "jnidispatch" });
+        Pointer handle = f.invokePointer(new Object[] { "jnidispatch.dll" });
         assertTrue("GetModuleHandle(\"jnidispatch\") failed: " + Native.getLastError(), result != 0);
-        assertNotNull("Could not object module handle for jnidispatch.dll", handle);
+        assertNotNull("Could not get module handle for jnidispatch.dll", handle);
         assertEquals("Wrong module HANDLE for DLL function pointer", handle, pref.getValue());
 
         // Check slot re-use

File: test/com/sun/jna/CallbacksTest.java
Patch:
@@ -1196,15 +1196,16 @@ public void callback() {
         // Check module information
         Pointer fp = CallbackReference.getFunctionPointer(cb);
         NativeLibrary kernel32 = NativeLibrary.getInstance("kernel32", W32APIOptions.DEFAULT_OPTIONS);
-        Function f = kernel32.getFunction("GetModuleHandleEx");
+        Function f = kernel32.getFunction("GetModuleHandleExW");
         final int GET_MODULE_HANDLE_FROM_ADDRESS = 0x4;
         PointerByReference pref = new PointerByReference();
         int result = f.invokeInt(new Object[] { new Integer(GET_MODULE_HANDLE_FROM_ADDRESS), fp, pref });
         assertTrue("GetModuleHandleEx(fptr) failed: " + Native.getLastError(), result != 0);
 
-        f = kernel32.getFunction("GetModuleHandle");
+        f = kernel32.getFunction("GetModuleHandleW");
         Pointer handle = f.invokePointer(new Object[] { "jnidispatch" });
         assertTrue("GetModuleHandle(\"jnidispatch\") failed: " + Native.getLastError(), result != 0);
+        assertNotNull("Could not object module handle for jnidispatch.dll", handle);
         assertEquals("Wrong module HANDLE for DLL function pointer", handle, pref.getValue());
 
         // Check slot re-use

File: src/com/sun/jna/NativeLibrary.java
Patch:
@@ -382,7 +382,8 @@ public static synchronized final NativeLibrary getProcess(Map options) {
 
     /**
      * Add a path to search for the specified library, ahead of any system
-     * paths.
+     * paths.  This is similar to setting <code>jna.library.path</code>, but
+     * only extends the search path for a single library.
      *
      * @param libraryName The name of the library to use the path for
      * @param path The path to use when trying to load the library

File: src/com/sun/jna/NativeLibrary.java
Patch:
@@ -89,8 +89,8 @@ private NativeLibrary(String libraryName, String libraryPath, long handle, Map o
         this.libraryPath = libraryPath;
         this.handle = handle;
         Object option = options.get(Library.OPTION_CALLING_CONVENTION);
-        int callingConvention = option instanceof Integer
-            ? ((Integer)option).intValue() : Function.C_CONVENTION;
+        int callingConvention = option instanceof Number
+            ? ((Number)option).intValue() : Function.C_CONVENTION;
         this.callFlags = callingConvention;
         this.options = options;
         String encoding = (String)options.get(Library.OPTION_STRING_ENCODING);

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32Util.java
Patch:
@@ -48,7 +48,7 @@ public static String getComputerName() {
 	
     /**
      * Format a message from the value obtained from {@link
-     * Kernel32.GetLastError} or {@link Native.getLastError}.
+     * Kernel32#GetLastError} or {@link Native#getLastError}.
      * @param code
      *  int
      * @return
@@ -84,7 +84,7 @@ public static String formatMessage(HRESULT code) {
         return formatMessage(code.intValue());
     }
 
-    /** @deprecated use {@link formatMessage(HRESULT)} instead. */
+    /** @deprecated use {@link #formatMessage(WinNT.HRESULT)} instead. */
     public static String formatMessageFromHR(HRESULT code) {
         return formatMessage(code.intValue());
     }

File: src/com/sun/jna/Pointer.java
Patch:
@@ -1207,7 +1207,7 @@ public void setPointer(long offset, Pointer value) {
      * <code>char</code> using the encoding indicated by {@link
      * Native#getDefaultStringEncoding()}. 
      * 
-     * @deprecated use {@link setWideString(long,String)} instead.
+     * @deprecated use {@link #setWideString(long,String)} instead.
      */
     public void setString(long offset, String value, boolean wide) {
         if (wide) {

File: test/com/sun/jna/NativeTest.java
Patch:
@@ -337,7 +337,7 @@ public void testGetOptionsForDirectMapping() {
             assertEquals("Wrong encoding for direct mapping " + classes[i],
                          encoding, Native.getStringEncoding(classes[i]));
             Object last = Native.getLibraryOptions(classes[i]);;
-            assertSame("Options not cached", last, Native.getStringEncoding(classes[i]));
+            assertSame("Options not cached", last, Native.getLibraryOptions(classes[i]));
         }
     }
 
@@ -380,7 +380,7 @@ public void testGetOptionsForDirectMappingStatic() {
             assertEquals("Wrong encoding for direct mapping " + classes[i],
                          DirectMappingStatic.TEST_ENCODING, Native.getStringEncoding(classes[i]));
             Object last = Native.getLibraryOptions(classes[i]);;
-            assertSame("Options not cached", last, Native.getStringEncoding(classes[i]));
+            assertSame("Options not cached", last, Native.getLibraryOptions(classes[i]));
         }
     }
 

File: src/com/sun/jna/Native.java
Patch:
@@ -151,7 +151,6 @@ public void uncaughtException(Callback c, Throwable e) {
                             + " - set jna.boot.library.path to include the path to the version of the " + LS
                             + "   jnidispatch library included with the JNA jar file you are using" + LS);
         }
-        setPreserveLastError("true".equalsIgnoreCase(System.getProperty("jna.preserve_last_error", "true")));
 	MAX_PADDING = Platform.isSPARC() || Platform.isWindows() || Platform.isARM()
             || Platform.isAIX() || Platform.isAndroid()
             || (Platform.isPPC() && Platform.isLinux())

File: src/com/sun/jna/Union.java
Patch:
@@ -209,8 +209,9 @@ Object readField(StructField field) {
             return super.readField(field);
         }
         // Field not accessible
-        // TODO: read structure, to the extent possible; need a "recursive"
-        // flag to "read" to indicate we want to avoid pointer-based fields
+        // TODO: read by-value structures, to the extent possible; need a
+        // "read cautiously" method to "read" to indicate we want to avoid
+        // pointer-based fields 
         return null;
     }
 

File: test/com/sun/jna/StructureTest.java
Patch:
@@ -158,7 +158,7 @@ protected List getFieldOrder() {
         }
         Structure s = new TestStructure();
         s.setAlignType(Structure.ALIGN_GNUC);
-        final int SIZE = Structure.MAX_GNUC_ALIGNMENT == 8 ? 32 : 28;
+        final int SIZE = Native.MAX_PADDING == 8 ? 32 : 28;
         assertEquals("Wrong structure size", SIZE, s.size());
     }
 

File: src/com/sun/jna/Structure.java
Patch:
@@ -1303,7 +1303,7 @@ else if (actualAlignType == ALIGN_MSVC) {
         else if (actualAlignType == ALIGN_GNUC) {
             // NOTE this is published ABI for 32-bit gcc/linux/x86, osx/x86,
             // and osx/ppc.  osx/ppc special-cases the first element
-            if (!isFirstElement || !(Platform.isMac() && Platfomr.isPPC())) {
+            if (!isFirstElement || !(Platform.isMac() && Platform.isPPC())) {
                 alignment = Math.min(MAX_GNUC_ALIGNMENT, alignment);
             }
             if (!isFirstElement && Platform.isAIX() && (type == double.class || type == Double.class)) {

File: src/com/sun/jna/Native.java
Patch:
@@ -152,7 +152,9 @@ public void uncaughtException(Callback c, Throwable e) {
                             + "   jnidispatch library included with the JNA jar file you are using" + LS);
         }
         setPreserveLastError("true".equalsIgnoreCase(System.getProperty("jna.preserve_last_error", "true")));
-	MAX_PADDING = Platform.isSPARC() || Platform.isWindows()
+	MAX_PADDING = Platform.isSPARC() || Platform.isWindows() || Platform.isARM()
+            || Platform.isAIX() || Platform.isAndroid()
+            || (Platform.isPPC() && Platform.isLinux())
             ? 8 : LONG_SIZE;
     }
 

File: contrib/platform/src/com/sun/jna/platform/win32/WinDef.java
Patch:
@@ -70,11 +70,11 @@ public WORDByReference(WORD value) {
 		}
 
 		public void setValue(WORD value) {
-			getPointer().setInt(0, value.intValue());
+			getPointer().setShort(0, value.shortValue());
 		}
 
 		public WORD getValue() {
-			return new WORD(getPointer().getInt(0));
+			return new WORD(getPointer().getShort(0));
 		}
 	}
 

File: contrib/platform/src/com/sun/jna/platform/win32/Guid.java
Patch:
@@ -19,7 +19,6 @@
 import com.sun.jna.Pointer;
 import com.sun.jna.Structure;
 
-// TODO: Auto-generated Javadoc
 /**
  * Ported from Guid.h. Microsoft Windows SDK 6.0A.
  *

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32.java
Patch:
@@ -20,7 +20,6 @@
 import com.sun.jna.ptr.PointerByReference;
 import com.sun.jna.win32.W32APIOptions;
 
-// TODO: Auto-generated Javadoc
 /**
  * Interface definitions for <code>kernel32.dll</code>. Includes additional
  * alternate mappings from {@link WinNT} which make use of NIO buffers.

File: contrib/platform/src/com/sun/jna/platform/win32/OaIdl.java
Patch:
@@ -33,7 +33,6 @@
 import com.sun.jna.platform.win32.COM.ITypeComp;
 import com.sun.jna.ptr.ByReference;
 
-// TODO: Auto-generated Javadoc
 /**
  * The Interface OaIdl.
  */

File: contrib/platform/src/com/sun/jna/platform/win32/ObjBase.java
Patch:
@@ -22,7 +22,6 @@
 import com.sun.jna.platform.win32.WTypes;
 
 
-// TODO: Auto-generated Javadoc
 /**
  * Definitions from ObjBase.h
  * @author scott.palmer

File: contrib/platform/src/com/sun/jna/platform/win32/Ole32.java
Patch:
@@ -23,7 +23,6 @@
 import com.sun.jna.win32.StdCallLibrary;
 import com.sun.jna.win32.W32APIOptions;
 
-// TODO: Auto-generated Javadoc
 /**
  * Ole32.dll Interface.
  * 

File: contrib/platform/src/com/sun/jna/platform/win32/OleAuto.java
Patch:
@@ -38,7 +38,6 @@
 import com.sun.jna.win32.StdCallLibrary;
 import com.sun.jna.win32.W32APIOptions;
 
-// TODO: Auto-generated Javadoc
 /**
  * Oleaut32.dll Interface.
  * 

File: contrib/platform/src/com/sun/jna/platform/win32/OleAutoUtil.java
Patch:
@@ -19,7 +19,6 @@
 import com.sun.jna.platform.win32.WinNT.HRESULT;
 import com.sun.jna.platform.win32.COM.COMUtils;
 
-// TODO: Auto-generated Javadoc
 /**
  * The Class OleAut32Util.
  *

File: contrib/platform/src/com/sun/jna/platform/win32/User32.java
Patch:
@@ -23,7 +23,6 @@
 import com.sun.jna.win32.StdCallLibrary;
 import com.sun.jna.win32.W32APIOptions;
 
-// TODO: Auto-generated Javadoc
 /**
  * Provides access to the w32 user32 library. Incomplete implementation to
  * support demos.

File: contrib/platform/src/com/sun/jna/platform/win32/W32Errors.java
Patch:
@@ -14,7 +14,6 @@
 
 import com.sun.jna.platform.win32.WinNT.HRESULT;
 
-// TODO: Auto-generated Javadoc
 /**
  * Utility class for some common error functions.
  */

File: contrib/platform/src/com/sun/jna/platform/win32/WinDef.java
Patch:
@@ -24,7 +24,6 @@
 import com.sun.jna.ptr.ByReference;
 import com.sun.jna.win32.StdCallLibrary;
 
-// TODO: Auto-generated Javadoc
 /**
  * Ported from Windef.h (various macros and types). Microsoft Windows SDK 6.0A.
  *

File: contrib/platform/src/com/sun/jna/platform/win32/Ole32.java
Patch:
@@ -46,7 +46,7 @@ public interface Ole32 extends StdCallLibrary {
      */
     HRESULT CoCreateGuid(GUID pguid);
 
-    /** @deprecated use {@link #CoCreateGuid(GUID)}. */
+    /** @deprecated use {@link #CoCreateGuid(Guid.GUID)}. */
     HRESULT CoCreateGuid(GUID.ByReference pguid);
 
     /**

File: contrib/platform/src/com/sun/jna/platform/win32/OaIdl.java
Patch:
@@ -1214,5 +1214,4 @@ protected List getFieldOrder() {
 							"wMinorVerNum", "tdescAlias", "idldescType" });
 		}
 	}
-
 }

File: contrib/platform/test/com/sun/jna/platform/win32/Kernel32Test.java
Patch:
@@ -411,7 +411,6 @@ public void testCreateProcess() {
         assertTrue(processInformation.dwProcessId.longValue() > 0);
     }
 
-    // TODO
     public void testCreateProcessW() {
         WinBase.STARTUPINFO startupInfo = new WinBase.STARTUPINFO();
         WinBase.PROCESS_INFORMATION.ByReference processInformation = new WinBase.PROCESS_INFORMATION.ByReference();

File: test/com/sun/jna/WebStartTest.java
Patch:
@@ -152,7 +152,6 @@ private void runTestUnderWebStart(String testClass, String testMethod) throws Ex
                 path,
                 Platform.isWindows() ? "-J-Ddummy" : (Platform.is64Bit() ? "-J-d64" : "-J-d32"),
                 "-Xnosplash", 
-                "-verbose",
                 "-wait", 
                 jnlp.toURI().toURL().toString(),
             };

File: src/com/sun/jna/Native.java
Patch:
@@ -152,7 +152,8 @@ public void uncaughtException(Callback c, Throwable e) {
                             + "   jnidispatch library included with the JNA jar file you are using" + LS);
         }
         setPreserveLastError("true".equalsIgnoreCase(System.getProperty("jna.preserve_last_error", "true")));
-	MAX_PADDING = Platform.isSPARC() ? 8 : LONG_SIZE;
+	MAX_PADDING = Platform.isSPARC() || Platform.isWindows()
+            ? 8 : LONG_SIZE;
     }
 
     /** Force a dispose when this class is GC'd. */

File: src/com/sun/jna/Platform.java
Patch:
@@ -45,6 +45,7 @@ public final class Platform {
     public static final String RESOURCE_PREFIX;
 
     private static final int osType;
+    static final int MAX_PADDING;
 
     static {
         String osName = System.getProperty("os.name");
@@ -108,6 +109,8 @@ else if (osName.equalsIgnoreCase("netbsd")) {
         MATH_LIBRARY_NAME = osType == WINDOWS ? "msvcrt" : osType == WINDOWSCE ? "coredll" : "m";
         HAS_DLL_CALLBACKS = osType == WINDOWS;
         RESOURCE_PREFIX = getNativeLibraryResourcePrefix();
+	String arch = System.getProperty("os.arch").toLowerCase();
+	MAX_PADDING = "sparc".equals(arch) ? 8 : Native.LONG_SIZE;
     }
     private Platform() { }
     public static final int getOSType() {

File: test/com/sun/jna/StructureTest.java
Patch:
@@ -401,7 +401,7 @@ protected List getFieldOrder() {
             }
         }
         TestStructure s = new TestStructure();
-        assertEquals("Wrong structure size", Pointer.SIZE == 4 ? 20 : 24, s.size());
+        assertEquals("Wrong structure size",Platform.MAX_PADDING == 4 ? 20 : 24, s.size());
         assertEquals("Wrong union size", 8, s.s_union.size());
     }
 

File: test/com/sun/jna/StructureTest.java
Patch:
@@ -401,7 +401,7 @@ protected List getFieldOrder() {
             }
         }
         TestStructure s = new TestStructure();
-        assertEquals("Wrong structure size", 24, s.size());
+        assertEquals("Wrong structure size", Pointer.SIZE == 4 ? 20 : 24, s.size());
         assertEquals("Wrong union size", 8, s.s_union.size());
     }
 

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32.java
Patch:
@@ -1142,7 +1142,7 @@ boolean CreateProcess(String lpApplicationName, String lpCommandLine,
 	 *            NULL, the module name portion of <i>lpCommandLine</i> is
 	 *            limited to MAX_PATH characters.
          *            <p/>
-         *            The Unicode version of this function, {@link #CreateProcessW()},
+         *            The Unicode version of this function, {@link #CreateProcessW},
 	 *            can modify the contents of this string. Therefore, this
 	 *            parameter cannot be a pointer to read-only memory (such
 	 *            as a const variable or a literal string). If this

File: contrib/platform/test/com/sun/jna/platform/win32/Kernel32UtilTest.java
Patch:
@@ -185,8 +185,8 @@ public final void testWritePrivateProfileString() throws IOException {
     }
 
     public final void testGetLogicalProcessorInformation() {
-        WinNT.SYSTEM_LOGICAL_PROCESSOR_INFORMATION informationArray = Kernel32Util.getLogicalProcessorInformation();
-        assertTrue(informationArray >= 1); // docs say so
+        WinNT.SYSTEM_LOGICAL_PROCESSOR_INFORMATION[] informationArray = Kernel32Util.getLogicalProcessorInformation();
+        assertTrue(informationArray.length >= 1); // docs say so
         for (WinNT.SYSTEM_LOGICAL_PROCESSOR_INFORMATION information : informationArray) {
             //TODO: What can we check? Java itself has no way to get physical processor info (if it did,
             // I wouldn't be writing in JNA support for it.)

File: test/com/sun/jna/CallbacksTest.java
Patch:
@@ -1088,7 +1088,7 @@ public void callback() {
                      1, threads.size());
     }
 
-    // Thread object is never GC'd on linux-amd64 and (sometimes) win32-amd64
+    // Thread object is never GC'd on linux-amd64 and darwin-amd64 (w/openjdk7)
     public void testAttachedThreadCleanupOnExit() throws Exception {
         final Set threads = new HashSet();
         final int[] called = { 0 };

File: test/com/sun/jna/WebStartTest.java
Patch:
@@ -149,6 +149,7 @@ private void runTestUnderWebStart(String testClass, String testMethod) throws Ex
             String path = findJWS();
             String[] cmd = {
                 path,
+                Platform.isWindows() ? "-J-Ddummy" : (Platform.is64Bit() ? "-J-d64" : "-J-d32"),
                 "-Xnosplash", 
                 "-wait", 
                 jnlp.toURI().toURL().toString(),

File: src/com/sun/jna/NativeLibrary.java
Patch:
@@ -189,8 +189,7 @@ else if (Platform.isLinux()) {
             }
             // Search framework libraries on OS X
             else if (Platform.isMac()
-                     && !libraryName.endsWith(".dylib")
-                     && !isAbsolutePath) {
+                     && !libraryName.endsWith(".dylib")) {
                 libraryPath = matchFramework(libraryName);
                 if (libraryPath != null) {
                     try {

File: test/com/sun/jna/LastErrorTest.java
Patch:
@@ -75,10 +75,10 @@ public void testLastErrorPerThreadStorage() throws Exception {
         }
     }
 
+    private final int ERROR = Platform.isWindows() ? 1 : -1;
     public void testThrowLastError() {
         TestLibrary lib = (TestLibrary)Native.loadLibrary("testlib", TestLibrary.class, OPTIONS);
 
-        final int ERROR = -1;
         lib.noThrowLastError(ERROR);
         assertEquals("Last error not preserved", ERROR, Native.getLastError());
         try {
@@ -87,14 +87,13 @@ public void testThrowLastError() {
         }
         catch(LastErrorException e) {
             assertEquals("Exception should contain error code", ERROR, e.getErrorCode());
-            assertTrue("Exception should include error message: " + e.getMessage(), e.getMessage().length() > 10);
+            assertTrue("Exception should include error message: '" + e.getMessage() + "'", e.getMessage().length() > 0);
         }
     }
 
     public void testThrowLastErrorDirect() {
         TestLibrary lib = new DirectTestLibrary();
 
-        final int ERROR = -1;
         lib.noThrowLastError(ERROR);
         assertEquals("Last error not preserved", ERROR, Native.getLastError());
         try {

File: src/com/sun/jna/Structure.java
Patch:
@@ -1283,9 +1283,9 @@ else if (actualAlignType == ALIGN_GNUC) {
             if (!isFirstElement || !(Platform.isMac() && isPPC)) {
                 alignment = Math.min(MAX_GNUC_ALIGNMENT, alignment);
             }
-            if (!isFirstElement && Platform.isAix() && (type.getName().equals("double"))) {
+            if (!isFirstElement && Platform.isAIX() && (type.getName().equals("double"))) {
                 alignment = 4;
-			}
+            }
         }
         return alignment;
     }

File: test/com/sun/jna/JNAUnloadTest.java
Patch:
@@ -62,7 +62,7 @@ protected void assertJarExists() {
     
     protected void assertLibraryExists() {
         String osPrefix = Platform.getNativeLibraryResourcePrefix();
-        String name = System.mapLibraryName("jnidispatch");
+        String name = System.mapLibraryName("jnidispatch").replace(".dylib", ".jnilib");
         File lib = new File(CLASSES + "/com/sun/jna/" + osPrefix + "/" + name);
         if (!lib.exists()) {
             throw new Error("Expected JNA library at " + lib + " is missing");

File: test/com/sun/jna/DirectTest.java
Patch:
@@ -110,7 +110,7 @@ public TestLoader() throws MalformedURLException {
                   : new URL[] {
                       new File(BUILDDIR + "/classes").toURI().toURL(),
                       new File(BUILDDIR + "/test-classes").toURI().toURL(),
-                  }, null);
+                  }, new CloverLoader());
         }
         protected Class findClass(String name) throws ClassNotFoundException {
             String boot = System.getProperty("jna.boot.library.path");
@@ -125,6 +125,7 @@ protected Class findClass(String name) throws ClassNotFoundException {
         }
     }
 
+    // Fails under clover
     public void testRegisterMethods() throws Exception {
         // Use a dedicated class loader to ensure the class can be gc'd
         String name = "com.sun.jna.DirectTest$MathLibrary";

File: test/com/sun/jna/JNAUnloadTest.java
Patch:
@@ -32,7 +32,7 @@ public TestLoader(boolean fromJar) throws MalformedURLException {
                     Platform.isWindowsCE() 
                     ? new File("/Storage Card/" + (fromJar ? "jna.jar" : "test.jar")).toURI().toURL()
                     : new File(BUILDDIR + (fromJar ? "/jna.jar" : "/classes")).toURI().toURL(),
-            }, null);
+                  }, new CloverLoader());
             if (fromJar) {
                 assertJarExists();
             }

File: test/com/sun/jna/LibraryLoadTest.java
Patch:
@@ -29,7 +29,8 @@ public class LibraryLoadTest extends TestCase implements Paths {
     
     private class TestLoader extends URLClassLoader {
         public TestLoader(File path) throws MalformedURLException {
-            super(new URL[] { path.toURI().toURL() }, null);
+            super(new URL[] { path.toURI().toURL(), },
+                  new CloverLoader());
         }
     }
 

File: test/com/sun/jna/PerformanceTest.java
Patch:
@@ -17,9 +17,6 @@
 import com.sun.jna.ptr.PointerByReference;
 import java.lang.ref.*;
 import java.io.File;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.net.URLClassLoader;
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;

File: test/com/sun/jna/WebStartTest.java
Patch:
@@ -136,10 +136,8 @@ private void runTestUnderWebStart(String testClass, String testMethod) throws Ex
         contents = contents.replace("{CODEBASE}", codebase);
         contents = contents.replace("{JNLP_FILE}", jnlp.toURI().toURL().toString());
         contents = contents.replace("{PORT}", String.valueOf(port));
-        boolean clover =
-            System.getProperty("java.class.path").indexOf("clover") != -1;
         contents = contents.replace("{CLOVER}",
-                                    clover ? "<jar href='clover.jar'/>" : "");
+                                    USING_CLOVER ? "<jar href='clover.jar'/>" : "");
 
         try {
             OutputStream os = new FileOutputStream(jnlp);

File: src/com/sun/jna/Native.java
Patch:
@@ -716,7 +716,7 @@ static boolean isUnpacked(File file) {
      * no transformations of the library name are performed.  If only the base
      * name is given, the resource path is attempted both with and without
      * {@link Platform#RESOURCE_PREFIX}, after mapping the library name via
-     * {@link NativeLibrary#mapSharedLibraryName()}.
+     * {@link NativeLibrary#mapSharedLibraryName(String)}.
      * @return File indicating extracted resource on disk
      * @throws IOException if resource not found
      */
@@ -731,7 +731,7 @@ public static File extractFromResourcePath(String name) throws IOException {
      * no transformations of the library name are performed.  If only the base
      * name is given, the resource path is attempted both with and without
      * {@link Platform#RESOURCE_PREFIX}, after mapping the library name via
-     * {@link NativeLibrary#mapSharedLibraryName()}.
+     * {@link NativeLibrary#mapSharedLibraryName(String)}.
      * @param loader Class loader to use to load resources
      * @return File indicating extracted resource on disk
      * @throws IOException if resource not found
@@ -747,6 +747,7 @@ public static File extractFromResourcePath(String name, ClassLoader loader) thro
         }
         URL url = loader.getResource(resourcePath);
         if (url == null && resourcePath.startsWith(Platform.RESOURCE_PREFIX)) {
+            // If not found with the standard resource prefix, try without it
             url = loader.getResource(libname);
         }
         if (url == null) {

File: src/com/sun/jna/NativeLibrary.java
Patch:
@@ -299,9 +299,9 @@ public static final NativeLibrary getInstance(String libraryName) {
      *      included somewhere in the classpath, either bundled in a jar file
      *      or as a plain file within the classpath.
      */
-    public static final NativeLibrary getInstance(String libraryName, ClassLoader loader) {
+    public static final NativeLibrary getInstance(String libraryName, ClassLoader classLoader) {
         Map map = new HashMap();
-        map.put(Library.OPTION_CLASSLOADER, loader);
+        map.put(Library.OPTION_CLASSLOADER, classLoader);
         return getInstance(libraryName, map);
     }
 
@@ -328,7 +328,7 @@ public static final NativeLibrary getInstance(String libraryName, Map options) {
 
         // Use current process to load libraries we know are already
         // loaded by the VM to ensure we get the correct version
-        if ((Platform.isLinux() || Platform.isAix())
+        if ((Platform.isLinux() || Platform.isAIX())
             && Platform.C_LIBRARY_NAME.equals(libraryName)) {
             libraryName = null;
         }

File: test/com/sun/jna/PlatformTest.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 20013 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2013 Timothy Wall, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: contrib/msoffice/src/com/sun/jna/platform/win32/office/MSExcel.java
Patch:
@@ -8,7 +8,7 @@
 public class MSExcel extends COMObject {
 
 	public MSExcel() throws COMException {
-		super("Excel.Application", false);
+		super("Excel.Application", true);
 	}
 
 	public MSExcel(boolean visible) throws COMException {

File: contrib/platform/src/com/sun/jna/platform/win32/OleAuto.java
Patch:
@@ -32,7 +32,7 @@
 import com.sun.jna.platform.win32.WinDef.PVOID;
 import com.sun.jna.platform.win32.WinDef.UINT;
 import com.sun.jna.platform.win32.WinNT.HRESULT;
-import com.sun.jna.platform.win32.COM.ITypeLib;
+import com.sun.jna.platform.win32.COM.TypeLib;
 import com.sun.jna.ptr.DoubleByReference;
 import com.sun.jna.ptr.PointerByReference;
 import com.sun.jna.win32.StdCallLibrary;
@@ -471,7 +471,7 @@ public HRESULT LoadRegTypeLib(GUID rguid, int wVerMajor, int wVerMinor,
 	 *            TYPE_E_CANTLOADLIBRARY The type library or DLL could not be
 	 *            loaded.
 	 */
-	public HRESULT LoadTypeLib(WString szFile, ITypeLib.ByReference pptlib);
+	public HRESULT LoadTypeLib(WString szFile, TypeLib.ByReference pptlib);
 
 	/**
 	 * Converts a system time to a variant representation.

File: contrib/platform/src/com/sun/jna/platform/win32/Winioctl.java
Patch:
@@ -32,7 +32,8 @@ public interface Winioctl extends StdCallLibrary {
      */
     public static class STORAGE_DEVICE_NUMBER extends Structure {
 
-        public static class ByReference extends STORAGE_DEVICE_NUMBER implements Structure.ByReference {
+		public static class ByReference extends STORAGE_DEVICE_NUMBER implements
+				Structure.ByReference {
             public ByReference() {
             }
 

File: contrib/platform/test/com/sun/jna/platform/win32/COM/IUnknownTest.java
Patch:
@@ -26,7 +26,7 @@
 
 public class IUnknownTest extends TestCase {
 
-	private IDispatch iDispatch = new IDispatch();
+	private Dispatch iDispatch = new Dispatch();
 
 	private PointerByReference pDispatch = new PointerByReference();
 
@@ -63,7 +63,7 @@ protected void setUp() throws Exception {
 			throw new COMException("Internet Explorer not registered properly!");
 		}
 
-		this.iDispatch = new IDispatch(pDispatch.getPointer());
+		this.iDispatch = new Dispatch(pDispatch.getPointer());
 	}
 
 	public void testQueryInterface() {

File: src/com/sun/jna/Version.java
Patch:
@@ -12,6 +12,6 @@
  */
 package com.sun.jna;
 interface Version {
-    String VERSION = "3.6.1-SNAPSHOT";
+    String VERSION = "3.6.0-SNAPSHOT";
     String VERSION_NATIVE = "3.6.0";
 }

File: src/com/sun/jna/Structure.java
Patch:
@@ -1295,7 +1295,7 @@ public String toString() {
     }
 
     public String toString(boolean debug) {
-        return toString(0, true, true);
+        return toString(0, true, debug);
     }
 
     private String format(Class type) {

File: test/com/sun/jna/LastErrorTest.java
Patch:
@@ -87,6 +87,7 @@ public void testThrowLastError() {
         }
         catch(LastErrorException e) {
             assertEquals("Exception should contain error code", ERROR, e.getErrorCode());
+            assertTrue("Exception should include error message: " + e.getMessage(), e.getMessage().length() > 10);
         }
     }
 
@@ -102,6 +103,7 @@ public void testThrowLastErrorDirect() {
         }
         catch(LastErrorException e) {
             assertEquals("Exception should contain error code", ERROR, e.getErrorCode());
+            assertTrue("Exception should include error message: " + e.getMessage(), e.getMessage().length() > 10);
         }
     }
 

File: src/com/sun/jna/Structure.java
Patch:
@@ -1287,7 +1287,7 @@ public String toString() {
     }
 
     public String toString(boolean debug) {
-        return toString(0, true, true);
+        return toString(0, true, debug);
     }
 
     private String format(Class type) {

File: src/com/sun/jna/Platform.java
Patch:
@@ -28,7 +28,9 @@ public final class Platform {
     public static final boolean RO_FIELDS;
     /** Whether this platform provides NIO Buffers. */
     public static final boolean HAS_BUFFERS;
-    /** Whether this platform provides the AWT Component class. */
+    /** Whether this platform provides the AWT Component class; also false if
+     * running headless.
+     */
     public static final boolean HAS_AWT;
     /** Canonical name of this platform's math library. */
     public static final String MATH_LIBRARY_NAME;

File: contrib/platform/src/com/sun/jna/platform/win32/OleAuto.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012 Tobias Wolf, All Rights Reserved
+/* copyright (c) 2012 Tobias Wolf, All Rights Reserved
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -272,7 +272,7 @@ public SAFEARRAY.ByReference SafeArrayCreate(VARTYPE vt, int cDims,
 	 * @param rgIndices
 	 *            [in] A vector of indexes for each dimension of the array. The
 	 *            right-most (least significant) dimension is rgIndices[0]. The
-	 *            left-most dimension is stored at rgIndices[psa->cDims � 1].
+	 *            left-most dimension is stored at rgIndices[psa->cDims - 1].
 	 * @param pv
 	 *            [out] The element of the array.
 	 * 

File: src/com/sun/jna/Pointer.java
Patch:
@@ -1190,7 +1190,7 @@ public String toString() {
     
     /** Read the native peer value.  Use with caution. */
     public static long nativeValue(Pointer p) {
-        return p.peer;
+        return p == null ? 0 : p.peer;
     }
 
     /** Set the native peer value.  Use with caution. */

File: src/com/sun/jna/Native.java
Patch:
@@ -1590,7 +1590,7 @@ public static void main(String[] args) {
         System.out.println("Version: " + version);
         System.out.println(" Native: " + getNativeVersion() + " ("
                            + getAPIChecksum() + ")");
-        System.exit(0);
+        System.out.println(" Prefix: " + getNativeLibraryResourcePrefix());
     }
 
     /** Free the given callback trampoline. */

File: src/com/sun/jna/Native.java
Patch:
@@ -840,7 +840,7 @@ else if (resourcePath.endsWith(".dylib")) {
                 }
             }
             catch(IOException e) {
-                throw new IOException("Failed to create temporary file for " + name + " library", e);
+                throw new IOException("Failed to create temporary file for " + name + " library: " + e.getMessage());
             }
             finally {
                 try { is.close(); } catch(IOException e) { }

File: src/com/sun/jna/Platform.java
Patch:
@@ -28,7 +28,9 @@ public final class Platform {
     public static final boolean RO_FIELDS;
     /** Whether this platform provides NIO Buffers. */
     public static final boolean HAS_BUFFERS;
-    /** Whether this platform provides the AWT Component class. */
+    /** Whether this platform provides the AWT Component class; also false if
+     * running headless.
+     */
     public static final boolean HAS_AWT;
     /** Canonical name of this platform's math library. */
     public static final String MATH_LIBRARY_NAME;

File: contrib/platform/src/com/sun/jna/platform/mac/Carbon.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.Arrays;
 import java.util.List;
 
+import com.sun.jna.Library;
 import com.sun.jna.Callback;
 import com.sun.jna.Native;
 import com.sun.jna.Pointer;
@@ -31,7 +32,7 @@
  * Author: Denis Tulskiy
  * Date: 7/25/11
  */
-public interface Carbon {
+public interface Carbon extends Library {
     public static Carbon INSTANCE = (Carbon) Native.loadLibrary("Carbon", Carbon.class);
 
     public static final int cmdKey = 0x0100;

File: contrib/platform/src/com/sun/jna/platform/win32/OleAuto.java
Patch:
@@ -471,7 +471,7 @@ public HRESULT LoadRegTypeLib(GUID rguid, int wVerMajor, int wVerMinor,
 	 *            TYPE_E_CANTLOADLIBRARY The type library or DLL could not be
 	 *            loaded.
 	 */
-	public HRESULT LoadTypeLib(WString szFile, ITypeLib pptlib);
+	public HRESULT LoadTypeLib(WString szFile, ITypeLib.ByReference pptlib);
 
 	/**
 	 * Converts a system time to a variant representation.

File: contrib/platform/test/com/sun/jna/platform/win32/COM/ITypeLibTest.java
Patch:
@@ -21,6 +21,7 @@
 import com.sun.jna.platform.win32.Kernel32;
 import com.sun.jna.platform.win32.OaIdl.MEMBERID;
 import com.sun.jna.platform.win32.OaIdl.TLIBATTR;
+import com.sun.jna.platform.win32.OaIdl.TYPEKIND;
 import com.sun.jna.platform.win32.Ole32;
 import com.sun.jna.platform.win32.OleAuto;
 import com.sun.jna.platform.win32.WinDef.LCID;
@@ -85,7 +86,7 @@ public void testGetTypeInfo() {
 	public void testGetTypeInfoType() {
 		ITypeLib shellTypeLib = loadShellTypeLib();
 
-		IntByReference pTKind = new IntByReference();
+		TYPEKIND.ByReference pTKind = new TYPEKIND.ByReference();
 		HRESULT hr = shellTypeLib.GetTypeInfoType(new UINT(0), pTKind);
 
 		COMUtils.checkTypeLibRC(hr);

File: contrib/alphamaskdemo/com/sun/jna/contrib/demo/AlphaMaskDemo.java
Patch:
@@ -154,7 +154,7 @@ private void updateX11(boolean a, boolean i) {
                 int w = image.getWidth(null);
                 int h = image.getHeight(null);
                 alphaWindow.setSize(w, h);
-                if (buffer == null || buffer.getSize() != w*h*4) {
+                if (buffer == null || buffer.size() != w*h*4) {
                     buffer = new com.sun.jna.Memory(w*h*4);
                     pixels = new int[w*h];
                 }

File: contrib/platform/src/com/sun/jna/platform/win32/Advapi32.java
Patch:
@@ -912,7 +912,7 @@ public int RegQueryInfoKey(HKEY hKey, char[] lpClass,
 	 *            receive the value, the function returns ERROR_MORE_DATA.
 	 */
 	public int RegGetValue(HKEY hkey, String lpSubKey, String lpValue,
-			int dwFlags, IntByReference pdwType, byte[] lpData,
+			int dwFlags, IntByReference pdwType, byte[] pvData,
 			IntByReference pcbData);
 
 	/**

File: contrib/platform/src/com/sun/jna/platform/win32/Advapi32Util.java
Patch:
@@ -828,11 +828,11 @@ public static long registryGetLongValue(HKEY root, String key, String value) {
 	 * Get a registry value and returns a java object depending on the value
 	 * type.
 	 *
-	 * @param root
+	 * @param hkKey
 	 *            Root key.
-	 * @param key
+	 * @param subKey
 	 *            Registry key path.
-	 * @param value
+	 * @param lpValueName
 	 *            Name of the value to retrieve or null for the default value.
 	 * @return Object value.
 	 */

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32.java
Patch:
@@ -1743,7 +1743,7 @@ boolean Process32Next(HANDLE hSnapshot,
      * @param appName
      *            The name of the section in the initialization file.
      * @param keyName
-     *            The name of the key whose value is to be retrieved. This value is in the form of a string; the {@link GetPrivateProfileInt} function converts
+     *            The name of the key whose value is to be retrieved. This value is in the form of a string; the {@link #GetPrivateProfileInt} function converts
      *            the string into an integer and returns the integer.
      * @param defaultValue
      *            The default value to return if the key name cannot be found in the initialization file.
@@ -1759,13 +1759,13 @@ boolean Process32Next(HANDLE hSnapshot,
      * Retrieves a string from the specified section in an initialization file.
      * 
      * @param lpAppName
-     *            The name of the section containing the key name. If this parameter is {@code null}, the {@link GetPrivateProfileString} function copies all
+     *            The name of the section containing the key name. If this parameter is {@code null}, the {@link #GetPrivateProfileString} function copies all
      *            section names in the file to the supplied buffer.
      * @param lpKeyName
      *            The name of the key whose associated string is to be retrieved. If this parameter is {@code null}, all key names in the section specified by
      *            the {@code lpAppName} parameter are copied to the buffer specified by the {@code lpReturnedString} parameter.
      * @param lpDefault
-     *            A default string. If the {@code lpKeyName} key cannot be found in the initialization file, {@link GetPrivateProfileString} copies the default
+     *            A default string. If the {@code lpKeyName} key cannot be found in the initialization file, {@link #GetPrivateProfileString} copies the default
      *            string to the {@code lpReturnedString} buffer. If this parameter is {@code null}, the default is an empty string, {@code ""}.
      *            <p>
      *            Avoid specifying a default string with trailing blank characters. The function inserts a {@code null} character in the

File: contrib/platform/src/com/sun/jna/platform/win32/User32.java
Patch:
@@ -31,7 +31,7 @@
  * @author Todd Fast, todd.fast@sun.com
  * @author twalljava@dev.java.net
  * @author Tobias Wolf, wolf.tobias@gmx.net
- * @auhtor Markus KARG (markus[at]headcrashing[dot]eu)
+ * @author Markus KARG (markus[at]headcrashing[dot]eu)
  */
 public interface User32 extends StdCallLibrary, WinUser {
 

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32.java
Patch:
@@ -13,9 +13,6 @@
 package com.sun.jna.platform.win32;
 
 import java.nio.Buffer;
-
-import sun.security.jca.GetInstance.Instance;
-
 import com.sun.jna.Native;
 import com.sun.jna.Pointer;
 import com.sun.jna.ptr.IntByReference;

File: contrib/platform/src/com/sun/jna/platform/win32/OaIdl.java
Patch:
@@ -757,11 +757,13 @@ protected List getFieldOrder() {
 		 *            C type : MEMBERID<br>
 		 * @param lpstrSchema
 		 *            C type : LPOLESTR<br>
-		 * @param DUMMYUNIONNAME
+		 * @param union
 		 *            [switch_is][switch_type]<br>
 		 *            C type : DUMMYUNIONNAMEUnion<br>
 		 * @param elemdescVar
 		 *            C type : ELEMDESC<br>
+                 * @param wVarFlags
+                 *            C type : short
 		 * @param varkind
 		 *            C type : VARKIND
 		 */

File: contrib/platform/src/com/sun/jna/platform/win32/OleAuto.java
Patch:
@@ -270,7 +270,7 @@ public SAFEARRAY.ByReference SafeArrayCreate(VARTYPE vt, int cDims,
 	 * @param rgIndices
 	 *            [in] A vector of indexes for each dimension of the array. The
 	 *            right-most (least significant) dimension is rgIndices[0]. The
-	 *            left-most dimension is stored at rgIndices[psa->cDims � 1].
+	 *            left-most dimension is stored at rgIndices[psa->cDims - 1].
 	 * @param pv
 	 *            [out] The element of the array.
 	 * 

File: contrib/platform/src/com/sun/jna/platform/win32/COM/COMException.java
Patch:
@@ -12,7 +12,7 @@
  */
 package com.sun.jna.platform.win32.COM;
 
-import com.sun.jna.platform.win32.OaIdl.EXCEPINFO;
+import com.sun.jna.platform.win32.OAIdl.EXCEPINFO;
 import com.sun.jna.ptr.IntByReference;
 
 /**

File: contrib/platform/src/com/sun/jna/platform/win32/COM/COMUtils.java
Patch:
@@ -1,6 +1,6 @@
 package com.sun.jna.platform.win32.COM;
 
-import com.sun.jna.platform.win32.OaIdl.EXCEPINFO;
+import com.sun.jna.platform.win32.OAIdl.EXCEPINFO;
 import com.sun.jna.platform.win32.WinError;
 import com.sun.jna.platform.win32.WinNT.HRESULT;
 import com.sun.jna.ptr.IntByReference;

File: contrib/platform/test/com/sun/jna/platform/win32/VariantTest.java
Patch:
@@ -21,7 +21,7 @@ public void testVariantClear() {
 		System.out.println("------------------------------------------");
 
 		VARIANT variant = new VARIANT(new SHORT(33333));
-		HRESULT hr = OleAut32.INSTANCE.VariantClear(variant.getPointer());
+		HRESULT hr = OleAuto.INSTANCE.VariantClear(variant.getPointer());
 		
 		assertTrue("hr: " + hr.intValue(), hr.intValue() == 0);
 		
@@ -36,7 +36,7 @@ public void testVariantCopyShort() {
 		VARIANT variantDest = new VARIANT();
 		
 		System.out.println(variantSource.toString(true));
-		HRESULT hr = OleAut32.INSTANCE.VariantCopy(variantDest.getPointer(), variantSource);
+		HRESULT hr = OleAuto.INSTANCE.VariantCopy(variantDest.getPointer(), variantSource);
 		
 		assertTrue("hr: " + hr.intValue(), hr.intValue() == 0);
 
@@ -53,7 +53,7 @@ public void testVariantCopyBoolean() {
 		VARIANT variantDest = new VARIANT();
 		
 		System.out.println(variantSource.toString(true));
-		HRESULT hr = OleAut32.INSTANCE.VariantCopy(variantDest.getPointer(), variantSource);
+		HRESULT hr = OleAuto.INSTANCE.VariantCopy(variantDest.getPointer(), variantSource);
 		
 		assertTrue("hr: " + hr.intValue(), hr.intValue() == 0);
 		

File: contrib/platform/src/com/sun/jna/platform/win32/Guid.java
Patch:
@@ -256,8 +256,6 @@ public static GUID fromString(String guid) {
 		 * Generates a new guid. Code taken from the standard jdk
 		 * implementation (see UUID class).
 		 *
-		 * @param guid
-		 *            the guid
 		 * @return the guid
 		 */
 		public static GUID newGuid() {

File: contrib/platform/src/com/sun/jna/platform/win32/User32.java
Patch:
@@ -1625,15 +1625,15 @@ public LRESULT DefWindowProc(HWND hWnd, int Msg, WPARAM wParam,
 	 * Registers the device or type of device for which a window will receive
 	 * notifications.
 	 * 
-	 * @hRecipient [in] A handle to the window or service that will receive
+	 * @param hRecipient [in] A handle to the window or service that will receive
 	 *             device events for the devices specified in the
 	 *             NotificationFilter parameter. The same window handle can be
 	 *             used in multiple calls to RegisterDeviceNotification.
 	 * 
 	 *             Services can specify either a window handle or service status
 	 *             handle.
 	 * 
-	 * @param NotificationFilter
+	 * @param notificationFilter
 	 *            [in] A pointer to a block of data that specifies the type of
 	 *            device for which notifications should be sent. This block
 	 *            always begins with the DEV_BROADCAST_HDR structure. The data
@@ -1673,7 +1673,7 @@ HDEVNOTIFY RegisterDeviceNotification(HANDLE hRecipient,
 	/**
 	 * Closes the specified device notification handle.
 	 * 
-	 * @Handle [in] Device notification handle returned by the
+	 * @param Handle [in] Device notification handle returned by the
 	 *         RegisterDeviceNotification function.
 	 * 
 	 * @return Return value

File: contrib/platform/src/com/sun/jna/platform/win32/LMAccess.java
Patch:
@@ -411,7 +411,7 @@ public GROUP_INFO_3(Pointer memory) {
         public int grpi3_attributes;
         
         protected List getFieldOrder() {
-            return Arrays.asList(new String[] { "grpi3_name", "grpi3_comment", "grpi3_group_id", "grpi3_attributes" });
+            return Arrays.asList(new String[] { "grpi3_name", "grpi3_comment", "grpi3_group_sid", "grpi3_attributes" });
         }
     }
 	

File: contrib/platform/src/com/sun/jna/platform/win32/OleAut32Util.java
Patch:
@@ -49,7 +49,6 @@ public static VARIANT SafeArrayGetElement(SAFEARRAY array, long index)
 		long[] idx = new long[1];
 		idx[0] = index;
 		VARIANT result = new VARIANT();
-		OleAut32.INSTANCE.VariantInit(result);
 		HRESULT hr = OleAut32.INSTANCE.SafeArrayGetElement(array, idx,
 				result.getPointer());
 		COMUtils.SUCCEEDED(hr);

File: contrib/platform/test/com/sun/jna/platform/win32/OleAut32UtilTest.java
Patch:
@@ -16,6 +16,7 @@
 
 import com.sun.jna.platform.win32.OaIdl.SAFEARRAY;
 import com.sun.jna.platform.win32.Variant.VARIANT;
+import com.sun.jna.platform.win32.WinDef.SHORT;
 import com.sun.jna.platform.win32.COM.COMException;
 
 /**
@@ -28,8 +29,7 @@ public static void main(String[] args) {
 	}
 
 	public void testCreateVarArray() {
-		SAFEARRAY varArray = OleAut32Util
-				.createVarArray(Variant.VT_VARIANT, 10);
+		SAFEARRAY varArray = OleAut32Util.createVarArray(Variant.VT_VARIANT, 1);
 		assertTrue(varArray != null);
 	}
 
@@ -38,7 +38,7 @@ public void testSafeArrayPutGetElement() {
 
 		for (int i = 0; i < 1; i++) {
 			try {
-				VARIANT variant = new VARIANT(i + 3333333);
+				VARIANT variant = new VARIANT(new SHORT(i + 3333));
 				System.out.println(variant.toString(true));
 				OleAut32Util.SafeArrayPutElement(varArray, i, variant);
 			} catch (COMException e) {

File: contrib/platform/test/com/sun/jna/platform/win32/VariantTest.java
Patch:
@@ -2,9 +2,8 @@
 
 import junit.framework.TestCase;
 
-import com.sun.jna.platform.win32.Guid.GUID;
 import com.sun.jna.platform.win32.Variant.VARIANT;
-import com.sun.jna.platform.win32.WinDef.HWND;
+import com.sun.jna.platform.win32.WinDef.SHORT;
 
 public class VariantTest extends TestCase {
 
@@ -16,7 +15,7 @@ public VariantTest() {
 	}
 
 	public void testVariant() {
-		VARIANT variant = new VARIANT(33333);
+		VARIANT variant = new VARIANT(new SHORT(33333));
 		System.out.println(variant.toString(false));
 
 		VARIANT variant2 = new VARIANT(variant.getPointer());

File: contrib/platform/src/com/sun/jna/platform/win32/DsGetDC.java
Patch:
@@ -105,7 +105,7 @@ public DOMAIN_CONTROLLER_INFO(Pointer memory) {
         public WString ClientSiteName;
         
         protected List getFieldOrder() {
-            return Arrays.asList(new String[] { "DomainControllerName", "DomainControllerAddress", "DomainGuid", "DomainName", "DnsForestName", "Flags", "DcSiteName", "ClientSiteName"});
+            return Arrays.asList(new String[] { "DomainControllerName", "DomainControllerAddress", "DomainControllerAddressType", "DomainGuid", "DomainName", "DnsForestName", "Flags", "DcSiteName", "ClientSiteName"});
         }
     }	
 	
@@ -214,6 +214,7 @@ public DS_DOMAIN_TRUSTS() {
 
         public DS_DOMAIN_TRUSTS(Pointer p) {
             super(p);
+            read();
         }
     };
 }

File: contrib/platform/src/com/sun/jna/platform/win32/DsGetDC.java
Patch:
@@ -105,7 +105,7 @@ public DOMAIN_CONTROLLER_INFO(Pointer memory) {
         public WString ClientSiteName;
         
         protected List getFieldOrder() {
-            return Arrays.asList(new String[] { "DomainControllerName", "DomainControllerAddress", "DomainGuid", "DomainName", "DnsForestName", "Flags", "DcSiteName", "ClientSiteName"});
+            return Arrays.asList(new String[] { "DomainControllerName", "DomainControllerAddress", "DomainControllerAddressType", "DomainGuid", "DomainName", "DnsForestName", "Flags", "DcSiteName", "ClientSiteName"});
         }
     }	
 	

File: contrib/platform/src/com/sun/jna/platform/win32/DsGetDC.java
Patch:
@@ -214,6 +214,7 @@ public DS_DOMAIN_TRUSTS() {
 
         public DS_DOMAIN_TRUSTS(Pointer p) {
             super(p);
+            read();
         }
     };
 }

File: src/com/sun/jna/Native.java
Patch:
@@ -770,7 +770,7 @@ private static void loadNativeLibraryFromJar() {
                 unpacked = true;
             }
             catch(IOException e) {
-                throw new Error("Failed to create temporary file for jnidispatch library: " + e);
+                throw new Error("Failed to create temporary file for jnidispatch library", e);
             }
             finally {
                 try { is.close(); } catch(IOException e) { }

File: contrib/platform/src/com/sun/jna/platform/win32/WinDef.java
Patch:
@@ -65,7 +65,7 @@ public DWORD(long value) {
          *  Low WORD.
          */
         public WORD getLow() {
-            return new WORD(longValue() & 0xFF);
+            return new WORD(longValue() & 0xFFFF);
         }
 				
         /**
@@ -74,7 +74,7 @@ public WORD getLow() {
          *  High WORD.
          */
         public WORD getHigh() {
-            return new WORD((longValue() >> 16) & 0xFF);
+            return new WORD((longValue() >> 16) & 0xFFFF);
         }
     }
 

File: src/com/sun/jna/Native.java
Patch:
@@ -1025,7 +1025,7 @@ public static int getNativeSize(Class cls) {
             return POINTER_SIZE;
         }
         throw new IllegalArgumentException("Native size for type \"" + cls.getName() 
-        								   + "\" is unknown");
+                                           + "\" is unknown");
     }
 
     /** Indicate whether the given class is supported as a native argument

File: src/com/sun/jna/Pointer.java
Patch:
@@ -452,6 +452,9 @@ else if (NativeMapped.class.isAssignableFrom(type)) {
             if (nm != null) {
                 Object value = getValue(offset, nm.nativeType(), null);
                 result = nm.fromNative(value, new FromNativeContext(type));
+                if (nm.equals(result)) {
+                    result = nm;
+                }
             }
             else {
                 NativeMappedConverter tc = NativeMappedConverter.getInstance(type);

File: src/com/sun/jna/PointerType.java
Patch:
@@ -98,6 +98,6 @@ public boolean equals(Object o) {
     }
 
     public String toString() {
-        return pointer == null ? "NULL" : pointer.toString();
+        return pointer == null ? "NULL" : pointer.toString() + " (" + super.toString() + ")";
     }
 }

File: src/com/sun/jna/Platform.java
Patch:
@@ -76,7 +76,8 @@ else if (osName.startsWith("OpenBSD")) {
             Class.forName("java.awt.Component");
             hasAWT = true;
         }
-        catch(ClassNotFoundException e) {
+        catch(Throwable t) {
+            // Don't care why
         }
         HAS_AWT = hasAWT;
         boolean hasBuffers = false;

File: test/com/sun/jna/ReturnTypesTest.java
Patch:
@@ -43,7 +43,6 @@ protected List getFieldOrder() {
         
         public static class TestSmallStructure extends Structure {
             public static class ByValue extends TestSmallStructure implements Structure.ByValue { }
-            
             public byte c1;
             public byte c2;
             public short s;
@@ -54,7 +53,6 @@ protected List getFieldOrder() {
 
         public static class TestStructure extends Structure {
             public static class ByValue extends TestStructure implements Structure.ByValue { }
-            
             public byte c;
             public short s;
             public int i;

File: test/com/sun/jna/StructureTest.java
Patch:
@@ -1521,7 +1521,6 @@ public TestByReferenceArrayField(Pointer m) {
             super(m);
             read(); // Important!
         }
-
         public int value1;
         public ByReference[] array = new ByReference[13];
         public int value2;

File: src/com/sun/jna/CallbackReference.java
Patch:
@@ -226,7 +226,6 @@ private CallbackReference(Callback callback, int callingConvention, boolean dire
                                                     callingConvention, flags);
             cbstruct = peer != 0 ? new Pointer(peer) : null;
         }
-
     }
     
     private Class getNativeType(Class cls) {

File: src/com/sun/jna/Structure.java
Patch:
@@ -199,6 +199,7 @@ protected Structure(Pointer p, int alignType) {
     protected Structure(Pointer p, int alignType, TypeMapper mapper) {
         setAlignType(alignType);
         initializeTypeMapper(mapper);
+        validateFields();
         if (p != null) {
             useMemory(p);
         }
@@ -967,10 +968,8 @@ private LayoutInfo deriveLayout(boolean force, boolean avoidFFIType) {
         int calculatedSize = 0;
         List fields = getFields(force);
         if (fields == null) {
-            validateFields();
             return null;
         }
-
         boolean firstField = true;
         for (Iterator i=fields.iterator();i.hasNext();firstField=false) {
             Field field = (Field)i.next();

File: test/com/sun/jna/TypeMapperTest.java
Patch:
@@ -15,6 +15,7 @@
 
 import java.util.HashMap;
 import java.util.Map;
+
 import junit.framework.TestCase;
 
 //@SuppressWarnings("unused")
@@ -133,7 +134,7 @@ public Class nativeType() {
     public static interface StructureTestLibrary extends Library {
         public static class TestStructure extends Structure {
             public TestStructure(TypeMapper mapper) {
-                setTypeMapper(mapper);
+                super(mapper);
             }
             public boolean data;
         }

File: test/com/sun/jna/TypeMapperTest.java
Patch:
@@ -15,6 +15,7 @@
 
 import java.util.HashMap;
 import java.util.Map;
+
 import junit.framework.TestCase;
 
 //@SuppressWarnings("unused")
@@ -133,7 +134,7 @@ public Class nativeType() {
     public static interface StructureTestLibrary extends Library {
         public static class TestStructure extends Structure {
             public TestStructure(TypeMapper mapper) {
-                setTypeMapper(mapper);
+                super(mapper);
             }
             public boolean data;
         }

File: test/com/sun/jna/StructureTest.java
Patch:
@@ -1534,7 +1534,7 @@ class TestStructure extends Structure {
             // Ensure we're not stuffed into a register
             public int p0,p1,p2,p3,p4,p5,p6,p7;
             public TestStructure() {
-                setTypeMapper(mapper);
+                super(mapper);
             }
             { setFieldOrder(new String[] { "b", "s", "p0", "p1", "p2", "p3", "p4", "p5", "p6", "p7" }); }
         }

File: test/com/sun/jna/StructureTest.java
Patch:
@@ -1534,7 +1534,7 @@ class TestStructure extends Structure {
             // Ensure we're not stuffed into a register
             public int p0,p1,p2,p3,p4,p5,p6,p7;
             public TestStructure() {
-                setTypeMapper(mapper);
+                super(mapper);
             }
             { setFieldOrder(new String[] { "b", "s", "p0", "p1", "p2", "p3", "p4", "p5", "p6", "p7" }); }
         }

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32.java
Patch:
@@ -16,7 +16,6 @@
 import com.sun.jna.Pointer;
 import com.sun.jna.Structure;
 import com.sun.jna.platform.win32.DsGetDC.PDOMAIN_CONTROLLER_INFO;
-import com.sun.jna.platform.win32.DsGetDC.PDS_DOMAIN_TRUSTS;
 import com.sun.jna.platform.win32.Guid.GUID;
 import com.sun.jna.platform.win32.NTSecApi.PLSA_FOREST_TRUST_INFORMATION;
 import com.sun.jna.ptr.IntByReference;

File: contrib/platform/test/com/sun/jna/platform/win32/Advapi32UtilTest.java
Patch:
@@ -296,8 +296,9 @@ public void testRegistryGetValues() {
 		Advapi32Util.registrySetStringArray(WinReg.HKEY_CURRENT_USER, "Software\\JNA", "StringArray", stringsWritten);
 		String[] emptyArray = new String[0];
 		Advapi32Util.registrySetStringArray(WinReg.HKEY_CURRENT_USER, "Software\\JNA", "EmptyStringArray", emptyArray);
+		Advapi32Util.registrySetBinaryValue(WinReg.HKEY_CURRENT_USER, "Software\\JNA", "EmptyBinary", new byte[0]);
 		TreeMap<String, Object> values = Advapi32Util.registryGetValues(WinReg.HKEY_CURRENT_USER, "Software\\JNA");
-		assertEquals(6, values.keySet().size());
+		assertEquals(7, values.keySet().size());
 		assertEquals("FourtyTwo" + uu, values.get("42" + uu));
 		assertEquals(42, values.get("FourtyTwo" + uu));
 		assertEquals("%TEMP%", values.get("ExpandableString"));

File: contrib/platform/src/com/sun/jna/platform/unix/X11.java
Patch:
@@ -563,7 +563,7 @@ class XVisualInfo extends Structure {
     }
     class XPoint extends Structure {
         public short x, y;
-        public XPoint() { this(0, 0); }
+        public XPoint() { this((short)0, (short)0); }
         public XPoint(short x, short y) {
             this.x = x;
             this.y = y;
@@ -573,7 +573,7 @@ public XPoint(short x, short y) {
     class XRectangle extends Structure {
         public short x, y;
         public short width, height;
-        public XRectangle() { this(0, 0, 0, 0); }
+        public XRectangle() { this((short)0, (short)0, (short)0, (short)0); }
         public XRectangle(short x, short y, short width, short height) {
             this.x = x; this.y = y;
             this.width = width; this.height = height;

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32Util.java
Patch:
@@ -204,7 +204,7 @@ public static int getDriveType(String rootName) {
 	
 	/**
 	 * Get the value of an environment variable.
-	 * @name
+	 * @param name
 	 * 	Name of the environment variable.
 	 * @return 
 	 *  Value of an environment variable.

File: src/com/sun/jna/Structure.java
Patch:
@@ -374,6 +374,7 @@ public int size() {
     }
 
     public void clear() {
+        ensureAllocated();
         memory.clear(size());
     }
 

File: src/com/sun/jna/Memory.java
Patch:
@@ -105,8 +105,6 @@ public Pointer share(long offset) {
      * the allocated bounds. 
      */
     public Pointer share(long offset, long sz) {
-        if (offset == 0 && sz == getSize())
-            return this;
         boundsCheck(offset, sz);
         return new SharedMemory(offset);
     }

File: src/com/sun/jna/Structure.java
Patch:
@@ -1456,15 +1456,13 @@ private static class FFITypes {
         // From ffi.h
         private static final int FFI_TYPE_STRUCT = 13;
         // Structure fields
-        { setFieldOrder(new String[] { "size", "alignment", "type", "elements" }); }
         public size_t size;
         public short alignment;
         public short type = FFI_TYPE_STRUCT;
         public Pointer elements;
 
         private FFIType(Structure ref) {
             Pointer[] els;
-
             ref.ensureAllocated(true);
 
             if (ref instanceof Union) {
@@ -1494,6 +1492,7 @@ private FFIType(Object array, Class type) {
             init(els);
         }
         private void init(Pointer[] els) {
+            setFieldOrder(new String[] { "size", "alignment", "type", "elements" });
             elements = new Memory(Pointer.SIZE * els.length);
             elements.write(0, els, 0, els.length);
             write();

File: test/com/sun/jna/StructureTest.java
Patch:
@@ -761,12 +761,12 @@ public static class size_t extends IntegerType {
     class FFIType extends Structure {
         public FFIType(Pointer p) {
             super(p); 
+            setFieldOrder(new String[] { "size", "alignment", "type", "elements" });
             // Must explicitly calculate our size field
             Native.initialize_ffi_type(p.peer); 
             read();
         }
-        { setFieldOrder(new String[] { "size", "alignment", "type", "elements" }); }
-        // NOTE: this field is never initialized by libffi
+        // NOTE: this field is not normally initialized by libffi
         public size_t size;
         public short alignment;
         public short type;

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32.java
Patch:
@@ -16,7 +16,6 @@
 import com.sun.jna.Pointer;
 import com.sun.jna.Structure;
 import com.sun.jna.platform.win32.DsGetDC.PDOMAIN_CONTROLLER_INFO;
-import com.sun.jna.platform.win32.DsGetDC.PDS_DOMAIN_TRUSTS;
 import com.sun.jna.platform.win32.Guid.GUID;
 import com.sun.jna.platform.win32.NTSecApi.PLSA_FOREST_TRUST_INFORMATION;
 import com.sun.jna.ptr.IntByReference;

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32.java
Patch:
@@ -388,7 +388,7 @@ public int DsGetForestTrustInformation(String serverName, String trustedDomainNa
 	 * @param Flags
 	 *  Contains a set of flags that determines which domain trusts to enumerate.
 	 * @param Domains
-	 *  Pointer to a PDS_DOMAIN_TRUSTS value that receives an array of DS_DOMAIN_TRUSTS structures. 
+	 *  Receives a pointer which points to an array of DS_DOMAIN_TRUSTS structures. 
 	 *  Each structure in this array contains trust data about a domain. The caller must free this 
 	 *  memory when it is no longer required by calling NetApiBufferFree.
 	 * @param DomainCount
@@ -397,7 +397,7 @@ public int DsGetForestTrustInformation(String serverName, String trustedDomainNa
 	 *  Returns ERROR_SUCCESS if successful or a Win32 error code otherwise.
 	 */
 	public int DsEnumerateDomainTrusts(String serverName, int Flags, 
-			PDS_DOMAIN_TRUSTS.ByReference Domains, IntByReference DomainCount);
+			PointerByReference Domains, IntByReference DomainCount);
 	
 	/**
 	 * The NetUserGetInfo function retrieves information about a particular user account on a server.

File: contrib/platform/src/com/sun/jna/platform/win32/WinDef.java
Patch:
@@ -41,7 +41,7 @@ public WORD() {
         }
 
         public WORD(long value) {
-            super(2, value);
+            super(2, value, true);
         }
     }
 
@@ -371,7 +371,7 @@ public DWORDLONG() {
         }
 
         public DWORDLONG(long value) {
-            super(8, value);
+            super(8, value, true);
         }
     }
 }

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32.java
Patch:
@@ -388,7 +388,7 @@ public int DsGetForestTrustInformation(String serverName, String trustedDomainNa
 	 * @param Flags
 	 *  Contains a set of flags that determines which domain trusts to enumerate.
 	 * @param Domains
-	 *  Pointer to a PDS_DOMAIN_TRUSTS value that receives an array of DS_DOMAIN_TRUSTS structures. 
+	 *  Receives a pointer which points to an array of DS_DOMAIN_TRUSTS structures. 
 	 *  Each structure in this array contains trust data about a domain. The caller must free this 
 	 *  memory when it is no longer required by calling NetApiBufferFree.
 	 * @param DomainCount
@@ -397,7 +397,7 @@ public int DsGetForestTrustInformation(String serverName, String trustedDomainNa
 	 *  Returns ERROR_SUCCESS if successful or a Win32 error code otherwise.
 	 */
 	public int DsEnumerateDomainTrusts(String serverName, int Flags, 
-			PDS_DOMAIN_TRUSTS.ByReference Domains, IntByReference DomainCount);
+			PointerByReference Domains, IntByReference DomainCount);
 	
 	/**
 	 * The NetUserGetInfo function retrieves information about a particular user account on a server.

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32.java
Patch:
@@ -398,8 +398,8 @@ public int DsGetForestTrustInformation(String serverName, String trustedDomainNa
 	 * @return
 	 *  Returns ERROR_SUCCESS if successful or a Win32 error code otherwise.
 	 */
-	public int DsEnumerateDomainTrusts(String serverName, NativeLong Flags, 
-			PDS_DOMAIN_TRUSTS.ByReference Domains, NativeLongByReference DomainCount);
+	public int DsEnumerateDomainTrusts(String serverName, int Flags, 
+			PDS_DOMAIN_TRUSTS.ByReference Domains, IntByReference DomainCount);
 	
 	/**
 	 * The NetUserGetInfo function retrieves information about a particular user account on a server.

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32.java
Patch:
@@ -398,8 +398,8 @@ public int DsGetForestTrustInformation(String serverName, String trustedDomainNa
 	 * @return
 	 *  Returns ERROR_SUCCESS if successful or a Win32 error code otherwise.
 	 */
-	public int DsEnumerateDomainTrusts(String serverName, NativeLong Flags, 
-			PDS_DOMAIN_TRUSTS.ByReference Domains, NativeLongByReference DomainCount);
+	public int DsEnumerateDomainTrusts(String serverName, int Flags, 
+			PDS_DOMAIN_TRUSTS.ByReference Domains, IntByReference DomainCount);
 	
 	/**
 	 * The NetUserGetInfo function retrieves information about a particular user account on a server.

File: test/com/sun/jna/ArgumentsMarshalTest.java
Patch:
@@ -396,6 +396,8 @@ public void testRejectNoncontiguousStructureArrayArgument() {
         }
     }
     
+    /** When passing an array of <code>struct*</code> to native, be sure to
+        invoke <code>Structure.write()</code> on each of the elements. */
     public void testWriteStructureByReferenceArrayArgumentMemory() {
         TestLibrary.CheckFieldAlignment.ByReference[] array = {
             new TestLibrary.CheckFieldAlignment.ByReference(),

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32Util.java
Patch:
@@ -652,7 +652,7 @@ public static DomainTrust[] getDomainTrusts(String serverName) {
             }
             return trusts.toArray(new DomainTrust[0]);
     	} finally {
-            rc = Netapi32.INSTANCE.NetApiBufferFree(domains.getPointer());   	    	
+            rc = Netapi32.INSTANCE.NetApiBufferFree(domains.getPointer().getPointer(0));   	    	
             if(W32Errors.NO_ERROR != rc) {
                 throw new Win32Exception(rc);
             }

File: contrib/platform/src/com/sun/jna/platform/win32/Shell32.java
Patch:
@@ -13,7 +13,6 @@
 package com.sun.jna.platform.win32;
 
 import com.sun.jna.Native;
-import com.sun.jna.platform.win32.ShellAPI.SHFILEOPSTRUCT;
 import com.sun.jna.platform.win32.WinDef.DWORD;
 import com.sun.jna.platform.win32.WinDef.HWND;
 import com.sun.jna.platform.win32.WinNT.HANDLE;

File: contrib/platform/src/com/sun/jna/platform/win32/ShlObj.java
Patch:
@@ -13,7 +13,6 @@
 package com.sun.jna.platform.win32;
 
 import com.sun.jna.platform.win32.WinDef.DWORD;
-import com.sun.jna.win32.StdCallLibrary;
 
 /**
  * Ported from ShlObj.h.

File: contrib/platform/src/com/sun/jna/platform/win32/W32FileMonitor.java
Patch:
@@ -19,11 +19,10 @@
 import java.util.Map;
 
 import com.sun.jna.platform.FileMonitor;
+import com.sun.jna.platform.win32.BaseTSD.ULONG_PTRByReference;
 import com.sun.jna.platform.win32.WinBase.OVERLAPPED;
 import com.sun.jna.platform.win32.WinNT.FILE_NOTIFY_INFORMATION;
 import com.sun.jna.platform.win32.WinNT.HANDLE;
-import com.sun.jna.platform.win32.WinNT.HANDLEByReference;
-import com.sun.jna.platform.win32.BaseTSD.ULONG_PTRByReference;
 import com.sun.jna.ptr.IntByReference;
 import com.sun.jna.ptr.PointerByReference;
 

File: contrib/platform/src/com/sun/jna/platform/win32/WinNT.java
Patch:
@@ -20,11 +20,9 @@
 import com.sun.jna.Structure;
 import com.sun.jna.Union;
 import com.sun.jna.ptr.ByReference;
-import com.sun.jna.ptr.ByteByReference;
 import com.sun.jna.ptr.IntByReference;
 import com.sun.jna.ptr.LongByReference;
 import com.sun.jna.ptr.PointerByReference;
-import com.sun.jna.win32.StdCallLibrary;
 
 /**
  * This module defines the 32-Bit Windows types and constants that are defined

File: contrib/platform/src/com/sun/jna/platform/win32/Winspool.java
Patch:
@@ -16,7 +16,6 @@
 import com.sun.jna.Native;
 import com.sun.jna.Pointer;
 import com.sun.jna.Structure;
-import com.sun.jna.WString;
 import com.sun.jna.platform.win32.WinDef.DWORD;
 import com.sun.jna.ptr.IntByReference;
 import com.sun.jna.win32.StdCallLibrary;

File: contrib/platform/test/com/sun/jna/platform/win32/Netapi32UtilTest.java
Patch:
@@ -17,7 +17,6 @@
 import com.sun.jna.platform.win32.Netapi32Util.DomainController;
 import com.sun.jna.platform.win32.Netapi32Util.DomainTrust;
 import com.sun.jna.platform.win32.Netapi32Util.UserInfo;
-import com.sun.jna.platform.win32.Secur32.EXTENDED_NAME_FORMAT;
 
 /**
  * @author dblock[at]dblock[dot]org

File: contrib/platform/test/com/sun/jna/platform/win32/VersionTest.java
Patch:
@@ -25,17 +25,17 @@ public static void main(String[] args) {
 
     public void testGetFileVersion() {
         String systemRoot = System.getenv("SystemRoot");
-        File notepad = new File(systemRoot + "\\notepad.exe");
+        File explorer = new File(systemRoot + "\\explorer.exe");
 
-        int size = Version.INSTANCE.GetFileVersionInfoSize(notepad.getAbsolutePath(), null);
+        int size = Version.INSTANCE.GetFileVersionInfoSize(explorer.getAbsolutePath(), null);
         assertTrue(size > 0);
 
         Pointer buffer = Kernel32.INSTANCE.LocalAlloc(WinBase.LMEM_ZEROINIT, size);
         assertTrue(!buffer.equals(Pointer.NULL));
 
         try
         {
-            assertTrue(Version.INSTANCE.GetFileVersionInfo(notepad.getAbsolutePath(), 0, size, buffer));
+            assertTrue(Version.INSTANCE.GetFileVersionInfo(explorer.getAbsolutePath(), 0, size, buffer));
 
             IntByReference outputSize = new IntByReference();
             PointerByReference pointer = new PointerByReference();

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32Util.java
Patch:
@@ -196,7 +196,7 @@ public static int getFileType(String fileName) throws FileNotFoundException {
 	}
 
 	/**
-	 * @returns One of the WinBase.DRIVE_* constants.
+	 * @return One of the WinBase.DRIVE_* constants.
 	 */
 	public static int getDriveType(String rootName) {
 	    return Kernel32.INSTANCE.GetDriveType(rootName);

File: contrib/platform/src/com/sun/jna/platform/win32/LMAccess.java
Patch:
@@ -206,7 +206,7 @@ public USER_INFO_23(Pointer memory) {
          * A pointer to a SID structure that contains the security identifier (SID) 
          * that uniquely identifies the user. The NetUserAdd and NetUserSetInfo functions ignore this member.
          */
-        public PSID   usri23_user_sid;		
+        public PSID.ByReference   usri23_user_sid;		
     }	
 	
     /**
@@ -362,7 +362,7 @@ public GROUP_INFO_3(Pointer memory) {
          * Pointer to a SID structure that contains the security identifier (SID) that 
          * uniquely identifies the global group.
          */
-        public PSID grpi3_group_sid;
+        public PSID.ByReference grpi3_group_sid;
         /**
          * These attributes are hard-coded to SE_GROUP_MANDATORY, SE_GROUP_ENABLED, and 
          * SE_GROUP_ENABLED_BY_DEFAULT.

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32Util.java
Patch:
@@ -632,7 +632,7 @@ public static UserInfo getUserInfo(String accountName, String domainName) {
         PointerByReference bufptr = new PointerByReference();
         int rc = -1;
         try {
-            rc = Netapi32.INSTANCE.NetUserGetInfo(Netapi32Util.getDCName(), accountName, (short)23, bufptr);
+            rc = Netapi32.INSTANCE.NetUserGetInfo(domainName, accountName, (short)23, bufptr);
             if (rc == LMErr.NERR_Success) {
                 USER_INFO_23 info_23 = new USER_INFO_23(bufptr.getValue());
                 UserInfo userInfo = new UserInfo();

File: contrib/platform/src/com/sun/jna/platform/win32/LMAccess.java
Patch:
@@ -206,7 +206,7 @@ public USER_INFO_23(Pointer memory) {
          * A pointer to a SID structure that contains the security identifier (SID) 
          * that uniquely identifies the user. The NetUserAdd and NetUserSetInfo functions ignore this member.
          */
-        public PSID   usri23_user_sid;		
+        public PSID.ByReference   usri23_user_sid;		
     }	
 	
     /**
@@ -362,7 +362,7 @@ public GROUP_INFO_3(Pointer memory) {
          * Pointer to a SID structure that contains the security identifier (SID) that 
          * uniquely identifies the global group.
          */
-        public PSID grpi3_group_sid;
+        public PSID.ByReference grpi3_group_sid;
         /**
          * These attributes are hard-coded to SE_GROUP_MANDATORY, SE_GROUP_ENABLED, and 
          * SE_GROUP_ENABLED_BY_DEFAULT.

File: contrib/platform/src/com/sun/jna/platform/win32/Netapi32Util.java
Patch:
@@ -632,7 +632,7 @@ public static UserInfo getUserInfo(String accountName, String domainName) {
         PointerByReference bufptr = new PointerByReference();
         int rc = -1;
         try {
-            rc = Netapi32.INSTANCE.NetUserGetInfo(Netapi32Util.getDCName(), accountName, (short)23, bufptr);
+            rc = Netapi32.INSTANCE.NetUserGetInfo(domainName, accountName, (short)23, bufptr);
             if (rc == LMErr.NERR_Success) {
                 USER_INFO_23 info_23 = new USER_INFO_23(bufptr.getValue());
                 UserInfo userInfo = new UserInfo();

File: src/com/sun/jna/Structure.java
Patch:
@@ -849,7 +849,7 @@ int calculateSize(boolean force, boolean avoidFFIType) {
     /** Keep track of structure layout information.  Alignment type, type
         mapper, and explicit field order will affect this information.
     */
-    private class LayoutInfo {
+    private static class LayoutInfo {
         int size = CALCULATE_SIZE;
         int alignment = 1;
         Map fields = Collections.synchronizedMap(new LinkedHashMap());
@@ -1546,7 +1546,7 @@ private static Pointer get(Object obj, Class cls) {
         }
     }
 
-    private class AutoAllocated extends Memory {
+    private static class AutoAllocated extends Memory {
         public AutoAllocated(int size) {
             super(size);
             // Always clear new structure memory

File: src/com/sun/jna/Structure.java
Patch:
@@ -1375,7 +1375,7 @@ public static Structure newInstance(Class type) throws IllegalArgumentException
         }
     }
 
-    class StructField extends Object {
+    static class StructField extends Object {
         public String name;
         public Class type;
         public Field field;

File: src/com/sun/jna/Structure.java
Patch:
@@ -1285,7 +1285,7 @@ protected void cacheTypeInfo(Pointer p) {
     }
 
     /** Override to supply native type information for the given field. */
-    protected Pointer getFieldTypeInfo(StructField f) {
+    Pointer getFieldTypeInfo(StructField f) {
         Class type = f.type;
         Object value = getField(f);
         if (typeMapper != null) {

File: src/com/sun/jna/Native.java
Patch:
@@ -908,7 +908,7 @@ static void markTemporaryFile(File file) {
 
     static File getTempDir() {
         File tmp = new File(System.getProperty("java.io.tmpdir"));
-        File jnatmp = new File(tmp, "jna");
+        File jnatmp = new File(tmp, "jna-" + System.getProperty("user.name"));
         jnatmp.mkdirs();
         return jnatmp.exists() ? jnatmp : tmp;
     }

File: contrib/platform/test/com/sun/jna/platform/win32/User32Test.java
Patch:
@@ -98,8 +98,7 @@ public void testGetLastInputInfo() throws Exception {
         LASTINPUTINFO plii = new LASTINPUTINFO();
         assertEquals(plii.size(), plii.cbSize);
 
-        boolean flag = User32.INSTANCE.GetLastInputInfo(plii);
-        assertTrue(flag);
+        assertTrue(User32.INSTANCE.GetLastInputInfo(plii));
         assertTrue(Kernel32.INSTANCE.GetTickCount() >= plii.dwTime);
         assertTrue(plii.dwTime > 0);
     }

File: contrib/platform/src/com/sun/jna/platform/win32/WinDef.java
Patch:
@@ -54,7 +54,7 @@ public DWORD() {
         }
 
         public DWORD(long value) {
-            super(4, value);
+            super(4, value, true);
         }
 		
         /**

File: contrib/platform/src/com/sun/jna/platform/win32/Advapi32Util.java
Patch:
@@ -464,6 +464,7 @@ public static boolean registryValueExists(HKEY root, String key, String value) {
 		    phkKey.getValue(), value, 0, lpType, (char[]) null, lpcbData);
 	    switch(rc) {
 	    case W32Errors.ERROR_SUCCESS:
+	    case W32Errors.ERROR_MORE_DATA:
 	    case W32Errors.ERROR_INSUFFICIENT_BUFFER:
 		return true;
 	    case W32Errors.ERROR_FILE_NOT_FOUND:

File: src/com/sun/jna/Structure.java
Patch:
@@ -64,7 +64,8 @@
  * <p>
  * NOTE: This class assumes that fields are returned in {@link Class#getFields}
  * in the same or reverse order as declared.  If your VM returns them in
- * no particular order, you're out of luck.
+ * no particular order, you need to explicitly indicate the order with {@link
+ * #setFieldOrder} in your subclass constructor.
  * <p/>
  * NOTE: In general, instances of this class are <em>not</em> synchronized.
  * <p/>

File: contrib/platform/src/com/sun/jna/platform/win32/Advapi32.java
Patch:
@@ -1179,7 +1179,7 @@ public boolean LookupPrivilegeValue(
 	 *   A pointer to the variable that receives the number of bytes necessary to store the complete security descriptor. 
 	 *   If the returned number of bytes is less than or equal to nLength, the entire security descriptor is returned in the output buffer; 
 	 *   otherwise, none of the descriptor is returned.
-	 * @return
+	 * @return whether the call succeeded
 	 */
 	public boolean GetFileSecurity(
 	    WString lpFileName,

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32.java
Patch:
@@ -29,10 +29,10 @@
 import java.nio.Buffer;
 
 /** Interface definitions for <code>kernel32.dll</code>.
- * Includes additional alternate mappings from {@link WinBase} which make use
+ * Includes additional alternate mappings from {@link WinNT} which make use
  * of NIO buffers.
  */
-public interface Kernel32 extends StdCallLibrary, WinBase {
+public interface Kernel32 extends WinNT {
 
     Kernel32 INSTANCE = (Kernel32) Native.loadLibrary("kernel32", Kernel32.class, 
     		W32APIOptions.UNICODE_OPTIONS);

File: contrib/platform/src/com/sun/jna/platform/win32/W32Errors.java
Patch:
@@ -84,7 +84,7 @@ public static final int MAKE_SCODE(short sev, short fac, short code) {
      * Map a WIN32 error value into a HRESULT
      * Note: This assumes that WIN32 errors fall in the range -32k to=32k.
      * @param x original w32 error code
-     * @return
+     * @return the converted value
      */
     public static final HRESULT HRESULT_FROM_WIN32(int x) {
         int f = FACILITY_WIN32;

File: contrib/platform/src/com/sun/jna/platform/win32/W32FileMonitor.java
Patch:
@@ -23,6 +23,7 @@
 import com.sun.jna.platform.win32.WinNT.FILE_NOTIFY_INFORMATION;
 import com.sun.jna.platform.win32.WinNT.HANDLE;
 import com.sun.jna.platform.win32.WinNT.HANDLEByReference;
+import com.sun.jna.platform.win32.BaseTSD.ULONG_PTRByReference;
 import com.sun.jna.ptr.IntByReference;
 import com.sun.jna.ptr.PointerByReference;
 
@@ -111,7 +112,7 @@ private void handleChanges(FileInfo finfo) throws IOException {
     private FileInfo waitForChange() {
         Kernel32 klib = Kernel32.INSTANCE;
         IntByReference rcount = new IntByReference();
-        HANDLEByReference rkey = new HANDLEByReference();
+        ULONG_PTRByReference rkey = new ULONG_PTRByReference();
         PointerByReference roverlap = new PointerByReference();
         klib.GetQueuedCompletionStatus(port, rcount, rkey, roverlap, WinBase.INFINITE);
         

File: contrib/platform/src/com/sun/jna/platform/wince/CoreDLL.java
Patch:
@@ -14,12 +14,13 @@
 
 import com.sun.jna.Native;
 import com.sun.jna.win32.W32APIOptions;
-import com.sun.jna.platform.win32.Kernel32;
+import com.sun.jna.win32.StdCallLibrary;
+import com.sun.jna.platform.win32.WinNT;
 
 /** Definition <code>coredll.dll</code>.
     Add other win32 interface mappings as needed.
  */
-public interface CoreDLL extends WinBase, StdCallLibrary {
+public interface CoreDLL extends WinNT {
 
     CoreDLL INSTANCE = (CoreDLL)
         Native.loadLibrary("coredll", CoreDLL.class, 

File: contrib/platform/src/com/sun/jna/platform/win32/ShellAPI.java
Patch:
@@ -12,6 +12,7 @@
  */
 package com.sun.jna.platform.win32;
 
+import com.sun.jna.Platform;
 import com.sun.jna.Pointer;
 import com.sun.jna.Structure;
 import com.sun.jna.WString;
@@ -25,7 +26,7 @@
  */
 public interface ShellAPI extends StdCallLibrary {
 
-    int STRUCTURE_ALIGNMENT = Structure.ALIGN_NONE;
+    int STRUCTURE_ALIGNMENT = Platform.is64Bit() ? Structure.ALIGN_DEFAULT : Structure.ALIGN_NONE;
 	
     int FO_MOVE = 0x0001;
     int FO_COPY = 0x0002;

File: contrib/platform/src/com/sun/jna/platform/win32/W32FileUtils.java
Patch:
@@ -36,7 +36,7 @@ public void moveToTrash(File[] files) throws IOException {
         fileop.fFlags = ShellAPI.FOF_ALLOWUNDO|ShellAPI.FOF_NO_UI;
         int ret = shell.SHFileOperation(fileop);
         if (ret != 0) {
-            throw new IOException("Move to trash failed: " + 
+            throw new IOException("Move to trash failed: " + fileop.pFrom + ": " + 
                                   Kernel32Util.formatMessageFromLastErrorCode(ret));
         }
         if (fileop.fAnyOperationsAborted) {

File: contrib/platform/test/com/sun/jna/platform/FileUtilsTest.java
Patch:
@@ -34,7 +34,7 @@ public void testMoveToTrash() throws Exception {
             catch(IOException e) {
                 fail(e.toString());
             }
-            assertFalse("Failed to move " + file + " to trash", file.exists());
+            assertFalse("File still exists after move to trash: " + file, file.exists());
         }
         finally {
             if (file.exists()) {

File: src/com/sun/jna/Union.java
Patch:
@@ -148,7 +148,6 @@ public Object getTypedValue(Class type) {
      * @return this Union object
      */
     public Object setTypedValue(Object object) {
-        ensureAllocated();
         StructField f = findField(object.getClass());
         if (f != null) {
             activeField = f;
@@ -164,6 +163,7 @@ public Object setTypedValue(Object object) {
      * @return StructField of matching type
      */
     private StructField findField(Class type) {
+        ensureAllocated();
         for (Iterator i=fields().values().iterator();i.hasNext();) {
             StructField f = (StructField)i.next();
             if (f.type.isAssignableFrom(type)) {
@@ -222,7 +222,7 @@ int calculateSize(boolean force, boolean avoidFFIType) {
             size = calculateAlignedSize(fsize);
             if (size > 0) {
                 // Update native FFI type information, if needed
-                if (this instanceof ByValue) {
+                if (this instanceof ByValue && !avoidFFIType) {
                     getTypeInfo();
                 }
             }

File: test/com/sun/jna/UnionTest.java
Patch:
@@ -92,6 +92,7 @@ public void testReadUnion() {
         assertTrue("short field not read", u.shortField != 0);
         assertTrue("long field not read", u.longField != 0);
         assertNotNull("Unselected Pointer not read", u.pointer);
+        assertNotNull("Union struct field should be initialized", u.structField);
         assertNull("Unselected structure should not be read", u.structField.value);
         assertNull("Unselected String should be null", u.string);
         assertNull("Unselected WString should be null", u.wstring);

File: contrib/platform/src/com/sun/jna/platform/win32/Kernel32Util.java
Patch:
@@ -10,7 +10,7 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.  
  */
-package com.sun.jna.platform.win32;
+package com.sun.jna.platform.win32;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -64,9 +64,8 @@ public static String formatMessageFromHR(HRESULT code) {
         	throw new LastErrorException(Kernel32.INSTANCE.GetLastError());
         }	       
     	String s = buffer.getValue().getString(0, ! Boolean.getBoolean("w32.ascii"));
-    	s = s.replace(".\r",".").replace(".\n",".");
     	Kernel32.INSTANCE.LocalFree(buffer.getValue());
-    	return s;		
+    	return s.trim();		
 	}
 	
 	/**

File: contrib/platform/test/com/sun/jna/platform/win32/User32Test.java
Patch:
@@ -37,7 +37,7 @@ public void testRegisterHotKey() {
         int vk = KeyEvent.VK_D;
         int id = 1;
 
-        assertTrue(INSTANCE.RegisterHotKey(null, id, WinUser.MOD_CONTROL | WinUser.MOD_ALT, vk));
+        assertTrue("RegisterHotKey failed", INSTANCE.RegisterHotKey(null, id, WinUser.MOD_CONTROL | WinUser.MOD_ALT, vk));
 
         Robot robot = null;
         try {

File: test/com/sun/jna/StructureTest.java
Patch:
@@ -1278,7 +1278,7 @@ public Class nativeType() {
                             return byte.class;
                         }
                         public Object fromNative(Object nativeValue, FromNativeContext context) {
-                            return nativeValue.equals((byte)0)
+                            return nativeValue.equals(new Byte((byte)0))
                                 ? Boolean.FALSE : Boolean.TRUE;
                         }
                     };

File: src/com/sun/jna/Native.java
Patch:
@@ -1458,7 +1458,9 @@ private static Object fromNative(FromNativeConverter cvt, Object o, Class cls) {
         return cvt.fromNative(o, new FromNativeContext(cls));
     }
 
+    /** Create a new cif structure. */
     public static native long ffi_prep_cif(int abi, int nargs, long ffi_return_type, long ffi_types);
+    /** Make an FFI function call. */
     public static native void ffi_call(long cif, long fptr, long resp, long args);
     public static native long ffi_prep_closure(long cif, ffi_callback cb);
     public static native void ffi_free_closure(long closure);

File: src/com/sun/jna/NativeString.java
Patch:
@@ -78,7 +78,9 @@ public boolean equals(Object other) {
     }
 
     public String toString() {
-        return pointer.getString(0, wide);
+        String s = wide ? "const wchar_t*" : "const char*";
+        s += "(" + pointer.getString(0, wide) + ")";
+        return s;
     }
 
     public Pointer getPointer() {

File: test/com/sun/jna/NativeLibraryTest.java
Patch:
@@ -38,10 +38,11 @@ public void testGCNativeLibrary() throws Exception {
         assertNull("Library not GC'd", ref.get());
     }
 
-    // wce fail
     public void testAvoidDuplicateLoads() {
+        NativeLibrary.disposeAll();
+
         TestLibrary lib = (TestLibrary)Native.loadLibrary("testlib", TestLibrary.class);
-        assertEquals("Library should be loaded exactly once",
+        assertEquals("Library should be newly loaded after all others disposed",
                      1, lib.callCount());
         if (lib.callCount() <= 1) {
             fail("Library should not be reloaded");

File: test/com/sun/jna/ArgumentsMarshalTest.java
Patch:
@@ -545,8 +545,7 @@ public void testDisableAutoSynch() {
         assertEquals("Auto read should be disabled", EXPECTED, s.field);
     }
 
-    // w32ce crash
-    public void XFAIL_WCE_testUnionByValueCallbackArgument() throws Exception{ 
+    public void testUnionByValueCallbackArgument() throws Exception{ 
         TestLibrary.TestUnion arg = new TestLibrary.TestUnion();
         arg.setType(String.class);
         final String VALUE = getName();

File: test/com/sun/jna/CallbacksTest.java
Patch:
@@ -546,7 +546,7 @@ public String callback(String arg) {
         assertEquals("Wrong String return", VALUE, value);
     }
     
-    public void XFAIL_WCE_testStringCallbackMemoryReclamation() throws InterruptedException {
+    public void testStringCallbackMemoryReclamation() throws InterruptedException {
         TestLibrary.StringCallback cb = new TestLibrary.StringCallback() {
             public String callback(String arg) {
                 return arg;
@@ -623,8 +623,7 @@ public int callback(int arg, IntByReference result) {
         assertEquals("Wrong value in by reference memory", VALUE, ref.getValue());
     }
     
-    // crash
-    public void XFAIL_WCE_testCallCallbackWithStructByValue() {
+    public void testCallCallbackWithStructByValue() {
         final TestStructure.ByValue s = new TestStructure.ByValue();
         final TestStructure innerResult = new TestStructure();
         TestStructure.TestCallback cb = new TestStructure.TestCallback() {

File: test/com/sun/jna/ReturnTypesTest.java
Patch:
@@ -227,8 +227,7 @@ public void testInvokeNullStructure() {
         assertNull("Expect null structure return", s);
     }
     
-    // w32ce crash
-    public void XFAIL_WCE_testReturnSmallStructureByValue() {
+    public void testReturnSmallStructureByValue() {
         TestSmallStructure s = lib.returnSmallStructureByValue();
         assertNotNull("Returned structure must not be null", s);
         assertEquals("Wrong char field value (1)", 1, s.c1);

File: test/com/sun/jna/StructureTest.java
Patch:
@@ -852,7 +852,7 @@ private ROStructure avoidConstantFieldOptimization(ROStructure s) {
         return s;
     }
 
-    // This functionality is no longer supported
+    // wce/phoneME fails to write final field
     public void testReadOnlyField() {
         ROStructure s = new ROStructure();
         s.getPointer().setInt(0, 42);

File: test/com/sun/jna/DirectArgumentsMarshalTest.java
Patch:
@@ -50,7 +50,7 @@ public static class DirectTestLibrary implements TestLibrary {
         public native long checkInt64ArgumentAlignment(int i, long j, int i2, long j2);
         public native double checkDoubleArgumentAlignment(float i, double j, float i2, double j2);
         public native Pointer testStructurePointerArgument(CheckFieldAlignment p);
-        public native double testStructureByValueArgument(CheckFieldAlignment.ByValue p);
+        public native int testStructureByValueArgument(CheckFieldAlignment.ByValue p);
         public int testStructureArrayInitialization(CheckFieldAlignment[] p, int len) {
             throw new UnsupportedOperationException();
         }

File: contrib/balloontips/com/sun/jna/contrib/demo/FilteredTextField.java
Patch:
@@ -8,6 +8,7 @@
 
 import javax.swing.BorderFactory;
 import javax.swing.JFrame;
+import javax.swing.JLabel;
 import javax.swing.JPanel;
 import javax.swing.JTextField;
 import javax.swing.Popup;

File: src/com/sun/jna/Native.java
Patch:
@@ -144,6 +144,7 @@ public void uncaughtException(Callback c, Throwable e) {
                             + " - set the system property jna.nosys=true" + LS
                             + " - set jna.boot.library.path to include the path to the version of the " + LS + "   jnidispatch library included with the JNA jar file you are using" + LS);
         }
+        setPreserveLastError(Boolean.parseBoolean(System.getProperty("jna.preserve_last_error", "true")));
     }
     
     /** Force a dispose when this class is GC'd. */

File: test/com/sun/jna/LastErrorTest.java
Patch:
@@ -63,7 +63,7 @@ public void testThrowLastError() {
     }
 
     // wce setlasterror doesn't persist
-    public void XFAIL_WCE_testThrowLastErrorDirect() {
+    public void testThrowLastErrorDirect() {
         TestLibrary lib = new DirectTestLibrary();
 
         final int ERROR = -1;

File: test/com/sun/jna/ArgumentsMarshalTest.java
Patch:
@@ -418,8 +418,7 @@ public void testIntArrayArgument() {
         }
     }
     
-    // crash
-    public void XFAIL_WCE_testLongArrayArgument() { 
+    public void testLongArrayArgument() { 
         long[] buf = new long[1024];
         final long MAGIC = 0x1234567887654321L;
         assertEquals("Wrong return value", buf.length, 
@@ -540,7 +539,7 @@ public void testDisableAutoSynch() {
         assertEquals("Auto read should be disabled", EXPECTED, s.field);
     }
 
-    // crash
+    // w32ce crash
     public void XFAIL_WCE_testUnionByValueCallbackArgument() throws Exception{ 
         TestLibrary.TestUnion arg = new TestLibrary.TestUnion();
         arg.setType(String.class);

File: test/com/sun/jna/CallbacksTest.java
Patch:
@@ -293,7 +293,7 @@ public int callback(int arg, int arg2) {
         assertEquals("Wrong callback return", -3, value);
     }
     
-    public void XFAIL_WCE_testCallInt64Callback() {
+    public void testCallInt64Callback() {
         final long MAGIC = 0x1111111111111111L;
         final boolean[] called = { false };
         TestLibrary.Int64Callback cb = new TestLibrary.Int64Callback() {
@@ -334,7 +334,7 @@ public float callback(float arg, float arg2) {
         assertEquals("Wrong callback return", -3f, value, 0);
     }
     
-    public void XFAIL_WCE_testCallDoubleCallback() {
+    public void testCallDoubleCallback() {
         final boolean[] called = { false };
         final double[] args = { 0, 0 };
         TestLibrary.DoubleCallback cb = new TestLibrary.DoubleCallback() {

File: test/com/sun/jna/ReturnTypesTest.java
Patch:
@@ -227,7 +227,7 @@ public void testInvokeNullStructure() {
         assertNull("Expect null structure return", s);
     }
     
-    // crash
+    // w32ce crash
     public void XFAIL_WCE_testReturnSmallStructureByValue() {
         TestSmallStructure s = lib.returnSmallStructureByValue();
         assertNotNull("Returned structure must not be null", s);

File: src/com/sun/jna/Native.java
Patch:
@@ -676,7 +676,7 @@ private static void loadNativeLibrary() {
                         nativeLibraryPath = path;
                         return;
                     } catch (UnsatisfiedLinkError ex) {
-                        ex.printStackTrace();
+                        System.err.println("File found at " + file + " but not loadable: " + ex.getMessage());
                     }
                 }
                 if (Platform.isMac()) {
@@ -695,6 +695,7 @@ private static void loadNativeLibrary() {
                             nativeLibraryPath = path;
                             return;
                         } catch (UnsatisfiedLinkError ex) {
+                            System.err.println("File found at " + path + " but not loadable: " + ex.getMessage());
                         }
                     }
                 }

File: test/com/sun/jna/CallbacksTest.java
Patch:
@@ -155,7 +155,6 @@ class CbStruct extends Structure {
 
     TestLibrary lib;
     protected void setUp() {
-        System.out.println("test: " + getName());
         lib = (TestLibrary)Native.loadLibrary("testlib", TestLibrary.class);
     }
     

File: test/com/sun/jna/ReturnTypesTest.java
Patch:
@@ -90,7 +90,6 @@ class TestObject { }
 
     TestLibrary lib;
     protected void setUp() {
-        System.out.println("test: " + getName());
         lib = (TestLibrary)Native.loadLibrary("testlib", TestLibrary.class);
     }
     

File: src/com/sun/jna/Platform.java
Patch:
@@ -69,6 +69,7 @@ public static final boolean isLinux() {
     public static final boolean isWindowsCE() {
         return osType == WINDOWSCE;
     }
+    /** Returns true for any windows variant. */
     public static final boolean isWindows() {
         return osType == WINDOWS || osType == WINDOWSCE;
     }

File: test/com/sun/jna/NativeLibraryTest.java
Patch:
@@ -183,7 +183,7 @@ public void testParseVersion() throws Exception {
     	}
     }
     
-    public void XFAIL_WCE_testGetProcess() {
+    public void testGetProcess() {
         NativeLibrary process = NativeLibrary.getProcess();
         // Access a common C library function
         process.getFunction("printf");

File: src/com/sun/jna/NativeLibrary.java
Patch:
@@ -120,7 +120,6 @@ private static NativeLibrary loadLibrary(String libraryName, Map options) {
         // name if it cannot find the library.
         //
         try {
-            System.out.println("Attempt " + libraryPath);
             handle = Native.open(libraryPath);
         }
         catch(UnsatisfiedLinkError e) {
@@ -130,7 +129,6 @@ private static NativeLibrary loadLibrary(String libraryName, Map options) {
         try {
             if (handle == 0) {
                 libraryPath = findLibraryPath(libraryName, searchPath);
-                System.out.println("Attempt " + libraryPath);
                 handle = Native.open(libraryPath);
                 if (handle == 0) {
                     throw new UnsatisfiedLinkError("Failed to load library '" + libraryName + "'");

File: test/com/sun/jna/DirectTest.java
Patch:
@@ -232,7 +232,7 @@ public static void checkPerformance() {
         }
         else {
             b.putLong(0, Structure.FFIType.get(double.class).peer);
-            cif = Native.ffi_prep_cif(0, 1, Structure.FFIType.get(double.class).peer, types);
+            cif = Native.ffi_prep_cif(1, 1, Structure.FFIType.get(double.class).peer, types);
             resp = pb.peer + 8;
             argv = pb.peer + 16;
             double INPUT = 42;

File: test/com/sun/jna/ArgumentsMarshalTest.java
Patch:
@@ -341,7 +341,7 @@ public void testStructurePointerArgument() {
     public void testStructureByValueArgument() {
         TestLibrary.CheckFieldAlignment.ByValue struct = 
             new TestLibrary.CheckFieldAlignment.ByValue();
-        assertEquals("Wrong sum of fields", 
+        assertEquals("Wrong sum of fields for " + struct.toString(true),
                      21d, lib.testStructureByValueArgument(struct));
     }
     

File: test/com/sun/jna/StructureTest.java
Patch:
@@ -108,8 +108,7 @@ class TestStructure extends Structure {
         }
         TestStructure s = new TestStructure();
         s.setAlignType(Structure.ALIGN_GNUC);
-        boolean isSPARC = "sparc".equals(System.getProperty("os.arch"));
-        final int SIZE = NativeLong.SIZE == 4 && !isSPARC ? 28 : 32;
+        final int SIZE = Structure.MAX_GNUC_ALIGNMENT == 8 ? 32 : 28;
         assertEquals("Wrong structure size", SIZE, s.size());
     }
 
@@ -171,7 +170,7 @@ private void testStructureSize(int index) {
             SizeTest lib = (SizeTest)Native.loadLibrary("testlib", SizeTest.class);
             Class cls = Class.forName(getClass().getName() + "$TestStructure" + index);
             Structure s = Structure.newInstance(cls);
-            assertEquals("Incorrect size: " + s, lib.getStructureSize(index), s.size());
+            assertEquals("Incorrect size for structure " + index + "=>" + s.toString(true), lib.getStructureSize(index), s.size());
         }
         catch(Exception e) {
             throw new Error(e);

File: jnalib/contrib/platform/src/com/sun/jna/platform/win32/Kernel32.java
Patch:
@@ -28,6 +28,7 @@
 import com.sun.jna.platform.win32.structures.STARTUPINFO;
 import com.sun.jna.ptr.ByReference;
 import com.sun.jna.ptr.IntByReference;
+import com.sun.jna.ptr.LongByReference;
 import com.sun.jna.ptr.PointerByReference;
 import com.sun.jna.win32.StdCallLibrary;
 import com.sun.jna.win32.W32APIOptions;
@@ -940,8 +941,8 @@ Pointer MapViewOfFile(HANDLE hFileMappingObject, int dwDesiredAccess,
      *   A pointer to a PROCESS_INFORMATION structure that receives identification information about the new process.
      * @return If the function succeeds, the return value is nonzero.
      */
-    boolean CreateProcess(String lpApplicationName, String lpCommandLine, SECURITY_ATTRIBUTES lpProcessAttributes,
-                          SECURITY_ATTRIBUTES lpThreadAttributes, boolean bInheritHandles, DWORD dwCreationFlags,
+    boolean CreateProcess(String lpApplicationName, String lpCommandLine, WinBase.SECURITY_ATTRIBUTES lpProcessAttributes,
+                          WinBase.SECURITY_ATTRIBUTES lpThreadAttributes, boolean bInheritHandles, DWORD dwCreationFlags,
                           Pointer lpEnvironment, String lpCurrentDirectory, STARTUPINFO lpStartupInfo,
                           PROCESS_INFORMATION.ByReference lpProcessInformation);
 

File: jnalib/contrib/platform/src/com/sun/jna/platform/win32/User32.java
Patch:
@@ -15,6 +15,7 @@
 import com.sun.jna.Native;
 import com.sun.jna.Pointer;
 import com.sun.jna.platform.win32.BaseTSD.LONG_PTR;
+import com.sun.jna.platform.win32.WinDef.DWORD;
 import com.sun.jna.platform.win32.WinDef.HDC;
 import com.sun.jna.platform.win32.WinDef.HICON;
 import com.sun.jna.platform.win32.WinDef.HINSTANCE;

File: jnalib/contrib/platform/src/com/sun/jna/platform/win32/WinBase.java
Patch:
@@ -521,8 +521,7 @@ public MEMORYSTATUSEX() {
 	 * object and specifies whether the handle retrieved by specifying this
 	 * structure is inheritable. This structure provides security settings for
 	 * objects created by various functions, such as {@link Kernel32#CreateFile},
-	 * {@link Kernel32#CreatePipe}, {@link Kernel32#CreateProcess},
-	 * {@link Advapi32#RegCreateKeyEx}, or {@link Advapi32#RegSaveKeyEx}.
+	 * {@link Kernel32#CreatePipe}, or {@link Advapi32#RegCreateKeyEx}.
 	 */
     public static class SECURITY_ATTRIBUTES extends Structure {
     	/**

File: jnalib/src/com/sun/jna/Native.java
Patch:
@@ -1573,7 +1573,6 @@ private static native void invokeStructure(long fp, int callFlags,
      * @param fp function pointer
      * @param   callFlags calling convention to be used
      * @param   args Arguments to pass to the native function
-     * @param   result Pre-allocated structure to hold the result
      * @return the passed-in Structure
      */
     static Structure invokeStructure(long fp, int callFlags, Object[] args,

File: jnalib/contrib/platform/src/com/sun/jna/platform/win32/Netapi32Util.java
Patch:
@@ -449,7 +449,7 @@ public static DomainController getDC() {
     	dc.domainName = pdci.dci.DomainName.toString();
     	dc.flags = pdci.dci.Flags;
     	dc.name = pdci.dci.DomainControllerName.toString();
-		rc = Netapi32.INSTANCE.NetApiBufferFree(pdci.getPointer());
+		rc = Netapi32.INSTANCE.NetApiBufferFree(pdci.dci.getPointer());
 		if (LMErr.NERR_Success != rc) {
 			throw new Win32Exception(rc);
 		}

File: jnalib/src/com/sun/jna/Pointer.java
Patch:
@@ -504,6 +504,7 @@ else if (type.isArray()) {
         return result;
     }
 
+    /** Copy memory starting at offset into the array with element type cls. */
     private void getArrayValue(long offset, Object o, Class cls) {
         int length = 0;
         length = Array.getLength(o);

File: jnalib/contrib/platform/src/com/sun/jna/platform/win32/Advapi32Util.java
Patch:
@@ -966,7 +966,7 @@ public static void registrySetBinaryValue(HKEY hKey, String name, byte[] data) {
 	 *  Path to an existing registry key.
 	 * @param name
 	 *  Value name.
-	 * @param value
+	 * @param data
 	 *  Data to write to registry.
 	 */
 	public static void registrySetBinaryValue(HKEY root, String keyPath, String name, byte[] data) {

File: jnalib/contrib/platform/test/com/sun/jna/platform/win32/Advapi32Test.java
Patch:
@@ -675,7 +675,7 @@ public void testStartService() {
     	SC_HANDLE scmHandle = Advapi32.INSTANCE.OpenSCManager(null, null, Winsvc.SC_MANAGER_CONNECT);
     	assertNotNull(scmHandle);
     	
-    	SC_HANDLE serviceHandle = Advapi32.INSTANCE.OpenService(scmHandle, "Wecsvc", Winsvc.SERVICE_QUERY_CONFIG);
+    	SC_HANDLE serviceHandle = Advapi32.INSTANCE.OpenService(scmHandle, "eventlog", Winsvc.SERVICE_QUERY_CONFIG);
     	assertNotNull(serviceHandle);
     	
     	assertFalse(Advapi32.INSTANCE.StartService(serviceHandle, 0, null));

File: jnalib/contrib/platform/test/com/sun/jna/platform/win32/WinspoolTest.java
Patch:
@@ -34,7 +34,6 @@ public void testEnumPrinters_1() {
     	assertTrue(pcReturned.getValue() == 0);
     	if (pcbNeeded.getValue() > 0) {
 	    	PRINTER_INFO_1 pPrinterEnum = new PRINTER_INFO_1(pcbNeeded.getValue());
-	    	assertTrue(pcbNeeded.getValue() > 0);
 	    	assertTrue(Winspool.INSTANCE.EnumPrinters(Winspool.PRINTER_ENUM_LOCAL, 
 	    			null, 1, pPrinterEnum.getPointer(), pcbNeeded.getValue(), pcbNeeded, pcReturned));
 	    	assertTrue(pcReturned.getValue() >= 0);

File: jnalib/contrib/platform/test/com/sun/jna/platform/win32/GDI32Test.java
Patch:
@@ -14,9 +14,7 @@
 
 import junit.framework.TestCase;
 
-import com.sun.jna.*;
 import com.sun.jna.platform.win32.WinGDI.BITMAPINFO;
-import com.sun.jna.platform.win32.WinGDI.RGBQUAD;
 
 /**
  * @author twalljava[at]dev[dot]java[dot]net

File: jnalib/contrib/platform/test/com/sun/jna/platform/win32/WinspoolTest.java
Patch:
@@ -37,9 +37,10 @@ public void testEnumPrinters_1() {
     	assertTrue(pcReturned.getValue() == 0);
     	assertTrue(Winspool.INSTANCE.EnumPrinters(Winspool.PRINTER_ENUM_LOCAL, 
     			null, 1, pPrinterEnum.getPointer(), pcbNeeded.getValue(), pcbNeeded, pcReturned));
-    	assertTrue(pcReturned.getValue() > 0);
+    	assertTrue(pcReturned.getValue() >= 0);
     	PRINTER_INFO_1[] printerInfo = (PRINTER_INFO_1[]) pPrinterEnum.toArray(pcReturned.getValue());
     	for(PRINTER_INFO_1 pi : printerInfo) {
+    		assertTrue(pi.pName == null || pi.pName.length() >= 0);
     		// System.out.println(pi.pName);
     	}
     }

File: jnalib/contrib/platform/test/com/sun/jna/platform/win32/WinspoolUtilTest.java
Patch:
@@ -29,6 +29,6 @@ public static void main(String[] args) {
     }
     
 	public void testGetFolderPath() {
-		assertTrue(WinspoolUtil.getPrinterInfo1().length > 0);
+		assertTrue(WinspoolUtil.getPrinterInfo1().length >= 0);
 	}
 }

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -520,6 +520,7 @@ Object readField(StructField structField) {
                                || Callback.class.isAssignableFrom(fieldType)
                                || Buffer.class.isAssignableFrom(fieldType)
                                || Pointer.class.isAssignableFrom(fieldType)
+                               || NativeMapped.class.isAssignableFrom(fieldType)
                                || fieldType.isArray())
             ? getField(structField) : null;
         Object result = memory.getValue(offset, fieldType, currentValue);

File: jnalib/src/com/sun/jna/Function.java
Patch:
@@ -763,7 +763,7 @@ public boolean equals(Object o) {
         equivalent.
     */
     public int hashCode() {
-        return callFlags + options.hashCode() + peer.hashCode();
+        return callFlags + options.hashCode() + super.hashCode();
     }
 
     /** Concatenate varargs with normal args to obtain a simple argument 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Advapi32.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,7 +8,7 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Advapi32Util.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,7 +8,7 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Crypt32.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,7 +8,7 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Crypt32Util.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,7 +8,7 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Guid.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Kernel32Util.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/LMAccess.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/LMCons.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/LMJoin.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/NTSecApi.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,7 +8,7 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Netapi32.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,7 +8,7 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Netapi32Util.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,7 +8,7 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/NtDll.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,7 +8,7 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/NtDllUtil.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,7 +8,7 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Ole32.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,7 +8,7 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Ole32Util.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,7 +8,7 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Secur32.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,7 +8,7 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Secur32Util.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,7 +8,7 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Shell32Util.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,7 +8,7 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/ShellAPI.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/ShlObj.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -7,8 +7,8 @@
  * 
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details. 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Sspi.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/W32Errors.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,7 +8,7 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Wdm.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Win32Exception.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -8,14 +8,15 @@
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * Lesser General Public License for more details.  
  */
 package com.sun.jna.platform.win32;
 
 import com.sun.jna.platform.win32.WinNT.HRESULT;
 
 /**
  * Win32 exception.
+ * @author dblock[at]dblock[dot]org
  */
 public class Win32Exception extends RuntimeException {
 	

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/WinBase.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/WinCrypt.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/WinDef.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/WinReg.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/WinUser.java
Patch:
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007 Timothy Wall, All Rights Reserved
+/* Copyright (c) 2010 Daniel Doubrovkine, All Rights Reserved
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: jnalib/contrib/src/balloonmanagerdemo/com/sun/jna/contrib/demo/BalloonManager.java
Patch:
@@ -57,6 +57,7 @@ private static boolean useDropShadow() {
     }
     
     private static class DropShadow extends JWindow {
+		private static final long serialVersionUID = 1L;
         private static final float SHADOW_ALPHA = .25f;
         private static final float YSCALE = .80f;
         private static final double ANGLE = 2*Math.PI/24;
@@ -149,6 +150,7 @@ private Shape getMask() {
     }
     
     private static final class BubbleWindow extends JWindow {
+		private static final long serialVersionUID = 1L;
         private static final int Y_OFFSET = 50;
         private static final int ARC = 25;
 

File: jnalib/contrib/src/balloontips/com/sun/jna/contrib/demo/BalloonTipManager.java
Patch:
@@ -62,6 +62,7 @@ public class BalloonTipManager {
    * The BalloonTip class defines the look of the BalloonTip object.
    */
   private static final class BalloonTip extends JWindow {
+		private static final long serialVersionUID = 1L;
     private static final Integer HMARGIN = 10;
     private static final Integer VMARGIN = 6;
     private static final Integer VSPACER = 4;
@@ -475,7 +476,6 @@ public void actionPerformed (ActionEvent e) {
       /*
        * This class handles events spawned from moving the component.
        */
-      @SuppressWarnings("serial")
       final class ComponentEar extends ComponentAdapter {
         /*
          * (non-Javadoc)
@@ -490,7 +490,6 @@ public void componentMoved (ComponentEvent e) {
       /*
        * This class handles events spawned when a mouse button is pressed.
        */
-      @SuppressWarnings("serial")
       final class MouseEar extends MouseAdapter {
         /*
          * (non-Javadoc)
@@ -505,7 +504,6 @@ public void mousePressed (MouseEvent e) {
       /*
        * This class handles events spawned when the component loses focus.
        */
-      @SuppressWarnings("serial")
       final class FocusEar extends FocusAdapter {
         /*
          * (non-Javadoc)

File: jnalib/contrib/src/dnddemo/com/sun/jna/contrib/demo/GhostedDragImageDemo.java
Patch:
@@ -63,7 +63,8 @@ public boolean isDataFlavorSupported(DataFlavor flavor) {
     }
 
     public static class DragLabel extends JLabel {
-        private boolean dragging;
+		private static final long serialVersionUID = 1L;
+		private boolean dragging;
         public DragLabel(Icon icon) {
             super(icon);
             new DragHandler(this, DnDConstants.ACTION_COPY_OR_MOVE) {

File: jnalib/contrib/src/ntservice/src/jnacontrib/jna/WINREG.java
Patch:
@@ -9,7 +9,6 @@
 
 package jnacontrib.jna;
 
-import com.sun.jna.Pointer;
 
 /**
  *

File: jnalib/contrib/src/ntservice/src/jnacontrib/win32/Accounts.java
Patch:
@@ -19,8 +19,6 @@
  * @author TB
  */
 public class Accounts {
-  private static Object userInfoLock = new Object();
-  private static Object groupInfoLock = new Object();
   
   /** Creates a new instance of Accounts */
   private Accounts() {
@@ -290,7 +288,6 @@ public static byte[] getAccountSid(String account) {
     IntByReference cbSid;
     IntByReference cchReferencedDomainName;
     PointerByReference peUse;
-    String sidString = null;
     byte[] sid;
     char[] referencedDomainName;
     

File: jnalib/contrib/src/ntservice/src/jnacontrib/win32/Win32Service.java
Patch:
@@ -180,7 +180,6 @@ public boolean stop() throws Exception {
    */
   public void init() {
     Advapi32 advapi32;
-    Advapi32.SERVICE_TABLE_ENTRY[] entries = new Advapi32.SERVICE_TABLE_ENTRY[2];
     Advapi32.SERVICE_TABLE_ENTRY entry;
     
     serviceMain = new ServiceMain();

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/dnd/DragHandler.java
Patch:
@@ -180,7 +180,7 @@ else if (e instanceof DropTargetDropEvent) {
     private Component dragSource;
     private GhostedDragImage ghost;
     private Point imageOffset;
-    private Dimension maxGhostSize = MAX_GHOST_SIZE;
+	private Dimension maxGhostSize = MAX_GHOST_SIZE;
     private float ghostAlpha = DEFAULT_GHOST_ALPHA;
 
     /** Enable drags from the given component, supporting the actions in
@@ -530,4 +530,4 @@ public void dropActionChanged(DragSourceDragEvent e) {
         }
         updateCursor(e);
     }
-}
\ No newline at end of file
+}

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/dnd/DropHandler.java
Patch:
@@ -88,7 +88,7 @@
 public abstract class DropHandler implements DropTargetListener {
 
     private int acceptedActions;
-    private List acceptedFlavors;
+    private List<DataFlavor> acceptedFlavors;
     private DropTarget dropTarget;
     private boolean active = true;
     private DropTargetPainter painter;
@@ -347,7 +347,7 @@ public void drop(DropTargetDropEvent e) {
      * constructor.
      */
     protected boolean isSupported(DataFlavor[] flavors) {
-        Set set = new HashSet(Arrays.asList(flavors));
+        Set<DataFlavor> set = new HashSet<DataFlavor>(Arrays.asList(flavors));
         set.retainAll(acceptedFlavors);
         return !set.isEmpty();
     }

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/dnd/GhostedDragImage.java
Patch:
@@ -56,6 +56,7 @@ public GhostedDragImage(Component dragSource, final Icon icon, Point initialScre
         // FIXME ensure gc is compatible (X11)
         GraphicsConfiguration gc = parent.getGraphicsConfiguration();
         dragImage = new Window(JOptionPane.getRootFrame(), gc) {
+    		private static final long serialVersionUID = 1L;
             public void paint(Graphics g) {
                 icon.paintIcon(this, g, 0, 0);
             }

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/mac/MacFileUtils.java
Patch:
@@ -30,7 +30,7 @@ public void moveToTrash(File[] files) throws IOException {
         if (!trash.exists()) {
             throw new IOException("The Trash was not found in its expected location (" + trash + ")");
         }
-        List failed = new ArrayList();
+        List<File> failed = new ArrayList<File>();
         for (int i=0;i < files.length;i++) {
             File src = files[i];
             File target = new File(trash, src.getName());

File: jnalib/contrib/src/shapedwindowdemo/com/sun/jna/contrib/demo/ShapedWindowDemo.java
Patch:
@@ -61,6 +61,7 @@ public class ShapedWindowDemo {
     public static final int ICON_SIZE = 64;
 
     private static class ClockFace extends JComponent {
+		private static final long serialVersionUID = 1L;
         private Stroke border;
         private Stroke secondHand;
         private Stroke minuteHand;
@@ -206,11 +207,13 @@ private void showPopup(MouseEvent e) {
                     public void actionPerformed(ActionEvent e) {
                         frame.setState(JFrame.ICONIFIED);
                     }
+            		private static final long serialVersionUID = 1L;
                 });
                 m.add(new AbstractAction("Close") {
                     public void actionPerformed(ActionEvent e) {
                         System.exit(0);
                     }
+            		private static final long serialVersionUID = 1L;
                 });
                 m.pack();
                 m.show(e.getComponent(), e.getX(), e.getY());

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -84,7 +84,7 @@ private static class MemberOrder {
             "first", "second", "middle", "penultimate", "last",
         };
         public int first;
-        public int second;
+		public int second;
         public int middle;
         public int penultimate;
         public int last;
@@ -369,7 +369,7 @@ public boolean add(Object o) {
             private int indexOf(Object o) {
                 Structure s1 = (Structure)o;
                 for (int i=0;i < count;i++) {
-                    Structure s2 = (Structure)elements[i];
+                    Structure s2 = elements[i];
                     if (s1 == s2
                         || (s1.getClass() == s2.getClass()
                             && s1.size() == s2.size()

File: jnalib/test/com/sun/jna/ArgumentsMarshalTest.java
Patch:
@@ -29,6 +29,7 @@
  *
  * @author twall@users.sf.net
  */
+@SuppressWarnings("unused")
 public class ArgumentsMarshalTest extends TestCase {
 
     public static interface TestLibrary extends Library {

File: jnalib/test/com/sun/jna/CallbacksTest.java
Patch:
@@ -29,6 +29,7 @@
  *
  * @author twall@users.sf.net
  */
+@SuppressWarnings("unused")
 public class CallbacksTest extends TestCase {
 
     private static final double DOUBLE_MAGIC = -118.625d;

File: jnalib/test/com/sun/jna/DirectTest.java
Patch:
@@ -24,6 +24,7 @@
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 
+@SuppressWarnings("unused")
 public class DirectTest extends TestCase {
 
     private static final String BUILDDIR = 

File: jnalib/test/com/sun/jna/LastErrorTest.java
Patch:
@@ -18,6 +18,7 @@
 
 import junit.framework.TestCase;
 
+@SuppressWarnings("unused")
 public class LastErrorTest extends TestCase {
     
     private static final Map OPTIONS = new HashMap() {{

File: jnalib/test/com/sun/jna/NativeTest.java
Patch:
@@ -17,6 +17,7 @@
 import java.util.Properties;
 import junit.framework.TestCase;
 
+@SuppressWarnings("unused")
 public class NativeTest extends TestCase {
     
     public void testDefaultStringEncoding() throws Exception {

File: jnalib/test/com/sun/jna/StructureByValueTest.java
Patch:
@@ -91,14 +91,14 @@ public void testStructureArgByValue32() {
     }
     public void testStructureArgByValue64() {
         ByValue64 data = new ByValue64();
-        final long DATA = (long)MAGIC;
+        final long DATA = MAGIC;
         data.data = DATA;
         assertEquals("Failed to pass 64-bit struct by value",
                      DATA, lib.testStructureByValueArgument64(data));
     }
     public void testStructureArgByValue128() {
         ByValue128 data = new ByValue128();
-        final long DATA = (long)MAGIC;
+        final long DATA = MAGIC;
         data.data = DATA;
         data.data1 = DATA;
         assertEquals("Failed to pass 128-bit struct by value",

File: jnalib/test/com/sun/jna/StructureTest.java
Patch:
@@ -28,6 +28,7 @@
 /** TODO: need more alignment tests, especially platform-specific behavior
  * @author twall@users.sf.net
  */
+@SuppressWarnings("unused")
 public class StructureTest extends TestCase {
 
     public static void main(java.lang.String[] argList) {

File: jnalib/test/com/sun/jna/TypeMapperTest.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.Map;
 import junit.framework.TestCase;
 
+@SuppressWarnings("unused")
 public class TypeMapperTest extends TestCase {
     public static interface TestLibrary extends Library {
         int returnInt32Argument(boolean b);
@@ -157,7 +158,7 @@ public Class nativeType() {
         mapper.addTypeConverter(Boolean.class, converter);
         Map options = new HashMap();
         options.put(Library.OPTION_TYPE_MAPPER, mapper);
-        StructureTestLibrary lib = (StructureTestLibrary)
+		StructureTestLibrary lib = (StructureTestLibrary)
             Native.loadLibrary("testlib", StructureTestLibrary.class, options);
         StructureTestLibrary.TestStructure s = new StructureTestLibrary.TestStructure(mapper);
         assertEquals("Wrong native size", 4, s.size());

File: jnalib/test/com/sun/jna/UnionTest.java
Patch:
@@ -14,6 +14,7 @@
 
 import junit.framework.TestCase;
 
+@SuppressWarnings("unused")
 public class UnionTest extends TestCase {
 
     public static class TestStructure extends Structure {

File: jnalib/src/com/sun/jna/Native.java
Patch:
@@ -72,7 +72,7 @@
  */
 public final class Native {
 
-    private static final String VERSION = "3.2.5";
+    private static final String VERSION = "3.2.6";
 
     private static String nativeLibraryPath = null;
     private static boolean unpacked;

File: jnalib/test/com/sun/jna/MemoryTest.java
Patch:
@@ -109,7 +109,7 @@ public void testInvalidAlignment() {
 
     public void testAvoidGCWithExtantBuffer() throws Exception {
         Memory m = new Memory(1024);
-        ByteBuffer b = m.getByteBuffer(0, m.getSize());
+        ByteBuffer b = m.getByteBuffer(0, m.size());
         WeakReference ref = new WeakReference(m);
         WeakReference bref = new WeakReference(b);
         m = null;

File: jnalib/test/com/sun/jna/StructureTest.java
Patch:
@@ -1233,7 +1233,7 @@ public TestStructure(Pointer p) {
         }
         Memory p = new Memory(256);
         Structure s = new TestStructure(p);
-        assertEquals("Wrong structure size", p.getSize(), s.size());
+        assertEquals("Wrong structure size", p.size(), s.size());
     }
 
 }

File: jnalib/contrib/src/platform/test/com/sun/jna/platform/win32/W32FileMonitorTest.java
Patch:
@@ -31,12 +31,12 @@ public static void main(String[] args) {
         junit.textui.TestRunner.run(W32FileMonitorTest.class);
     }
 	
-    private Map events;
+    private Map<Integer, FileEvent> events;
     private FileMonitor monitor;
     private File tmpdir;
     
     protected void setUp() throws Exception {
-        events = new HashMap();
+        events = new HashMap<Integer, FileEvent>();
         final FileListener listener = new FileListener() {
             public void fileChanged(FileEvent e) {
                 events.put(new Integer(e.getType()), e);

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Crypt32Util.java
Patch:
@@ -12,7 +12,6 @@
  */
 package com.sun.jna.platform.win32;
 
-import com.sun.jna.LastErrorException;
 import com.sun.jna.platform.win32.WinCrypt.CRYPTPROTECT_PROMPTSTRUCT;
 import com.sun.jna.platform.win32.WinCrypt.DATA_BLOB;
 import com.sun.jna.ptr.PointerByReference;
@@ -70,7 +69,7 @@ public static byte[] cryptProtectData(byte[] data, byte[] entropy, int flags,
     	try {
 	    	if (! Crypt32.INSTANCE.CryptProtectData(pDataIn, description, 
 	    			pEntropy, null, prompt, flags, pDataProtected)) {
-	    		throw new LastErrorException(Kernel32.INSTANCE.GetLastError());
+	    		throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
 	    	}
 	    	return pDataProtected.getData();
     	} finally {
@@ -126,7 +125,7 @@ public static byte[] cryptUnprotectData(byte[] data, byte[] entropy, int flags,
     	try {
 	    	if (! Crypt32.INSTANCE.CryptUnprotectData(pDataIn, pDescription, 
 	    			pEntropy, null, prompt, flags, pDataUnprotected)) {
-	    		throw new LastErrorException(Kernel32.INSTANCE.GetLastError());
+	    		throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
 	    	}
 	    	return pDataUnprotected.getData();
     	} finally {

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/NtDllUtil.java
Patch:
@@ -1,6 +1,5 @@
 package com.sun.jna.platform.win32;
 
-import com.sun.jna.LastErrorException;
 import com.sun.jna.platform.win32.Wdm.KEY_BASIC_INFORMATION;
 import com.sun.jna.platform.win32.Wdm.KEY_INFORMATION_CLASS;
 import com.sun.jna.platform.win32.WinReg.HKEY;
@@ -22,14 +21,14 @@ public static String getKeyName(HKEY hkey) {
     	int rc = NtDll.INSTANCE.ZwQueryKey(hkey, KEY_INFORMATION_CLASS.KeyBasicInformation, 
     			null, 0, resultLength);
     	if (rc != NTStatus.STATUS_BUFFER_TOO_SMALL || resultLength.getValue() <= 0) {
-    		throw new LastErrorException(rc);
+    		throw new Win32Exception(rc);
     	}    	
     	KEY_BASIC_INFORMATION keyInformation = new KEY_BASIC_INFORMATION(
     			resultLength.getValue());
     	rc = NtDll.INSTANCE.ZwQueryKey(hkey, KEY_INFORMATION_CLASS.KeyBasicInformation,
     			keyInformation, resultLength.getValue(), resultLength);
     	if (rc != NTStatus.STATUS_SUCCESS) {
-    		throw new LastErrorException(rc);
+    		throw new Win32Exception(rc);
     	}    	
     	return keyInformation.getName();
 	}

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/W32Errors.java
Patch:
@@ -23805,9 +23805,9 @@ public static final int MAKE_SCODE(short sev, short fac, short code) {
 
 	public static final int FACILITY_NT_BIT = 0x10000000;
 
-	public static final int HRESULT_FROM_WIN32(int x) {
+	public static final HRESULT HRESULT_FROM_WIN32(int x) {
 		int f = FACILITY_WIN32;
-		return (x <= 0 ? x : ((x) & 0x0000FFFF) | (f <<= 16) | 0x80000000);
+		return new HRESULT(x <= 0 ? x : ((x) & 0x0000FFFF) | (f <<= 16) | 0x80000000);
 	}
 
 	// ---------------------- HRESULT value definitions -----------------

File: jnalib/contrib/src/platform/src/com/sun/jna/platform/win32/Advapi32.java
Patch:
@@ -143,7 +143,7 @@ public boolean ConvertStringSidToSid(String StringSid,
 	 * Returns the length, in bytes, of a valid security identifier (SID).
 	 * http://msdn.microsoft.com/en-us/library/aa446642(VS.85).aspx
 	 * 
-	 * @param sid A pointer to the SID structure whose length is returned.
+	 * @param pSid A pointer to the SID structure whose length is returned.
 	 * @return Length of the SID.
 	 */
 	public int GetLengthSid(PSID pSid);
@@ -282,7 +282,7 @@ public boolean DuplicateToken(
 	 *  Pointer to a buffer the function fills with the requested information. The structure put 
 	 *  into this buffer depends upon the type of information specified by the TokenInformationClass 
 	 *  parameter.
-	 * @param tokenInformationLengt
+	 * @param tokenInformationLength
 	 *  Specifies the size, in bytes, of the buffer pointed to by the TokenInformation parameter. 
 	 *  If TokenInformation is NULL, this parameter must be zero. 
 	 * @param returnLength

File: jnalib/contrib/src/platform/test/com/sun/jna/platform/win32/Advapi32Test.java
Patch:
@@ -239,6 +239,7 @@ public void testGetTokenGroupsInformation() {
         assertTrue(Kernel32.INSTANCE.CloseHandle(phToken.getValue()));
     }
     
+    /*
     public void testImpersonateLoggedOnUser() {
     	USER_INFO_1 userInfo = new USER_INFO_1();
     	userInfo.usri1_name = new WString("JNAAdvapi32TestImp");
@@ -262,6 +263,7 @@ public void testImpersonateLoggedOnUser() {
 		} finally {
 	    	assertEquals(LMErr.NERR_Success, Netapi32.INSTANCE.NetUserDel(
 	    			null, userInfo.usri1_name.toString()));			
-		}    	
+		}
+		*/
     }
 }

File: jnalib/src/com/sun/jna/examples/win32/W32Errors.java
Patch:
@@ -14,7 +14,8 @@
 
 /**
  * Error code definitions for the Win32 API functions.
- * Ported from Microsoft Windows SDK 6.1
+ * Ported from Windows SDK 6.0A
+ * @author dblock[at]dblock.org
  */
 public abstract class W32Errors {
 

File: jnalib/test/com/sun/jna/examples/win32/Secur32Test.java
Patch:
@@ -26,11 +26,11 @@ public static void main(String[] args) {
     
     public void testGetUserNameEx() {
     	IntByReference len = new IntByReference();
-    	Secur32.INSTANCE.GetUserNameExW(
+    	Secur32.INSTANCE.GetUserNameEx(
     			Secur32.EXTENDED_NAME_FORMAT.NameSamCompatible, null, len);
     	assertTrue(len.getValue() > 0);
     	char[] buffer = new char[len.getValue() + 1];
-    	assertTrue(Secur32.INSTANCE.GetUserNameExW(
+    	assertTrue(Secur32.INSTANCE.GetUserNameEx(
     			Secur32.EXTENDED_NAME_FORMAT.NameSamCompatible, buffer, len));
     	String username = Native.toString(buffer);
     	assertTrue(username.length() > 0);

File: jnalib/contrib/src/balloontips/BalloonTipManager.java
Patch:
@@ -1,4 +1,4 @@
-//package bms.ui.widgets;
+package balloontips;
 
 import java.awt.Color;
 import java.awt.Component;
@@ -61,7 +61,6 @@ public class BalloonTipManager {
   /*
    * The BalloonTip class defines the look of the BalloonTip object.
    */
-  @SuppressWarnings("serial")
   private static final class BalloonTip extends JWindow {
     private static final Integer HMARGIN = 10;
     private static final Integer VMARGIN = 6;

File: jnalib/contrib/src/balloontips/FilteredTextField.java
Patch:
@@ -1,4 +1,4 @@
-//package bms.ui.widgets;
+package balloontips;
 
 import java.awt.BorderLayout;
 import java.awt.Color;

File: jnalib/contrib/src/w32util/Advapi32Util.java
Patch:
@@ -1,4 +1,4 @@
-package com.sun.jna.examples.win32.util;
+package w32util;
 
 import com.sun.jna.LastErrorException;
 import com.sun.jna.Native;

File: jnalib/contrib/src/w32util/Netapi32Util.java
Patch:
@@ -1,5 +1,4 @@
-package com.sun.jna.examples.win32.util;
-
+package w32util;
 
 import com.sun.jna.LastErrorException;
 import com.sun.jna.Native;

File: jnalib/contrib/src/w32util/Secur32Util.java
Patch:
@@ -1,4 +1,4 @@
-package com.sun.jna.examples.win32.util;
+package w32util;
 
 import com.sun.jna.LastErrorException;
 import com.sun.jna.Native;

File: jnalib/contrib/test/win32/w32util/Secur32UtilTest.java
Patch:
@@ -10,7 +10,7 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.  
  */
-package com.sun.jna.examples.win32.util;
+package w32util;
 
 import com.sun.jna.examples.win32.Netapi32.*;
 import com.sun.jna.examples.win32.Secur32.*;

File: jnalib/src/com/sun/jna/examples/win32/Advapi32.java
Patch:
@@ -74,9 +74,9 @@ public boolean LookupAccountNameW(char[] lpSystemName,
 	 * Convert a security identifier (SID) to a string format suitable for display, 
 	 * storage, or transmission.
 	 * 
-	 * @param sid
+	 * @param Sid
 	 *            The SID structure to be converted.
-	 * @param stringSid
+	 * @param StringSid
 	 *            Pointer to a variable that receives a pointer to a
 	 *            null-terminated SID string. To free the returned buffer, call
 	 *            the LocalFree function.

File: jnalib/test/com/sun/jna/examples/win32/Netapi32Test.java
Patch:
@@ -35,7 +35,7 @@ public void testNetGetJoinInformation() {
     	assertTrue(lpNameBuffer.getValue().getString(0).length() > 0);
     	assertTrue(bufferType.getValue() > 0);
     	assertEquals(W32Errors.ERROR_SUCCESS, Netapi32.INSTANCE.NetApiBufferFree(
-    			lpNameBuffer.getPointer()));
+    			lpNameBuffer.getValue()));
     }
     
 }

File: jnalib/src/com/sun/jna/examples/win32/W32API.java
Patch:
@@ -92,7 +92,7 @@ class HMODULE extends HINSTANCE { }
     class HRESULT extends NativeLong { }
 
     /** Constant value representing an invalid HANDLE. */
-    HANDLE INVALID_HANDLE_VALUE = new HANDLE(Pointer.createConstant(0xFFFFFFFF));
+    HANDLE INVALID_HANDLE_VALUE = new HANDLE(Pointer.createConstant(Pointer.SIZE==8?-1:0xFFFFFFFF));
 
     /** Special HWND value. */
     HWND HWND_BROADCAST = new HWND(Pointer.createConstant(0xFFFF));

File: jnalib/src/com/sun/jna/examples/win32/W32API.java
Patch:
@@ -92,7 +92,7 @@ class HMODULE extends HINSTANCE { }
     class HRESULT extends NativeLong { }
 
     /** Constant value representing an invalid HANDLE. */
-    HANDLE INVALID_HANDLE_VALUE = new HANDLE(Pointer.createConstant(-1));
+    HANDLE INVALID_HANDLE_VALUE = new HANDLE(Pointer.createConstant(0xFFFFFFFF));
 
     /** Special HWND value. */
     HWND HWND_BROADCAST = new HWND(Pointer.createConstant(0xFFFF));

File: jnalib/src/com/sun/jna/examples/win32/Secur32.java
Patch:
@@ -41,7 +41,7 @@ public abstract class EXTENDED_NAME_FORMAT {
 	 * @param nameFormat The format of the name. 
 	 * @param lpNameBuffer A pointer to a buffer that receives the name in the specified format. 
 	 * @param len On input, the size of the buffer, on output the number of characters copied into the buffer, not including the terminating null character.
-	 * @return
+	 * @return True if the function succeeds. False otherwise.
 	 */
 	public boolean GetUserNameExW(int nameFormat, char[] lpNameBuffer, IntByReference len);
 }

File: jnalib/src/com/sun/jna/examples/win32/util/Advapi32Util.java
Patch:
@@ -14,7 +14,7 @@ public abstract class Advapi32Util {
 
 	/**
 	 * Retrieves the name of the user associated with the current thread.
-	 * @return 
+	 * @return A user name.
 	 */
 	public static String GetUserName() {
 		char[] buffer = new char[128];
@@ -48,7 +48,7 @@ public static String GetUserName() {
 	 * on which the account was found.
 	 * @param systemName Specifies the name of the system.
 	 * @param accountName Specifies the account name.
-	 * @return
+	 * @return A SID.
 	 * @throws Exception
 	 */
 	public static byte[] LookupAccountName(String systemName, String accountName) throws Exception {
@@ -84,7 +84,7 @@ public static byte[] LookupAccountName(String systemName, String accountName) th
 	/**
 	 * Convert a security identifier (SID) to a string format suitable for display, storage, or transmission.
 	 * @param sid
-	 * @return
+	 * @return A SID.
 	 */
 	public static String ConvertSidToStringSid(byte[] sid) {
 		PointerByReference stringSid = new PointerByReference();

File: jnalib/src/com/sun/jna/examples/win32/util/Netapi32Util.java
Patch:
@@ -13,7 +13,7 @@ public abstract class Netapi32Util {
 	/**
 	 * Get information about a computer.
 	 * @param computerName
-	 * @return
+	 * @return Domain or workgroup name.
 	 */
 	public static String GetDomainName(String computerName) {
 		char[] lpServer = (computerName == null) ? null : Native.toCharArray(computerName);

File: jnalib/src/com/sun/jna/examples/win32/util/Secur32Util.java
Patch:
@@ -15,7 +15,7 @@ public abstract class Secur32Util {
 	/**
 	 * Retrieves the name of the user or other security principal associated with the calling thread. 
 	 * You can specify the format of the returned name.
-	 * @return 
+	 * @return A user name in the given format.
 	 */
 	public static String GetUserNameEx(int format) {
 		char[] buffer = new char[128];

File: jnalib/test/com/sun/jna/examples/win32/Secur32Test.java
Patch:
@@ -26,9 +26,9 @@ public static void main(String[] args) {
     
     public void testGetUserNameEx() {
     	IntByReference len = new IntByReference();
-    	assertFalse(Secur32.INSTANCE.GetUserNameExW(
-    			Secur32.EXTENDED_NAME_FORMAT.NameSamCompatible, null, len));
-    	assertEquals(W32Errors.ERROR_MORE_DATA, Kernel32.INSTANCE.GetLastError());
+    	Secur32.INSTANCE.GetUserNameExW(
+    			Secur32.EXTENDED_NAME_FORMAT.NameSamCompatible, null, len);
+    	assertTrue(len.getValue() > 0);
     	char[] buffer = new char[len.getValue() + 1];
     	assertTrue(Secur32.INSTANCE.GetUserNameExW(
     			Secur32.EXTENDED_NAME_FORMAT.NameSamCompatible, buffer, len));

File: jnalib/src/com/sun/jna/examples/win32/W32API.java
Patch:
@@ -30,7 +30,7 @@
  * for unicode/ASCII mappings.  Set the system property <code>w32.ascii</code>
  * to <code>true</code> to default to the ASCII mappings.
  */
-public interface W32API extends StdCallLibrary, W32Errors {
+public interface W32API extends StdCallLibrary {
     
     /** Standard options to use the unicode version of a w32 API. */
     Map UNICODE_OPTIONS = new HashMap() {

File: jnalib/src/com/sun/jna/Pointer.java
Patch:
@@ -467,6 +467,7 @@ else if (Buffer.class.isAssignableFrom(type)) {
                 if (oldbp == null || !oldbp.equals(bp)) {
                     throw new IllegalStateException("Can't autogenerate a direct buffer on memory read");
                 }
+                result = currentValue;
             }
         }
         else if (NativeMapped.class.isAssignableFrom(type)) {

File: jnalib/test/com/sun/jna/StructureTest.java
Patch:
@@ -612,10 +612,12 @@ public void testBufferFieldWriteNonNULL() {
     }
     public void testBufferFieldReadUnchanged() {
         BufferStructure bs = new BufferStructure();
-        bs.buffer = ByteBuffer.allocateDirect(16);
+        Buffer b = ByteBuffer.allocateDirect(16);
+        bs.buffer = b;
         bs.dbuffer = ((ByteBuffer)bs.buffer).asDoubleBuffer();
         bs.write();
         bs.read();
+        assertEquals("Buffer field should be unchanged", b, bs.buffer);
     }
     public void testBufferFieldReadChanged() {
         BufferStructure bs = new BufferStructure();

File: jnalib/src/com/sun/jna/Native.java
Patch:
@@ -853,9 +853,7 @@ public Object run() {
             if (libpath != null) {
                 return new File(libpath).getParent();
             }
-            String msg = 
-                "Library '" + libName + "' was not found by class loader " + cl;
-            throw new UnsatisfiedLinkError(msg);
+            return null;
         }
         catch (Exception e) {
             return null;

File: jnalib/src/com/sun/jna/examples/win32/User32.java
Patch:
@@ -23,7 +23,7 @@
  * Incomplete implementation to support demos.
  *
  * @author  Todd Fast, todd.fast@sun.com
- * @author twall@users.sf.net
+ * @author twalljava@dev.java.net
  */
 public interface User32 extends W32API {
 

File: jnalib/test/com/sun/jna/DirectStructureByValueTest.java
Patch:
@@ -31,7 +31,6 @@ public static class DirectTestLibrary implements TestLibrary {
         public native int testStructureByValueArgument32(ByValue32 arg);
         public native long testStructureByValueArgument64(ByValue64 arg);
         public native long testStructureByValueArgument128(ByValue128 arg);
-        public native int testStructureByValueArgumentMultiple(Pointer p1, ByValue32 arg, Pointer p2);
         static {
             Native.register("testlib");
         }

File: jnalib/test/com/sun/jna/ArgumentsMarshalTest.java
Patch:
@@ -141,7 +141,6 @@ interface UnionCallback extends Callback {
 
     TestLibrary lib;
     protected void setUp() {
-        System.out.println(getName());
         lib = (TestLibrary)Native.loadLibrary("testlib", TestLibrary.class);
     }
     

File: jnalib/src/com/sun/jna/Function.java
Patch:
@@ -716,7 +716,9 @@ public void invokeVoid(Object[] args) {
      * and calling convention.
      */
     public boolean equals(Object o) {
-        if (o instanceof Function) {
+        if (o == this) return true;
+        if (o == null) return false;
+        if (o.getClass() == getClass()) {
             Function other = (Function)o;
             return other.callFlags == this.callFlags
                 && other.options.equals(this.options)

File: jnalib/src/com/sun/jna/Pointer.java
Patch:
@@ -89,9 +89,9 @@ public void clear(long size) {
      *			equal. Returns false otherwise.
      */
     public boolean equals(Object o) {
-        if (o == null)
-            return peer == 0;
-        return (o instanceof Pointer) && ((Pointer)o).peer == peer;
+        if (o == this) return true;
+        if (o == null) return false;
+        return o instanceof Pointer && ((Pointer)o).peer == peer;
     }
 
     /**

File: jnalib/src/com/sun/jna/PointerType.java
Patch:
@@ -87,6 +87,7 @@ public int hashCode() {
      * equal by default.
      */
     public boolean equals(Object o) {
+        if (o == this) return true;
         if (o instanceof PointerType) {
             Pointer p = ((PointerType)o).getPointer();
             if (pointer == null)

File: jnalib/test/com/sun/jna/ArgumentsMarshalTest.java
Patch:
@@ -560,9 +560,9 @@ public void testStructureByReferenceArrayArgument() {
             null,
             new CheckFieldAlignment.ByReference(),
         };
-        assertEquals("Wrong value returned", args[0], lib.returnPointerArrayElement(args, 0));
-        assertNull("Wrong value returned", lib.returnPointerArrayElement(args, 1));
-        assertEquals("Wrong value returned", args[2], lib.returnPointerArrayElement(args, 2));
+        assertEquals("Wrong value returned (0)", args[0], lib.returnPointerArrayElement(args, 0));
+        assertNull("Wrong value returned (1)", lib.returnPointerArrayElement(args, 1));
+        assertEquals("Wrong value returned (2)", args[2], lib.returnPointerArrayElement(args, 2));
         assertNull("Native array should be null terminated", lib.returnPointerArrayElement(args, 3));
     }
 

File: jnalib/test/com/sun/jna/WebStartTest.java
Patch:
@@ -241,11 +241,12 @@ else if (getName().equals("testDetectError")) {
                     runTestUnderWebStart(getClass().getName(), getName());
                 }
                 catch(AssertionFailedError e) {
-                    fail("Wrong error type: " + e);
+                    fail("Test produced a failure instead of an error: " + e);
                 }
                 catch(Error e) {
                     if (e.getMessage().indexOf(ERROR) != -1)
                         return;
+                    throw e;
                 }
                 fail("Failed to detect test error");
             }

File: jnalib/test/com/sun/jna/RawCallbacksTest.java
Patch:
@@ -56,7 +56,8 @@ protected void setUp() {
     }
     
     public static class DirectCallbackTestLibrary implements CallbackTestLibrary {
-        public native double callInt32Callback(Int32Callback c, double arg, double arg2);
+        public native double callInt32Callback(DoubleCallback c, double arg, double arg2);
+        public native float callInt64Callback(FloatCallback c, float arg, float arg2);
         static {
             Native.register(NativeLibrary.getInstance("testlib", _OPTIONS));
         }

File: jnalib/src/com/sun/jna/Native.java
Patch:
@@ -1189,7 +1189,7 @@ public static void register(Class cls, NativeLibrary lib) {
                 throw new IllegalArgumentException(rclass + " is not a supported return type (in method " + method.getName() + " in " + cls + ")");
             case CVT_TYPE_MAPPER:
                 fromNative = mapper.getFromNativeConverter(rclass);
-                closure_rtype = FFIType.get(Pointer.class).peer;
+                closure_rtype = FFIType.get(rclass).peer;
                 rtype = FFIType.get(fromNative.nativeType()).peer;
                 break;
             case CVT_NATIVE_MAPPED:

File: jnalib/test/com/sun/jna/RawCallbacksTest.java
Patch:
@@ -56,7 +56,7 @@ protected void setUp() {
     }
     
     public static class DirectCallbackTestLibrary implements CallbackTestLibrary {
-        public native float callInt32Callback(Int32Callback c, float arg, float arg2);
+        public native double callInt32Callback(Int32Callback c, double arg, double arg2);
         static {
             Native.register(NativeLibrary.getInstance("testlib", _OPTIONS));
         }

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -689,7 +689,8 @@ else if (writeConverter != null || readConverter != null) {
                 if (!force && typeMapper == null) {
                     return CALCULATE_SIZE;
                 }
-                throw e;
+                String msg = "Invalid Structure field in " + getClass() + ", field name '" + structField.name + "', " + structField.type + ": " + e.getMessage();
+                throw new IllegalArgumentException(msg);
             }
 
             // Align fields as appropriate

File: jnalib/src/com/sun/jna/Native.java
Patch:
@@ -793,7 +793,7 @@ public Object run() {
             }
             String msg = 
                 "Library '" + libName + "' was not found by class loader " + cl;
-            throw new IllegalArgumentException(msg);
+            throw new UnsatisfiedLinkError(msg);
         }
         catch (Exception e) {
             return null;

File: jnalib/src/com/sun/jna/Native.java
Patch:
@@ -173,7 +173,6 @@ private static boolean deleteNativeLibrary() {
             }
         }
         catch(Exception e) {
-            throw new RuntimeException("Native library delete failed: " + e.getMessage());
         }
         return false;
     }

File: jnalib/test/com/sun/jna/JNAUnloadTest.java
Patch:
@@ -12,12 +12,13 @@
  */
 package com.sun.jna;
 
+import java.io.File;
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Field;
-import java.io.File;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLClassLoader;
+
 import junit.framework.TestCase;
 
 public class JNAUnloadTest extends TestCase {

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -742,7 +742,7 @@ else if (Structure.class.isAssignableFrom(nativeType)) {
         else if (Callback.class.isAssignableFrom(nativeType)) {
             memory.setPointer(offset, CallbackReference.getFunctionPointer((Callback)value));
         }
-        else if (nativeType == Buffer.class) {
+        else if (Buffer.class.isAssignableFrom(nativeType)) {
             Pointer p = value == null ? null
                 : Native.getDirectBufferPointer((Buffer)value);
             memory.setPointer(offset, p);

File: jnalib/src/com/sun/jna/Native.java
Patch:
@@ -152,10 +152,13 @@ private static boolean unloadNativeLibrary() {
                     Method m = lib.getClass().getDeclaredMethod("finalize", new Class[0]);
                     m.setAccessible(true);
                     m.invoke(lib, new Object[0]);
+                    System.out.println("library unloaded (unpacked=" + unpacked + ")");
                     nativeLibraryPath = null;
                     if (unpacked) {
                         if (flib.exists()) {
+                            System.out.println("attempt file delete: " + flib);
                             if (flib.delete()) {
+                                System.out.println("file deleted");
                                 unpacked = false;
                                 return true;
                             }

File: jnalib/src/com/sun/jna/CallbackReference.java
Patch:
@@ -154,7 +154,7 @@ private static Method checkMethod(Method m) {
         if (m.getParameterTypes().length > Function.MAX_NARGS) {
             String msg = "Method signature exceeds the maximum "
                 + "parameter count: " + m;
-            throw new IllegalArgumentException(msg);
+            throw new UnsupportedOperationException(msg);
         }
         return m;
     }

File: jnalib/src/com/sun/jna/Function.java
Patch:
@@ -374,9 +374,9 @@ else if (allowObjects) {
             result = invokeObject(callingConvention, args);
             if (result != null
                 && !returnType.isAssignableFrom(result.getClass())) {
-                throw new IllegalArgumentException("Return type " + returnType
-                                                   + " does not match result "
-                                                   + result.getClass());
+                throw new ClassCastException("Return type " + returnType
+                                             + " does not match result "
+                                             + result.getClass());
             }
         }
         else {

File: jnalib/src/com/sun/jna/Function.java
Patch:
@@ -276,7 +276,7 @@ else if (Structure[].class.isAssignableFrom(inArg.getClass())) {
         return result;
     }
 
-    /** @see NativeLibrary#NativeLibrary(String,String,long) implementation */
+    /** @see NativeLibrary#NativeLibrary(String,String,long,Map) implementation */
     Object invoke(Object[] args, Class returnType, boolean allowObjects) {
         Object result = null;
         if (returnType == null || returnType==void.class || returnType==Void.class) {

File: jnalib/src/com/sun/jna/NativeLibrary.java
Patch:
@@ -202,7 +202,8 @@ public static final NativeLibrary getInstance(String libraryName) {
      *      This can be short form (e.g. "c"),
      *      an explicit version (e.g. "libc.so.6"), or
      *      the full path to the library (e.g. "/lib/libc.so.6").
-     * @param callingConvention the calling convention for the given library.
+     * @param options native library options for the given library (see {@link
+     * Library}).
      */
     public static final NativeLibrary getInstance(String libraryName, Map options) {
         if (libraryName == null)

File: jnalib/src/com/sun/jna/examples/win32/Kernel32.java
Patch:
@@ -205,11 +205,11 @@ public FILE_NOTIFY_INFORMATION next() {
         }
     }
     class OVERLAPPED extends Structure {
-        public int Internal;
-        public int InternalHigh;
+        public ULONG_PTR Internal;
+        public ULONG_PTR InternalHigh;
         public int Offset;
         public int OffsetHigh;
-        public Pointer hEvent;
+        public HANDLE hEvent;
     }
     // TODO: figure out how OVERLAPPED is used and apply an appropriate mapping
     interface OVERLAPPED_COMPLETION_ROUTINE extends StdCallCallback {

File: jnalib/src/com/sun/jna/CallbackReference.java
Patch:
@@ -33,7 +33,7 @@ class CallbackReference extends WeakReference {
     
     static final Map callbackMap = new WeakHashMap();
     static final Map altCallbackMap = new WeakHashMap();
-    private static final Map allocations = new WeakHashMap();
+    static final Map allocations = new WeakHashMap();
     private static final Method PROXY_CALLBACK_METHOD;
     
     static {

File: jnalib/test/com/sun/jna/StructureTest.java
Patch:
@@ -71,7 +71,7 @@ public TestStructure() { }
             public int fieldCount() { return fields().size(); }
         }
         try {
-            s = new TestStructure(new Memory(2));
+            TestStructure s = new TestStructure(new Memory(2));
             fail("Expect exception if provided memory is insufficient");
         }
         catch(IllegalArgumentException e) {

File: jnalib/src/com/sun/jna/examples/dnd/DragHandler.java
Patch:
@@ -162,7 +162,7 @@ public static Transferable getTransferable(DropTargetEvent e) {
             try {
                 // getTransferable is available during drag only on 1.5+
                 return (Transferable)
-                    e.getClass().getMethod("getTransferable", null).invoke(e, null);
+                    e.getClass().getMethod("getTransferable", (Class[])null).invoke(e, (Object[])null);
             }
             catch(Exception ex) {
                 // Method not available

File: jnalib/src/com/sun/jna/NativeLibrary.java
Patch:
@@ -374,7 +374,7 @@ private static String mapLibraryName(String libName) {
             return name;
         }
         else if (Platform.isLinux()) {
-            if (isVersionedName(libName)) {
+            if (isVersionedName(libName) || libName.endsWith(".so")) {
                 // A specific version was requested - use as is for search
                 return libName;
             }

File: jnalib/src/com/sun/jna/Memory.java
Patch:
@@ -63,7 +63,7 @@ public String toString() {
     public Memory(long size) {
         this.size = size;
         if (size <= 0) {
-            throw new IllegalArgumentException("Allocation size must be >= 0");
+            throw new IllegalArgumentException("Allocation size must be greater than zero");
         } 
         peer = malloc(size);
         if (peer == 0) 

File: jnalib/src/com/sun/jna/Native.java
Patch:
@@ -361,6 +361,7 @@ public static Map getLibraryOptions(Class type) {
             if (!options.containsKey(interfaceClass)) {
                 try {
                     Field field = interfaceClass.getField("OPTIONS");
+                    field.setAccessible(true);
                     options.put(interfaceClass, field.get(null));
                 }
                 catch (NoSuchFieldException e) {
@@ -388,6 +389,7 @@ public static TypeMapper getTypeMapper(Class cls) {
             if (!typeMappers.containsKey(interfaceClass)) {
                 try {
                     Field field = interfaceClass.getField("TYPE_MAPPER");
+                    field.setAccessible(true);
                     typeMappers.put(interfaceClass, field.get(null));
                 }
                 catch (NoSuchFieldException e) {
@@ -420,6 +422,7 @@ public static int getStructureAlignment(Class cls) {
             if (!alignments.containsKey(interfaceClass)) {
                 try {
                     Field field = interfaceClass.getField("STRUCTURE_ALIGNMENT");
+                    field.setAccessible(true);
                     alignments.put(interfaceClass, field.get(null));
                 }
                 catch(NoSuchFieldException e) {

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -433,12 +433,12 @@ else if (nativeType == double.class || nativeType == Double.class) {
         }
         else if (nativeType == Pointer.class) {
             Pointer p = memory.getPointer(offset);
-            result = p;
             if (p == null) {
                 result = null;
             }
             else {
-                Pointer oldp = (Pointer)currentValue;
+                Pointer oldp = currentValue instanceof Pointer
+                    ? (Pointer)currentValue : null;
                 if (oldp == null || p.peer != oldp.peer)
                     result = p;
                 else

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -322,7 +322,7 @@ Object getField(StructField structField) {
         }
     }
 
-    private void setField(StructField structField, Object value) {
+    void setField(StructField structField, Object value) {
         try {
             structField.field.set(this, value);
         }

File: jnalib/test/com/sun/jna/NativeTest.java
Patch:
@@ -126,11 +126,11 @@ public void testFindInterfaceClass() throws Exception {
         Class subClass = TestInterface.InnerTestClass.InnerSubclass.class;
         Class callbackClass = TestInterface.InnerTestClass.TestCallback.class;
         assertEquals("Enclosing interface not found for class",
-                     interfaceClass, Native.findLibraryClass(cls));
+                     interfaceClass, Native.findEnclosingLibraryClass(cls));
         assertEquals("Enclosing interface not found for derived class",
-                     interfaceClass, Native.findLibraryClass(subClass));
+                     interfaceClass, Native.findEnclosingLibraryClass(subClass));
         assertEquals("Enclosing interface not found for callback",
-                     interfaceClass, Native.findLibraryClass(callbackClass));
+                     interfaceClass, Native.findEnclosingLibraryClass(callbackClass));
     }
 
     public interface TestInterfaceWithInstance extends Library {

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -81,7 +81,7 @@ private static class MemberOrder {
     }
 
     private static final boolean REVERSE_FIELDS;
-    private static boolean REQUIRES_FIELD_ORDER;
+    static boolean REQUIRES_FIELD_ORDER;
 
     static final boolean isPPC;
     static final boolean isSPARC;

File: jnalib/src/com/sun/jna/Union.java
Patch:
@@ -44,6 +44,7 @@ protected Union(int size, int alignType) {
      * any declared union field.
      */
     public void setType(Class type) {
+        ensureAllocated();
         for (Iterator i=fields().values().iterator();i.hasNext();) {
             StructField f = (StructField)i.next();
             if (f.type == type) {

File: jnalib/test/com/sun/jna/examples/FileMonitorTest.java
Patch:
@@ -170,6 +170,8 @@ public void testMultipleConsecutiveWatches() throws Exception {
             assertFileEventCreated(File.createTempFile(getName(), ".tmp", subdir2));
             monitor.removeWatch(subdir2);
             monitor.addWatch(subdir1);
+            // assertion below has intermittent failures on slow W2K box w/out sleep
+            Thread.sleep(10);
             // trigger change in dir 1
             assertFileEventCreated(File.createTempFile(getName(), ".tmp", subdir1));
             monitor.removeWatch(subdir1);

File: jnalib/src/com/sun/jna/examples/FileMonitor.java
Patch:
@@ -219,7 +219,7 @@ private int convertMask(int mask) {
                 result |= Kernel32.FILE_NOTIFY_CHANGE_CREATION;
             }
             if ((mask & FILE_DELETED) != 0) {
-                result |= Kernel32.FILE_NOTIFY_CHANGE_CREATION;
+                result |= Kernel32.FILE_NOTIFY_CHANGE_NAME;
             }
             if ((mask & FILE_MODIFIED) != 0) {
                 result |= Kernel32.FILE_NOTIFY_CHANGE_LAST_WRITE;

File: jnalib/test/com/sun/jna/JNAUnloadTest.java
Patch:
@@ -17,15 +17,16 @@
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLClassLoader;
-import java.util.Properties;
 import junit.framework.TestCase;
 
 public class JNAUnloadTest extends TestCase {
     
     private static class TestLoader extends URLClassLoader {
         public TestLoader() throws MalformedURLException {
             super(new URL[] {
-                new File("build/classes").toURI().toURL(),
+                                  // use "build-d64" for 64-bit jvm's
+                new File("build" + System.getProperty(LibraryLoadTest.DIR_BUILD_SUFFIX, "")
+                        + "/classes").toURI().toURL(),
             }, null);
         }
     }

File: jnalib/src/com/sun/jna/win32/StdCallFunctionMapper.java
Patch:
@@ -67,12 +67,11 @@ public String getFunctionName(NativeLibrary library, Method method) {
 
         }
         catch(UnsatisfiedLinkError e) {
-            // try with an explicit underscore; some compilers prepend
-            // an extra one
+            // try with an explicit underscore
             try {
                 name = library.getFunction("_" + decorated, conv).getName();
             }
-            catch(UnsatisfiedLinkError e) {
+            catch(UnsatisfiedLinkError e2) {
                 // not found; let caller try undecorated version
             }
         }

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -847,7 +847,7 @@ else if (type.isArray()) {
         if (alignType == ALIGN_GNUC) {
             // NOTE this is published ABI for 32-bit gcc/linux/x86, osx/x86,
             // and osx/ppc.  osx/ppc special-cases the first element
-            if (!isFirstElement || !isPPC)
+            if (!isFirstElement || !(Platform.isMac() && isPPC))
                 return Math.min(MAX_GNUC_ALIGNMENT, alignment);
         }
         return alignment;

File: jnalib/test/com/sun/jna/examples/FileMonitorTest.java
Patch:
@@ -177,6 +177,7 @@ public void testMultipleWatches() throws Exception {
             assertTrue("No events sent", events.size() != 0);
             assertNotNull("No creation event: " + events, event);
             assertEquals("Wrong target file for event", file, event.getFile());
+            events.clear();
 
             // trigger change in dir 1
             file = File.createTempFile(getName(), ".tmp", subdir1);
@@ -189,6 +190,7 @@ public void testMultipleWatches() throws Exception {
             assertTrue("No events sent", events.size() != 0);
             assertNotNull("No creation event: " + events, event);
             assertEquals("Wrong target file for event", file, event.getFile());
+            events.clear();
         }
         finally {
             delete(subdir1);

File: jnalib/src/com/sun/jna/Function.java
Patch:
@@ -414,7 +414,7 @@ else if (Structure[].class.isAssignableFrom(argClass)) {
             if (byRef) {
                 Pointer[] pointers = new Pointer[ss.length + 1];
                 for (int i=0;i < ss.length;i++) {
-                    pointers[i] = ss[i].getPointer();
+                	pointers[i] = ss[i] != null ? ss[i].getPointer() : null;
                 }
                 return new PointerArray(pointers);
             }
@@ -579,7 +579,7 @@ public String toString() {
         }
         return "native function@0x" + Long.toHexString(peer);
     }
-    
+
     /** Convenience method for 
      * {@link #invoke(Class,Object[]) invoke(Pointer.class, args)}.
      */

File: jnalib/src/com/sun/jna/win32/W32APITypeMapper.java
Patch:
@@ -48,10 +48,10 @@ public Object toNative(Object value, ToNativeContext context) {
                 public Object fromNative(Object value, FromNativeContext context) {
                     if (value == null)
                         return null;
-                    return ((Pointer)value).getString(0, true);
+                    return value.toString();
                 }
                 public Class nativeType() {
-                    return Pointer.class;
+                    return WString.class;
                 }
             };
             addTypeConverter(String.class, stringConverter);

File: jnalib/src/com/sun/jna/examples/AlphaMaskDemo2.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007 Timothy Wall, All Rights Reserved This library is
+ * Copyright (c) 2007-2008 Timothy Wall, All Rights Reserved This library is
  * free software; you can redistribute it and/or modify it under the
  * terms of the GNU Lesser General Public License as published by the
  * Free Software Foundation; either version 2.1 of the License, or (at
@@ -33,6 +33,7 @@
 import java.util.List;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+
 import javax.swing.ImageIcon;
 import javax.swing.JButton;
 import javax.swing.JComponent;

File: jnalib/src/com/sun/jna/examples/ShapedWindowDemo.java
Patch:
@@ -36,6 +36,7 @@
 import java.awt.geom.Rectangle2D;
 import java.awt.image.BufferedImage;
 import java.util.Calendar;
+
 import javax.swing.AbstractAction;
 import javax.swing.JComponent;
 import javax.swing.JFrame;

File: jnalib/src/com/sun/jna/IntegerType.java
Patch:
@@ -73,7 +73,9 @@ public Object toNative() {
     }
 
     public Object fromNative(Object nativeValue, FromNativeContext context) {
-        long value = ((Number) nativeValue).longValue();
+        // be forgiving of null values read from memory
+        long value = nativeValue == null
+            ? 0 : ((Number) nativeValue).longValue();
         try {
             IntegerType number = (IntegerType) getClass().newInstance();
             number.setValue(value);

File: jnalib/src/com/sun/jna/NativeMappedConverter.java
Patch:
@@ -67,6 +67,6 @@ public Class nativeType() {
     }
 
     public Object toNative(Object value, ToNativeContext context) {
-        return ((NativeMapped)value).toNative();
+        return value == null ? null : ((NativeMapped)value).toNative();
     }
 }
\ No newline at end of file

File: jnalib/src/com/sun/jna/NativeLibrary.java
Patch:
@@ -369,14 +369,15 @@ private static boolean isVersionedName(String name) {
     
     /**
      * matchLibrary is very Linux specific.  It is here to deal with the case
-     * where there is no /usr/lib/libc.so, or it is not a valid symlink to
+     * where /usr/lib/libc.so does not exist, or it is not a valid symlink to
      * a versioned file (e.g. /lib/libc.so.6).
      */
     private static String matchLibrary(final String libName, List searchPath) {
         
         FilenameFilter filter = new FilenameFilter() {
             public boolean accept(File dir, String name) {
-                return isVersionedName(name);
+                return name.startsWith("lib" + libName)
+                    && isVersionedName(name);
             }
         };
         

File: jnalib/src/com/sun/jna/Native.java
Patch:
@@ -349,7 +349,7 @@ public static Map getLibraryOptions(Class type) {
     }
 
     /** Return the preferred {@link TypeMapper} for the given native interface.
-     * @see Library#OPTION_TYPE_MAPPER 
+     * See {@link com.sun.jna.Library#OPTION_TYPE_MAPPER}. 
      */
     public static TypeMapper getTypeMapper(Class cls) {
         synchronized(libraries) {
@@ -380,7 +380,7 @@ public static TypeMapper getTypeMapper(Class cls) {
     }
 
     /** Return the preferred structure alignment for the given native interface. 
-     * @see Library#OPTION_STRUCTURE_ALIGNMENT
+     * See {@link com.sun.jna.Library#OPTION_STRUCTURE_ALIGNMENT}.
      */
     public static int getStructureAlignment(Class cls) {
         synchronized(libraries) {

File: jnalib/src/com/sun/jna/Native.java
Patch:
@@ -601,7 +601,7 @@ public static String getWebStartLibraryPath(String libName) {
             return null;
         try {
             ClassLoader cl = Native.class.getClassLoader();
-            Method m = ClassLoader.class.getMethod("findLibrary", new Class[] { String.class });
+            Method m = ClassLoader.class.getDeclaredMethod("findLibrary", new Class[] { String.class });
             m.setAccessible(true);
             String libpath = (String)m.invoke(cl, new Object[] { libName });
             if (libpath != null) {

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -1049,7 +1049,7 @@ class StructField extends Object {
      * to manage on the Java side than in native code.
      */
     private static class FFIType extends Structure {
-        public class size_t extends IntegerType {
+        public static class size_t extends IntegerType {
             public size_t() { this(0); }
             public size_t(long value) { super(Native.POINTER_SIZE, value); }
         }

File: jnalib/src/com/sun/jna/Function.java
Patch:
@@ -233,8 +233,6 @@ else if (mapper != null) {
                     }
                 }
                 else if (args[i] instanceof StringArray) {
-                    // Read back arrays of String, just in case they
-                    // were modified
                     ((StringArray)args[i]).read();
                 }
                 else if (args[i] instanceof PointerArray) {

File: jnalib/src/com/sun/jna/NativeString.java
Patch:
@@ -48,7 +48,7 @@ public NativeString(String string, boolean wide) {
             throw new NullPointerException("String must not be null");
         }
         // Allocate the memory to hold the string.  Note, we have to
-        // make this 1 element longer in order to accomodate the terminating 
+        // make this 1 element longer in order to accommodate the terminating 
         // NUL (which is generated in Pointer.setString()).
         if (wide) {
             int len = (string.length() + 1 ) * Native.WCHAR_SIZE;

File: jnalib/test/com/sun/jna/NativeTest.java
Patch:
@@ -54,8 +54,8 @@ public void testCustomStringEncoding() throws Exception {
         try {
             String encoding = "UTF8";
             System.setProperty("jna.encoding", encoding);
-            String unicode = "\u81ff\u81fe\u4404\u3804\u4104\u3204\u4304";
-            String unicodez = "\u81ff\u81fe\u4404\u3804\u4104\u3204\u4304\0more stuff";
+            String unicode = "\u0444\u043b\u0441\u0432\u0443";
+            String unicodez = unicode + "\0more stuff";
             byte[] utf8 = Native.getBytes(unicode);
             byte[] expected = unicode.getBytes(encoding);
             for (int i=0;i < Math.min(utf8.length, expected.length);i++) {

File: jnalib/src/com/sun/jna/Native.java
Patch:
@@ -85,8 +85,8 @@ public final class Native {
         POINTER_SIZE = pointerSize();
         LONG_SIZE = longSize();
         WCHAR_SIZE = wideCharSize();
-        // Defer initialization of other JNA classes until *after* initializing 
-        // this class's fields
+        // Perform initialization of other JNA classes until *after* 
+        // initializing the above final fields
         initIDs();
         if (Boolean.getBoolean("jna.protected")) {
             setProtected(true);

File: jnalib/test/com/sun/jna/ReturnTypesTest.java
Patch:
@@ -197,7 +197,7 @@ public int callback(int arg) {
     
     public void testReturnStructureByValue() {
         TestStructure s = lib.returnStructureByValue();
-        assertNotNull("Returned structure must not be null");
+        assertNotNull("Returned structure must not be null", s);
         assertEquals("Wrong char field value", 1, s.c);
         assertEquals("Wrong short field value", 2, s.s);
         assertEquals("Wrong int field value", 3, s.i);

File: jnalib/test/com/sun/jna/LibraryLoadTest.java
Patch:
@@ -14,6 +14,7 @@
 
 import java.awt.Frame;
 import java.awt.Toolkit;
+import java.awt.GraphicsEnvironment;
 
 import javax.swing.JFrame;
 
@@ -27,6 +28,8 @@ public void testLoadJNALibrary() {
     }
     
     public void testLoadJAWT() {
+        if (GraphicsEnvironment.isHeadless()) return;
+
         Frame f = new Frame(getName());
         f.pack();
         try {

File: jnalib/src/com/sun/jna/Memory.java
Patch:
@@ -47,7 +47,7 @@ public SharedMemory(long offset) {
         protected void finalize() { } 
         /** Pass bounds check to parent. */
         protected void boundsCheck(long off, long sz) {
-            Memory.this.boundsCheck((int)(this.peer - Memory.this.peer) + off, sz);
+            Memory.this.boundsCheck(this.peer - Memory.this.peer + off, sz);
         }
     }
     
@@ -56,7 +56,7 @@ protected void boundsCheck(long off, long sz) {
      *
      * @param size number of <em>bytes</em> of space to allocate
      */
-    public Memory(int size) {
+    public Memory(long size) {
         this.size = size;
         if (size <= 0)
             throw new IllegalArgumentException("Allocation size must be >= 0"); 

File: jnalib/src/com/sun/jna/Pointer.java
Patch:
@@ -447,7 +447,7 @@ public String getString(long offset) {
             long len = indexOf(offset, (byte)0);
             if (len != -1) {
                 if (len > Integer.MAX_VALUE) {
-                    throw new OutOfMemoryError("String exceeds maximum length");
+                    throw new OutOfMemoryError("String exceeds maximum length: " + len);
                 }
                 byte[] data = getByteArray(offset, (int)len);
                 try {

File: jnalib/contrib/ntservice/src/jnacontrib/win32/Win32Service.java
Patch:
@@ -277,7 +277,7 @@ public void callback(int dwArgc, Pointer lpszArgv) {
       // See http://support.microsoft.com/kb/201349, which recommends
       // having init() wait for this thread.  
       // Waiting on this thread in init() won't fix the crash, though.
-      System.exit(0);
+      //System.exit(0);
     }
   }
   

File: jnalib/src/com/sun/jna/examples/win32/W32API.java
Patch:
@@ -104,7 +104,6 @@ public HANDLE getValue() {
     public static class LONG_PTR extends IntegerType { 
         public LONG_PTR() { this(0); }
         public LONG_PTR(long value) { super(Pointer.SIZE, value); }
-        public Pointer toPointer() { return Pointer.createConstant(longValue()); }
     }
     public static class SSIZE_T extends LONG_PTR {
         public SSIZE_T() { this(0); }
@@ -113,7 +112,6 @@ public static class SSIZE_T extends LONG_PTR {
     public static class ULONG_PTR extends IntegerType { 
         public ULONG_PTR() { this(0); }
         public ULONG_PTR(long value) { super(Pointer.SIZE, value); }
-        public Pointer toPointer() { return Pointer.createConstant(longValue()); }
     }
     public static class SIZE_T extends ULONG_PTR {
         public SIZE_T() { this(0); }

File: jnalib/test/com/sun/jna/examples/FileMonitorTest.java
Patch:
@@ -46,7 +46,9 @@ public void fileChanged(FileEvent e) {
     }
     
     protected void tearDown() {
-        monitor.dispose();
+        if (monitor != null) {
+            monitor.dispose();
+        }
     }
     
     public void testNotifyOnFileCreation() throws Exception {

File: jnalib/src/com/sun/jna/examples/FileMonitor.java
Patch:
@@ -24,9 +24,9 @@
 import com.sun.jna.Pointer;
 import com.sun.jna.examples.win32.Kernel32;
 import com.sun.jna.examples.win32.Kernel32.FILE_NOTIFY_INFORMATION;
-import com.sun.jna.examples.win32.Kernel32.HANDLEByReference;
 import com.sun.jna.examples.win32.Kernel32.OVERLAPPED;
 import com.sun.jna.examples.win32.W32API.HANDLE;
+import com.sun.jna.examples.win32.W32API.HANDLEByReference;
 import com.sun.jna.ptr.IntByReference;
 import com.sun.jna.ptr.PointerByReference;
 

File: jnalib/src/com/sun/jna/examples/WindowUtils.java
Patch:
@@ -103,7 +103,7 @@
  * before the corresponding native Drawable may be obtained; in later
  * Java versions, the window need only be displayable.
  * <p>
- * NOTE: If you use {@link #setWindowMask(Shape)} and override {@link
+ * NOTE: If you use {@link #setWindowMask(Window,Shape)} and override {@link
  * Window#paint(Graphics)} on OS X, you'll need to explicitly set the clip
  * mask on the <code>Graphics</code> object with the window mask; only the
  * content pane of the window and below have the window mask automatically

File: jnalib/src/com/sun/jna/examples/WindowUtils.java
Patch:
@@ -967,7 +967,7 @@ public void run() {
                                                                 false),
                                                 X11.XA_CARDINAL, 32,
                                                 X11.PropModeReplace,
-                                                patom, 1);
+                                                patom.getPointer(), 1);
                         }
                     }
                     finally {

File: jnalib/src/com/sun/jna/examples/unix/X11.java
Patch:
@@ -80,7 +80,8 @@ public Object fromNative(Object nativeValue, FromNativeContext context) {
     public static class AtomByReference extends ByReference {
         public AtomByReference() { super(4); }
         public Atom getValue() {
-            return (Atom)new Atom().fromNative(new Integer(getInt(0)), null);
+        	int value = getPointer().getInt(0);
+            return (Atom)new Atom().fromNative(new Integer(value), null);
         }
     }
     public static class Colormap extends XID {
@@ -130,7 +131,7 @@ public Object fromNative(Object nativeValue, FromNativeContext context) {
     public static class WindowByReference extends ByReference {
         public WindowByReference() { super(4); }
         public Window getValue() {
-            int value = getInt(0);
+            int value = getPointer().getInt(0);
             return value == X11.None ? Window.None : new Window(value);
         }
     }

File: jnalib/src/com/sun/jna/examples/win32/Kernel32.java
Patch:
@@ -38,10 +38,10 @@ public HANDLEByReference(HANDLE h) {
             setValue(h);
         }
         public void setValue(HANDLE h) {
-            setPointer(0, h != null ? h.getPointer() : null);
+            getPointer().setPointer(0, h != null ? h.getPointer() : null);
         }
         public HANDLE getValue() {
-            Pointer p = getPointer(0);
+            Pointer p = getPointer().getPointer(0);
             if (Pointer.PM1.equals(p))
                 return INVALID_HANDLE_VALUE;
             return new HANDLE(p);

File: jnalib/src/com/sun/jna/ptr/ByteByReference.java
Patch:
@@ -24,11 +24,11 @@ public ByteByReference(byte value) {
     }
 
     public void setValue(byte value) {
-        setByte(0, value);
+        getPointer().setByte(0, value);
     }
     
     public byte getValue() {
-        return getByte(0);
+        return getPointer().getByte(0);
     }
 
 }

File: jnalib/src/com/sun/jna/ptr/DoubleByReference.java
Patch:
@@ -23,11 +23,11 @@ public DoubleByReference(double value) {
     }
     
     public void setValue(double value) {
-        setDouble(0, value);
+        getPointer().setDouble(0, value);
     }
     
     public double getValue() {
-        return getDouble(0);
+        return getPointer().getDouble(0);
     }
     
 }

File: jnalib/src/com/sun/jna/ptr/FloatByReference.java
Patch:
@@ -23,11 +23,11 @@ public FloatByReference(float value) {
     }
     
     public void setValue(float value) {
-        setFloat(0, value);
+        getPointer().setFloat(0, value);
     }
     
     public float getValue() {
-        return getFloat(0);
+        return getPointer().getFloat(0);
     }
 
 }

File: jnalib/src/com/sun/jna/ptr/IntByReference.java
Patch:
@@ -24,10 +24,10 @@ public IntByReference(int value) {
     }
     
     public void setValue(int value) {
-        setInt(0, value);
+        getPointer().setInt(0, value);
     }
     
     public int getValue() {
-        return getInt(0);
+        return getPointer().getInt(0);
     }
 }

File: jnalib/src/com/sun/jna/ptr/LongByReference.java
Patch:
@@ -23,10 +23,10 @@ public LongByReference(long value) {
     }
     
     public void setValue(long value) {
-        setLong(0, value);
+        getPointer().setLong(0, value);
     }
     
     public long getValue() {
-        return getLong(0);
+        return getPointer().getLong(0);
     }
 }

File: jnalib/src/com/sun/jna/ptr/NativeLongByReference.java
Patch:
@@ -25,10 +25,10 @@ public NativeLongByReference(NativeLong value) {
     }
     
     public void setValue(NativeLong value) {
-        setNativeLong(0, value);
+        getPointer().setNativeLong(0, value);
     }
     
     public NativeLong getValue() {
-        return getNativeLong(0);
+        return getPointer().getNativeLong(0);
     }
 }

File: jnalib/src/com/sun/jna/ptr/PointerByReference.java
Patch:
@@ -30,10 +30,10 @@ public PointerByReference(Pointer value) {
     }
     
     public void setValue(Pointer value) {
-        setPointer(0, value);
+        getPointer().setPointer(0, value);
     }
     
     public Pointer getValue() {
-        return getPointer(0);
+        return getPointer().getPointer(0);
     }
 }

File: jnalib/src/com/sun/jna/ptr/ShortByReference.java
Patch:
@@ -24,11 +24,11 @@ public ShortByReference(short value) {
     }
     
     public void setValue(short value) {
-        setShort(0, value);
+        getPointer().setShort(0, value);
     }
     
     public short getValue() {
-        return getShort(0);
+        return getPointer().getShort(0);
     }
     
 }

File: jnalib/src/com/sun/jna/examples/BalloonManagerDemo.java
Patch:
@@ -113,8 +113,7 @@ public void mousePressed(MouseEvent e) {
         catch(UnsatisfiedLinkError e) {
             e.printStackTrace();
             String msg = e.getMessage() 
-                + "\nError loading the JNA library after looking in "
-                + System.getProperty("jna.library.path");
+                + "\nError loading the JNA library";
             JTextArea area = new JTextArea(msg);
             area.setOpaque(false);
             area.setFont(UIManager.getFont("Label.font"));

File: jnalib/src/com/sun/jna/examples/ShapedWindowDemo.java
Patch:
@@ -254,8 +254,7 @@ public void mouseReleased(MouseEvent e) {
         catch(UnsatisfiedLinkError e) {
             e.printStackTrace();
             String msg = e.getMessage() 
-                + "\nError loading the JNA library after looking in "
-                + System.getProperty("jna.library.path");
+                + "\nError loading the JNA library";
             JTextArea area = new JTextArea(msg);
             area.setOpaque(false);
             area.setFont(UIManager.getFont("Label.font"));

File: jnalib/src/com/sun/jna/Native.java
Patch:
@@ -368,7 +368,9 @@ private static boolean loadNativeLibrary() {
             
             FileOutputStream fos = null;
             try {
-                lib = File.createTempFile("jna", "");
+                // Suffix is required on windows, or library fails to load
+                // Let Java pick the suffix
+                lib = File.createTempFile("jna", null);
                 lib.deleteOnExit();
                 fos = new FileOutputStream(lib);
                 int count;

File: jnalib/src/com/sun/jna/Native.java
Patch:
@@ -38,7 +38,7 @@
  * <p>
  * {@link #getTypeMapper} and {@link #getStructureAlignment} are provided
  * to avoid having to explicitly pass these parameters to {@link Structure}s, 
- * which would require every {@link Structure} which requries custom mapping
+ * which would require every {@link Structure} which requires custom mapping
  * or alignment to define a constructor and pass parameters to the superclass.
  * To avoid lots of boilerplate, the base {@link Structure} constructor
  * figures out these properties based on the enclosing interface.
@@ -368,7 +368,7 @@ private static boolean loadNativeLibrary() {
             
             FileOutputStream fos = null;
             try {
-                lib = File.createTempFile("jna", null);
+                lib = File.createTempFile("jna", "");
                 lib.deleteOnExit();
                 fos = new FileOutputStream(lib);
                 int count;

File: jnalib/test/com/sun/jna/MemoryTest.java
Patch:
@@ -43,14 +43,14 @@ public void testSharedMemoryBounds() {
             shared.getInt(-8);
             fail("Bounds check should fail");
         }
-        catch(ArrayIndexOutOfBoundsException e) {
+        catch(IndexOutOfBoundsException e) {
         }
         shared.getInt(8);
         try {
             shared.getInt(12);
             fail("Bounds check should fail");
         }
-        catch(ArrayIndexOutOfBoundsException e) {
+        catch(IndexOutOfBoundsException e) {
         }
     }
 }

File: jnalib/test/com/sun/jna/examples/WindowUtilsTest.java
Patch:
@@ -224,7 +224,9 @@ public void testWindowRegion() throws Exception {
         Color sample = robot.getPixelColor(front.getX(), front.getY());
         long start = System.currentTimeMillis();
         while (!sample.equals(frontColor)) {
-            front.toFront();
+            SwingUtilities.invokeAndWait(new Runnable() { public void run() {
+                front.toFront(); 
+            }});
             Thread.sleep(10);
             if (System.currentTimeMillis() - start > 5000)
                 fail("Timed out waiting for window to show");

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -822,7 +822,7 @@ public Structure[] toArray(Structure[] array) {
      * backing, the memory will be resized to fit the entire array.
      */
     public Structure[] toArray(int size) {
-        return toArray(new Structure[size]);
+        return toArray((Structure[])Array.newInstance(getClass(), size));
     }
 
     /** This structure is only equal to another based on the same native 

File: jnalib/contrib/ntservice/src/jnacontrib/jna/Advapi32.java
Patch:
@@ -284,7 +284,7 @@ DWORD WINAPI HandlerEx(
       LPVOID lpEventData,
       LPVOID lpContext
     );*/
-    public void callback(int dwControl, int dwEventType, Pointer lpEventData, Pointer lpContext);
+    public int callback(int dwControl, int dwEventType, Pointer lpEventData, Pointer lpContext);
   }
   
 /*

File: jnalib/src/com/sun/jna/Function.java
Patch:
@@ -431,8 +431,7 @@ else if (ss[0] == null) {
                 int size = ss[0].size();
                 ss[0].write();
                 for (int si=1;si < ss.length;si++) {
-                    Pointer p = base.share(size*si, size);
-                    if (ss[si].getPointer().peer != p.peer) {
+                    if (ss[si].getPointer().peer != base.peer + size*si) {
                         String msg = "Structure array elements must use"
                             + " contiguous memory (at element index " + si + ")";     
                         throw new IllegalArgumentException(msg);

File: jnalib/src/com/sun/jna/CallbackReference.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.Iterator;
 import java.util.Map;
 import java.util.WeakHashMap;
-import com.sun.jna.Library.Handler;
 
 /** Provides a reference to an association between a native callback closure
  * and a Java {@link Callback} closure. 

File: jnalib/src/com/sun/jna/examples/WindowUtils.java
Patch:
@@ -984,7 +984,7 @@ public void run() {
                                                                 false),
                                                 X11.XA_CARDINAL, 32,
                                                 X11.PropModeReplace,
-                                                patom.getPointer(), 1);
+                                                patom, 1);
                         }
                     }
                     finally {

File: jnalib/src/com/sun/jna/ptr/ByteByReference.java
Patch:
@@ -24,11 +24,11 @@ public ByteByReference(byte value) {
     }
 
     public void setValue(byte value) {
-        getPointer().setByte(0, value);
+        setByte(0, value);
     }
     
     public byte getValue() {
-        return getPointer().getByte(0);
+        return getByte(0);
     }
 
 }

File: jnalib/src/com/sun/jna/ptr/DoubleByReference.java
Patch:
@@ -23,11 +23,11 @@ public DoubleByReference(double value) {
     }
     
     public void setValue(double value) {
-        getPointer().setDouble(0, value);
+        setDouble(0, value);
     }
     
     public double getValue() {
-        return getPointer().getDouble(0);
+        return getDouble(0);
     }
     
 }

File: jnalib/src/com/sun/jna/ptr/FloatByReference.java
Patch:
@@ -23,11 +23,11 @@ public FloatByReference(float value) {
     }
     
     public void setValue(float value) {
-        getPointer().setFloat(0, value);
+        setFloat(0, value);
     }
     
     public float getValue() {
-        return getPointer().getFloat(0);
+        return getFloat(0);
     }
 
 }

File: jnalib/src/com/sun/jna/ptr/IntByReference.java
Patch:
@@ -24,10 +24,10 @@ public IntByReference(int value) {
     }
     
     public void setValue(int value) {
-        getPointer().setInt(0, value);
+        setInt(0, value);
     }
     
     public int getValue() {
-        return getPointer().getInt(0);
+        return getInt(0);
     }
 }

File: jnalib/src/com/sun/jna/ptr/LongByReference.java
Patch:
@@ -23,10 +23,10 @@ public LongByReference(long value) {
     }
     
     public void setValue(long value) {
-        getPointer().setLong(0, value);
+        setLong(0, value);
     }
     
     public long getValue() {
-        return getPointer().getLong(0);
+        return getLong(0);
     }
 }

File: jnalib/src/com/sun/jna/ptr/NativeLongByReference.java
Patch:
@@ -25,10 +25,10 @@ public NativeLongByReference(NativeLong value) {
     }
     
     public void setValue(NativeLong value) {
-        getPointer().setNativeLong(0, value);
+        setNativeLong(0, value);
     }
     
     public NativeLong getValue() {
-        return getPointer().getNativeLong(0);
+        return getNativeLong(0);
     }
 }

File: jnalib/src/com/sun/jna/ptr/PointerByReference.java
Patch:
@@ -30,10 +30,10 @@ public PointerByReference(Pointer value) {
     }
     
     public void setValue(Pointer value) {
-        getPointer().setPointer(0, value);
+        setPointer(0, value);
     }
     
     public Pointer getValue() {
-        return getPointer().getPointer(0);
+        return getPointer(0);
     }
 }

File: jnalib/src/com/sun/jna/ptr/ShortByReference.java
Patch:
@@ -24,11 +24,11 @@ public ShortByReference(short value) {
     }
     
     public void setValue(short value) {
-        getPointer().setShort(0, value);
+        setShort(0, value);
     }
     
     public short getValue() {
-        return getPointer().getShort(0);
+        return getShort(0);
     }
     
 }

File: jnalib/src/com/sun/jna/StringArray.java
Patch:
@@ -44,7 +44,7 @@ public void read() {
         boolean returnWide = original instanceof WString[];
         for (int si=0;si < original.length;si++) {
             String s = getPointer(si * Pointer.SIZE).getString(0, wide);
-            original[si] = returnWide ? new WString(s) : s; 
+            original[si] = returnWide ? new WString(s) : (Object)s; 
         }
     }
 }
\ No newline at end of file

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -48,7 +48,6 @@ private static class MemberOrder {
     
     static {
         // IBM and JRockit store fields in reverse order; check for it
-        // GCJ returns an array created from a set, and needs fixing
         Field[] fields = MemberOrder.class.getFields();
         REVERSE_FIELDS = "last".equals(fields[0].getName());
         if (!"middle".equals(fields[1].getName())) {

File: jnalib/src/com/sun/jna/ToNativeConverter.java
Patch:
@@ -32,7 +32,7 @@ public interface ToNativeConverter {
      * <li>{@link Structure}
      * <li>String
      * <li>{@link WString}
-     * <li>{@link java.nio.ByteBuffer}
+     * <li>{@link java.nio.Buffer}
      * <li>primitive array
      * </ul>
      */

File: jnalib/src/com/sun/jna/NativeLong.java
Patch:
@@ -20,7 +20,7 @@
  */
 public class NativeLong extends Number implements NativeMapped {
     /** Size of a native long, in bytes. */
-    public static final int SIZE = Pointer.LONG_SIZE;
+    public static final int SIZE = Native.LONG_SIZE;
     private final Number value;
 
     /** Create a zero-valued NativeLong. */

File: jnalib/src/com/sun/jna/NativeString.java
Patch:
@@ -51,7 +51,7 @@ public NativeString(String string, boolean wide) {
         // make this 1 element longer in order to accomodate the terminating 
         // NUL (which is generated in Pointer.setString()).
         if (wide) {
-            int len = (string.length() + 1 ) * Pointer.WCHAR_SIZE;
+            int len = (string.length() + 1 ) * Native.WCHAR_SIZE;
             pointer = new Memory(len);
             pointer.setString(0, string, true);
         }

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -687,7 +687,7 @@ else if (type.isArray()) {
     protected int getNativeSize(Class cls) {
         if (cls == byte.class || cls == Byte.class) return 1;
         if (cls == short.class || cls == Short.class) return 2; 
-        if (cls == char.class || cls == Character.class) return Pointer.WCHAR_SIZE;
+        if (cls == char.class || cls == Character.class) return Native.WCHAR_SIZE;
         if (cls == int.class || cls == Integer.class) return 4;
         if (cls == long.class || cls == Long.class) return 8;
         if (cls == float.class || cls == Float.class) return 4;

File: jnalib/src/com/sun/jna/ToNativeContext.java
Patch:
@@ -13,7 +13,7 @@
 
 package com.sun.jna;
 
-
+/** Context for converting a Java value to a native one. */
 public class ToNativeContext {
     public ToNativeContext() {
     }

File: jnalib/src/com/sun/jna/examples/KeyboardUtils.java
Patch:
@@ -112,7 +112,7 @@ public boolean isPressed(int keycode, int location) {
         }
     }
     private static class X11KeyboardUtils extends NativeKeyboardUtils {
-        // TODO: map from X11 keycodes to java keycodes
+        // TODO: fully map from X11 keycodes to java keycodes
         // this is a minimal implementation
         private int toKeySym(int code, int location) {
             if (code >= KeyEvent.VK_A && code <= KeyEvent.VK_Z)

File: jnalib/src/com/sun/jna/win32/StdCallFunctionMapper.java
Patch:
@@ -17,6 +17,7 @@
 
 import com.sun.jna.Callback;
 import com.sun.jna.FunctionMapper;
+import com.sun.jna.Native;
 import com.sun.jna.NativeLibrary;
 import com.sun.jna.NativeLong;
 import com.sun.jna.Pointer;
@@ -33,13 +34,13 @@ public class StdCallFunctionMapper implements FunctionMapper {
     /** Override this to handle any custom class mappings. */
     protected int getArgumentNativeStackSize(Class cls) {
         if (cls == byte.class || cls == Byte.class) return 1;
-        if (cls == char.class || cls == Character.class) return Pointer.WCHAR_SIZE;
+        if (cls == char.class || cls == Character.class) return Native.WCHAR_SIZE;
         if (cls == short.class || cls == Short.class) return 2; 
         if (cls == int.class || cls == Integer.class) return 4;
         if (cls == long.class || cls == Long.class) return 8;
         if (cls == float.class || cls == Float.class) return 4;
         if (cls == double.class || cls == Double.class) return 8;
-        if (NativeLong.class.isAssignableFrom(cls)) return Pointer.LONG_SIZE;
+        if (NativeLong.class.isAssignableFrom(cls)) return Native.LONG_SIZE;
         if (Pointer.class.isAssignableFrom(cls)
             || Callback.class.isAssignableFrom(cls)
             || Structure.class.isAssignableFrom(cls)

File: jnalib/test/com/sun/jna/examples/WindowUtilsTest.java
Patch:
@@ -224,6 +224,7 @@ public void testWindowRegion() throws Exception {
         Color sample = robot.getPixelColor(front.getX(), front.getY());
         long start = System.currentTimeMillis();
         while (!sample.equals(frontColor)) {
+            front.toFront();
             Thread.sleep(10);
             if (System.currentTimeMillis() - start > 5000)
                 fail("Timed out waiting for window to show");

File: jnalib/src/com/sun/jna/CallbackReference.java
Patch:
@@ -268,7 +268,7 @@ else if ((boolean.class == dstType || Boolean.class == dstType)
         
         private Object convertResult(Object value) {
             if (toNative != null) {
-                value = toNative.toNative(value);
+                value = toNative.toNative(value, new ToNativeContext());
             }
             if (value == null)
                 return null;

File: jnalib/src/com/sun/jna/NativeMappedConverter.java
Patch:
@@ -49,7 +49,7 @@ public Class nativeType() {
         return nativeType;
     }
 
-    public Object toNative(Object value) {
+    public Object toNative(Object value, ToNativeContext context) {
         return ((NativeMapped)value).toNative();
     }
 }
\ No newline at end of file

File: jnalib/src/com/sun/jna/ToNativeConverter.java
Patch:
@@ -36,7 +36,7 @@ public interface ToNativeConverter {
      * <li>primitive array
      * </ul>
      */
-    Object toNative(Object value);
+    Object toNative(Object value, ToNativeContext context);
     /** Indicate the type expected from {@link #toNative}. */
     Class nativeType();
 }

File: jnalib/src/com/sun/jna/CallbackInvocationContext.java
Patch:
@@ -14,7 +14,7 @@
 
 import java.lang.reflect.Method;
 
-/** Provide argument conversion context for a callback. */
+/** Provide argument conversion context for a callback invocation. */
 public class CallbackInvocationContext extends FromNativeContext {
     private Method method;
     private Object[] args;

File: jnalib/src/com/sun/jna/Library.java
Patch:
@@ -159,8 +159,7 @@ else if (OBJECT_EQUALS.equals(method)) {
                     f = new FunctionInfo();
                     f.function = nativeLibrary.getFunction(methodName, callingConvention);
                     f.isVarArgs = Function.isVarArgs(method);                    
-                    f.options = new HashMap();
-                    f.options.putAll(this.options);
+                    f.options = new HashMap(this.options);
                     //
                     // Pass in the original method from the Library interface subclass
                     // so annotations present in the interface get passed on.

File: jnalib/src/com/sun/jna/examples/FileUtils.java
Patch:
@@ -62,8 +62,7 @@ public boolean moveToTrash(File[] files) {
 
     private static class MacFileUtils extends FileUtils {
         public boolean moveToTrash(File[] files) {
-            // TODO: account for stuff not on the same volume
-            // Also should suffix file by time moved to trash
+            // TODO: use native API for moving to trash (if any)
             File home = new File(System.getProperty("user.home"));
             File trash = new File(home, ".Trash");
             if (trash.exists()) {

File: jnalib/src/com/sun/jna/CallbackReference.java
Patch:
@@ -277,7 +277,7 @@ private Object convertResult(Object value) {
                 return ((Structure)value).getPointer();
             }
             else if (cls == boolean.class || cls == Boolean.class) {
-                return new Integer(Boolean.TRUE.equals(value)?-1:0);
+                return Integer.valueOf(Boolean.TRUE.equals(value)?-1:0);
             }
             else if (cls == String.class) {
                 // FIXME: need to prevent GC, but how and for how long?

File: jnalib/src/com/sun/jna/NativeLong.java
Patch:
@@ -35,9 +35,9 @@ public NativeLong(long value) {
             if (masked != 0 && masked != 0xFFFFFFFF80000000L) {
                 throw new IllegalArgumentException("Argument exceeds native long capacity");
             }
-            this.value = new Integer((int) (value & 0xFFFFFFFF));
+            this.value = Integer.valueOf((int) (value & 0xFFFFFFFF));
         } else {
-            this.value = new Long(value);
+            this.value = Long.valueOf(value);
         }
     }
     

File: jnalib/src/com/sun/jna/examples/BalloonManager.java
Patch:
@@ -145,8 +145,8 @@ private Shape getMask() {
     }
     
     private static final class BubbleWindow extends JWindow {
-        private final int Y_OFFSET = 50;
-        private final int ARC = 25;
+        private static final int Y_OFFSET = 50;
+        private static final int ARC = 25;
 
         private Point offset;
         private Area mask;

File: jnalib/src/com/sun/jna/win32/W32APITypeMapper.java
Patch:
@@ -53,7 +53,7 @@ public Class nativeType() {
         }
         TypeConverter booleanConverter = new TypeConverter() {
             public Object toNative(Object value) {
-                return new Integer(Boolean.TRUE.equals(value) ? 1 : 0);
+                return Integer.valueOf(Boolean.TRUE.equals(value) ? 1 : 0);
             }
             public Object fromNative(Object value, FromNativeContext context) {
                 return Boolean.valueOf(((Integer)value).intValue() != 0);

File: jnalib/test/com/sun/jna/ArgumentsMarshalTest.java
Patch:
@@ -217,7 +217,7 @@ public void testPointerArgumentReturn() {
                      lib.returnPointerArgument(s.getPointer()));
     }
 
-    final String MAGIC = "magic";
+    static final String MAGIC = "magic";
     public void testStringArgumentReturn() {
         assertEquals("Expect null pointer", null, lib.returnStringArgument(null));
         assertEquals("Expect string magic", MAGIC, lib.returnStringArgument(MAGIC));

File: jnalib/test/com/sun/jna/ReturnTypesTest.java
Patch:
@@ -141,7 +141,7 @@ public void testInvokeDouble() {
                      DOUBLE_MAGIC, lib.returnDoubleMagic(), 0d);
     }
 
-    final String MAGIC = "magic";
+    static final String MAGIC = "magic";
     public void testInvokeString() {
         assertEquals("Expect string magic", MAGIC, lib.returnStringMagic());
     }

File: jnalib/src/com/sun/jna/Pointer.java
Patch:
@@ -112,8 +112,7 @@ private static boolean loadNativeLibrary() {
             
             FileOutputStream fos = null;
             try {
-                String ext = libname.substring(libname.lastIndexOf("."));
-                lib = File.createTempFile("jna", ext);
+                lib = File.createTempFile("jna", null);
                 lib.deleteOnExit();
                 fos = new FileOutputStream(lib);
                 int count;

File: jnalib/src/com/sun/jna/FromNativeConverter.java
Patch:
@@ -18,7 +18,7 @@ public interface FromNativeConverter {
     /** Convert the given native object into its Java representation using
      * the given context. 
      */
-    public Object fromNative(Object value, FromNativeContext context);
+    Object fromNative(Object nativeValue, FromNativeContext context);
     /** Indicate the native type used by this converter. */
-    public Class nativeType();
+    Class nativeType();
 }

File: jnalib/src/com/sun/jna/ToNativeConverter.java
Patch:
@@ -36,7 +36,7 @@ public interface ToNativeConverter {
      * <li>primitive array
      * </ul>
      */
-    public Object toNative(Object value);
+    Object toNative(Object value);
     /** Indicate the type expected from {@link #toNative}. */
-    public Class nativeType();
+    Class nativeType();
 }

File: jnalib/src/com/sun/jna/examples/KeyboardUtils.java
Patch:
@@ -18,6 +18,7 @@
 import com.sun.jna.Native;
 import com.sun.jna.Pointer;
 import com.sun.jna.examples.unix.X11;
+import com.sun.jna.examples.unix.X11.Display;
 import com.sun.jna.examples.win32.User32;
 
 /** Provide access to the local keyboard state.  Note that this is meaningless
@@ -142,7 +143,7 @@ private int toKeySym(int code, int location) {
         }
         public boolean isPressed(int keycode, int location) {
             X11 lib = X11.INSTANCE;
-            Pointer dpy = lib.XOpenDisplay(null);
+            Display dpy = lib.XOpenDisplay(null);
             try {
                 byte[] keys = new byte[32];
                 int result = lib.XQueryKeymap(dpy, keys); 

File: jnalib/test/com/sun/jna/StructureTest.java
Patch:
@@ -69,7 +69,9 @@ class TestStructure extends Structure {
         }
         TestStructure s = new TestStructure();
         s.setAlignType(Structure.ALIGN_GNUC);
-        assertEquals("Wrong structure size", 28, s.size());
+        boolean isSPARC = "sparc".equals(System.getProperty("os.arch"));
+        final int SIZE = NativeLong.SIZE == 4 && !isSPARC ? 28 : 32;
+        assertEquals("Wrong structure size", SIZE, s.size());
     }
     
     // cross-platform smoke test

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * Represents a native structure with a Java peer class. 
  * <p>
- * See the <a href=overview.html>overview</a> for supported type mappings.
+ * See the <a href={@docRoot}/overview-summary.html>overview</a> for supported type mappings.
  * <p>
  * NOTE: Strings are used to represent native C strings because usage of 
  * <code>char *</code> is generally more common than <code>wchar_t *</code>.<p>

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -709,7 +709,9 @@ public Structure[] toArray(Structure[] array) {
             Memory m = (Memory)memory;
             int requiredSize = array.length * size();
             if (m.getSize() < requiredSize) {
-                useMemory(new Memory(requiredSize));
+                m = new Memory(requiredSize);
+                m.clear();
+                useMemory(m);
             }
         }
         array[0] = this;

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -258,11 +258,11 @@ else if (Pointer.class.isAssignableFrom(nativeType)) {
         }
         else if (nativeType == String.class) {
             Pointer p = memory.getPointer(offset);
-            result = p != null ? new NativeString(p, false).toString() : null;
+            result = p != null ? p.getString(0, false) : null;
         }
         else if (nativeType == WString.class) {
             Pointer p = memory.getPointer(offset);
-            result = p != null ? new NativeString(p, true).toString() : null;
+            result = p != null ? new WString(p.getString(0, true)) : null;
         }
         else if (Callback.class.isAssignableFrom(nativeType)) {
             // ignore; Callback members are write-only (don't try to convert

File: jnalib/src/com/sun/jna/examples/BalloonManagerDemo.java
Patch:
@@ -105,6 +105,7 @@ public void mousePressed(MouseEvent e) {
         f.setSize(new Dimension(300, 300));
         f.setLocation(100, 100);
         try {
+            // Force a load of JNA
             WindowUtils.setWindowMask(f, WindowUtils.MASK_NONE);
             f.setVisible(true);
             f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

File: jnalib/test/com/sun/jna/StructureTest.java
Patch:
@@ -12,6 +12,7 @@
  */
 package com.sun.jna;
 
+import java.nio.ByteBuffer;
 import java.util.Map;
 import com.sun.jna.ptr.IntByReference;
 import com.sun.jna.ptr.LongByReference;
@@ -45,7 +46,7 @@ class TestStructure extends Structure {
             public double d;
         }
         TestStructure s = new TestStructure();
-        s.setAlignment(Structure.ALIGN_GNUC);
+        s.setAlignType(Structure.ALIGN_GNUC);
         assertEquals("Wrong structure size", 28, s.size());
     }
     
@@ -60,7 +61,7 @@ class TestStructure extends Structure {
             public double d;
         }
         TestStructure s = new TestStructure();
-        s.setAlignment(Structure.ALIGN_MSVC);
+        s.setAlignType(Structure.ALIGN_MSVC);
         assertEquals("Wrong structure size", 32, s.size());
     }
     

File: jnalib/src/com/sun/jna/Callback.java
Patch:
@@ -19,7 +19,9 @@
  * a callback which has been GC'd, you will likely crash the VM.  If 
  * there is no method to deregister the callback (e.g. <code>atexit</code>
  * in the C library), you must ensure that you always keep a live reference
- * to the callback object.  
+ * to the callback object.<p>
+ * A callback should generally never throw an exception, since it doesn't
+ * necessarily have an encompassing Java environment to catch it.
  */
 public interface Callback { 
     String METHOD_NAME = "callback";

File: jnalib/src/com/sun/jna/FunctionResultContext.java
Patch:
@@ -13,7 +13,7 @@
 package com.sun.jna;
 
 /** Provide result conversion context for a function call. */
-public class FunctionResultContext extends ResultContext {
+public class FunctionResultContext extends FromNativeContext {
     
     private Function function;
     private Object[] args;

File: jnalib/src/com/sun/jna/Platform.java
Patch:
@@ -10,7 +10,8 @@
 package com.sun.jna;
 
 /** Provide simplified platform information. */
-final class Platform {
+public final class Platform {
+    private static final int UNSPECIFIED = -1;
     private static final int MAC = 0;
     private static final int LINUX = 1;
     private static final int WINDOWS = 2;
@@ -32,7 +33,7 @@ else if (osName.startsWith("Solaris") || osName.startsWith("SunOS")) {
             osType = SOLARIS;
         }
         else {
-            osType = ~0;
+            osType = UNSPECIFIED;
         }
     }
     private Platform() { }

File: jnalib/src/com/sun/jna/StructureReadContext.java
Patch:
@@ -15,7 +15,7 @@
 /** Provide native to Java type conversion context for a {@link Structure} 
  * read. 
  */
-public class StructureReadContext extends ResultContext {
+public class StructureReadContext extends FromNativeContext {
     
     private Structure structure;
     public StructureReadContext(Class resultClass, Structure struct) {

File: jnalib/src/com/sun/jna/TypeConverter.java
Patch:
@@ -16,4 +16,4 @@
 /** Convenience interface for bidirectional conversion. 
  * @author Wayne Meissner
  */
-public interface TypeConverter extends ResultConverter, ArgumentConverter {}
+public interface TypeConverter extends FromNativeConverter, ToNativeConverter {}

File: jnalib/test/com/sun/jna/ByReferenceArgumentsTest.java
Patch:
@@ -28,8 +28,6 @@
 public class ByReferenceArgumentsTest extends TestCase {
 
     public static interface TestLibrary extends Library {
-        TestLibrary INSTANCE = (TestLibrary)
-            Native.loadLibrary("testlib", TestLibrary.class);
 
         void incrementInt8ByReference(ByteByReference b);
         void incrementInt16ByReference(ShortByReference s);
@@ -42,7 +40,7 @@ public static interface TestLibrary extends Library {
 
     TestLibrary lib;
     protected void setUp() {
-        lib = TestLibrary.INSTANCE;
+        lib = (TestLibrary)Native.loadLibrary("testlib", TestLibrary.class);
     }
     
     protected void tearDown() {

File: jnalib/test/com/sun/jna/ReturnTypesTest.java
Patch:
@@ -25,8 +25,6 @@ public class ReturnTypesTest extends TestCase {
     private static final float FLOAT_MAGIC = -118.625f;
 
     public static interface TestLibrary extends Library {
-        TestLibrary INSTANCE = (TestLibrary)
-            Native.loadLibrary("testlib", TestLibrary.class);
         
         public static class TestStructure extends Structure {
             public double value;
@@ -59,7 +57,7 @@ class CheckFieldAlignment extends Structure {
 
     TestLibrary lib;
     protected void setUp() {
-        lib = TestLibrary.INSTANCE;
+        lib = (TestLibrary)Native.loadLibrary("testlib", TestLibrary.class);
     }
     
     protected void tearDown() {

File: jnalib/test/com/sun/jna/StructureTest.java
Patch:
@@ -283,8 +283,6 @@ static class CbStruct extends Structure {
         public Callback cb;
     }
     static interface CbTest extends Library {
-        CbTest INSTANCE = (CbTest)
-            Native.loadLibrary("testlib", CbTest.class);
         public void callCallbackInStruct(CbStruct cbstruct);
     }
     public void testCallbackWrite() {
@@ -310,7 +308,8 @@ public void callback() {
                 flag[0] = true;
             }
         };
-        CbTest.INSTANCE.callCallbackInStruct(s);
+        CbTest lib = (CbTest)Native.loadLibrary("testlib", CbTest.class);
+        lib.callCallbackInStruct(s);
         assertTrue("Callback not invoked", flag[0]);
     }
 }
\ No newline at end of file

File: jnalib/test/com/sun/jna/examples/KeyboardUtilsTest.java
Patch:
@@ -15,13 +15,14 @@
 import java.awt.GraphicsEnvironment;
 import java.awt.Robot;
 import java.awt.event.KeyEvent;
+import com.sun.jna.Platform;
 import junit.framework.TestCase;
 
 public class KeyboardUtilsTest extends TestCase {
     
     public void testIsPressed() throws Exception {
-        // Can't run this test headless
-        if (GraphicsEnvironment.isHeadless())
+        // Can't run this test headless; not yet implemented on mac
+        if (GraphicsEnvironment.isHeadless() || Platform.isMac())
             return;
         
         Robot robot = new Robot();

File: jnalib/test/com/sun/jna/win32/W32APIMapperTest.java
Patch:
@@ -10,7 +10,7 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.  
  */
-package com.sun.jna.examples.win32;
+package com.sun.jna.win32;
 
 import com.sun.jna.Library;
 import com.sun.jna.Native;

File: jnalib/src/com/sun/jna/CallbackReference.java
Patch:
@@ -21,7 +21,7 @@
  * and a Java {@link Callback} closure. 
  */
 
-public class CallbackReference extends WeakReference {
+class CallbackReference extends WeakReference {
     
     static final Map callbackMap = new WeakHashMap();
     static final Map altCallbackMap = new WeakHashMap();

File: jnalib/src/com/sun/jna/NativeLibrary.java
Patch:
@@ -317,6 +317,7 @@ public boolean accept(File dir, String name) {
         
         librarySearchPath.addAll(initPaths("jna.library.path"));
         if (System.getProperty("jna.platform.library.path") == null) {
+            // Add default path lookups for unix-like systems
             if (new File("/lib").exists() 
                 || new File("/usr/lib").exists()
                 || new File("/lib64").exists()
@@ -329,6 +330,5 @@ public boolean accept(File dir, String name) {
             }
         }
         librarySearchPath.addAll(initPaths("jna.platform.library.path"));
-        librarySearchPath.addAll(initPaths("java.library.path"));
     }
 }

File: jnalib/test/com/sun/jna/StructureTest.java
Patch:
@@ -233,7 +233,7 @@ class TestStructure extends Structure {
         TestStructure s = new TestStructure();
         if (NativeLong.SIZE == 8) {
             final long MAGIC = 0x1234567887654321L;
-            s.getPointer().setLong(4, MAGIC);
+            s.getPointer().setLong(8, MAGIC);
             s.read();
             assertEquals("NativeLong field mismatch", MAGIC, s.l.longValue());
         } 
@@ -255,7 +255,7 @@ class TestStructure extends Structure {
             final long MAGIC = 0x1234567887654321L;
             s.l = new NativeLong(MAGIC);
             s.write();
-            long l = s.getPointer().getLong(4);
+            long l = s.getPointer().getLong(8);
             assertEquals("NativeLong field mismatch", MAGIC, l);
         } 
         else {

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -47,8 +47,8 @@ private static class MemberOrder {
     static {
         // IBM and JRockit store fields in reverse order; check for it
         Field[] fields = MemberOrder.class.getFields();
-        REVERSE_FIELDS = fields[0].getName().equals("last");
-        if (!fields[1].equals("middle")) {
+        REVERSE_FIELDS = "last".equals(fields[0].getName());
+        if (!"middle".equals(fields[1].getName())) {
             throw new Error("This VM does not store fields in a predictable order");
         }
     }

File: jnalib/src/com/sun/jna/DefaultTypeMapper.java
Patch:
@@ -28,7 +28,7 @@
  * Object type and vice versa (i.e. you don't have to register both 
  * <code>int.class</code> and <code>Integer.class</code>).
  * If you want different mapping behavior than the default, simply override
- * {@link #getArgumentConverter} and {@link #getResultconverter}.
+ * {@link #getArgumentConverter} and {@link #getResultConverter}.
  * @see Library#OPTION_TYPE_MAPPER 
  */
 public class DefaultTypeMapper implements TypeMapper {
@@ -96,8 +96,8 @@ protected void addArgumentConverter(Class cls, ArgumentConverter converter) {
             argumentConverters.put(alt, converter);
         }
     }
-    /** Add a {@link ResultConverter} to convert a native result type into
-     * the given Java type.  Converters are checked for in the order added.
+    /** Add a {@link ResultConverter} to convert a native result type into the 
+     * given Java type.  Converters are checked for in the order added.
      */
     protected void addResultConverter(Class cls, ResultConverter converter) {
         resultConverters.put(cls, converter);

File: jnalib/src/com/sun/jna/NativeLibrary.java
Patch:
@@ -154,7 +154,7 @@ public static final void addSearchPath(String libraryName, String path) {
      *
      * @param	functionName
      *			Name of the native function to be linked with
-     * @throw   UnsatisfiedLinkError if the function is not found
+     * @throws   UnsatisfiedLinkError if the function is not found
      */
     public Function getFunction(String functionName) {
         return getFunction(functionName, Function.C_CONVENTION);
@@ -171,7 +171,7 @@ public Function getFunction(String functionName) {
      *			Name of the native function to be linked with
      * @param	callingConvention
      *			Calling convention used by the native function
-     * @throw   UnsatisfiedLinkError if the function is not found
+     * @throws   UnsatisfiedLinkError if the function is not found
      */
     public Function getFunction(String functionName, int callingConvention) {
         synchronized (functions) {

File: jnalib/src/com/sun/jna/NativeLibrary.java
Patch:
@@ -154,6 +154,7 @@ public static final void addSearchPath(String libraryName, String path) {
      *
      * @param	functionName
      *			Name of the native function to be linked with
+     * @throw   UnsatisfiedLinkError if the function is not found
      */
     public Function getFunction(String functionName) {
         return getFunction(functionName, Function.C_CONVENTION);
@@ -170,6 +171,7 @@ public Function getFunction(String functionName) {
      *			Name of the native function to be linked with
      * @param	callingConvention
      *			Calling convention used by the native function
+     * @throw   UnsatisfiedLinkError if the function is not found
      */
     public Function getFunction(String functionName, int callingConvention) {
         synchronized (functions) {

File: jnalib/src/com/sun/jna/NativeLong.java
Patch:
@@ -19,6 +19,7 @@
  * @author wmeissner@gmail.com
  */
 public class NativeLong extends Number {
+    /** Size of a native long, in bytes. */
     public static final int SIZE = Pointer.LONG_SIZE;
     private final Number value;
 

File: jnalib/src/com/sun/jna/examples/AlphaMaskDemo.java
Patch:
@@ -192,9 +192,9 @@ private void updateW32(boolean a, boolean i) {
         if (!alphaWindow.isDisplayable()) {
             alphaWindow.pack();
             hWnd = Native.getWindowPointer(alphaWindow);
-            int flags = user.GetWindowLongA(hWnd, User32.GWL_EXSTYLE);
+            int flags = user.GetWindowLong(hWnd, User32.GWL_EXSTYLE);
             flags |= User32.WS_EX_LAYERED;
-            user.SetWindowLongA(hWnd, User32.GWL_EXSTYLE, flags);
+            user.SetWindowLong(hWnd, User32.GWL_EXSTYLE, flags);
             Window parent = alphaWindow.getOwner();
             Point where = parent.getLocationOnScreen();
             where.translate(parent.getWidth(), 0);

File: jnalib/src/com/sun/jna/examples/FileUtils.java
Patch:
@@ -14,7 +14,7 @@
 
 import java.io.File;
 import com.sun.jna.examples.win32.Shell32;
-import com.sun.jna.examples.win32.Shell32.SHFILEOPSTRUCTW;
+import com.sun.jna.examples.win32.Shell32.SHFILEOPSTRUCT;
 
 /** Miscellaneous file utils not provided for by Java. */
 public abstract class FileUtils {
@@ -48,15 +48,15 @@ public static FileUtils getInstance() {
     private static class W32FileUtils extends FileUtils {
         public boolean moveToTrash(File[] files) {
             Shell32 shell = Shell32.INSTANCE;
-            SHFILEOPSTRUCTW fileop = new SHFILEOPSTRUCTW();
+            SHFILEOPSTRUCT fileop = new SHFILEOPSTRUCT();
             fileop.wFunc = Shell32.FO_DELETE;
             String[] paths = new String[files.length];
             for (int i=0;i < paths.length;i++) {
                 paths[i] = files[i].getAbsolutePath();
             }
             fileop.pFrom = fileop.encodePaths(paths);
             fileop.fFlags = Shell32.FOF_ALLOWUNDO|Shell32.FOF_NOCONFIRMATION|Shell32.FOF_SILENT;
-            return shell.SHFileOperationW(fileop) == 0;
+            return shell.SHFileOperation(fileop) == 0;
         }
     }
 

File: jnalib/src/com/sun/jna/examples/KeyboardUtils.java
Patch:
@@ -157,7 +157,7 @@ public boolean isPressed(int keycode, int location) {
                         int idx = code / 8;
                         int shift = code % 8;
                         if ((keys[idx] & (1 << shift)) != 0) {
-                            int sym = lib.XKeycodeToKeysym(dpy, code, 0);
+                            int sym = lib.XKeycodeToKeysym(dpy, (byte)code, 0);
                             if (sym == keysym)
                                 return true;
                         }

File: jnalib/src/com/sun/jna/examples/unix/X11.java
Patch:
@@ -324,7 +324,7 @@ boolean XQueryPointer(Pointer display, int window,
     int XGetWMName(Pointer display, int window,
                    XTextProperty text_property_return);
     int XQueryKeymap(Pointer display, byte[] keys_return);
-    int XKeycodeToKeysym(Pointer display, int keycode, int index);
+    int XKeycodeToKeysym(Pointer display, byte keycode, int index);
     /** Returns an array of {@link XVisualInfo} which must be freed by {@link #XFree}.
      * Use {@link XVisualInfo#toArray(Structure[]) 
      * toArray(new XVisualInfo[nitems_return.getValue()]} to obtain the array. 

File: jnalib/test/com/sun/jna/VarArgsTest.java
Patch:
@@ -55,7 +55,7 @@ public void testLongVarArgs() {
                      TestLibrary.INSTANCE.addInt32VarArgs("ll", args));
     }
     public void testStringVarArgs() {
-        String[] args = new String[] { "Test" };
+        Object[] args = new Object[] { "Test" };
         assertEquals("Did not return correct string", args[0],
                      TestLibrary.INSTANCE.returnStringVarArgs("", args));
     }

File: jnalib/test/com/sun/jna/examples/KeyboardUtilsTest.java
Patch:
@@ -30,10 +30,11 @@ public void testIsPressed() throws Exception {
             KeyEvent.VK_CONTROL,
             KeyEvent.VK_A, KeyEvent.VK_Z,
             KeyEvent.VK_0, KeyEvent.VK_9, 
-            KeyEvent.VK_SHIFT, 
+            KeyEvent.VK_SHIFT,
+            KeyEvent.VK_U,
         };
         String[] keystr = {
-            "VK_CONTROL", "VK_A", "VK_Z", "VK_0", "VK_9", "VK_SHIFT", 
+            "VK_CONTROL", "VK_A", "VK_Z", "VK_0", "VK_9", "VK_SHIFT", "VK_U", 
         };
         int[] nonkeys = {
             KeyEvent.VK_B, KeyEvent.VK_1,

File: jnalib/test/com/sun/jna/PointerTest.java
Patch:
@@ -76,7 +76,7 @@ public void testByteBufferGetLong() {
         m.setLong(0, MAGIC);
         assertEquals("Long not read from memory", MAGIC, 
                 buf.getLong(0));
-    }/*
+    }
     public void testGetNativeLong() {
         Memory m = new Memory(8);
         if (NativeLong.SIZE == 4) {
@@ -102,5 +102,5 @@ public void testSetNativeLong() {
             m.setNativeLong(0, new NativeLong(MAGIC));
             assertEquals("Native long mismatch", MAGIC, m.getLong(0));
         }
-    }*/
+    }
 }

File: jnalib/src/com/sun/jna/Structure.java
Patch:
@@ -557,6 +557,7 @@ public Structure[] toArray(Structure[] array) {
             try {
                 array[i] = (Structure)getClass().newInstance();
                 array[i].useMemory(getPointer().share(i*size, size));
+                array[i].read();
             }
             catch (InstantiationException e) {
                 throw new IllegalArgumentException("Error instantiating "

File: jnalib/src/com/sun/jna/WString.java
Patch:
@@ -30,7 +30,7 @@ public int hashCode() {
         return toString().hashCode();
     }
     public int compareTo(Object o) {
-        return toString().compareTo(o);
+        return toString().compareTo(o.toString());
     }
     public int length() {
         return toString().length();

