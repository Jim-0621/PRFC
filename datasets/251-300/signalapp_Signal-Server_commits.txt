File: service/src/test/java/org/whispersystems/textsecuregcm/redis/FaultTolerantRedisClusterClientTest.java
Patch:
@@ -107,13 +107,13 @@ void testTimeout() {
     cluster = buildCluster(null, ClientResources.builder());
 
     final ExecutionException asyncException = assertThrows(ExecutionException.class,
-        () -> cluster.withCluster(connection -> connection.async().blpop(2 * TIMEOUT.toMillis() / 1000d, "key"))
+        () -> cluster.withCluster(connection -> connection.async().blpop(10 * TIMEOUT.toMillis() / 1000d, "key"))
             .get());
 
     assertInstanceOf(RedisCommandTimeoutException.class, asyncException.getCause());
 
     assertThrows(RedisCommandTimeoutException.class,
-        () -> cluster.withCluster(connection -> connection.sync().blpop(2 * TIMEOUT.toMillis() / 1000d, "key")));
+        () -> cluster.withCluster(connection -> connection.sync().blpop(10 * TIMEOUT.toMillis() / 1000d, "key")));
   }
 
   @Test

File: service/src/main/java/org/whispersystems/textsecuregcm/mappers/SubscriptionExceptionMapper.java
Patch:
@@ -22,10 +22,10 @@ public class SubscriptionExceptionMapper implements ExceptionMapper<Subscription
   public Response toResponse(final SubscriptionException exception) {
 
     // Some exceptions have specific error body formats
-    if (exception instanceof SubscriptionException.AmountTooSmall e) {
+    if (exception instanceof SubscriptionException.InvalidAmount e) {
       return Response
           .status(Response.Status.BAD_REQUEST)
-          .entity(Map.of("error", "amount_too_small"))
+          .entity(Map.of("error", e.getErrorCode()))
           .type(MediaType.APPLICATION_JSON_TYPE)
           .build();
     }

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/MessageController.java
Patch:
@@ -272,10 +272,10 @@ public MessageController(
       description="The message is not a story and some the recipient service ID does not correspond to a registered Signal user")
   @ApiResponse(
       responseCode = "409", description = "Incorrect set of devices supplied for recipient",
-      content = @Content(schema = @Schema(implementation = AccountMismatchedDevices[].class)))
+      content = @Content(schema = @Schema(implementation = MismatchedDevices.class)))
   @ApiResponse(
       responseCode = "410", description = "Mismatched registration ids supplied for some recipient devices",
-      content = @Content(schema = @Schema(implementation = AccountStaleDevices[].class)))
+      content = @Content(schema = @Schema(implementation = StaleDevices.class)))
   @ApiResponse(
       responseCode="428",
       description="The sender should complete a challenge before proceeding")

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -647,7 +647,8 @@ public void run(WhisperServerConfiguration config, Environment environment) thro
         config.getDynamoDbTables().getIssuedReceipts().getTableName(),
         config.getDynamoDbTables().getIssuedReceipts().getExpiration(),
         dynamoDbAsyncClient,
-        config.getDynamoDbTables().getIssuedReceipts().getGenerator());
+        config.getDynamoDbTables().getIssuedReceipts().getGenerator(),
+        config.getDynamoDbTables().getIssuedReceipts().getmaxIssuedReceiptsPerPaymentId());
     OneTimeDonationsManager oneTimeDonationsManager = new OneTimeDonationsManager(
         config.getDynamoDbTables().getOnetimeDonations().getTableName(), config.getDynamoDbTables().getOnetimeDonations().getExpiration(), dynamoDbAsyncClient);
     RedeemedReceiptsManager redeemedReceiptsManager = new RedeemedReceiptsManager(clock,

File: service/src/main/java/org/whispersystems/textsecuregcm/workers/CommandDependencies.java
Patch:
@@ -268,7 +268,8 @@ static CommandDependencies build(
         configuration.getDynamoDbTables().getIssuedReceipts().getTableName(),
         configuration.getDynamoDbTables().getIssuedReceipts().getExpiration(),
         dynamoDbAsyncClient,
-        configuration.getDynamoDbTables().getIssuedReceipts().getGenerator());
+        configuration.getDynamoDbTables().getIssuedReceipts().getGenerator(),
+        configuration.getDynamoDbTables().getIssuedReceipts().getmaxIssuedReceiptsPerPaymentId());
 
     APNSender apnSender = new APNSender(apnSenderExecutor, configuration.getApnConfiguration());
     FcmSender fcmSender = new FcmSender(fcmSenderExecutor, configuration.getFcmConfiguration().credentials().value());

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -267,7 +267,6 @@
 import org.whispersystems.textsecuregcm.workers.CheckDynamicConfigurationCommand;
 import org.whispersystems.textsecuregcm.workers.DeleteUserCommand;
 import org.whispersystems.textsecuregcm.workers.IdleDeviceNotificationSchedulerFactory;
-import org.whispersystems.textsecuregcm.workers.IssuedReceiptMigrationCommand;
 import org.whispersystems.textsecuregcm.workers.MessagePersisterServiceCommand;
 import org.whispersystems.textsecuregcm.workers.NotifyIdleDevicesCommand;
 import org.whispersystems.textsecuregcm.workers.ProcessScheduledJobsServiceCommand;
@@ -333,7 +332,6 @@ public void initialize(final Bootstrap<WhisperServerConfiguration> bootstrap) {
     bootstrap.addCommand(new BackupMetricsCommand(Clock.systemUTC()));
     bootstrap.addCommand(new RemoveExpiredLinkedDevicesCommand());
     bootstrap.addCommand(new NotifyIdleDevicesCommand());
-    bootstrap.addCommand(new IssuedReceiptMigrationCommand());
     bootstrap.addCommand(new ProcessScheduledJobsServiceCommand("process-idle-device-notification-jobs",
         "Processes scheduled jobs to send notifications to idle devices",
         new IdleDeviceNotificationSchedulerFactory()));

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -267,6 +267,7 @@
 import org.whispersystems.textsecuregcm.workers.CheckDynamicConfigurationCommand;
 import org.whispersystems.textsecuregcm.workers.DeleteUserCommand;
 import org.whispersystems.textsecuregcm.workers.IdleDeviceNotificationSchedulerFactory;
+import org.whispersystems.textsecuregcm.workers.IssuedReceiptMigrationCommand;
 import org.whispersystems.textsecuregcm.workers.MessagePersisterServiceCommand;
 import org.whispersystems.textsecuregcm.workers.NotifyIdleDevicesCommand;
 import org.whispersystems.textsecuregcm.workers.ProcessScheduledJobsServiceCommand;
@@ -332,6 +333,7 @@ public void initialize(final Bootstrap<WhisperServerConfiguration> bootstrap) {
     bootstrap.addCommand(new BackupMetricsCommand(Clock.systemUTC()));
     bootstrap.addCommand(new RemoveExpiredLinkedDevicesCommand());
     bootstrap.addCommand(new NotifyIdleDevicesCommand());
+    bootstrap.addCommand(new IssuedReceiptMigrationCommand());
     bootstrap.addCommand(new ProcessScheduledJobsServiceCommand("process-idle-device-notification-jobs",
         "Processes scheduled jobs to send notifications to idle devices",
         new IdleDeviceNotificationSchedulerFactory()));

File: service/src/main/java/org/whispersystems/textsecuregcm/backup/BackupAuthManager.java
Patch:
@@ -48,7 +48,7 @@
  */
 public class BackupAuthManager {
 
-  private static final Logger logger = LoggerFactory.getLogger(BackupManager.class);
+  private static final Logger logger = LoggerFactory.getLogger(BackupAuthManager.class);
 
 
   final static Duration MAX_REDEMPTION_DURATION = Duration.ofDays(7);

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/OneTimeDonationController.java
Patch:
@@ -78,7 +78,7 @@
 @io.swagger.v3.oas.annotations.tags.Tag(name = "OneTimeDonations")
 public class OneTimeDonationController {
 
-  private static final Logger logger = LoggerFactory.getLogger(SubscriptionController.class);
+  private static final Logger logger = LoggerFactory.getLogger(OneTimeDonationController.class);
 
   private static final String EURO_CURRENCY_CODE = "EUR";
 

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/ChangeNumberManager.java
Patch:
@@ -16,7 +16,6 @@
 import org.signal.libsignal.protocol.IdentityKey;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.whispersystems.textsecuregcm.controllers.AccountController;
 import org.whispersystems.textsecuregcm.controllers.MessageController;
 import org.whispersystems.textsecuregcm.controllers.MismatchedDevicesException;
 import org.whispersystems.textsecuregcm.controllers.StaleDevicesException;
@@ -29,7 +28,8 @@
 import org.whispersystems.textsecuregcm.util.DestinationDeviceValidator;
 
 public class ChangeNumberManager {
-  private static final Logger logger = LoggerFactory.getLogger(AccountController.class);
+
+  private static final Logger logger = LoggerFactory.getLogger(ChangeNumberManager.class);
   private final MessageSender messageSender;
   private final AccountsManager accountsManager;
 

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/AccountsManagerTest.java
Patch:
@@ -853,6 +853,7 @@ void testReregisterAccount() throws InterruptedException, AccountAlreadyExistsEx
           when(existingAccount.getNumber()).thenReturn(e164);
           when(existingAccount.getPhoneNumberIdentifier()).thenReturn(requestedAccount.getIdentifier(IdentityType.PNI));
           when(existingAccount.getIdentifier(IdentityType.PNI)).thenReturn(requestedAccount.getIdentifier(IdentityType.PNI));
+          when(existingAccount.getPrimaryDevice()).thenReturn(mock(Device.class));
 
           throw new AccountAlreadyExistsException(existingAccount);
         });

File: service/src/main/java/org/whispersystems/textsecuregcm/backup/BackupAuthManager.java
Patch:
@@ -238,7 +238,7 @@ public CompletableFuture<Void> redeemReceipt(
           return accountsManager.updateAsync(account, a -> {
             final Account.BackupVoucher newPayment = new Account.BackupVoucher(receiptLevel, receiptExpiration);
             final Account.BackupVoucher existingPayment = a.getBackupVoucher();
-            account.setBackupVoucher(merge(existingPayment, newPayment));
+            a.setBackupVoucher(merge(existingPayment, newPayment));
           });
         })
         .thenRun(Util.NOOP);

File: service/src/main/java/org/whispersystems/textsecuregcm/backup/BackupManager.java
Patch:
@@ -649,7 +649,7 @@ static void checkBackupLevel(final AuthenticatedBackupUser backupUser, final Bac
    *
    * @param backupUser     The backup user to check
    * @param credentialType The credential type to require
-   * @throws {@link Status#PERMISSION_DENIED} error if the backup user is not authenticated with the given
+   * @throws {@link Status#UNAUTHENTICATED} error if the backup user is not authenticated with the given
    * {@code credentialType}
    */
   @VisibleForTesting
@@ -659,8 +659,8 @@ static void checkBackupCredentialType(final AuthenticatedBackupUser backupUser,
               FAILURE_REASON_TAG_NAME, "credential_type")
           .increment();
 
-      throw Status.PERMISSION_DENIED
-          .withDescription("credential does not support the requested operation")
+      throw Status.UNAUTHENTICATED
+          .withDescription("wrong credential type for the requested operation")
           .asRuntimeException();
     }
   }

File: service/src/test/java/org/whispersystems/textsecuregcm/controllers/ArchiveControllerTest.java
Patch:
@@ -310,7 +310,9 @@ public void getCredentials() {
         .header("Authorization", AuthHelper.getAuthHeader(AuthHelper.VALID_UUID, AuthHelper.VALID_PASSWORD))
         .get(ArchiveController.BackupAuthCredentialsResponse.class);
 
-    expectedCredentialsByType.forEach((credentialType, expectedCredentials) -> {
+    expectedCredentialsByType.forEach((libsignalCredentialType, expectedCredentials) -> {
+      final ArchiveController.BackupAuthCredentialsResponse.CredentialType credentialType =
+          ArchiveController.BackupAuthCredentialsResponse.CredentialType.fromLibsignalType(libsignalCredentialType);
       assertThat(credentialResponse.credentials().get(credentialType)).size().isEqualTo(expectedCredentials.size());
       assertThat(credentialResponse.credentials().get(credentialType).getFirst().redemptionTime())
           .isEqualTo(start.getEpochSecond());

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/ProfileController.java
Patch:
@@ -492,6 +492,6 @@ private ProfileAvatarUploadAttributes generateAvatarUploadForm(
   private static Map<String, Boolean> getAccountCapabilities(final Account account) {
     return Arrays.stream(DeviceCapability.values())
         .filter(DeviceCapability::includeInProfile)
-        .collect(Collectors.toMap(Enum::name, account::hasCapability));
+        .collect(Collectors.toMap(DeviceCapability::getName, account::hasCapability));
   }
 }

File: service/src/test/java/org/whispersystems/textsecuregcm/controllers/ProfileControllerTest.java
Patch:
@@ -452,8 +452,8 @@ void testProfileCapabilities(
         .header("Authorization", AuthHelper.getAuthHeader(AuthHelper.VALID_UUID, AuthHelper.VALID_PASSWORD))
         .get(BaseProfileResponse.class);
 
-    assertEquals(isDeleteSyncSupported, profile.getCapabilities().get(DeviceCapability.DELETE_SYNC.name()));
-    assertEquals(isVersionedExpirationTimerSupported, profile.getCapabilities().get(DeviceCapability.VERSIONED_EXPIRATION_TIMER.name()));
+    assertEquals(isDeleteSyncSupported, profile.getCapabilities().get("deleteSync"));
+    assertEquals(isVersionedExpirationTimerSupported, profile.getCapabilities().get("versionedExpirationTimer"));
   }
 
   @Test

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/DeviceController.java
Patch:
@@ -13,6 +13,7 @@
 import io.micrometer.core.instrument.Timer;
 import io.swagger.v3.oas.annotations.Operation;
 import io.swagger.v3.oas.annotations.headers.Header;
+import io.swagger.v3.oas.annotations.media.Content;
 import io.swagger.v3.oas.annotations.media.Schema;
 import io.swagger.v3.oas.annotations.responses.ApiResponse;
 import java.time.Duration;
@@ -317,11 +318,11 @@ public LinkDeviceResponse linkDevice(@HeaderParam(HttpHeaders.AUTHORIZATION) Bas
           Waits for a new device to be linked to an account and returns basic information about the new device when
           available.
           """)
-  @ApiResponse(responseCode = "200", description = "The specified was linked to an account")
+  @ApiResponse(responseCode = "200", description = "The specified was linked to an account",
+      content = @Content(schema = @Schema(implementation = DeviceInfo.class)))
   @ApiResponse(responseCode = "204", description = "No device was linked to the account before the call completed")
   @ApiResponse(responseCode = "400", description = "The given token identifier or timeout was invalid")
   @ApiResponse(responseCode = "429", description = "Rate-limited; try again after the prescribed delay")
-  @Schema(description = "Basic information about the linked device", implementation = DeviceInfo.class)
   public CompletableFuture<Response> waitForLinkedDevice(
       @ReadOnly @Auth final AuthenticatedDevice authenticatedDevice,
 

File: service/src/main/java/org/whispersystems/textsecuregcm/configuration/FaultTolerantRedisClientFactory.java
Patch:
@@ -7,11 +7,11 @@
 
 import com.fasterxml.jackson.annotation.JsonTypeInfo;
 import io.dropwizard.jackson.Discoverable;
-import io.lettuce.core.RedisClient;
 import io.lettuce.core.resource.ClientResources;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClient;
 
 @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type", defaultImpl = RedisConfiguration.class)
-public interface SingletonRedisClientFactory extends Discoverable {
+public interface FaultTolerantRedisClientFactory extends Discoverable {
 
-  RedisClient build(ClientResources clientResources);
+  FaultTolerantRedisClient build(String name, ClientResources clientResources);
 }

File: service/src/main/java/org/whispersystems/textsecuregcm/configuration/FaultTolerantRedisClusterFactory.java
Patch:
@@ -8,10 +8,10 @@
 import com.fasterxml.jackson.annotation.JsonTypeInfo;
 import io.dropwizard.jackson.Discoverable;
 import io.lettuce.core.resource.ClientResources;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 
 @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type", defaultImpl = RedisClusterConfiguration.class)
 public interface FaultTolerantRedisClusterFactory extends Discoverable {
 
-  FaultTolerantRedisCluster build(String name, ClientResources.Builder clientResourcesBuilder);
+  FaultTolerantRedisClusterClient build(String name, ClientResources.Builder clientResourcesBuilder);
 }

File: service/src/main/java/org/whispersystems/textsecuregcm/configuration/RedisClusterConfiguration.java
Patch:
@@ -13,7 +13,7 @@
 import javax.validation.Valid;
 import javax.validation.constraints.NotEmpty;
 import javax.validation.constraints.NotNull;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 
 @JsonTypeName("default")
 public class RedisClusterConfiguration implements FaultTolerantRedisClusterFactory {
@@ -58,7 +58,7 @@ public RetryConfiguration getRetryConfiguration() {
   }
 
   @Override
-  public FaultTolerantRedisCluster build(final String name, final ClientResources.Builder clientResourcesBuilder) {
-    return new FaultTolerantRedisCluster(name, this, clientResourcesBuilder);
+  public FaultTolerantRedisClusterClient build(final String name, final ClientResources.Builder clientResourcesBuilder) {
+    return new FaultTolerantRedisClusterClient(name, this, clientResourcesBuilder);
   }
 }

File: service/src/main/java/org/whispersystems/textsecuregcm/currency/CurrencyConversionManager.java
Patch:
@@ -27,7 +27,7 @@
 import org.slf4j.LoggerFactory;
 import org.whispersystems.textsecuregcm.entities.CurrencyConversionEntity;
 import org.whispersystems.textsecuregcm.entities.CurrencyConversionEntityList;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 
 public class CurrencyConversionManager implements Managed {
 
@@ -47,7 +47,7 @@ public class CurrencyConversionManager implements Managed {
 
   private final CoinMarketCapClient coinMarketCapClient;
 
-  private final FaultTolerantRedisCluster cacheCluster;
+  private final FaultTolerantRedisClusterClient cacheCluster;
 
   private final Clock clock;
 
@@ -67,7 +67,7 @@ public class CurrencyConversionManager implements Managed {
   public CurrencyConversionManager(
       final FixerClient fixerClient,
       final CoinMarketCapClient coinMarketCapClient,
-      final FaultTolerantRedisCluster cacheCluster,
+      final FaultTolerantRedisClusterClient cacheCluster,
       final List<String> currencies,
       final ScheduledExecutorService executor,
       final Clock clock) {

File: service/src/main/java/org/whispersystems/textsecuregcm/limits/CardinalityEstimator.java
Patch:
@@ -12,7 +12,7 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
 import org.whispersystems.textsecuregcm.metrics.MetricsUtil;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import org.whispersystems.textsecuregcm.util.Util;
 
 /**
@@ -21,11 +21,11 @@
 public class CardinalityEstimator {
 
   private volatile double uniqueElementCount;
-  private final FaultTolerantRedisCluster redisCluster;
+  private final FaultTolerantRedisClusterClient redisCluster;
   private final String hllName;
   private final Duration period;
 
-  public CardinalityEstimator(final FaultTolerantRedisCluster redisCluster, final String name, final Duration period) {
+  public CardinalityEstimator(final FaultTolerantRedisClusterClient redisCluster, final String name, final Duration period) {
     this.redisCluster = redisCluster;
     this.hllName = "cardinality_estimator::" + name;
     this.period = period;

File: service/src/main/java/org/whispersystems/textsecuregcm/limits/DynamicRateLimiter.java
Patch:
@@ -15,7 +15,7 @@
 import org.whispersystems.textsecuregcm.configuration.dynamic.DynamicConfiguration;
 import org.whispersystems.textsecuregcm.controllers.RateLimitExceededException;
 import org.whispersystems.textsecuregcm.redis.ClusterLuaScript;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import org.whispersystems.textsecuregcm.storage.DynamicConfigurationManager;
 
 public class DynamicRateLimiter implements RateLimiter {
@@ -26,7 +26,7 @@ public class DynamicRateLimiter implements RateLimiter {
 
   private final ClusterLuaScript validateScript;
 
-  private final FaultTolerantRedisCluster cluster;
+  private final FaultTolerantRedisClusterClient cluster;
 
   private final Clock clock;
 
@@ -38,7 +38,7 @@ public DynamicRateLimiter(
       final DynamicConfigurationManager<DynamicConfiguration> dynamicConfigurationManager,
       final Supplier<RateLimiterConfig> configResolver,
       final ClusterLuaScript validateScript,
-      final FaultTolerantRedisCluster cluster,
+      final FaultTolerantRedisClusterClient cluster,
       final Clock clock) {
     this.name = requireNonNull(name);
     this.dynamicConfigurationManager = dynamicConfigurationManager;

File: service/src/main/java/org/whispersystems/textsecuregcm/limits/MessageDeliveryLoopMonitor.java
Patch:
@@ -11,7 +11,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.whispersystems.textsecuregcm.redis.ClusterLuaScript;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 
 public class MessageDeliveryLoopMonitor {
 
@@ -22,7 +22,7 @@ public class MessageDeliveryLoopMonitor {
 
   private static final Logger logger = LoggerFactory.getLogger(MessageDeliveryLoopMonitor.class);
 
-  public MessageDeliveryLoopMonitor(final FaultTolerantRedisCluster rateLimitCluster) {
+  public MessageDeliveryLoopMonitor(final FaultTolerantRedisClusterClient rateLimitCluster) {
     try {
       getDeliveryAttemptsScript =
           ClusterLuaScript.fromResource(rateLimitCluster, "lua/get_delivery_attempt_count.lua", ScriptOutputType.INTEGER);

File: service/src/main/java/org/whispersystems/textsecuregcm/limits/RateLimiters.java
Patch:
@@ -11,7 +11,7 @@
 import java.util.Map;
 import org.whispersystems.textsecuregcm.configuration.dynamic.DynamicConfiguration;
 import org.whispersystems.textsecuregcm.redis.ClusterLuaScript;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import org.whispersystems.textsecuregcm.storage.DynamicConfigurationManager;
 
 public class RateLimiters extends BaseRateLimiters<RateLimiters.For> {
@@ -81,7 +81,7 @@ public RateLimiterConfig defaultConfig() {
   public static RateLimiters createAndValidate(
       final Map<String, RateLimiterConfig> configs,
       final DynamicConfigurationManager<DynamicConfiguration> dynamicConfigurationManager,
-      final FaultTolerantRedisCluster cacheCluster) {
+      final FaultTolerantRedisClusterClient cacheCluster) {
     final RateLimiters rateLimiters = new RateLimiters(
         configs, dynamicConfigurationManager, defaultScript(cacheCluster), cacheCluster, Clock.systemUTC());
     rateLimiters.validateValuesAndConfigs();
@@ -93,7 +93,7 @@ public static RateLimiters createAndValidate(
       final Map<String, RateLimiterConfig> configs,
       final DynamicConfigurationManager<DynamicConfiguration> dynamicConfigurationManager,
       final ClusterLuaScript validateScript,
-      final FaultTolerantRedisCluster cacheCluster,
+      final FaultTolerantRedisClusterClient cacheCluster,
       final Clock clock) {
     super(For.values(), configs, dynamicConfigurationManager, validateScript, cacheCluster, clock);
   }

File: service/src/main/java/org/whispersystems/textsecuregcm/limits/StaticRateLimiter.java
Patch:
@@ -20,7 +20,7 @@
 import org.whispersystems.textsecuregcm.controllers.RateLimitExceededException;
 import org.whispersystems.textsecuregcm.metrics.MetricsUtil;
 import org.whispersystems.textsecuregcm.redis.ClusterLuaScript;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import org.whispersystems.textsecuregcm.storage.DynamicConfigurationManager;
 import org.whispersystems.textsecuregcm.util.ExceptionUtils;
 import org.whispersystems.textsecuregcm.util.Util;
@@ -36,7 +36,7 @@ public class StaticRateLimiter implements RateLimiter {
 
   private final ClusterLuaScript validateScript;
 
-  private final FaultTolerantRedisCluster cacheCluster;
+  private final FaultTolerantRedisClusterClient cacheCluster;
 
   private final Clock clock;
 
@@ -45,7 +45,7 @@ public StaticRateLimiter(
       final String name,
       final RateLimiterConfig config,
       final ClusterLuaScript validateScript,
-      final FaultTolerantRedisCluster cacheCluster,
+      final FaultTolerantRedisClusterClient cacheCluster,
       final Clock clock,
       final DynamicConfigurationManager<DynamicConfiguration> dynamicConfigurationManager) {
     this.name = requireNonNull(name);

File: service/src/main/java/org/whispersystems/textsecuregcm/providers/RedisClusterHealthCheck.java
Patch:
@@ -6,13 +6,13 @@
 package org.whispersystems.textsecuregcm.providers;
 
 import com.codahale.metrics.health.HealthCheck;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 
 public class RedisClusterHealthCheck extends HealthCheck {
 
-    private final FaultTolerantRedisCluster redisCluster;
+    private final FaultTolerantRedisClusterClient redisCluster;
 
-    public RedisClusterHealthCheck(final FaultTolerantRedisCluster redisCluster) {
+    public RedisClusterHealthCheck(final FaultTolerantRedisClusterClient redisCluster) {
         this.redisCluster = redisCluster;
     }
 

File: service/src/main/java/org/whispersystems/textsecuregcm/redis/ClusterLuaScript.java
Patch:
@@ -25,7 +25,7 @@
 
 public class ClusterLuaScript {
 
-  private final FaultTolerantRedisCluster redisCluster;
+  private final FaultTolerantRedisClusterClient redisCluster;
   private final ScriptOutputType scriptOutputType;
   private final String script;
   private final String sha;
@@ -35,7 +35,7 @@ public class ClusterLuaScript {
 
   private static final Logger log = LoggerFactory.getLogger(ClusterLuaScript.class);
 
-  public static ClusterLuaScript fromResource(final FaultTolerantRedisCluster redisCluster,
+  public static ClusterLuaScript fromResource(final FaultTolerantRedisClusterClient redisCluster,
       final String resource,
       final ScriptOutputType scriptOutputType) throws IOException {
 
@@ -51,7 +51,7 @@ public static ClusterLuaScript fromResource(final FaultTolerantRedisCluster redi
   }
 
   @VisibleForTesting
-  ClusterLuaScript(final FaultTolerantRedisCluster redisCluster,
+  ClusterLuaScript(final FaultTolerantRedisClusterClient redisCluster,
       final String script,
       final ScriptOutputType scriptOutputType) {
 

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/AccountsManager.java
Patch:
@@ -67,7 +67,7 @@
 import org.whispersystems.textsecuregcm.identity.ServiceIdentifier;
 import org.whispersystems.textsecuregcm.metrics.UserAgentTagUtil;
 import org.whispersystems.textsecuregcm.push.ClientPresenceManager;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import org.whispersystems.textsecuregcm.redis.RedisOperation;
 import org.whispersystems.textsecuregcm.securestorage.SecureStorageClient;
 import org.whispersystems.textsecuregcm.securevaluerecovery.SecureValueRecovery2Client;
@@ -107,7 +107,7 @@ public class AccountsManager {
 
   private final Accounts accounts;
   private final PhoneNumberIdentifiers phoneNumberIdentifiers;
-  private final FaultTolerantRedisCluster cacheCluster;
+  private final FaultTolerantRedisClusterClient cacheCluster;
   private final AccountLockManager accountLockManager;
   private final KeysManager keysManager;
   private final MessagesManager messagesManager;
@@ -157,7 +157,7 @@ public enum DeletionReason {
 
   public AccountsManager(final Accounts accounts,
       final PhoneNumberIdentifiers phoneNumberIdentifiers,
-      final FaultTolerantRedisCluster cacheCluster,
+      final FaultTolerantRedisClusterClient cacheCluster,
       final AccountLockManager accountLockManager,
       final KeysManager keysManager,
       final MessagesManager messagesManager,

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/MessagesCacheGetItemsScript.java
Patch:
@@ -11,7 +11,7 @@
 import java.util.List;
 import java.util.UUID;
 import org.whispersystems.textsecuregcm.redis.ClusterLuaScript;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import reactor.core.publisher.Mono;
 
 /**
@@ -22,7 +22,7 @@ class MessagesCacheGetItemsScript {
 
   private final ClusterLuaScript getItemsScript;
 
-  MessagesCacheGetItemsScript(FaultTolerantRedisCluster redisCluster) throws IOException {
+  MessagesCacheGetItemsScript(FaultTolerantRedisClusterClient redisCluster) throws IOException {
     this.getItemsScript = ClusterLuaScript.fromResource(redisCluster, "lua/get_items.lua", ScriptOutputType.OBJECT);
   }
 

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/MessagesCacheGetQueuesToPersistScript.java
Patch:
@@ -11,7 +11,7 @@
 import java.time.Instant;
 import java.util.List;
 import org.whispersystems.textsecuregcm.redis.ClusterLuaScript;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 
 /**
  * Returns a list of queues that may be persisted. They will be sorted from oldest to more recent, limited by the
@@ -23,7 +23,7 @@ class MessagesCacheGetQueuesToPersistScript {
 
   private final ClusterLuaScript getQueuesToPersistScript;
 
-  MessagesCacheGetQueuesToPersistScript(final FaultTolerantRedisCluster redisCluster) throws IOException {
+  MessagesCacheGetQueuesToPersistScript(final FaultTolerantRedisClusterClient redisCluster) throws IOException {
     this.getQueuesToPersistScript = ClusterLuaScript.fromResource(redisCluster, "lua/get_queues_to_persist.lua",
         ScriptOutputType.MULTI);
   }

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/MessagesCacheInsertScript.java
Patch:
@@ -14,7 +14,7 @@
 import java.util.UUID;
 import org.whispersystems.textsecuregcm.entities.MessageProtos;
 import org.whispersystems.textsecuregcm.redis.ClusterLuaScript;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 
 /**
  * Inserts an envelope into the message queue for a destination device.
@@ -23,7 +23,7 @@ class MessagesCacheInsertScript {
 
   private final ClusterLuaScript insertScript;
 
-  MessagesCacheInsertScript(FaultTolerantRedisCluster redisCluster) throws IOException {
+  MessagesCacheInsertScript(FaultTolerantRedisClusterClient redisCluster) throws IOException {
     this.insertScript = ClusterLuaScript.fromResource(redisCluster, "lua/insert_item.lua", ScriptOutputType.INTEGER);
   }
 

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/MessagesCacheInsertSharedMultiRecipientPayloadAndViewsScript.java
Patch:
@@ -11,7 +11,7 @@
 import java.util.List;
 import org.signal.libsignal.protocol.SealedSenderMultiRecipientMessage;
 import org.whispersystems.textsecuregcm.redis.ClusterLuaScript;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 
 /**
  * Inserts the shared multi-recipient message payload into the cache. The list of recipients and views will be set as
@@ -25,7 +25,7 @@ class MessagesCacheInsertSharedMultiRecipientPayloadAndViewsScript {
 
   static final String ERROR_KEY_EXISTS = "ERR key exists";
 
-  MessagesCacheInsertSharedMultiRecipientPayloadAndViewsScript(FaultTolerantRedisCluster redisCluster)
+  MessagesCacheInsertSharedMultiRecipientPayloadAndViewsScript(FaultTolerantRedisClusterClient redisCluster)
       throws IOException {
     this.script = ClusterLuaScript.fromResource(redisCluster, "lua/insert_shared_multirecipient_message_data.lua",
         ScriptOutputType.INTEGER);

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/MessagesCacheRemoveByGuidScript.java
Patch:
@@ -12,7 +12,7 @@
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import org.whispersystems.textsecuregcm.redis.ClusterLuaScript;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 
 /**
  * Removes a list of message GUIDs from the queue of a destination device.
@@ -21,7 +21,7 @@ class MessagesCacheRemoveByGuidScript {
 
   private final ClusterLuaScript removeByGuidScript;
 
-  MessagesCacheRemoveByGuidScript(final FaultTolerantRedisCluster redisCluster) throws IOException {
+  MessagesCacheRemoveByGuidScript(final FaultTolerantRedisClusterClient redisCluster) throws IOException {
     this.removeByGuidScript = ClusterLuaScript.fromResource(redisCluster, "lua/remove_item_by_guid.lua",
         ScriptOutputType.OBJECT);
   }

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/MessagesCacheRemoveQueueScript.java
Patch:
@@ -12,7 +12,7 @@
 import java.util.List;
 import java.util.UUID;
 import org.whispersystems.textsecuregcm.redis.ClusterLuaScript;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import reactor.core.publisher.Mono;
 
 /**
@@ -29,7 +29,7 @@ class MessagesCacheRemoveQueueScript {
 
   private final ClusterLuaScript removeQueueScript;
 
-  MessagesCacheRemoveQueueScript(FaultTolerantRedisCluster redisCluster) throws IOException {
+  MessagesCacheRemoveQueueScript(FaultTolerantRedisClusterClient redisCluster) throws IOException {
     this.removeQueueScript = ClusterLuaScript.fromResource(redisCluster, "lua/remove_queue.lua",
         ScriptOutputType.MULTI);
   }

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/MessagesCacheRemoveRecipientViewFromMrmDataScript.java
Patch:
@@ -12,7 +12,7 @@
 import java.util.List;
 import org.whispersystems.textsecuregcm.identity.ServiceIdentifier;
 import org.whispersystems.textsecuregcm.redis.ClusterLuaScript;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import reactor.core.publisher.Mono;
 
 /**
@@ -25,7 +25,7 @@ class MessagesCacheRemoveRecipientViewFromMrmDataScript {
 
   private final ClusterLuaScript removeRecipientViewFromMrmDataScript;
 
-  MessagesCacheRemoveRecipientViewFromMrmDataScript(final FaultTolerantRedisCluster redisCluster) throws IOException {
+  MessagesCacheRemoveRecipientViewFromMrmDataScript(final FaultTolerantRedisClusterClient redisCluster) throws IOException {
     this.removeRecipientViewFromMrmDataScript = ClusterLuaScript.fromResource(redisCluster,
         "lua/remove_recipient_view_from_mrm_data.lua", ScriptOutputType.INTEGER);
   }

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/ProfilesManager.java
Patch:
@@ -14,7 +14,7 @@
 import java.util.concurrent.CompletableFuture;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import org.whispersystems.textsecuregcm.util.SystemMapper;
 import org.whispersystems.textsecuregcm.util.Util;
 import javax.annotation.Nullable;
@@ -26,12 +26,12 @@ public class ProfilesManager {
   private static final String CACHE_PREFIX = "profiles::";
 
   private final Profiles profiles;
-  private final FaultTolerantRedisCluster cacheCluster;
+  private final FaultTolerantRedisClusterClient cacheCluster;
   private final ObjectMapper mapper;
 
 
   public ProfilesManager(final Profiles profiles,
-      final FaultTolerantRedisCluster cacheCluster) {
+      final FaultTolerantRedisClusterClient cacheCluster) {
     this.profiles = profiles;
     this.cacheCluster = cacheCluster;
     this.mapper = SystemMapper.jsonMapper();

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/ReportMessageManager.java
Patch:
@@ -21,13 +21,13 @@
 import org.slf4j.LoggerFactory;
 import org.whispersystems.textsecuregcm.metrics.MetricsUtil;
 import org.whispersystems.textsecuregcm.metrics.UserAgentTagUtil;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import org.whispersystems.textsecuregcm.util.UUIDUtil;
 
 public class ReportMessageManager {
 
   private final ReportMessageDynamoDb reportMessageDynamoDb;
-  private final FaultTolerantRedisCluster rateLimitCluster;
+  private final FaultTolerantRedisClusterClient rateLimitCluster;
 
   private final Duration counterTtl;
 
@@ -40,7 +40,7 @@ public class ReportMessageManager {
   private static final Logger logger = LoggerFactory.getLogger(ReportMessageManager.class);
 
   public ReportMessageManager(final ReportMessageDynamoDb reportMessageDynamoDb,
-      final FaultTolerantRedisCluster rateLimitCluster,
+      final FaultTolerantRedisClusterClient rateLimitCluster,
       final Duration counterTtl) {
 
     this.reportMessageDynamoDb = reportMessageDynamoDb;

File: service/src/test/java/org/whispersystems/textsecuregcm/configuration/LocalFaultTolerantRedisClusterFactory.java
Patch:
@@ -8,7 +8,7 @@
 import com.fasterxml.jackson.annotation.JsonTypeName;
 import io.lettuce.core.resource.ClientResources;
 import java.util.concurrent.atomic.AtomicBoolean;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import org.whispersystems.textsecuregcm.redis.RedisClusterExtension;
 
 @JsonTypeName("local")
@@ -31,7 +31,7 @@ private LocalFaultTolerantRedisClusterFactory() {
   }
 
   @Override
-  public FaultTolerantRedisCluster build(final String name, final ClientResources.Builder clientResourcesBuilder) {
+  public FaultTolerantRedisClusterClient build(final String name, final ClientResources.Builder clientResourcesBuilder) {
 
     if (shutdownHookConfigured.compareAndSet(false, true)) {
       Runtime.getRuntime().addShutdownHook(new Thread(() -> {
@@ -47,7 +47,7 @@ public FaultTolerantRedisCluster build(final String name, final ClientResources.
     final RedisClusterConfiguration config = new RedisClusterConfiguration();
     config.setConfigurationUri(RedisClusterExtension.getRedisURIs().getFirst().toString());
 
-    return new FaultTolerantRedisCluster(name, config, clientResourcesBuilder);
+    return new FaultTolerantRedisClusterClient(name, config, clientResourcesBuilder);
   }
 
 }

File: service/src/test/java/org/whispersystems/textsecuregcm/currency/CurrencyConversionManagerTest.java
Patch:
@@ -25,7 +25,7 @@
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.RegisterExtension;
 import org.whispersystems.textsecuregcm.entities.CurrencyConversionEntityList;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import org.whispersystems.textsecuregcm.redis.RedisClusterExtension;
 
 class CurrencyConversionManagerTest {
@@ -240,7 +240,7 @@ void testCurrencyCalculationsFixerTimeoutWithRun() throws IOException {
   void convertToUsd() {
     final CurrencyConversionManager currencyConversionManager = new CurrencyConversionManager(mock(FixerClient.class),
         mock(CoinMarketCapClient.class),
-        mock(FaultTolerantRedisCluster.class),
+        mock(FaultTolerantRedisClusterClient.class),
         Collections.emptyList(),
         EXECUTOR,
         Clock.systemUTC());

File: service/src/test/java/org/whispersystems/textsecuregcm/limits/CardinalityEstimatorTest.java
Patch:
@@ -9,7 +9,7 @@
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.Timeout;
 import org.junit.jupiter.api.extension.RegisterExtension;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import org.whispersystems.textsecuregcm.redis.RedisClusterExtension;
 import java.time.Duration;
 
@@ -20,7 +20,7 @@ public class CardinalityEstimatorTest {
 
   @Test
   public void testAdd() throws Exception {
-    final FaultTolerantRedisCluster redisCluster = REDIS_CLUSTER_EXTENSION.getRedisCluster();
+    final FaultTolerantRedisClusterClient redisCluster = REDIS_CLUSTER_EXTENSION.getRedisCluster();
     final CardinalityEstimator estimator = new CardinalityEstimator(redisCluster, "test", Duration.ofSeconds(1));
 
     estimator.add("1");
@@ -40,7 +40,7 @@ public void testAdd() throws Exception {
   @Test
   @Timeout(5)
   public void testEventuallyExpires() throws InterruptedException {
-    final FaultTolerantRedisCluster redisCluster = REDIS_CLUSTER_EXTENSION.getRedisCluster();
+    final FaultTolerantRedisClusterClient redisCluster = REDIS_CLUSTER_EXTENSION.getRedisCluster();
     final CardinalityEstimator estimator = new CardinalityEstimator(redisCluster, "test", Duration.ofMillis(100));
     estimator.add("1");
     long count;

File: service/src/test/java/org/whispersystems/textsecuregcm/limits/RateLimitersTest.java
Patch:
@@ -22,7 +22,7 @@
 import org.whispersystems.textsecuregcm.configuration.dynamic.DynamicConfiguration;
 import org.whispersystems.textsecuregcm.configuration.dynamic.DynamicRateLimitPolicy;
 import org.whispersystems.textsecuregcm.redis.ClusterLuaScript;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import org.whispersystems.textsecuregcm.storage.DynamicConfigurationManager;
 import org.whispersystems.textsecuregcm.util.MockUtils;
 import org.whispersystems.textsecuregcm.util.MutableClock;
@@ -37,7 +37,7 @@ public class RateLimitersTest {
 
   private final ClusterLuaScript validateScript = mock(ClusterLuaScript.class);
 
-  private final FaultTolerantRedisCluster redisCluster = mock(FaultTolerantRedisCluster.class);
+  private final FaultTolerantRedisClusterClient redisCluster = mock(FaultTolerantRedisClusterClient.class);
 
   private final MutableClock clock = MockUtils.mutableClock(0);
 

File: service/src/test/java/org/whispersystems/textsecuregcm/push/PushNotificationSchedulerTest.java
Patch:
@@ -31,7 +31,7 @@
 import org.junit.jupiter.params.provider.CsvSource;
 import org.mockito.ArgumentCaptor;
 import org.whispersystems.textsecuregcm.identity.IdentityType;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import org.whispersystems.textsecuregcm.redis.RedisClusterExtension;
 import org.whispersystems.textsecuregcm.storage.Account;
 import org.whispersystems.textsecuregcm.storage.AccountsManager;
@@ -247,7 +247,7 @@ void testProcessScheduledDelayedNotifications() {
   void testDedicatedProcessDynamicConfiguration(final int dedicatedThreadCount, final boolean expectActivity)
       throws Exception {
 
-    final FaultTolerantRedisCluster redisCluster = mock(FaultTolerantRedisCluster.class);
+    final FaultTolerantRedisClusterClient redisCluster = mock(FaultTolerantRedisClusterClient.class);
     when(redisCluster.withCluster(any())).thenReturn(0L);
 
     final AccountsManager accountsManager = mock(AccountsManager.class);

File: service/src/test/java/org/whispersystems/textsecuregcm/redis/FaultTolerantPubSubClusterConnectionTest.java
Patch:
@@ -40,11 +40,11 @@
 import reactor.core.scheduler.Schedulers;
 import reactor.test.publisher.TestPublisher;
 
-class FaultTolerantPubSubConnectionTest {
+class FaultTolerantPubSubClusterConnectionTest {
 
   private StatefulRedisClusterPubSubConnection<String, String> pubSubConnection;
   private RedisClusterPubSubCommands<String, String> pubSubCommands;
-  private FaultTolerantPubSubConnection<String, String> faultTolerantPubSubConnection;
+  private FaultTolerantPubSubClusterConnection<String, String> faultTolerantPubSubConnection;
 
 
   @SuppressWarnings("unchecked")
@@ -68,7 +68,7 @@ public void setUp() {
         .build();
     final Retry resubscribeRetry = Retry.of("test-resubscribe", resubscribeRetryConfiguration);
 
-    faultTolerantPubSubConnection = new FaultTolerantPubSubConnection<>("test", pubSubConnection,
+    faultTolerantPubSubConnection = new FaultTolerantPubSubClusterConnection<>("test", pubSubConnection,
         retry, resubscribeRetry, Schedulers.newSingle("test"));
   }
 

File: service/src/test/java/org/whispersystems/textsecuregcm/redis/RedisClusterExtension.java
Patch:
@@ -42,7 +42,7 @@ public class RedisClusterExtension implements BeforeAllCallback, BeforeEachCallb
 
   private final Duration timeout;
   private final RetryConfiguration retryConfiguration;
-  private FaultTolerantRedisCluster redisCluster;
+  private FaultTolerantRedisClusterClient redisCluster;
   private ClientResources redisClientResources;
 
   public RedisClusterExtension(final Duration timeout, final RetryConfiguration retryConfiguration) {
@@ -87,7 +87,7 @@ public void beforeEach(final ExtensionContext context) throws Exception {
     redisClientResources = ClientResources.builder().build();
     final CircuitBreakerConfiguration circuitBreakerConfig = new CircuitBreakerConfiguration();
     circuitBreakerConfig.setWaitDurationInOpenState(Duration.ofMillis(500));
-    redisCluster = new FaultTolerantRedisCluster("test-cluster",
+    redisCluster = new FaultTolerantRedisClusterClient("test-cluster",
         redisClientResources.mutate(),
         getRedisURIs(),
         timeout,
@@ -130,7 +130,7 @@ public static List<RedisURI> getRedisURIs() {
         .toList();
   }
 
-  public FaultTolerantRedisCluster getRedisCluster() {
+  public FaultTolerantRedisClusterClient getRedisCluster() {
     return redisCluster;
   }
 

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/AccountsManagerTest.java
Patch:
@@ -77,7 +77,7 @@
 import org.whispersystems.textsecuregcm.identity.IdentityType;
 import org.whispersystems.textsecuregcm.identity.PniServiceIdentifier;
 import org.whispersystems.textsecuregcm.push.ClientPresenceManager;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import org.whispersystems.textsecuregcm.securestorage.SecureStorageClient;
 import org.whispersystems.textsecuregcm.securevaluerecovery.SecureValueRecovery2Client;
 import org.whispersystems.textsecuregcm.securevaluerecovery.SecureValueRecoveryException;
@@ -230,7 +230,7 @@ void setup() throws InterruptedException {
 
     CLOCK = TestClock.now();
 
-    final FaultTolerantRedisCluster redisCluster = RedisClusterHelper.builder()
+    final FaultTolerantRedisClusterClient redisCluster = RedisClusterHelper.builder()
         .stringCommands(commands)
         .stringAsyncCommands(asyncCommands)
         .build();

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/MessagesCacheTest.java
Patch:
@@ -72,7 +72,7 @@
 import org.whispersystems.textsecuregcm.entities.MessageProtos;
 import org.whispersystems.textsecuregcm.identity.AciServiceIdentifier;
 import org.whispersystems.textsecuregcm.identity.ServiceIdentifier;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import org.whispersystems.textsecuregcm.redis.RedisClusterExtension;
 import org.whispersystems.textsecuregcm.tests.util.RedisClusterHelper;
 import reactor.core.publisher.Flux;
@@ -690,7 +690,7 @@ class WithMockCluster {
     void setup() throws Exception {
       reactiveCommands = mock(RedisAdvancedClusterReactiveCommands.class);
       asyncCommands = mock(RedisAdvancedClusterAsyncCommands.class);
-      final FaultTolerantRedisCluster mockCluster = RedisClusterHelper.builder()
+      final FaultTolerantRedisClusterClient mockCluster = RedisClusterHelper.builder()
           .binaryReactiveCommands(reactiveCommands)
           .binaryAsyncCommands(asyncCommands)
           .build();

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/ProfilesManagerTest.java
Patch:
@@ -30,7 +30,7 @@
 import org.signal.libsignal.protocol.ServiceId;
 import org.signal.libsignal.zkgroup.InvalidInputException;
 import org.signal.libsignal.zkgroup.profiles.ProfileKey;
-import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisCluster;
+import org.whispersystems.textsecuregcm.redis.FaultTolerantRedisClusterClient;
 import org.whispersystems.textsecuregcm.tests.util.MockRedisFuture;
 import org.whispersystems.textsecuregcm.tests.util.ProfileTestHelper;
 import org.whispersystems.textsecuregcm.tests.util.RedisClusterHelper;
@@ -50,7 +50,7 @@ void setUp() {
     //noinspection unchecked
     commands = mock(RedisAdvancedClusterCommands.class);
     asyncCommands = mock(RedisAdvancedClusterAsyncCommands.class);
-    final FaultTolerantRedisCluster cacheCluster = RedisClusterHelper.builder()
+    final FaultTolerantRedisClusterClient cacheCluster = RedisClusterHelper.builder()
         .stringCommands(commands)
         .stringAsyncCommands(asyncCommands)
         .build();

File: service/src/main/java/org/whispersystems/textsecuregcm/limits/RateLimiters.java
Patch:
@@ -24,8 +24,8 @@ public enum For implements RateLimiterDescriptor {
     PRE_KEYS("prekeys", false, new RateLimiterConfig(6, Duration.ofMinutes(10))),
     MESSAGES("messages", false, new RateLimiterConfig(60, Duration.ofSeconds(1))),
     STORIES("stories", false, new RateLimiterConfig(5_000, Duration.ofSeconds(8))),
-    ALLOCATE_DEVICE("allocateDevice", false, new RateLimiterConfig(2, Duration.ofMinutes(2))),
-    VERIFY_DEVICE("verifyDevice", false, new RateLimiterConfig(6, Duration.ofMinutes(10))),
+    ALLOCATE_DEVICE("allocateDevice", false, new RateLimiterConfig(6, Duration.ofMinutes(2))),
+    VERIFY_DEVICE("verifyDevice", false, new RateLimiterConfig(6, Duration.ofMinutes(2))),
     TURN("turnAllocate", false, new RateLimiterConfig(60, Duration.ofSeconds(1))),
     PROFILE("profile", false, new RateLimiterConfig(4320, Duration.ofSeconds(20))),
     STICKER_PACK("stickerPack", false, new RateLimiterConfig(50, Duration.ofMinutes(72))),

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/AccountsManager.java
Patch:
@@ -989,14 +989,14 @@ private CompletableFuture<Void> delete(final Account account) {
                     device.getId())))
         .toList();
     CompletableFuture<Void> deleteBackupFuture = secureValueRecovery2Client.deleteBackups(account.getUuid())
-        .exceptionally(exception -> {
+        .exceptionally(ExceptionUtils.exceptionallyHandler(SecureValueRecoveryException.class, exception -> {
           final List<String> svrStatusCodesToIgnore = dynamicConfigurationManager.getConfiguration().getSvrStatusCodesToIgnoreForAccountDeletion();
-          if (exception instanceof SecureValueRecoveryException e && svrStatusCodesToIgnore.contains(e.getStatusCode())) {
+          if (svrStatusCodesToIgnore.contains(exception.getStatusCode())) {
             logger.warn("Failed to delete backup for account: " + account.getUuid(), exception);
             return null;
           }
           throw new CompletionException(exception);
-        });
+        }));
 
     return CompletableFuture.allOf(
             secureStorageClient.deleteStoredData(account.getUuid()),

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -650,7 +650,7 @@ public void run(WhisperServerConfiguration config, Environment environment) thro
         secureStorageClient, secureValueRecovery2Client,
         clientPresenceManager,
         registrationRecoveryPasswordsManager, clientPublicKeysManager, accountLockExecutor, clientPresenceExecutor,
-        clock);
+        clock, dynamicConfigurationManager);
     RemoteConfigsManager remoteConfigsManager = new RemoteConfigsManager(remoteConfigs);
     APNSender apnSender = new APNSender(apnSenderExecutor, config.getApnConfiguration());
     FcmSender fcmSender = new FcmSender(fcmSenderExecutor, config.getFcmConfiguration().credentials().value());

File: service/src/main/java/org/whispersystems/textsecuregcm/securevaluerecovery/SecureValueRecovery2Client.java
Patch:
@@ -72,7 +72,7 @@ public CompletableFuture<Void> deleteBackups(final UUID accountUuid) {
         return null;
       }
 
-      throw new SecureValueRecoveryException("Failed to delete backup: " + response.statusCode());
+      throw new SecureValueRecoveryException("Failed to delete backup", String.valueOf(response.statusCode()));
     });
   }
 

File: service/src/main/java/org/whispersystems/textsecuregcm/workers/CommandDependencies.java
Patch:
@@ -222,7 +222,7 @@ static CommandDependencies build(
         accountLockManager, keys, messagesManager, profilesManager,
         secureStorageClient, secureValueRecovery2Client, clientPresenceManager,
         registrationRecoveryPasswordsManager, clientPublicKeysManager, accountLockExecutor, clientPresenceExecutor,
-        clock);
+        clock, dynamicConfigurationManager);
     RateLimiters rateLimiters = RateLimiters.createAndValidate(configuration.getLimitsConfiguration(),
         dynamicConfigurationManager, rateLimitersCluster);
     final BackupsDb backupsDb =

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/AccountCreationDeletionIntegrationTest.java
Patch:
@@ -152,7 +152,8 @@ void setUp() {
         clientPublicKeysManager,
         accountLockExecutor,
         clientPresenceExecutor,
-        CLOCK);
+        CLOCK,
+        dynamicConfigurationManager);
   }
 
   @AfterEach

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/AccountsManagerChangeNumberIntegrationTest.java
Patch:
@@ -147,7 +147,8 @@ void setup() throws InterruptedException {
           clientPublicKeysManager,
           accountLockExecutor,
           clientPresenceExecutor,
-          mock(Clock.class));
+          mock(Clock.class),
+          dynamicConfigurationManager);
     }
   }
 

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/AccountsManagerConcurrentModificationIntegrationTest.java
Patch:
@@ -134,7 +134,8 @@ void setup() throws InterruptedException {
           mock(ClientPublicKeysManager.class),
           mock(Executor.class),
           mock(Executor.class),
-          mock(Clock.class)
+          mock(Clock.class),
+          dynamicConfigurationManager
       );
     }
   }

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/AccountsManagerUsernameIntegrationTest.java
Patch:
@@ -146,7 +146,8 @@ private void buildAccountsManager(final int initialWidth, int discriminatorMaxWi
         mock(ClientPublicKeysManager.class),
         Executors.newSingleThreadExecutor(),
         Executors.newSingleThreadExecutor(),
-        mock(Clock.class));
+        mock(Clock.class),
+        dynamicConfigurationManager);
   }
 
   @Test

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/AddRemoveDeviceIntegrationTest.java
Patch:
@@ -140,7 +140,8 @@ void setUp() {
         clientPublicKeysManager,
         accountLockExecutor,
         clientPresenceExecutor,
-        CLOCK);
+        CLOCK,
+        dynamicConfigurationManager);
   }
 
   @AfterEach

File: service/src/main/java/org/whispersystems/textsecuregcm/limits/MessageDeliveryLoopMonitor.java
Patch:
@@ -54,7 +54,7 @@ public void recordDeliveryAttempt(final UUID accountIdentifier,
         .thenAccept(deliveryAttemptCount -> {
           if (deliveryAttemptCount == DELIVERY_LOOP_THRESHOLD) {
             logger.warn("Detected loop delivering message {} via {} to {}:{} ({})",
-                messageGuid, accountIdentifier, deviceId, context, userAgent);
+                messageGuid, context, accountIdentifier, deviceId, userAgent);
           }
         });
   }

File: service/src/test/java/org/whispersystems/textsecuregcm/configuration/LocalFaultTolerantRedisClusterFactory.java
Patch:
@@ -22,6 +22,9 @@ private LocalFaultTolerantRedisClusterFactory() {
     try {
       redisClusterExtension.beforeAll(null);
       redisClusterExtension.beforeEach(null);
+
+      redisClusterExtension.getRedisCluster().useCluster(connection ->
+          connection.sync().upstream().commands().configSet("notify-keyspace-events", "K$glz"));
     } catch (final Exception e) {
       throw new RuntimeException(e);
     }

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/SubscriptionManager.java
Patch:
@@ -263,7 +263,7 @@ public <T extends SubscriptionPaymentProcessor, R> CompletableFuture<R> addPayme
           final String customerId = updatedRecord.getProcessorCustomer()
               .filter(pc -> pc.processor().equals(subscriptionPaymentProcessor.getProvider()))
               .orElseThrow(() ->
-                  ExceptionUtils.wrap(new SubscriptionException("record should not be missing customer", null)))
+                  ExceptionUtils.wrap(new SubscriptionException(null, "record should not be missing customer")))
               .customerId();
           return paymentSetupFunction.apply(subscriptionPaymentProcessor, customerId);
         });

File: service/src/main/java/org/whispersystems/textsecuregcm/backup/BackupManager.java
Patch:
@@ -6,6 +6,7 @@
 package org.whispersystems.textsecuregcm.backup;
 
 import com.google.common.annotations.VisibleForTesting;
+import io.dropwizard.util.DataSize;
 import io.grpc.Status;
 import io.micrometer.core.instrument.DistributionSummary;
 import io.micrometer.core.instrument.Metrics;
@@ -47,8 +48,8 @@ public class BackupManager {
   private static final Logger logger = LoggerFactory.getLogger(BackupManager.class);
 
   static final String MESSAGE_BACKUP_NAME = "messageBackup";
-  static final long MAX_TOTAL_BACKUP_MEDIA_BYTES = 1024L * 1024L * 1024L * 50L;
-  static final long MAX_MEDIA_OBJECT_SIZE = 1024L * 1024L * 101L;
+  public static final long MAX_TOTAL_BACKUP_MEDIA_BYTES = DataSize.gibibytes(100).toBytes();
+  static final long MAX_MEDIA_OBJECT_SIZE = DataSize.mebibytes(101).toBytes();
 
   // If the last media usage recalculation is over MAX_QUOTA_STALENESS, force a recalculation before quota enforcement.
   static final Duration MAX_QUOTA_STALENESS = Duration.ofDays(1);

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/KeysController.java
Patch:
@@ -349,7 +349,7 @@ public PreKeyResponse getDeviceKeys(
         throw new NotAuthorizedException(e);
       }
     } else {
-      OptionalAccess.verify(account, accessKey, maybeTarget, deviceId);
+      OptionalAccess.verify(account, accessKey, maybeTarget, targetIdentifier, deviceId);
     }
     final Account target = maybeTarget.orElseThrow(NotFoundException::new);
 

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/MessageController.java
Patch:
@@ -374,7 +374,8 @@ public Response sendMessage(@ReadOnly @Auth Optional<AuthenticatedAccount> sourc
             throw new NotFoundException();
           }
         } else {
-          OptionalAccess.verify(source.map(AuthenticatedAccount::getAccount), accessKey, destination);
+          OptionalAccess.verify(source.map(AuthenticatedAccount::getAccount), accessKey, destination,
+              destinationIdentifier);
         }
 
         boolean needsSync = !isSyncMessage && source.isPresent() && source.get().getAccount().getDevices().size() > 1;

File: service/src/test/java/org/whispersystems/textsecuregcm/controllers/KeysControllerTest.java
Patch:
@@ -38,7 +38,6 @@
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.stream.Stream;
-
 import javax.ws.rs.client.Entity;
 import javax.ws.rs.client.Invocation;
 import javax.ws.rs.core.MediaType;
@@ -51,7 +50,6 @@
 import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
-import org.junit.jupiter.params.provider.EnumSource;
 import org.junit.jupiter.params.provider.MethodSource;
 import org.mockito.ArgumentCaptor;
 import org.signal.libsignal.protocol.IdentityKey;
@@ -227,7 +225,9 @@ void setup() {
     when(sampleDevice4.getId()).thenReturn(sampleDevice4Id);
 
     when(existsAccount.getUuid()).thenReturn(EXISTS_UUID);
+    when(existsAccount.isIdentifiedBy(new AciServiceIdentifier(EXISTS_UUID))).thenReturn(true);
     when(existsAccount.getPhoneNumberIdentifier()).thenReturn(EXISTS_PNI);
+    when(existsAccount.isIdentifiedBy(new PniServiceIdentifier(EXISTS_PNI))).thenReturn(true);
     when(existsAccount.getIdentifier(IdentityType.ACI)).thenReturn(EXISTS_UUID);
     when(existsAccount.getIdentifier(IdentityType.PNI)).thenReturn(EXISTS_PNI);
     when(existsAccount.getDevice(sampleDeviceId)).thenReturn(Optional.of(sampleDevice));

File: service/src/main/java/org/whispersystems/textsecuregcm/grpc/net/ErrorHandler.java
Patch:
@@ -43,6 +43,7 @@ public void exceptionCaught(final ChannelHandlerContext context, final Throwable
         case NoiseHandshakeException e -> ApplicationWebSocketCloseReason.NOISE_HANDSHAKE_ERROR.toWebSocketCloseStatus(e.getMessage());
         case ClientAuthenticationException ignored -> ApplicationWebSocketCloseReason.CLIENT_AUTHENTICATION_ERROR.toWebSocketCloseStatus("Not authenticated");
         case BadPaddingException ignored -> ApplicationWebSocketCloseReason.NOISE_ENCRYPTION_ERROR.toWebSocketCloseStatus("Noise encryption error");
+        case NoiseException ignored -> ApplicationWebSocketCloseReason.NOISE_ENCRYPTION_ERROR.toWebSocketCloseStatus("Noise encryption error");
         default -> {
           log.warn("An unexpected exception reached the end of the pipeline", cause);
           yield WebSocketCloseStatus.INTERNAL_SERVER_ERROR;

File: service/src/test/java/org/whispersystems/textsecuregcm/backup/BackupAuthManagerTest.java
Patch:
@@ -406,9 +406,10 @@ void testRateLimits() {
     when(accountsManager.updateAsync(any(), any())).thenReturn(CompletableFuture.completedFuture(account));
 
     // Should be rate limited
-    CompletableFutureTestUtil.assertFailsWithCause(
+    final RateLimitExceededException ex = CompletableFutureTestUtil.assertFailsWithCause(
         RateLimitExceededException.class,
         authManager.commitBackupId(account, credentialRequest));
+    assertThat(ex.isLegacy()).isFalse();
 
     // If we don't change the request, shouldn't be rate limited
     when(account.getBackupCredentialRequest()).thenReturn(credentialRequest.serialize());

File: service/src/main/java/org/whispersystems/textsecuregcm/auth/AccountAuthenticator.java
Patch:
@@ -108,9 +108,10 @@ public Optional<AuthenticatedAccount> authenticate(BasicCredentials basicCredent
               SaltedTokenHash.generateFor(basicCredentials.getPassword()));  // new credentials have current version
         }
         return Optional.of(new AuthenticatedAccount(authenticatedAccount, device.get()));
+      } else {
+        failureReason = "incorrectPassword";
+        return Optional.empty();
       }
-
-      return Optional.empty();
     } catch (IllegalArgumentException | InvalidAuthorizationHeaderException iae) {
       failureReason = "invalidHeader";
       return Optional.empty();

File: service/src/test/java/org/whispersystems/textsecuregcm/controllers/ArchiveControllerTest.java
Patch:
@@ -541,7 +541,8 @@ public void mediaUploadForm() throws RateLimitExceededException, VerificationFai
     when(backupManager.authenticateBackupUser(any(), any()))
         .thenReturn(CompletableFuture.completedFuture(backupUser(presentation.getBackupId(), BackupLevel.MEDIA)));
     when(backupManager.createTemporaryAttachmentUploadDescriptor(any()))
-        .thenReturn(new BackupUploadDescriptor(3, "abc", Map.of("k", "v"), "example.org"));
+        .thenReturn(CompletableFuture.completedFuture(
+            new BackupUploadDescriptor(3, "abc", Map.of("k", "v"), "example.org")));
     final ArchiveController.UploadDescriptorResponse desc = resources.getJerseyTest()
         .target("v1/archives/media/upload/form")
         .request()
@@ -555,7 +556,7 @@ public void mediaUploadForm() throws RateLimitExceededException, VerificationFai
 
     // rate limit
     when(backupManager.createTemporaryAttachmentUploadDescriptor(any()))
-        .thenThrow(new RateLimitExceededException(null, false));
+        .thenReturn(CompletableFuture.failedFuture(new RateLimitExceededException(null, false)));
     final Response response = resources.getJerseyTest()
         .target("v1/archives/media/upload/form")
         .request()

File: service/src/test/java/org/whispersystems/textsecuregcm/controllers/MessageControllerTest.java
Patch:
@@ -119,6 +119,7 @@
 import org.whispersystems.textsecuregcm.limits.RateLimiter;
 import org.whispersystems.textsecuregcm.limits.RateLimiters;
 import org.whispersystems.textsecuregcm.mappers.RateLimitExceededExceptionMapper;
+import org.whispersystems.textsecuregcm.metrics.MessageMetrics;
 import org.whispersystems.textsecuregcm.providers.MultiRecipientMessageProvider;
 import org.whispersystems.textsecuregcm.push.MessageSender;
 import org.whispersystems.textsecuregcm.push.NotPushRegisteredException;
@@ -212,7 +213,7 @@ class MessageControllerTest {
           new MessageController(rateLimiters, cardinalityEstimator, messageSender, receiptSender, accountsManager,
               messagesManager, pushNotificationManager, reportMessageManager, multiRecipientMessageExecutor,
               messageDeliveryScheduler, ReportSpamTokenProvider.noop(), mock(ClientReleaseManager.class), dynamicConfigurationManager,
-              serverSecretParams, SpamChecker.noop(), clock))
+              serverSecretParams, SpamChecker.noop(), new MessageMetrics(), clock))
       .build();
 
   @BeforeEach

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/AccountsTest.java
Patch:
@@ -1419,7 +1419,7 @@ void testHoldUsername() {
     accounts.reserveUsernameHash(account, USERNAME_HASH_1, Duration.ofDays(1)).join();
     accounts.confirmUsernameHash(account, USERNAME_HASH_1, ENCRYPTED_USERNAME_1).join();
 
-    accounts.clearUsernameHash(account);
+    accounts.clearUsernameHash(account).join();
 
     Account account2 = generateAccount("+18005554321", UUID.randomUUID(), UUID.randomUUID());
     createAccount(account2);

File: service/src/main/java/org/whispersystems/textsecuregcm/util/SystemMapper.java
Patch:
@@ -20,13 +20,15 @@
 import java.util.List;
 import java.util.Objects;
 import javax.annotation.Nonnull;
+import io.dropwizard.jackson.DiscoverableSubtypeResolver;
 import org.whispersystems.textsecuregcm.configuration.secrets.SecretsModule;
 
 public class SystemMapper {
 
   private static final ObjectMapper JSON_MAPPER = configureMapper(new ObjectMapper());
 
-  private static final ObjectMapper YAML_MAPPER = configureMapper(new YAMLMapper());
+  private static final ObjectMapper YAML_MAPPER = configureMapper(new YAMLMapper())
+      .setSubtypeResolver(new DiscoverableSubtypeResolver());
 
 
   @Nonnull

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/ArchiveController.java
Patch:
@@ -311,9 +311,8 @@ public record BackupInfoResponse(
       @Schema(description = "The name of the most recent message backup on the cdn. The backup is at /backupDir/backupName")
       String backupName,
 
-      @Nullable
       @Schema(description = "The amount of space used to store media")
-      Long usedSpace) {}
+      long usedSpace) {}
 
   @GET
   @Produces(MediaType.APPLICATION_JSON)
@@ -345,7 +344,7 @@ public CompletionStage<BackupInfoResponse> backupInfo(
             backupInfo.backupSubdir(),
             backupInfo.mediaSubdir(),
             backupInfo.messageBackupKey(),
-            backupInfo.mediaUsedSpace().orElse(null)));
+            backupInfo.mediaUsedSpace().orElse(0L)));
   }
 
   public record SetPublicKeyRequest(

File: service/src/test/java/org/whispersystems/textsecuregcm/controllers/ArchiveControllerTest.java
Patch:
@@ -337,7 +337,7 @@ public void getBackupInfo() throws VerificationFailedException {
     assertThat(response.backupDir()).isEqualTo("myBackupDir");
     assertThat(response.backupName()).isEqualTo("filename");
     assertThat(response.cdn()).isEqualTo(1);
-    assertThat(response.usedSpace()).isNull();
+    assertThat(response.usedSpace()).isEqualTo(0L);
   }
 
   @Test

File: service/src/main/java/org/whispersystems/textsecuregcm/backup/Cdn3RemoteStorageManager.java
Patch:
@@ -86,6 +86,7 @@ public Cdn3RemoteStorageManager(
         .withConnectTimeout(Duration.ofSeconds(10))
         .withVersion(HttpClient.Version.HTTP_2)
         .withTrustedServerCertificates(cdnCaCertificates.toArray(new String[0]))
+        .withNumClients(configuration.numHttpClients())
         .build();
 
     // Client used for calls to storage-manager
@@ -98,6 +99,7 @@ public Cdn3RemoteStorageManager(
         .withRetry(retryConfiguration)
         .withConnectTimeout(Duration.ofSeconds(10))
         .withVersion(HttpClient.Version.HTTP_2)
+        .withNumClients(configuration.numHttpClients())
         .build();
   }
 
@@ -164,7 +166,7 @@ private HttpRequest createCopyRequest(
 
     if (actualSourceLength != expectedSourceLength) {
       throw new InvalidLengthException(
-              "Provided sourceLength " + expectedSourceLength + " was " + actualSourceLength);
+          "Provided sourceLength " + expectedSourceLength + " was " + actualSourceLength);
     }
 
     final int expectedEncryptedLength = encrypter.outputSize(expectedSourceLength);

File: service/src/test/java/org/whispersystems/textsecuregcm/backup/Cdn3RemoteStorageManagerTest.java
Patch:
@@ -76,7 +76,8 @@ public void init() throws CertificateException {
         new Cdn3StorageManagerConfiguration(
             wireMock.url("storage-manager/"),
             "clientId",
-            new SecretString("clientSecret")));
+            new SecretString("clientSecret"),
+            2));
 
     wireMock.stubFor(get(urlEqualTo("/cdn2/source/small"))
         .willReturn(aResponse()

File: service/src/main/java/org/whispersystems/textsecuregcm/websocket/WebSocketConnection.java
Patch:
@@ -397,6 +397,8 @@ private void measureSendMessageErrors(Throwable e, final boolean terminal) {
       errorType = "closedChannel";
     } else if (e == WebSocketResourceProvider.CONNECTION_CLOSED_EXCEPTION) {
       errorType = "connectionClosed";
+    } else if (e instanceof org.eclipse.jetty.io.EofException) {
+      errorType = "connectionEof";
     } else {
       logger.warn(terminal ? "Send message failure terminated stream" : "Send message failed", e);
       errorType = "other";

File: service/src/main/java/org/whispersystems/textsecuregcm/entities/ChangeNumberRequest.java
Patch:
@@ -68,16 +68,15 @@ Exactly one message must be supplied for each enabled device other than the send
     @Schema(description="the new phone-number-identity registration ID for each enabled device on the account, including this one")
     @NotNull Map<Byte, Integer> pniRegistrationIds) implements PhoneVerificationRequest {
 
-  @AssertTrue
-  public boolean isSignatureValidOnEachSignedPreKey() {
+  public boolean isSignatureValidOnEachSignedPreKey(@Nullable final String userAgent) {
     List<SignedPreKey<?>> spks = new ArrayList<>();
     if (devicePniSignedPrekeys != null) {
       spks.addAll(devicePniSignedPrekeys.values());
     }
     if (devicePniPqLastResortPrekeys != null) {
       spks.addAll(devicePniPqLastResortPrekeys.values());
     }
-    return spks.isEmpty() || PreKeySignatureValidator.validatePreKeySignatures(pniIdentityKey, spks);
+    return spks.isEmpty() || PreKeySignatureValidator.validatePreKeySignatures(pniIdentityKey, spks, userAgent, "change-number");
   }
 
   @AssertTrue

File: service/src/main/java/org/whispersystems/textsecuregcm/entities/PhoneNumberIdentityKeyDistributionRequest.java
Patch:
@@ -11,6 +11,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import javax.annotation.Nullable;
 import javax.validation.Valid;
 import javax.validation.constraints.AssertTrue;
 import javax.validation.constraints.NotNull;
@@ -53,13 +54,12 @@ Exactly one message must be supplied for each enabled device other than the send
     @Schema(description="The new registration ID to use for the phone-number identity of each device, including this one.")
     Map<Byte, Integer> pniRegistrationIds) {
 
-  @AssertTrue
-  public boolean isSignatureValidOnEachSignedPreKey() {
+  public boolean isSignatureValidOnEachSignedPreKey(@Nullable final String userAgent) {
     List<SignedPreKey<?>> spks = new ArrayList<>(devicePniSignedPrekeys.values());
     if (devicePniPqLastResortPrekeys != null) {
       spks.addAll(devicePniPqLastResortPrekeys.values());
     }
-    return spks.isEmpty() || PreKeySignatureValidator.validatePreKeySignatures(pniIdentityKey, spks);
+    return spks.isEmpty() || PreKeySignatureValidator.validatePreKeySignatures(pniIdentityKey, spks, userAgent, "distribute-pni-keys");
   }
 
 }

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -700,7 +700,7 @@ public void run(WhisperServerConfiguration config, Environment environment) thro
     ServerZkReceiptOperations zkReceiptOperations = new ServerZkReceiptOperations(zkSecretParams);
 
     Cdn3BackupCredentialGenerator cdn3BackupCredentialGenerator = new Cdn3BackupCredentialGenerator(config.getTus());
-    BackupAuthManager backupAuthManager = new BackupAuthManager(dynamicConfigurationManager, rateLimiters, accountsManager, backupsGenericZkSecretParams, clock);
+    BackupAuthManager backupAuthManager = new BackupAuthManager(experimentEnrollmentManager, rateLimiters, accountsManager, backupsGenericZkSecretParams, clock);
     BackupsDb backupsDb = new BackupsDb(
         dynamoDbAsyncClient,
         config.getDynamoDbTables().getBackups().getTableName(),

File: service/src/main/java/org/whispersystems/textsecuregcm/entities/AnswerChallengeRequest.java
Patch:
@@ -11,6 +11,7 @@
 @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")
 @JsonSubTypes({
     @JsonSubTypes.Type(value = AnswerPushChallengeRequest.class, name = "rateLimitPushChallenge"),
+    @JsonSubTypes.Type(value = AnswerRecaptchaChallengeRequest.class, name = "captcha"),
     @JsonSubTypes.Type(value = AnswerRecaptchaChallengeRequest.class, name = "recaptcha")
 })
 public abstract class AnswerChallengeRequest {

File: websocket-resources/src/main/java/org/whispersystems/websocket/WebSocketResourceProvider.java
Patch:
@@ -264,7 +264,7 @@ private void sendResponse(WebSocketRequestMessage requestMessage, ContainerRespo
       ByteArrayOutputStream responseBody) throws IOException {
     if (requestMessage.hasRequestId()) {
       byte[] body = responseBody.toByteArray();
-
+      response.getHeaders().putIfAbsent(HttpHeaders.CONTENT_LENGTH, List.of(body.length));
       if (body.length <= 0) {
         body = null;
       }

File: websocket-resources/src/test/java/org/whispersystems/websocket/WebSocketResourceProviderTest.java
Patch:
@@ -137,6 +137,7 @@ public String getReasonPhrase() {
         return "OK";
       }
     });
+    when(response.getHeaders()).thenReturn(new MultivaluedHashMap<>());
 
     ArgumentCaptor<OutputStream> responseOutputStream = ArgumentCaptor.forClass(OutputStream.class);
 

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/KeysController.java
Patch:
@@ -254,7 +254,7 @@ private void checkSignedPreKeySignatures(final SetKeysRequest setKeysRequest, fi
     not be found
   """)
   @ApiResponse(responseCode = "422", description = "Invalid request format")
-  public CompletableFuture<Response> setKeys(
+  public CompletableFuture<Response> checkKeys(
       @ReadOnly @Auth final AuthenticatedAccount auth,
       @RequestBody @NotNull @Valid final CheckKeysRequest checkKeysRequest,
       @HeaderParam(HttpHeaders.USER_AGENT) final String userAgent) {

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/KeysController.java
Patch:
@@ -288,7 +288,7 @@ public PreKeyResponse getDeviceKeys(@Auth Optional<AuthenticatedAccount> auth,
                         Tag.of("targetPlatform", getDevicePlatform(device).map(Enum::name).orElse("unknown")),
                         Tag.of(IDENTITY_TYPE_TAG_NAME, targetIdentifier.identityType().name()),
                         Tag.of("isStale", String.valueOf(isDeviceStale(device))),
-                        Tag.of("oneTimeEcKeyAvailable", String.valueOf(unsignedEcPreKey == null))))
+                        Tag.of("oneTimeEcKeyAvailable", String.valueOf(unsignedEcPreKey != null))))
                     .increment();
 
                 if (signedEcPreKey != null || unsignedEcPreKey != null || pqPreKey != null) {

File: service/src/main/java/org/whispersystems/textsecuregcm/configuration/RedisClusterConfiguration.java
Patch:
@@ -20,7 +20,7 @@ public class RedisClusterConfiguration {
 
   @JsonProperty
   @NotNull
-  private Duration timeout = Duration.ofMillis(3_000);
+  private Duration timeout = Duration.ofSeconds(1);
 
   @JsonProperty
   @NotNull

File: service/src/main/java/org/whispersystems/textsecuregcm/configuration/RedisConfiguration.java
Patch:
@@ -20,7 +20,7 @@ public class RedisConfiguration {
 
   @JsonProperty
   @NotNull
-  private Duration timeout = Duration.ofSeconds(10);
+  private Duration timeout = Duration.ofSeconds(1);
 
   @JsonProperty
   @NotNull

File: service/src/main/java/org/whispersystems/textsecuregcm/calls/routing/CallRoutingTableManager.java
Patch:
@@ -50,7 +50,7 @@ public CallRoutingTableManager(
 
     this.tableTag = tableTag;
     this.routingTable.set(CallRoutingTable.empty());
-    this.refreshTimer = Metrics.timer(MetricsUtil.name(CallRoutingTableManager.class), tableTag);
+    this.refreshTimer = Metrics.timer(MetricsUtil.name(CallRoutingTableManager.class, tableTag));
   }
 
   private void handleDatabaseChanged(final InputStream inputStream) {

File: service/src/main/java/org/whispersystems/textsecuregcm/calls/routing/CallDnsRecordsManager.java
Patch:
@@ -53,7 +53,7 @@ public CallDnsRecordsManager(
     );
 
     this.callDnsRecords.set(CallDnsRecords.empty());
-    this.refreshTimer = Metrics.timer(MetricsUtil.name(CallDnsRecordsManager.class), "refresh");
+    this.refreshTimer = Metrics.timer(MetricsUtil.name(CallDnsRecordsManager.class, "refresh"));
   }
 
   private void handleDatabaseChanged(final InputStream inputStream) {

File: service/src/main/java/org/whispersystems/textsecuregcm/metrics/MetricsUtil.java
Patch:
@@ -76,15 +76,14 @@ public DistributionStatisticConfig configure(final Meter.Id id, final Distributi
             return defaultDistributionStatisticConfig.merge(config);
           }
         })
-        // Remove high-cardinality `command` and `remote` tags from Lettuce metrics and prepend "chat." to meter names
+        // Remove high-cardinality `command` tags from Lettuce metrics and prepend "chat." to meter names
         .meterFilter(new MeterFilter() {
           @Override
           public Meter.Id map(final Meter.Id id) {
             if (id.getName().startsWith("lettuce")) {
               return id.withName(PREFIX + "." + id.getName())
                   .replaceTags(id.getTags().stream()
                       .filter(tag -> !"command".equals(tag.getKey()))
-                      .filter(tag -> !"remote".equals(tag.getKey()))
                       .toList());
             }
 

File: service/src/test/java/org/whispersystems/textsecuregcm/metrics/MetricsUtilTest.java
Patch:
@@ -37,7 +37,6 @@ void lettuceTagRejection() {
     Meter meter = meters.get(0);
     assertThat(meter.getId().getName()).isEqualTo("chat.lettuce.command.completion.max");
     assertThat(meter.getId().getTag("command")).isNull();
-    assertThat(meter.getId().getTag("remote")).isNull();
     assertThat(meter.getId().getTag("allowed")).isNotNull();
   }
 }

File: service/src/test/java/org/whispersystems/textsecuregcm/identity/AciServiceIdentifierTest.java
Patch:
@@ -53,11 +53,12 @@ void valueOf() {
     final UUID uuid = UUID.randomUUID();
 
     assertEquals(uuid, AciServiceIdentifier.valueOf(uuid.toString()).uuid());
-    assertEquals(uuid, AciServiceIdentifier.valueOf("ACI:" + uuid).uuid());
     assertThrows(IllegalArgumentException.class, () -> AciServiceIdentifier.valueOf("Not a valid UUID"));
     assertThrows(IllegalArgumentException.class, () -> AciServiceIdentifier.valueOf("PNI:" + uuid));
+    assertThrows(IllegalArgumentException.class, () -> AciServiceIdentifier.valueOf("ACI:" + uuid).uuid());
   }
 
+
   @Test
   void fromBytes() {
     final UUID uuid = UUID.randomUUID();

File: service/src/test/java/org/whispersystems/textsecuregcm/identity/ServiceIdentifierTest.java
Patch:
@@ -32,12 +32,11 @@ private static Stream<Arguments> valueOf() {
 
     return Stream.of(
         Arguments.of(uuid.toString(), IdentityType.ACI, uuid),
-        Arguments.of("ACI:" + uuid, IdentityType.ACI, uuid),
         Arguments.of("PNI:" + uuid, IdentityType.PNI, uuid));
   }
 
   @ParameterizedTest
-  @ValueSource(strings = {"Not a valid UUID", "BAD:a9edc243-3e93-45d4-95c6-e3a84cd4a254"})
+  @ValueSource(strings = {"Not a valid UUID", "BAD:a9edc243-3e93-45d4-95c6-e3a84cd4a254", "ACI:a9edc243-3e93-45d4-95c6-e3a84cd4a254"})
   void valueOfIllegalArgument(final String identifierString) {
     assertThrows(IllegalArgumentException.class, () -> ServiceIdentifier.valueOf(identifierString));
   }

File: service/src/main/java/org/whispersystems/textsecuregcm/auth/ExternalServiceCredentialsGenerator.java
Patch:
@@ -154,7 +154,7 @@ public Optional<String> identityFromSignature(final String password) {
 
   /**
    * Given an instance of {@link ExternalServiceCredentials} object, checks that the password
-   * matches the username taking into accound this generator's configuration.
+   * matches the username taking into account this generator's configuration.
    * @param credentials an instance of {@link ExternalServiceCredentials}
    * @return An optional with a timestamp (seconds) of when the credentials were generated,
    *         or an empty optional if the password doesn't match the username for any reason (including malformed data)

File: service/src/main/java/org/whispersystems/textsecuregcm/grpc/ConvertibleToGrpcStatus.java
Patch:
@@ -10,7 +10,7 @@
 import java.util.Optional;
 
 /**
- * Interface to be imlemented by our custom exceptions that are consistently mapped to a gRPC status.
+ * Interface to be implemented by our custom exceptions that are consistently mapped to a gRPC status.
  */
 public interface ConvertibleToGrpcStatus {
 

File: service/src/main/java/org/whispersystems/textsecuregcm/grpc/validators/ExactlySizeFieldValidator.java
Patch:
@@ -36,7 +36,7 @@ protected void validateBytesValue(
     if (permittedSizes.contains(fieldValue.size())) {
       return;
     }
-    throw invalidArgument("byte arrray length is [%d] but expected to be one of %s".formatted(fieldValue.size(), permittedSizes));
+    throw invalidArgument("byte array length is [%d] but expected to be one of %s".formatted(fieldValue.size(), permittedSizes));
   }
 
   @Override

File: service/src/main/java/org/whispersystems/textsecuregcm/backup/BackupManager.java
Patch:
@@ -198,13 +198,13 @@ public CompletableFuture<Boolean> canStoreMedia(final AuthenticatedBackupUser ba
           return this.remoteStorageManager.calculateBytesUsed(mediaPrefix)
               .thenCompose(usage -> backupsDb
                   .setMediaUsage(backupUser, usage)
-                  .thenApply(ignored -> usage.bytesUsed()))
+                  .thenApply(ignored -> usage))
               .whenComplete((newUsage, throwable) -> {
                 boolean usageChanged = throwable == null && !newUsage.equals(info.usageInfo());
                 Metrics.counter(USAGE_RECALCULATION_COUNTER_NAME, "usageChanged", String.valueOf(usageChanged))
                     .increment();
               })
-              .thenApply(usedSpace -> MAX_TOTAL_BACKUP_MEDIA_BYTES - usedSpace >= mediaLength);
+              .thenApply(newUsage -> MAX_TOTAL_BACKUP_MEDIA_BYTES - newUsage.bytesUsed() >= mediaLength);
         });
   }
 

File: service/src/main/java/org/whispersystems/textsecuregcm/backup/BackupManager.java
Patch:
@@ -335,7 +335,7 @@ public CompletionStage<ListMediaResult> list(
           .withDescription("credential does not support list operation")
           .asRuntimeException();
     }
-    final String mediaPrefix = "%s/%s/".formatted(MEDIA_DIRECTORY_NAME, encodeBackupIdForCdn(backupUser));
+    final String mediaPrefix = "%s/%s/".formatted(encodeBackupIdForCdn(backupUser), MEDIA_DIRECTORY_NAME);
     return remoteStorageManager.list(mediaPrefix, cursor, limit)
         .thenApply(result ->
             new ListMediaResult(

File: service/src/main/java/org/whispersystems/textsecuregcm/backup/Cdn3RemoteStorageManager.java
Patch:
@@ -65,7 +65,7 @@ public Cdn3RemoteStorageManager(
     // strip trailing "/" for easier URI construction
     this.storageManagerBaseUrl = StringUtils.removeEnd(configuration.baseUri(), "/");
     this.clientId = configuration.clientId();
-    this.clientSecret = configuration.clientSecret();
+    this.clientSecret = configuration.clientSecret().value();
 
     // Client used to read/write to cdn
     this.cdnHttpClient = FaultTolerantHttpClient.newBuilder()

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/MessageController.java
Patch:
@@ -461,7 +461,7 @@ public Response sendMultiRecipientMessage(
       if (accessKeys != null) {
         throw new BadRequestException("Only one of group send credential and unidentified access key may be provided");
       } else if (isStory) {
-        throw new BadRequestExcpetion("Stories should not provide a group send credential");
+        throw new BadRequestException("Stories should not provide a group send credential");
       }
     }
 

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -844,7 +844,7 @@ public void run(WhisperServerConfiguration config, Environment environment) thro
             config.getCdnConfiguration().bucket()),
         new VerificationController(registrationServiceClient, new VerificationSessionManager(verificationSessions),
             pushNotificationManager, registrationCaptchaManager, registrationRecoveryPasswordsManager, rateLimiters,
-            accountsManager, useRemoteAddress, clock)
+            accountsManager, useRemoteAddress, dynamicConfigurationManager, clock)
     );
     if (config.getSubscription() != null && config.getOneTimeDonations() != null) {
       commonControllers.add(new SubscriptionController(clock, config.getSubscription(), config.getOneTimeDonations(),

File: service/src/main/java/org/whispersystems/textsecuregcm/registration/RegistrationServiceClient.java
Patch:
@@ -146,6 +146,9 @@ public CompletableFuture<RegistrationServiceSession> sendVerificationCode(final
 
               case SEND_VERIFICATION_CODE_ERROR_TYPE_SENDER_REJECTED -> throw new CompletionException(
                   RegistrationServiceSenderException.rejected(response.getError().getMayRetry()));
+              case SEND_VERIFICATION_CODE_ERROR_TYPE_SUSPECTED_FRAUD ->
+                  throw new CompletionException(new RegistrationFraudException(
+                      RegistrationServiceSenderException.rejected(response.getError().getMayRetry())));
               case SEND_VERIFICATION_CODE_ERROR_TYPE_SENDER_ILLEGAL_ARGUMENT -> throw new CompletionException(
                   RegistrationServiceSenderException.illegalArgument(response.getError().getMayRetry()));
               case SEND_VERIFICATION_CODE_ERROR_TYPE_UNSPECIFIED -> throw new CompletionException(

File: service/src/test/java/org/whispersystems/textsecuregcm/controllers/KeysControllerTest.java
Patch:
@@ -217,6 +217,8 @@ void setup() {
 
     when(existsAccount.getUuid()).thenReturn(EXISTS_UUID);
     when(existsAccount.getPhoneNumberIdentifier()).thenReturn(EXISTS_PNI);
+    when(existsAccount.getIdentifier(IdentityType.ACI)).thenReturn(EXISTS_UUID);
+    when(existsAccount.getIdentifier(IdentityType.PNI)).thenReturn(EXISTS_PNI);
     when(existsAccount.getDevice(sampleDeviceId)).thenReturn(Optional.of(sampleDevice));
     when(existsAccount.getDevice(sampleDevice2Id)).thenReturn(Optional.of(sampleDevice2));
     when(existsAccount.getDevice(sampleDevice3Id)).thenReturn(Optional.of(sampleDevice3));

File: service/src/test/java/org/whispersystems/textsecuregcm/tests/util/AccountsHelper.java
Patch:
@@ -119,6 +119,7 @@ private static Account copyAndMarkStale(Account account) throws IOException {
         switch (stubbing.getInvocation().getMethod().getName()) {
           case "getUuid" -> when(updatedAccount.getUuid()).thenAnswer(stubbing);
           case "getPhoneNumberIdentifier" -> when(updatedAccount.getPhoneNumberIdentifier()).thenAnswer(stubbing);
+          case "getIdentifier" -> when(updatedAccount.getIdentifier(stubbing.getInvocation().getArgument(0))).thenAnswer(stubbing);
           case "isIdentifiedBy" -> when(updatedAccount.isIdentifiedBy(stubbing.getInvocation().getArgument(0))).thenAnswer(stubbing);
           case "getNumber" -> when(updatedAccount.getNumber()).thenAnswer(stubbing);
           case "getUsername" -> when(updatedAccount.getUsernameHash()).thenAnswer(stubbing);

File: service/src/main/java/org/whispersystems/textsecuregcm/limits/PushChallengeManager.java
Patch:
@@ -88,9 +88,9 @@ public boolean answerChallenge(final Account account, final String challengeToke
 
     final String platform = account.getPrimaryDevice().map(primaryDevice -> {
       if (StringUtils.isNotBlank(primaryDevice.getGcmId())) {
-        return ClientPlatform.IOS.name().toLowerCase();
-      } else if (StringUtils.isNotBlank(primaryDevice.getApnId())) {
         return ClientPlatform.ANDROID.name().toLowerCase();
+      } else if (StringUtils.isNotBlank(primaryDevice.getApnId())) {
+        return ClientPlatform.IOS.name().toLowerCase();
       } else {
         return "unknown";
       }

File: service/src/test/java/org/whispersystems/textsecuregcm/controllers/SubscriptionControllerTest.java
Patch:
@@ -769,10 +769,10 @@ void testGetBankMandate() {
 
   @Test
   void testGetBankMandateInvalidBankTransferType() {
-    final Response response = RESOURCE_EXTENSION.target("/v1/subscription/ach")
+    final Response response = RESOURCE_EXTENSION.target("/v1/subscription/bank_mandate/ach")
         .request()
         .get();
-    assertThat(response.getStatus()).isEqualTo(404);
+    assertThat(response.getStatus()).isEqualTo(400);
   }
 
   @ParameterizedTest

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/AccountsManager.java
Patch:
@@ -250,9 +250,7 @@ public Account create(final String number,
         final Tags tags;
 
         if (freshUser) {
-          tags = Tags.of("type", "new");
-        } else if (maybeRecentlyDeletedAccountIdentifier.isPresent()) {
-          tags = Tags.of("type", "recently-deleted");
+          tags = Tags.of("type", maybeRecentlyDeletedAccountIdentifier.isPresent() ? "recently-deleted" : "new");
         } else {
           tags = Tags.of("type", "re-registration");
         }

File: integration-tests/src/test/java/org/signal/integration/AccountTest.java
Patch:
@@ -22,6 +22,7 @@
 import org.whispersystems.textsecuregcm.entities.ReserveUsernameHashRequest;
 import org.whispersystems.textsecuregcm.entities.ReserveUsernameHashResponse;
 import org.whispersystems.textsecuregcm.entities.UsernameHashResponse;
+import org.whispersystems.textsecuregcm.identity.AciServiceIdentifier;
 
 public class AccountTest {
 
@@ -107,7 +108,7 @@ private static void verifyFullUsernameLifecycle(final TestUser user) throws Base
     final AccountIdentifierResponse accountIdentifierResponse = Operations
         .apiGet("/v1/accounts/username_hash/" + Base64.getUrlEncoder().encodeToString(reservedHash))
         .executeExpectSuccess(AccountIdentifierResponse.class);
-    assertEquals(user.aciUuid(), accountIdentifierResponse.uuid());
+    assertEquals(new AciServiceIdentifier(user.aciUuid()), accountIdentifierResponse.uuid());
     // try authorized
     Operations
         .apiGet("/v1/accounts/username_hash/" + Base64.getUrlEncoder().encodeToString(reservedHash))

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -140,6 +140,7 @@
 import org.whispersystems.textsecuregcm.mappers.RateLimitExceededExceptionMapper;
 import org.whispersystems.textsecuregcm.mappers.RegistrationServiceSenderExceptionMapper;
 import org.whispersystems.textsecuregcm.mappers.ServerRejectedExceptionMapper;
+import org.whispersystems.textsecuregcm.mappers.SubscriptionProcessorExceptionMapper;
 import org.whispersystems.textsecuregcm.metrics.MetricsApplicationEventListener;
 import org.whispersystems.textsecuregcm.metrics.MetricsUtil;
 import org.whispersystems.textsecuregcm.metrics.ReportedMessageMetricsListener;
@@ -858,6 +859,7 @@ private void registerExceptionMappers(Environment environment,
         new ImpossiblePhoneNumberExceptionMapper(),
         new NonNormalizedPhoneNumberExceptionMapper(),
         new RegistrationServiceSenderExceptionMapper(),
+        new SubscriptionProcessorExceptionMapper(),
         new JsonMappingExceptionMapper()
     ).forEach(exceptionMapper -> {
       environment.jersey().register(exceptionMapper);

File: service/src/main/java/org/whispersystems/textsecuregcm/spam/RateLimitChallengeListener.java
Patch:
@@ -11,7 +11,7 @@
 
 public interface RateLimitChallengeListener {
 
-  void handleRateLimitChallengeAnswered(Account account);
+  void handleRateLimitChallengeAnswered(Account account, ChallengeType type);
 
   /**
    * Configures this rate limit challenge listener. This method will be called before the service begins processing any

File: service/src/test/java/org/whispersystems/textsecuregcm/limits/RateLimitChallengeManagerTest.java
Patch:
@@ -21,6 +21,7 @@
 import org.whispersystems.textsecuregcm.captcha.AssessmentResult;
 import org.whispersystems.textsecuregcm.captcha.CaptchaChecker;
 import org.whispersystems.textsecuregcm.controllers.RateLimitExceededException;
+import org.whispersystems.textsecuregcm.spam.ChallengeType;
 import org.whispersystems.textsecuregcm.spam.RateLimitChallengeListener;
 import org.whispersystems.textsecuregcm.storage.Account;
 
@@ -63,7 +64,7 @@ void answerPushChallenge(final boolean successfulChallenge) throws RateLimitExce
     rateLimitChallengeManager.answerPushChallenge(account, "challenge");
 
     if (successfulChallenge) {
-      verify(rateLimitChallengeListener).handleRateLimitChallengeAnswered(account);
+      verify(rateLimitChallengeListener).handleRateLimitChallengeAnswered(account, ChallengeType.PUSH);
     } else {
       verifyNoInteractions(rateLimitChallengeListener);
     }
@@ -88,7 +89,7 @@ void answerRecaptchaChallenge(final boolean successfulChallenge) throws RateLimi
     rateLimitChallengeManager.answerRecaptchaChallenge(account, "captcha", "10.0.0.1", "Test User-Agent");
 
     if (successfulChallenge) {
-      verify(rateLimitChallengeListener).handleRateLimitChallengeAnswered(account);
+      verify(rateLimitChallengeListener).handleRateLimitChallengeAnswered(account, ChallengeType.CAPTCHA);
     } else {
       verifyNoInteractions(rateLimitChallengeListener);
     }

File: service/src/main/java/org/whispersystems/textsecuregcm/captcha/ShortCodeExpander.java
Patch:
@@ -28,7 +28,7 @@ public ShortCodeExpander(final HttpClient client, final String shortenerHost) {
   }
 
   public Optional<String> retrieve(final String shortCode) throws IOException {
-    final URI uri = shortenerHost.resolve("/" + shortCode);
+    final URI uri = shortenerHost.resolve(shortCode);
     final HttpRequest request = HttpRequest.newBuilder().uri(uri).GET().build();
 
     try {

File: service/src/test/java/org/whispersystems/textsecuregcm/grpc/KeysAnonymousGrpcServiceTest.java
Patch:
@@ -152,7 +152,7 @@ void getPreKeysIncorrectUnidentifiedAccessKey() {
     when(accountsManager.getByServiceIdentifierAsync(new AciServiceIdentifier(identifier)))
         .thenReturn(CompletableFuture.completedFuture(Optional.of(targetAccount)));
 
-    @SuppressWarnings("ResultOfMethodCallIgnored") final StatusRuntimeException statusRuntimeException =
+    final StatusRuntimeException statusRuntimeException =
         assertThrows(StatusRuntimeException.class,
             () -> keysAnonymousStub.getPreKeys(GetPreKeysAnonymousRequest.newBuilder()
                 .setRequest(GetPreKeysRequest.newBuilder()
@@ -172,7 +172,7 @@ void getPreKeysAccountNotFound() {
     when(accountsManager.getByServiceIdentifierAsync(any()))
         .thenReturn(CompletableFuture.completedFuture(Optional.empty()));
 
-    @SuppressWarnings("ResultOfMethodCallIgnored") final StatusRuntimeException exception =
+    final StatusRuntimeException exception =
         assertThrows(StatusRuntimeException.class,
             () -> keysAnonymousStub.getPreKeys(GetPreKeysAnonymousRequest.newBuilder()
                 .setUnidentifiedAccessKey(UUIDUtil.toByteString(UUID.randomUUID()))
@@ -205,7 +205,7 @@ void getPreKeysDeviceNotFound(final long deviceId) {
     when(accountsManager.getByServiceIdentifierAsync(new AciServiceIdentifier(accountIdentifier)))
         .thenReturn(CompletableFuture.completedFuture(Optional.of(targetAccount)));
 
-    @SuppressWarnings("ResultOfMethodCallIgnored") final StatusRuntimeException exception =
+    final StatusRuntimeException exception =
         assertThrows(StatusRuntimeException.class,
             () -> keysAnonymousStub.getPreKeys(GetPreKeysAnonymousRequest.newBuilder()
                 .setUnidentifiedAccessKey(ByteString.copyFrom(unidentifiedAccessKey))

File: integration-tests/src/main/java/org/signal/integration/Operations.java
Patch:
@@ -77,7 +77,7 @@ public static TestUser newRegisteredUser(final String number) {
 
     // register account
     final RegistrationRequest registrationRequest = new RegistrationRequest(
-        null, registrationPassword, accountAttributes, true,
+        null, registrationPassword, accountAttributes, true, false,
         Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
 
     final AccountIdentityResponse registrationResponse = apiPost("/v1/registration", registrationRequest)
@@ -113,6 +113,7 @@ public static TestUser newRegisteredUserAtomic(final String number) {
         registrationPassword,
         accountAttributes,
         true,
+        true,
         Optional.of(new IdentityKey(aciIdentityKeyPair.getPublicKey())),
         Optional.of(new IdentityKey(pniIdentityKeyPair.getPublicKey())),
         Optional.of(generateSignedECPreKey(1, aciIdentityKeyPair)),

File: service/src/main/java/org/whispersystems/textsecuregcm/push/ProvisioningManager.java
Patch:
@@ -19,12 +19,12 @@
 import io.lettuce.core.pubsub.StatefulRedisPubSubConnection;
 import io.lettuce.core.resource.ClientResources;
 import io.micrometer.core.instrument.Metrics;
+import io.micrometer.core.instrument.Tags;
 import java.nio.charset.StandardCharsets;
 import java.time.Duration;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
-import io.micrometer.core.instrument.Tags;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.whispersystems.textsecuregcm.configuration.CircuitBreakerConfiguration;
@@ -71,6 +71,7 @@ public ProvisioningManager(final String redisUri,
       final CircuitBreakerConfiguration circuitBreakerConfiguration) {
 
     this.redisClient = redisClient;
+    this.redisClient.setDefaultTimeout(timeout);
 
     this.subscriptionConnection = redisClient.connectPubSub(new ByteArrayCodec());
     this.publicationConnection = redisClient.connect(new ByteArrayCodec());

File: integration-tests/src/main/java/org/signal/integration/Operations.java
Patch:
@@ -311,6 +311,7 @@ private static FaultTolerantHttpClient buildClient() {
       return FaultTolerantHttpClient.newBuilder()
           .withName("integration-test")
           .withExecutor(Executors.newFixedThreadPool(16))
+          .withRetryExecutor(Executors.newSingleThreadScheduledExecutor())
           .withCircuitBreaker(new CircuitBreakerConfiguration())
           .withTrustedServerCertificates(CONFIG.rootCert())
           .build();

File: service/src/main/java/org/whispersystems/textsecuregcm/auth/TurnTokenGenerator.java
Patch:
@@ -18,10 +18,11 @@
 import java.security.InvalidKeyException;
 import java.security.NoSuchAlgorithmException;
 import java.security.SecureRandom;
+import java.time.Duration;
+import java.time.Instant;
 import java.util.Base64;
 import java.util.List;
 import java.util.Optional;
-import java.util.concurrent.TimeUnit;
 
 public class TurnTokenGenerator {
 
@@ -38,7 +39,7 @@ public TurnToken generate(final String e164) {
       final byte[] key = dynamicConfiguration.getConfiguration().getTurnConfiguration().getSecret().getBytes();
       final List<String> urls = urls(e164);
       final Mac mac = Mac.getInstance(ALGORITHM);
-      final long validUntilSeconds = (System.currentTimeMillis() + TimeUnit.DAYS.toMillis(1)) / 1000;
+      final long validUntilSeconds = Instant.now().plus(Duration.ofDays(1)).getEpochSecond();
       final long user = Util.ensureNonNegativeInt(new SecureRandom().nextInt());
       final String userTime = validUntilSeconds + ":" + user;
 

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/SingleUsePreKeyStore.java
Patch:
@@ -47,7 +47,7 @@
  * the event that a party wants to begin a session with a device that has no single-use pre-keys remaining, that party
  * may fall back to using the device's repeated-use ("last-resort") signed pre-key instead.
  */
-public abstract class SingleUsePreKeyStore<K extends PreKey> {
+public abstract class SingleUsePreKeyStore<K extends PreKey<?>> {
 
   private final DynamoDbAsyncClient dynamoDbAsyncClient;
   private final String tableName;

File: service/src/test/java/org/whispersystems/textsecuregcm/controllers/MessageControllerTest.java
Patch:
@@ -74,6 +74,7 @@
 import org.whispersystems.textsecuregcm.auth.AuthenticatedAccount;
 import org.whispersystems.textsecuregcm.auth.DisabledPermittedAuthenticatedAccount;
 import org.whispersystems.textsecuregcm.auth.OptionalAccess;
+import org.whispersystems.textsecuregcm.entities.ECSignedPreKey;
 import org.whispersystems.textsecuregcm.entities.IncomingMessage;
 import org.whispersystems.textsecuregcm.entities.IncomingMessageList;
 import org.whispersystems.textsecuregcm.entities.MessageProtos;
@@ -84,7 +85,6 @@
 import org.whispersystems.textsecuregcm.entities.OutgoingMessageEntity;
 import org.whispersystems.textsecuregcm.entities.OutgoingMessageEntityList;
 import org.whispersystems.textsecuregcm.entities.SendMultiRecipientMessageResponse;
-import org.whispersystems.textsecuregcm.entities.SignedPreKey;
 import org.whispersystems.textsecuregcm.entities.SpamReport;
 import org.whispersystems.textsecuregcm.entities.StaleDevices;
 import org.whispersystems.textsecuregcm.limits.RateLimiter;
@@ -194,7 +194,7 @@ void setup() {
     when(rateLimiters.getMessagesLimiter()).thenReturn(rateLimiter);
   }
 
-  private static Device generateTestDevice(final long id, final int registrationId, final int pniRegistrationId, final SignedPreKey signedPreKey, final long createdAt, final long lastSeen) {
+  private static Device generateTestDevice(final long id, final int registrationId, final int pniRegistrationId, final ECSignedPreKey signedPreKey, final long createdAt, final long lastSeen) {
     final Device device = new Device();
     device.setId(id);
     device.setRegistrationId(registrationId);

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/AccountsTest.java
Patch:
@@ -1023,9 +1023,7 @@ private void verifyStoredState(String number, UUID uuid, UUID pni, byte[] userna
       assertThat(resultDevice.getApnId()).isEqualTo(expectingDevice.getApnId());
       assertThat(resultDevice.getGcmId()).isEqualTo(expectingDevice.getGcmId());
       assertThat(resultDevice.getLastSeen()).isEqualTo(expectingDevice.getLastSeen());
-      assertThat(resultDevice.getSignedPreKey().getPublicKey()).isEqualTo(expectingDevice.getSignedPreKey().getPublicKey());
-      assertThat(resultDevice.getSignedPreKey().getKeyId()).isEqualTo(expectingDevice.getSignedPreKey().getKeyId());
-      assertThat(resultDevice.getSignedPreKey().getSignature()).isEqualTo(expectingDevice.getSignedPreKey().getSignature());
+      assertThat(resultDevice.getSignedPreKey()).isEqualTo(expectingDevice.getSignedPreKey());
       assertThat(resultDevice.getFetchesMessages()).isEqualTo(expectingDevice.getFetchesMessages());
       assertThat(resultDevice.getUserAgent()).isEqualTo(expectingDevice.getUserAgent());
       assertThat(resultDevice.getName()).isEqualTo(expectingDevice.getName());

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/SingleUsePreKeyStoreTest.java
Patch:
@@ -24,7 +24,7 @@
 import software.amazon.awssdk.core.SdkBytes;
 import software.amazon.awssdk.services.dynamodb.model.AttributeValue;
 
-abstract class SingleUsePreKeyStoreTest<K extends PreKey> {
+abstract class SingleUsePreKeyStoreTest<K extends PreKey<?>> {
 
   private static final int KEY_COUNT = 100;
 

File: service/src/test/java/org/whispersystems/textsecuregcm/tests/entities/PreKeyTest.java
Patch:
@@ -12,7 +12,8 @@
 import static org.whispersystems.textsecuregcm.tests.util.JsonHelpers.jsonFixture;
 
 import org.junit.jupiter.api.Test;
-import org.whispersystems.textsecuregcm.entities.PreKey;
+import org.signal.libsignal.protocol.ecc.ECPublicKey;
+import org.whispersystems.textsecuregcm.entities.ECPreKey;
 
 import java.util.Base64;
 
@@ -22,7 +23,7 @@ class PreKeyTest {
 
   @Test
   void serializeToJSONV2() throws Exception {
-    PreKey preKey = new PreKey(1234, PUBLIC_KEY);
+    ECPreKey preKey = new ECPreKey(1234, new ECPublicKey(PUBLIC_KEY));
 
     assertThat("PreKeyV2 Serialization works",
                asJson(preKey),

File: service/src/test/java/org/whispersystems/textsecuregcm/tests/util/DevicesHelper.java
Patch:
@@ -8,7 +8,6 @@
 import java.util.Random;
 
 import org.signal.libsignal.protocol.ecc.Curve;
-import org.whispersystems.textsecuregcm.entities.SignedPreKey;
 import org.whispersystems.textsecuregcm.storage.Device;
 import org.whispersystems.textsecuregcm.util.Util;
 

File: service/src/main/java/org/whispersystems/textsecuregcm/util/IdentityKeyAdapter.java
Patch:
@@ -24,7 +24,7 @@
 public class IdentityKeyAdapter {
 
   private static final Counter IDENTITY_KEY_WITHOUT_VERSION_BYTE_COUNTER =
-      Metrics.counter(MetricsUtil.name(IdentityKeyAdapter.class), "identityKeyWithoutVersionByte");
+      Metrics.counter(MetricsUtil.name(IdentityKeyAdapter.class, "identityKeyWithoutVersionByte"));
 
   public static class Serializer extends JsonSerializer<IdentityKey> {
 

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/AccountsTest.java
Patch:
@@ -154,7 +154,8 @@ public void testUsernameLinksViaAccountsManager() throws Exception {
         accounts,
         mock(PhoneNumberIdentifiers.class),
         mock(FaultTolerantRedisCluster.class),
-        mock(DeletedAccountsManager.class),
+        mock(AccountLockManager.class),
+        mock(DeletedAccounts.class),
         mock(Keys.class),
         mock(MessagesManager.class),
         mock(ProfilesManager.class),

File: service/src/main/java/org/whispersystems/textsecuregcm/limits/RateLimiters.java
Patch:
@@ -74,7 +74,7 @@ public enum For implements RateLimiterDescriptor {
 
     PUSH_CHALLENGE_SUCCESS("pushChallengeSuccess", true, new RateLimiterConfig(2, 2.0 / (60 * 24))),
 
-    CREATE_CALL_LINK("createCallLink", false, new RateLimiterConfig(100, 100 / (60 * 24)));
+    CREATE_CALL_LINK("createCallLink", false, new RateLimiterConfig(100, 100.0 / (60 * 24)));
     ;
 
     private final String id;

File: service/src/main/java/org/whispersystems/textsecuregcm/metrics/MetricsUtil.java
Patch:
@@ -7,7 +7,7 @@
 
 public class MetricsUtil {
 
-  private static final String PREFIX = "chat";
+  public static final String PREFIX = "chat";
 
   /**
    * Returns a dot-separated ('.') name for the given class and name parts

File: service/src/test/java/org/whispersystems/textsecuregcm/tests/controllers/KeysControllerTest.java
Patch:
@@ -199,7 +199,7 @@ void validKeyStatusTest() {
                                           AuthHelper.getAuthHeader(AuthHelper.VALID_UUID, AuthHelper.VALID_PASSWORD))
                                   .get(PreKeyCount.class);
 
-    assertThat(result.getCount()).isEqualTo(4);
+    assertThat(result.getCount()).isEqualTo(5);
 
     verify(KEYS).getCount(AuthHelper.VALID_UUID, 1);
   }

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/DeviceController.java
Patch:
@@ -224,7 +224,7 @@ public void setUnauthenticatedDelivery(@Auth AuthenticatedAccount auth) {
   @Timed
   @PUT
   @Path("/capabilities")
-  public void setCapabiltities(@Auth AuthenticatedAccount auth, @NotNull @Valid DeviceCapabilities capabilities) {
+  public void setCapabilities(@Auth AuthenticatedAccount auth, @NotNull @Valid DeviceCapabilities capabilities) {
     assert (auth.getAuthenticatedDevice() != null);
     final long deviceId = auth.getAuthenticatedDevice().getId();
     accounts.updateDevice(auth.getAccount(), deviceId, d -> d.setCapabilities(capabilities));

File: service/src/main/java/org/whispersystems/textsecuregcm/limits/RateLimiters.java
Patch:
@@ -28,7 +28,7 @@ public enum For implements RateLimiterDescriptor {
 
     SMS_VOICE_PREFIX("smsVoicePrefix", false, new RateLimiterConfig(1000, 1000)),
 
-    VERIFY("verify", false, new RateLimiterConfig(2, 2)),
+    VERIFY("verify", false, new RateLimiterConfig(6, 2)),
 
     PIN("pin", false, new RateLimiterConfig(10, 1 / (24.0 * 60.0))),
 

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/AccountController.java
Patch:
@@ -521,6 +521,7 @@ public TurnToken getTurnToken(@Auth AuthenticatedAccount auth) throws RateLimitE
   @PUT
   @Path("/gcm/")
   @Consumes(MediaType.APPLICATION_JSON)
+  @Produces(MediaType.APPLICATION_JSON)
   @ChangesDeviceEnabledState
   public void setGcmRegistrationId(@Auth DisabledPermittedAuthenticatedAccount disabledPermittedAuth,
       @NotNull @Valid GcmRegistrationId registrationId) {

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/ReportMessageManager.java
Patch:
@@ -31,7 +31,7 @@ public class ReportMessageManager {
 
   private final List<ReportedMessageListener> reportedMessageListeners = new ArrayList<>();
 
-  private static final String REPORT_MESSAGE_COUNTER_NAME = MetricsUtil.name(ReportMessageManager.class);
+  private static final String REPORT_MESSAGE_COUNTER_NAME = MetricsUtil.name(ReportMessageManager.class, "reportMessage");
   private static final String FOUND_MESSAGE_TAG = "foundMessage";
   private static final String TOKEN_PRESENT_TAG = "hasReportSpamToken";
 

File: service/src/main/java/org/whispersystems/textsecuregcm/securestorage/SecureStorageClient.java
Patch:
@@ -40,8 +40,8 @@ public SecureStorageClient(final ExternalServiceCredentialsGenerator storageServ
         this.storageServiceCredentialsGenerator = storageServiceCredentialsGenerator;
         this.deleteUri                         = URI.create(configuration.uri()).resolve(DELETE_PATH);
         this.httpClient                        = FaultTolerantHttpClient.newBuilder()
-                                                                        .withCircuitBreaker(configuration.circuitBreakerConfig())
-                                                                        .withRetry(configuration.retryConfig())
+                                                                        .withCircuitBreaker(configuration.circuitBreaker())
+                                                                        .withRetry(configuration.retry())
                                                                         .withVersion(HttpClient.Version.HTTP_1_1)
                                                                         .withConnectTimeout(Duration.ofSeconds(10))
                                                                         .withRedirect(HttpClient.Redirect.NEVER)

File: service/src/main/java/org/whispersystems/textsecuregcm/registration/RegistrationServiceClient.java
Patch:
@@ -128,7 +128,7 @@ public CompletableFuture<Boolean> checkVerificationCode(final byte[] sessionId,
               default -> throw new CompletionException(new RuntimeException("Failed to check verification code: " + response.getError().getErrorType()));
             }
           } else {
-            return response.getSessionMetadata().getVerified();
+            return response.getVerified() || response.getSessionMetadata().getVerified();
           }
         });
   }

File: service/src/main/java/org/whispersystems/textsecuregcm/util/ExceptionUtils.java
Patch:
@@ -27,7 +27,7 @@ public static Throwable unwrap(Throwable throwable) {
   }
 
   /**
-   * Wraps the given {@code throwable} in a {@link CompletionException} unless the given {@code throwable} is alreadt
+   * Wraps the given {@code throwable} in a {@link CompletionException} unless the given {@code throwable} is already
    * a {@code CompletionException}, in which case this method returns the original throwable.
    *
    * @param throwable the throwable to wrap in a {@code CompletionException}

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/SubscriptionController.java
Patch:
@@ -777,7 +777,9 @@ private void validateRequestCurrencyAmount(CreateBoostRequest request, BigDecima
         minCurrencyAmountMajorUnits);
     if (minCurrencyAmountMinorUnits.compareTo(amount) > 0) {
       throw new BadRequestException(Response.status(Status.BAD_REQUEST)
-          .entity(Map.of("error", "amount_below_currency_minimum")).build());
+          .entity(Map.of(
+              "error", "amount_below_currency_minimum",
+              "minimum", minCurrencyAmountMajorUnits.toString())).build());
     }
   }
 

File: service/src/main/java/org/whispersystems/textsecuregcm/subscriptions/StripeManager.java
Patch:
@@ -211,6 +211,7 @@ public CompletableFuture<Subscription> createSubscription(String customerId, Str
       SubscriptionCreateParams params = SubscriptionCreateParams.builder()
           .setCustomer(customerId)
           .setOffSession(true)
+          .setPaymentBehavior(SubscriptionCreateParams.PaymentBehavior.ERROR_IF_INCOMPLETE)
           .addItem(SubscriptionCreateParams.Item.builder()
               .setPrice(priceId)
               .build())
@@ -250,6 +251,7 @@ public CompletableFuture<Subscription> updateSubscription(
           .setProrationBehavior(ProrationBehavior.NONE)
           .setBillingCycleAnchor(BillingCycleAnchor.NOW)
           .setOffSession(true)
+          .setPaymentBehavior(SubscriptionUpdateParams.PaymentBehavior.ERROR_IF_INCOMPLETE)
           .addAllItem(items)
           .build();
       try {

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/CertificateController.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.UUID;
 import javax.annotation.Nonnull;
 import javax.ws.rs.BadRequestException;
+import javax.ws.rs.DefaultValue;
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
 import javax.ws.rs.PathParam;
@@ -66,14 +67,13 @@ public CertificateController(
   @Produces(MediaType.APPLICATION_JSON)
   @Path("/delivery")
   public DeliveryCertificate getDeliveryCertificate(@Auth AuthenticatedAccount auth,
-      @QueryParam("includeE164") Optional<Boolean> maybeIncludeE164)
+      @QueryParam("includeE164") @DefaultValue("true") boolean includeE164)
       throws InvalidKeyException {
+
     if (Util.isEmpty(auth.getAccount().getIdentityKey())) {
       throw new WebApplicationException(Response.Status.BAD_REQUEST);
     }
 
-    final boolean includeE164 = maybeIncludeE164.orElse(true);
-
     Metrics.counter(GENERATE_DELIVERY_CERTIFICATE_COUNTER_NAME, INCLUDE_E164_TAG_NAME, String.valueOf(includeE164))
         .increment();
 

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -205,7 +205,7 @@
 import org.whispersystems.textsecuregcm.storage.StoredVerificationCodeManager;
 import org.whispersystems.textsecuregcm.storage.SubscriptionManager;
 import org.whispersystems.textsecuregcm.storage.VerificationCodeStore;
-import org.whispersystems.textsecuregcm.stripe.StripeManager;
+import org.whispersystems.textsecuregcm.subscriptions.StripeManager;
 import org.whispersystems.textsecuregcm.util.Constants;
 import org.whispersystems.textsecuregcm.util.DynamoDbFromConfig;
 import org.whispersystems.textsecuregcm.util.HostnameUtil;

File: service/src/test/java/org/whispersystems/textsecuregcm/tests/controllers/AccountControllerTest.java
Patch:
@@ -705,7 +705,7 @@ void testSendCodeWithInvalidPreauth() throws Exception {
                  .header("X-Forwarded-For", NICE_HOST)
                  .get();
 
-    assertThat(response.getStatus()).isEqualTo(402);
+    assertThat(response.getStatus()).isEqualTo(403);
 
     verifyNoMoreInteractions(smsSender);
     verifyNoMoreInteractions(abusiveHostRules);

File: service/src/main/java/org/whispersystems/textsecuregcm/configuration/UsernameConfiguration.java
Patch:
@@ -13,7 +13,7 @@ public class UsernameConfiguration {
 
   @JsonProperty
   @Min(1)
-  private int discriminatorInitialWidth = 4;
+  private int discriminatorInitialWidth = 2;
 
   @JsonProperty
   @Min(1)

File: service/src/main/java/org/whispersystems/textsecuregcm/util/UsernameGenerator.java
Patch:
@@ -34,7 +34,7 @@ public class UsernameGenerator {
    * Usernames typically consist of a nickname and an integer discriminator
    */
   public static final Pattern NICKNAME_PATTERN = Pattern.compile("^[_a-z][_a-z0-9]{2,31}$");
-  public static final String SEPARATOR = "#";
+  public static final String SEPARATOR = ".";
 
   private static final Counter USERNAME_NOT_AVAILABLE_COUNTER = Metrics.counter(name(UsernameGenerator.class, "usernameNotAvailable"));
   private static final DistributionSummary DISCRIMINATOR_ATTEMPT_COUNTER = Metrics.summary(name(UsernameGenerator.class, "discriminatorAttempts"));
@@ -112,7 +112,7 @@ public String fromParts(final String nickname, final int discriminator) throws I
       throw new IllegalArgumentException("Invalid nickname " + nickname);
     }
     // zero pad discriminators less than the discriminator initial width
-    return String.format("%s#%0" + initialWidth + "d", nickname, discriminator);
+    return String.format("%s%s%0" + initialWidth + "d",  nickname, SEPARATOR, discriminator);
   }
 
   public Duration getReservationTtl() {

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/AccountsManagerUsernameIntegrationTest.java
Patch:
@@ -171,7 +171,7 @@ private void buildAccountsManager(final int initialWidth, int discriminatorMaxWi
   }
 
   private static int discriminator(String username) {
-    return Integer.parseInt(username.split(UsernameGenerator.SEPARATOR)[1]);
+    return Integer.parseInt(username.substring(username.indexOf(UsernameGenerator.SEPARATOR) + 1));
   }
 
   @Test

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/MessagesCacheTest.java
Patch:
@@ -361,8 +361,8 @@ public boolean handleMessagesPersisted() {
    * Helper class that implements {@link MessageAvailabilityListener#handleNewMessagesAvailable()} by always returning
    * {@code false}. Its {@code counter} field tracks how many times {@code handleNewMessagesAvailable} has been called.
    * <p>
-   * It uses a parameterized {@code AtomicBoolean} for asynchronous observation. It <em>must</em> be reset to
-   * {@code false} between observations.
+   * It uses a {@link CompletableFuture} to signal that it has received a messages available callback for the first
+   * time.
    */
   private static class NewMessagesAvailabilityClosedListener implements MessageAvailabilityListener {
 

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -381,7 +381,7 @@ public DistributionStatisticConfig configure(final Id id, final DistributionStat
     ScheduledExecutorService websocketScheduledExecutor           = environment.lifecycle().scheduledExecutorService(name(getClass(), "websocket-%d")).threads(8).build();
     ExecutorService          keyspaceNotificationDispatchExecutor = environment.lifecycle().executorService(name(getClass(), "keyspaceNotification-%d")).maxThreads(16).workQueue(keyspaceNotificationDispatchQueue).build();
     ExecutorService          apnSenderExecutor                    = environment.lifecycle().executorService(name(getClass(), "apnSender-%d")).maxThreads(1).minThreads(1).build();
-    ExecutorService          gcmSenderExecutor                    = environment.lifecycle().executorService(name(getClass(), "gcmSender-%d")).maxThreads(1).minThreads(1).build();
+    ExecutorService          fcmSenderExecutor                    = environment.lifecycle().executorService(name(getClass(), "fcmSender-%d")).maxThreads(32).minThreads(32).build();
     ExecutorService          backupServiceExecutor                = environment.lifecycle().executorService(name(getClass(), "backupService-%d")).maxThreads(1).minThreads(1).build();
     ExecutorService          storageServiceExecutor               = environment.lifecycle().executorService(name(getClass(), "storageService-%d")).maxThreads(1).minThreads(1).build();
 
@@ -448,7 +448,7 @@ public DistributionStatisticConfig configure(final Id id, final DistributionStat
     DispatchManager            dispatchManager            = new DispatchManager(pubSubClientFactory, Optional.empty());
     PubSubManager              pubSubManager              = new PubSubManager(pubsubClient, dispatchManager);
     APNSender                  apnSender                  = new APNSender(apnSenderExecutor, config.getApnConfiguration());
-    FcmSender                  fcmSender                  = new FcmSender(gcmSenderExecutor, config.getFcmConfiguration().credentials());
+    FcmSender                  fcmSender                  = new FcmSender(fcmSenderExecutor, config.getFcmConfiguration().credentials());
     ApnFallbackManager         apnFallbackManager         = new ApnFallbackManager(pushSchedulerCluster, apnSender, accountsManager);
     PushNotificationManager    pushNotificationManager    = new PushNotificationManager(accountsManager, apnSender, fcmSender, apnFallbackManager);
     RateLimiters               rateLimiters               = new RateLimiters(config.getLimitsConfiguration(), rateLimitersCluster);

File: service/src/main/java/org/whispersystems/textsecuregcm/entities/OutgoingMessageEntity.java
Patch:
@@ -49,7 +49,7 @@ public static OutgoingMessageEntity fromEnvelope(final MessageProtos.Envelope en
         UUID.fromString(envelope.getServerGuid()),
         envelope.getType().getNumber(),
         envelope.getTimestamp(),
-        envelope.getSource(),
+        envelope.hasSource() ? envelope.getSource() : null,
         envelope.hasSourceUuid() ? UUID.fromString(envelope.getSourceUuid()) : null,
         envelope.getSourceDevice(),
         envelope.hasDestinationUuid() ? UUID.fromString(envelope.getDestinationUuid()) : null,

File: service/src/test/java/org/whispersystems/textsecuregcm/entities/OutgoingMessageEntityTest.java
Patch:
@@ -30,11 +30,11 @@ void toFromEnvelope(@Nullable final String source, @Nullable final UUID sourceUu
     final OutgoingMessageEntity outgoingMessageEntity = new OutgoingMessageEntity(UUID.randomUUID(),
         MessageProtos.Envelope.Type.CIPHERTEXT_VALUE,
         messageTimestamp,
-        "+18005551234",
-        UUID.randomUUID(),
+        source,
+        sourceUuid,
         source != null ? (int) Device.MASTER_ID : 0,
         UUID.randomUUID(),
-        UUID.randomUUID(),
+        updatedPni,
         messageContent,
         serverTimestamp);
 

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/ChangeNumberManager.java
Patch:
@@ -64,8 +64,8 @@ public Account changeNumber(final Account account, final String number,
                   IncomingMessage::getDestinationDeviceId,
                   IncomingMessage::getDestinationRegistrationId)),
           false);
-    } else if (!ObjectUtils.allNull(deviceSignedPreKeys, deviceMessages, pniRegistrationIds)) {
-      throw new IllegalArgumentException("Signed pre-keys, device messages, and registration IDs must be all null or all non-null");
+    } else if (!ObjectUtils.allNull(pniIdentityKey, deviceSignedPreKeys, deviceMessages, pniRegistrationIds)) {
+      throw new IllegalArgumentException("PNI identity key, signed pre-keys, device messages, and registration IDs must be all null or all non-null");
     }
 
     final Account updatedAccount;

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/ProfileController.java
Patch:
@@ -357,7 +357,7 @@ public CompletableFuture<BatchIdentityCheckResponse> runBatchIdentityCheck(@NotN
               } catch (NoSuchAlgorithmException e) {
                 throw new AssertionError(e);
               }
-              for (final BatchIdentityCheckRequest.Element element : request.elements()) {
+              for (final BatchIdentityCheckRequest.Element element : batch) {
                 checkFingerprintAndAdd(element, responseElements, sha256);
               }
             }, batchIdentityCheckExecutor);

File: service/src/main/java/org/whispersystems/textsecuregcm/push/GCMSender.java
Patch:
@@ -135,7 +135,7 @@ private void handleCanonicalRegistrationId(GcmMessage message, Result result) {
   }
 
   private void handleGenericError(GcmMessage message, Result result) {
-    logger.warn("Unrecoverable Error ::: (error={}}), (gcm_id={}}), (destination={}}), (device_id={}})",
+    logger.debug("Unrecoverable Error ::: (error={}}), (gcm_id={}}), (destination={}}), (device_id={}})",
         result.getError(), message.getGcmId(), message.getUuid(), message.getDeviceId());
 
     Metrics.counter(DOWNSTREAM_ERROR_COUNTER_NAME, "code", result.getError()).increment();

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/KeepAliveController.java
Patch:
@@ -43,7 +43,7 @@ public Response getKeepAlive(@Auth AuthenticatedAccount auth,
       @WebSocketSession WebSocketSessionContext context) {
     if (auth != null) {
       if (!clientPresenceManager.isLocallyPresent(auth.getAccount().getUuid(), auth.getAuthenticatedDevice().getId())) {
-        logger.warn("***** No local subscription found for {}::{}; age = {}ms, User-Agent = {}",
+        logger.debug("***** No local subscription found for {}::{}; age = {}ms, User-Agent = {}",
             auth.getAccount().getUuid(), auth.getAuthenticatedDevice().getId(),
             System.currentTimeMillis() - context.getClient().getCreatedTimestamp(),
             context.getClient().getUserAgent());

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/AccountController.java
Patch:
@@ -120,7 +120,7 @@ public class AccountController {
   private static final String CHALLENGE_PRESENT_TAG_NAME = "present";
   private static final String CHALLENGE_MATCH_TAG_NAME = "matches";
   private static final String COUNTRY_CODE_TAG_NAME = "countryCode";
-  private static final String VERFICATION_TRANSPORT_TAG_NAME = "transport";
+  private static final String VERIFICATION_TRANSPORT_TAG_NAME = "transport";
 
   private static final String VERIFY_EXPERIMENT_TAG_NAME = "twilioVerify";
 
@@ -320,7 +320,7 @@ public Response createAccount(@PathParam("transport")         String transport,
     {
       final List<Tag> tags = new ArrayList<>();
       tags.add(Tag.of(COUNTRY_CODE_TAG_NAME, Util.getCountryCode(number)));
-      tags.add(Tag.of(VERFICATION_TRANSPORT_TAG_NAME, transport));
+      tags.add(Tag.of(VERIFICATION_TRANSPORT_TAG_NAME, transport));
       tags.add(UserAgentTagUtil.getPlatformTag(userAgent));
       tags.add(Tag.of(VERIFY_EXPERIMENT_TAG_NAME, String.valueOf(enrolledInVerifyExperiment)));
 

File: gcm-sender-async/src/test/java/org/whispersystems/gcm/server/SenderTest.java
Patch:
@@ -141,7 +141,7 @@ void testServerErrorRecovery() throws InterruptedException, ExecutionException,
     CompletableFuture<Result> future = sender.send(Message.newBuilder().withDestination("1").build());
 
     // up to three failures can happen, with 100ms exponential backoff
-    // if we end up using the fourth, and finally try, it would be after ~700 ms
+    // if we end up using the fourth, and final try, it would be after ~700 ms
     CompletableFuture.delayedExecutor(300, TimeUnit.MILLISECONDS).execute(() ->
         wireMock.stubFor(any(anyUrl())
             .willReturn(aResponse()

File: gcm-sender-async/src/test/java/org/whispersystems/gcm/server/SenderTest.java
Patch:
@@ -141,7 +141,7 @@ void testServerErrorRecovery() throws InterruptedException, ExecutionException,
     CompletableFuture<Result> future = sender.send(Message.newBuilder().withDestination("1").build());
 
     // up to three failures can happen, with 100ms exponential backoff
-    // if we end up using the fourth, and finaly try, it would be after ~700 ms
+    // if we end up using the fourth, and finally try, it would be after ~700 ms
     CompletableFuture.delayedExecutor(300, TimeUnit.MILLISECONDS).execute(() ->
         wireMock.stubFor(any(anyUrl())
             .willReturn(aResponse()

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/MessagesDynamoDb.java
Patch:
@@ -73,7 +73,7 @@ public void store(final List<MessageProtos.Envelope> messages, final UUID destin
 
   private void storeBatch(final List<MessageProtos.Envelope> messages, final UUID destinationAccountUuid, final long destinationDeviceId) {
     if (messages.size() > DYNAMO_DB_MAX_BATCH_SIZE) {
-      throw new IllegalArgumentException("Maximum batch size of " + DYNAMO_DB_MAX_BATCH_SIZE + " execeeded with " + messages.size() + " messages");
+      throw new IllegalArgumentException("Maximum batch size of " + DYNAMO_DB_MAX_BATCH_SIZE + " exceeded with " + messages.size() + " messages");
     }
 
     final AttributeValue partitionKey = convertPartitionKey(destinationAccountUuid);

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/AccountsManagerConcurrentModificationIntegrationTest.java
Patch:
@@ -233,15 +233,15 @@ private Account getLastAccountFromRedisMock(RedisAdvancedClusterCommands<String,
     return JsonHelpers.fromJson(redisSetArgumentCapture.getValue(), Account.class);
   }
 
-  private void verifyAccount(final String name, final Account account, final boolean discoverableByPhoneNumber, final String currentProfileVersion, final String identityKey, final byte[] unidentifiedAccessKey, final String pin, final String clientRegistrationLock, final boolean unrestrictedUnidentifiedAcces, final long lastSeen) {
+  private void verifyAccount(final String name, final Account account, final boolean discoverableByPhoneNumber, final String currentProfileVersion, final String identityKey, final byte[] unidentifiedAccessKey, final String pin, final String clientRegistrationLock, final boolean unrestrictedUnidentifiedAccess, final long lastSeen) {
 
     assertAll(name,
         () -> assertEquals(discoverableByPhoneNumber, account.isDiscoverableByPhoneNumber()),
         () -> assertEquals(currentProfileVersion, account.getCurrentProfileVersion().orElseThrow()),
         () -> assertEquals(identityKey, account.getIdentityKey()),
         () -> assertArrayEquals(unidentifiedAccessKey, account.getUnidentifiedAccessKey().orElseThrow()),
         () -> assertTrue(account.getRegistrationLock().verify(clientRegistrationLock)),
-        () -> assertEquals(unrestrictedUnidentifiedAcces, account.isUnrestrictedUnidentifiedAccess())
+        () -> assertEquals(unrestrictedUnidentifiedAccess, account.isUnrestrictedUnidentifiedAccess())
     );
   }
 

File: service/src/test/java/org/whispersystems/textsecuregcm/tests/auth/OptionalAccessTest.java
Patch:
@@ -94,7 +94,7 @@ void testUnsolicitedBadTarget() {
 
     try {
       OptionalAccess.verify(Optional.empty(), Optional.empty(), Optional.of(account));
-      throw new AssertionError("shold fai");
+      throw new AssertionError("should fail");
     } catch (WebApplicationException e) {
       assertEquals(e.getResponse().getStatus(), 401);
     }

File: service/src/main/java/org/whispersystems/textsecuregcm/limits/LockingRateLimiter.java
Patch:
@@ -31,7 +31,7 @@ public LockingRateLimiter(FaultTolerantRedisCluster cacheCluster, String name, i
   public void validate(String key, int amount) throws RateLimitExceededException {
     if (!acquireLock(key)) {
       meter.mark();
-      throw new RateLimitExceededException("Locked", Duration.ZERO);
+      throw new RateLimitExceededException(Duration.ZERO);
     }
 
     try {

File: service/src/main/java/org/whispersystems/textsecuregcm/limits/RateLimiter.java
Patch:
@@ -57,7 +57,7 @@ public void validate(String key, int amount) throws RateLimitExceededException {
         setBucket(key, bucket);
       } else {
         meter.mark();
-        throw new RateLimitExceededException(key + " , " + amount, bucket.getTimeUntilSpaceAvailable(amount));
+        throw new RateLimitExceededException(bucket.getTimeUntilSpaceAvailable(amount));
       }
     }
   }

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -123,7 +123,6 @@
 import org.whispersystems.textsecuregcm.mappers.NonNormalizedPhoneNumberExceptionMapper;
 import org.whispersystems.textsecuregcm.mappers.RateLimitChallengeExceptionMapper;
 import org.whispersystems.textsecuregcm.mappers.RateLimitExceededExceptionMapper;
-import org.whispersystems.textsecuregcm.mappers.RetryLaterExceptionMapper;
 import org.whispersystems.textsecuregcm.mappers.ServerRejectedExceptionMapper;
 import org.whispersystems.textsecuregcm.metrics.ApplicationShutdownMonitor;
 import org.whispersystems.textsecuregcm.metrics.BufferPoolGauges;
@@ -758,7 +757,6 @@ private void registerExceptionMappers(Environment environment,
         new RateLimitExceededExceptionMapper(),
         new InvalidWebsocketAddressExceptionMapper(),
         new DeviceLimitExceededExceptionMapper(),
-        new RetryLaterExceptionMapper(),
         new ServerRejectedExceptionMapper(),
         new ImpossiblePhoneNumberExceptionMapper(),
         new NonNormalizedPhoneNumberExceptionMapper()

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/ChallengeController.java
Patch:
@@ -51,7 +51,7 @@ public ChallengeController(final RateLimitChallengeManager rateLimitChallengeMan
   public Response handleChallengeResponse(@Auth final AuthenticatedAccount auth,
       @Valid final AnswerChallengeRequest answerRequest,
       @HeaderParam("X-Forwarded-For") final String forwardedFor,
-      @HeaderParam(HttpHeaders.USER_AGENT) final String userAgent) throws RetryLaterException {
+      @HeaderParam(HttpHeaders.USER_AGENT) final String userAgent) throws RateLimitExceededException {
 
     Tags tags = Tags.of(UserAgentTagUtil.getPlatformTag(userAgent));
 
@@ -76,8 +76,6 @@ public Response handleChallengeResponse(@Auth final AuthenticatedAccount auth,
       } else {
         tags = tags.and(CHALLENGE_TYPE_TAG, "unrecognized");
       }
-    } catch (final RateLimitExceededException e) {
-      throw new RetryLaterException(e);
     } finally {
       Metrics.counter(CHALLENGE_RESPONSE_COUNTER_NAME, tags).increment();
     }

File: service/src/test/java/org/whispersystems/textsecuregcm/controllers/ChallengeControllerTest.java
Patch:
@@ -27,7 +27,7 @@
 import org.whispersystems.textsecuregcm.auth.AuthenticatedAccount;
 import org.whispersystems.textsecuregcm.auth.DisabledPermittedAuthenticatedAccount;
 import org.whispersystems.textsecuregcm.limits.RateLimitChallengeManager;
-import org.whispersystems.textsecuregcm.mappers.RetryLaterExceptionMapper;
+import org.whispersystems.textsecuregcm.mappers.RateLimitExceededExceptionMapper;
 import org.whispersystems.textsecuregcm.push.NotPushRegisteredException;
 import org.whispersystems.textsecuregcm.tests.util.AuthHelper;
 import org.whispersystems.textsecuregcm.util.SystemMapper;
@@ -45,7 +45,7 @@ class ChallengeControllerTest {
           Set.of(AuthenticatedAccount.class, DisabledPermittedAuthenticatedAccount.class)))
       .setMapper(SystemMapper.getMapper())
       .setTestContainerFactory(new GrizzlyWebTestContainerFactory())
-      .addResource(new RetryLaterExceptionMapper())
+      .addResource(new RateLimitExceededExceptionMapper())
       .addResource(challengeController)
       .build();
 

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -436,7 +436,7 @@ public DistributionStatisticConfig configure(final Id id, final DistributionStat
     ReportMessageManager       reportMessageManager       = new ReportMessageManager(reportMessageDynamoDb, rateLimitersCluster, Metrics.globalRegistry, config.getReportMessageConfiguration().getCounterTtl());
     MessagesManager            messagesManager            = new MessagesManager(messagesDynamoDb, messagesCache, pushLatencyManager, reportMessageManager);
     DeletedAccountsManager deletedAccountsManager = new DeletedAccountsManager(deletedAccounts,
-        deletedAccountsLockDynamoDbClient, config.getDynamoDbTables().getDeletedAccounts().getTableName());
+        deletedAccountsLockDynamoDbClient, config.getDynamoDbTables().getDeletedAccountsLock().getTableName());
     AccountsManager accountsManager = new AccountsManager(accounts, phoneNumberIdentifiers, cacheCluster,
         deletedAccountsManager, directoryQueue, keys, messagesManager, reservedUsernames, profilesManager,
         pendingAccountsManager, secureStorageClient, secureBackupClient, clientPresenceManager, clock);

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/MessageController.java
Patch:
@@ -112,10 +112,10 @@ public class MessageController {
   private final ExecutorService             multiRecipientMessageExecutor;
 
   @VisibleForTesting
-  static final Semver FIRST_IOS_VERSION_WITH_INCORRECT_ENVELOPE_TYPE = new Semver("5.22.0.32");
+  static final Semver FIRST_IOS_VERSION_WITH_INCORRECT_ENVELOPE_TYPE = new Semver("5.22.0");
 
   @VisibleForTesting
-  static final Semver IOS_VERSION_WITH_FIXED_ENVELOPE_TYPE = new Semver("5.25.0.0");
+  static final Semver IOS_VERSION_WITH_FIXED_ENVELOPE_TYPE = new Semver("5.25.0");
 
   private static final String REJECT_OVERSIZE_MESSAGE_COUNTER = name(MessageController.class, "rejectOversizeMessage");
   private static final String LEGACY_MESSAGE_SENT_COUNTER = name(MessageController.class, "legacyMessageSent");
@@ -505,7 +505,7 @@ private void sendMessage(Optional<AuthenticatedAccount> source,
         try {
           final UserAgent userAgent = UserAgentUtil.parseUserAgentString(userAgentString);
           if (userAgent.getPlatform() == ClientPlatform.IOS &&
-              userAgent.getVersion().isGreaterThanOrEqualTo(FIRST_IOS_VERSION_WITH_INCORRECT_ENVELOPE_TYPE) &&
+              FIRST_IOS_VERSION_WITH_INCORRECT_ENVELOPE_TYPE.isLowerThanOrEqualTo(userAgent.getVersion()) &&
               userAgent.getVersion().isLowerThan(IOS_VERSION_WITH_FIXED_ENVELOPE_TYPE)) {
             envelopeTypeNumber = Type.PLAINTEXT_CONTENT.getNumber();
           }

File: service/src/test/java/org/whispersystems/textsecuregcm/controllers/MessageControllerTest.java
Patch:
@@ -30,6 +30,7 @@
 
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.google.common.collect.ImmutableSet;
+import com.vdurmont.semver4j.Semver;
 import io.dropwizard.auth.PolymorphicAuthValueFactoryProvider;
 import io.dropwizard.testing.junit5.DropwizardExtensionsSupport;
 import io.dropwizard.testing.junit5.ResourceExtension;
@@ -232,6 +233,7 @@ private static Stream<Arguments> testSingleDeviceCurrentBadType() {
     return Stream.of(
         Arguments.of(String.format("Signal-iOS/%s iOS/14.2", MessageController.FIRST_IOS_VERSION_WITH_INCORRECT_ENVELOPE_TYPE), true),
         Arguments.of(String.format("Signal-iOS/%s iOS/14.2", MessageController.FIRST_IOS_VERSION_WITH_INCORRECT_ENVELOPE_TYPE.nextPatch()), true),
+        Arguments.of(String.format("Signal-iOS/%s iOS/14.2", new Semver("5.22.0.38")), true),
         Arguments.of(String.format("Signal-iOS/%s iOS/14.2", MessageController.IOS_VERSION_WITH_FIXED_ENVELOPE_TYPE.withIncMinor(-1)), true),
         Arguments.of(String.format("Signal-iOS/%s iOS/14.2", MessageController.IOS_VERSION_WITH_FIXED_ENVELOPE_TYPE), false)
     );

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/MessageController.java
Patch:
@@ -503,7 +503,7 @@ public void removePendingMessage(@Auth AuthenticatedAccount auth, @PathParam("uu
   public Response reportMessage(@Auth AuthenticatedAccount auth, @PathParam("sourceNumber") String sourceNumber,
       @PathParam("messageGuid") UUID messageGuid) {
 
-    reportMessageManager.report(sourceNumber, messageGuid);
+    reportMessageManager.report(sourceNumber, messageGuid, auth.getAccount().getUuid());
 
     return Response.status(Status.ACCEPTED)
         .build();

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/ReportMessageManager.java
Patch:
@@ -54,15 +54,15 @@ public void store(String sourceNumber, UUID messageGuid) {
     }
   }
 
-  public void report(String sourceNumber, UUID messageGuid) {
+  public void report(String sourceNumber, UUID messageGuid, UUID reporterUuid) {
 
     final boolean found = reportMessageDynamoDb.remove(hash(messageGuid, sourceNumber));
 
     if (found) {
       rateLimitCluster.useCluster(connection -> {
         final String reportedSenderKey = getReportedSenderKey(sourceNumber);
 
-        connection.sync().pfadd(reportedSenderKey, sourceNumber);
+        connection.sync().pfadd(reportedSenderKey, reporterUuid.toString());
         connection.sync().expire(reportedSenderKey, counterTtl.toSeconds());
       });
 

File: service/src/test/java/org/whispersystems/textsecuregcm/controllers/MessageControllerTest.java
Patch:
@@ -575,7 +575,7 @@ void testReportMessage() {
 
     assertThat(response.getStatus(), is(equalTo(202)));
 
-    verify(reportMessageManager).report(senderNumber, messageGuid);
+    verify(reportMessageManager).report(senderNumber, messageGuid, AuthHelper.VALID_UUID);
   }
 
   static Account mockAccountWithDeviceAndRegId(Object... deviceAndRegistrationIds) {

File: service/src/main/java/org/whispersystems/textsecuregcm/recaptcha/LegacyRecaptchaClient.java
Patch:
@@ -41,7 +41,7 @@ public boolean verify(String captchaToken, String ip) {
                                     .post(Entity.form(formData), VerifyResponse.class);
 
     if (response.success) {
-      logger.info("Got successful captcha time: " + response.challenge_ts + ", current time: " + System.currentTimeMillis());
+      logger.debug("Got successful captcha time: " + response.challenge_ts + ", current time: " + System.currentTimeMillis());
     }
 
     return response.success;

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/SubscriptionController.java
Patch:
@@ -29,7 +29,6 @@
 import java.util.Objects;
 import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
-import java.util.function.Function;
 import java.util.stream.Collectors;
 import javax.annotation.Nonnull;
 import javax.crypto.Mac;
@@ -408,7 +407,7 @@ public CompletableFuture<Response> getLevels(@Context ContainerRequestContext co
   public CompletableFuture<Response> getBoostAmounts() {
     return CompletableFuture.supplyAsync(() -> Response.ok(
         boostConfiguration.getCurrencies().entrySet().stream().collect(
-            Collectors.toMap(entry -> entry.getKey().toUpperCase(Locale.ROOT), Function.identity()))).build());
+            Collectors.toMap(entry -> entry.getKey().toUpperCase(Locale.ROOT), Entry::getValue))).build());
   }
 
   public static class CreateBoostRequest {

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerConfiguration.java
Patch:
@@ -328,7 +328,7 @@ public class WhisperServerConfiguration extends Configuration {
   @Valid
   @NotNull
   @JsonProperty
-  private ReportMessageConfiguration reportMessage;
+  private ReportMessageConfiguration reportMessage = new ReportMessageConfiguration();
 
   private Map<String, String> transparentDataIndex = new HashMap<>();
 

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -248,6 +248,8 @@ public String getName() {
   public void run(WhisperServerConfiguration config, Environment environment)
       throws Exception {
 
+    final Clock clock = Clock.systemUTC();
+
     UncaughtExceptionHandler.register();
 
     SharedMetricRegistries.add(Constants.METRICS_NAME, environment.metrics());
@@ -590,7 +592,7 @@ public DistributionStatisticConfig configure(final Id id, final DistributionStat
         new DonationController(donationExecutor, config.getDonationConfiguration()),
         new MessageController(rateLimiters, messageSender, receiptSender, accountsManager, messagesManager, unsealedSenderRateLimiter, apnFallbackManager, dynamicConfigurationManager, rateLimitChallengeManager, reportMessageManager, metricsCluster, declinedMessageReceiptExecutor, multiRecipientMessageExecutor),
         new PaymentsController(currencyManager, paymentsCredentialsGenerator),
-        new ProfileController(rateLimiters, accountsManager, profilesManager, usernamesManager, dynamicConfigurationManager, profileBadgeConverter, cdnS3Client, profileCdnPolicyGenerator, profileCdnPolicySigner, config.getCdnConfiguration().getBucket(), zkProfileOperations, isZkEnabled),
+        new ProfileController(clock, rateLimiters, accountsManager, profilesManager, usernamesManager, dynamicConfigurationManager, profileBadgeConverter, config.getBadges(), cdnS3Client, profileCdnPolicyGenerator, profileCdnPolicySigner, config.getCdnConfiguration().getBucket(), zkProfileOperations),
         new ProvisioningController(rateLimiters, provisioningManager),
         new RemoteConfigController(remoteConfigsManager, config.getRemoteConfigConfiguration().getAuthorizedTokens(), config.getRemoteConfigConfiguration().getGlobalConfig()),
         new SecureBackupController(backupCredentialsGenerator),

File: service/src/main/java/org/whispersystems/textsecuregcm/websocket/WebSocketConnection.java
Patch:
@@ -258,6 +258,8 @@ void processStoredMessages() {
             processStoredMessages();
           }
         } else {
+          logger.debug("Failed to clear queue", cause);
+
           if (consecutiveRetries.incrementAndGet() > MAX_CONSECUTIVE_RETRIES) {
             client.close(1011, "Failed to retrieve messages");
           } else {

File: service/src/test/java/org/whispersystems/textsecuregcm/tests/controllers/PaymentsControllerTest.java
Patch:
@@ -123,7 +123,7 @@ void testGetCurrencyConversions_Json() {
         resources.getJerseyTest()
             .target("/v1/payments/conversions")
             .request()
-            .header("Authorization", AuthHelper.getAuthHeader(AuthHelper.VALID_NUMBER, AuthHelper.VALID_PASSWORD))
+            .header("Authorization", AuthHelper.getAuthHeader(AuthHelper.VALID_UUID, AuthHelper.VALID_PASSWORD))
             .get(String.class);
 
     assertThat(json.contains("{\"USD\":2.35,\"EUR\":1.89}"));

File: redis-dispatch/src/main/java/org/whispersystems/dispatch/io/RedisInputStream.java
Patch:
@@ -20,7 +20,7 @@ public RedisInputStream(InputStream inputStream) {
   }
 
   public String readLine() throws IOException {
-    ByteArrayOutputStream boas = new ByteArrayOutputStream();
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
 
     boolean foundCr = false;
 
@@ -31,14 +31,14 @@ public String readLine() throws IOException {
         throw new IOException("Stream closed!");
       }
 
-      boas.write(character);
+      baos.write(character);
 
       if      (foundCr && character == LF) break;
       else if (character == CR)            foundCr = true;
       else if (foundCr)                    foundCr = false;
     }
 
-    byte[] data = boas.toByteArray();
+    byte[] data = baos.toByteArray();
     return new String(data, 0, data.length-2);
   }
 

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -491,7 +491,7 @@ public DistributionStatisticConfig configure(final Id id, final DistributionStat
           directoryServerConfiguration.getReplicationName(), directoryReconciliationClient);
       deletedAccountsDirectoryReconcilers.add(deletedAccountsDirectoryReconciler);
     }
-    accountDatabaseCrawlerListeners.add(new ContactDiscoveryWriter(accounts));
+    accountDatabaseCrawlerListeners.add(new ContactDiscoveryWriter(accountsManager));
     // PushFeedbackProcessor may update device properties
     accountDatabaseCrawlerListeners.add(new PushFeedbackProcessor(accountsManager));
     // delete accounts last

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/ContactDiscoveryWriter.java
Patch:
@@ -6,9 +6,9 @@
 
 public class ContactDiscoveryWriter extends AccountDatabaseCrawlerListener {
 
-  private final AccountStore accounts;
+  private final AccountsManager accounts;
 
-  public ContactDiscoveryWriter(final AccountStore accounts) {
+  public ContactDiscoveryWriter(final AccountsManager accounts) {
     this.accounts = accounts;
   }
 
@@ -30,7 +30,7 @@ protected void onCrawlChunk(final Optional<UUID> fromUuid, final List<Account> c
         // Its less than ideal, but crawler listeners currently must not call update()
         // with the accounts from the chunk, because updates cause the account instance to become stale. Instead, they
         // must get a new copy, which they are free to update.
-        accounts.get(account.getUuid()).ifPresent(accounts::update);
+        accounts.get(account.getUuid()).ifPresent(a -> accounts.update(a, updated -> {}));
       }
     }
   }

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/AccountsDynamoDbTest.java
Patch:
@@ -524,6 +524,7 @@ void testCanonicallyDiscoverableSet() {
     verifyStoredState("+14151112222", account.getUuid(), account, false);
   }
 
+  /*
   @Test
   void testContactDiscoveryWriter() throws Exception {
     Device device = generateDevice(1);
@@ -555,6 +556,7 @@ void testContactDiscoveryWriter() throws Exception {
     account.setVersion(2);
     verifyStoredState("+14151112222", account.getUuid(), account, true);
   }
+  */
 
   private Device generateDevice(long id) {
     Random       random       = new Random(System.currentTimeMillis());

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/MessagesCache.java
Patch:
@@ -86,7 +86,7 @@ public class MessagesCache extends RedisClusterPubSubAdapter<String, String> imp
     private static final String REMOVE_TIMER_NAME = name(MessagesCache.class, "remove");
 
     private static final String REMOVE_METHOD_TAG    = "method";
-  private static final String REMOVE_METHOD_SENDER = "sender";
+    private static final String REMOVE_METHOD_SENDER = "sender";
     private static final String REMOVE_METHOD_UUID   = "uuid";
 
     private static final Logger logger = LoggerFactory.getLogger(MessagesCache.class);

File: websocket-resources/src/test/java/org/whispersystems/websocket/WebSocketResourceProviderFactoryTest.java
Patch:
@@ -20,6 +20,7 @@
 import javax.security.auth.Subject;
 import org.eclipse.jetty.websocket.api.Session;
 import org.eclipse.jetty.websocket.api.UpgradeRequest;
+import org.eclipse.jetty.websocket.api.WebSocketPolicy;
 import org.eclipse.jetty.websocket.servlet.ServletUpgradeRequest;
 import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse;
 import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
@@ -105,6 +106,7 @@ public void testConfigure() {
     WebSocketEnvironment             environment       = mock(WebSocketEnvironment.class    );
     WebSocketServletFactory          servletFactory    = mock(WebSocketServletFactory.class );
     when(environment.jersey()).thenReturn(jerseyEnvironment);
+    when(servletFactory.getPolicy()).thenReturn(mock(WebSocketPolicy.class));
 
     WebSocketResourceProviderFactory factory = new WebSocketResourceProviderFactory(environment, Account.class);
     factory.configure(servletFactory);

File: service/src/main/java/org/whispersystems/textsecuregcm/recaptcha/TransitionalRecaptchaClient.java
Patch:
@@ -10,7 +10,7 @@
 
 public class TransitionalRecaptchaClient implements RecaptchaClient {
 
-  private static final String PREFIX = "signal-v2:";
+  private static final String PREFIX = "signal-recaptcha-v2:";
 
   private final LegacyRecaptchaClient legacyRecaptchaClient;
   private final EnterpriseRecaptchaClient enterpriseRecaptchaClient;

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -574,8 +574,8 @@ public DistributionStatisticConfig configure(final Id id, final DistributionStat
         new StickerController(rateLimiters, config.getCdnConfiguration().getAccessKey(), config.getCdnConfiguration().getAccessSecret(), config.getCdnConfiguration().getRegion(), config.getCdnConfiguration().getBucket())
     );
     for (Object controller : commonControllers) {
-      environment.jersey().register(controller);
-      webSocketEnvironment.jersey().register(controller);
+        environment.jersey().register(controller);
+        webSocketEnvironment.jersey().register(controller);
     }
 
     WebSocketEnvironment<Account> provisioningEnvironment = new WebSocketEnvironment<>(environment, webSocketEnvironment.getRequestLog(), 60000);

File: service/src/main/java/org/whispersystems/textsecuregcm/configuration/MessageDynamoDbConfiguration.java
Patch:
@@ -5,13 +5,12 @@
 
 package org.whispersystems.textsecuregcm.configuration;
 
-import javax.validation.Valid;
-import javax.validation.constraints.NotEmpty;
 import java.time.Duration;
+import javax.validation.Valid;
 
 public class MessageDynamoDbConfiguration extends DynamoDbConfiguration {
 
-  private Duration timeToLive = Duration.ofDays(7);
+  private Duration timeToLive = Duration.ofDays(14);
 
   @Valid
   public Duration getTimeToLive() {

File: service/src/main/java/org/whispersystems/textsecuregcm/entities/IncomingMessageList.java
Patch:
@@ -4,6 +4,8 @@
  */
 package org.whispersystems.textsecuregcm.entities;
 
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.annotation.JsonInclude.Include;
 import com.fasterxml.jackson.annotation.JsonProperty;
 
 import javax.validation.Valid;
@@ -15,6 +17,7 @@ public class IncomingMessageList {
   @JsonProperty
   @NotNull
   @Valid
+  @JsonInclude(Include.NON_NULL)
   private List<IncomingMessage> messages;
 
   @JsonProperty

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/MessageController.java
Patch:
@@ -549,7 +549,7 @@ public void removePendingMessage(@Auth Account account,
                                                                        account.getAuthenticatedDevice().get().getId(),
                                                                        source, timestamp);
 
-      if (message.isPresent() && message.get().getType() != Envelope.Type.RECEIPT_VALUE) {
+      if (message.isPresent() && message.get().getType() != Envelope.Type.SERVER_DELIVERY_RECEIPT_VALUE) {
         receiptSender.sendReceipt(account,
                                   message.get().getSource(),
                                   message.get().getTimestamp());
@@ -571,7 +571,7 @@ public void removePendingMessage(@Auth Account account, @PathParam("uuid") UUID
 
       if (message.isPresent()) {
         WebSocketConnection.recordMessageDeliveryDuration(message.get().getTimestamp(), account.getAuthenticatedDevice().get());
-        if (!Util.isEmpty(message.get().getSource()) && message.get().getType() != Envelope.Type.RECEIPT_VALUE) {
+        if (!Util.isEmpty(message.get().getSource()) && message.get().getType() != Envelope.Type.SERVER_DELIVERY_RECEIPT_VALUE) {
           receiptSender.sendReceipt(account, message.get().getSource(), message.get().getTimestamp());
         }
       }
@@ -605,7 +605,7 @@ private void sendMessage(Optional<Account> source,
       Optional<byte[]> messageContent = getMessageContent(incomingMessage);
       Envelope.Builder messageBuilder = Envelope.newBuilder();
 
-      messageBuilder.setType(Envelope.Type.valueOf(incomingMessage.getType()))
+      messageBuilder.setType(Envelope.Type.forNumber(incomingMessage.getType()))
                     .setTimestamp(timestamp == 0 ? System.currentTimeMillis() : timestamp)
                     .setServerTimestamp(System.currentTimeMillis());
 

File: service/src/main/java/org/whispersystems/textsecuregcm/push/ReceiptSender.java
Patch:
@@ -43,7 +43,7 @@ public void sendReceipt(Account source, String destination, long messageId)
                                                   .setSourceUuid(source.getUuid().toString())
                                                   .setSourceDevice((int) source.getAuthenticatedDevice().get().getId())
                                                   .setTimestamp(messageId)
-                                                  .setType(Envelope.Type.RECEIPT);
+                                                  .setType(Envelope.Type.SERVER_DELIVERY_RECEIPT);
 
     if (source.getRelay().isPresent()) {
       message.setRelay(source.getRelay().get());

File: service/src/main/java/org/whispersystems/textsecuregcm/websocket/WebSocketConnection.java
Patch:
@@ -171,7 +171,7 @@ private CompletableFuture<WebSocketResponseMessage> sendMessage(final Envelope m
             messagesManager.delete(account.getUuid(), device.getId(), storedMessageInfo.get().getGuid());
           }
 
-          if (message.getType() != Envelope.Type.RECEIPT) {
+          if (message.getType() != Envelope.Type.SERVER_DELIVERY_RECEIPT) {
             recordMessageDeliveryDuration(message.getTimestamp(), device);
             sendDeliveryReceiptFor(message);
           }

File: service/src/test/java/org/whispersystems/textsecuregcm/tests/controllers/MessageControllerTest.java
Patch:
@@ -478,7 +478,7 @@ void testGetMessages() throws Exception {
 
     List<OutgoingMessageEntity> messages = new LinkedList<>() {{
       add(new OutgoingMessageEntity(1L, false, messageGuidOne, Envelope.Type.CIPHERTEXT_VALUE, null, timestampOne, "+14152222222", sourceUuid, 2, "hi there".getBytes(), null, 0));
-      add(new OutgoingMessageEntity(2L, false, null, Envelope.Type.RECEIPT_VALUE, null, timestampTwo, "+14152222222", sourceUuid, 2, null, null, 0));
+      add(new OutgoingMessageEntity(2L, false, null, Envelope.Type.SERVER_DELIVERY_RECEIPT_VALUE, null, timestampTwo, "+14152222222", sourceUuid, 2, null, null, 0));
     }};
 
     OutgoingMessageEntityList messagesList = new OutgoingMessageEntityList(messages, false);
@@ -515,7 +515,7 @@ void testGetMessagesBadAuth() throws Exception {
 
     List<OutgoingMessageEntity> messages = new LinkedList<OutgoingMessageEntity>() {{
       add(new OutgoingMessageEntity(1L, false, UUID.randomUUID(), Envelope.Type.CIPHERTEXT_VALUE, null, timestampOne, "+14152222222", UUID.randomUUID(), 2, "hi there".getBytes(), null, 0));
-      add(new OutgoingMessageEntity(2L, false, UUID.randomUUID(), Envelope.Type.RECEIPT_VALUE, null, timestampTwo, "+14152222222", UUID.randomUUID(), 2, null, null, 0));
+      add(new OutgoingMessageEntity(2L, false, UUID.randomUUID(), Envelope.Type.SERVER_DELIVERY_RECEIPT_VALUE, null, timestampTwo, "+14152222222", UUID.randomUUID(), 2, null, null, 0));
     }};
 
     OutgoingMessageEntityList messagesList = new OutgoingMessageEntityList(messages, false);
@@ -546,7 +546,7 @@ void testDeleteMessages() throws Exception {
 
     when(messagesManager.delete(AuthHelper.VALID_UUID, 1, "+14152222222", 31338))
         .thenReturn(Optional.of(new OutgoingMessageEntity(31337L, true, null,
-                                                          Envelope.Type.RECEIPT_VALUE,
+                                                          Envelope.Type.SERVER_DELIVERY_RECEIPT_VALUE,
                                                           null, System.currentTimeMillis(),
                                                           "+14152222222", sourceUuid, 1, null, null, 0)));
 

File: service/src/test/java/org/whispersystems/textsecuregcm/websocket/WebSocketConnectionTest.java
Patch:
@@ -823,7 +823,7 @@ public void testRetrieveMessageException() {
   }
 
   private OutgoingMessageEntity createMessage(long id, boolean cached, String sender, UUID senderUuid, long timestamp, boolean receipt, String content) {
-    return new OutgoingMessageEntity(id, cached, UUID.randomUUID(), receipt ? Envelope.Type.RECEIPT_VALUE : Envelope.Type.CIPHERTEXT_VALUE,
+    return new OutgoingMessageEntity(id, cached, UUID.randomUUID(), receipt ? Envelope.Type.SERVER_DELIVERY_RECEIPT_VALUE : Envelope.Type.CIPHERTEXT_VALUE,
                                      null, timestamp, sender, senderUuid, 1, content.getBytes(), null, 0);
   }
 

File: service/src/main/java/org/whispersystems/textsecuregcm/util/TorExitNodeManager.java
Patch:
@@ -69,7 +69,7 @@ public boolean isTorExitNode(final String address) {
   }
 
   private void handleExitListChanged(final InputStream exitList) {
-    REFRESH_TIMER.record(() -> handleExitListChanged(exitList));
+    REFRESH_TIMER.record(() -> handleExitListChangedStream(exitList));
   }
 
   @VisibleForTesting

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/MessageController.java
Patch:
@@ -647,7 +647,7 @@ private void sendMessage(Account destinationAccount, Device destinationDevice, l
       byte[] payload = new byte[1 + recipientKeyMaterial.length + commonPayload.length];
       payload[0] = MultiRecipientMessageProvider.VERSION;
       System.arraycopy(recipientKeyMaterial, 0, payload, 1, recipientKeyMaterial.length);
-      System.arraycopy(commonPayload, 0, payload, 1 + recipientKeyMaterial.length, payload.length);
+      System.arraycopy(commonPayload, 0, payload, 1 + recipientKeyMaterial.length, commonPayload.length);
 
       messageBuilder
           .setType(Type.UNIDENTIFIED_SENDER)

File: websocket-resources/src/test/java/org/whispersystems/websocket/WebSocketResourceProviderFactoryTest.java
Patch:
@@ -18,7 +18,6 @@
 import java.security.Principal;
 import java.util.Optional;
 import javax.security.auth.Subject;
-import javax.servlet.ServletException;
 import org.eclipse.jetty.websocket.api.Session;
 import org.eclipse.jetty.websocket.api.UpgradeRequest;
 import org.eclipse.jetty.websocket.servlet.ServletUpgradeRequest;
@@ -53,7 +52,7 @@ public void testUnauthorized() throws AuthenticationException, IOException {
   }
 
   @Test
-  public void testValidAuthorization() throws AuthenticationException, ServletException {
+  public void testValidAuthorization() throws AuthenticationException {
     ResourceConfig         jerseyEnvironment = new DropwizardResourceConfig();
     WebSocketEnvironment   environment       = mock(WebSocketEnvironment.class    );
     WebSocketAuthenticator authenticator     = mock(WebSocketAuthenticator.class  );
@@ -81,7 +80,7 @@ public void testValidAuthorization() throws AuthenticationException, ServletExce
   }
 
   @Test
-  public void testErrorAuthorization() throws AuthenticationException, ServletException, IOException {
+  public void testErrorAuthorization() throws AuthenticationException, IOException {
     ResourceConfig         jerseyEnvironment = new DropwizardResourceConfig();
     WebSocketEnvironment   environment       = mock(WebSocketEnvironment.class    );
     WebSocketAuthenticator authenticator     = mock(WebSocketAuthenticator.class  );

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/ReportMessageManager.java
Patch:
@@ -1,5 +1,7 @@
 package org.whispersystems.textsecuregcm.storage;
 
+import static com.codahale.metrics.MetricRegistry.name;
+
 import com.google.common.annotations.VisibleForTesting;
 import io.micrometer.core.instrument.Counter;
 import io.micrometer.core.instrument.MeterRegistry;
@@ -16,7 +18,7 @@
 public class ReportMessageManager {
 
   @VisibleForTesting
-  static final String REPORT_COUNTER_NAME = "reported";
+  static final String REPORT_COUNTER_NAME = name(ReportMessageManager.class, "reported");
 
   private final ReportMessageDynamoDb reportMessageDynamoDb;
   private final MeterRegistry meterRegistry;

File: websocket-resources/src/main/java/org/whispersystems/websocket/WebSocketResourceProvider.java
Patch:
@@ -140,7 +140,7 @@ public void onWebSocketText(String message) {
   }
 
   private void handleRequest(WebSocketRequestMessage requestMessage) {
-    ContainerRequest containerRequest = new ContainerRequest(null, URI.create(requestMessage.getPath()), requestMessage.getVerb(), new WebSocketSecurityContext(new ContextPrincipal(context)), new MapPropertiesDelegate(new HashMap<>()), null);
+    ContainerRequest containerRequest = new ContainerRequest(null, URI.create(requestMessage.getPath()), requestMessage.getVerb(), new WebSocketSecurityContext(new ContextPrincipal(context)), new MapPropertiesDelegate(new HashMap<>()), jerseyHandler.getConfiguration());
     containerRequest.headers(getCombinedHeaders(session.getUpgradeRequest().getHeaders(), requestMessage.getHeaders()));
 
     if (requestMessage.getBody().isPresent()) {

File: service/src/main/java/org/whispersystems/textsecuregcm/configuration/DonationConfiguration.java
Patch:
@@ -17,8 +17,8 @@ public class DonationConfiguration {
   private String uri;
   private String apiKey;
   private Set<String> supportedCurrencies;
-  private CircuitBreakerConfiguration circuitBreaker;
-  private RetryConfiguration retry;
+  private CircuitBreakerConfiguration circuitBreaker = new CircuitBreakerConfiguration();
+  private RetryConfiguration retry = new RetryConfiguration();
 
   @JsonProperty
   @NotEmpty

File: service/src/main/java/org/whispersystems/textsecuregcm/providers/MultiRecipientMessageProvider.java
Patch:
@@ -94,7 +94,7 @@ private UUID readUuid(InputStream stream) throws IOException {
   private long convertNetworkByteOrderToLong(byte[] buffer) {
     long result = 0;
     for (int i = 0; i < 8; i++) {
-      result = (result << (i * 8)) | (buffer[i] & 0xFFL);
+      result = (result << 8) | (buffer[i] & 0xFFL);
     }
     return result;
   }

File: service/src/test/java/org/whispersystems/textsecuregcm/tests/controllers/AccountControllerTest.java
Patch:
@@ -38,7 +38,6 @@
 import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
-import org.junit.jupiter.params.provider.CsvSource;
 import org.junit.jupiter.params.provider.MethodSource;
 import org.junit.jupiter.params.provider.ValueSource;
 import org.mockito.ArgumentCaptor;
@@ -1361,7 +1360,7 @@ void testSetApnIdByUuid() throws Exception {
   }
 
   @ParameterizedTest
-  @CsvSource("/v1/accounts/whoami/, /v1/accounts/me/")
+  @ValueSource(strings = {"/v1/accounts/whoami/", "/v1/accounts/me/"})
   public void testWhoAmI(final String path) {
     AccountCreationResult response =
         resources.getJerseyTest()

File: websocket-resources/src/main/java/org/whispersystems/websocket/WebSocketResourceProvider.java
Patch:
@@ -88,9 +88,7 @@ public void onWebSocketConnect(Session session) {
     this.context.setAuthenticated(authenticated);
     this.session.setIdleTimeout(idleTimeoutMillis);
 
-    if (connectListener.isPresent()) {
-      connectListener.get().onWebSocketConnect(this.context);
-    }
+    connectListener.ifPresent(listener -> listener.onWebSocketConnect(this.context));
   }
 
   @Override

File: service/src/main/java/org/whispersystems/textsecuregcm/securestorage/SecureStorageClient.java
Patch:
@@ -46,6 +46,7 @@ public SecureStorageClient(final ExternalServiceCredentialGenerator storageServi
                                                                         .withRedirect(HttpClient.Redirect.NEVER)
                                                                         .withExecutor(executor)
                                                                         .withName("secure-storage")
+                                                                        .withSecurityProtocol(FaultTolerantHttpClient.SECURITY_PROTOCOL_TLS_1_3)
                                                                         .withTrustedServerCertificate(configuration.getStorageCaCertificate())
                                                                         .build();
     }

File: service/src/test/java/org/whispersystems/textsecuregcm/tests/controllers/MessageControllerTest.java
Patch:
@@ -12,8 +12,8 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.anyBoolean;
 import static org.mockito.Mockito.anyString;
 import static org.mockito.Mockito.argThat;

File: service/src/main/java/org/whispersystems/textsecuregcm/controllers/MessageController.java
Patch:
@@ -136,7 +136,7 @@ public Response sendMessage(@Auth                                     Optional<A
           rateLimiters.getUnsealedSenderLimiter().validate(source.get().getUuid().toString());
         } catch (RateLimitExceededException e) {
           rejectUnsealedSenderLimit.mark();
-          logger.info("Rejected unsealed sender limit from: " + source.get().getNumber());
+          logger.debug("Rejected unsealed sender limit from: " + source.get().getNumber());
         }
       }
 

File: gcm-sender-async/src/test/java/org/whispersystems/gcm/server/SenderTest.java
Patch:
@@ -11,6 +11,7 @@
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -147,6 +148,7 @@ public void testServerErrorRecovery() throws InterruptedException, ExecutionExce
   }
 
   @Test
+  @Ignore
   public void testNetworkError() throws TimeoutException, InterruptedException, IOException {
     MockResponse response = new MockResponse().setResponseCode(200)
                                               .setBody(fixture("fixtures/response-success.json"));

File: gcm-sender-async/src/test/java/org/whispersystems/gcm/server/SimultaneousSenderTest.java
Patch:
@@ -10,6 +10,7 @@
 import com.fasterxml.jackson.databind.DeserializationFeature;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.github.tomakehurst.wiremock.junit.WireMockRule;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -61,6 +62,7 @@ public void testSimultaneousSuccess() throws TimeoutException, InterruptedExcept
   }
 
   @Test
+  @Ignore
   public void testSimultaneousFailure() throws TimeoutException, InterruptedException {
     stubFor(post(urlPathEqualTo("/gcm/send"))
                 .willReturn(aResponse()

File: service/src/main/java/org/whispersystems/textsecuregcm/push/ReceiptSender.java
Patch:
@@ -38,6 +38,7 @@ public void sendReceipt(Account source, String destination, long messageId)
 
     Account          destinationAccount = getDestinationAccount(destination);
     Envelope.Builder message            = Envelope.newBuilder()
+                                                  .setServerTimestamp(System.currentTimeMillis())
                                                   .setSource(source.getNumber())
                                                   .setSourceUuid(source.getUuid().toString())
                                                   .setSourceDevice((int) source.getAuthenticatedDevice().get().getId())

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/DynamicConfigurationManager.java
Patch:
@@ -1,6 +1,7 @@
 package org.whispersystems.textsecuregcm.storage;
 
 import com.amazonaws.ClientConfiguration;
+import com.amazonaws.auth.InstanceProfileCredentialsProvider;
 import com.amazonaws.services.appconfig.AmazonAppConfig;
 import com.amazonaws.services.appconfig.AmazonAppConfigClient;
 import com.amazonaws.services.appconfig.model.GetConfigurationRequest;
@@ -44,6 +45,7 @@ public class DynamicConfigurationManager implements Managed {
   public DynamicConfigurationManager(String application, String environment, String configurationName) {
     this(AmazonAppConfigClient.builder()
                               .withClientConfiguration(new ClientConfiguration().withClientExecutionTimeout(10000).withRequestTimeout(10000))
+                              .withCredentials(InstanceProfileCredentialsProvider.getInstance())
                               .build(),
          application, environment, configurationName, UUID.randomUUID().toString());
   }

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/Messages.java
Patch:
@@ -46,7 +46,6 @@ public class Messages {
   private final MetricRegistry metricRegistry      = SharedMetricRegistries.getOrCreate(Constants.METRICS_NAME);
   private final Timer          storeTimer          = metricRegistry.timer(name(Messages.class, "store"         ));
   private final Timer          loadTimer           = metricRegistry.timer(name(Messages.class, "load"          ));
-  private final Timer          hasMessagesTimer    = metricRegistry.timer(name(Messages.class, "hasMessages"   ));
   private final Timer          removeBySourceTimer = metricRegistry.timer(name(Messages.class, "removeBySource"));
   private final Timer          removeByGuidTimer   = metricRegistry.timer(name(Messages.class, "removeByGuid"  ));
   private final Timer          removeByIdTimer     = metricRegistry.timer(name(Messages.class, "removeById"    ));

File: service/src/test/java/org/whispersystems/textsecuregcm/websocket/WebSocketConnectionTest.java
Patch:
@@ -195,7 +195,7 @@ public CompletableFuture<WebSocketResponseMessage> answer(InvocationOnMock invoc
     futures.get(0).completeExceptionally(new IOException());
     futures.get(2).completeExceptionally(new IOException());
 
-    verify(storedMessages, times(1)).delete(eq(account.getNumber()), eq(accountUuid), eq(2L), eq(2L), eq(false));
+    verify(storedMessages, times(1)).delete(eq(account.getNumber()), eq(accountUuid), eq(2L), eq(outgoingMessages.get(1).getGuid()));
     verify(receiptSender, times(1)).sendReceipt(eq(account), eq("sender1"), eq(2222L));
 
     connection.stop();
@@ -712,7 +712,7 @@ public CompletableFuture<WebSocketResponseMessage> answer(InvocationOnMock invoc
 
     // We should delete all three messages even though we only sent two; one got discarded because it was too big for
     // desktop clients.
-    verify(storedMessages, times(3)).delete(eq(account.getNumber()), eq(accountUuid), eq(2L), anyLong(), anyBoolean());
+    verify(storedMessages, times(3)).delete(eq(account.getNumber()), eq(accountUuid), eq(2L), any(UUID.class));
 
     connection.stop();
     verify(client).close(anyInt(), anyString());
@@ -785,7 +785,7 @@ public CompletableFuture<WebSocketResponseMessage> answer(InvocationOnMock invoc
     futures.get(1).complete(response);
     futures.get(2).complete(response);
 
-    verify(storedMessages, times(3)).delete(eq(account.getNumber()), eq(accountUuid), eq(2L), anyLong(), anyBoolean());
+    verify(storedMessages, times(3)).delete(eq(account.getNumber()), eq(accountUuid), eq(2L), any(UUID.class));
 
     connection.stop();
     verify(client).close(anyInt(), anyString());

File: service/src/main/java/org/whispersystems/textsecuregcm/workers/SetFeatureFlagTask.java
Patch:
@@ -34,7 +34,7 @@ public void execute(final Map<String, List<String>> parameters, final PrintWrite
             out.println();
             printFeatureFlags(out);
         } else {
-            out.println("Usage: set-feature-flag?flag=FLAG_NAME&value=[true|false]");
+            out.println("Usage: set-feature-flag?flag=FLAG_NAME&active=[true|false]");
         }
     }
 }

File: service/src/main/java/org/whispersystems/textsecuregcm/configuration/DirectoryConfiguration.java
Patch:
@@ -8,6 +8,7 @@
 
 import javax.validation.Valid;
 import javax.validation.constraints.NotNull;
+import java.util.List;
 
 public class DirectoryConfiguration {
 
@@ -29,7 +30,7 @@ public class DirectoryConfiguration {
   @JsonProperty
   @NotNull
   @Valid
-  private DirectoryServerConfiguration server;
+  private List<DirectoryServerConfiguration> server;
 
   public RedisConfiguration getRedisConfiguration() {
     return redis;
@@ -43,8 +44,7 @@ public DirectoryClientConfiguration getDirectoryClientConfiguration() {
     return client;
   }
 
-  public DirectoryServerConfiguration getDirectoryServerConfiguration() {
+  public List<DirectoryServerConfiguration> getDirectoryServerConfiguration() {
     return server;
   }
-
 }

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/DirectoryReconciliationClient.java
Patch:
@@ -42,7 +42,7 @@ public DirectoryReconciliationClient(DirectoryServerConfiguration directoryServe
     this.client         = initializeClient(directoryServerConfiguration);
 
     SharedMetricRegistries.getOrCreate(Constants.METRICS_NAME)
-                          .register(name(getClass(), "days_until_certificate_expiration"),
+                          .register(name(getClass(), directoryServerConfiguration.getReplicationName(), "days_until_certificate_expiration"),
                                     new CertificateExpirationGauge(getCertificate(directoryServerConfiguration.getReplicationCaCertificate())));
   }
 

File: service/src/test/java/org/whispersystems/textsecuregcm/tests/storage/DirectoryReconcilerTest.java
Patch:
@@ -42,7 +42,7 @@ public class DirectoryReconcilerTest {
   private final BatchOperationHandle          batchOperationHandle  = mock(BatchOperationHandle.class);
   private final DirectoryManager              directoryManager      = mock(DirectoryManager.class);
   private final DirectoryReconciliationClient reconciliationClient  = mock(DirectoryReconciliationClient.class);
-  private final DirectoryReconciler           directoryReconciler   = new DirectoryReconciler(reconciliationClient, directoryManager);
+  private final DirectoryReconciler           directoryReconciler   = new DirectoryReconciler("test", true, reconciliationClient, directoryManager);
 
   private final DirectoryReconciliationResponse successResponse = new DirectoryReconciliationResponse(DirectoryReconciliationResponse.Status.OK);
 

File: service/src/main/java/org/whispersystems/textsecuregcm/configuration/RedisClusterConfiguration.java
Patch:
@@ -21,7 +21,7 @@ public class RedisClusterConfiguration {
 
     @JsonProperty
     @NotNull
-    private Duration timeout = Duration.ofMillis(3_500);
+    private Duration timeout = Duration.ofMillis(3_000);
 
     @JsonProperty
     @NotNull

File: service/src/main/java/org/whispersystems/textsecuregcm/push/ClientPresenceManager.java
Patch:
@@ -66,7 +66,7 @@ public class ClientPresenceManager extends RedisClusterPubSubAdapter<String, Str
     private final Meter remoteDisplacementMeter;
     private final Meter pubSubMessageMeter;
 
-    private static final int PRUNE_PEERS_INTERVAL_SECONDS = (int)Duration.ofMinutes(3).toSeconds();
+    private static final int PRUNE_PEERS_INTERVAL_SECONDS = (int)Duration.ofSeconds(30).toSeconds();
 
     static final String MANAGER_SET_KEY = "presence::managers";
 
@@ -115,7 +115,7 @@ public void start() {
 
         presenceCluster.useCluster(connection -> connection.sync().sadd(MANAGER_SET_KEY, managerId));
 
-        pruneMissingPeersFuture = scheduledExecutorService.scheduleAtFixedRate(() -> {
+        pruneMissingPeersFuture = scheduledExecutorService.scheduleWithFixedDelay(() -> {
             try {
                 pruneMissingPeers();
             } catch (final Throwable t) {

File: service/src/main/java/org/whispersystems/textsecuregcm/configuration/RedisClusterConfiguration.java
Patch:
@@ -16,7 +16,7 @@ public class RedisClusterConfiguration {
 
     @JsonProperty
     @NotNull
-    private Duration timeout = Duration.ofSeconds(10);
+    private Duration timeout = Duration.ofSeconds(3);
 
     @JsonProperty
     @NotNull

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/MessagePersister.java
Patch:
@@ -102,7 +102,7 @@ void persistNextQueues(final Instant currentTime) {
                 try {
                     persistQueue(accountUuid, deviceId);
                 } catch (final Exception e) {
-                    logger.warn("Failed to persist queue {}::{}; will schedule for retry", accountUuid, deviceId);
+                    logger.warn("Failed to persist queue {}::{}; will schedule for retry", accountUuid, deviceId, e);
                     messagesCache.addQueueToPersist(accountUuid, deviceId);
                 }
             }

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/MessagePersister.java
Patch:
@@ -120,7 +120,7 @@ void persistQueue(final String queue) {
         }
 
         try (final Timer.Context ignored = persistQueueTimer.time()) {
-            messagesCache.lockQueueForPersistence(queue);
+            messagesCache.lockQueueForPersistence(accountUuid, deviceId);
 
             try {
                 int messageCount = 0;
@@ -135,7 +135,7 @@ void persistQueue(final String queue) {
 
                 queueSizeHistogram.update(messageCount);
             } finally {
-                messagesCache.unlockQueueForPersistence(queue);
+                messagesCache.unlockQueueForPersistence(accountUuid, deviceId);
             }
         }
     }

File: service/src/test/java/org/whispersystems/textsecuregcm/storage/MessagesCacheTest.java
Patch:
@@ -325,8 +325,8 @@ public void handleMessagesPersisted() {
 
         messagesCache.addMessageAvailabilityListener(DESTINATION_UUID, DESTINATION_DEVICE_ID, listener);
 
-        messagesCache.lockQueueForPersistence(MessagesCache.getQueueName(DESTINATION_UUID, DESTINATION_DEVICE_ID));
-        messagesCache.unlockQueueForPersistence(MessagesCache.getQueueName(DESTINATION_UUID, DESTINATION_DEVICE_ID));
+        messagesCache.lockQueueForPersistence(DESTINATION_UUID, DESTINATION_DEVICE_ID);
+        messagesCache.unlockQueueForPersistence(DESTINATION_UUID, DESTINATION_DEVICE_ID);
 
         synchronized (notified) {
             while (!notified.get()) {

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/MessagesManager.java
Patch:
@@ -55,7 +55,7 @@ public OutgoingMessageEntityList getMessagesForDevice(String destination, UUID d
 
     List<OutgoingMessageEntity> messages = cachedMessagesOnly ? new ArrayList<>() : this.messages.load(destination, destinationDevice);
 
-    if (messages.size() <= Messages.RESULT_SET_CHUNK_SIZE) {
+    if (messages.size() < Messages.RESULT_SET_CHUNK_SIZE) {
       messages.addAll(messagesCache.get(destinationUuid, destinationDevice, Messages.RESULT_SET_CHUNK_SIZE - messages.size()));
     }
 

File: service/src/main/java/org/whispersystems/textsecuregcm/configuration/RedisClusterConfiguration.java
Patch:
@@ -16,7 +16,7 @@ public class RedisClusterConfiguration {
 
     @JsonProperty
     @NotNull
-    private Duration timeout = Duration.ofSeconds(2);
+    private Duration timeout = Duration.ofSeconds(10);
 
     @JsonProperty
     @NotNull

File: service/src/main/java/org/whispersystems/textsecuregcm/redis/FaultTolerantRedisCluster.java
Patch:
@@ -56,11 +56,11 @@ public FaultTolerantRedisCluster(final String name, final RedisClusterConfigurat
     }
 
     @VisibleForTesting
-    FaultTolerantRedisCluster(final String name, final RedisClusterClient clusterClient, final Duration timeout, final CircuitBreakerConfiguration circuitBreakerConfiguration) {
+    FaultTolerantRedisCluster(final String name, final RedisClusterClient clusterClient, final Duration commandTimeout, final CircuitBreakerConfiguration circuitBreakerConfiguration) {
         this.name = name;
 
         this.clusterClient = clusterClient;
-        this.clusterClient.setDefaultTimeout(timeout);
+        this.clusterClient.setDefaultTimeout(commandTimeout);
 
         this.stringConnection = clusterClient.connect();
         this.binaryConnection = clusterClient.connect(ByteArrayCodec.INSTANCE);

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -333,9 +333,9 @@ protected DistributionStatisticConfig defaultHistogramConfig() {
     ReplicatedJedisPool messagesClient      = messagesClientFactory.getRedisClientPool();
     ReplicatedJedisPool pushSchedulerClient = pushSchedulerClientFactory.getRedisClientPool();
 
-    FaultTolerantRedisCluster cacheCluster         = new FaultTolerantRedisCluster("main_cache_cluster", config.getCacheClusterConfiguration().getUrls(), config.getCacheClusterConfiguration().getTimeout(), config.getCacheClusterConfiguration().getCircuitBreakerConfiguration());
-    FaultTolerantRedisCluster messagesCacheCluster = new FaultTolerantRedisCluster("messages_cluster", config.getMessageCacheConfiguration().getRedisClusterConfiguration().getUrls(), config.getMessageCacheConfiguration().getRedisClusterConfiguration().getTimeout(), config.getMessageCacheConfiguration().getRedisClusterConfiguration().getCircuitBreakerConfiguration());
-    FaultTolerantRedisCluster metricsCluster       = new FaultTolerantRedisCluster("metrics_cluster", config.getMetricsClusterConfiguration().getUrls(), config.getMetricsClusterConfiguration().getTimeout(), config.getMetricsClusterConfiguration().getCircuitBreakerConfiguration());
+    FaultTolerantRedisCluster cacheCluster         = new FaultTolerantRedisCluster("main_cache_cluster", config.getCacheClusterConfiguration());
+    FaultTolerantRedisCluster messagesCacheCluster = new FaultTolerantRedisCluster("messages_cluster", config.getMessageCacheConfiguration().getRedisClusterConfiguration());
+    FaultTolerantRedisCluster metricsCluster       = new FaultTolerantRedisCluster("metrics_cluster", config.getMetricsClusterConfiguration());
 
     ScheduledExecutorService clientPresenceExecutor                = environment.lifecycle().scheduledExecutorService("clientPresenceManager").threads(1).build();
     ExecutorService          messageNotificationExecutor           = environment.lifecycle().executorService("messageCacheNotifications").maxThreads(8).workQueue(new ArrayBlockingQueue<>(1_000)).build();

File: service/src/main/java/org/whispersystems/textsecuregcm/workers/ClearMessagesCacheClusterCommand.java
Patch:
@@ -14,7 +14,7 @@ public ClearMessagesCacheClusterCommand() {
 
     @Override
     protected void run(final Bootstrap<WhisperServerConfiguration> bootstrap, final Namespace namespace, final WhisperServerConfiguration config) {
-        final FaultTolerantRedisCluster messagesCacheCluster = new FaultTolerantRedisCluster("messages_cluster", config.getMessageCacheConfiguration().getRedisClusterConfiguration().getUrls(), config.getMessageCacheConfiguration().getRedisClusterConfiguration().getTimeout(), config.getMessageCacheConfiguration().getRedisClusterConfiguration().getCircuitBreakerConfiguration());
+        final FaultTolerantRedisCluster messagesCacheCluster = new FaultTolerantRedisCluster("messages_cluster", config.getMessageCacheConfiguration().getRedisClusterConfiguration());
         messagesCacheCluster.useCluster(connection -> connection.sync().masters().commands().flushallAsync());
     }
 }

File: service/src/main/java/org/whispersystems/textsecuregcm/workers/DeleteUserCommand.java
Patch:
@@ -66,7 +66,7 @@ protected void run(Environment environment, Namespace namespace,
       Jdbi                  accountJdbi     = jdbiFactory.build(environment, configuration.getAccountsDatabaseConfiguration(), "accountdb");
       FaultTolerantDatabase accountDatabase = new FaultTolerantDatabase("account_database_delete_user", accountJdbi, configuration.getAccountsDatabaseConfiguration().getCircuitBreakerConfiguration());
 
-      FaultTolerantRedisCluster cacheCluster = new FaultTolerantRedisCluster("main_cache_cluster", configuration.getCacheClusterConfiguration().getUrls(), configuration.getCacheClusterConfiguration().getTimeout(), configuration.getCacheClusterConfiguration().getCircuitBreakerConfiguration());
+      FaultTolerantRedisCluster cacheCluster = new FaultTolerantRedisCluster("main_cache_cluster", configuration.getCacheClusterConfiguration());
 
       Accounts            accounts        = new Accounts(accountDatabase);
       ReplicatedJedisPool redisClient     = new RedisClientFactory("directory_cache_delete_command", configuration.getDirectoryConfiguration().getRedisConfiguration().getUrl(), configuration.getDirectoryConfiguration().getRedisConfiguration().getReplicaUrls(), configuration.getDirectoryConfiguration().getRedisConfiguration().getCircuitBreakerConfiguration()).getRedisClientPool();

File: service/src/test/java/org/whispersystems/textsecuregcm/redis/FaultTolerantRedisClusterTest.java
Patch:
@@ -9,6 +9,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.whispersystems.textsecuregcm.configuration.CircuitBreakerConfiguration;
+import org.whispersystems.textsecuregcm.configuration.RedisConnectionPoolConfiguration;
 
 import java.time.Duration;
 
@@ -40,7 +41,7 @@ public void setUp() {
         breakerConfiguration.setRingBufferSizeInClosedState(1);
         breakerConfiguration.setWaitDurationInOpenStateInSeconds(Integer.MAX_VALUE);
 
-        faultTolerantCluster = new FaultTolerantRedisCluster("test", clusterClient, Duration.ofSeconds(2), breakerConfiguration);
+        faultTolerantCluster = new FaultTolerantRedisCluster("test", clusterClient, Duration.ofSeconds(2), breakerConfiguration, new RedisConnectionPoolConfiguration());
     }
 
     @Test

File: service/src/test/java/org/whispersystems/textsecuregcm/push/ClientPresenceManagerTest.java
Patch:
@@ -123,7 +123,7 @@ public void testRemoteDisplacementAfterTopologyChange() throws InterruptedExcept
                 }
             });
 
-            getRedisCluster().usePubSubConnection(connection -> connection.getResources().eventBus().publish(new ClusterTopologyChangedEvent(List.of(), List.of())));
+            clientPresenceManager.getPubSubConnection().usePubSubConnection(connection -> connection.getResources().eventBus().publish(new ClusterTopologyChangedEvent(List.of(), List.of())));
 
             getRedisCluster().useWriteCluster(connection -> connection.sync().set(ClientPresenceManager.getPresenceKey(accountUuid, deviceId),
                     UUID.randomUUID().toString()));
@@ -170,8 +170,7 @@ public void testPruneMissingPeers() {
             addClientPresence(missingPeerId);
         }
 
-        getRedisCluster().usePubSubConnection(connection -> connection.sync().masters().commands().subscribe(ClientPresenceManager.getManagerPresenceChannel(presentPeerId)));
-
+        clientPresenceManager.getPubSubConnection().usePubSubConnection(connection -> connection.sync().masters().commands().subscribe(ClientPresenceManager.getManagerPresenceChannel(presentPeerId)));
         clientPresenceManager.pruneMissingPeers();
 
         assertEquals(1, (long)getRedisCluster().withWriteCluster(connection -> connection.sync().exists(ClientPresenceManager.getConnectedClientSetKey(presentPeerId))));

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -338,7 +338,7 @@ protected DistributionStatisticConfig defaultHistogramConfig() {
     FaultTolerantRedisCluster metricsCluster       = new FaultTolerantRedisCluster("metrics_cluster", config.getMetricsClusterConfiguration().getUrls(), config.getMetricsClusterConfiguration().getTimeout(), config.getMetricsClusterConfiguration().getCircuitBreakerConfiguration());
 
     ScheduledExecutorService clientPresenceExecutor                = environment.lifecycle().scheduledExecutorService("clientPresenceManager").threads(1).build();
-    ExecutorService          messageNotificationExecutor           = environment.lifecycle().executorService("messageCacheNotifications").maxThreads(8).build();
+    ExecutorService          messageNotificationExecutor           = environment.lifecycle().executorService("messageCacheNotifications").maxThreads(8).workQueue(new ArrayBlockingQueue<>(1_000)).build();
     ExecutorService          messageCacheClusterExperimentExecutor = environment.lifecycle().executorService("messages_cache_experiment").maxThreads(8).workQueue(new ArrayBlockingQueue<>(1_000)).build();
     ExecutorService          websocketExperimentExecutor           = environment.lifecycle().executorService("websocketPresenceExperiment").maxThreads(8).workQueue(new ArrayBlockingQueue<>(1_000)).build();
     ClientPresenceManager    clientPresenceManager                 = new ClientPresenceManager(messagesCacheCluster, clientPresenceExecutor);

File: service/src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -382,7 +382,6 @@ protected List<Tag> getConventionTags(@Nonnull Meter.Id id) {
     environment.lifecycle().manage(messagesCache);
     environment.lifecycle().manage(accountDatabaseCrawler);
     environment.lifecycle().manage(remoteConfigsManager);
-    environment.lifecycle().manage(cacheCluster);
     environment.lifecycle().manage(clusterMessagePersister);
 
     AWSCredentials         credentials               = new BasicAWSCredentials(config.getCdnConfiguration().getAccessKey(), config.getCdnConfiguration().getAccessSecret());

File: service/src/test/java/org/whispersystems/textsecuregcm/redis/AbstractRedisClusterTest.java
Patch:
@@ -64,7 +64,7 @@ protected FaultTolerantRedisCluster getRedisCluster() {
 
     @After
     public void tearDown() throws Exception {
-        redisCluster.stop();
+        redisCluster.shutdown();
     }
 
     @AfterClass

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/AccountDatabaseCrawlerCache.java
Patch:
@@ -52,7 +52,7 @@ public boolean isAccelerated() {
   }
 
   public boolean claimActiveWork(String workerId, long ttlMs) {
-    return "OK".equals(cacheCluster.withWriteCluster(connection -> connection.sync().set(ACCELERATE_KEY, workerId, SetArgs.Builder.nx().px(ttlMs))));
+    return "OK".equals(cacheCluster.withWriteCluster(connection -> connection.sync().set(ACTIVE_WORKER_KEY, workerId, SetArgs.Builder.nx().px(ttlMs))));
   }
 
   public void releaseActiveWork(String workerId) {

File: service/src/test/java/org/whispersystems/textsecuregcm/redis/AbstractRedisClusterTest.java
Patch:
@@ -113,7 +113,7 @@ private static void assembleCluster(final RedisServer... nodes) throws Interrupt
             final int startInclusive = i * slotsPerNode;
             final int endExclusive   = i == nodes.length - 1 ? MAX_SLOT : (i + 1) * slotsPerNode;
 
-            final RedisClient assignSlotClient = RedisClient.create(RedisURI.create("127.0.0.1", nodes[0].ports().get(0)));
+            final RedisClient assignSlotClient = RedisClient.create(RedisURI.create("127.0.0.1", nodes[i].ports().get(0)));
 
             try {
                 final int[] slots = new int[endExclusive - startInclusive];

File: service/src/main/java/org/whispersystems/textsecuregcm/push/APNSender.java
Patch:
@@ -92,7 +92,8 @@ public ListenableFuture<ApnResult> sendMessage(final ApnMessage message) {
     
     ListenableFuture<ApnResult> future = apnsClient.send(message.getApnId(), topic,
                                                          message.getMessage(),
-                                                         Instant.ofEpochMilli(message.getExpirationTime()));
+                                                         Instant.ofEpochMilli(message.getExpirationTime()),
+                                                         message.isVoip());
 
     Futures.addCallback(future, new FutureCallback<ApnResult>() {
       @Override

File: service/src/main/java/org/whispersystems/textsecuregcm/push/RetryingApnsClient.java
Patch:
@@ -7,6 +7,7 @@
 import com.eatthepath.pushy.apns.ApnsClientBuilder;
 import com.eatthepath.pushy.apns.DeliveryPriority;
 import com.eatthepath.pushy.apns.PushNotificationResponse;
+import com.eatthepath.pushy.apns.PushType;
 import com.eatthepath.pushy.apns.auth.ApnsSigningKey;
 import com.eatthepath.pushy.apns.metrics.dropwizard.DropwizardApnsClientMetricsListener;
 import com.eatthepath.pushy.apns.util.SimpleApnsPushNotification;
@@ -54,9 +55,9 @@ public RetryingApnsClient(ApnsClient apnsClient) {
     this.apnsClient = apnsClient;
   }
 
-  ListenableFuture<ApnResult> send(final String apnId, final String topic, final String payload, final Instant expiration) {
+  ListenableFuture<ApnResult> send(final String apnId, final String topic, final String payload, final Instant expiration, final boolean isVoip) {
     SettableFuture<ApnResult>  result       = SettableFuture.create();
-    SimpleApnsPushNotification notification = new SimpleApnsPushNotification(apnId, topic, payload, expiration, DeliveryPriority.IMMEDIATE);
+    SimpleApnsPushNotification notification = new SimpleApnsPushNotification(apnId, topic, payload, expiration, DeliveryPriority.IMMEDIATE, isVoip ? PushType.VOIP : PushType.ALERT);
         
     apnsClient.sendNotification(notification).whenComplete(new ResponseHandler(result));
 

File: service/src/test/java/org/whispersystems/textsecuregcm/experiment/ExperimentTest.java
Patch:
@@ -27,7 +27,7 @@ public void setUp() {
         controlNullMismatchCounter = mock(Counter.class);
         experimentNullMismatchCounter = mock(Counter.class);
 
-        experiment = new Experiment(matchCounter, errorCounter, bothPresentMismatchCounter, controlNullMismatchCounter, experimentNullMismatchCounter);
+        experiment = new Experiment("test", matchCounter, errorCounter, bothPresentMismatchCounter, controlNullMismatchCounter, experimentNullMismatchCounter);
     }
 
     @Test

File: service/src/main/java/org/whispersystems/textsecuregcm/configuration/TwilioConfiguration.java
Patch:
@@ -22,6 +22,7 @@
 import javax.validation.Valid;
 import javax.validation.constraints.NotEmpty;
 import javax.validation.constraints.NotNull;
+import java.util.ArrayList;
 import java.util.List;
 
 public class TwilioConfiguration {
@@ -55,7 +56,7 @@ public class TwilioConfiguration {
 
   @NotNull
   @Valid
-  private List<TwilioAlphaIdConfiguration> alphaId;
+  private List<TwilioAlphaIdConfiguration> alphaId = new ArrayList<>();
 
   public String getAccountId() {
     return accountId;

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/AccountDatabaseCrawlerCache.java
Patch:
@@ -81,7 +81,7 @@ public boolean claimActiveWork(String workerId, long ttlMs) {
 
       if (claimed) {
         // TODO Restore the NX flag when making the cluster the primary data store
-        cacheCluster.useWriteCluster(connection -> connection.sync().set(ACCELERATE_KEY, workerId, SetArgs.Builder.px(ttlMs)));
+        cacheCluster.useWriteCluster(connection -> connection.sync().set(ACTIVE_WORKER_KEY, workerId, SetArgs.Builder.px(ttlMs)));
       }
 
       return claimed;

File: websocket-resources/src/test/java/org/whispersystems/websocket/WebSocketResourceProviderFactoryTest.java
Patch:
@@ -2,6 +2,7 @@
 
 
 import org.eclipse.jetty.websocket.api.Session;
+import org.eclipse.jetty.websocket.api.UpgradeRequest;
 import org.eclipse.jetty.websocket.servlet.ServletUpgradeRequest;
 import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse;
 import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
@@ -58,6 +59,7 @@ public void testValidAuthorization() throws AuthenticationException, ServletExce
     when(environment.getAuthenticator()).thenReturn(authenticator);
     when(authenticator.authenticate(eq(request))).thenReturn(new WebSocketAuthenticator.AuthenticationResult<>(Optional.of(account), true));
     when(environment.jersey()).thenReturn(jerseyEnvironment);
+    when(session.getUpgradeRequest()).thenReturn(mock(UpgradeRequest.class));
 
     WebSocketResourceProviderFactory factory    = new WebSocketResourceProviderFactory(environment, Account.class);
     Object                           connection = factory.createWebSocket(request, response);

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/UsernamesManager.java
Patch:
@@ -131,7 +131,7 @@ private void redisSet(UUID uuid, String username, boolean required) {
       cacheCluster.useWriteCluster(connection -> {
         final RedisAdvancedClusterAsyncCommands<String, String> asyncCommands = connection.async();
 
-        maybeOldUsername.ifPresent(asyncCommands::del);
+        maybeOldUsername.ifPresent(oldUsername -> asyncCommands.del(getUsernameMapKey(oldUsername)));
         asyncCommands.set(uuidMapKey, username);
         asyncCommands.set(usernameMapKey, uuid.toString());
       });

File: service/src/main/java/org/whispersystems/textsecuregcm/push/GCMSender.java
Patch:
@@ -70,7 +70,6 @@ public void sendMessage(GcmMessage message) {
     String key;
 
     switch (message.getType()) {
-      case RECEIPT:      key = "receipt";      break;
       case NOTIFICATION: key = "notification"; break;
       case CHALLENGE:    key = "challenge";    break;
       default:           throw new AssertionError();

File: service/src/main/java/org/whispersystems/textsecuregcm/push/GcmMessage.java
Patch:
@@ -7,7 +7,7 @@
 public class GcmMessage {
 
   public enum Type {
-    RECEIPT, NOTIFICATION, CHALLENGE
+    NOTIFICATION, CHALLENGE
   }
 
   private final String           gcmId;

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/Account.java
Patch:
@@ -133,7 +133,9 @@ public Optional<Device> getDevice(long deviceId) {
   }
 
   public boolean isUuidAddressingSupported() {
-    return devices.stream().filter(Device::isEnabled).allMatch(device -> device.getCapabilities().isUuid());
+    return devices.stream()
+                  .filter(Device::isEnabled)
+                  .allMatch(device -> device.getCapabilities() != null && device.getCapabilities().isUuid());
   }
 
   public boolean isEnabled() {

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/Device.java
Patch:
@@ -23,6 +23,8 @@
 import org.whispersystems.textsecuregcm.entities.SignedPreKey;
 import org.whispersystems.textsecuregcm.util.Util;
 
+import javax.annotation.Nullable;
+import javax.validation.constraints.Null;
 import java.util.concurrent.TimeUnit;
 
 public class Device {
@@ -188,7 +190,7 @@ public AuthenticationCredentials getAuthenticationCredentials() {
     return new AuthenticationCredentials(authToken, salt);
   }
 
-  public DeviceCapabilities getCapabilities() {
+  public @Nullable DeviceCapabilities getCapabilities() {
     return capabilities;
   }
 

File: service/src/main/java/org/whispersystems/textsecuregcm/providers/RedisClientFactory.java
Patch:
@@ -48,6 +48,7 @@ public RedisClientFactory(String name, String url, List<String> replicaUrls, Cir
   {
     JedisPoolConfig poolConfig = new JedisPoolConfig();
     poolConfig.setTestOnBorrow(true);
+    poolConfig.setMaxWaitMillis(10000);
 
     URI redisURI = new URI(url);
 

File: service/src/main/java/org/whispersystems/textsecuregcm/storage/Accounts.java
Patch:
@@ -67,8 +67,9 @@ public boolean create(Account account) {
                           .mapTo(UUID.class)
                           .findOnly();
 
+        boolean isNew = uuid.equals(account.getUuid());
         account.setUuid(uuid);
-        return uuid.equals(account.getUuid());
+        return isNew;
       } catch (JsonProcessingException e) {
         throw new IllegalArgumentException(e);
       }

File: src/test/java/org/whispersystems/textsecuregcm/tests/controllers/AccountControllerTest.java
Patch:
@@ -63,6 +63,7 @@ public class AccountControllerTest {
   private        RateLimiter            rateLimiter            = mock(RateLimiter.class           );
   private        RateLimiter            pinLimiter             = mock(RateLimiter.class           );
   private        RateLimiter            smsVoiceIpLimiter      = mock(RateLimiter.class           );
+  private        RateLimiter            smsVoicePrefixLimiter  = mock(RateLimiter.class);
   private        SmsSender              smsSender              = mock(SmsSender.class             );
   private        DirectoryQueue         directoryQueue         = mock(DirectoryQueue.class);
   private        MessagesManager        storedMessages         = mock(MessagesManager.class       );
@@ -98,6 +99,7 @@ public void setup() throws Exception {
     when(rateLimiters.getVerifyLimiter()).thenReturn(rateLimiter);
     when(rateLimiters.getPinLimiter()).thenReturn(pinLimiter);
     when(rateLimiters.getSmsVoiceIpLimiter()).thenReturn(smsVoiceIpLimiter);
+    when(rateLimiters.getSmsVoicePrefixLimiter()).thenReturn(smsVoicePrefixLimiter);
 
     when(timeProvider.getCurrentTimeMillis()).thenReturn(System.currentTimeMillis());
 

File: src/main/java/org/whispersystems/textsecuregcm/auth/AccountAuthenticator.java
Patch:
@@ -66,7 +66,7 @@ public Optional<Account> authenticate(BasicCredentials basicCredentials)
         return Optional.empty();
       }
 
-      if (!device.get().isMaster() && !device.get().isActive()) {
+      if (!device.get().isMaster() && device.get().isIdleInactive()) {
         return Optional.empty();
       }
 

File: src/main/java/org/whispersystems/textsecuregcm/storage/PendingAccountsManager.java
Patch:
@@ -86,7 +86,7 @@ private Optional<StoredVerificationCode> memcacheGet(String number) {
       if (json == null) return Optional.absent();
       else              return Optional.of(mapper.readValue(json, StoredVerificationCode.class));
     } catch (IOException e) {
-      logger.warn("PendingAccountsManager", "Error deserializing value...");
+      logger.warn("Error deserializing value...", e);
       return Optional.absent();
     }
   }

File: src/test/java/org/whispersystems/textsecuregcm/tests/controllers/DeviceControllerTest.java
Patch:
@@ -94,7 +94,7 @@ public void setup() throws Exception {
     when(rateLimiters.getVerifyDeviceLimiter()).thenReturn(rateLimiter);
 
     when(account.getNextDeviceId()).thenReturn(42L);
-//    when(maxedAccount.getActiveDeviceCount()).thenReturn(1);
+//    when(maxedAccount.getActiveDeviceCount()).thenReturn(6);
 
     when(pendingDevicesManager.getCodeForNumber(AuthHelper.VALID_NUMBER)).thenReturn(Optional.of("5678901"));
     when(pendingDevicesManager.getCodeForNumber(AuthHelper.VALID_NUMBER_TWO)).thenReturn(Optional.of("1112223"));
@@ -133,7 +133,7 @@ public void maxDevicesTest() throws Exception {
                                  .header("Authorization", AuthHelper.getAuthHeader(AuthHelper.VALID_NUMBER_TWO, AuthHelper.VALID_PASSWORD_TWO))
                                  .get();
 
-    assertEquals(response.getStatus(), 411);
+    assertEquals(411, response.getStatus());
   }
 
   @Test

File: src/test/java/org/whispersystems/textsecuregcm/tests/util/AuthHelper.java
Patch:
@@ -48,7 +48,7 @@ public static AuthDynamicFeature getAuthFilter() {
     when(VALID_DEVICE_TWO.getId()).thenReturn(1L);
     when(VALID_ACCOUNT.getDevice(anyLong())).thenReturn(Optional.of(VALID_DEVICE));
     when(VALID_ACCOUNT_TWO.getDevice(eq(1L))).thenReturn(Optional.of(VALID_DEVICE_TWO));
-    when(VALID_ACCOUNT_TWO.getActiveDeviceCount()).thenReturn(4);
+    when(VALID_ACCOUNT_TWO.getActiveDeviceCount()).thenReturn(6);
     when(VALID_ACCOUNT.getNumber()).thenReturn(VALID_NUMBER);
     when(VALID_ACCOUNT_TWO.getNumber()).thenReturn(VALID_NUMBER_TWO);
     when(VALID_ACCOUNT.getAuthenticatedDevice()).thenReturn(Optional.of(VALID_DEVICE));

File: src/main/java/org/whispersystems/textsecuregcm/sms/SmsSender.java
Patch:
@@ -43,8 +43,8 @@ public void deliverSmsVerification(String destination, Optional<String> clientTy
       throws IOException
   {
     // Fix up mexico numbers to 'mobile' format just for SMS delivery.
-    if (destination.startsWith("+42") && !destination.startsWith("+421")) {
-      destination = "+421" + destination.substring(3);
+    if (destination.startsWith("+52") && !destination.startsWith("+521")) {
+      destination = "+521" + destination.substring(3);
     }
 
     try {

File: src/main/java/org/whispersystems/textsecuregcm/limits/LeakyBucket.java
Patch:
@@ -42,7 +42,8 @@ private LeakyBucket(int bucketSize, double leakRatePerMillis, int spaceRemaining
   }
 
   public boolean add(int amount) {
-    this.spaceRemaining = getUpdatedSpaceRemaining();
+    this.spaceRemaining       = getUpdatedSpaceRemaining();
+    this.lastUpdateTimeMillis = System.currentTimeMillis();
 
     if (this.spaceRemaining >= amount) {
       this.spaceRemaining -= amount;

File: src/test/java/org/whispersystems/textsecuregcm/tests/controllers/DeviceControllerTest.java
Patch:
@@ -94,7 +94,7 @@ public void setup() throws Exception {
     when(rateLimiters.getVerifyDeviceLimiter()).thenReturn(rateLimiter);
 
     when(account.getNextDeviceId()).thenReturn(42L);
-    when(maxedAccount.getActiveDeviceCount()).thenReturn(3);
+//    when(maxedAccount.getActiveDeviceCount()).thenReturn(1);
 
     when(pendingDevicesManager.getCodeForNumber(AuthHelper.VALID_NUMBER)).thenReturn(Optional.of("5678901"));
     when(pendingDevicesManager.getCodeForNumber(AuthHelper.VALID_NUMBER_TWO)).thenReturn(Optional.of("1112223"));

File: src/test/java/org/whispersystems/textsecuregcm/tests/util/AuthHelper.java
Patch:
@@ -48,7 +48,7 @@ public static AuthDynamicFeature getAuthFilter() {
     when(VALID_DEVICE_TWO.getId()).thenReturn(1L);
     when(VALID_ACCOUNT.getDevice(anyLong())).thenReturn(Optional.of(VALID_DEVICE));
     when(VALID_ACCOUNT_TWO.getDevice(eq(1L))).thenReturn(Optional.of(VALID_DEVICE_TWO));
-    when(VALID_ACCOUNT_TWO.getActiveDeviceCount()).thenReturn(3);
+    when(VALID_ACCOUNT_TWO.getActiveDeviceCount()).thenReturn(4);
     when(VALID_ACCOUNT.getNumber()).thenReturn(VALID_NUMBER);
     when(VALID_ACCOUNT_TWO.getNumber()).thenReturn(VALID_NUMBER_TWO);
     when(VALID_ACCOUNT.getAuthenticatedDevice()).thenReturn(Optional.of(VALID_DEVICE));

File: src/main/java/org/whispersystems/textsecuregcm/controllers/AccountController.java
Patch:
@@ -105,7 +105,7 @@ public AccountController(PendingAccountsManager pendingAccounts,
   @Path("/{transport}/code/{number}")
   public Response createAccount(@PathParam("transport") String transport,
                                 @PathParam("number")    String number,
-                                @QueryParam("client")   String client)
+                                @QueryParam("client")   Optional<String> client)
       throws IOException, RateLimitExceededException
   {
     if (!Util.isValidNumber(number)) {

File: src/main/java/org/whispersystems/textsecuregcm/sms/TwilioSmsSender.java
Patch:
@@ -19,6 +19,7 @@
 import com.codahale.metrics.Meter;
 import com.codahale.metrics.MetricRegistry;
 import com.codahale.metrics.SharedMetricRegistries;
+import com.google.common.base.Optional;
 import com.twilio.sdk.TwilioRestClient;
 import com.twilio.sdk.TwilioRestException;
 import com.twilio.sdk.resource.factory.CallFactory;
@@ -63,7 +64,7 @@ public TwilioSmsSender(TwilioConfiguration config) {
     this.random       = new Random(System.currentTimeMillis());
   }
 
-  public void deliverSmsVerification(String destination, String clientType, String verificationCode)
+  public void deliverSmsVerification(String destination, Optional<String> clientType, String verificationCode)
       throws IOException, TwilioRestException
   {
     TwilioRestClient    client         = new TwilioRestClient(accountId, accountToken);
@@ -72,7 +73,7 @@ public void deliverSmsVerification(String destination, String clientType, String
     messageParams.add(new BasicNameValuePair("To", destination));
     messageParams.add(new BasicNameValuePair("From", getRandom(random, numbers)));
     
-    if ("ios".equals(clientType)) {
+    if ("ios".equals(clientType.orNull())) {
       messageParams.add(new BasicNameValuePair("Body", String.format(SmsSender.SMS_IOS_VERIFICATION_TEXT, verificationCode, verificationCode)));
     } else {
       messageParams.add(new BasicNameValuePair("Body", String.format(SmsSender.SMS_VERIFICATION_TEXT, verificationCode)));

File: src/test/java/org/whispersystems/textsecuregcm/tests/controllers/AccountControllerTest.java
Patch:
@@ -82,7 +82,7 @@ public void testSendCode() throws Exception {
 
     assertThat(response.getStatus()).isEqualTo(200);
 
-    verify(smsSender).deliverSmsVerification(eq(SENDER), isNull(String.class), anyString());
+    verify(smsSender).deliverSmsVerification(eq(SENDER), eq(Optional.<String>absent()), anyString());
   }
   
   @Test
@@ -96,7 +96,7 @@ public void testSendiOSCode() throws Exception {
 
     assertThat(response.getStatus()).isEqualTo(200);
 
-    verify(smsSender).deliverSmsVerification(eq(SENDER), eq("ios"), anyString());
+    verify(smsSender).deliverSmsVerification(eq(SENDER), eq(Optional.of("ios")), anyString());
   }
 
   @Test

File: src/main/java/org/whispersystems/textsecuregcm/controllers/AccountController.java
Patch:
@@ -272,6 +272,7 @@ public void deleteApnRegistrationId(@Auth Account account) {
   @Timed
   @PUT
   @Path("/attributes/")
+  @Consumes(MediaType.APPLICATION_JSON)
   public void setAccountAttributes(@Auth Account account,
                                    @HeaderParam("X-Signal-Agent") String userAgent,
                                    @Valid AccountAttributes attributes)

File: src/main/java/org/whispersystems/textsecuregcm/push/PushSender.java
Patch:
@@ -65,8 +65,8 @@ public WebsocketSender getWebSocketSender() {
   private void sendGcmMessage(Account account, Device device, Envelope message)
       throws TransientPushFailureException, NotPushRegisteredException
   {
-    if (device.getFetchesMessages()) sendNotificationGcmMessage(account, device, message);
-    else                             sendPayloadGcmMessage(account, device, message);
+    sendNotificationGcmMessage(account, device, message);
+//    else                             sendPayloadGcmMessage(account, device, message);
   }
 
   private void sendPayloadGcmMessage(Account account, Device device, Envelope message)

File: src/main/java/org/whispersystems/textsecuregcm/federation/FederatedClient.java
Patch:
@@ -191,7 +191,8 @@ public void sendDeliveryReceipt(String source, long sourceDeviceId, String desti
       Response response = client.target(peer.getUrl())
                                 .path(String.format(RECEIPT_PATH, source, sourceDeviceId, destination, messageId))
                                 .request()
-                                .put(Entity.json(null));
+                                .property(ClientProperties.SUPPRESS_HTTP_COMPLIANCE_VALIDATION, true)
+                                .put(null);
 
       if (response.getStatus() != 200 && response.getStatus() != 204) {
         throw new WebApplicationException(response);

File: src/main/java/org/whispersystems/textsecuregcm/sms/TwilioSmsSender.java
Patch:
@@ -40,7 +40,7 @@ public class TwilioSmsSender {
 
   public static final String SAY_TWIML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                                          "<Response>\n" +
-                                         "    <Say voice=\"woman\" language=\"en\">" + SmsSender.VOX_VERIFICATION_TEXT + "%s</Say>\n" +
+                                         "    <Say voice=\"woman\" language=\"en\" loop=\"3\">" + SmsSender.VOX_VERIFICATION_TEXT + "%s.</Say>\n" +
                                          "</Response>";
 
   private final MetricRegistry metricRegistry = SharedMetricRegistries.getOrCreate(Constants.METRICS_NAME);

File: src/main/java/org/whispersystems/textsecuregcm/websocket/WebSocketConnection.java
Patch:
@@ -141,7 +141,7 @@ private void sendDeliveryReceiptFor(OutgoingMessageSignal message) {
       Optional<Account> source = accountsManager.get(message.getSource());
 
       if (!source.isPresent()) {
-        logger.warn("Source account disappeared? (%s)", message.getSource());
+        logger.warn(String.format("Source account disappeared? (%s)", message.getSource()));
         return;
       }
 

File: src/main/java/org/whispersystems/textsecuregcm/controllers/ProvisioningController.java
Patch:
@@ -15,6 +15,7 @@
 import javax.ws.rs.PUT;
 import javax.ws.rs.Path;
 import javax.ws.rs.PathParam;
+import javax.ws.rs.Produces;
 import javax.ws.rs.WebApplicationException;
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.core.Response;
@@ -37,6 +38,7 @@ public ProvisioningController(RateLimiters rateLimiters, PushSender pushSender)
   @Path("/{destination}")
   @PUT
   @Consumes(MediaType.APPLICATION_JSON)
+  @Produces(MediaType.APPLICATION_JSON)
   public void sendProvisioningMessage(@Auth                     Account source,
                                       @PathParam("destination") String destinationName,
                                       @Valid                    ProvisioningMessage message)

File: src/main/java/org/whispersystems/textsecuregcm/push/PushSender.java
Patch:
@@ -58,8 +58,9 @@ public WebsocketSender getWebSocketSender() {
   private void sendGcmMessage(Account account, Device device, OutgoingMessageSignal message)
       throws TransientPushFailureException, NotPushRegisteredException
   {
-    if (device.getFetchesMessages()) sendNotificationGcmMessage(account, device, message);
-    else                             sendPayloadGcmMessage(account, device, message);
+//    if (device.getFetchesMessages()) sendNotificationGcmMessage(account, device, message);
+//    else                             sendPayloadGcmMessage(account, device, message);
+    sendPayloadGcmMessage(account, device, message);
   }
 
   private void sendPayloadGcmMessage(Account account, Device device, OutgoingMessageSignal message)

File: src/main/java/org/whispersystems/textsecuregcm/WhisperServerConfiguration.java
Patch:
@@ -17,14 +17,13 @@
 package org.whispersystems.textsecuregcm;
 
 import com.fasterxml.jackson.annotation.JsonProperty;
-import org.whispersystems.textsecuregcm.configuration.RedisConfiguration;
 import org.whispersystems.textsecuregcm.configuration.FederationConfiguration;
 import org.whispersystems.textsecuregcm.configuration.GraphiteConfiguration;
-import org.whispersystems.textsecuregcm.configuration.MemcacheConfiguration;
 import org.whispersystems.textsecuregcm.configuration.NexmoConfiguration;
 import org.whispersystems.textsecuregcm.configuration.PushConfiguration;
 import org.whispersystems.textsecuregcm.configuration.RateLimitsConfiguration;
 import org.whispersystems.textsecuregcm.configuration.RedPhoneConfiguration;
+import org.whispersystems.textsecuregcm.configuration.RedisConfiguration;
 import org.whispersystems.textsecuregcm.configuration.S3Configuration;
 import org.whispersystems.textsecuregcm.configuration.TwilioConfiguration;
 import org.whispersystems.textsecuregcm.configuration.WebsocketConfiguration;

File: src/main/java/org/whispersystems/textsecuregcm/limits/RateLimiter.java
Patch:
@@ -73,7 +73,7 @@ public void validate(String key) throws RateLimitExceededException {
 
   private void setBucket(String key, LeakyBucket bucket) {
     try (Jedis jedis = cacheClient.getResource()) {
-      String serialized = mapper.writeValueAsString(bucket);
+      String serialized = bucket.serialize(mapper);
       jedis.setex(getBucketName(key), (int) Math.ceil((bucketSize / leakRatePerMillis) / 1000), serialized);
     } catch (JsonProcessingException e) {
       throw new IllegalArgumentException(e);
@@ -85,7 +85,7 @@ private LeakyBucket getBucket(String key) {
       String serialized = jedis.get(getBucketName(key));
 
       if (serialized != null) {
-        return mapper.readValue(serialized, LeakyBucket.class);
+        return LeakyBucket.fromSerialized(mapper, serialized);
       }
     } catch (IOException e) {
       logger.warn("Deserialization error", e);

File: src/main/java/org/whispersystems/textsecuregcm/controllers/DeviceController.java
Patch:
@@ -31,6 +31,7 @@
 import org.whispersystems.textsecuregcm.storage.AccountsManager;
 import org.whispersystems.textsecuregcm.storage.Device;
 import org.whispersystems.textsecuregcm.storage.PendingDevicesManager;
+import org.whispersystems.textsecuregcm.util.Util;
 import org.whispersystems.textsecuregcm.util.VerificationCode;
 
 import javax.validation.Valid;
@@ -119,6 +120,7 @@ public DeviceResponse verifyDeviceToken(@PathParam("verification_code") String v
       device.setSignalingKey(accountAttributes.getSignalingKey());
       device.setFetchesMessages(accountAttributes.getFetchesMessages());
       device.setId(account.get().getNextDeviceId());
+      device.setLastSeen(Util.todayInMillis());
 
       account.get().addDevice(device);
       accounts.update(account.get());

File: src/main/java/org/whispersystems/textsecuregcm/controllers/ReceiptController.java
Patch:
@@ -18,7 +18,7 @@
 import javax.ws.rs.WebApplicationException;
 import javax.ws.rs.core.Response;
 import java.io.IOException;
-import java.util.List;
+import java.util.Set;
 
 import io.dropwizard.auth.Auth;
 import static org.whispersystems.textsecuregcm.entities.MessageProtos.OutgoingMessageSignal;
@@ -74,8 +74,8 @@ private void sendRelayedReceipt(Account source, String destination, long message
   private void sendDirectReceipt(Account source, String destination, long messageId)
       throws NotPushRegisteredException, TransientPushFailureException, NoSuchUserException
   {
-    Account      destinationAccount = getDestinationAccount(destination);
-    List<Device> destinationDevices = destinationAccount.getDevices();
+    Account     destinationAccount = getDestinationAccount(destination);
+    Set<Device> destinationDevices = destinationAccount.getDevices();
 
     OutgoingMessageSignal.Builder message =
         OutgoingMessageSignal.newBuilder()

File: src/main/java/org/whispersystems/textsecuregcm/federation/NonLimitedAccount.java
Patch:
@@ -40,6 +40,6 @@ public Optional<String> getRelay() {
 
   @Override
   public Optional<Device> getAuthenticatedDevice() {
-    return Optional.of(new Device(deviceId, null, null, null, null, null, false, 0, null));
+    return Optional.of(new Device(deviceId, null, null, null, null, null, false, 0, null, System.currentTimeMillis()));
   }
 }

File: src/test/java/org/whispersystems/textsecuregcm/tests/websocket/WebSocketConnectionTest.java
Patch:
@@ -25,8 +25,10 @@
 
 import java.io.IOException;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Set;
 
 import io.dropwizard.auth.basic.BasicCredentials;
 import static org.junit.Assert.assertTrue;
@@ -127,7 +129,7 @@ public void testOpen() throws Exception {
 
     final Device sender1device = mock(Device.class);
 
-    List<Device> sender1devices = new LinkedList<Device>() {{
+    Set<Device> sender1devices = new HashSet<Device>() {{
       add(sender1device);
     }};
 

File: src/main/java/org/whispersystems/textsecuregcm/push/PushSender.java
Patch:
@@ -32,6 +32,8 @@ public class PushSender {
 
   private final Logger logger = LoggerFactory.getLogger(PushSender.class);
 
+  private static final String APN_PAYLOAD = "{\"aps\":{\"sound\":\"default\",\"alert\":{\"loc-key\":\"APN_Message\"},\"content-available\":1,\"category\":\"Signal_Message\"}}";
+
   private final PushServiceClient pushServiceClient;
   private final WebsocketSender   webSocketSender;
 
@@ -87,9 +89,7 @@ private void sendApnMessage(Account account, Device device, PendingMessage outgo
 
     if (!online && !outgoingMessage.isReceipt()) {
       ApnMessage apnMessage = new ApnMessage(device.getApnId(), account.getNumber(),
-                                             (int)device.getId(),
-                                             outgoingMessage.getEncryptedOutgoingMessage());
-
+                                             (int)device.getId(), APN_PAYLOAD);
       pushServiceClient.send(apnMessage);
     }
   }

File: src/main/java/org/whispersystems/textsecuregcm/WhisperServerService.java
Patch:
@@ -172,7 +172,7 @@ public void run(WhisperServerConfiguration config, Environment environment)
                                                                deviceAuthenticator,
                                                                Device.class, "WhisperServer"));
 
-    environment.jersey().register(new AccountController(pendingAccountsManager, accountsManager, rateLimiters, smsSender));
+    environment.jersey().register(new AccountController(pendingAccountsManager, accountsManager, rateLimiters, smsSender, storedMessages));
     environment.jersey().register(new DeviceController(pendingDevicesManager, accountsManager, rateLimiters));
     environment.jersey().register(new DirectoryController(rateLimiters, directory));
     environment.jersey().register(new FederationControllerV1(accountsManager, attachmentController, messageController, keysControllerV1));

File: src/main/java/org/whispersystems/textsecuregcm/controllers/WebsocketController.java
Patch:
@@ -94,7 +94,7 @@ public void onWebSocketConnect(Session session) {
 
       this.account = account.get();
       this.device  = account.get().getAuthenticatedDevice().get();
-      this.address = new WebsocketAddress(this.account.getId(), this.device.getId());
+      this.address = new WebsocketAddress(this.account.getNumber(), this.device.getId());
       this.session = session;
 
       this.session.setIdleTimeout(10 * 60 * 1000);
@@ -148,7 +148,7 @@ public void onWebSocketClose(int i, String s) {
         pushSender.sendMessage(account, device, remainingMessage);
       } catch (NotPushRegisteredException | TransientPushFailureException e) {
         logger.warn("onWebSocketClose", e);
-        storedMessages.insert(account.getId(), device.getId(), remainingMessage);
+        storedMessages.insert(address, remainingMessage);
       }
     }
   }
@@ -208,7 +208,7 @@ private void handleMessageAck(String message) {
   }
 
   private void handleQueryDatabase() {
-    List<PendingMessage> messages = storedMessages.getMessagesForDevice(account.getId(), device.getId());
+    List<PendingMessage> messages = storedMessages.getMessagesForDevice(address);
 
     for (PendingMessage message : messages) {
       handleDeliverOutgoingMessage(message);

File: src/main/java/org/whispersystems/textsecuregcm/push/WebsocketSender.java
Patch:
@@ -57,14 +57,14 @@ public WebsocketSender(StoredMessages storedMessages, PubSubManager pubSubManage
   public void sendMessage(Account account, Device device, PendingMessage pendingMessage) {
     try {
       String           serialized    = mapper.writeValueAsString(pendingMessage);
-      WebsocketAddress address       = new WebsocketAddress(account.getId(), device.getId());
+      WebsocketAddress address       = new WebsocketAddress(account.getNumber(), device.getId());
       PubSubMessage    pubSubMessage = new PubSubMessage(PubSubMessage.TYPE_DELIVER, serialized);
 
       if (pubSubManager.publish(address, pubSubMessage)) {
         onlineMeter.mark();
       } else {
         offlineMeter.mark();
-        storedMessages.insert(account.getId(), device.getId(), pendingMessage);
+        storedMessages.insert(address, pendingMessage);
         pubSubManager.publish(address, new PubSubMessage(PubSubMessage.TYPE_QUERY_DB, null));
       }
     } catch (JsonProcessingException e) {

File: src/main/java/org/whispersystems/textsecuregcm/storage/Accounts.java
Patch:
@@ -92,7 +92,7 @@ public Account map(int i, ResultSet resultSet, StatementContext statementContext
     {
       try {
         Account account = mapper.readValue(resultSet.getString(DATA), Account.class);
-        account.setId(resultSet.getLong(ID));
+//        account.setId(resultSet.getLong(ID));
 
         return account;
       } catch (IOException e) {

File: src/test/java/org/whispersystems/textsecuregcm/tests/controllers/WebsocketControllerTest.java
Patch:
@@ -94,7 +94,6 @@ public void testOpen() throws Exception {
     }};
 
     when(device.getId()).thenReturn(2L);
-    when(account.getId()).thenReturn(31337L);
     when(account.getAuthenticatedDevice()).thenReturn(Optional.of(device));
     when(account.getNumber()).thenReturn("+14152222222");
     when(session.getRemote()).thenReturn(remote);
@@ -120,15 +119,15 @@ public void testOpen() throws Exception {
     when(accountAuthenticator.authenticate(eq(new BasicCredentials(VALID_USER, VALID_PASSWORD))))
         .thenReturn(Optional.of(account));
 
-    when(storedMessages.getMessagesForDevice(account.getId(), device.getId()))
+    when(storedMessages.getMessagesForDevice(new WebsocketAddress(account.getNumber(), device.getId())))
         .thenReturn(outgoingMessages);
 
     WebsocketControllerFactory factory    = new WebsocketControllerFactory(accountAuthenticator, accountsManager, pushSender, storedMessages, pubSubManager);
     WebsocketController        controller = (WebsocketController) factory.createWebSocket(null, null);
 
     controller.onWebSocketConnect(session);
 
-    verify(pubSubManager).subscribe(eq(new WebsocketAddress(31337L, 2L)), eq((controller)));
+    verify(pubSubManager).subscribe(eq(new WebsocketAddress("+14152222222", 2L)), eq((controller)));
     verify(remote, times(3)).sendStringByFuture(anyString());
 
     controller.onWebSocketText(mapper.writeValueAsString(new AcknowledgeWebsocketMessage(1)));

File: src/main/java/org/whispersystems/textsecuregcm/storage/StoredMessages.java
Patch:
@@ -68,7 +68,7 @@ public List<String> getMessagesForDevice(long accountId, long deviceId) {
       jedis = jedisPool.getResource();
       String message;
 
-      while ((message = jedis.rpop(QUEUE_PREFIX + accountId + ":" + deviceId)) != null) {
+      while ((message = jedis.rpop(getKey(accountId, deviceId))) != null) {
         messages.add(message);
       }
 

File: src/main/java/org/whispersystems/textsecuregcm/util/Base64.java
Patch:
@@ -1241,7 +1241,7 @@ public static byte[] decode( byte[] source, int off, int len, int options )
      * @since 1.4
      */
     public static byte[] decode( String s ) throws java.io.IOException {
-        return decode( s, NO_OPTIONS );
+        return decode( s, DONT_GUNZIP );
     }
 
     

File: src/main/java/org/whispersystems/textsecuregcm/controllers/MessageController.java
Patch:
@@ -186,7 +186,8 @@ private void sendRelayMessage(Account source,
   {
     try {
       FederatedClient client = federatedClientManager.getClient(messages.getRelay());
-      client.sendMessages(source.getNumber(), destinationName, messages);
+      client.sendMessages(source.getNumber(), source.getAuthenticatedDevice().get().getId(),
+                          destinationName, messages);
     } catch (NoSuchPeerException e) {
       throw new NoSuchUserException(e);
     }

File: src/main/java/org/whispersystems/textsecuregcm/federation/FederatedClient.java
Patch:
@@ -64,7 +64,7 @@ public class FederatedClient {
 
   private static final String USER_COUNT_PATH     = "/v1/federation/user_count";
   private static final String USER_TOKENS_PATH    = "/v1/federation/user_tokens/%d";
-  private static final String RELAY_MESSAGE_PATH  = "/v1/federation/messages/%s/%s";
+  private static final String RELAY_MESSAGE_PATH  = "/v1/federation/messages/%s/%d/%s";
   private static final String PREKEY_PATH_DEVICE  = "/v1/federation/key/%s/%s";
   private static final String ATTACHMENT_URI_PATH = "/v1/federation/attachment/%d";
 
@@ -155,11 +155,11 @@ public List<ClientContact> getUserTokens(int offset) {
     }
   }
 
-  public void sendMessages(String source, String destination, IncomingMessageList messages)
+  public void sendMessages(String source, long sourceDeviceId, String destination, IncomingMessageList messages)
       throws IOException
   {
     try {
-      WebResource    resource = client.resource(peer.getUrl()).path(String.format(RELAY_MESSAGE_PATH, source, destination));
+      WebResource    resource = client.resource(peer.getUrl()).path(String.format(RELAY_MESSAGE_PATH, source, sourceDeviceId, destination));
       ClientResponse response = resource.type(MediaType.APPLICATION_JSON)
                                         .header("Authorization", authorizationHeader)
                                         .entity(messages)

File: src/main/java/org/whispersystems/textsecuregcm/controllers/MessageController.java
Patch:
@@ -235,7 +235,9 @@ private void validateLegacyDestinations(List<IncomingMessage> messages)
     String destination = null;
 
     for (IncomingMessage message : messages) {
-      if (destination != null && !destination.equals(message.getDestination())) {
+      if ((message.getDestination() == null) ||
+          (destination != null && !destination.equals(message.getDestination())))
+      {
         throw new ValidationException("Multiple account destinations!");
       }
 

File: src/main/java/org/whispersystems/textsecuregcm/entities/IncomingMessage.java
Patch:
@@ -25,7 +25,6 @@ public class IncomingMessage {
   private int    type;
 
   @JsonProperty
-  @NotEmpty
   private String destination;
 
   @JsonProperty

File: src/main/java/org/whispersystems/textsecuregcm/controllers/MessageController.java
Patch:
@@ -88,12 +88,13 @@ public void sendMessage(@Auth                     Account source,
     rateLimiters.getMessagesLimiter().validate(source.getNumber());
 
     try {
-      if (messages.getRelay() != null) sendLocalMessage(source, destinationName, messages);
+      if (messages.getRelay() == null) sendLocalMessage(source, destinationName, messages);
       else                             sendRelayMessage(source, destinationName, messages);
     } catch (NoSuchUserException e) {
       throw new WebApplicationException(Response.status(404).build());
     } catch (MismatchedDevicesException e) {
       throw new WebApplicationException(Response.status(409)
+                                                .type(MediaType.APPLICATION_JSON_TYPE)
                                                 .entity(new MismatchedDevices(e.getMissingDevices(),
                                                                               e.getExtraDevices()))
                                                 .build());

File: src/main/java/org/whispersystems/textsecuregcm/storage/Keys.java
Patch:
@@ -63,7 +63,8 @@ public abstract class Keys {
   @Mapper(PreKeyMapper.class)
   abstract PreKey retrieveFirst(@Bind("number") String number, @Bind("device_id") long deviceId);
 
-  @SqlQuery("SELECT DISTINCT ON (number, device_id) * FROM keys WHERE number = :number ORDER BY key_id ASC FOR UPDATE")
+  @SqlQuery("SELECT DISTINCT ON (number, device_id) * FROM keys WHERE number = :number ORDER BY number, device_id, key_id ASC")
+  @Mapper(PreKeyMapper.class)
   abstract List<PreKey> retrieveFirst(@Bind("number") String number);
 
   @Transaction(TransactionIsolationLevel.SERIALIZABLE)

File: src/main/java/org/whispersystems/textsecuregcm/controllers/ValidationException.java
Patch:
@@ -18,4 +18,7 @@
 
 
 public class ValidationException extends Exception {
+  public ValidationException(String s) {
+    super(s);
+  }
 }

File: src/main/java/org/whispersystems/textsecuregcm/entities/PreKey.java
Patch:
@@ -35,7 +35,6 @@ public class PreKey {
   private String  number;
 
   @JsonProperty
-  @NotNull
   private long deviceId;
 
   @JsonProperty

File: src/main/java/org/whispersystems/textsecuregcm/limits/RateLimiters.java
Patch:
@@ -59,6 +59,7 @@ public RateLimiters(RateLimitsConfiguration config, MemcachedClient memcachedCli
     this.messagesLimiter = new RateLimiter(memcachedClient, "messages",
                                            config.getMessages().getBucketSize(),
                                            config.getMessages().getLeakRatePerMinute());
+
   }
 
   public RateLimiter getMessagesLimiter() {

File: src/main/java/org/whispersystems/textsecuregcm/storage/PendingDevices.java
Patch:
@@ -20,7 +20,7 @@
 import org.skife.jdbi.v2.sqlobject.SqlQuery;
 import org.skife.jdbi.v2.sqlobject.SqlUpdate;
 
-public interface PendingDeviceRegistrations {
+public interface PendingDevices {
 
   @SqlUpdate("WITH upsert AS (UPDATE pending_devices SET verification_code = :verification_code WHERE number = :number RETURNING *) " +
              "INSERT INTO pending_devices (number, verification_code) SELECT :number, :verification_code WHERE NOT EXISTS (SELECT * FROM upsert)")

File: src/main/java/org/whispersystems/textsecuregcm/controllers/MessageController.java
Patch:
@@ -257,11 +257,9 @@ private List<Pair<LocalOrRemoteDevice, OutgoingMessageSignal>> getOutgoingMessag
 
       outgoingMessage.setTimestamp(System.currentTimeMillis());
 
-      int index = 0;
-
       for (String destination : destinationNumbers) {
         if (!destination.equals(incoming.getDestination()))
-          outgoingMessage.setDestinations(index++, destination);
+          outgoingMessage.addDestinations(destination);
       }
 
       LocalOrRemoteDevice device = null;

File: src/main/java/org/whispersystems/textsecuregcm/controllers/AttachmentController.java
Patch:
@@ -78,8 +78,8 @@ public Response allocateAttachment(@Auth Device device) throws RateLimitExceeded
   @GET
   @Produces(MediaType.APPLICATION_JSON)
   @Path("/{attachmentId}")
-  public Response redirectToAttachment(@Auth Device device,
-                                       @PathParam("attachmentId") long attachmentId,
+  public Response redirectToAttachment(@Auth                      Device device,
+                                       @PathParam("attachmentId") long   attachmentId,
                                        @QueryParam("relay")       String relay)
   {
     try {

File: src/main/java/org/whispersystems/textsecuregcm/controllers/KeysController.java
Patch:
@@ -95,7 +95,7 @@ private List<PreKey> getKeys(Device device, String number, String relay) throws
   @GET
   @Path("/{number}")
   @Produces(MediaType.APPLICATION_JSON)
-  public Response get(@Auth Device device,
+  public Response get(@Auth                    Device device,
                       @PathParam("number")     String number,
                       @QueryParam("multikeys") Optional<String> multikey,
                       @QueryParam("relay")     String relay)

File: src/main/java/org/whispersystems/textsecuregcm/controllers/MessageController.java
Patch:
@@ -74,7 +74,7 @@ public class MessageController extends HttpServlet {
   private final Logger logger       = LoggerFactory.getLogger(MessageController.class);
 
   private final RateLimiters           rateLimiters;
-  private final DeviceAuthenticator deviceAuthenticator;
+  private final DeviceAuthenticator    deviceAuthenticator;
   private final PushSender             pushSender;
   private final FederatedClientManager federatedClientManager;
   private final ObjectMapper           objectMapper;
@@ -86,7 +86,7 @@ public MessageController(RateLimiters rateLimiters,
                            FederatedClientManager federatedClientManager)
   {
     this.rateLimiters           = rateLimiters;
-    this.deviceAuthenticator = deviceAuthenticator;
+    this.deviceAuthenticator    = deviceAuthenticator;
     this.pushSender             = pushSender;
     this.federatedClientManager = federatedClientManager;
     this.objectMapper           = new ObjectMapper();

File: src/main/java/org/whispersystems/textsecuregcm/controllers/DeviceController.java
Patch:
@@ -66,7 +66,6 @@ public DeviceController(PendingDevicesManager pendingDevices,
 
   @Timed
   @GET
-  @Path("")
   @Produces(MediaType.APPLICATION_JSON)
   public VerificationCode createDeviceToken(@Auth Account account)
       throws RateLimitExceededException

File: src/main/java/org/whispersystems/textsecuregcm/controllers/KeysController.java
Patch:
@@ -46,7 +46,7 @@
 @Path("/v1/keys")
 public class KeysController {
 
-  private final Logger logger = LoggerFactory.getLogger(DeviceController.class);
+  private final Logger logger = LoggerFactory.getLogger(KeysController.class);
 
   private final RateLimiters           rateLimiters;
   private final Keys                   keys;

File: src/main/java/org/whispersystems/textsecuregcm/push/PushSender.java
Patch:
@@ -106,7 +106,7 @@ private void sendApnMessage(Account account, EncryptedOutgoingMessage outgoingMe
     apnSender.sendMessage(account.getApnRegistrationId(), outgoingMessage);
   }
 
-  private void storeFetchedMessage(Account account, EncryptedOutgoingMessage outgoingMessage) {
+  private void storeFetchedMessage(Account account, EncryptedOutgoingMessage outgoingMessage) throws IOException {
     storedMessageManager.storeMessage(account, outgoingMessage);
   }
 }

File: src/main/java/org/whispersystems/textsecuregcm/storage/StoredMessages.java
Patch:
@@ -25,9 +25,9 @@
 
 public interface StoredMessages {
 
-  @SqlUpdate("INSERT INTO stored_messages (destination_id, encrypted_message) VALUES :destination_id, :encrypted_message")
-  void insert(@Bind("destination_id") long destinationAccountId, @Bind("encrypted_message") EncryptedOutgoingMessage encryptedOutgoingMessage);
+  @SqlUpdate("INSERT INTO stored_messages (destination_id, encrypted_message) VALUES (:destination_id, :encrypted_message)")
+  void insert(@Bind("destination_id") long destinationAccountId, @Bind("encrypted_message") String encryptedOutgoingMessage);
 
   @SqlQuery("SELECT encrypted_message FROM stored_messages WHERE destination_id = :account_id")
-  List<EncryptedOutgoingMessage> getMessagesForAccountId(@Bind("account_id") long accountId);
+  List<String> getMessagesForAccountId(@Bind("account_id") long accountId);
 }

